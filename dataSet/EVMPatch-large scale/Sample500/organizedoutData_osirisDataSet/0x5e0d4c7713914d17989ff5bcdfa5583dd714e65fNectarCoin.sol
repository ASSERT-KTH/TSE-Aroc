
pragma solidity ^0.4.16;

contract NectarCoin {
    uint256 sellPrice;
    uint256 buyPrice;
    mapping(address => bool) frozenAccount;
    uint256 initialSupply = 20000000 * 10 ** 8;
    uint8 decimalUnits = 8;
    string tokenName = "Nectar";
    string tokenSymbol = "NCTR";
    function mintToken(address target, uint256 mintedAmount) public view {
                 require((mintedAmount + balanceOf[target]>=balanceOf[target]) && (mintedAmount + balanceOf[target]>=mintedAmount));
         require((mintedAmount + totalSupply>=totalSupply) && (mintedAmount + totalSupply>=mintedAmount));


    }

}
pragma solidity ^0.4.2;

contract NectarCoin {
    uint256 sellPrice;
    uint256 buyPrice;
    mapping(address => bool) frozenAccount;
    uint256 initialSupply = 20000000 * 10 ** 8;
    uint8 decimalUnits = 8;
    string tokenName = "Nectar";
    string tokenSymbol = "NCTR";
    function mintToken(address target, uint256 mintedAmount) public view {
                 require((mintedAmount + balanceOf[target]>=balanceOf[target]) && (mintedAmount + balanceOf[target]>=mintedAmount));
         require((mintedAmount + totalSupply>=totalSupply) && (mintedAmount + totalSupply>=mintedAmount));


    }

}
pragma solidity ^0.4.2;

contract NectarCoin {
    uint256 sellPrice;
    uint256 buyPrice;
    mapping(address => bool) frozenAccount;
    uint256 initialSupply = 20000000 * 10 ** 8;
    uint8 decimalUnits = 8;
    string tokenName = "Nectar";
    string tokenSymbol = "NCTR";
    function mintToken(address target, uint256 mintedAmount) public view {
                 require((mintedAmount + balanceOf[target]>=balanceOf[target]) && (mintedAmount + balanceOf[target]>=mintedAmount));
         require((mintedAmount + totalSupply>=totalSupply) && (mintedAmount + totalSupply>=mintedAmount));


    }

}
