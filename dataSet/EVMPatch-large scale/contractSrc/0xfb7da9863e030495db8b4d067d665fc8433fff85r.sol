pragma solidity ^0.4.15;

contract PccToken {
    function transferFrom(address _from, address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
 ){
 
require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));

}
        return true;
    }

    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function generateTokens(address _reciever, uint256 _amount) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
 ){
 
require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));

}
        return true;
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
 ){
 
require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));

}
        return true;
    }

    function transfer(address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
 ){
 
require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));

}
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
 ){
 
require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));

}
        return true;
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    function transferFrom(address _from, address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

 
require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));

}
        return true;
    }

    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function generateTokens(address _reciever, uint256 _amount) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

 
require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));

}
        return true;
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

 
require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));

}
        return true;
    }

    function transfer(address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

 
require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));

}
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

 
require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));

}
        return true;
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    function transferFrom(address _from, address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function generateTokens(address _reciever, uint256 _amount) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function transfer(address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    function transfer(address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function createTokens() public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function transfer(address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    function transfer(address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function transfer(address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function transfer(address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function transfer(address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public view returns(bool success) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view returns(bool ) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function generateTokens(address _reciever, uint256 _amount) public view returns(bool ) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function transfer(address _to, uint256 _value) public view returns(bool ) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public view returns(bool ) {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        return true;
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        
    }

    function transfer(address _to, uint256 _value) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){

require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        
    }

    function transfer(address _to, uint256 _value) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}
        
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
    if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
      require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}        
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
    if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
      require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}        
    }

    function transfer(address _to, uint256 _value) public view {
    if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
      require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}        
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
    if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
      require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}        
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
    if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}        
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
    if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}        
    }

    function transfer(address _to, uint256 _value) public view {
    if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}        
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
    if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}        
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
    if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}        
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
    if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}        
    }

    function transfer(address _to, uint256 _value) public view {
    if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}        
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
    if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
}        
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
          if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
          }        
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
          if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
          }        
    }

    function transfer(address _to, uint256 _value) public view {
          if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
          }        
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
          if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
          }        
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transfer(address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transfer(address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transfer(address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transfer(address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transfer(address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function createTokens() public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transfer(address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transfer(address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transfer(address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }        
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function transfer(address _to, uint256 _value) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function transfer(address _to, uint256 _value) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function transfer(address _to, uint256 _value) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function transfer(address _to, uint256 _value) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function transfer(address _to, uint256 _value) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
        uint multiplier = 10 ** 10;
            if(safeDiv(msg.value * 100000000, oneTokenInWei)!=0 && 10 **  10!=0){
          require((safeDiv(msg.value * 100000000, oneTokenInWei) * 10 **  10/safeDiv(msg.value * 100000000, oneTokenInWei)==10 **  10) && (safeDiv(msg.value * 100000000, oneTokenInWei) * 10 **  10/10 **  10==safeDiv(msg.value * 100000000, oneTokenInWei)));
            }
        uint256 tokens = safeDiv(msg.value * 100000000, oneTokenInWei) * multiplier;
        uint256 checkedSupply = safeAdd(totalSupply, tokens);
        if (currentPhase == Phase.PreICO && checkedSupply <= tokenCreationCapPreICO) {
            addTokens(tokens);
        } else         if (currentPhase == Phase.ICO && checkedSupply <= tokenCreationCap) {
            addTokens(tokens);
        } else {
            revert();
        }


    }

    function generateTokens(address _reciever, uint256 _amount) public view {
        require(_reciever != address(0));        if( _reciever!=address(0)){
          require((_amount + balances[_reciever]>=balances[_reciever]) && (_amount + balances[_reciever]>=_amount));
        }
        balances[_reciever] += _amount;
        totalSupply = safeAdd(totalSupply, _amount);
        CreatePCC(_reciever, _amount);
    }

    function transfer(address _to, uint256 _value) public view {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            
        } else {
            return false;
        }
        if( balances[msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            
        } else {
            return false;
        }
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
        uint multiplier = 10 ** 10;
        uint256 tokens = safeDiv(msg.value * 100000000, oneTokenInWei) * multiplier;
        uint256 checkedSupply = safeAdd(totalSupply, tokens);
        if (currentPhase == Phase.PreICO && checkedSupply <= tokenCreationCapPreICO) {
            addTokens(tokens);
        } else         if (currentPhase == Phase.ICO && checkedSupply <= tokenCreationCap) {
            addTokens(tokens);
        } else {
            revert();
        }


            if(safeDiv(msg.value * 100000000, oneTokenInWei)!=0 && 10 **  10!=0){
          require((safeDiv(msg.value * 100000000, oneTokenInWei) * 10 **  10/safeDiv(msg.value * 100000000, oneTokenInWei)==10 **  10) && (safeDiv(msg.value * 100000000, oneTokenInWei) * 10 **  10/10 **  10==safeDiv(msg.value * 100000000, oneTokenInWei)));
            }
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
        require(_reciever != address(0));
        balances[_reciever] += _amount;
        totalSupply = safeAdd(totalSupply, _amount);
        CreatePCC(_reciever, _amount);        if( _reciever!=address(0)){
          require((_amount + balances[_reciever]>=balances[_reciever]) && (_amount + balances[_reciever]>=_amount));
        }
    }

    function transfer(address _to, uint256 _value) public view {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            
        } else {
            return false;
        }
        if( balances[msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            
        } else {
            return false;
        }
        if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    function createTokens() public view {
        
            if(safeDiv(msg.value * 100000000, oneTokenInWei)!=0 && 10 **  10!=0){
          require((safeDiv(msg.value * 100000000, oneTokenInWei) * 10 **  10/safeDiv(msg.value * 100000000, oneTokenInWei)==10 **  10) && (safeDiv(msg.value * 100000000, oneTokenInWei) * 10 **  10/10 **  10==safeDiv(msg.value * 100000000, oneTokenInWei)));
            }
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
                if( _reciever!=address(0)){
          require((_amount + balances[_reciever]>=balances[_reciever]) && (_amount + balances[_reciever]>=_amount));
        }
    }

    function transfer(address _to, uint256 _value) public view {
                if( balances[msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    string name = "PCC Token";
    string symbol = "PCC";
    uint256 decimals = 18;
    uint256 tokenCreationCap = 1000000000 * 10 ** decimals;
    uint256 tokenCreationCapPreICO = 1000000 * 10 ** decimals;
    uint256 oneTokenInWei = 200000000000000;
    uint totalEthRecieved;
    Phase currentPhase = Phase.PreICO;
    enum Phase{PreICO, ICO}
    function createTokens() public view {
        
            if(safeDiv(msg.value * 100000000, oneTokenInWei)!=0 && 10 **  10!=0){
          require((safeDiv(msg.value * 100000000, oneTokenInWei) * 10 **  10/safeDiv(msg.value * 100000000, oneTokenInWei)==10 **  10) && (safeDiv(msg.value * 100000000, oneTokenInWei) * 10 **  10/10 **  10==safeDiv(msg.value * 100000000, oneTokenInWei)));
            }
    }

    function generateTokens(address _reciever, uint256 _amount) public view {
                if( _reciever!=address(0)){
          require((_amount + balances[_reciever]>=balances[_reciever]) && (_amount + balances[_reciever]>=_amount));
        }
    }

    function transfer(address _to, uint256 _value) public view {
                if( balances[msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public view {
                if( balances[_from] >= _value && allowed[_from][msg.sender] >=  _value && _value >  0){
          require((_value + balances[_to]>=balances[_to]) && (_value + balances[_to]>=_value));
        }
    }

}
pragma solidity ^0.4.15;

contract PccToken {
    enum Phase{PreICO, ICO}
    function createTokens() public {
        
    }

    function generateTokens(address _reciever, uint256 _amount) public {
        
    }

    function transfer(address _to, uint256 _value) public {
        
    }

    function transferFrom(address _from, address _to, uint256 _value) public {
        
    }

}
