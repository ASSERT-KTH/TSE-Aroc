Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xf31619a15518dce0613a514e6672d1f84f6e7fe7.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "Utils"
   Source: "contract Utils {\r\n    /**\r\n        constructor\r\n    */\r\n    function Utils() {\r\n    }\r\n\r\n    // verifies that an amount is greater than zero\r\n    modifier greaterThanZero(uint256 _amount) {\r\n        require(_amount > 0);\r\n        _;\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != 0x0);\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    // Overflow protected math functions\r\n\r\n    /**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n}"
  FunctionDefinition "Utils" - public
     Source: "function Utils() {\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Gas costs: 0
       Source: "{\r\n    }"
  ModifierDefinition "greaterThanZero"
     Source: "modifier greaterThanZero(uint256 _amount) {\r\n        require(_amount > 0);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _amount)"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        require(_amount > 0);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 105
         Source: "require(_amount > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_amount > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "_amount > 0"
            Identifier _amount
               Type: uint256
               Source: "_amount"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "validAddress"
     Source: "modifier validAddress(address _address) {\r\n        require(_address != 0x0);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        require(_address != 0x0);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 176
         Source: "require(_address != 0x0)"
        FunctionCall
           Type: tuple()
           Source: "require(_address != 0x0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_address != 0x0"
            Identifier _address
               Type: address
               Source: "_address"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      PlaceholderStatement
         Gas costs: 8
         Source: "_"
  ModifierDefinition "notThis"
     Source: "modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        require(_address != address(this));\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 147
         Source: "require(_address != address(this))"
        FunctionCall
           Type: tuple()
           Source: "require(_address != address(this))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_address != address(this)"
            Identifier _address
               Type: address
               Source: "_address"
            FunctionCall
               Type: address
               Source: "address(this)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Identifier this
                 Type: contract Utils
                 Source: "this"
      PlaceholderStatement
         Gas costs: 2
         Source: "_"
  FunctionDefinition "safeAdd"
     Source: "function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _x, uint256 _y)"
      VariableDeclaration "_x"
         Type: uint256
         Source: "uint256 _x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_y"
         Type: uint256
         Source: "uint256 _y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 z = _x + _y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "_x + _y"
          Identifier _x
             Type: uint256
             Source: "_x"
          Identifier _y
             Type: uint256
             Source: "_y"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(z >= _x)"
        FunctionCall
           Type: tuple()
           Source: "assert(z >= _x)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "z >= _x"
            Identifier z
               Type: uint256
               Source: "z"
            Identifier _x
               Type: uint256
               Source: "_x"
      Return
         Gas costs: 8
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
  FunctionDefinition "safeSub"
     Source: "function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _x, uint256 _y)"
      VariableDeclaration "_x"
         Type: uint256
         Source: "uint256 _x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_y"
         Type: uint256
         Source: "uint256 _y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(_x >= _y)"
        FunctionCall
           Type: tuple()
           Source: "assert(_x >= _y)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "_x >= _y"
            Identifier _x
               Type: uint256
               Source: "_x"
            Identifier _y
               Type: uint256
               Source: "_y"
      Return
         Gas costs: 14
         Source: "return _x - _y"
        BinaryOperation using operator -
           Type: uint256
           Source: "_x - _y"
          Identifier _x
             Type: uint256
             Source: "_x"
          Identifier _y
             Type: uint256
             Source: "_y"
  FunctionDefinition "safeMul"
     Source: "function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _x, uint256 _y)"
      VariableDeclaration "_x"
         Type: uint256
         Source: "uint256 _x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_y"
         Type: uint256
         Source: "uint256 _y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint256 z = _x * _y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "_x * _y"
          Identifier _x
             Type: uint256
             Source: "_x"
          Identifier _y
             Type: uint256
             Source: "_y"
      ExpressionStatement
         Gas costs: 88
         Source: "assert(_x == 0 || z / _x == _y)"
        FunctionCall
           Type: tuple()
           Source: "assert(_x == 0 || z / _x == _y)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "_x == 0 || z / _x == _y"
            BinaryOperation using operator ==
               Type: bool
               Source: "_x == 0"
              Identifier _x
                 Type: uint256
                 Source: "_x"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "z / _x == _y"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "z / _x"
                Identifier z
                   Type: uint256
                   Source: "z"
                Identifier _x
                   Type: uint256
                   Source: "_x"
              Identifier _y
                 Type: uint256
                 Source: "_y"
      Return
         Gas costs: 8
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
ContractDefinition "IOwned"
   Source: "contract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public constant returns (address owner) { owner; }\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}"
  FunctionDefinition "owner" - public - const
     Source: "function owner() public constant returns (address owner) { owner; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{ owner; }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner"
        Identifier owner
           Type: address
           Source: "owner"
  FunctionDefinition "transferOwnership" - public
     Gas costs: 0
     Source: "function transferOwnership(address _newOwner) public;"
    ParameterList
       Source: "(address _newOwner)"
      VariableDeclaration "_newOwner"
         Type: address
         Source: "address _newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: ""
  FunctionDefinition "acceptOwnership" - public
     Gas costs: 0
     Source: "function acceptOwnership() public;"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
ContractDefinition "Owned"
   Source: "contract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the contract ownership\r\n        the new owner still needs to accept the transfer\r\n        can only be called by the contract owner\r\n\r\n        @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n        @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "IOwned"
    UserDefinedTypeName "IOwned"
       Source: "IOwned"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "newOwner"
     Type: address
     Gas costs: [???]
     Source: "address public newOwner"
    ElementaryTypeName address
       Source: "address"
  EventDefinition "OwnerUpdate"
     Gas costs: 0
     Source: "event OwnerUpdate(address _prevOwner, address _newOwner);"
    ParameterList
       Source: "(address _prevOwner, address _newOwner)"
      VariableDeclaration "_prevOwner"
         Type: address
         Source: "address _prevOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_newOwner"
         Type: address
         Source: "address _newOwner"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "Owned" - public
     Source: "function Owned() {\r\n        owner = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "ownerOnly"
     Source: "modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 3312
         Source: "assert(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "assert(msg.sender == owner)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 10
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _newOwner)"
      VariableDeclaration "_newOwner"
         Type: address
         Source: "address _newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerOnly"
       Gas costs: 0
       Source: "ownerOnly"
      Identifier ownerOnly
         Type: modifier ()
         Source: "ownerOnly"
    Block
       Source: "{\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }"
      ExpressionStatement
         Gas costs: 286
         Source: "require(_newOwner != owner)"
        FunctionCall
           Type: tuple()
           Source: "require(_newOwner != owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_newOwner != owner"
            Identifier _newOwner
               Type: address
               Source: "_newOwner"
            Identifier owner
               Type: address
               Source: "owner"
      ExpressionStatement
         Gas costs: 20267
         Source: "newOwner = _newOwner"
        Assignment using operator =
           Type: address
           Source: "newOwner = _newOwner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
          Identifier _newOwner
             Type: address
             Source: "_newOwner"
  FunctionDefinition "acceptOwnership" - public
     Source: "function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }"
      ExpressionStatement
         Gas costs: 282
         Source: "require(msg.sender == newOwner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == newOwner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == newOwner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier newOwner
               Type: address
               Source: "newOwner"
      ExpressionStatement
         Gas costs: [???]
         Source: "OwnerUpdate(owner, newOwner)"
        FunctionCall
           Type: tuple()
           Source: "OwnerUpdate(owner, newOwner)"
          Identifier OwnerUpdate
             Type: function (address,address)
             Source: "OwnerUpdate"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
      ExpressionStatement
         Gas costs: 20503
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
      ExpressionStatement
         Gas costs: 20267
         Source: "newOwner = 0x0"
        Assignment using operator =
           Type: address
           Source: "newOwner = 0x0"
          Identifier newOwner
             Type: address
             Source: "newOwner"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
ContractDefinition "Managed"
   Source: "contract Managed {\r\n    address public manager;\r\n    address public newManager;\r\n\r\n    event ManagerUpdate(address _prevManager, address _newManager);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function Managed() {\r\n        manager = msg.sender;\r\n    }\r\n\r\n    // allows execution by the manager only\r\n    modifier managerOnly {\r\n        assert(msg.sender == manager);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the contract management\r\n        the new manager still needs to accept the transfer\r\n        can only be called by the contract manager\r\n\r\n        @param _newManager    new contract manager\r\n    */\r\n    function transferManagement(address _newManager) public managerOnly {\r\n        require(_newManager != manager);\r\n        newManager = _newManager;\r\n    }\r\n\r\n    /**\r\n        @dev used by a new manager to accept a management transfer\r\n    */\r\n    function acceptManagement() public {\r\n        require(msg.sender == newManager);\r\n        ManagerUpdate(manager, newManager);\r\n        manager = newManager;\r\n        newManager = 0x0;\r\n    }\r\n}"
  VariableDeclaration "manager"
     Type: address
     Gas costs: [???]
     Source: "address public manager"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "newManager"
     Type: address
     Gas costs: [???]
     Source: "address public newManager"
    ElementaryTypeName address
       Source: "address"
  EventDefinition "ManagerUpdate"
     Gas costs: 0
     Source: "event ManagerUpdate(address _prevManager, address _newManager);"
    ParameterList
       Source: "(address _prevManager, address _newManager)"
      VariableDeclaration "_prevManager"
         Type: address
         Source: "address _prevManager"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_newManager"
         Type: address
         Source: "address _newManager"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "Managed" - public
     Source: "function Managed() {\r\n        manager = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        manager = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "manager = msg.sender"
        Assignment using operator =
           Type: address
           Source: "manager = msg.sender"
          Identifier manager
             Type: address
             Source: "manager"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "managerOnly"
     Source: "modifier managerOnly {\r\n        assert(msg.sender == manager);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        assert(msg.sender == manager);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 828
         Source: "assert(msg.sender == manager)"
        FunctionCall
           Type: tuple()
           Source: "assert(msg.sender == manager)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == manager"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier manager
               Type: address
               Source: "manager"
      PlaceholderStatement
         Gas costs: 2
         Source: "_"
  FunctionDefinition "transferManagement" - public
     Source: "function transferManagement(address _newManager) public managerOnly {\r\n        require(_newManager != manager);\r\n        newManager = _newManager;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _newManager)"
      VariableDeclaration "_newManager"
         Type: address
         Source: "address _newManager"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "managerOnly"
       Gas costs: 0
       Source: "managerOnly"
      Identifier managerOnly
         Type: modifier ()
         Source: "managerOnly"
    Block
       Source: "{\r\n        require(_newManager != manager);\r\n        newManager = _newManager;\r\n    }"
      ExpressionStatement
         Gas costs: 286
         Source: "require(_newManager != manager)"
        FunctionCall
           Type: tuple()
           Source: "require(_newManager != manager)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_newManager != manager"
            Identifier _newManager
               Type: address
               Source: "_newManager"
            Identifier manager
               Type: address
               Source: "manager"
      ExpressionStatement
         Gas costs: 20267
         Source: "newManager = _newManager"
        Assignment using operator =
           Type: address
           Source: "newManager = _newManager"
          Identifier newManager
             Type: address
             Source: "newManager"
          Identifier _newManager
             Type: address
             Source: "_newManager"
  FunctionDefinition "acceptManagement" - public
     Source: "function acceptManagement() public {\r\n        require(msg.sender == newManager);\r\n        ManagerUpdate(manager, newManager);\r\n        manager = newManager;\r\n        newManager = 0x0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(msg.sender == newManager);\r\n        ManagerUpdate(manager, newManager);\r\n        manager = newManager;\r\n        newManager = 0x0;\r\n    }"
      ExpressionStatement
         Gas costs: 282
         Source: "require(msg.sender == newManager)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == newManager)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == newManager"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier newManager
               Type: address
               Source: "newManager"
      ExpressionStatement
         Gas costs: [???]
         Source: "ManagerUpdate(manager, newManager)"
        FunctionCall
           Type: tuple()
           Source: "ManagerUpdate(manager, newManager)"
          Identifier ManagerUpdate
             Type: function (address,address)
             Source: "ManagerUpdate"
          Identifier manager
             Type: address
             Source: "manager"
          Identifier newManager
             Type: address
             Source: "newManager"
      ExpressionStatement
         Gas costs: 20503
         Source: "manager = newManager"
        Assignment using operator =
           Type: address
           Source: "manager = newManager"
          Identifier manager
             Type: address
             Source: "manager"
          Identifier newManager
             Type: address
             Source: "newManager"
      ExpressionStatement
         Gas costs: 20267
         Source: "newManager = 0x0"
        Assignment using operator =
           Type: address
           Source: "newManager = 0x0"
          Identifier newManager
             Type: address
             Source: "newManager"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
ContractDefinition "ITokenHolder"
   Gas costs: 0
   Source: "contract ITokenHolder is IOwned {\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n}"
  InheritanceSpecifier
     Source: "IOwned"
    UserDefinedTypeName "IOwned"
       Source: "IOwned"
  FunctionDefinition "withdrawTokens" - public
     Source: "function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;"
    ParameterList
       Source: "(IERC20Token _token, address _to, uint256 _amount)"
      VariableDeclaration "_token"
         Type: contract IERC20Token
         Source: "IERC20Token _token"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
ContractDefinition "TokenHolder"
   Source: "contract TokenHolder is ITokenHolder, Owned, Utils {\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function TokenHolder() {\r\n    }\r\n\r\n    /**\r\n        @dev withdraws tokens held by the contract and sends them to an account\r\n        can only be called by the owner\r\n\r\n        @param _token   ERC20 token contract address\r\n        @param _to      account to receive the new amount\r\n        @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        assert(_token.transfer(_to, _amount));\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ITokenHolder"
    UserDefinedTypeName "ITokenHolder"
       Source: "ITokenHolder"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Owned"
    UserDefinedTypeName "Owned"
       Source: "Owned"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Utils"
    UserDefinedTypeName "Utils"
       Source: "Utils"
  FunctionDefinition "TokenHolder" - public
     Source: "function TokenHolder() {\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Gas costs: 0
       Source: "{\r\n    }"
  FunctionDefinition "withdrawTokens" - public
     Source: "function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        assert(_token.transfer(_to, _amount));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _token, address _to, uint256 _amount)"
      VariableDeclaration "_token"
         Type: contract IERC20Token
         Source: "IERC20Token _token"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerOnly"
       Gas costs: 0
       Source: "ownerOnly"
      Identifier ownerOnly
         Type: modifier ()
         Source: "ownerOnly"
    ModifierInvocation "validAddress"
       Gas costs: 3
       Source: "validAddress(_token)"
      Identifier validAddress
         Type: modifier (address)
         Source: "validAddress"
      Identifier _token
         Type: contract IERC20Token
         Source: "_token"
    ModifierInvocation "validAddress"
       Gas costs: 3
       Source: "validAddress(_to)"
      Identifier validAddress
         Type: modifier (address)
         Source: "validAddress"
      Identifier _to
         Type: address
         Source: "_to"
    ModifierInvocation "notThis"
       Gas costs: 3
       Source: "notThis(_to)"
      Identifier notThis
         Type: modifier (address)
         Source: "notThis"
      Identifier _to
         Type: address
         Source: "_to"
    Block
       Source: "{\r\n        assert(_token.transfer(_to, _amount));\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(_token.transfer(_to, _amount))"
        FunctionCall
           Type: tuple()
           Source: "assert(_token.transfer(_to, _amount))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          FunctionCall
             Type: bool
             Source: "_token.transfer(_to, _amount)"
            MemberAccess to member transfer
               Type: function (address,uint256) external returns (bool)
               Source: "_token.transfer"
              Identifier _token
                 Type: contract IERC20Token
                 Source: "_token"
            Identifier _to
               Type: address
               Source: "_to"
            Identifier _amount
               Type: uint256
               Source: "_amount"
ContractDefinition "SmartTokenController"
   Source: "contract SmartTokenController is TokenHolder {\r\n    ISmartToken public token;   // smart token\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function SmartTokenController(ISmartToken _token)\r\n        validAddress(_token)\r\n    {\r\n        token = _token;\r\n    }\r\n\r\n    // ensures that the controller is the token's owner\r\n    modifier active() {\r\n        assert(token.owner() == address(this));\r\n        _;\r\n    }\r\n\r\n    // ensures that the controller is not the token's owner\r\n    modifier inactive() {\r\n        assert(token.owner() != address(this));\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the token ownership\r\n        the new owner still need to accept the transfer\r\n        can only be called by the contract owner\r\n\r\n        @param _newOwner    new token owner\r\n    */\r\n    function transferTokenOwnership(address _newOwner) public ownerOnly {\r\n        token.transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n        @dev used by a new owner to accept a token ownership transfer\r\n        can only be called by the contract owner\r\n    */\r\n    function acceptTokenOwnership() public ownerOnly {\r\n        token.acceptOwnership();\r\n    }\r\n\r\n    /**\r\n        @dev disables/enables token transfers\r\n        can only be called by the contract owner\r\n\r\n        @param _disable    true to disable transfers, false to enable them\r\n    */\r\n    function disableTokenTransfers(bool _disable) public ownerOnly {\r\n        token.disableTransfers(_disable);\r\n    }\r\n\r\n    /**\r\n        @dev withdraws tokens held by the token and sends them to an account\r\n        can only be called by the owner\r\n\r\n        @param _token   ERC20 token contract address\r\n        @param _to      account to receive the new amount\r\n        @param _amount  amount to withdraw\r\n    */\r\n    function withdrawFromToken(IERC20Token _token, address _to, uint256 _amount) public ownerOnly {\r\n        token.withdrawTokens(_token, _to, _amount);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "TokenHolder"
    UserDefinedTypeName "TokenHolder"
       Source: "TokenHolder"
  VariableDeclaration "token"
     Type: contract ISmartToken
     Gas costs: [???]
     Source: "ISmartToken public token"
    UserDefinedTypeName "ISmartToken"
       Source: "ISmartToken"
  FunctionDefinition "SmartTokenController" - public
     Source: "function SmartTokenController(ISmartToken _token)\r\n        validAddress(_token)\r\n    {\r\n        token = _token;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ISmartToken _token)"
      VariableDeclaration "_token"
         Type: contract ISmartToken
         Source: "ISmartToken _token"
        UserDefinedTypeName "ISmartToken"
           Source: "ISmartToken"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "validAddress"
       Gas costs: 0
       Source: "validAddress(_token)"
      Identifier validAddress
         Type: modifier (address)
         Source: "validAddress"
      Identifier _token
         Type: contract ISmartToken
         Source: "_token"
    Block
       Source: "{\r\n        token = _token;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "token = _token"
        Assignment using operator =
           Type: contract ISmartToken
           Source: "token = _token"
          Identifier token
             Type: contract ISmartToken
             Source: "token"
          Identifier _token
             Type: contract ISmartToken
             Source: "_token"
  ModifierDefinition "active"
     Source: "modifier active() {\r\n        assert(token.owner() == address(this));\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        assert(token.owner() == address(this));\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(token.owner() == address(this))"
        FunctionCall
           Type: tuple()
           Source: "assert(token.owner() == address(this))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "token.owner() == address(this)"
            FunctionCall
               Type: address
               Source: "token.owner()"
              MemberAccess to member owner
                 Type: function () view external returns (address)
                 Source: "token.owner"
                Identifier token
                   Type: contract ISmartToken
                   Source: "token"
            FunctionCall
               Type: address
               Source: "address(this)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Identifier this
                 Type: contract SmartTokenController
                 Source: "this"
      PlaceholderStatement
         Gas costs: 4
         Source: "_"
  ModifierDefinition "inactive"
     Source: "modifier inactive() {\r\n        assert(token.owner() != address(this));\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        assert(token.owner() != address(this));\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(token.owner() != address(this))"
        FunctionCall
           Type: tuple()
           Source: "assert(token.owner() != address(this))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator !=
             Type: bool
             Source: "token.owner() != address(this)"
            FunctionCall
               Type: address
               Source: "token.owner()"
              MemberAccess to member owner
                 Type: function () view external returns (address)
                 Source: "token.owner"
                Identifier token
                   Type: contract ISmartToken
                   Source: "token"
            FunctionCall
               Type: address
               Source: "address(this)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Identifier this
                 Type: contract SmartTokenController
                 Source: "this"
      PlaceholderStatement
         Gas costs: 2
         Source: "_"
  FunctionDefinition "transferTokenOwnership" - public
     Source: "function transferTokenOwnership(address _newOwner) public ownerOnly {\r\n        token.transferOwnership(_newOwner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _newOwner)"
      VariableDeclaration "_newOwner"
         Type: address
         Source: "address _newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerOnly"
       Gas costs: 0
       Source: "ownerOnly"
      Identifier ownerOnly
         Type: modifier ()
         Source: "ownerOnly"
    Block
       Source: "{\r\n        token.transferOwnership(_newOwner);\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.transferOwnership(_newOwner)"
        FunctionCall
           Type: tuple()
           Source: "token.transferOwnership(_newOwner)"
          MemberAccess to member transferOwnership
             Type: function (address) external
             Source: "token.transferOwnership"
            Identifier token
               Type: contract ISmartToken
               Source: "token"
          Identifier _newOwner
             Type: address
             Source: "_newOwner"
  FunctionDefinition "acceptTokenOwnership" - public
     Source: "function acceptTokenOwnership() public ownerOnly {\r\n        token.acceptOwnership();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerOnly"
       Gas costs: 0
       Source: "ownerOnly"
      Identifier ownerOnly
         Type: modifier ()
         Source: "ownerOnly"
    Block
       Source: "{\r\n        token.acceptOwnership();\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.acceptOwnership()"
        FunctionCall
           Type: tuple()
           Source: "token.acceptOwnership()"
          MemberAccess to member acceptOwnership
             Type: function () external
             Source: "token.acceptOwnership"
            Identifier token
               Type: contract ISmartToken
               Source: "token"
  FunctionDefinition "disableTokenTransfers" - public
     Source: "function disableTokenTransfers(bool _disable) public ownerOnly {\r\n        token.disableTransfers(_disable);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bool _disable)"
      VariableDeclaration "_disable"
         Type: bool
         Source: "bool _disable"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerOnly"
       Gas costs: 0
       Source: "ownerOnly"
      Identifier ownerOnly
         Type: modifier ()
         Source: "ownerOnly"
    Block
       Source: "{\r\n        token.disableTransfers(_disable);\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.disableTransfers(_disable)"
        FunctionCall
           Type: tuple()
           Source: "token.disableTransfers(_disable)"
          MemberAccess to member disableTransfers
             Type: function (bool) external
             Source: "token.disableTransfers"
            Identifier token
               Type: contract ISmartToken
               Source: "token"
          Identifier _disable
             Type: bool
             Source: "_disable"
  FunctionDefinition "withdrawFromToken" - public
     Source: "function withdrawFromToken(IERC20Token _token, address _to, uint256 _amount) public ownerOnly {\r\n        token.withdrawTokens(_token, _to, _amount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _token, address _to, uint256 _amount)"
      VariableDeclaration "_token"
         Type: contract IERC20Token
         Source: "IERC20Token _token"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerOnly"
       Gas costs: 0
       Source: "ownerOnly"
      Identifier ownerOnly
         Type: modifier ()
         Source: "ownerOnly"
    Block
       Source: "{\r\n        token.withdrawTokens(_token, _to, _amount);\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.withdrawTokens(_token, _to, _amount)"
        FunctionCall
           Type: tuple()
           Source: "token.withdrawTokens(_token, _to, _amount)"
          MemberAccess to member withdrawTokens
             Type: function (contract IERC20Token,address,uint256) external
             Source: "token.withdrawTokens"
            Identifier token
               Type: contract ISmartToken
               Source: "token"
          Identifier _token
             Type: contract IERC20Token
             Source: "_token"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
ContractDefinition "IERC20Token"
   Source: "contract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public constant returns (string name) { name; }\r\n    function symbol() public constant returns (string symbol) { symbol; }\r\n    function decimals() public constant returns (uint8 decimals) { decimals; }\r\n    function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}"
  FunctionDefinition "name" - public - const
     Source: "function name() public constant returns (string name) { name; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(string name)"
      VariableDeclaration "name"
         Type: string memory
         Source: "string name"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{ name; }"
      ExpressionStatement
         Gas costs: 0
         Source: "name"
        Identifier name
           Type: string memory
           Source: "name"
  FunctionDefinition "symbol" - public - const
     Source: "function symbol() public constant returns (string symbol) { symbol; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(string symbol)"
      VariableDeclaration "symbol"
         Type: string memory
         Source: "string symbol"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{ symbol; }"
      ExpressionStatement
         Gas costs: 0
         Source: "symbol"
        Identifier symbol
           Type: string memory
           Source: "symbol"
  FunctionDefinition "decimals" - public - const
     Source: "function decimals() public constant returns (uint8 decimals) { decimals; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint8 decimals)"
      VariableDeclaration "decimals"
         Type: uint8
         Source: "uint8 decimals"
        ElementaryTypeName uint8
           Source: "uint8"
    Block
       Source: "{ decimals; }"
      ExpressionStatement
         Gas costs: 0
         Source: "decimals"
        Identifier decimals
           Type: uint8
           Source: "decimals"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint256 totalSupply)"
      VariableDeclaration "totalSupply"
         Type: uint256
         Source: "uint256 totalSupply"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{ totalSupply; }"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply"
        Identifier totalSupply
           Type: uint256
           Source: "totalSupply"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{ _owner; balance; }"
      ExpressionStatement
         Gas costs: 0
         Source: "_owner"
        Identifier _owner
           Type: address
           Source: "_owner"
      ExpressionStatement
         Gas costs: 0
         Source: "balance"
        Identifier balance
           Type: uint256
           Source: "balance"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{ _owner; _spender; remaining; }"
      ExpressionStatement
         Gas costs: 0
         Source: "_owner"
        Identifier _owner
           Type: address
           Source: "_owner"
      ExpressionStatement
         Gas costs: 0
         Source: "_spender"
        Identifier _spender
           Type: address
           Source: "_spender"
      ExpressionStatement
         Gas costs: 0
         Source: "remaining"
        Identifier remaining
           Type: uint256
           Source: "remaining"
  FunctionDefinition "transfer" - public
     Gas costs: 0
     Source: "function transfer(address _to, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Gas costs: 0
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Gas costs: 0
     Source: "function approve(address _spender, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
ContractDefinition "IEtherToken"
   Gas costs: 0
   Source: "contract IEtherToken is ITokenHolder, IERC20Token {\r\n    function deposit() public payable;\r\n    function withdraw(uint256 _amount) public;\r\n    function withdrawTo(address _to, uint256 _amount);\r\n}"
  InheritanceSpecifier
     Source: "ITokenHolder"
    UserDefinedTypeName "ITokenHolder"
       Source: "ITokenHolder"
  InheritanceSpecifier
     Source: "IERC20Token"
    UserDefinedTypeName "IERC20Token"
       Source: "IERC20Token"
  FunctionDefinition "deposit" - public
     Source: "function deposit() public payable;"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
  FunctionDefinition "withdraw" - public
     Source: "function withdraw(uint256 _amount) public;"
    ParameterList
       Source: "(uint256 _amount)"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
  FunctionDefinition "withdrawTo" - public
     Source: "function withdrawTo(address _to, uint256 _amount);"
    ParameterList
       Source: "(address _to, uint256 _amount)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
ContractDefinition "ISmartToken"
   Gas costs: 0
   Source: "contract ISmartToken is ITokenHolder, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}"
  InheritanceSpecifier
     Source: "ITokenHolder"
    UserDefinedTypeName "ITokenHolder"
       Source: "ITokenHolder"
  InheritanceSpecifier
     Source: "IERC20Token"
    UserDefinedTypeName "IERC20Token"
       Source: "IERC20Token"
  FunctionDefinition "disableTransfers" - public
     Source: "function disableTransfers(bool _disable) public;"
    ParameterList
       Source: "(bool _disable)"
      VariableDeclaration "_disable"
         Type: bool
         Source: "bool _disable"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Source: ""
  FunctionDefinition "issue" - public
     Source: "function issue(address _to, uint256 _amount) public;"
    ParameterList
       Source: "(address _to, uint256 _amount)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
  FunctionDefinition "destroy" - public
     Source: "function destroy(address _from, uint256 _amount) public;"
    ParameterList
       Source: "(address _from, uint256 _amount)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
ContractDefinition "IBancorFormula"
   Gas costs: 0
   Source: "contract IBancorFormula {\r\n    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _depositAmount) public constant returns (uint256);\r\n    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _sellAmount) public constant returns (uint256);\r\n}"
  FunctionDefinition "calculatePurchaseReturn" - public - const
     Source: "function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _depositAmount) public constant returns (uint256);"
    ParameterList
       Source: "(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _depositAmount)"
      VariableDeclaration "_supply"
         Type: uint256
         Source: "uint256 _supply"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_reserveBalance"
         Type: uint256
         Source: "uint256 _reserveBalance"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_reserveRatio"
         Type: uint32
         Source: "uint32 _reserveRatio"
        ElementaryTypeName uint32
           Source: "uint32"
      VariableDeclaration "_depositAmount"
         Type: uint256
         Source: "uint256 _depositAmount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "calculateSaleReturn" - public - const
     Source: "function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _sellAmount) public constant returns (uint256);"
    ParameterList
       Source: "(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _sellAmount)"
      VariableDeclaration "_supply"
         Type: uint256
         Source: "uint256 _supply"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_reserveBalance"
         Type: uint256
         Source: "uint256 _reserveBalance"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_reserveRatio"
         Type: uint32
         Source: "uint32 _reserveRatio"
        ElementaryTypeName uint32
           Source: "uint32"
      VariableDeclaration "_sellAmount"
         Type: uint256
         Source: "uint256 _sellAmount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "ITokenChanger"
   Gas costs: 0
   Source: "contract ITokenChanger {\r\n    function changeableTokenCount() public constant returns (uint16 count);\r\n    function changeableToken(uint16 _tokenIndex) public constant returns (address tokenAddress);\r\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public constant returns (uint256 amount);\r\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 amount);\r\n}"
  FunctionDefinition "changeableTokenCount" - public - const
     Source: "function changeableTokenCount() public constant returns (uint16 count);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint16 count)"
      VariableDeclaration "count"
         Type: uint16
         Source: "uint16 count"
        ElementaryTypeName uint16
           Source: "uint16"
  FunctionDefinition "changeableToken" - public - const
     Source: "function changeableToken(uint16 _tokenIndex) public constant returns (address tokenAddress);"
    ParameterList
       Source: "(uint16 _tokenIndex)"
      VariableDeclaration "_tokenIndex"
         Type: uint16
         Source: "uint16 _tokenIndex"
        ElementaryTypeName uint16
           Source: "uint16"
    ParameterList
       Source: "(address tokenAddress)"
      VariableDeclaration "tokenAddress"
         Type: address
         Source: "address tokenAddress"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "getReturn" - public - const
     Source: "function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public constant returns (uint256 amount);"
    ParameterList
       Source: "(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount)"
      VariableDeclaration "_fromToken"
         Type: contract IERC20Token
         Source: "IERC20Token _fromToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_toToken"
         Type: contract IERC20Token
         Source: "IERC20Token _toToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "change" - public
     Source: "function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 amount);"
    ParameterList
       Source: "(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn)"
      VariableDeclaration "_fromToken"
         Type: contract IERC20Token
         Source: "IERC20Token _fromToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_toToken"
         Type: contract IERC20Token
         Source: "IERC20Token _toToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_minReturn"
         Type: uint256
         Source: "uint256 _minReturn"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "BancorChanger"
   Source: "contract BancorChanger is ITokenChanger, SmartTokenController, Managed {\r\n    uint32 private constant MAX_CRR = 1000000;\r\n    uint32 private constant MAX_CHANGE_FEE = 1000000;\r\n\r\n    struct Reserve {\r\n        uint256 virtualBalance;         // virtual balance\r\n        uint32 ratio;                   // constant reserve ratio (CRR), represented in ppm, 1-1000000\r\n        bool isVirtualBalanceEnabled;   // true if virtual balance is enabled, false if not\r\n        bool isPurchaseEnabled;         // is purchase of the smart token enabled with the reserve, can be set by the owner\r\n        bool isSet;                     // used to tell if the mapping element is defined\r\n    }\r\n\r\n    string public version = '0.3';\r\n    string public changerType = 'bancor';\r\n\r\n    IBancorFormula public formula;                  // bancor calculation formula contract\r\n    IERC20Token[] public reserveTokens;             // ERC20 standard token addresses\r\n    IERC20Token[] public quickBuyPath;              // change path that's used in order to buy the token with ETH\r\n    mapping (address => Reserve) public reserves;   // reserve token addresses -> reserve data\r\n    uint32 private totalReserveRatio = 0;           // used to efficiently prevent increasing the total reserve ratio above 100%\r\n    uint32 public maxChangeFee = 0;                 // maximum change fee for the lifetime of the contract, represented in ppm, 0...1000000 (0 = no fee, 100 = 0.01%, 1000000 = 100%)\r\n    uint32 public changeFee = 0;                    // current change fee, represented in ppm, 0...maxChangeFee\r\n    bool public changingEnabled = true;             // true if token changing is enabled, false if not\r\n\r\n    // triggered when a change between two tokens occurs (TokenChanger event)\r\n    event Change(address indexed _fromToken, address indexed _toToken, address indexed _trader, uint256 _amount, uint256 _return,\r\n                 uint256 _currentPriceN, uint256 _currentPriceD);\r\n\r\n    /**\r\n        @dev constructor\r\n\r\n        @param  _token          smart token governed by the changer\r\n        @param  _formula        address of a bancor formula contract\r\n        @param  _maxChangeFee   maximum change fee, represented in ppm\r\n        @param  _reserveToken   optional, initial reserve, allows defining the first reserve at deployment time\r\n        @param  _reserveRatio   optional, ratio for the initial reserve\r\n    */\r\n    function BancorChanger(ISmartToken _token, IBancorFormula _formula, uint32 _maxChangeFee, IERC20Token _reserveToken, uint32 _reserveRatio)\r\n        SmartTokenController(_token)\r\n        validAddress(_formula)\r\n        validMaxChangeFee(_maxChangeFee)\r\n    {\r\n        formula = _formula;\r\n        maxChangeFee = _maxChangeFee;\r\n\r\n        if (address(_reserveToken) != 0x0)\r\n            addReserve(_reserveToken, _reserveRatio, false);\r\n    }\r\n\r\n    // validates a reserve token address - verifies that the address belongs to one of the reserve tokens\r\n    modifier validReserve(IERC20Token _address) {\r\n        require(reserves[_address].isSet);\r\n        _;\r\n    }\r\n\r\n    // validates a token address - verifies that the address belongs to one of the changeable tokens\r\n    modifier validToken(IERC20Token _address) {\r\n        require(_address == token || reserves[_address].isSet);\r\n        _;\r\n    }\r\n\r\n    // validates maximum change fee\r\n    modifier validMaxChangeFee(uint32 _changeFee) {\r\n        require(_changeFee >= 0 && _changeFee <= MAX_CHANGE_FEE);\r\n        _;\r\n    }\r\n\r\n    // validates change fee\r\n    modifier validChangeFee(uint32 _changeFee) {\r\n        require(_changeFee >= 0 && _changeFee <= maxChangeFee);\r\n        _;\r\n    }\r\n\r\n    // validates reserve ratio range\r\n    modifier validReserveRatio(uint32 _ratio) {\r\n        require(_ratio > 0 && _ratio <= MAX_CRR);\r\n        _;\r\n    }\r\n\r\n    // validates a change path - verifies that the number of elements is odd and that maximum number of 'hops' is 10\r\n    modifier validChangePath(IERC20Token[] _path) {\r\n        require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1);\r\n        _;\r\n    }\r\n\r\n    // allows execution only when changing isn't disabled\r\n    modifier changingAllowed {\r\n        assert(changingEnabled);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev returns the number of reserve tokens defined\r\n\r\n        @return number of reserve tokens\r\n    */\r\n    function reserveTokenCount() public constant returns (uint16 count) {\r\n        return uint16(reserveTokens.length);\r\n    }\r\n\r\n    /**\r\n        @dev returns the number of changeable tokens supported by the contract\r\n        note that the number of changeable tokens is the number of reserve token, plus 1 (that represents the smart token)\r\n\r\n        @return number of changeable tokens\r\n    */\r\n    function changeableTokenCount() public constant returns (uint16 count) {\r\n        return reserveTokenCount() + 1;\r\n    }\r\n\r\n    /**\r\n        @dev given a changeable token index, returns the changeable token contract address\r\n\r\n        @param _tokenIndex  changeable token index\r\n\r\n        @return number of changeable tokens\r\n    */\r\n    function changeableToken(uint16 _tokenIndex) public constant returns (address tokenAddress) {\r\n        if (_tokenIndex == 0)\r\n            return token;\r\n        return reserveTokens[_tokenIndex - 1];\r\n    }\r\n\r\n    /*\r\n        @dev allows the owner to update the formula contract address\r\n\r\n        @param _formula    address of a bancor formula contract\r\n    */\r\n    function setFormula(IBancorFormula _formula)\r\n        public\r\n        ownerOnly\r\n        validAddress(_formula)\r\n        notThis(_formula)\r\n    {\r\n        formula = _formula;\r\n    }\r\n\r\n    /*\r\n        @dev allows the manager to update the quick buy path\r\n\r\n        @param _path    new quick buy path, see change path format above\r\n    */\r\n    function setQuickBuyPath(IERC20Token[] _path)\r\n        public\r\n        ownerOnly\r\n        validChangePath(_path)\r\n    {\r\n        quickBuyPath = _path;\r\n    }\r\n\r\n    /*\r\n        @dev allows the manager to clear the quick buy path\r\n    */\r\n    function clearQuickBuyPath() public ownerOnly {\r\n        quickBuyPath.length = 0;\r\n    }\r\n\r\n    /**\r\n        @dev returns the length of the quick buy path array\r\n\r\n        @return quick buy path length\r\n    */\r\n    function getQuickBuyPathLength() public constant returns (uint256 length) {\r\n        return quickBuyPath.length;\r\n    }\r\n\r\n    /**\r\n        @dev returns true if ether token exists in the quick buy path, false if not\r\n        note that there should always be one in the quick buy path, if one is set\r\n\r\n        @return true if ether token exists, false if not\r\n    */\r\n    function hasQuickBuyEtherToken() public constant returns (bool) {\r\n        return quickBuyPath.length > 0;\r\n    }\r\n\r\n    /**\r\n        @dev returns the address of the ether token used by the quick buy functionality\r\n        note that it should always be the first element in the quick buy path, if one is set\r\n\r\n        @return ether token address\r\n    */\r\n    function getQuickBuyEtherToken() public constant returns (IEtherToken etherToken) {\r\n        assert(quickBuyPath.length > 0);\r\n        return IEtherToken(quickBuyPath[0]);\r\n    }\r\n\r\n    /**\r\n        @dev disables the entire change functionality\r\n        this is a safety mechanism in case of a emergency\r\n        can only be called by the manager\r\n\r\n        @param _disable true to disable changing, false to re-enable it\r\n    */\r\n    function disableChanging(bool _disable) public managerOnly {\r\n        changingEnabled = !_disable;\r\n    }\r\n\r\n    /**\r\n        @dev updates the current change fee\r\n        can only be called by the manager\r\n\r\n        @param _changeFee new change fee, represented in ppm\r\n    */\r\n    function setChangeFee(uint32 _changeFee)\r\n        public\r\n        managerOnly\r\n        validChangeFee(_changeFee)\r\n    {\r\n        changeFee = _changeFee;\r\n    }\r\n\r\n    /*\r\n        @dev returns the change fee amount for a given return amount\r\n\r\n        @return change fee amount\r\n    */\r\n    function getChangeFeeAmount(uint256 _amount) public constant returns (uint256 feeAmount) {\r\n        return safeMul(_amount, changeFee) / MAX_CHANGE_FEE;\r\n    }\r\n\r\n    /**\r\n        @dev defines a new reserve for the token\r\n        can only be called by the owner while the changer is inactive\r\n\r\n        @param _token                  address of the reserve token\r\n        @param _ratio                  constant reserve ratio, represented in ppm, 1-1000000\r\n        @param _enableVirtualBalance   true to enable virtual balance for the reserve, false to disable it\r\n    */\r\n    function addReserve(IERC20Token _token, uint32 _ratio, bool _enableVirtualBalance)\r\n        public\r\n        ownerOnly\r\n        inactive\r\n        validAddress(_token)\r\n        notThis(_token)\r\n        validReserveRatio(_ratio)\r\n    {\r\n        require(_token != token && !reserves[_token].isSet && totalReserveRatio + _ratio <= MAX_CRR); // validate input\r\n\r\n        reserves[_token].virtualBalance = 0;\r\n        reserves[_token].ratio = _ratio;\r\n        reserves[_token].isVirtualBalanceEnabled = _enableVirtualBalance;\r\n        reserves[_token].isPurchaseEnabled = true;\r\n        reserves[_token].isSet = true;\r\n        reserveTokens.push(_token);\r\n        totalReserveRatio += _ratio;\r\n    }\r\n\r\n    /**\r\n        @dev updates one of the token reserves\r\n        can only be called by the owner\r\n\r\n        @param _reserveToken           address of the reserve token\r\n        @param _ratio                  constant reserve ratio, represented in ppm, 1-1000000\r\n        @param _enableVirtualBalance   true to enable virtual balance for the reserve, false to disable it\r\n        @param _virtualBalance         new reserve's virtual balance\r\n    */\r\n    function updateReserve(IERC20Token _reserveToken, uint32 _ratio, bool _enableVirtualBalance, uint256 _virtualBalance)\r\n        public\r\n        ownerOnly\r\n        validReserve(_reserveToken)\r\n        validReserveRatio(_ratio)\r\n    {\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        require(totalReserveRatio - reserve.ratio + _ratio <= MAX_CRR); // validate input\r\n\r\n        totalReserveRatio = totalReserveRatio - reserve.ratio + _ratio;\r\n        reserve.ratio = _ratio;\r\n        reserve.isVirtualBalanceEnabled = _enableVirtualBalance;\r\n        reserve.virtualBalance = _virtualBalance;\r\n    }\r\n\r\n    /**\r\n        @dev disables purchasing with the given reserve token in case the reserve token got compromised\r\n        can only be called by the owner\r\n        note that selling is still enabled regardless of this flag and it cannot be disabled by the owner\r\n\r\n        @param _reserveToken    reserve token contract address\r\n        @param _disable         true to disable the token, false to re-enable it\r\n    */\r\n    function disableReservePurchases(IERC20Token _reserveToken, bool _disable)\r\n        public\r\n        ownerOnly\r\n        validReserve(_reserveToken)\r\n    {\r\n        reserves[_reserveToken].isPurchaseEnabled = !_disable;\r\n    }\r\n\r\n    /**\r\n        @dev returns the reserve's virtual balance if one is defined, otherwise returns the actual balance\r\n\r\n        @param _reserveToken    reserve token contract address\r\n\r\n        @return reserve balance\r\n    */\r\n    function getReserveBalance(IERC20Token _reserveToken)\r\n        public\r\n        constant\r\n        validReserve(_reserveToken)\r\n        returns (uint256 balance)\r\n    {\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        return reserve.isVirtualBalanceEnabled ? reserve.virtualBalance : _reserveToken.balanceOf(this);\r\n    }\r\n\r\n    /**\r\n        @dev returns the expected return for changing a specific amount of _fromToken to _toToken\r\n\r\n        @param _fromToken  ERC20 token to change from\r\n        @param _toToken    ERC20 token to change to\r\n        @param _amount     amount to change, in fromToken\r\n\r\n        @return expected change return amount\r\n    */\r\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public constant returns (uint256 amount) {\r\n        require(_fromToken != _toToken); // validate input\r\n\r\n        // change between the token and one of its reserves\r\n        if (_toToken == token)\r\n            return getPurchaseReturn(_fromToken, _amount);\r\n        else if (_fromToken == token)\r\n            return getSaleReturn(_toToken, _amount);\r\n\r\n        // change between 2 reserves\r\n        uint256 purchaseReturnAmount = getPurchaseReturn(_fromToken, _amount);\r\n        return getSaleReturn(_toToken, purchaseReturnAmount, safeAdd(token.totalSupply(), purchaseReturnAmount));\r\n    }\r\n\r\n    /**\r\n        @dev returns the expected return for buying the token for a reserve token\r\n\r\n        @param _reserveToken   reserve token contract address\r\n        @param _depositAmount  amount to deposit (in the reserve token)\r\n\r\n        @return expected purchase return amount\r\n    */\r\n    function getPurchaseReturn(IERC20Token _reserveToken, uint256 _depositAmount)\r\n        public\r\n        constant\r\n        active\r\n        validReserve(_reserveToken)\r\n        returns (uint256 amount)\r\n    {\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        require(reserve.isPurchaseEnabled); // validate input\r\n\r\n        uint256 tokenSupply = token.totalSupply();\r\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\r\n        amount = formula.calculatePurchaseReturn(tokenSupply, reserveBalance, reserve.ratio, _depositAmount);\r\n\r\n        // deduct the fee from the return amount\r\n        uint256 feeAmount = getChangeFeeAmount(amount);\r\n        return safeSub(amount, feeAmount);\r\n    }\r\n\r\n    /**\r\n        @dev returns the expected return for selling the token for one of its reserve tokens\r\n\r\n        @param _reserveToken   reserve token contract address\r\n        @param _sellAmount     amount to sell (in the smart token)\r\n\r\n        @return expected sale return amount\r\n    */\r\n    function getSaleReturn(IERC20Token _reserveToken, uint256 _sellAmount) public constant returns (uint256 amount) {\r\n        return getSaleReturn(_reserveToken, _sellAmount, token.totalSupply());\r\n    }\r\n\r\n    /**\r\n        @dev changes a specific amount of _fromToken to _toToken\r\n\r\n        @param _fromToken  ERC20 token to change from\r\n        @param _toToken    ERC20 token to change to\r\n        @param _amount     amount to change, in fromToken\r\n        @param _minReturn  if the change results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n\r\n        @return change return amount\r\n    */\r\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 amount) {\r\n        require(_fromToken != _toToken); // validate input\r\n\r\n        // change between the token and one of its reserves\r\n        if (_toToken == token)\r\n            return buy(_fromToken, _amount, _minReturn);\r\n        else if (_fromToken == token)\r\n            return sell(_toToken, _amount, _minReturn);\r\n\r\n        // change between 2 reserves\r\n        uint256 purchaseAmount = buy(_fromToken, _amount, 1);\r\n        return sell(_toToken, purchaseAmount, _minReturn);\r\n    }\r\n\r\n    /**\r\n        @dev buys the token by depositing one of its reserve tokens\r\n\r\n        @param _reserveToken   reserve token contract address\r\n        @param _depositAmount  amount to deposit (in the reserve token)\r\n        @param _minReturn      if the change results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n\r\n        @return buy return amount\r\n    */\r\n    function buy(IERC20Token _reserveToken, uint256 _depositAmount, uint256 _minReturn)\r\n        public\r\n        changingAllowed\r\n        greaterThanZero(_minReturn)\r\n        returns (uint256 amount)\r\n    {\r\n        amount = getPurchaseReturn(_reserveToken, _depositAmount);\r\n        assert(amount != 0 && amount >= _minReturn); // ensure the trade gives something in return and meets the minimum requested amount\r\n\r\n        // update virtual balance if relevant\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        if (reserve.isVirtualBalanceEnabled)\r\n            reserve.virtualBalance = safeAdd(reserve.virtualBalance, _depositAmount);\r\n\r\n        // transfer _depositAmount funds from the caller in the reserve token\r\n        // note that there's no need to execute the transfer if the sender is the local contract\r\n        if (msg.sender != address(this))\r\n            assert(_reserveToken.transferFrom(msg.sender, this, _depositAmount));\r\n        // issue new funds to the caller in the smart token\r\n        token.issue(msg.sender, amount);\r\n\r\n        // calculate the new price using the simple price formula\r\n        // price = reserve balance / (supply * CRR)\r\n        // CRR is represented in ppm, so multiplying by 1000000\r\n        uint256 reserveAmount = safeMul(getReserveBalance(_reserveToken), MAX_CRR);\r\n        uint256 tokenAmount = safeMul(token.totalSupply(), reserve.ratio);\r\n        Change(_reserveToken, token, msg.sender, _depositAmount, amount, reserveAmount, tokenAmount);\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n        @dev sells the token by withdrawing from one of its reserve tokens\r\n\r\n        @param _reserveToken   reserve token contract address\r\n        @param _sellAmount     amount to sell (in the smart token)\r\n        @param _minReturn      if the change results in an amount smaller the minimum return - it is cancelled, must be nonzero\r\n\r\n        @return sell return amount\r\n    */\r\n    function sell(IERC20Token _reserveToken, uint256 _sellAmount, uint256 _minReturn)\r\n        public\r\n        changingAllowed\r\n        greaterThanZero(_minReturn)\r\n        returns (uint256 amount)\r\n    {\r\n        require(_sellAmount <= token.balanceOf(msg.sender)); // validate input\r\n\r\n        amount = getSaleReturn(_reserveToken, _sellAmount);\r\n        assert(amount != 0 && amount >= _minReturn); // ensure the trade gives something in return and meets the minimum requested amount\r\n\r\n        uint256 tokenSupply = token.totalSupply();\r\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\r\n        // ensure that the trade will only deplete the reserve if the total supply is depleted as well\r\n        assert(amount < reserveBalance || (amount == reserveBalance && _sellAmount == tokenSupply));\r\n\r\n        // update virtual balance if relevant\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        if (reserve.isVirtualBalanceEnabled)\r\n            reserve.virtualBalance = safeSub(reserve.virtualBalance, amount);\r\n\r\n        // destroy _sellAmount from the caller's balance in the smart token\r\n        token.destroy(msg.sender, _sellAmount);\r\n        // transfer funds to the caller in the reserve token\r\n        // the transfer might fail if the actual reserve balance is smaller than the virtual balance\r\n        // note that there's no need to execute the transfer if the sender is the local contract\r\n        if (msg.sender != address(this))\r\n            assert(_reserveToken.transfer(msg.sender, amount));\r\n\r\n        // calculate the new price using the simple price formula\r\n        // price = reserve balance / (supply * CRR)\r\n        // CRR is represented in ppm, so multiplying by 1000000\r\n        uint256 reserveAmount = safeMul(getReserveBalance(_reserveToken), MAX_CRR);\r\n        uint256 tokenAmount = safeMul(token.totalSupply(), reserve.ratio);\r\n        Change(token, _reserveToken, msg.sender, _sellAmount, amount, tokenAmount, reserveAmount);\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n        @dev changes the token to any other token in the bancor network by following a predefined change path\r\n        note that when changing from an ERC20 token (as opposed to a smart token), allowance must be set beforehand\r\n\r\n        @param _path        change path, see change path format above\r\n        @param _amount      amount to change from (in the initial source token)\r\n        @param _minReturn   if the change results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n\r\n        @return tokens issued in return\r\n    */\r\n    function quickChange(IERC20Token[] _path, uint256 _amount, uint256 _minReturn)\r\n        public\r\n        validChangePath(_path)\r\n        returns (uint256 amount)\r\n    {\r\n        // we need to transfer the tokens from the caller to the local contract before we\r\n        // follow the change path, to allow it to execute the change on behalf of the caller\r\n        IERC20Token fromToken = _path[0];\r\n        claimTokens(fromToken, msg.sender, _amount);\r\n\r\n        ISmartToken smartToken;\r\n        IERC20Token toToken;\r\n        BancorChanger changer;\r\n        uint256 pathLength = _path.length;\r\n\r\n        // iterate over the change path\r\n        for (uint256 i = 1; i < pathLength; i += 2) {\r\n            smartToken = ISmartToken(_path[i]);\r\n            toToken = _path[i + 1];\r\n            changer = BancorChanger(smartToken.owner());\r\n\r\n            // if the smart token isn't the source (from token), the changer doesn't have control over it and thus we need to approve the request\r\n            if (smartToken != fromToken)\r\n                ensureAllowance(fromToken, changer, _amount);\r\n\r\n            // make the change - if it's the last one, also provide the minimum return value\r\n            _amount = changer.change(fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1);\r\n            fromToken = toToken;\r\n        }\r\n\r\n        // finished the change, transfer the funds back to the caller\r\n        // if the last change resulted in ether tokens, withdraw them and send them as ETH to the caller\r\n        if (changer.hasQuickBuyEtherToken() && changer.getQuickBuyEtherToken() == toToken) {\r\n            IEtherToken etherToken = IEtherToken(toToken);\r\n            etherToken.withdrawTo(msg.sender, _amount);\r\n        }\r\n        // no need to transfer the tokens if the sender is the local contract\r\n        else if (msg.sender != address(this)) {\r\n            // not ETH, transfer the tokens to the caller\r\n            assert(toToken.transfer(msg.sender, _amount));\r\n        }\r\n\r\n        return _amount;\r\n    }\r\n\r\n    /**\r\n        @dev buys the smart token with ETH if the return amount meets the minimum requested\r\n        note that this function can eventually be moved into a separate contract\r\n\r\n        @param _minReturn  if the change results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n\r\n        @return tokens issued in return\r\n    */\r\n    function quickBuy(uint256 _minReturn) public payable returns (uint256 amount) {\r\n        // ensure that the quick buy path was set\r\n        assert(quickBuyPath.length > 0);\r\n        // get the ether token\r\n        IEtherToken etherToken = getQuickBuyEtherToken();\r\n        // deposit ETH in the ether token\r\n        etherToken.deposit.value(msg.value)();\r\n        // execute the change\r\n        uint256 returnAmount = this.quickChange(quickBuyPath, msg.value, _minReturn);\r\n        // get the target token\r\n        IERC20Token toToken = quickBuyPath[quickBuyPath.length - 1];\r\n        // transfer the tokens to the caller\r\n        assert(toToken.transfer(msg.sender, returnAmount));\r\n        return returnAmount;\r\n    }\r\n\r\n    /**\r\n        @dev utility, returns the expected return for selling the token for one of its reserve tokens, given a total supply override\r\n\r\n        @param _reserveToken   reserve token contract address\r\n        @param _sellAmount     amount to sell (in the smart token)\r\n        @param _totalSupply    total token supply, overrides the actual token total supply when calculating the return\r\n\r\n        @return sale return amount\r\n    */\r\n    function getSaleReturn(IERC20Token _reserveToken, uint256 _sellAmount, uint256 _totalSupply)\r\n        private\r\n        constant\r\n        active\r\n        validReserve(_reserveToken)\r\n        greaterThanZero(_totalSupply)\r\n        returns (uint256 amount)\r\n    {\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\r\n        amount = formula.calculateSaleReturn(_totalSupply, reserveBalance, reserve.ratio, _sellAmount);\r\n\r\n        // deduct the fee from the return amount\r\n        uint256 feeAmount = getChangeFeeAmount(amount);\r\n        return safeSub(amount, feeAmount);\r\n    }\r\n\r\n    /**\r\n        @dev utility, checks whether allowance for the given spender exists and approves one if it doesn't\r\n\r\n        @param _token   token to check the allowance in\r\n        @param _spender approved address\r\n        @param _value   allowance amount\r\n    */\r\n    function ensureAllowance(IERC20Token _token, address _spender, uint256 _value) private {\r\n        // no need to set an allowance if the spender is the local contract\r\n        if (_spender == address(this))\r\n            return;\r\n\r\n        // check if allowance for the given amount already exists\r\n        if (_token.allowance(this, _spender) >= _value)\r\n            return;\r\n\r\n        // if the allowance is nonzero, must reset it to 0 first\r\n        if (_token.allowance(this, _spender) != 0)\r\n            assert(_token.approve(_spender, 0));\r\n\r\n        // approve the new allowance\r\n        assert(_token.approve(_spender, _value));\r\n    }\r\n\r\n    /**\r\n        @dev utility, transfers tokens from an account to the local contract\r\n\r\n        @param _token   token to claim\r\n        @param _from    account to claim the tokens from\r\n        @param _amount  amount to claim\r\n    */\r\n    function claimTokens(IERC20Token _token, address _from, uint256 _amount) private {\r\n        // no need to claim the tokens if the source is the local contract\r\n        if (_from == address(this))\r\n            return;\r\n\r\n        // if the token is the smart token, no allowance is required - destroy the tokens from the caller and issue them to the local contract\r\n        if (_token == token) {\r\n            token.destroy(_from, _amount); // destroy _amount tokens from the caller's balance in the smart token\r\n            token.issue(this, _amount); // issue _amount new tokens to the local contract\r\n            return;\r\n        }\r\n\r\n        // otherwise, we assume we already have allowance\r\n        assert(_token.transferFrom(_from, this, _amount));\r\n    }\r\n\r\n    /**\r\n        @dev fallback, buys the smart token with ETH\r\n        note that the purchase will use the price at the time of the purchase\r\n    */\r\n    function() payable {\r\n        quickBuy(1);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ITokenChanger"
    UserDefinedTypeName "ITokenChanger"
       Source: "ITokenChanger"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SmartTokenController"
    UserDefinedTypeName "SmartTokenController"
       Source: "SmartTokenController"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Managed"
    UserDefinedTypeName "Managed"
       Source: "Managed"
  VariableDeclaration "MAX_CRR"
     Type: uint32
     Gas costs: 18
     Source: "uint32 private constant MAX_CRR = 1000000"
    ElementaryTypeName uint32
       Source: "uint32"
    Literal, token: [no token] value: 1000000
       Type: int_const 1000000
       Source: "1000000"
  VariableDeclaration "MAX_CHANGE_FEE"
     Type: uint32
     Gas costs: 3
     Source: "uint32 private constant MAX_CHANGE_FEE = 1000000"
    ElementaryTypeName uint32
       Source: "uint32"
    Literal, token: [no token] value: 1000000
       Type: int_const 1000000
       Source: "1000000"
  StructDefinition "Reserve"
     Gas costs: 0
     Source: "struct Reserve {\r\n        uint256 virtualBalance;         // virtual balance\r\n        uint32 ratio;                   // constant reserve ratio (CRR), represented in ppm, 1-1000000\r\n        bool isVirtualBalanceEnabled;   // true if virtual balance is enabled, false if not\r\n        bool isPurchaseEnabled;         // is purchase of the smart token enabled with the reserve, can be set by the owner\r\n        bool isSet;                     // used to tell if the mapping element is defined\r\n    }"
    VariableDeclaration "virtualBalance"
       Type: uint256
       Source: "uint256 virtualBalance"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "ratio"
       Type: uint32
       Source: "uint32 ratio"
      ElementaryTypeName uint32
         Source: "uint32"
    VariableDeclaration "isVirtualBalanceEnabled"
       Type: bool
       Source: "bool isVirtualBalanceEnabled"
      ElementaryTypeName bool
         Source: "bool"
    VariableDeclaration "isPurchaseEnabled"
       Type: bool
       Source: "bool isPurchaseEnabled"
      ElementaryTypeName bool
         Source: "bool"
    VariableDeclaration "isSet"
       Type: bool
       Source: "bool isSet"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "version"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public version = '0.3'"
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: 0.3
       Type: literal_string "0.3"
       Source: "'0.3'"
  VariableDeclaration "changerType"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public changerType = 'bancor'"
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: bancor
       Type: literal_string "bancor"
       Source: "'bancor'"
  VariableDeclaration "formula"
     Type: contract IBancorFormula
     Gas costs: [???]
     Source: "IBancorFormula public formula"
    UserDefinedTypeName "IBancorFormula"
       Source: "IBancorFormula"
  VariableDeclaration "reserveTokens"
     Type: contract IERC20Token[] storage ref
     Gas costs: [???]
     Source: "IERC20Token[] public reserveTokens"
    ArrayTypeName
       Source: "IERC20Token[]"
      UserDefinedTypeName "IERC20Token"
         Source: "IERC20Token"
  VariableDeclaration "quickBuyPath"
     Type: contract IERC20Token[] storage ref
     Gas costs: [???]
     Source: "IERC20Token[] public quickBuyPath"
    ArrayTypeName
       Source: "IERC20Token[]"
      UserDefinedTypeName "IERC20Token"
         Source: "IERC20Token"
  VariableDeclaration "reserves"
     Type: mapping(address => struct BancorChanger.Reserve storage ref)
     Gas costs: [???]
     Source: "mapping (address => Reserve) public reserves"
    Mapping
       Source: "mapping (address => Reserve)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "Reserve"
         Source: "Reserve"
  VariableDeclaration "totalReserveRatio"
     Type: uint32
     Gas costs: 0
     Source: "uint32 private totalReserveRatio = 0"
    ElementaryTypeName uint32
       Source: "uint32"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "maxChangeFee"
     Type: uint32
     Gas costs: [???]
     Source: "uint32 public maxChangeFee = 0"
    ElementaryTypeName uint32
       Source: "uint32"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "changeFee"
     Type: uint32
     Gas costs: [???]
     Source: "uint32 public changeFee = 0"
    ElementaryTypeName uint32
       Source: "uint32"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "changingEnabled"
     Type: bool
     Gas costs: [???]
     Source: "bool public changingEnabled = true"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: true value: true
       Type: bool
       Source: "true"
  EventDefinition "Change"
     Gas costs: 0
     Source: "event Change(address indexed _fromToken, address indexed _toToken, address indexed _trader, uint256 _amount, uint256 _return,\r\n                 uint256 _currentPriceN, uint256 _currentPriceD);"
    ParameterList
       Source: "(address indexed _fromToken, address indexed _toToken, address indexed _trader, uint256 _amount, uint256 _return,\r\n                 uint256 _currentPriceN, uint256 _currentPriceD)"
      VariableDeclaration "_fromToken"
         Type: address
         Source: "address indexed _fromToken"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_toToken"
         Type: address
         Source: "address indexed _toToken"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_trader"
         Type: address
         Source: "address indexed _trader"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_return"
         Type: uint256
         Source: "uint256 _return"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_currentPriceN"
         Type: uint256
         Source: "uint256 _currentPriceN"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_currentPriceD"
         Type: uint256
         Source: "uint256 _currentPriceD"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "BancorChanger" - public
     Source: "function BancorChanger(ISmartToken _token, IBancorFormula _formula, uint32 _maxChangeFee, IERC20Token _reserveToken, uint32 _reserveRatio)\r\n        SmartTokenController(_token)\r\n        validAddress(_formula)\r\n        validMaxChangeFee(_maxChangeFee)\r\n    {\r\n        formula = _formula;\r\n        maxChangeFee = _maxChangeFee;\r\n\r\n        if (address(_reserveToken) != 0x0)\r\n            addReserve(_reserveToken, _reserveRatio, false);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ISmartToken _token, IBancorFormula _formula, uint32 _maxChangeFee, IERC20Token _reserveToken, uint32 _reserveRatio)"
      VariableDeclaration "_token"
         Type: contract ISmartToken
         Source: "ISmartToken _token"
        UserDefinedTypeName "ISmartToken"
           Source: "ISmartToken"
      VariableDeclaration "_formula"
         Type: contract IBancorFormula
         Source: "IBancorFormula _formula"
        UserDefinedTypeName "IBancorFormula"
           Source: "IBancorFormula"
      VariableDeclaration "_maxChangeFee"
         Type: uint32
         Source: "uint32 _maxChangeFee"
        ElementaryTypeName uint32
           Source: "uint32"
      VariableDeclaration "_reserveToken"
         Type: contract IERC20Token
         Source: "IERC20Token _reserveToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_reserveRatio"
         Type: uint32
         Source: "uint32 _reserveRatio"
        ElementaryTypeName uint32
           Source: "uint32"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "SmartTokenController"
       Gas costs: 0
       Source: "SmartTokenController(_token)"
      Identifier SmartTokenController
         Type: type(contract SmartTokenController)
         Source: "SmartTokenController"
      Identifier _token
         Type: contract ISmartToken
         Source: "_token"
    ModifierInvocation "validAddress"
       Gas costs: 0
       Source: "validAddress(_formula)"
      Identifier validAddress
         Type: modifier (address)
         Source: "validAddress"
      Identifier _formula
         Type: contract IBancorFormula
         Source: "_formula"
    ModifierInvocation "validMaxChangeFee"
       Gas costs: 0
       Source: "validMaxChangeFee(_maxChangeFee)"
      Identifier validMaxChangeFee
         Type: modifier (uint32)
         Source: "validMaxChangeFee"
      Identifier _maxChangeFee
         Type: uint32
         Source: "_maxChangeFee"
    Block
       Source: "{\r\n        formula = _formula;\r\n        maxChangeFee = _maxChangeFee;\r\n\r\n        if (address(_reserveToken) != 0x0)\r\n            addReserve(_reserveToken, _reserveRatio, false);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "formula = _formula"
        Assignment using operator =
           Type: contract IBancorFormula
           Source: "formula = _formula"
          Identifier formula
             Type: contract IBancorFormula
             Source: "formula"
          Identifier _formula
             Type: contract IBancorFormula
             Source: "_formula"
      ExpressionStatement
         Gas costs: 0
         Source: "maxChangeFee = _maxChangeFee"
        Assignment using operator =
           Type: uint32
           Source: "maxChangeFee = _maxChangeFee"
          Identifier maxChangeFee
             Type: uint32
             Source: "maxChangeFee"
          Identifier _maxChangeFee
             Type: uint32
             Source: "_maxChangeFee"
      IfStatement
         Source: "if (address(_reserveToken) != 0x0)\r\n            addReserve(_reserveToken, _reserveRatio, false)"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "address(_reserveToken) != 0x0"
          FunctionCall
             Type: address
             Source: "address(_reserveToken)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier _reserveToken
               Type: contract IERC20Token
               Source: "_reserveToken"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
        ExpressionStatement
           Gas costs: 0
           Source: "addReserve(_reserveToken, _reserveRatio, false)"
          FunctionCall
             Type: tuple()
             Source: "addReserve(_reserveToken, _reserveRatio, false)"
            Identifier addReserve
               Type: function (contract IERC20Token,uint32,bool)
               Source: "addReserve"
            Identifier _reserveToken
               Type: contract IERC20Token
               Source: "_reserveToken"
            Identifier _reserveRatio
               Type: uint32
               Source: "_reserveRatio"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  ModifierDefinition "validReserve"
     Source: "modifier validReserve(IERC20Token _address) {\r\n        require(reserves[_address].isSet);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _address)"
      VariableDeclaration "_address"
         Type: contract IERC20Token
         Source: "IERC20Token _address"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
    Block
       Source: "{\r\n        require(reserves[_address].isSet);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 2085
         Source: "require(reserves[_address].isSet)"
        FunctionCall
           Type: tuple()
           Source: "require(reserves[_address].isSet)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          MemberAccess to member isSet
             Type: bool
             Source: "reserves[_address].isSet"
            IndexAccess
               Type: struct BancorChanger.Reserve storage ref
               Source: "reserves[_address]"
              Identifier reserves
                 Type: mapping(address => struct BancorChanger.Reserve storage ref)
                 Source: "reserves"
              Identifier _address
                 Type: contract IERC20Token
                 Source: "_address"
      PlaceholderStatement
         Gas costs: 4
         Source: "_"
  ModifierDefinition "validToken"
     Source: "modifier validToken(IERC20Token _address) {\r\n        require(_address == token || reserves[_address].isSet);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _address)"
      VariableDeclaration "_address"
         Type: contract IERC20Token
         Source: "IERC20Token _address"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
    Block
       Source: "{\r\n        require(_address == token || reserves[_address].isSet);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_address == token || reserves[_address].isSet)"
        FunctionCall
           Type: tuple()
           Source: "require(_address == token || reserves[_address].isSet)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "_address == token || reserves[_address].isSet"
            BinaryOperation using operator ==
               Type: bool
               Source: "_address == token"
              Identifier _address
                 Type: contract IERC20Token
                 Source: "_address"
              Identifier token
                 Type: contract ISmartToken
                 Source: "token"
            MemberAccess to member isSet
               Type: bool
               Source: "reserves[_address].isSet"
              IndexAccess
                 Type: struct BancorChanger.Reserve storage ref
                 Source: "reserves[_address]"
                Identifier reserves
                   Type: mapping(address => struct BancorChanger.Reserve storage ref)
                   Source: "reserves"
                Identifier _address
                   Type: contract IERC20Token
                   Source: "_address"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "validMaxChangeFee"
     Source: "modifier validMaxChangeFee(uint32 _changeFee) {\r\n        require(_changeFee >= 0 && _changeFee <= MAX_CHANGE_FEE);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint32 _changeFee)"
      VariableDeclaration "_changeFee"
         Type: uint32
         Source: "uint32 _changeFee"
        ElementaryTypeName uint32
           Source: "uint32"
    Block
       Source: "{\r\n        require(_changeFee >= 0 && _changeFee <= MAX_CHANGE_FEE);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_changeFee >= 0 && _changeFee <= MAX_CHANGE_FEE)"
        FunctionCall
           Type: tuple()
           Source: "require(_changeFee >= 0 && _changeFee <= MAX_CHANGE_FEE)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_changeFee >= 0 && _changeFee <= MAX_CHANGE_FEE"
            BinaryOperation using operator >=
               Type: bool
               Source: "_changeFee >= 0"
              Identifier _changeFee
                 Type: uint32
                 Source: "_changeFee"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator <=
               Type: bool
               Source: "_changeFee <= MAX_CHANGE_FEE"
              Identifier _changeFee
                 Type: uint32
                 Source: "_changeFee"
              Identifier MAX_CHANGE_FEE
                 Type: uint32
                 Source: "MAX_CHANGE_FEE"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "validChangeFee"
     Source: "modifier validChangeFee(uint32 _changeFee) {\r\n        require(_changeFee >= 0 && _changeFee <= maxChangeFee);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint32 _changeFee)"
      VariableDeclaration "_changeFee"
         Type: uint32
         Source: "uint32 _changeFee"
        ElementaryTypeName uint32
           Source: "uint32"
    Block
       Source: "{\r\n        require(_changeFee >= 0 && _changeFee <= maxChangeFee);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 376
         Source: "require(_changeFee >= 0 && _changeFee <= maxChangeFee)"
        FunctionCall
           Type: tuple()
           Source: "require(_changeFee >= 0 && _changeFee <= maxChangeFee)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_changeFee >= 0 && _changeFee <= maxChangeFee"
            BinaryOperation using operator >=
               Type: bool
               Source: "_changeFee >= 0"
              Identifier _changeFee
                 Type: uint32
                 Source: "_changeFee"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator <=
               Type: bool
               Source: "_changeFee <= maxChangeFee"
              Identifier _changeFee
                 Type: uint32
                 Source: "_changeFee"
              Identifier maxChangeFee
                 Type: uint32
                 Source: "maxChangeFee"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "validReserveRatio"
     Source: "modifier validReserveRatio(uint32 _ratio) {\r\n        require(_ratio > 0 && _ratio <= MAX_CRR);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint32 _ratio)"
      VariableDeclaration "_ratio"
         Type: uint32
         Source: "uint32 _ratio"
        ElementaryTypeName uint32
           Source: "uint32"
    Block
       Source: "{\r\n        require(_ratio > 0 && _ratio <= MAX_CRR);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 168
         Source: "require(_ratio > 0 && _ratio <= MAX_CRR)"
        FunctionCall
           Type: tuple()
           Source: "require(_ratio > 0 && _ratio <= MAX_CRR)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_ratio > 0 && _ratio <= MAX_CRR"
            BinaryOperation using operator >
               Type: bool
               Source: "_ratio > 0"
              Identifier _ratio
                 Type: uint32
                 Source: "_ratio"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator <=
               Type: bool
               Source: "_ratio <= MAX_CRR"
              Identifier _ratio
                 Type: uint32
                 Source: "_ratio"
              Identifier MAX_CRR
                 Type: uint32
                 Source: "MAX_CRR"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "validChangePath"
     Source: "modifier validChangePath(IERC20Token[] _path) {\r\n        require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token[] _path)"
      VariableDeclaration "_path"
         Type: contract IERC20Token[] memory
         Source: "IERC20Token[] _path"
        ArrayTypeName
           Source: "IERC20Token[]"
          UserDefinedTypeName "IERC20Token"
             Source: "IERC20Token"
    Block
       Source: "{\r\n        require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1)"
        FunctionCall
           Type: tuple()
           Source: "require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1"
            BinaryOperation using operator &&
               Type: bool
               Source: "_path.length > 2 && _path.length <= (1 + 2 * 10)"
              BinaryOperation using operator >
                 Type: bool
                 Source: "_path.length > 2"
                MemberAccess to member length
                   Type: uint256
                   Source: "_path.length"
                  Identifier _path
                     Type: contract IERC20Token[] memory
                     Source: "_path"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "_path.length <= (1 + 2 * 10)"
                MemberAccess to member length
                   Type: uint256
                   Source: "_path.length"
                  Identifier _path
                     Type: contract IERC20Token[] memory
                     Source: "_path"
                TupleExpression
                   Type: int_const 21
                   Source: "(1 + 2 * 10)"
                  BinaryOperation using operator +
                     Type: int_const 21
                     Source: "1 + 2 * 10"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
                    BinaryOperation using operator *
                       Type: int_const 20
                       Source: "2 * 10"
                      Literal, token: [no token] value: 2
                         Type: int_const 2
                         Source: "2"
                      Literal, token: [no token] value: 10
                         Type: int_const 10
                         Source: "10"
            BinaryOperation using operator ==
               Type: bool
               Source: "_path.length % 2 == 1"
              BinaryOperation using operator %
                 Type: uint256
                 Source: "_path.length % 2"
                MemberAccess to member length
                   Type: uint256
                   Source: "_path.length"
                  Identifier _path
                     Type: contract IERC20Token[] memory
                     Source: "_path"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "changingAllowed"
     Source: "modifier changingAllowed {\r\n        assert(changingEnabled);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        assert(changingEnabled);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 618
         Source: "assert(changingEnabled)"
        FunctionCall
           Type: tuple()
           Source: "assert(changingEnabled)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          Identifier changingEnabled
             Type: bool
             Source: "changingEnabled"
      PlaceholderStatement
         Gas costs: 4
         Source: "_"
  FunctionDefinition "reserveTokenCount" - public - const
     Source: "function reserveTokenCount() public constant returns (uint16 count) {\r\n        return uint16(reserveTokens.length);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint16 count)"
      VariableDeclaration "count"
         Type: uint16
         Source: "uint16 count"
        ElementaryTypeName uint16
           Source: "uint16"
    Block
       Source: "{\r\n        return uint16(reserveTokens.length);\r\n    }"
      Return
         Gas costs: 216
         Source: "return uint16(reserveTokens.length)"
        FunctionCall
           Type: uint16
           Source: "uint16(reserveTokens.length)"
          ElementaryTypeNameExpression uint16
             Type: type(uint16)
             Source: "uint16"
          MemberAccess to member length
             Type: uint256
             Source: "reserveTokens.length"
            Identifier reserveTokens
               Type: contract IERC20Token[] storage ref
               Source: "reserveTokens"
  FunctionDefinition "changeableTokenCount" - public - const
     Source: "function changeableTokenCount() public constant returns (uint16 count) {\r\n        return reserveTokenCount() + 1;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint16 count)"
      VariableDeclaration "count"
         Type: uint16
         Source: "uint16 count"
        ElementaryTypeName uint16
           Source: "uint16"
    Block
       Source: "{\r\n        return reserveTokenCount() + 1;\r\n    }"
      Return
         Gas costs: 15
         Source: "return reserveTokenCount() + 1"
        BinaryOperation using operator +
           Type: uint16
           Source: "reserveTokenCount() + 1"
          FunctionCall
             Type: uint16
             Source: "reserveTokenCount()"
            Identifier reserveTokenCount
               Type: function () view returns (uint16)
               Source: "reserveTokenCount"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
  FunctionDefinition "changeableToken" - public - const
     Source: "function changeableToken(uint16 _tokenIndex) public constant returns (address tokenAddress) {\r\n        if (_tokenIndex == 0)\r\n            return token;\r\n        return reserveTokens[_tokenIndex - 1];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint16 _tokenIndex)"
      VariableDeclaration "_tokenIndex"
         Type: uint16
         Source: "uint16 _tokenIndex"
        ElementaryTypeName uint16
           Source: "uint16"
    ParameterList
       Gas costs: 3
       Source: "(address tokenAddress)"
      VariableDeclaration "tokenAddress"
         Type: address
         Source: "address tokenAddress"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        if (_tokenIndex == 0)\r\n            return token;\r\n        return reserveTokens[_tokenIndex - 1];\r\n    }"
      IfStatement
         Source: "if (_tokenIndex == 0)\r\n            return token"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 15
           Source: "_tokenIndex == 0"
          Identifier _tokenIndex
             Type: uint16
             Source: "_tokenIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 255
           Source: "return token"
          Identifier token
             Type: contract ISmartToken
             Source: "token"
      Return
         Gas costs: 545
         Source: "return reserveTokens[_tokenIndex - 1]"
        IndexAccess
           Type: contract IERC20Token
           Source: "reserveTokens[_tokenIndex - 1]"
          Identifier reserveTokens
             Type: contract IERC20Token[] storage ref
             Source: "reserveTokens"
          BinaryOperation using operator -
             Type: uint16
             Source: "_tokenIndex - 1"
            Identifier _tokenIndex
               Type: uint16
               Source: "_tokenIndex"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
  FunctionDefinition "setFormula" - public
     Source: "function setFormula(IBancorFormula _formula)\r\n        public\r\n        ownerOnly\r\n        validAddress(_formula)\r\n        notThis(_formula)\r\n    {\r\n        formula = _formula;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IBancorFormula _formula)"
      VariableDeclaration "_formula"
         Type: contract IBancorFormula
         Source: "IBancorFormula _formula"
        UserDefinedTypeName "IBancorFormula"
           Source: "IBancorFormula"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerOnly"
       Gas costs: 0
       Source: "ownerOnly"
      Identifier ownerOnly
         Type: modifier ()
         Source: "ownerOnly"
    ModifierInvocation "validAddress"
       Gas costs: 3
       Source: "validAddress(_formula)"
      Identifier validAddress
         Type: modifier (address)
         Source: "validAddress"
      Identifier _formula
         Type: contract IBancorFormula
         Source: "_formula"
    ModifierInvocation "notThis"
       Gas costs: 3
       Source: "notThis(_formula)"
      Identifier notThis
         Type: modifier (address)
         Source: "notThis"
      Identifier _formula
         Type: contract IBancorFormula
         Source: "_formula"
    Block
       Source: "{\r\n        formula = _formula;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "formula = _formula"
        Assignment using operator =
           Type: contract IBancorFormula
           Source: "formula = _formula"
          Identifier formula
             Type: contract IBancorFormula
             Source: "formula"
          Identifier _formula
             Type: contract IBancorFormula
             Source: "_formula"
  FunctionDefinition "setQuickBuyPath" - public
     Source: "function setQuickBuyPath(IERC20Token[] _path)\r\n        public\r\n        ownerOnly\r\n        validChangePath(_path)\r\n    {\r\n        quickBuyPath = _path;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token[] _path)"
      VariableDeclaration "_path"
         Type: contract IERC20Token[] memory
         Source: "IERC20Token[] _path"
        ArrayTypeName
           Source: "IERC20Token[]"
          UserDefinedTypeName "IERC20Token"
             Source: "IERC20Token"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerOnly"
       Gas costs: 0
       Source: "ownerOnly"
      Identifier ownerOnly
         Type: modifier ()
         Source: "ownerOnly"
    ModifierInvocation "validChangePath"
       Gas costs: 3
       Source: "validChangePath(_path)"
      Identifier validChangePath
         Type: modifier (contract IERC20Token[] memory)
         Source: "validChangePath"
      Identifier _path
         Type: contract IERC20Token[] memory
         Source: "_path"
    Block
       Source: "{\r\n        quickBuyPath = _path;\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "quickBuyPath = _path"
        Assignment using operator =
           Type: contract IERC20Token[] storage ref
           Source: "quickBuyPath = _path"
          Identifier quickBuyPath
             Type: contract IERC20Token[] storage ref
             Source: "quickBuyPath"
          Identifier _path
             Type: contract IERC20Token[] memory
             Source: "_path"
  FunctionDefinition "clearQuickBuyPath" - public
     Source: "function clearQuickBuyPath() public ownerOnly {\r\n        quickBuyPath.length = 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerOnly"
       Gas costs: 0
       Source: "ownerOnly"
      Identifier ownerOnly
         Type: modifier ()
         Source: "ownerOnly"
    Block
       Source: "{\r\n        quickBuyPath.length = 0;\r\n    }"
      ExpressionStatement
         Gas costs: 21
         Source: "quickBuyPath.length = 0"
        Assignment using operator =
           Type: uint256
           Source: "quickBuyPath.length = 0"
          MemberAccess to member length
             Type: uint256
             Source: "quickBuyPath.length"
            Identifier quickBuyPath
               Type: contract IERC20Token[] storage ref
               Source: "quickBuyPath"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "getQuickBuyPathLength" - public - const
     Source: "function getQuickBuyPathLength() public constant returns (uint256 length) {\r\n        return quickBuyPath.length;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256 length)"
      VariableDeclaration "length"
         Type: uint256
         Source: "uint256 length"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return quickBuyPath.length;\r\n    }"
      Return
         Gas costs: 216
         Source: "return quickBuyPath.length"
        MemberAccess to member length
           Type: uint256
           Source: "quickBuyPath.length"
          Identifier quickBuyPath
             Type: contract IERC20Token[] storage ref
             Source: "quickBuyPath"
  FunctionDefinition "hasQuickBuyEtherToken" - public - const
     Source: "function hasQuickBuyEtherToken() public constant returns (bool) {\r\n        return quickBuyPath.length > 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        return quickBuyPath.length > 0;\r\n    }"
      Return
         Gas costs: 222
         Source: "return quickBuyPath.length > 0"
        BinaryOperation using operator >
           Type: bool
           Source: "quickBuyPath.length > 0"
          MemberAccess to member length
             Type: uint256
             Source: "quickBuyPath.length"
            Identifier quickBuyPath
               Type: contract IERC20Token[] storage ref
               Source: "quickBuyPath"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "getQuickBuyEtherToken" - public - const
     Source: "function getQuickBuyEtherToken() public constant returns (IEtherToken etherToken) {\r\n        assert(quickBuyPath.length > 0);\r\n        return IEtherToken(quickBuyPath[0]);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(IEtherToken etherToken)"
      VariableDeclaration "etherToken"
         Type: contract IEtherToken
         Source: "IEtherToken etherToken"
        UserDefinedTypeName "IEtherToken"
           Source: "IEtherToken"
    Block
       Source: "{\r\n        assert(quickBuyPath.length > 0);\r\n        return IEtherToken(quickBuyPath[0]);\r\n    }"
      ExpressionStatement
         Gas costs: 237
         Source: "assert(quickBuyPath.length > 0)"
        FunctionCall
           Type: tuple()
           Source: "assert(quickBuyPath.length > 0)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >
             Type: bool
             Source: "quickBuyPath.length > 0"
            MemberAccess to member length
               Type: uint256
               Source: "quickBuyPath.length"
              Identifier quickBuyPath
                 Type: contract IERC20Token[] storage ref
                 Source: "quickBuyPath"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      Return
         Gas costs: 533
         Source: "return IEtherToken(quickBuyPath[0])"
        FunctionCall
           Type: contract IEtherToken
           Source: "IEtherToken(quickBuyPath[0])"
          Identifier IEtherToken
             Type: type(contract IEtherToken)
             Source: "IEtherToken"
          IndexAccess
             Type: contract IERC20Token
             Source: "quickBuyPath[0]"
            Identifier quickBuyPath
               Type: contract IERC20Token[] storage ref
               Source: "quickBuyPath"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "disableChanging" - public
     Source: "function disableChanging(bool _disable) public managerOnly {\r\n        changingEnabled = !_disable;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bool _disable)"
      VariableDeclaration "_disable"
         Type: bool
         Source: "bool _disable"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "managerOnly"
       Gas costs: 0
       Source: "managerOnly"
      Identifier managerOnly
         Type: modifier ()
         Source: "managerOnly"
    Block
       Source: "{\r\n        changingEnabled = !_disable;\r\n    }"
      ExpressionStatement
         Gas costs: 20320
         Source: "changingEnabled = !_disable"
        Assignment using operator =
           Type: bool
           Source: "changingEnabled = !_disable"
          Identifier changingEnabled
             Type: bool
             Source: "changingEnabled"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!_disable"
            Identifier _disable
               Type: bool
               Source: "_disable"
  FunctionDefinition "setChangeFee" - public
     Source: "function setChangeFee(uint32 _changeFee)\r\n        public\r\n        managerOnly\r\n        validChangeFee(_changeFee)\r\n    {\r\n        changeFee = _changeFee;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint32 _changeFee)"
      VariableDeclaration "_changeFee"
         Type: uint32
         Source: "uint32 _changeFee"
        ElementaryTypeName uint32
           Source: "uint32"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "managerOnly"
       Gas costs: 0
       Source: "managerOnly"
      Identifier managerOnly
         Type: modifier ()
         Source: "managerOnly"
    ModifierInvocation "validChangeFee"
       Gas costs: 3
       Source: "validChangeFee(_changeFee)"
      Identifier validChangeFee
         Type: modifier (uint32)
         Source: "validChangeFee"
      Identifier _changeFee
         Type: uint32
         Source: "_changeFee"
    Block
       Source: "{\r\n        changeFee = _changeFee;\r\n    }"
      ExpressionStatement
         Gas costs: 20317
         Source: "changeFee = _changeFee"
        Assignment using operator =
           Type: uint32
           Source: "changeFee = _changeFee"
          Identifier changeFee
             Type: uint32
             Source: "changeFee"
          Identifier _changeFee
             Type: uint32
             Source: "_changeFee"
  FunctionDefinition "getChangeFeeAmount" - public - const
     Source: "function getChangeFeeAmount(uint256 _amount) public constant returns (uint256 feeAmount) {\r\n        return safeMul(_amount, changeFee) / MAX_CHANGE_FEE;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _amount)"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 feeAmount)"
      VariableDeclaration "feeAmount"
         Type: uint256
         Source: "uint256 feeAmount"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return safeMul(_amount, changeFee) / MAX_CHANGE_FEE;\r\n    }"
      Return
         Gas costs: 341
         Source: "return safeMul(_amount, changeFee) / MAX_CHANGE_FEE"
        BinaryOperation using operator /
           Type: uint256
           Source: "safeMul(_amount, changeFee) / MAX_CHANGE_FEE"
          FunctionCall
             Type: uint256
             Source: "safeMul(_amount, changeFee)"
            Identifier safeMul
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeMul"
            Identifier _amount
               Type: uint256
               Source: "_amount"
            Identifier changeFee
               Type: uint32
               Source: "changeFee"
          Identifier MAX_CHANGE_FEE
             Type: uint32
             Source: "MAX_CHANGE_FEE"
  FunctionDefinition "addReserve" - public
     Source: "function addReserve(IERC20Token _token, uint32 _ratio, bool _enableVirtualBalance)\r\n        public\r\n        ownerOnly\r\n        inactive\r\n        validAddress(_token)\r\n        notThis(_token)\r\n        validReserveRatio(_ratio)\r\n    {\r\n        require(_token != token && !reserves[_token].isSet && totalReserveRatio + _ratio <= MAX_CRR); // validate input\r\n\r\n        reserves[_token].virtualBalance = 0;\r\n        reserves[_token].ratio = _ratio;\r\n        reserves[_token].isVirtualBalanceEnabled = _enableVirtualBalance;\r\n        reserves[_token].isPurchaseEnabled = true;\r\n        reserves[_token].isSet = true;\r\n        reserveTokens.push(_token);\r\n        totalReserveRatio += _ratio;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _token, uint32 _ratio, bool _enableVirtualBalance)"
      VariableDeclaration "_token"
         Type: contract IERC20Token
         Source: "IERC20Token _token"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_ratio"
         Type: uint32
         Source: "uint32 _ratio"
        ElementaryTypeName uint32
           Source: "uint32"
      VariableDeclaration "_enableVirtualBalance"
         Type: bool
         Source: "bool _enableVirtualBalance"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerOnly"
       Gas costs: 0
       Source: "ownerOnly"
      Identifier ownerOnly
         Type: modifier ()
         Source: "ownerOnly"
    ModifierInvocation "inactive"
       Gas costs: 0
       Source: "inactive"
      Identifier inactive
         Type: modifier ()
         Source: "inactive"
    ModifierInvocation "validAddress"
       Gas costs: 3
       Source: "validAddress(_token)"
      Identifier validAddress
         Type: modifier (address)
         Source: "validAddress"
      Identifier _token
         Type: contract IERC20Token
         Source: "_token"
    ModifierInvocation "notThis"
       Gas costs: 3
       Source: "notThis(_token)"
      Identifier notThis
         Type: modifier (address)
         Source: "notThis"
      Identifier _token
         Type: contract IERC20Token
         Source: "_token"
    ModifierInvocation "validReserveRatio"
       Gas costs: 3
       Source: "validReserveRatio(_ratio)"
      Identifier validReserveRatio
         Type: modifier (uint32)
         Source: "validReserveRatio"
      Identifier _ratio
         Type: uint32
         Source: "_ratio"
    Block
       Source: "{\r\n        require(_token != token && !reserves[_token].isSet && totalReserveRatio + _ratio <= MAX_CRR); // validate input\r\n\r\n        reserves[_token].virtualBalance = 0;\r\n        reserves[_token].ratio = _ratio;\r\n        reserves[_token].isVirtualBalanceEnabled = _enableVirtualBalance;\r\n        reserves[_token].isPurchaseEnabled = true;\r\n        reserves[_token].isSet = true;\r\n        reserveTokens.push(_token);\r\n        totalReserveRatio += _ratio;\r\n    }"
      ExpressionStatement
         Gas costs: 987
         Source: "require(_token != token && !reserves[_token].isSet && totalReserveRatio + _ratio <= MAX_CRR)"
        FunctionCall
           Type: tuple()
           Source: "require(_token != token && !reserves[_token].isSet && totalReserveRatio + _ratio <= MAX_CRR)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_token != token && !reserves[_token].isSet && totalReserveRatio + _ratio <= MAX_CRR"
            BinaryOperation using operator &&
               Type: bool
               Source: "_token != token && !reserves[_token].isSet"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "_token != token"
                Identifier _token
                   Type: contract IERC20Token
                   Source: "_token"
                Identifier token
                   Type: contract ISmartToken
                   Source: "token"
              UnaryOperation (prefix) !
                 Type: bool
                 Source: "!reserves[_token].isSet"
                MemberAccess to member isSet
                   Type: bool
                   Source: "reserves[_token].isSet"
                  IndexAccess
                     Type: struct BancorChanger.Reserve storage ref
                     Source: "reserves[_token]"
                    Identifier reserves
                       Type: mapping(address => struct BancorChanger.Reserve storage ref)
                       Source: "reserves"
                    Identifier _token
                       Type: contract IERC20Token
                       Source: "_token"
            BinaryOperation using operator <=
               Type: bool
               Source: "totalReserveRatio + _ratio <= MAX_CRR"
              BinaryOperation using operator +
                 Type: uint32
                 Source: "totalReserveRatio + _ratio"
                Identifier totalReserveRatio
                   Type: uint32
                   Source: "totalReserveRatio"
                Identifier _ratio
                   Type: uint32
                   Source: "_ratio"
              Identifier MAX_CRR
                 Type: uint32
                 Source: "MAX_CRR"
      ExpressionStatement
         Gas costs: 5116
         Source: "reserves[_token].virtualBalance = 0"
        Assignment using operator =
           Type: uint256
           Source: "reserves[_token].virtualBalance = 0"
          MemberAccess to member virtualBalance
             Type: uint256
             Source: "reserves[_token].virtualBalance"
            IndexAccess
               Type: struct BancorChanger.Reserve storage ref
               Source: "reserves[_token]"
              Identifier reserves
                 Type: mapping(address => struct BancorChanger.Reserve storage ref)
                 Source: "reserves"
              Identifier _token
                 Type: contract IERC20Token
                 Source: "_token"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 20363
         Source: "reserves[_token].ratio = _ratio"
        Assignment using operator =
           Type: uint32
           Source: "reserves[_token].ratio = _ratio"
          MemberAccess to member ratio
             Type: uint32
             Source: "reserves[_token].ratio"
            IndexAccess
               Type: struct BancorChanger.Reserve storage ref
               Source: "reserves[_token]"
              Identifier reserves
                 Type: mapping(address => struct BancorChanger.Reserve storage ref)
                 Source: "reserves"
              Identifier _token
                 Type: contract IERC20Token
                 Source: "_token"
          Identifier _ratio
             Type: uint32
             Source: "_ratio"
      ExpressionStatement
         Gas costs: 20413
         Source: "reserves[_token].isVirtualBalanceEnabled = _enableVirtualBalance"
        Assignment using operator =
           Type: bool
           Source: "reserves[_token].isVirtualBalanceEnabled = _enableVirtualBalance"
          MemberAccess to member isVirtualBalanceEnabled
             Type: bool
             Source: "reserves[_token].isVirtualBalanceEnabled"
            IndexAccess
               Type: struct BancorChanger.Reserve storage ref
               Source: "reserves[_token]"
              Identifier reserves
                 Type: mapping(address => struct BancorChanger.Reserve storage ref)
                 Source: "reserves"
              Identifier _token
                 Type: contract IERC20Token
                 Source: "_token"
          Identifier _enableVirtualBalance
             Type: bool
             Source: "_enableVirtualBalance"
      ExpressionStatement
         Gas costs: 20413
         Source: "reserves[_token].isPurchaseEnabled = true"
        Assignment using operator =
           Type: bool
           Source: "reserves[_token].isPurchaseEnabled = true"
          MemberAccess to member isPurchaseEnabled
             Type: bool
             Source: "reserves[_token].isPurchaseEnabled"
            IndexAccess
               Type: struct BancorChanger.Reserve storage ref
               Source: "reserves[_token]"
              Identifier reserves
                 Type: mapping(address => struct BancorChanger.Reserve storage ref)
                 Source: "reserves"
              Identifier _token
                 Type: contract IERC20Token
                 Source: "_token"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 20413
         Source: "reserves[_token].isSet = true"
        Assignment using operator =
           Type: bool
           Source: "reserves[_token].isSet = true"
          MemberAccess to member isSet
             Type: bool
             Source: "reserves[_token].isSet"
            IndexAccess
               Type: struct BancorChanger.Reserve storage ref
               Source: "reserves[_token]"
              Identifier reserves
                 Type: mapping(address => struct BancorChanger.Reserve storage ref)
                 Source: "reserves"
              Identifier _token
                 Type: contract IERC20Token
                 Source: "_token"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 20362
         Source: "reserveTokens.push(_token)"
        FunctionCall
           Type: uint256
           Source: "reserveTokens.push(_token)"
          MemberAccess to member push
             Type: function (contract IERC20Token) returns (uint256)
             Source: "reserveTokens.push"
            Identifier reserveTokens
               Type: contract IERC20Token[] storage ref
               Source: "reserveTokens"
          Identifier _token
             Type: contract IERC20Token
             Source: "_token"
      ExpressionStatement
         Gas costs: 20517
         Source: "totalReserveRatio += _ratio"
        Assignment using operator +=
           Type: uint32
           Source: "totalReserveRatio += _ratio"
          Identifier totalReserveRatio
             Type: uint32
             Source: "totalReserveRatio"
          Identifier _ratio
             Type: uint32
             Source: "_ratio"
  FunctionDefinition "updateReserve" - public
     Source: "function updateReserve(IERC20Token _reserveToken, uint32 _ratio, bool _enableVirtualBalance, uint256 _virtualBalance)\r\n        public\r\n        ownerOnly\r\n        validReserve(_reserveToken)\r\n        validReserveRatio(_ratio)\r\n    {\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        require(totalReserveRatio - reserve.ratio + _ratio <= MAX_CRR); // validate input\r\n\r\n        totalReserveRatio = totalReserveRatio - reserve.ratio + _ratio;\r\n        reserve.ratio = _ratio;\r\n        reserve.isVirtualBalanceEnabled = _enableVirtualBalance;\r\n        reserve.virtualBalance = _virtualBalance;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _reserveToken, uint32 _ratio, bool _enableVirtualBalance, uint256 _virtualBalance)"
      VariableDeclaration "_reserveToken"
         Type: contract IERC20Token
         Source: "IERC20Token _reserveToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_ratio"
         Type: uint32
         Source: "uint32 _ratio"
        ElementaryTypeName uint32
           Source: "uint32"
      VariableDeclaration "_enableVirtualBalance"
         Type: bool
         Source: "bool _enableVirtualBalance"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "_virtualBalance"
         Type: uint256
         Source: "uint256 _virtualBalance"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerOnly"
       Gas costs: 0
       Source: "ownerOnly"
      Identifier ownerOnly
         Type: modifier ()
         Source: "ownerOnly"
    ModifierInvocation "validReserve"
       Gas costs: 3
       Source: "validReserve(_reserveToken)"
      Identifier validReserve
         Type: modifier (contract IERC20Token)
         Source: "validReserve"
      Identifier _reserveToken
         Type: contract IERC20Token
         Source: "_reserveToken"
    ModifierInvocation "validReserveRatio"
       Gas costs: 3
       Source: "validReserveRatio(_ratio)"
      Identifier validReserveRatio
         Type: modifier (uint32)
         Source: "validReserveRatio"
      Identifier _ratio
         Type: uint32
         Source: "_ratio"
    Block
       Source: "{\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        require(totalReserveRatio - reserve.ratio + _ratio <= MAX_CRR); // validate input\r\n\r\n        totalReserveRatio = totalReserveRatio - reserve.ratio + _ratio;\r\n        reserve.ratio = _ratio;\r\n        reserve.isVirtualBalanceEnabled = _enableVirtualBalance;\r\n        reserve.virtualBalance = _virtualBalance;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 107
         Source: "Reserve storage reserve = reserves[_reserveToken]"
        VariableDeclaration "reserve"
           Type: struct BancorChanger.Reserve storage pointer
           Source: "Reserve storage reserve"
          UserDefinedTypeName "Reserve"
             Source: "Reserve"
        IndexAccess
           Type: struct BancorChanger.Reserve storage ref
           Source: "reserves[_reserveToken]"
          Identifier reserves
             Type: mapping(address => struct BancorChanger.Reserve storage ref)
             Source: "reserves"
          Identifier _reserveToken
             Type: contract IERC20Token
             Source: "_reserveToken"
      ExpressionStatement
         Gas costs: 537
         Source: "require(totalReserveRatio - reserve.ratio + _ratio <= MAX_CRR)"
        FunctionCall
           Type: tuple()
           Source: "require(totalReserveRatio - reserve.ratio + _ratio <= MAX_CRR)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "totalReserveRatio - reserve.ratio + _ratio <= MAX_CRR"
            BinaryOperation using operator +
               Type: uint32
               Source: "totalReserveRatio - reserve.ratio + _ratio"
              BinaryOperation using operator -
                 Type: uint32
                 Source: "totalReserveRatio - reserve.ratio"
                Identifier totalReserveRatio
                   Type: uint32
                   Source: "totalReserveRatio"
                MemberAccess to member ratio
                   Type: uint32
                   Source: "reserve.ratio"
                  Identifier reserve
                     Type: struct BancorChanger.Reserve storage pointer
                     Source: "reserve"
              Identifier _ratio
                 Type: uint32
                 Source: "_ratio"
            Identifier MAX_CRR
               Type: uint32
               Source: "MAX_CRR"
      ExpressionStatement
         Gas costs: 20757
         Source: "totalReserveRatio = totalReserveRatio - reserve.ratio + _ratio"
        Assignment using operator =
           Type: uint32
           Source: "totalReserveRatio = totalReserveRatio - reserve.ratio + _ratio"
          Identifier totalReserveRatio
             Type: uint32
             Source: "totalReserveRatio"
          BinaryOperation using operator +
             Type: uint32
             Source: "totalReserveRatio - reserve.ratio + _ratio"
            BinaryOperation using operator -
               Type: uint32
               Source: "totalReserveRatio - reserve.ratio"
              Identifier totalReserveRatio
                 Type: uint32
                 Source: "totalReserveRatio"
              MemberAccess to member ratio
                 Type: uint32
                 Source: "reserve.ratio"
                Identifier reserve
                   Type: struct BancorChanger.Reserve storage pointer
                   Source: "reserve"
            Identifier _ratio
               Type: uint32
               Source: "_ratio"
      ExpressionStatement
         Gas costs: 20273
         Source: "reserve.ratio = _ratio"
        Assignment using operator =
           Type: uint32
           Source: "reserve.ratio = _ratio"
          MemberAccess to member ratio
             Type: uint32
             Source: "reserve.ratio"
            Identifier reserve
               Type: struct BancorChanger.Reserve storage pointer
               Source: "reserve"
          Identifier _ratio
             Type: uint32
             Source: "_ratio"
      ExpressionStatement
         Gas costs: 20323
         Source: "reserve.isVirtualBalanceEnabled = _enableVirtualBalance"
        Assignment using operator =
           Type: bool
           Source: "reserve.isVirtualBalanceEnabled = _enableVirtualBalance"
          MemberAccess to member isVirtualBalanceEnabled
             Type: bool
             Source: "reserve.isVirtualBalanceEnabled"
            Identifier reserve
               Type: struct BancorChanger.Reserve storage pointer
               Source: "reserve"
          Identifier _enableVirtualBalance
             Type: bool
             Source: "_enableVirtualBalance"
      ExpressionStatement
         Gas costs: 20020
         Source: "reserve.virtualBalance = _virtualBalance"
        Assignment using operator =
           Type: uint256
           Source: "reserve.virtualBalance = _virtualBalance"
          MemberAccess to member virtualBalance
             Type: uint256
             Source: "reserve.virtualBalance"
            Identifier reserve
               Type: struct BancorChanger.Reserve storage pointer
               Source: "reserve"
          Identifier _virtualBalance
             Type: uint256
             Source: "_virtualBalance"
  FunctionDefinition "disableReservePurchases" - public
     Source: "function disableReservePurchases(IERC20Token _reserveToken, bool _disable)\r\n        public\r\n        ownerOnly\r\n        validReserve(_reserveToken)\r\n    {\r\n        reserves[_reserveToken].isPurchaseEnabled = !_disable;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _reserveToken, bool _disable)"
      VariableDeclaration "_reserveToken"
         Type: contract IERC20Token
         Source: "IERC20Token _reserveToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_disable"
         Type: bool
         Source: "bool _disable"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerOnly"
       Gas costs: 0
       Source: "ownerOnly"
      Identifier ownerOnly
         Type: modifier ()
         Source: "ownerOnly"
    ModifierInvocation "validReserve"
       Gas costs: 3
       Source: "validReserve(_reserveToken)"
      Identifier validReserve
         Type: modifier (contract IERC20Token)
         Source: "validReserve"
      Identifier _reserveToken
         Type: contract IERC20Token
         Source: "_reserveToken"
    Block
       Source: "{\r\n        reserves[_reserveToken].isPurchaseEnabled = !_disable;\r\n    }"
      ExpressionStatement
         Gas costs: 20422
         Source: "reserves[_reserveToken].isPurchaseEnabled = !_disable"
        Assignment using operator =
           Type: bool
           Source: "reserves[_reserveToken].isPurchaseEnabled = !_disable"
          MemberAccess to member isPurchaseEnabled
             Type: bool
             Source: "reserves[_reserveToken].isPurchaseEnabled"
            IndexAccess
               Type: struct BancorChanger.Reserve storage ref
               Source: "reserves[_reserveToken]"
              Identifier reserves
                 Type: mapping(address => struct BancorChanger.Reserve storage ref)
                 Source: "reserves"
              Identifier _reserveToken
                 Type: contract IERC20Token
                 Source: "_reserveToken"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!_disable"
            Identifier _disable
               Type: bool
               Source: "_disable"
  FunctionDefinition "getReserveBalance" - public - const
     Source: "function getReserveBalance(IERC20Token _reserveToken)\r\n        public\r\n        constant\r\n        validReserve(_reserveToken)\r\n        returns (uint256 balance)\r\n    {\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        return reserve.isVirtualBalanceEnabled ? reserve.virtualBalance : _reserveToken.balanceOf(this);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _reserveToken)"
      VariableDeclaration "_reserveToken"
         Type: contract IERC20Token
         Source: "IERC20Token _reserveToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    ModifierInvocation "validReserve"
       Gas costs: 3
       Source: "validReserve(_reserveToken)"
      Identifier validReserve
         Type: modifier (contract IERC20Token)
         Source: "validReserve"
      Identifier _reserveToken
         Type: contract IERC20Token
         Source: "_reserveToken"
    Block
       Source: "{\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        return reserve.isVirtualBalanceEnabled ? reserve.virtualBalance : _reserveToken.balanceOf(this);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 107
         Source: "Reserve storage reserve = reserves[_reserveToken]"
        VariableDeclaration "reserve"
           Type: struct BancorChanger.Reserve storage pointer
           Source: "Reserve storage reserve"
          UserDefinedTypeName "Reserve"
             Source: "Reserve"
        IndexAccess
           Type: struct BancorChanger.Reserve storage ref
           Source: "reserves[_reserveToken]"
          Identifier reserves
             Type: mapping(address => struct BancorChanger.Reserve storage ref)
             Source: "reserves"
          Identifier _reserveToken
             Type: contract IERC20Token
             Source: "_reserveToken"
      Return
         Gas costs: [???]
         Source: "return reserve.isVirtualBalanceEnabled ? reserve.virtualBalance : _reserveToken.balanceOf(this)"
        Conditional
           Type: uint256
           Source: "reserve.isVirtualBalanceEnabled ? reserve.virtualBalance : _reserveToken.balanceOf(this)"
          MemberAccess to member isVirtualBalanceEnabled
             Type: bool
             Source: "reserve.isVirtualBalanceEnabled"
            Identifier reserve
               Type: struct BancorChanger.Reserve storage pointer
               Source: "reserve"
          MemberAccess to member virtualBalance
             Type: uint256
             Source: "reserve.virtualBalance"
            Identifier reserve
               Type: struct BancorChanger.Reserve storage pointer
               Source: "reserve"
          FunctionCall
             Type: uint256
             Source: "_reserveToken.balanceOf(this)"
            MemberAccess to member balanceOf
               Type: function (address) view external returns (uint256)
               Source: "_reserveToken.balanceOf"
              Identifier _reserveToken
                 Type: contract IERC20Token
                 Source: "_reserveToken"
            Identifier this
               Type: contract BancorChanger
               Source: "this"
  FunctionDefinition "getReturn" - public - const
     Source: "function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public constant returns (uint256 amount) {\r\n        require(_fromToken != _toToken); // validate input\r\n\r\n        // change between the token and one of its reserves\r\n        if (_toToken == token)\r\n            return getPurchaseReturn(_fromToken, _amount);\r\n        else if (_fromToken == token)\r\n            return getSaleReturn(_toToken, _amount);\r\n\r\n        // change between 2 reserves\r\n        uint256 purchaseReturnAmount = getPurchaseReturn(_fromToken, _amount);\r\n        return getSaleReturn(_toToken, purchaseReturnAmount, safeAdd(token.totalSupply(), purchaseReturnAmount));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount)"
      VariableDeclaration "_fromToken"
         Type: contract IERC20Token
         Source: "IERC20Token _fromToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_toToken"
         Type: contract IERC20Token
         Source: "IERC20Token _toToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        require(_fromToken != _toToken); // validate input\r\n\r\n        // change between the token and one of its reserves\r\n        if (_toToken == token)\r\n            return getPurchaseReturn(_fromToken, _amount);\r\n        else if (_fromToken == token)\r\n            return getSaleReturn(_toToken, _amount);\r\n\r\n        // change between 2 reserves\r\n        uint256 purchaseReturnAmount = getPurchaseReturn(_fromToken, _amount);\r\n        return getSaleReturn(_toToken, purchaseReturnAmount, safeAdd(token.totalSupply(), purchaseReturnAmount));\r\n    }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(_fromToken != _toToken)"
        FunctionCall
           Type: tuple()
           Source: "require(_fromToken != _toToken)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_fromToken != _toToken"
            Identifier _fromToken
               Type: contract IERC20Token
               Source: "_fromToken"
            Identifier _toToken
               Type: contract IERC20Token
               Source: "_toToken"
      IfStatement
         Source: "if (_toToken == token)\r\n            return getPurchaseReturn(_fromToken, _amount);\r\n        else if (_fromToken == token)\r\n            return getSaleReturn(_toToken, _amount)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 257
           Source: "_toToken == token"
          Identifier _toToken
             Type: contract IERC20Token
             Source: "_toToken"
          Identifier token
             Type: contract ISmartToken
             Source: "token"
        Return
           Gas costs: 37
           Source: "return getPurchaseReturn(_fromToken, _amount)"
          FunctionCall
             Type: uint256
             Source: "getPurchaseReturn(_fromToken, _amount)"
            Identifier getPurchaseReturn
               Type: function (contract IERC20Token,uint256) view returns (uint256)
               Source: "getPurchaseReturn"
            Identifier _fromToken
               Type: contract IERC20Token
               Source: "_fromToken"
            Identifier _amount
               Type: uint256
               Source: "_amount"
        IfStatement
           Source: "if (_fromToken == token)\r\n            return getSaleReturn(_toToken, _amount)"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 257
             Source: "_fromToken == token"
            Identifier _fromToken
               Type: contract IERC20Token
               Source: "_fromToken"
            Identifier token
               Type: contract ISmartToken
               Source: "token"
          Return
             Gas costs: 37
             Source: "return getSaleReturn(_toToken, _amount)"
            FunctionCall
               Type: uint256
               Source: "getSaleReturn(_toToken, _amount)"
              Identifier getSaleReturn
                 Type: function (contract IERC20Token,uint256) view returns (uint256)
                 Source: "getSaleReturn"
              Identifier _toToken
                 Type: contract IERC20Token
                 Source: "_toToken"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
      VariableDeclarationStatement
         Gas costs: 29
         Source: "uint256 purchaseReturnAmount = getPurchaseReturn(_fromToken, _amount)"
        VariableDeclaration "purchaseReturnAmount"
           Type: uint256
           Source: "uint256 purchaseReturnAmount"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "getPurchaseReturn(_fromToken, _amount)"
          Identifier getPurchaseReturn
             Type: function (contract IERC20Token,uint256) view returns (uint256)
             Source: "getPurchaseReturn"
          Identifier _fromToken
             Type: contract IERC20Token
             Source: "_fromToken"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: [???]
         Source: "return getSaleReturn(_toToken, purchaseReturnAmount, safeAdd(token.totalSupply(), purchaseReturnAmount))"
        FunctionCall
           Type: uint256
           Source: "getSaleReturn(_toToken, purchaseReturnAmount, safeAdd(token.totalSupply(), purchaseReturnAmount))"
          Identifier getSaleReturn
             Type: function (contract IERC20Token,uint256,uint256) view returns (uint256)
             Source: "getSaleReturn"
          Identifier _toToken
             Type: contract IERC20Token
             Source: "_toToken"
          Identifier purchaseReturnAmount
             Type: uint256
             Source: "purchaseReturnAmount"
          FunctionCall
             Type: uint256
             Source: "safeAdd(token.totalSupply(), purchaseReturnAmount)"
            Identifier safeAdd
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeAdd"
            FunctionCall
               Type: uint256
               Source: "token.totalSupply()"
              MemberAccess to member totalSupply
                 Type: function () view external returns (uint256)
                 Source: "token.totalSupply"
                Identifier token
                   Type: contract ISmartToken
                   Source: "token"
            Identifier purchaseReturnAmount
               Type: uint256
               Source: "purchaseReturnAmount"
  FunctionDefinition "getPurchaseReturn" - public - const
     Source: "function getPurchaseReturn(IERC20Token _reserveToken, uint256 _depositAmount)\r\n        public\r\n        constant\r\n        active\r\n        validReserve(_reserveToken)\r\n        returns (uint256 amount)\r\n    {\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        require(reserve.isPurchaseEnabled); // validate input\r\n\r\n        uint256 tokenSupply = token.totalSupply();\r\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\r\n        amount = formula.calculatePurchaseReturn(tokenSupply, reserveBalance, reserve.ratio, _depositAmount);\r\n\r\n        // deduct the fee from the return amount\r\n        uint256 feeAmount = getChangeFeeAmount(amount);\r\n        return safeSub(amount, feeAmount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _reserveToken, uint256 _depositAmount)"
      VariableDeclaration "_reserveToken"
         Type: contract IERC20Token
         Source: "IERC20Token _reserveToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_depositAmount"
         Type: uint256
         Source: "uint256 _depositAmount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ModifierInvocation "active"
       Gas costs: 0
       Source: "active"
      Identifier active
         Type: modifier ()
         Source: "active"
    ModifierInvocation "validReserve"
       Gas costs: 3
       Source: "validReserve(_reserveToken)"
      Identifier validReserve
         Type: modifier (contract IERC20Token)
         Source: "validReserve"
      Identifier _reserveToken
         Type: contract IERC20Token
         Source: "_reserveToken"
    Block
       Source: "{\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        require(reserve.isPurchaseEnabled); // validate input\r\n\r\n        uint256 tokenSupply = token.totalSupply();\r\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\r\n        amount = formula.calculatePurchaseReturn(tokenSupply, reserveBalance, reserve.ratio, _depositAmount);\r\n\r\n        // deduct the fee from the return amount\r\n        uint256 feeAmount = getChangeFeeAmount(amount);\r\n        return safeSub(amount, feeAmount);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 107
         Source: "Reserve storage reserve = reserves[_reserveToken]"
        VariableDeclaration "reserve"
           Type: struct BancorChanger.Reserve storage pointer
           Source: "Reserve storage reserve"
          UserDefinedTypeName "Reserve"
             Source: "Reserve"
        IndexAccess
           Type: struct BancorChanger.Reserve storage ref
           Source: "reserves[_reserveToken]"
          Identifier reserves
             Type: mapping(address => struct BancorChanger.Reserve storage ref)
             Source: "reserves"
          Identifier _reserveToken
             Type: contract IERC20Token
             Source: "_reserveToken"
      ExpressionStatement
         Gas costs: 321
         Source: "require(reserve.isPurchaseEnabled)"
        FunctionCall
           Type: tuple()
           Source: "require(reserve.isPurchaseEnabled)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          MemberAccess to member isPurchaseEnabled
             Type: bool
             Source: "reserve.isPurchaseEnabled"
            Identifier reserve
               Type: struct BancorChanger.Reserve storage pointer
               Source: "reserve"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint256 tokenSupply = token.totalSupply()"
        VariableDeclaration "tokenSupply"
           Type: uint256
           Source: "uint256 tokenSupply"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "token.totalSupply()"
          MemberAccess to member totalSupply
             Type: function () view external returns (uint256)
             Source: "token.totalSupply"
            Identifier token
               Type: contract ISmartToken
               Source: "token"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint256 reserveBalance = getReserveBalance(_reserveToken)"
        VariableDeclaration "reserveBalance"
           Type: uint256
           Source: "uint256 reserveBalance"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "getReserveBalance(_reserveToken)"
          Identifier getReserveBalance
             Type: function (contract IERC20Token) view returns (uint256)
             Source: "getReserveBalance"
          Identifier _reserveToken
             Type: contract IERC20Token
             Source: "_reserveToken"
      ExpressionStatement
         Gas costs: [???]
         Source: "amount = formula.calculatePurchaseReturn(tokenSupply, reserveBalance, reserve.ratio, _depositAmount)"
        Assignment using operator =
           Type: uint256
           Source: "amount = formula.calculatePurchaseReturn(tokenSupply, reserveBalance, reserve.ratio, _depositAmount)"
          Identifier amount
             Type: uint256
             Source: "amount"
          FunctionCall
             Type: uint256
             Source: "formula.calculatePurchaseReturn(tokenSupply, reserveBalance, reserve.ratio, _depositAmount)"
            MemberAccess to member calculatePurchaseReturn
               Type: function (uint256,uint256,uint32,uint256) view external returns (uint256)
               Source: "formula.calculatePurchaseReturn"
              Identifier formula
                 Type: contract IBancorFormula
                 Source: "formula"
            Identifier tokenSupply
               Type: uint256
               Source: "tokenSupply"
            Identifier reserveBalance
               Type: uint256
               Source: "reserveBalance"
            MemberAccess to member ratio
               Type: uint32
               Source: "reserve.ratio"
              Identifier reserve
                 Type: struct BancorChanger.Reserve storage pointer
                 Source: "reserve"
            Identifier _depositAmount
               Type: uint256
               Source: "_depositAmount"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint256 feeAmount = getChangeFeeAmount(amount)"
        VariableDeclaration "feeAmount"
           Type: uint256
           Source: "uint256 feeAmount"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "getChangeFeeAmount(amount)"
          Identifier getChangeFeeAmount
             Type: function (uint256) view returns (uint256)
             Source: "getChangeFeeAmount"
          Identifier amount
             Type: uint256
             Source: "amount"
      Return
         Gas costs: 15
         Source: "return safeSub(amount, feeAmount)"
        FunctionCall
           Type: uint256
           Source: "safeSub(amount, feeAmount)"
          Identifier safeSub
             Type: function (uint256,uint256) returns (uint256)
             Source: "safeSub"
          Identifier amount
             Type: uint256
             Source: "amount"
          Identifier feeAmount
             Type: uint256
             Source: "feeAmount"
  FunctionDefinition "getSaleReturn" - public - const
     Source: "function getSaleReturn(IERC20Token _reserveToken, uint256 _sellAmount) public constant returns (uint256 amount) {\r\n        return getSaleReturn(_reserveToken, _sellAmount, token.totalSupply());\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _reserveToken, uint256 _sellAmount)"
      VariableDeclaration "_reserveToken"
         Type: contract IERC20Token
         Source: "IERC20Token _reserveToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_sellAmount"
         Type: uint256
         Source: "uint256 _sellAmount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return getSaleReturn(_reserveToken, _sellAmount, token.totalSupply());\r\n    }"
      Return
         Gas costs: [???]
         Source: "return getSaleReturn(_reserveToken, _sellAmount, token.totalSupply())"
        FunctionCall
           Type: uint256
           Source: "getSaleReturn(_reserveToken, _sellAmount, token.totalSupply())"
          Identifier getSaleReturn
             Type: function (contract IERC20Token,uint256,uint256) view returns (uint256)
             Source: "getSaleReturn"
          Identifier _reserveToken
             Type: contract IERC20Token
             Source: "_reserveToken"
          Identifier _sellAmount
             Type: uint256
             Source: "_sellAmount"
          FunctionCall
             Type: uint256
             Source: "token.totalSupply()"
            MemberAccess to member totalSupply
               Type: function () view external returns (uint256)
               Source: "token.totalSupply"
              Identifier token
                 Type: contract ISmartToken
                 Source: "token"
  FunctionDefinition "change" - public
     Source: "function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 amount) {\r\n        require(_fromToken != _toToken); // validate input\r\n\r\n        // change between the token and one of its reserves\r\n        if (_toToken == token)\r\n            return buy(_fromToken, _amount, _minReturn);\r\n        else if (_fromToken == token)\r\n            return sell(_toToken, _amount, _minReturn);\r\n\r\n        // change between 2 reserves\r\n        uint256 purchaseAmount = buy(_fromToken, _amount, 1);\r\n        return sell(_toToken, purchaseAmount, _minReturn);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn)"
      VariableDeclaration "_fromToken"
         Type: contract IERC20Token
         Source: "IERC20Token _fromToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_toToken"
         Type: contract IERC20Token
         Source: "IERC20Token _toToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_minReturn"
         Type: uint256
         Source: "uint256 _minReturn"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        require(_fromToken != _toToken); // validate input\r\n\r\n        // change between the token and one of its reserves\r\n        if (_toToken == token)\r\n            return buy(_fromToken, _amount, _minReturn);\r\n        else if (_fromToken == token)\r\n            return sell(_toToken, _amount, _minReturn);\r\n\r\n        // change between 2 reserves\r\n        uint256 purchaseAmount = buy(_fromToken, _amount, 1);\r\n        return sell(_toToken, purchaseAmount, _minReturn);\r\n    }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(_fromToken != _toToken)"
        FunctionCall
           Type: tuple()
           Source: "require(_fromToken != _toToken)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_fromToken != _toToken"
            Identifier _fromToken
               Type: contract IERC20Token
               Source: "_fromToken"
            Identifier _toToken
               Type: contract IERC20Token
               Source: "_toToken"
      IfStatement
         Source: "if (_toToken == token)\r\n            return buy(_fromToken, _amount, _minReturn);\r\n        else if (_fromToken == token)\r\n            return sell(_toToken, _amount, _minReturn)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 257
           Source: "_toToken == token"
          Identifier _toToken
             Type: contract IERC20Token
             Source: "_toToken"
          Identifier token
             Type: contract ISmartToken
             Source: "token"
        Return
           Gas costs: 40
           Source: "return buy(_fromToken, _amount, _minReturn)"
          FunctionCall
             Type: uint256
             Source: "buy(_fromToken, _amount, _minReturn)"
            Identifier buy
               Type: function (contract IERC20Token,uint256,uint256) returns (uint256)
               Source: "buy"
            Identifier _fromToken
               Type: contract IERC20Token
               Source: "_fromToken"
            Identifier _amount
               Type: uint256
               Source: "_amount"
            Identifier _minReturn
               Type: uint256
               Source: "_minReturn"
        IfStatement
           Source: "if (_fromToken == token)\r\n            return sell(_toToken, _amount, _minReturn)"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 257
             Source: "_fromToken == token"
            Identifier _fromToken
               Type: contract IERC20Token
               Source: "_fromToken"
            Identifier token
               Type: contract ISmartToken
               Source: "token"
          Return
             Gas costs: 40
             Source: "return sell(_toToken, _amount, _minReturn)"
            FunctionCall
               Type: uint256
               Source: "sell(_toToken, _amount, _minReturn)"
              Identifier sell
                 Type: function (contract IERC20Token,uint256,uint256) returns (uint256)
                 Source: "sell"
              Identifier _toToken
                 Type: contract IERC20Token
                 Source: "_toToken"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
              Identifier _minReturn
                 Type: uint256
                 Source: "_minReturn"
      VariableDeclarationStatement
         Gas costs: 32
         Source: "uint256 purchaseAmount = buy(_fromToken, _amount, 1)"
        VariableDeclaration "purchaseAmount"
           Type: uint256
           Source: "uint256 purchaseAmount"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "buy(_fromToken, _amount, 1)"
          Identifier buy
             Type: function (contract IERC20Token,uint256,uint256) returns (uint256)
             Source: "buy"
          Identifier _fromToken
             Type: contract IERC20Token
             Source: "_fromToken"
          Identifier _amount
             Type: uint256
             Source: "_amount"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      Return
         Gas costs: 29
         Source: "return sell(_toToken, purchaseAmount, _minReturn)"
        FunctionCall
           Type: uint256
           Source: "sell(_toToken, purchaseAmount, _minReturn)"
          Identifier sell
             Type: function (contract IERC20Token,uint256,uint256) returns (uint256)
             Source: "sell"
          Identifier _toToken
             Type: contract IERC20Token
             Source: "_toToken"
          Identifier purchaseAmount
             Type: uint256
             Source: "purchaseAmount"
          Identifier _minReturn
             Type: uint256
             Source: "_minReturn"
  FunctionDefinition "buy" - public
     Source: "function buy(IERC20Token _reserveToken, uint256 _depositAmount, uint256 _minReturn)\r\n        public\r\n        changingAllowed\r\n        greaterThanZero(_minReturn)\r\n        returns (uint256 amount)\r\n    {\r\n        amount = getPurchaseReturn(_reserveToken, _depositAmount);\r\n        assert(amount != 0 && amount >= _minReturn); // ensure the trade gives something in return and meets the minimum requested amount\r\n\r\n        // update virtual balance if relevant\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        if (reserve.isVirtualBalanceEnabled)\r\n            reserve.virtualBalance = safeAdd(reserve.virtualBalance, _depositAmount);\r\n\r\n        // transfer _depositAmount funds from the caller in the reserve token\r\n        // note that there's no need to execute the transfer if the sender is the local contract\r\n        if (msg.sender != address(this))\r\n            assert(_reserveToken.transferFrom(msg.sender, this, _depositAmount));\r\n        // issue new funds to the caller in the smart token\r\n        token.issue(msg.sender, amount);\r\n\r\n        // calculate the new price using the simple price formula\r\n        // price = reserve balance / (supply * CRR)\r\n        // CRR is represented in ppm, so multiplying by 1000000\r\n        uint256 reserveAmount = safeMul(getReserveBalance(_reserveToken), MAX_CRR);\r\n        uint256 tokenAmount = safeMul(token.totalSupply(), reserve.ratio);\r\n        Change(_reserveToken, token, msg.sender, _depositAmount, amount, reserveAmount, tokenAmount);\r\n        return amount;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _reserveToken, uint256 _depositAmount, uint256 _minReturn)"
      VariableDeclaration "_reserveToken"
         Type: contract IERC20Token
         Source: "IERC20Token _reserveToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_depositAmount"
         Type: uint256
         Source: "uint256 _depositAmount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_minReturn"
         Type: uint256
         Source: "uint256 _minReturn"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ModifierInvocation "changingAllowed"
       Gas costs: 0
       Source: "changingAllowed"
      Identifier changingAllowed
         Type: modifier ()
         Source: "changingAllowed"
    ModifierInvocation "greaterThanZero"
       Gas costs: 3
       Source: "greaterThanZero(_minReturn)"
      Identifier greaterThanZero
         Type: modifier (uint256)
         Source: "greaterThanZero"
      Identifier _minReturn
         Type: uint256
         Source: "_minReturn"
    Block
       Source: "{\r\n        amount = getPurchaseReturn(_reserveToken, _depositAmount);\r\n        assert(amount != 0 && amount >= _minReturn); // ensure the trade gives something in return and meets the minimum requested amount\r\n\r\n        // update virtual balance if relevant\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        if (reserve.isVirtualBalanceEnabled)\r\n            reserve.virtualBalance = safeAdd(reserve.virtualBalance, _depositAmount);\r\n\r\n        // transfer _depositAmount funds from the caller in the reserve token\r\n        // note that there's no need to execute the transfer if the sender is the local contract\r\n        if (msg.sender != address(this))\r\n            assert(_reserveToken.transferFrom(msg.sender, this, _depositAmount));\r\n        // issue new funds to the caller in the smart token\r\n        token.issue(msg.sender, amount);\r\n\r\n        // calculate the new price using the simple price formula\r\n        // price = reserve balance / (supply * CRR)\r\n        // CRR is represented in ppm, so multiplying by 1000000\r\n        uint256 reserveAmount = safeMul(getReserveBalance(_reserveToken), MAX_CRR);\r\n        uint256 tokenAmount = safeMul(token.totalSupply(), reserve.ratio);\r\n        Change(_reserveToken, token, msg.sender, _depositAmount, amount, reserveAmount, tokenAmount);\r\n        return amount;\r\n    }"
      ExpressionStatement
         Gas costs: 26
         Source: "amount = getPurchaseReturn(_reserveToken, _depositAmount)"
        Assignment using operator =
           Type: uint256
           Source: "amount = getPurchaseReturn(_reserveToken, _depositAmount)"
          Identifier amount
             Type: uint256
             Source: "amount"
          FunctionCall
             Type: uint256
             Source: "getPurchaseReturn(_reserveToken, _depositAmount)"
            Identifier getPurchaseReturn
               Type: function (contract IERC20Token,uint256) view returns (uint256)
               Source: "getPurchaseReturn"
            Identifier _reserveToken
               Type: contract IERC20Token
               Source: "_reserveToken"
            Identifier _depositAmount
               Type: uint256
               Source: "_depositAmount"
      ExpressionStatement
         Gas costs: 66
         Source: "assert(amount != 0 && amount >= _minReturn)"
        FunctionCall
           Type: tuple()
           Source: "assert(amount != 0 && amount >= _minReturn)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator &&
             Type: bool
             Source: "amount != 0 && amount >= _minReturn"
            BinaryOperation using operator !=
               Type: bool
               Source: "amount != 0"
              Identifier amount
                 Type: uint256
                 Source: "amount"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator >=
               Type: bool
               Source: "amount >= _minReturn"
              Identifier amount
                 Type: uint256
                 Source: "amount"
              Identifier _minReturn
                 Type: uint256
                 Source: "_minReturn"
      VariableDeclarationStatement
         Gas costs: 107
         Source: "Reserve storage reserve = reserves[_reserveToken]"
        VariableDeclaration "reserve"
           Type: struct BancorChanger.Reserve storage pointer
           Source: "Reserve storage reserve"
          UserDefinedTypeName "Reserve"
             Source: "Reserve"
        IndexAccess
           Type: struct BancorChanger.Reserve storage ref
           Source: "reserves[_reserveToken]"
          Identifier reserves
             Type: mapping(address => struct BancorChanger.Reserve storage ref)
             Source: "reserves"
          Identifier _reserveToken
             Type: contract IERC20Token
             Source: "_reserveToken"
      IfStatement
         Source: "if (reserve.isVirtualBalanceEnabled)\r\n            reserve.virtualBalance = safeAdd(reserve.virtualBalance, _depositAmount)"
        MemberAccess to member isVirtualBalanceEnabled
           Type: bool
           Gas costs: 295
           Source: "reserve.isVirtualBalanceEnabled"
          Identifier reserve
             Type: struct BancorChanger.Reserve storage pointer
             Source: "reserve"
        ExpressionStatement
           Gas costs: 20244
           Source: "reserve.virtualBalance = safeAdd(reserve.virtualBalance, _depositAmount)"
          Assignment using operator =
             Type: uint256
             Source: "reserve.virtualBalance = safeAdd(reserve.virtualBalance, _depositAmount)"
            MemberAccess to member virtualBalance
               Type: uint256
               Source: "reserve.virtualBalance"
              Identifier reserve
                 Type: struct BancorChanger.Reserve storage pointer
                 Source: "reserve"
            FunctionCall
               Type: uint256
               Source: "safeAdd(reserve.virtualBalance, _depositAmount)"
              Identifier safeAdd
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "safeAdd"
              MemberAccess to member virtualBalance
                 Type: uint256
                 Source: "reserve.virtualBalance"
                Identifier reserve
                   Type: struct BancorChanger.Reserve storage pointer
                   Source: "reserve"
              Identifier _depositAmount
                 Type: uint256
                 Source: "_depositAmount"
      IfStatement
         Source: "if (msg.sender != address(this))\r\n            assert(_reserveToken.transferFrom(msg.sender, this, _depositAmount))"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 22
           Source: "msg.sender != address(this)"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          FunctionCall
             Type: address
             Source: "address(this)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier this
               Type: contract BancorChanger
               Source: "this"
        ExpressionStatement
           Gas costs: [???]
           Source: "assert(_reserveToken.transferFrom(msg.sender, this, _depositAmount))"
          FunctionCall
             Type: tuple()
             Source: "assert(_reserveToken.transferFrom(msg.sender, this, _depositAmount))"
            Identifier assert
               Type: function (bool) pure
               Source: "assert"
            FunctionCall
               Type: bool
               Source: "_reserveToken.transferFrom(msg.sender, this, _depositAmount)"
              MemberAccess to member transferFrom
                 Type: function (address,address,uint256) external returns (bool)
                 Source: "_reserveToken.transferFrom"
                Identifier _reserveToken
                   Type: contract IERC20Token
                   Source: "_reserveToken"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier this
                 Type: contract BancorChanger
                 Source: "this"
              Identifier _depositAmount
                 Type: uint256
                 Source: "_depositAmount"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.issue(msg.sender, amount)"
        FunctionCall
           Type: tuple()
           Source: "token.issue(msg.sender, amount)"
          MemberAccess to member issue
             Type: function (address,uint256) external
             Source: "token.issue"
            Identifier token
               Type: contract ISmartToken
               Source: "token"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier amount
             Type: uint256
             Source: "amount"
      VariableDeclarationStatement
         Gas costs: 47
         Source: "uint256 reserveAmount = safeMul(getReserveBalance(_reserveToken), MAX_CRR)"
        VariableDeclaration "reserveAmount"
           Type: uint256
           Source: "uint256 reserveAmount"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "safeMul(getReserveBalance(_reserveToken), MAX_CRR)"
          Identifier safeMul
             Type: function (uint256,uint256) returns (uint256)
             Source: "safeMul"
          FunctionCall
             Type: uint256
             Source: "getReserveBalance(_reserveToken)"
            Identifier getReserveBalance
               Type: function (contract IERC20Token) view returns (uint256)
               Source: "getReserveBalance"
            Identifier _reserveToken
               Type: contract IERC20Token
               Source: "_reserveToken"
          Identifier MAX_CRR
             Type: uint32
             Source: "MAX_CRR"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint256 tokenAmount = safeMul(token.totalSupply(), reserve.ratio)"
        VariableDeclaration "tokenAmount"
           Type: uint256
           Source: "uint256 tokenAmount"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "safeMul(token.totalSupply(), reserve.ratio)"
          Identifier safeMul
             Type: function (uint256,uint256) returns (uint256)
             Source: "safeMul"
          FunctionCall
             Type: uint256
             Source: "token.totalSupply()"
            MemberAccess to member totalSupply
               Type: function () view external returns (uint256)
               Source: "token.totalSupply"
              Identifier token
                 Type: contract ISmartToken
                 Source: "token"
          MemberAccess to member ratio
             Type: uint32
             Source: "reserve.ratio"
            Identifier reserve
               Type: struct BancorChanger.Reserve storage pointer
               Source: "reserve"
      ExpressionStatement
         Gas costs: [???]
         Source: "Change(_reserveToken, token, msg.sender, _depositAmount, amount, reserveAmount, tokenAmount)"
        FunctionCall
           Type: tuple()
           Source: "Change(_reserveToken, token, msg.sender, _depositAmount, amount, reserveAmount, tokenAmount)"
          Identifier Change
             Type: function (address,address,address,uint256,uint256,uint256,uint256)
             Source: "Change"
          Identifier _reserveToken
             Type: contract IERC20Token
             Source: "_reserveToken"
          Identifier token
             Type: contract ISmartToken
             Source: "token"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _depositAmount
             Type: uint256
             Source: "_depositAmount"
          Identifier amount
             Type: uint256
             Source: "amount"
          Identifier reserveAmount
             Type: uint256
             Source: "reserveAmount"
          Identifier tokenAmount
             Type: uint256
             Source: "tokenAmount"
      Return
         Gas costs: 8
         Source: "return amount"
        Identifier amount
           Type: uint256
           Source: "amount"
  FunctionDefinition "sell" - public
     Source: "function sell(IERC20Token _reserveToken, uint256 _sellAmount, uint256 _minReturn)\r\n        public\r\n        changingAllowed\r\n        greaterThanZero(_minReturn)\r\n        returns (uint256 amount)\r\n    {\r\n        require(_sellAmount <= token.balanceOf(msg.sender)); // validate input\r\n\r\n        amount = getSaleReturn(_reserveToken, _sellAmount);\r\n        assert(amount != 0 && amount >= _minReturn); // ensure the trade gives something in return and meets the minimum requested amount\r\n\r\n        uint256 tokenSupply = token.totalSupply();\r\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\r\n        // ensure that the trade will only deplete the reserve if the total supply is depleted as well\r\n        assert(amount < reserveBalance || (amount == reserveBalance && _sellAmount == tokenSupply));\r\n\r\n        // update virtual balance if relevant\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        if (reserve.isVirtualBalanceEnabled)\r\n            reserve.virtualBalance = safeSub(reserve.virtualBalance, amount);\r\n\r\n        // destroy _sellAmount from the caller's balance in the smart token\r\n        token.destroy(msg.sender, _sellAmount);\r\n        // transfer funds to the caller in the reserve token\r\n        // the transfer might fail if the actual reserve balance is smaller than the virtual balance\r\n        // note that there's no need to execute the transfer if the sender is the local contract\r\n        if (msg.sender != address(this))\r\n            assert(_reserveToken.transfer(msg.sender, amount));\r\n\r\n        // calculate the new price using the simple price formula\r\n        // price = reserve balance / (supply * CRR)\r\n        // CRR is represented in ppm, so multiplying by 1000000\r\n        uint256 reserveAmount = safeMul(getReserveBalance(_reserveToken), MAX_CRR);\r\n        uint256 tokenAmount = safeMul(token.totalSupply(), reserve.ratio);\r\n        Change(token, _reserveToken, msg.sender, _sellAmount, amount, tokenAmount, reserveAmount);\r\n        return amount;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _reserveToken, uint256 _sellAmount, uint256 _minReturn)"
      VariableDeclaration "_reserveToken"
         Type: contract IERC20Token
         Source: "IERC20Token _reserveToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_sellAmount"
         Type: uint256
         Source: "uint256 _sellAmount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_minReturn"
         Type: uint256
         Source: "uint256 _minReturn"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ModifierInvocation "changingAllowed"
       Gas costs: 0
       Source: "changingAllowed"
      Identifier changingAllowed
         Type: modifier ()
         Source: "changingAllowed"
    ModifierInvocation "greaterThanZero"
       Gas costs: 3
       Source: "greaterThanZero(_minReturn)"
      Identifier greaterThanZero
         Type: modifier (uint256)
         Source: "greaterThanZero"
      Identifier _minReturn
         Type: uint256
         Source: "_minReturn"
    Block
       Source: "{\r\n        require(_sellAmount <= token.balanceOf(msg.sender)); // validate input\r\n\r\n        amount = getSaleReturn(_reserveToken, _sellAmount);\r\n        assert(amount != 0 && amount >= _minReturn); // ensure the trade gives something in return and meets the minimum requested amount\r\n\r\n        uint256 tokenSupply = token.totalSupply();\r\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\r\n        // ensure that the trade will only deplete the reserve if the total supply is depleted as well\r\n        assert(amount < reserveBalance || (amount == reserveBalance && _sellAmount == tokenSupply));\r\n\r\n        // update virtual balance if relevant\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        if (reserve.isVirtualBalanceEnabled)\r\n            reserve.virtualBalance = safeSub(reserve.virtualBalance, amount);\r\n\r\n        // destroy _sellAmount from the caller's balance in the smart token\r\n        token.destroy(msg.sender, _sellAmount);\r\n        // transfer funds to the caller in the reserve token\r\n        // the transfer might fail if the actual reserve balance is smaller than the virtual balance\r\n        // note that there's no need to execute the transfer if the sender is the local contract\r\n        if (msg.sender != address(this))\r\n            assert(_reserveToken.transfer(msg.sender, amount));\r\n\r\n        // calculate the new price using the simple price formula\r\n        // price = reserve balance / (supply * CRR)\r\n        // CRR is represented in ppm, so multiplying by 1000000\r\n        uint256 reserveAmount = safeMul(getReserveBalance(_reserveToken), MAX_CRR);\r\n        uint256 tokenAmount = safeMul(token.totalSupply(), reserve.ratio);\r\n        Change(token, _reserveToken, msg.sender, _sellAmount, amount, tokenAmount, reserveAmount);\r\n        return amount;\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(_sellAmount <= token.balanceOf(msg.sender))"
        FunctionCall
           Type: tuple()
           Source: "require(_sellAmount <= token.balanceOf(msg.sender))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_sellAmount <= token.balanceOf(msg.sender)"
            Identifier _sellAmount
               Type: uint256
               Source: "_sellAmount"
            FunctionCall
               Type: uint256
               Source: "token.balanceOf(msg.sender)"
              MemberAccess to member balanceOf
                 Type: function (address) view external returns (uint256)
                 Source: "token.balanceOf"
                Identifier token
                   Type: contract ISmartToken
                   Source: "token"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 26
         Source: "amount = getSaleReturn(_reserveToken, _sellAmount)"
        Assignment using operator =
           Type: uint256
           Source: "amount = getSaleReturn(_reserveToken, _sellAmount)"
          Identifier amount
             Type: uint256
             Source: "amount"
          FunctionCall
             Type: uint256
             Source: "getSaleReturn(_reserveToken, _sellAmount)"
            Identifier getSaleReturn
               Type: function (contract IERC20Token,uint256) view returns (uint256)
               Source: "getSaleReturn"
            Identifier _reserveToken
               Type: contract IERC20Token
               Source: "_reserveToken"
            Identifier _sellAmount
               Type: uint256
               Source: "_sellAmount"
      ExpressionStatement
         Gas costs: 66
         Source: "assert(amount != 0 && amount >= _minReturn)"
        FunctionCall
           Type: tuple()
           Source: "assert(amount != 0 && amount >= _minReturn)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator &&
             Type: bool
             Source: "amount != 0 && amount >= _minReturn"
            BinaryOperation using operator !=
               Type: bool
               Source: "amount != 0"
              Identifier amount
                 Type: uint256
                 Source: "amount"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator >=
               Type: bool
               Source: "amount >= _minReturn"
              Identifier amount
                 Type: uint256
                 Source: "amount"
              Identifier _minReturn
                 Type: uint256
                 Source: "_minReturn"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint256 tokenSupply = token.totalSupply()"
        VariableDeclaration "tokenSupply"
           Type: uint256
           Source: "uint256 tokenSupply"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "token.totalSupply()"
          MemberAccess to member totalSupply
             Type: function () view external returns (uint256)
             Source: "token.totalSupply"
            Identifier token
               Type: contract ISmartToken
               Source: "token"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint256 reserveBalance = getReserveBalance(_reserveToken)"
        VariableDeclaration "reserveBalance"
           Type: uint256
           Source: "uint256 reserveBalance"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "getReserveBalance(_reserveToken)"
          Identifier getReserveBalance
             Type: function (contract IERC20Token) view returns (uint256)
             Source: "getReserveBalance"
          Identifier _reserveToken
             Type: contract IERC20Token
             Source: "_reserveToken"
      ExpressionStatement
         Gas costs: 88
         Source: "assert(amount < reserveBalance || (amount == reserveBalance && _sellAmount == tokenSupply))"
        FunctionCall
           Type: tuple()
           Source: "assert(amount < reserveBalance || (amount == reserveBalance && _sellAmount == tokenSupply))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "amount < reserveBalance || (amount == reserveBalance && _sellAmount == tokenSupply)"
            BinaryOperation using operator <
               Type: bool
               Source: "amount < reserveBalance"
              Identifier amount
                 Type: uint256
                 Source: "amount"
              Identifier reserveBalance
                 Type: uint256
                 Source: "reserveBalance"
            TupleExpression
               Type: bool
               Source: "(amount == reserveBalance && _sellAmount == tokenSupply)"
              BinaryOperation using operator &&
                 Type: bool
                 Source: "amount == reserveBalance && _sellAmount == tokenSupply"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "amount == reserveBalance"
                  Identifier amount
                     Type: uint256
                     Source: "amount"
                  Identifier reserveBalance
                     Type: uint256
                     Source: "reserveBalance"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "_sellAmount == tokenSupply"
                  Identifier _sellAmount
                     Type: uint256
                     Source: "_sellAmount"
                  Identifier tokenSupply
                     Type: uint256
                     Source: "tokenSupply"
      VariableDeclarationStatement
         Gas costs: 107
         Source: "Reserve storage reserve = reserves[_reserveToken]"
        VariableDeclaration "reserve"
           Type: struct BancorChanger.Reserve storage pointer
           Source: "Reserve storage reserve"
          UserDefinedTypeName "Reserve"
             Source: "Reserve"
        IndexAccess
           Type: struct BancorChanger.Reserve storage ref
           Source: "reserves[_reserveToken]"
          Identifier reserves
             Type: mapping(address => struct BancorChanger.Reserve storage ref)
             Source: "reserves"
          Identifier _reserveToken
             Type: contract IERC20Token
             Source: "_reserveToken"
      IfStatement
         Source: "if (reserve.isVirtualBalanceEnabled)\r\n            reserve.virtualBalance = safeSub(reserve.virtualBalance, amount)"
        MemberAccess to member isVirtualBalanceEnabled
           Type: bool
           Gas costs: 295
           Source: "reserve.isVirtualBalanceEnabled"
          Identifier reserve
             Type: struct BancorChanger.Reserve storage pointer
             Source: "reserve"
        ExpressionStatement
           Gas costs: 20244
           Source: "reserve.virtualBalance = safeSub(reserve.virtualBalance, amount)"
          Assignment using operator =
             Type: uint256
             Source: "reserve.virtualBalance = safeSub(reserve.virtualBalance, amount)"
            MemberAccess to member virtualBalance
               Type: uint256
               Source: "reserve.virtualBalance"
              Identifier reserve
                 Type: struct BancorChanger.Reserve storage pointer
                 Source: "reserve"
            FunctionCall
               Type: uint256
               Source: "safeSub(reserve.virtualBalance, amount)"
              Identifier safeSub
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "safeSub"
              MemberAccess to member virtualBalance
                 Type: uint256
                 Source: "reserve.virtualBalance"
                Identifier reserve
                   Type: struct BancorChanger.Reserve storage pointer
                   Source: "reserve"
              Identifier amount
                 Type: uint256
                 Source: "amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.destroy(msg.sender, _sellAmount)"
        FunctionCall
           Type: tuple()
           Source: "token.destroy(msg.sender, _sellAmount)"
          MemberAccess to member destroy
             Type: function (address,uint256) external
             Source: "token.destroy"
            Identifier token
               Type: contract ISmartToken
               Source: "token"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _sellAmount
             Type: uint256
             Source: "_sellAmount"
      IfStatement
         Source: "if (msg.sender != address(this))\r\n            assert(_reserveToken.transfer(msg.sender, amount))"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 22
           Source: "msg.sender != address(this)"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          FunctionCall
             Type: address
             Source: "address(this)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier this
               Type: contract BancorChanger
               Source: "this"
        ExpressionStatement
           Gas costs: [???]
           Source: "assert(_reserveToken.transfer(msg.sender, amount))"
          FunctionCall
             Type: tuple()
             Source: "assert(_reserveToken.transfer(msg.sender, amount))"
            Identifier assert
               Type: function (bool) pure
               Source: "assert"
            FunctionCall
               Type: bool
               Source: "_reserveToken.transfer(msg.sender, amount)"
              MemberAccess to member transfer
                 Type: function (address,uint256) external returns (bool)
                 Source: "_reserveToken.transfer"
                Identifier _reserveToken
                   Type: contract IERC20Token
                   Source: "_reserveToken"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier amount
                 Type: uint256
                 Source: "amount"
      VariableDeclarationStatement
         Gas costs: 47
         Source: "uint256 reserveAmount = safeMul(getReserveBalance(_reserveToken), MAX_CRR)"
        VariableDeclaration "reserveAmount"
           Type: uint256
           Source: "uint256 reserveAmount"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "safeMul(getReserveBalance(_reserveToken), MAX_CRR)"
          Identifier safeMul
             Type: function (uint256,uint256) returns (uint256)
             Source: "safeMul"
          FunctionCall
             Type: uint256
             Source: "getReserveBalance(_reserveToken)"
            Identifier getReserveBalance
               Type: function (contract IERC20Token) view returns (uint256)
               Source: "getReserveBalance"
            Identifier _reserveToken
               Type: contract IERC20Token
               Source: "_reserveToken"
          Identifier MAX_CRR
             Type: uint32
             Source: "MAX_CRR"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint256 tokenAmount = safeMul(token.totalSupply(), reserve.ratio)"
        VariableDeclaration "tokenAmount"
           Type: uint256
           Source: "uint256 tokenAmount"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "safeMul(token.totalSupply(), reserve.ratio)"
          Identifier safeMul
             Type: function (uint256,uint256) returns (uint256)
             Source: "safeMul"
          FunctionCall
             Type: uint256
             Source: "token.totalSupply()"
            MemberAccess to member totalSupply
               Type: function () view external returns (uint256)
               Source: "token.totalSupply"
              Identifier token
                 Type: contract ISmartToken
                 Source: "token"
          MemberAccess to member ratio
             Type: uint32
             Source: "reserve.ratio"
            Identifier reserve
               Type: struct BancorChanger.Reserve storage pointer
               Source: "reserve"
      ExpressionStatement
         Gas costs: [???]
         Source: "Change(token, _reserveToken, msg.sender, _sellAmount, amount, tokenAmount, reserveAmount)"
        FunctionCall
           Type: tuple()
           Source: "Change(token, _reserveToken, msg.sender, _sellAmount, amount, tokenAmount, reserveAmount)"
          Identifier Change
             Type: function (address,address,address,uint256,uint256,uint256,uint256)
             Source: "Change"
          Identifier token
             Type: contract ISmartToken
             Source: "token"
          Identifier _reserveToken
             Type: contract IERC20Token
             Source: "_reserveToken"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _sellAmount
             Type: uint256
             Source: "_sellAmount"
          Identifier amount
             Type: uint256
             Source: "amount"
          Identifier tokenAmount
             Type: uint256
             Source: "tokenAmount"
          Identifier reserveAmount
             Type: uint256
             Source: "reserveAmount"
      Return
         Gas costs: 8
         Source: "return amount"
        Identifier amount
           Type: uint256
           Source: "amount"
  FunctionDefinition "quickChange" - public
     Source: "function quickChange(IERC20Token[] _path, uint256 _amount, uint256 _minReturn)\r\n        public\r\n        validChangePath(_path)\r\n        returns (uint256 amount)\r\n    {\r\n        // we need to transfer the tokens from the caller to the local contract before we\r\n        // follow the change path, to allow it to execute the change on behalf of the caller\r\n        IERC20Token fromToken = _path[0];\r\n        claimTokens(fromToken, msg.sender, _amount);\r\n\r\n        ISmartToken smartToken;\r\n        IERC20Token toToken;\r\n        BancorChanger changer;\r\n        uint256 pathLength = _path.length;\r\n\r\n        // iterate over the change path\r\n        for (uint256 i = 1; i < pathLength; i += 2) {\r\n            smartToken = ISmartToken(_path[i]);\r\n            toToken = _path[i + 1];\r\n            changer = BancorChanger(smartToken.owner());\r\n\r\n            // if the smart token isn't the source (from token), the changer doesn't have control over it and thus we need to approve the request\r\n            if (smartToken != fromToken)\r\n                ensureAllowance(fromToken, changer, _amount);\r\n\r\n            // make the change - if it's the last one, also provide the minimum return value\r\n            _amount = changer.change(fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1);\r\n            fromToken = toToken;\r\n        }\r\n\r\n        // finished the change, transfer the funds back to the caller\r\n        // if the last change resulted in ether tokens, withdraw them and send them as ETH to the caller\r\n        if (changer.hasQuickBuyEtherToken() && changer.getQuickBuyEtherToken() == toToken) {\r\n            IEtherToken etherToken = IEtherToken(toToken);\r\n            etherToken.withdrawTo(msg.sender, _amount);\r\n        }\r\n        // no need to transfer the tokens if the sender is the local contract\r\n        else if (msg.sender != address(this)) {\r\n            // not ETH, transfer the tokens to the caller\r\n            assert(toToken.transfer(msg.sender, _amount));\r\n        }\r\n\r\n        return _amount;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token[] _path, uint256 _amount, uint256 _minReturn)"
      VariableDeclaration "_path"
         Type: contract IERC20Token[] memory
         Source: "IERC20Token[] _path"
        ArrayTypeName
           Source: "IERC20Token[]"
          UserDefinedTypeName "IERC20Token"
             Source: "IERC20Token"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_minReturn"
         Type: uint256
         Source: "uint256 _minReturn"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ModifierInvocation "validChangePath"
       Gas costs: 3
       Source: "validChangePath(_path)"
      Identifier validChangePath
         Type: modifier (contract IERC20Token[] memory)
         Source: "validChangePath"
      Identifier _path
         Type: contract IERC20Token[] memory
         Source: "_path"
    Block
       Source: "{\r\n        // we need to transfer the tokens from the caller to the local contract before we\r\n        // follow the change path, to allow it to execute the change on behalf of the caller\r\n        IERC20Token fromToken = _path[0];\r\n        claimTokens(fromToken, msg.sender, _amount);\r\n\r\n        ISmartToken smartToken;\r\n        IERC20Token toToken;\r\n        BancorChanger changer;\r\n        uint256 pathLength = _path.length;\r\n\r\n        // iterate over the change path\r\n        for (uint256 i = 1; i < pathLength; i += 2) {\r\n            smartToken = ISmartToken(_path[i]);\r\n            toToken = _path[i + 1];\r\n            changer = BancorChanger(smartToken.owner());\r\n\r\n            // if the smart token isn't the source (from token), the changer doesn't have control over it and thus we need to approve the request\r\n            if (smartToken != fromToken)\r\n                ensureAllowance(fromToken, changer, _amount);\r\n\r\n            // make the change - if it's the last one, also provide the minimum return value\r\n            _amount = changer.change(fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1);\r\n            fromToken = toToken;\r\n        }\r\n\r\n        // finished the change, transfer the funds back to the caller\r\n        // if the last change resulted in ether tokens, withdraw them and send them as ETH to the caller\r\n        if (changer.hasQuickBuyEtherToken() && changer.getQuickBuyEtherToken() == toToken) {\r\n            IEtherToken etherToken = IEtherToken(toToken);\r\n            etherToken.withdrawTo(msg.sender, _amount);\r\n        }\r\n        // no need to transfer the tokens if the sender is the local contract\r\n        else if (msg.sender != address(this)) {\r\n            // not ETH, transfer the tokens to the caller\r\n            assert(toToken.transfer(msg.sender, _amount));\r\n        }\r\n\r\n        return _amount;\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "IERC20Token fromToken = _path[0]"
        VariableDeclaration "fromToken"
           Type: contract IERC20Token
           Source: "IERC20Token fromToken"
          UserDefinedTypeName "IERC20Token"
             Source: "IERC20Token"
        IndexAccess
           Type: contract IERC20Token
           Source: "_path[0]"
          Identifier _path
             Type: contract IERC20Token[] memory
             Source: "_path"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 12
         Source: "claimTokens(fromToken, msg.sender, _amount)"
        FunctionCall
           Type: tuple()
           Source: "claimTokens(fromToken, msg.sender, _amount)"
          Identifier claimTokens
             Type: function (contract IERC20Token,address,uint256)
             Source: "claimTokens"
          Identifier fromToken
             Type: contract IERC20Token
             Source: "fromToken"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "ISmartToken smartToken"
        VariableDeclaration "smartToken"
           Type: contract ISmartToken
           Source: "ISmartToken smartToken"
          UserDefinedTypeName "ISmartToken"
             Source: "ISmartToken"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "IERC20Token toToken"
        VariableDeclaration "toToken"
           Type: contract IERC20Token
           Source: "IERC20Token toToken"
          UserDefinedTypeName "IERC20Token"
             Source: "IERC20Token"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "BancorChanger changer"
        VariableDeclaration "changer"
           Type: contract BancorChanger
           Source: "BancorChanger changer"
          UserDefinedTypeName "BancorChanger"
             Source: "BancorChanger"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint256 pathLength = _path.length"
        VariableDeclaration "pathLength"
           Type: uint256
           Source: "uint256 pathLength"
          ElementaryTypeName uint256
             Source: "uint256"
        MemberAccess to member length
           Type: uint256
           Source: "_path.length"
          Identifier _path
             Type: contract IERC20Token[] memory
             Source: "_path"
      ForStatement
         Source: "for (uint256 i = 1; i < pathLength; i += 2) {\r\n            smartToken = ISmartToken(_path[i]);\r\n            toToken = _path[i + 1];\r\n            changer = BancorChanger(smartToken.owner());\r\n\r\n            // if the smart token isn't the source (from token), the changer doesn't have control over it and thus we need to approve the request\r\n            if (smartToken != fromToken)\r\n                ensureAllowance(fromToken, changer, _amount);\r\n\r\n            // make the change - if it's the last one, also provide the minimum return value\r\n            _amount = changer.change(fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1);\r\n            fromToken = toToken;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint256 i = 1"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint256 i"
            ElementaryTypeName uint256
               Source: "uint256"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < pathLength"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier pathLength
             Type: uint256
             Source: "pathLength"
        ExpressionStatement
           Gas costs: 14
           Source: "i += 2"
          Assignment using operator +=
             Type: uint256
             Source: "i += 2"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
        Block
           Source: "{\r\n            smartToken = ISmartToken(_path[i]);\r\n            toToken = _path[i + 1];\r\n            changer = BancorChanger(smartToken.owner());\r\n\r\n            // if the smart token isn't the source (from token), the changer doesn't have control over it and thus we need to approve the request\r\n            if (smartToken != fromToken)\r\n                ensureAllowance(fromToken, changer, _amount);\r\n\r\n            // make the change - if it's the last one, also provide the minimum return value\r\n            _amount = changer.change(fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1);\r\n            fromToken = toToken;\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "smartToken = ISmartToken(_path[i])"
            Assignment using operator =
               Type: contract ISmartToken
               Source: "smartToken = ISmartToken(_path[i])"
              Identifier smartToken
                 Type: contract ISmartToken
                 Source: "smartToken"
              FunctionCall
                 Type: contract ISmartToken
                 Source: "ISmartToken(_path[i])"
                Identifier ISmartToken
                   Type: type(contract ISmartToken)
                   Source: "ISmartToken"
                IndexAccess
                   Type: contract IERC20Token
                   Source: "_path[i]"
                  Identifier _path
                     Type: contract IERC20Token[] memory
                     Source: "_path"
                  Identifier i
                     Type: uint256
                     Source: "i"
          ExpressionStatement
             Gas costs: [???]
             Source: "toToken = _path[i + 1]"
            Assignment using operator =
               Type: contract IERC20Token
               Source: "toToken = _path[i + 1]"
              Identifier toToken
                 Type: contract IERC20Token
                 Source: "toToken"
              IndexAccess
                 Type: contract IERC20Token
                 Source: "_path[i + 1]"
                Identifier _path
                   Type: contract IERC20Token[] memory
                   Source: "_path"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "i + 1"
                  Identifier i
                     Type: uint256
                     Source: "i"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
          ExpressionStatement
             Gas costs: [???]
             Source: "changer = BancorChanger(smartToken.owner())"
            Assignment using operator =
               Type: contract BancorChanger
               Source: "changer = BancorChanger(smartToken.owner())"
              Identifier changer
                 Type: contract BancorChanger
                 Source: "changer"
              FunctionCall
                 Type: contract BancorChanger
                 Source: "BancorChanger(smartToken.owner())"
                Identifier BancorChanger
                   Type: type(contract BancorChanger)
                   Source: "BancorChanger"
                FunctionCall
                   Type: address
                   Source: "smartToken.owner()"
                  MemberAccess to member owner
                     Type: function () view external returns (address)
                     Source: "smartToken.owner"
                    Identifier smartToken
                       Type: contract ISmartToken
                       Source: "smartToken"
          IfStatement
             Source: "if (smartToken != fromToken)\r\n                ensureAllowance(fromToken, changer, _amount)"
            BinaryOperation using operator !=
               Type: bool
               Gas costs: 24
               Source: "smartToken != fromToken"
              Identifier smartToken
                 Type: contract ISmartToken
                 Source: "smartToken"
              Identifier fromToken
                 Type: contract IERC20Token
                 Source: "fromToken"
            ExpressionStatement
               Gas costs: 13
               Source: "ensureAllowance(fromToken, changer, _amount)"
              FunctionCall
                 Type: tuple()
                 Source: "ensureAllowance(fromToken, changer, _amount)"
                Identifier ensureAllowance
                   Type: function (contract IERC20Token,address,uint256)
                   Source: "ensureAllowance"
                Identifier fromToken
                   Type: contract IERC20Token
                   Source: "fromToken"
                Identifier changer
                   Type: contract BancorChanger
                   Source: "changer"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
          ExpressionStatement
             Gas costs: [???]
             Source: "_amount = changer.change(fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1)"
            Assignment using operator =
               Type: uint256
               Source: "_amount = changer.change(fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1)"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
              FunctionCall
                 Type: uint256
                 Source: "changer.change(fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1)"
                MemberAccess to member change
                   Type: function (contract IERC20Token,contract IERC20Token,uint256,uint256) external returns (uint256)
                   Source: "changer.change"
                  Identifier changer
                     Type: contract BancorChanger
                     Source: "changer"
                Identifier fromToken
                   Type: contract IERC20Token
                   Source: "fromToken"
                Identifier toToken
                   Type: contract IERC20Token
                   Source: "toToken"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
                Conditional
                   Type: uint256
                   Source: "i == pathLength - 2 ? _minReturn : 1"
                  BinaryOperation using operator ==
                     Type: bool
                     Source: "i == pathLength - 2"
                    Identifier i
                       Type: uint256
                       Source: "i"
                    BinaryOperation using operator -
                       Type: uint256
                       Source: "pathLength - 2"
                      Identifier pathLength
                         Type: uint256
                         Source: "pathLength"
                      Literal, token: [no token] value: 2
                         Type: int_const 2
                         Source: "2"
                  Identifier _minReturn
                     Type: uint256
                     Source: "_minReturn"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
          ExpressionStatement
             Gas costs: 8
             Source: "fromToken = toToken"
            Assignment using operator =
               Type: contract IERC20Token
               Source: "fromToken = toToken"
              Identifier fromToken
                 Type: contract IERC20Token
                 Source: "fromToken"
              Identifier toToken
                 Type: contract IERC20Token
                 Source: "toToken"
      IfStatement
         Source: "if (changer.hasQuickBuyEtherToken() && changer.getQuickBuyEtherToken() == toToken) {\r\n            IEtherToken etherToken = IEtherToken(toToken);\r\n            etherToken.withdrawTo(msg.sender, _amount);\r\n        }\r\n        // no need to transfer the tokens if the sender is the local contract\r\n        else if (msg.sender != address(this)) {\r\n            // not ETH, transfer the tokens to the caller\r\n            assert(toToken.transfer(msg.sender, _amount));\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: [???]
           Source: "changer.hasQuickBuyEtherToken() && changer.getQuickBuyEtherToken() == toToken"
          FunctionCall
             Type: bool
             Source: "changer.hasQuickBuyEtherToken()"
            MemberAccess to member hasQuickBuyEtherToken
               Type: function () view external returns (bool)
               Source: "changer.hasQuickBuyEtherToken"
              Identifier changer
                 Type: contract BancorChanger
                 Source: "changer"
          BinaryOperation using operator ==
             Type: bool
             Source: "changer.getQuickBuyEtherToken() == toToken"
            FunctionCall
               Type: contract IEtherToken
               Source: "changer.getQuickBuyEtherToken()"
              MemberAccess to member getQuickBuyEtherToken
                 Type: function () view external returns (contract IEtherToken)
                 Source: "changer.getQuickBuyEtherToken"
                Identifier changer
                   Type: contract BancorChanger
                   Source: "changer"
            Identifier toToken
               Type: contract IERC20Token
               Source: "toToken"
        Block
           Source: "{\r\n            IEtherToken etherToken = IEtherToken(toToken);\r\n            etherToken.withdrawTo(msg.sender, _amount);\r\n        }"
          VariableDeclarationStatement
             Gas costs: 11
             Source: "IEtherToken etherToken = IEtherToken(toToken)"
            VariableDeclaration "etherToken"
               Type: contract IEtherToken
               Source: "IEtherToken etherToken"
              UserDefinedTypeName "IEtherToken"
                 Source: "IEtherToken"
            FunctionCall
               Type: contract IEtherToken
               Source: "IEtherToken(toToken)"
              Identifier IEtherToken
                 Type: type(contract IEtherToken)
                 Source: "IEtherToken"
              Identifier toToken
                 Type: contract IERC20Token
                 Source: "toToken"
          ExpressionStatement
             Gas costs: [???]
             Source: "etherToken.withdrawTo(msg.sender, _amount)"
            FunctionCall
               Type: tuple()
               Source: "etherToken.withdrawTo(msg.sender, _amount)"
              MemberAccess to member withdrawTo
                 Type: function (address,uint256) external
                 Source: "etherToken.withdrawTo"
                Identifier etherToken
                   Type: contract IEtherToken
                   Source: "etherToken"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
        IfStatement
           Source: "if (msg.sender != address(this)) {\r\n            // not ETH, transfer the tokens to the caller\r\n            assert(toToken.transfer(msg.sender, _amount));\r\n        }"
          BinaryOperation using operator !=
             Type: bool
             Gas costs: 22
             Source: "msg.sender != address(this)"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            FunctionCall
               Type: address
               Source: "address(this)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Identifier this
                 Type: contract BancorChanger
                 Source: "this"
          Block
             Source: "{\r\n            // not ETH, transfer the tokens to the caller\r\n            assert(toToken.transfer(msg.sender, _amount));\r\n        }"
            ExpressionStatement
               Gas costs: [???]
               Source: "assert(toToken.transfer(msg.sender, _amount))"
              FunctionCall
                 Type: tuple()
                 Source: "assert(toToken.transfer(msg.sender, _amount))"
                Identifier assert
                   Type: function (bool) pure
                   Source: "assert"
                FunctionCall
                   Type: bool
                   Source: "toToken.transfer(msg.sender, _amount)"
                  MemberAccess to member transfer
                     Type: function (address,uint256) external returns (bool)
                     Source: "toToken.transfer"
                    Identifier toToken
                       Type: contract IERC20Token
                       Source: "toToken"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier _amount
                     Type: uint256
                     Source: "_amount"
      Return
         Gas costs: 8
         Source: "return _amount"
        Identifier _amount
           Type: uint256
           Source: "_amount"
  FunctionDefinition "quickBuy" - public
     Source: "function quickBuy(uint256 _minReturn) public payable returns (uint256 amount) {\r\n        // ensure that the quick buy path was set\r\n        assert(quickBuyPath.length > 0);\r\n        // get the ether token\r\n        IEtherToken etherToken = getQuickBuyEtherToken();\r\n        // deposit ETH in the ether token\r\n        etherToken.deposit.value(msg.value)();\r\n        // execute the change\r\n        uint256 returnAmount = this.quickChange(quickBuyPath, msg.value, _minReturn);\r\n        // get the target token\r\n        IERC20Token toToken = quickBuyPath[quickBuyPath.length - 1];\r\n        // transfer the tokens to the caller\r\n        assert(toToken.transfer(msg.sender, returnAmount));\r\n        return returnAmount;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _minReturn)"
      VariableDeclaration "_minReturn"
         Type: uint256
         Source: "uint256 _minReturn"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        // ensure that the quick buy path was set\r\n        assert(quickBuyPath.length > 0);\r\n        // get the ether token\r\n        IEtherToken etherToken = getQuickBuyEtherToken();\r\n        // deposit ETH in the ether token\r\n        etherToken.deposit.value(msg.value)();\r\n        // execute the change\r\n        uint256 returnAmount = this.quickChange(quickBuyPath, msg.value, _minReturn);\r\n        // get the target token\r\n        IERC20Token toToken = quickBuyPath[quickBuyPath.length - 1];\r\n        // transfer the tokens to the caller\r\n        assert(toToken.transfer(msg.sender, returnAmount));\r\n        return returnAmount;\r\n    }"
      ExpressionStatement
         Gas costs: 237
         Source: "assert(quickBuyPath.length > 0)"
        FunctionCall
           Type: tuple()
           Source: "assert(quickBuyPath.length > 0)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >
             Type: bool
             Source: "quickBuyPath.length > 0"
            MemberAccess to member length
               Type: uint256
               Source: "quickBuyPath.length"
              Identifier quickBuyPath
                 Type: contract IERC20Token[] storage ref
                 Source: "quickBuyPath"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 23
         Source: "IEtherToken etherToken = getQuickBuyEtherToken()"
        VariableDeclaration "etherToken"
           Type: contract IEtherToken
           Source: "IEtherToken etherToken"
          UserDefinedTypeName "IEtherToken"
             Source: "IEtherToken"
        FunctionCall
           Type: contract IEtherToken
           Source: "getQuickBuyEtherToken()"
          Identifier getQuickBuyEtherToken
             Type: function () view returns (contract IEtherToken)
             Source: "getQuickBuyEtherToken"
      ExpressionStatement
         Gas costs: [???]
         Source: "etherToken.deposit.value(msg.value)()"
        FunctionCall
           Type: tuple()
           Source: "etherToken.deposit.value(msg.value)()"
          FunctionCall
             Type: function () payable external
             Source: "etherToken.deposit.value(msg.value)"
            MemberAccess to member value
               Type: function (uint256) returns (function () payable external)
               Source: "etherToken.deposit.value"
              MemberAccess to member deposit
                 Type: function () payable external
                 Source: "etherToken.deposit"
                Identifier etherToken
                   Type: contract IEtherToken
                   Source: "etherToken"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint256 returnAmount = this.quickChange(quickBuyPath, msg.value, _minReturn)"
        VariableDeclaration "returnAmount"
           Type: uint256
           Source: "uint256 returnAmount"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "this.quickChange(quickBuyPath, msg.value, _minReturn)"
          MemberAccess to member quickChange
             Type: function (contract IERC20Token[] memory,uint256,uint256) external returns (uint256)
             Source: "this.quickChange"
            Identifier this
               Type: contract BancorChanger
               Source: "this"
          Identifier quickBuyPath
             Type: contract IERC20Token[] storage ref
             Source: "quickBuyPath"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _minReturn
             Type: uint256
             Source: "_minReturn"
      VariableDeclarationStatement
         Gas costs: 750
         Source: "IERC20Token toToken = quickBuyPath[quickBuyPath.length - 1]"
        VariableDeclaration "toToken"
           Type: contract IERC20Token
           Source: "IERC20Token toToken"
          UserDefinedTypeName "IERC20Token"
             Source: "IERC20Token"
        IndexAccess
           Type: contract IERC20Token
           Source: "quickBuyPath[quickBuyPath.length - 1]"
          Identifier quickBuyPath
             Type: contract IERC20Token[] storage ref
             Source: "quickBuyPath"
          BinaryOperation using operator -
             Type: uint256
             Source: "quickBuyPath.length - 1"
            MemberAccess to member length
               Type: uint256
               Source: "quickBuyPath.length"
              Identifier quickBuyPath
                 Type: contract IERC20Token[] storage ref
                 Source: "quickBuyPath"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(toToken.transfer(msg.sender, returnAmount))"
        FunctionCall
           Type: tuple()
           Source: "assert(toToken.transfer(msg.sender, returnAmount))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          FunctionCall
             Type: bool
             Source: "toToken.transfer(msg.sender, returnAmount)"
            MemberAccess to member transfer
               Type: function (address,uint256) external returns (bool)
               Source: "toToken.transfer"
              Identifier toToken
                 Type: contract IERC20Token
                 Source: "toToken"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier returnAmount
               Type: uint256
               Source: "returnAmount"
      Return
         Gas costs: 8
         Source: "return returnAmount"
        Identifier returnAmount
           Type: uint256
           Source: "returnAmount"
  FunctionDefinition "getSaleReturn" - const
     Source: "function getSaleReturn(IERC20Token _reserveToken, uint256 _sellAmount, uint256 _totalSupply)\r\n        private\r\n        constant\r\n        active\r\n        validReserve(_reserveToken)\r\n        greaterThanZero(_totalSupply)\r\n        returns (uint256 amount)\r\n    {\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\r\n        amount = formula.calculateSaleReturn(_totalSupply, reserveBalance, reserve.ratio, _sellAmount);\r\n\r\n        // deduct the fee from the return amount\r\n        uint256 feeAmount = getChangeFeeAmount(amount);\r\n        return safeSub(amount, feeAmount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _reserveToken, uint256 _sellAmount, uint256 _totalSupply)"
      VariableDeclaration "_reserveToken"
         Type: contract IERC20Token
         Source: "IERC20Token _reserveToken"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_sellAmount"
         Type: uint256
         Source: "uint256 _sellAmount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_totalSupply"
         Type: uint256
         Source: "uint256 _totalSupply"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ModifierInvocation "active"
       Gas costs: 0
       Source: "active"
      Identifier active
         Type: modifier ()
         Source: "active"
    ModifierInvocation "validReserve"
       Gas costs: 3
       Source: "validReserve(_reserveToken)"
      Identifier validReserve
         Type: modifier (contract IERC20Token)
         Source: "validReserve"
      Identifier _reserveToken
         Type: contract IERC20Token
         Source: "_reserveToken"
    ModifierInvocation "greaterThanZero"
       Gas costs: 3
       Source: "greaterThanZero(_totalSupply)"
      Identifier greaterThanZero
         Type: modifier (uint256)
         Source: "greaterThanZero"
      Identifier _totalSupply
         Type: uint256
         Source: "_totalSupply"
    Block
       Source: "{\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\r\n        amount = formula.calculateSaleReturn(_totalSupply, reserveBalance, reserve.ratio, _sellAmount);\r\n\r\n        // deduct the fee from the return amount\r\n        uint256 feeAmount = getChangeFeeAmount(amount);\r\n        return safeSub(amount, feeAmount);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 107
         Source: "Reserve storage reserve = reserves[_reserveToken]"
        VariableDeclaration "reserve"
           Type: struct BancorChanger.Reserve storage pointer
           Source: "Reserve storage reserve"
          UserDefinedTypeName "Reserve"
             Source: "Reserve"
        IndexAccess
           Type: struct BancorChanger.Reserve storage ref
           Source: "reserves[_reserveToken]"
          Identifier reserves
             Type: mapping(address => struct BancorChanger.Reserve storage ref)
             Source: "reserves"
          Identifier _reserveToken
             Type: contract IERC20Token
             Source: "_reserveToken"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint256 reserveBalance = getReserveBalance(_reserveToken)"
        VariableDeclaration "reserveBalance"
           Type: uint256
           Source: "uint256 reserveBalance"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "getReserveBalance(_reserveToken)"
          Identifier getReserveBalance
             Type: function (contract IERC20Token) view returns (uint256)
             Source: "getReserveBalance"
          Identifier _reserveToken
             Type: contract IERC20Token
             Source: "_reserveToken"
      ExpressionStatement
         Gas costs: [???]
         Source: "amount = formula.calculateSaleReturn(_totalSupply, reserveBalance, reserve.ratio, _sellAmount)"
        Assignment using operator =
           Type: uint256
           Source: "amount = formula.calculateSaleReturn(_totalSupply, reserveBalance, reserve.ratio, _sellAmount)"
          Identifier amount
             Type: uint256
             Source: "amount"
          FunctionCall
             Type: uint256
             Source: "formula.calculateSaleReturn(_totalSupply, reserveBalance, reserve.ratio, _sellAmount)"
            MemberAccess to member calculateSaleReturn
               Type: function (uint256,uint256,uint32,uint256) view external returns (uint256)
               Source: "formula.calculateSaleReturn"
              Identifier formula
                 Type: contract IBancorFormula
                 Source: "formula"
            Identifier _totalSupply
               Type: uint256
               Source: "_totalSupply"
            Identifier reserveBalance
               Type: uint256
               Source: "reserveBalance"
            MemberAccess to member ratio
               Type: uint32
               Source: "reserve.ratio"
              Identifier reserve
                 Type: struct BancorChanger.Reserve storage pointer
                 Source: "reserve"
            Identifier _sellAmount
               Type: uint256
               Source: "_sellAmount"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint256 feeAmount = getChangeFeeAmount(amount)"
        VariableDeclaration "feeAmount"
           Type: uint256
           Source: "uint256 feeAmount"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "getChangeFeeAmount(amount)"
          Identifier getChangeFeeAmount
             Type: function (uint256) view returns (uint256)
             Source: "getChangeFeeAmount"
          Identifier amount
             Type: uint256
             Source: "amount"
      Return
         Gas costs: 26
         Source: "return safeSub(amount, feeAmount)"
        FunctionCall
           Type: uint256
           Source: "safeSub(amount, feeAmount)"
          Identifier safeSub
             Type: function (uint256,uint256) returns (uint256)
             Source: "safeSub"
          Identifier amount
             Type: uint256
             Source: "amount"
          Identifier feeAmount
             Type: uint256
             Source: "feeAmount"
  FunctionDefinition "ensureAllowance"
     Source: "function ensureAllowance(IERC20Token _token, address _spender, uint256 _value) private {\r\n        // no need to set an allowance if the spender is the local contract\r\n        if (_spender == address(this))\r\n            return;\r\n\r\n        // check if allowance for the given amount already exists\r\n        if (_token.allowance(this, _spender) >= _value)\r\n            return;\r\n\r\n        // if the allowance is nonzero, must reset it to 0 first\r\n        if (_token.allowance(this, _spender) != 0)\r\n            assert(_token.approve(_spender, 0));\r\n\r\n        // approve the new allowance\r\n        assert(_token.approve(_spender, _value));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _token, address _spender, uint256 _value)"
      VariableDeclaration "_token"
         Type: contract IERC20Token
         Source: "IERC20Token _token"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        // no need to set an allowance if the spender is the local contract\r\n        if (_spender == address(this))\r\n            return;\r\n\r\n        // check if allowance for the given amount already exists\r\n        if (_token.allowance(this, _spender) >= _value)\r\n            return;\r\n\r\n        // if the allowance is nonzero, must reset it to 0 first\r\n        if (_token.allowance(this, _spender) != 0)\r\n            assert(_token.approve(_spender, 0));\r\n\r\n        // approve the new allowance\r\n        assert(_token.approve(_spender, _value));\r\n    }"
      IfStatement
         Source: "if (_spender == address(this))\r\n            return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 20
           Source: "_spender == address(this)"
          Identifier _spender
             Type: address
             Source: "_spender"
          FunctionCall
             Type: address
             Source: "address(this)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier this
               Type: contract BancorChanger
               Source: "this"
        Return
           Gas costs: 11
           Source: "return;"
      IfStatement
         Source: "if (_token.allowance(this, _spender) >= _value)\r\n            return;"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: [???]
           Source: "_token.allowance(this, _spender) >= _value"
          FunctionCall
             Type: uint256
             Source: "_token.allowance(this, _spender)"
            MemberAccess to member allowance
               Type: function (address,address) view external returns (uint256)
               Source: "_token.allowance"
              Identifier _token
                 Type: contract IERC20Token
                 Source: "_token"
            Identifier this
               Type: contract BancorChanger
               Source: "this"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
        Return
           Gas costs: 11
           Source: "return;"
      IfStatement
         Source: "if (_token.allowance(this, _spender) != 0)\r\n            assert(_token.approve(_spender, 0))"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: [???]
           Source: "_token.allowance(this, _spender) != 0"
          FunctionCall
             Type: uint256
             Source: "_token.allowance(this, _spender)"
            MemberAccess to member allowance
               Type: function (address,address) view external returns (uint256)
               Source: "_token.allowance"
              Identifier _token
                 Type: contract IERC20Token
                 Source: "_token"
            Identifier this
               Type: contract BancorChanger
               Source: "this"
            Identifier _spender
               Type: address
               Source: "_spender"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: [???]
           Source: "assert(_token.approve(_spender, 0))"
          FunctionCall
             Type: tuple()
             Source: "assert(_token.approve(_spender, 0))"
            Identifier assert
               Type: function (bool) pure
               Source: "assert"
            FunctionCall
               Type: bool
               Source: "_token.approve(_spender, 0)"
              MemberAccess to member approve
                 Type: function (address,uint256) external returns (bool)
                 Source: "_token.approve"
                Identifier _token
                   Type: contract IERC20Token
                   Source: "_token"
              Identifier _spender
                 Type: address
                 Source: "_spender"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(_token.approve(_spender, _value))"
        FunctionCall
           Type: tuple()
           Source: "assert(_token.approve(_spender, _value))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          FunctionCall
             Type: bool
             Source: "_token.approve(_spender, _value)"
            MemberAccess to member approve
               Type: function (address,uint256) external returns (bool)
               Source: "_token.approve"
              Identifier _token
                 Type: contract IERC20Token
                 Source: "_token"
            Identifier _spender
               Type: address
               Source: "_spender"
            Identifier _value
               Type: uint256
               Source: "_value"
  FunctionDefinition "claimTokens"
     Source: "function claimTokens(IERC20Token _token, address _from, uint256 _amount) private {\r\n        // no need to claim the tokens if the source is the local contract\r\n        if (_from == address(this))\r\n            return;\r\n\r\n        // if the token is the smart token, no allowance is required - destroy the tokens from the caller and issue them to the local contract\r\n        if (_token == token) {\r\n            token.destroy(_from, _amount); // destroy _amount tokens from the caller's balance in the smart token\r\n            token.issue(this, _amount); // issue _amount new tokens to the local contract\r\n            return;\r\n        }\r\n\r\n        // otherwise, we assume we already have allowance\r\n        assert(_token.transferFrom(_from, this, _amount));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(IERC20Token _token, address _from, uint256 _amount)"
      VariableDeclaration "_token"
         Type: contract IERC20Token
         Source: "IERC20Token _token"
        UserDefinedTypeName "IERC20Token"
           Source: "IERC20Token"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        // no need to claim the tokens if the source is the local contract\r\n        if (_from == address(this))\r\n            return;\r\n\r\n        // if the token is the smart token, no allowance is required - destroy the tokens from the caller and issue them to the local contract\r\n        if (_token == token) {\r\n            token.destroy(_from, _amount); // destroy _amount tokens from the caller's balance in the smart token\r\n            token.issue(this, _amount); // issue _amount new tokens to the local contract\r\n            return;\r\n        }\r\n\r\n        // otherwise, we assume we already have allowance\r\n        assert(_token.transferFrom(_from, this, _amount));\r\n    }"
      IfStatement
         Source: "if (_from == address(this))\r\n            return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 20
           Source: "_from == address(this)"
          Identifier _from
             Type: address
             Source: "_from"
          FunctionCall
             Type: address
             Source: "address(this)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier this
               Type: contract BancorChanger
               Source: "this"
        Return
           Gas costs: 11
           Source: "return;"
      IfStatement
         Source: "if (_token == token) {\r\n            token.destroy(_from, _amount); // destroy _amount tokens from the caller's balance in the smart token\r\n            token.issue(this, _amount); // issue _amount new tokens to the local contract\r\n            return;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 257
           Source: "_token == token"
          Identifier _token
             Type: contract IERC20Token
             Source: "_token"
          Identifier token
             Type: contract ISmartToken
             Source: "token"
        Block
           Source: "{\r\n            token.destroy(_from, _amount); // destroy _amount tokens from the caller's balance in the smart token\r\n            token.issue(this, _amount); // issue _amount new tokens to the local contract\r\n            return;\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "token.destroy(_from, _amount)"
            FunctionCall
               Type: tuple()
               Source: "token.destroy(_from, _amount)"
              MemberAccess to member destroy
                 Type: function (address,uint256) external
                 Source: "token.destroy"
                Identifier token
                   Type: contract ISmartToken
                   Source: "token"
              Identifier _from
                 Type: address
                 Source: "_from"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
          ExpressionStatement
             Gas costs: [???]
             Source: "token.issue(this, _amount)"
            FunctionCall
               Type: tuple()
               Source: "token.issue(this, _amount)"
              MemberAccess to member issue
                 Type: function (address,uint256) external
                 Source: "token.issue"
                Identifier token
                   Type: contract ISmartToken
                   Source: "token"
              Identifier this
                 Type: contract BancorChanger
                 Source: "this"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
          Return
             Gas costs: 11
             Source: "return;"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(_token.transferFrom(_from, this, _amount))"
        FunctionCall
           Type: tuple()
           Source: "assert(_token.transferFrom(_from, this, _amount))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          FunctionCall
             Type: bool
             Source: "_token.transferFrom(_from, this, _amount)"
            MemberAccess to member transferFrom
               Type: function (address,address,uint256) external returns (bool)
               Source: "_token.transferFrom"
              Identifier _token
                 Type: contract IERC20Token
                 Source: "_token"
            Identifier _from
               Type: address
               Source: "_from"
            Identifier this
               Type: contract BancorChanger
               Source: "this"
            Identifier _amount
               Type: uint256
               Source: "_amount"
  FunctionDefinition "" - public
     Source: "function() payable {\r\n        quickBuy(1);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        quickBuy(1);\r\n    }"
      ExpressionStatement
         Gas costs: 9
         Source: "quickBuy(1)"
        FunctionCall
           Type: uint256
           Source: "quickBuy(1)"
          Identifier quickBuy
             Type: function (uint256) returns (uint256)
             Source: "quickBuy"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
