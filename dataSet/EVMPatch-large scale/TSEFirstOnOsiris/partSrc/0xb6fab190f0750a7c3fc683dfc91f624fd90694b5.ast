Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xb6fab190f0750a7c3fc683dfc91f624fd90694b5.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.16;"
ContractDefinition "SafeMath"
   Source: "contract SafeMath {\r\n     function safeMul(uint a, uint b) internal returns (uint) {\r\n          uint c = a * b;\r\n          assert(a == 0 || c / a == b);\r\n          return c;\r\n     }\r\n\r\n     function safeSub(uint a, uint b) internal returns (uint) {\r\n          assert(b <= a);\r\n          return a - b;\r\n     }\r\n\r\n     function safeAdd(uint a, uint b) internal returns (uint) {\r\n          uint c = a + b;\r\n          assert(c>=a && c>=b);\r\n          return c;\r\n     }\r\n}"
  FunctionDefinition "safeMul"
     Source: "function safeMul(uint a, uint b) internal returns (uint) {\r\n          uint c = a * b;\r\n          assert(a == 0 || c / a == b);\r\n          return c;\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n          uint c = a * b;\r\n          assert(a == 0 || c / a == b);\r\n          return c;\r\n     }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "safeSub"
     Source: "function safeSub(uint a, uint b) internal returns (uint) {\r\n          assert(b <= a);\r\n          return a - b;\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n          assert(b <= a);\r\n          return a - b;\r\n     }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "safeAdd"
     Source: "function safeAdd(uint a, uint b) internal returns (uint) {\r\n          uint c = a + b;\r\n          assert(c>=a && c>=b);\r\n          return c;\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n          uint c = a + b;\r\n          assert(c>=a && c>=b);\r\n          return c;\r\n     }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 66
         Source: "assert(c>=a && c>=b)"
        FunctionCall
           Type: tuple()
           Source: "assert(c>=a && c>=b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator &&
             Type: bool
             Source: "c>=a && c>=b"
            BinaryOperation using operator >=
               Type: bool
               Source: "c>=a"
              Identifier c
                 Type: uint256
                 Source: "c"
              Identifier a
                 Type: uint256
                 Source: "a"
            BinaryOperation using operator >=
               Type: bool
               Source: "c>=b"
              Identifier c
                 Type: uint256
                 Source: "c"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "StdToken"
   Source: "contract StdToken is SafeMath {\r\n// Fields:\r\n     mapping(address => uint256) balances;\r\n     mapping (address => mapping (address => uint256)) allowed;\r\n     uint public totalSupply = 0;\r\n\r\n// Events:\r\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n// Functions:\r\n     function transfer(address _to, uint256 _value) returns(bool){\r\n          require(balances[msg.sender] >= _value);\r\n          require(balances[_to] + _value > balances[_to]);\r\n\r\n          balances[msg.sender] = safeSub(balances[msg.sender],_value);\r\n          balances[_to] = safeAdd(balances[_to],_value);\r\n\r\n          Transfer(msg.sender, _to, _value);\r\n          return true;\r\n     }\r\n\r\n     function transferFrom(address _from, address _to, uint256 _value) returns(bool){\r\n          require(balances[_from] >= _value);\r\n          require(allowed[_from][msg.sender] >= _value);\r\n          require(balances[_to] + _value > balances[_to]);\r\n\r\n          balances[_to] = safeAdd(balances[_to],_value);\r\n          balances[_from] = safeSub(balances[_from],_value);\r\n          allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\r\n\r\n          Transfer(_from, _to, _value);\r\n          return true;\r\n     }\r\n\r\n     function balanceOf(address _owner) constant returns (uint256) {\r\n          return balances[_owner];\r\n     }\r\n\r\n     function approve(address _spender, uint256 _value) returns (bool) {\r\n          // To change the approve amount you first have to reduce the addresses`\r\n          //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n          //  already 0 to mitigate the race condition described here:\r\n          //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n          require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n          allowed[msg.sender][_spender] = _value;\r\n          Approval(msg.sender, _spender, _value);\r\n          return true;\r\n     }\r\n\r\n     function allowance(address _owner, address _spender) constant returns (uint256) {\r\n          return allowed[_owner][_spender];\r\n     }\r\n\r\n     modifier onlyPayloadSize(uint _size) {\r\n          require(msg.data.length >= _size + 4);\r\n          _;\r\n     }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) balances"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "totalSupply"
     Type: uint256
     Gas costs: 0
     Source: "uint public totalSupply = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  EventDefinition "Transfer"
     Gas costs: 0
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Gas costs: 0
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns(bool){\r\n          require(balances[msg.sender] >= _value);\r\n          require(balances[_to] + _value > balances[_to]);\r\n\r\n          balances[msg.sender] = safeSub(balances[msg.sender],_value);\r\n          balances[_to] = safeAdd(balances[_to],_value);\r\n\r\n          Transfer(msg.sender, _to, _value);\r\n          return true;\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n          require(balances[msg.sender] >= _value);\r\n          require(balances[_to] + _value > balances[_to]);\r\n\r\n          balances[msg.sender] = safeSub(balances[msg.sender],_value);\r\n          balances[_to] = safeAdd(balances[_to],_value);\r\n\r\n          Transfer(msg.sender, _to, _value);\r\n          return true;\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balances[msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balances[_to] + _value > balances[_to])"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_to] + _value > balances[_to])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balances[_to] + _value > balances[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balances[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] = safeSub(balances[msg.sender],_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = safeSub(balances[msg.sender],_value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "safeSub(balances[msg.sender],_value)"
            Identifier safeSub
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeSub"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] = safeAdd(balances[_to],_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = safeAdd(balances[_to],_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "safeAdd(balances[_to],_value)"
            Identifier safeAdd
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeAdd"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns(bool){\r\n          require(balances[_from] >= _value);\r\n          require(allowed[_from][msg.sender] >= _value);\r\n          require(balances[_to] + _value > balances[_to]);\r\n\r\n          balances[_to] = safeAdd(balances[_to],_value);\r\n          balances[_from] = safeSub(balances[_from],_value);\r\n          allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\r\n\r\n          Transfer(_from, _to, _value);\r\n          return true;\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n          require(balances[_from] >= _value);\r\n          require(allowed[_from][msg.sender] >= _value);\r\n          require(balances[_to] + _value > balances[_to]);\r\n\r\n          balances[_to] = safeAdd(balances[_to],_value);\r\n          balances[_from] = safeSub(balances[_from],_value);\r\n          allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\r\n\r\n          Transfer(_from, _to, _value);\r\n          return true;\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balances[_from] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_from] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[_from] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[_from]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "require(allowed[_from][msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(allowed[_from][msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "allowed[_from][msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "allowed[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[_from]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balances[_to] + _value > balances[_to])"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_to] + _value > balances[_to])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balances[_to] + _value > balances[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balances[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] = safeAdd(balances[_to],_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = safeAdd(balances[_to],_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "safeAdd(balances[_to],_value)"
            Identifier safeAdd
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeAdd"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_from] = safeSub(balances[_from],_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_from] = safeSub(balances[_from],_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "safeSub(balances[_from],_value)"
            Identifier safeSub
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeSub"
            IndexAccess
               Type: uint256
               Source: "balances[_from]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value)"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "safeSub(allowed[_from][msg.sender],_value)"
            Identifier safeSub
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeSub"
            IndexAccess
               Type: uint256
               Source: "allowed[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[_from]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256) {\r\n          return balances[_owner];\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n          return balances[_owner];\r\n     }"
      Return
         Gas costs: 0
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool) {\r\n          // To change the approve amount you first have to reduce the addresses`\r\n          //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n          //  already 0 to mitigate the race condition described here:\r\n          //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n          require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n          allowed[msg.sender][_spender] = _value;\r\n          Approval(msg.sender, _spender, _value);\r\n          return true;\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n          // To change the approve amount you first have to reduce the addresses`\r\n          //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n          //  already 0 to mitigate the race condition described here:\r\n          //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n          require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n          allowed[msg.sender][_spender] = _value;\r\n          Approval(msg.sender, _spender, _value);\r\n          return true;\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require((_value == 0) || (allowed[msg.sender][_spender] == 0))"
        FunctionCall
           Type: tuple()
           Source: "require((_value == 0) || (allowed[msg.sender][_spender] == 0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "(_value == 0) || (allowed[msg.sender][_spender] == 0)"
            TupleExpression
               Type: bool
               Source: "(_value == 0)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "_value == 0"
                Identifier _value
                   Type: uint256
                   Source: "_value"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            TupleExpression
               Type: bool
               Source: "(allowed[msg.sender][_spender] == 0)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "allowed[msg.sender][_spender] == 0"
                IndexAccess
                   Type: uint256
                   Source: "allowed[msg.sender][_spender]"
                  IndexAccess
                     Type: mapping(address => uint256)
                     Source: "allowed[msg.sender]"
                    Identifier allowed
                       Type: mapping(address => mapping(address => uint256))
                       Source: "allowed"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                  Identifier _spender
                     Type: address
                     Source: "_spender"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256) {\r\n          return allowed[_owner][_spender];\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n          return allowed[_owner][_spender];\r\n     }"
      Return
         Gas costs: 0
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  ModifierDefinition "onlyPayloadSize"
     Source: "modifier onlyPayloadSize(uint _size) {\r\n          require(msg.data.length >= _size + 4);\r\n          _;\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint _size)"
      VariableDeclaration "_size"
         Type: uint256
         Source: "uint _size"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n          require(msg.data.length >= _size + 4);\r\n          _;\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.data.length >= _size + 4)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.data.length >= _size + 4)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.data.length >= _size + 4"
            MemberAccess to member length
               Type: uint256
               Source: "msg.data.length"
              MemberAccess to member data
                 Type: bytes calldata
                 Source: "msg.data"
                Identifier msg
                   Type: msg
                   Source: "msg"
            BinaryOperation using operator +
               Type: uint256
               Source: "_size + 4"
              Identifier _size
                 Type: uint256
                 Source: "_size"
              Literal, token: [no token] value: 4
                 Type: int_const 4
                 Source: "4"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
ContractDefinition "MNTP"
   Source: "contract MNTP is StdToken {\r\n// Fields:\r\n     string public constant name = \"Goldmint MNT Prelaunch Token\";\r\n     string public constant symbol = \"MNTP\";\r\n     uint public constant decimals = 18;\r\n\r\n     address public creator = 0x0;\r\n     address public icoContractAddress = 0x0;\r\n     bool public lockTransfers = false;\r\n\r\n     // 10 mln\r\n     uint public constant TOTAL_TOKEN_SUPPLY = 10000000 * 1 ether;\r\n\r\n/// Modifiers:\r\n     modifier onlyCreator() { \r\n          require(msg.sender == creator); \r\n          _; \r\n     }\r\n\r\n     modifier byIcoContract() { \r\n          require(msg.sender == icoContractAddress); \r\n          _; \r\n     }\r\n\r\n     function setCreator(address _creator) onlyCreator {\r\n          creator = _creator;\r\n     }\r\n\r\n// Setters/Getters\r\n     function setIcoContractAddress(address _icoContractAddress) onlyCreator {\r\n          icoContractAddress = _icoContractAddress;\r\n     }\r\n\r\n// Functions:\r\n     function MNTP() {\r\n          creator = msg.sender;\r\n\r\n          assert(TOTAL_TOKEN_SUPPLY == 10000000 * 1 ether);\r\n     }\r\n\r\n     /// @dev Override\r\n     function transfer(address _to, uint256 _value) public returns(bool){\r\n          require(!lockTransfers);\r\n          return super.transfer(_to,_value);\r\n     }\r\n\r\n     /// @dev Override\r\n     function transferFrom(address _from, address _to, uint256 _value) public returns(bool){\r\n          require(!lockTransfers);\r\n          return super.transferFrom(_from,_to,_value);\r\n     }\r\n\r\n     function issueTokens(address _who, uint _tokens) byIcoContract {\r\n          require((totalSupply + _tokens) <= TOTAL_TOKEN_SUPPLY);\r\n\r\n          balances[_who] = safeAdd(balances[_who],_tokens);\r\n          totalSupply = safeAdd(totalSupply,_tokens);\r\n\r\n          Transfer(0x0, _who, _tokens);\r\n     }\r\n\r\n     // For refunds only\r\n     function burnTokens(address _who, uint _tokens) byIcoContract {\r\n          balances[_who] = safeSub(balances[_who], _tokens);\r\n          totalSupply = safeSub(totalSupply, _tokens);\r\n     }\r\n\r\n     function lockTransfer(bool _lock) byIcoContract {\r\n          lockTransfers = _lock;\r\n     }\r\n\r\n     // Do not allow to send money directly to this contract\r\n     function() {\r\n          revert();\r\n     }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StdToken"
    UserDefinedTypeName "StdToken"
       Source: "StdToken"
  VariableDeclaration "name"
     Type: string memory
     Gas costs: 0
     Source: "string public constant name = \"Goldmint MNT Prelaunch Token\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Goldmint MNT Prelaunch Token
       Type: literal_string "Goldmint MNT Prelaunch Token"
       Source: "\"Goldmint MNT Prelaunch Token\""
  VariableDeclaration "symbol"
     Type: string memory
     Gas costs: 0
     Source: "string public constant symbol = \"MNTP\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: MNTP
       Type: literal_string "MNTP"
       Source: "\"MNTP\""
  VariableDeclaration "decimals"
     Type: uint256
     Gas costs: 0
     Source: "uint public constant decimals = 18"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "creator"
     Type: address
     Gas costs: 0
     Source: "address public creator = 0x0"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x0
       Type: int_const 0
       Source: "0x0"
  VariableDeclaration "icoContractAddress"
     Type: address
     Gas costs: 0
     Source: "address public icoContractAddress = 0x0"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x0
       Type: int_const 0
       Source: "0x0"
  VariableDeclaration "lockTransfers"
     Type: bool
     Gas costs: 0
     Source: "bool public lockTransfers = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "TOTAL_TOKEN_SUPPLY"
     Type: uint256
     Gas costs: 0
     Source: "uint public constant TOTAL_TOKEN_SUPPLY = 10000000 * 1 ether"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: int_const 10000000000000000000000000
       Source: "10000000 * 1 ether"
      Literal, token: [no token] value: 10000000
         Type: int_const 10000000
         Source: "10000000"
      Literal, token: [no token] value: 1
         Type: int_const 1000000000000000000
         Source: "1 ether"
  ModifierDefinition "onlyCreator"
     Source: "modifier onlyCreator() { \r\n          require(msg.sender == creator); \r\n          _; \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ \r\n          require(msg.sender == creator); \r\n          _; \r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.sender == creator)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == creator)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == creator"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier creator
               Type: address
               Source: "creator"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "byIcoContract"
     Source: "modifier byIcoContract() { \r\n          require(msg.sender == icoContractAddress); \r\n          _; \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ \r\n          require(msg.sender == icoContractAddress); \r\n          _; \r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.sender == icoContractAddress)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == icoContractAddress)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == icoContractAddress"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier icoContractAddress
               Type: address
               Source: "icoContractAddress"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "setCreator" - public
     Source: "function setCreator(address _creator) onlyCreator {\r\n          creator = _creator;\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _creator)"
      VariableDeclaration "_creator"
         Type: address
         Source: "address _creator"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyCreator"
       Gas costs: 0
       Source: "onlyCreator"
      Identifier onlyCreator
         Type: modifier ()
         Source: "onlyCreator"
    Block
       Source: "{\r\n          creator = _creator;\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "creator = _creator"
        Assignment using operator =
           Type: address
           Source: "creator = _creator"
          Identifier creator
             Type: address
             Source: "creator"
          Identifier _creator
             Type: address
             Source: "_creator"
  FunctionDefinition "setIcoContractAddress" - public
     Source: "function setIcoContractAddress(address _icoContractAddress) onlyCreator {\r\n          icoContractAddress = _icoContractAddress;\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _icoContractAddress)"
      VariableDeclaration "_icoContractAddress"
         Type: address
         Source: "address _icoContractAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyCreator"
       Gas costs: 0
       Source: "onlyCreator"
      Identifier onlyCreator
         Type: modifier ()
         Source: "onlyCreator"
    Block
       Source: "{\r\n          icoContractAddress = _icoContractAddress;\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "icoContractAddress = _icoContractAddress"
        Assignment using operator =
           Type: address
           Source: "icoContractAddress = _icoContractAddress"
          Identifier icoContractAddress
             Type: address
             Source: "icoContractAddress"
          Identifier _icoContractAddress
             Type: address
             Source: "_icoContractAddress"
  FunctionDefinition "MNTP" - public
     Source: "function MNTP() {\r\n          creator = msg.sender;\r\n\r\n          assert(TOTAL_TOKEN_SUPPLY == 10000000 * 1 ether);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n          creator = msg.sender;\r\n\r\n          assert(TOTAL_TOKEN_SUPPLY == 10000000 * 1 ether);\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "creator = msg.sender"
        Assignment using operator =
           Type: address
           Source: "creator = msg.sender"
          Identifier creator
             Type: address
             Source: "creator"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(TOTAL_TOKEN_SUPPLY == 10000000 * 1 ether)"
        FunctionCall
           Type: tuple()
           Source: "assert(TOTAL_TOKEN_SUPPLY == 10000000 * 1 ether)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "TOTAL_TOKEN_SUPPLY == 10000000 * 1 ether"
            Identifier TOTAL_TOKEN_SUPPLY
               Type: uint256
               Source: "TOTAL_TOKEN_SUPPLY"
            BinaryOperation using operator *
               Type: int_const 10000000000000000000000000
               Source: "10000000 * 1 ether"
              Literal, token: [no token] value: 10000000
                 Type: int_const 10000000
                 Source: "10000000"
              Literal, token: [no token] value: 1
                 Type: int_const 1000000000000000000
                 Source: "1 ether"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns(bool){\r\n          require(!lockTransfers);\r\n          return super.transfer(_to,_value);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n          require(!lockTransfers);\r\n          return super.transfer(_to,_value);\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!lockTransfers)"
        FunctionCall
           Type: tuple()
           Source: "require(!lockTransfers)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!lockTransfers"
            Identifier lockTransfers
               Type: bool
               Source: "lockTransfers"
      Return
         Gas costs: 0
         Source: "return super.transfer(_to,_value)"
        FunctionCall
           Type: bool
           Source: "super.transfer(_to,_value)"
          MemberAccess to member transfer
             Type: function (address,uint256) returns (bool)
             Source: "super.transfer"
            Identifier super
               Type: contract super MNTP
               Source: "super"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns(bool){\r\n          require(!lockTransfers);\r\n          return super.transferFrom(_from,_to,_value);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n          require(!lockTransfers);\r\n          return super.transferFrom(_from,_to,_value);\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!lockTransfers)"
        FunctionCall
           Type: tuple()
           Source: "require(!lockTransfers)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!lockTransfers"
            Identifier lockTransfers
               Type: bool
               Source: "lockTransfers"
      Return
         Gas costs: 0
         Source: "return super.transferFrom(_from,_to,_value)"
        FunctionCall
           Type: bool
           Source: "super.transferFrom(_from,_to,_value)"
          MemberAccess to member transferFrom
             Type: function (address,address,uint256) returns (bool)
             Source: "super.transferFrom"
            Identifier super
               Type: contract super MNTP
               Source: "super"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "issueTokens" - public
     Source: "function issueTokens(address _who, uint _tokens) byIcoContract {\r\n          require((totalSupply + _tokens) <= TOTAL_TOKEN_SUPPLY);\r\n\r\n          balances[_who] = safeAdd(balances[_who],_tokens);\r\n          totalSupply = safeAdd(totalSupply,_tokens);\r\n\r\n          Transfer(0x0, _who, _tokens);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _who, uint _tokens)"
      VariableDeclaration "_who"
         Type: address
         Source: "address _who"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "byIcoContract"
       Gas costs: 0
       Source: "byIcoContract"
      Identifier byIcoContract
         Type: modifier ()
         Source: "byIcoContract"
    Block
       Source: "{\r\n          require((totalSupply + _tokens) <= TOTAL_TOKEN_SUPPLY);\r\n\r\n          balances[_who] = safeAdd(balances[_who],_tokens);\r\n          totalSupply = safeAdd(totalSupply,_tokens);\r\n\r\n          Transfer(0x0, _who, _tokens);\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require((totalSupply + _tokens) <= TOTAL_TOKEN_SUPPLY)"
        FunctionCall
           Type: tuple()
           Source: "require((totalSupply + _tokens) <= TOTAL_TOKEN_SUPPLY)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "(totalSupply + _tokens) <= TOTAL_TOKEN_SUPPLY"
            TupleExpression
               Type: uint256
               Source: "(totalSupply + _tokens)"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "totalSupply + _tokens"
                Identifier totalSupply
                   Type: uint256
                   Source: "totalSupply"
                Identifier _tokens
                   Type: uint256
                   Source: "_tokens"
            Identifier TOTAL_TOKEN_SUPPLY
               Type: uint256
               Source: "TOTAL_TOKEN_SUPPLY"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_who] = safeAdd(balances[_who],_tokens)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_who] = safeAdd(balances[_who],_tokens)"
          IndexAccess
             Type: uint256
             Source: "balances[_who]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _who
               Type: address
               Source: "_who"
          FunctionCall
             Type: uint256
             Source: "safeAdd(balances[_who],_tokens)"
            Identifier safeAdd
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeAdd"
            IndexAccess
               Type: uint256
               Source: "balances[_who]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _who
                 Type: address
                 Source: "_who"
            Identifier _tokens
               Type: uint256
               Source: "_tokens"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = safeAdd(totalSupply,_tokens)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = safeAdd(totalSupply,_tokens)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "safeAdd(totalSupply,_tokens)"
            Identifier safeAdd
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeAdd"
            Identifier totalSupply
               Type: uint256
               Source: "totalSupply"
            Identifier _tokens
               Type: uint256
               Source: "_tokens"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(0x0, _who, _tokens)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(0x0, _who, _tokens)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
          Identifier _who
             Type: address
             Source: "_who"
          Identifier _tokens
             Type: uint256
             Source: "_tokens"
  FunctionDefinition "burnTokens" - public
     Source: "function burnTokens(address _who, uint _tokens) byIcoContract {\r\n          balances[_who] = safeSub(balances[_who], _tokens);\r\n          totalSupply = safeSub(totalSupply, _tokens);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _who, uint _tokens)"
      VariableDeclaration "_who"
         Type: address
         Source: "address _who"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "byIcoContract"
       Gas costs: 0
       Source: "byIcoContract"
      Identifier byIcoContract
         Type: modifier ()
         Source: "byIcoContract"
    Block
       Source: "{\r\n          balances[_who] = safeSub(balances[_who], _tokens);\r\n          totalSupply = safeSub(totalSupply, _tokens);\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_who] = safeSub(balances[_who], _tokens)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_who] = safeSub(balances[_who], _tokens)"
          IndexAccess
             Type: uint256
             Source: "balances[_who]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _who
               Type: address
               Source: "_who"
          FunctionCall
             Type: uint256
             Source: "safeSub(balances[_who], _tokens)"
            Identifier safeSub
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeSub"
            IndexAccess
               Type: uint256
               Source: "balances[_who]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _who
                 Type: address
                 Source: "_who"
            Identifier _tokens
               Type: uint256
               Source: "_tokens"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = safeSub(totalSupply, _tokens)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = safeSub(totalSupply, _tokens)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "safeSub(totalSupply, _tokens)"
            Identifier safeSub
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeSub"
            Identifier totalSupply
               Type: uint256
               Source: "totalSupply"
            Identifier _tokens
               Type: uint256
               Source: "_tokens"
  FunctionDefinition "lockTransfer" - public
     Source: "function lockTransfer(bool _lock) byIcoContract {\r\n          lockTransfers = _lock;\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(bool _lock)"
      VariableDeclaration "_lock"
         Type: bool
         Source: "bool _lock"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "byIcoContract"
       Gas costs: 0
       Source: "byIcoContract"
      Identifier byIcoContract
         Type: modifier ()
         Source: "byIcoContract"
    Block
       Source: "{\r\n          lockTransfers = _lock;\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "lockTransfers = _lock"
        Assignment using operator =
           Type: bool
           Source: "lockTransfers = _lock"
          Identifier lockTransfers
             Type: bool
             Source: "lockTransfers"
          Identifier _lock
             Type: bool
             Source: "_lock"
  FunctionDefinition "" - public
     Source: "function() {\r\n          revert();\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n          revert();\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "revert()"
        FunctionCall
           Type: tuple()
           Source: "revert()"
          Identifier revert
             Type: function () pure
             Source: "revert"
ContractDefinition "GoldmintUnsold"
   Source: "contract GoldmintUnsold is SafeMath {\r\n     address public creator;\r\n     address public teamAccountAddress;\r\n     address public icoContractAddress;\r\n     uint64 public icoIsFinishedDate;\r\n\r\n     MNTP public mntToken;\r\n\r\n     function GoldmintUnsold(address _teamAccountAddress,address _mntTokenAddress){\r\n          creator = msg.sender;\r\n          teamAccountAddress = _teamAccountAddress;\r\n\r\n          mntToken = MNTP(_mntTokenAddress);          \r\n     }\r\n\r\n     modifier onlyCreator() { \r\n          require(msg.sender==creator); \r\n          _; \r\n     }\r\n\r\n     modifier onlyIcoContract() { \r\n          require(msg.sender==icoContractAddress); \r\n          _; \r\n     }\r\n\r\n// Setters/Getters\r\n     function setIcoContractAddress(address _icoContractAddress) onlyCreator {\r\n          icoContractAddress = _icoContractAddress;\r\n     }\r\n\r\n     function finishIco() public onlyIcoContract {\r\n          icoIsFinishedDate = uint64(now);\r\n     }\r\n\r\n     // can be called by anyone...\r\n     function withdrawTokens() public {\r\n          // Check if 1 year is passed\r\n          uint64 oneYearPassed = icoIsFinishedDate + 365 days;  \r\n          require(uint(now) >= oneYearPassed);\r\n\r\n          // Transfer all tokens from this contract to the teamAccountAddress\r\n          uint total = mntToken.balanceOf(this);\r\n          mntToken.transfer(teamAccountAddress,total);\r\n     }\r\n\r\n     // Do not allow to send money directly to this contract\r\n     function() payable {\r\n          revert();\r\n     }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  VariableDeclaration "creator"
     Type: address
     Gas costs: 0
     Source: "address public creator"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "teamAccountAddress"
     Type: address
     Gas costs: 0
     Source: "address public teamAccountAddress"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "icoContractAddress"
     Type: address
     Gas costs: 0
     Source: "address public icoContractAddress"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "icoIsFinishedDate"
     Type: uint64
     Gas costs: 0
     Source: "uint64 public icoIsFinishedDate"
    ElementaryTypeName uint64
       Source: "uint64"
  VariableDeclaration "mntToken"
     Type: contract MNTP
     Gas costs: 0
     Source: "MNTP public mntToken"
    UserDefinedTypeName "MNTP"
       Source: "MNTP"
  FunctionDefinition "GoldmintUnsold" - public
     Source: "function GoldmintUnsold(address _teamAccountAddress,address _mntTokenAddress){\r\n          creator = msg.sender;\r\n          teamAccountAddress = _teamAccountAddress;\r\n\r\n          mntToken = MNTP(_mntTokenAddress);          \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _teamAccountAddress,address _mntTokenAddress)"
      VariableDeclaration "_teamAccountAddress"
         Type: address
         Source: "address _teamAccountAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_mntTokenAddress"
         Type: address
         Source: "address _mntTokenAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n          creator = msg.sender;\r\n          teamAccountAddress = _teamAccountAddress;\r\n\r\n          mntToken = MNTP(_mntTokenAddress);          \r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "creator = msg.sender"
        Assignment using operator =
           Type: address
           Source: "creator = msg.sender"
          Identifier creator
             Type: address
             Source: "creator"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "teamAccountAddress = _teamAccountAddress"
        Assignment using operator =
           Type: address
           Source: "teamAccountAddress = _teamAccountAddress"
          Identifier teamAccountAddress
             Type: address
             Source: "teamAccountAddress"
          Identifier _teamAccountAddress
             Type: address
             Source: "_teamAccountAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "mntToken = MNTP(_mntTokenAddress)"
        Assignment using operator =
           Type: contract MNTP
           Source: "mntToken = MNTP(_mntTokenAddress)"
          Identifier mntToken
             Type: contract MNTP
             Source: "mntToken"
          FunctionCall
             Type: contract MNTP
             Source: "MNTP(_mntTokenAddress)"
            Identifier MNTP
               Type: type(contract MNTP)
               Source: "MNTP"
            Identifier _mntTokenAddress
               Type: address
               Source: "_mntTokenAddress"
  ModifierDefinition "onlyCreator"
     Source: "modifier onlyCreator() { \r\n          require(msg.sender==creator); \r\n          _; \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ \r\n          require(msg.sender==creator); \r\n          _; \r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.sender==creator)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender==creator)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender==creator"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier creator
               Type: address
               Source: "creator"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyIcoContract"
     Source: "modifier onlyIcoContract() { \r\n          require(msg.sender==icoContractAddress); \r\n          _; \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ \r\n          require(msg.sender==icoContractAddress); \r\n          _; \r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.sender==icoContractAddress)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender==icoContractAddress)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender==icoContractAddress"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier icoContractAddress
               Type: address
               Source: "icoContractAddress"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "setIcoContractAddress" - public
     Source: "function setIcoContractAddress(address _icoContractAddress) onlyCreator {\r\n          icoContractAddress = _icoContractAddress;\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _icoContractAddress)"
      VariableDeclaration "_icoContractAddress"
         Type: address
         Source: "address _icoContractAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyCreator"
       Gas costs: 0
       Source: "onlyCreator"
      Identifier onlyCreator
         Type: modifier ()
         Source: "onlyCreator"
    Block
       Source: "{\r\n          icoContractAddress = _icoContractAddress;\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "icoContractAddress = _icoContractAddress"
        Assignment using operator =
           Type: address
           Source: "icoContractAddress = _icoContractAddress"
          Identifier icoContractAddress
             Type: address
             Source: "icoContractAddress"
          Identifier _icoContractAddress
             Type: address
             Source: "_icoContractAddress"
  FunctionDefinition "finishIco" - public
     Source: "function finishIco() public onlyIcoContract {\r\n          icoIsFinishedDate = uint64(now);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyIcoContract"
       Gas costs: 0
       Source: "onlyIcoContract"
      Identifier onlyIcoContract
         Type: modifier ()
         Source: "onlyIcoContract"
    Block
       Source: "{\r\n          icoIsFinishedDate = uint64(now);\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "icoIsFinishedDate = uint64(now)"
        Assignment using operator =
           Type: uint64
           Source: "icoIsFinishedDate = uint64(now)"
          Identifier icoIsFinishedDate
             Type: uint64
             Source: "icoIsFinishedDate"
          FunctionCall
             Type: uint64
             Source: "uint64(now)"
            ElementaryTypeNameExpression uint64
               Type: type(uint64)
               Source: "uint64"
            Identifier now
               Type: uint256
               Source: "now"
  FunctionDefinition "withdrawTokens" - public
     Source: "function withdrawTokens() public {\r\n          // Check if 1 year is passed\r\n          uint64 oneYearPassed = icoIsFinishedDate + 365 days;  \r\n          require(uint(now) >= oneYearPassed);\r\n\r\n          // Transfer all tokens from this contract to the teamAccountAddress\r\n          uint total = mntToken.balanceOf(this);\r\n          mntToken.transfer(teamAccountAddress,total);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n          // Check if 1 year is passed\r\n          uint64 oneYearPassed = icoIsFinishedDate + 365 days;  \r\n          require(uint(now) >= oneYearPassed);\r\n\r\n          // Transfer all tokens from this contract to the teamAccountAddress\r\n          uint total = mntToken.balanceOf(this);\r\n          mntToken.transfer(teamAccountAddress,total);\r\n     }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint64 oneYearPassed = icoIsFinishedDate + 365 days"
        VariableDeclaration "oneYearPassed"
           Type: uint64
           Source: "uint64 oneYearPassed"
          ElementaryTypeName uint64
             Source: "uint64"
        BinaryOperation using operator +
           Type: uint64
           Source: "icoIsFinishedDate + 365 days"
          Identifier icoIsFinishedDate
             Type: uint64
             Source: "icoIsFinishedDate"
          Literal, token: [no token] value: 365
             Type: int_const 31536000
             Source: "365 days"
      ExpressionStatement
         Gas costs: 0
         Source: "require(uint(now) >= oneYearPassed)"
        FunctionCall
           Type: tuple()
           Source: "require(uint(now) >= oneYearPassed)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "uint(now) >= oneYearPassed"
            FunctionCall
               Type: uint256
               Source: "uint(now)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              Identifier now
                 Type: uint256
                 Source: "now"
            Identifier oneYearPassed
               Type: uint64
               Source: "oneYearPassed"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint total = mntToken.balanceOf(this)"
        VariableDeclaration "total"
           Type: uint256
           Source: "uint total"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "mntToken.balanceOf(this)"
          MemberAccess to member balanceOf
             Type: function (address) view external returns (uint256)
             Source: "mntToken.balanceOf"
            Identifier mntToken
               Type: contract MNTP
               Source: "mntToken"
          Identifier this
             Type: contract GoldmintUnsold
             Source: "this"
      ExpressionStatement
         Gas costs: 0
         Source: "mntToken.transfer(teamAccountAddress,total)"
        FunctionCall
           Type: bool
           Source: "mntToken.transfer(teamAccountAddress,total)"
          MemberAccess to member transfer
             Type: function (address,uint256) external returns (bool)
             Source: "mntToken.transfer"
            Identifier mntToken
               Type: contract MNTP
               Source: "mntToken"
          Identifier teamAccountAddress
             Type: address
             Source: "teamAccountAddress"
          Identifier total
             Type: uint256
             Source: "total"
  FunctionDefinition "" - public
     Source: "function() payable {\r\n          revert();\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n          revert();\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "revert()"
        FunctionCall
           Type: tuple()
           Source: "revert()"
          Identifier revert
             Type: function () pure
             Source: "revert"
ContractDefinition "FoundersVesting"
   Source: "contract FoundersVesting is SafeMath {\r\n     address public teamAccountAddress;\r\n     uint64 public lastWithdrawTime;\r\n\r\n     uint public withdrawsCount = 0;\r\n     uint public amountToSend = 0;\r\n\r\n     MNTP public mntToken;\r\n\r\n     function FoundersVesting(address _teamAccountAddress,address _mntTokenAddress){\r\n          teamAccountAddress = _teamAccountAddress;\r\n          lastWithdrawTime = uint64(now);\r\n\r\n          mntToken = MNTP(_mntTokenAddress);          \r\n     }\r\n\r\n     // Can be called by anyone\r\n     function withdrawTokens() public {\r\n          // 1 - wait for the next month\r\n          uint64 oneMonth = lastWithdrawTime + 30 days;  \r\n          require(uint(now) >= oneMonth);\r\n\r\n          // 2 - calculate amount (only first time)\r\n          if(withdrawsCount==0){\r\n               amountToSend = mntToken.balanceOf(this) / 10;\r\n          }\r\n\r\n          require(amountToSend!=0);\r\n\r\n          // 3 - send 1/10th\r\n          uint currentBalance = mntToken.balanceOf(this);\r\n          if(currentBalance<amountToSend){\r\n             amountToSend = currentBalance;  \r\n          }\r\n          mntToken.transfer(teamAccountAddress,amountToSend);\r\n\r\n          // 4 - update counter\r\n          withdrawsCount++;\r\n          lastWithdrawTime = uint64(now);\r\n     }\r\n\r\n     // Do not allow to send money directly to this contract\r\n     function() payable {\r\n          revert();\r\n     }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  VariableDeclaration "teamAccountAddress"
     Type: address
     Gas costs: 0
     Source: "address public teamAccountAddress"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "lastWithdrawTime"
     Type: uint64
     Gas costs: 0
     Source: "uint64 public lastWithdrawTime"
    ElementaryTypeName uint64
       Source: "uint64"
  VariableDeclaration "withdrawsCount"
     Type: uint256
     Gas costs: 0
     Source: "uint public withdrawsCount = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "amountToSend"
     Type: uint256
     Gas costs: 0
     Source: "uint public amountToSend = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "mntToken"
     Type: contract MNTP
     Gas costs: 0
     Source: "MNTP public mntToken"
    UserDefinedTypeName "MNTP"
       Source: "MNTP"
  FunctionDefinition "FoundersVesting" - public
     Source: "function FoundersVesting(address _teamAccountAddress,address _mntTokenAddress){\r\n          teamAccountAddress = _teamAccountAddress;\r\n          lastWithdrawTime = uint64(now);\r\n\r\n          mntToken = MNTP(_mntTokenAddress);          \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _teamAccountAddress,address _mntTokenAddress)"
      VariableDeclaration "_teamAccountAddress"
         Type: address
         Source: "address _teamAccountAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_mntTokenAddress"
         Type: address
         Source: "address _mntTokenAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n          teamAccountAddress = _teamAccountAddress;\r\n          lastWithdrawTime = uint64(now);\r\n\r\n          mntToken = MNTP(_mntTokenAddress);          \r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "teamAccountAddress = _teamAccountAddress"
        Assignment using operator =
           Type: address
           Source: "teamAccountAddress = _teamAccountAddress"
          Identifier teamAccountAddress
             Type: address
             Source: "teamAccountAddress"
          Identifier _teamAccountAddress
             Type: address
             Source: "_teamAccountAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "lastWithdrawTime = uint64(now)"
        Assignment using operator =
           Type: uint64
           Source: "lastWithdrawTime = uint64(now)"
          Identifier lastWithdrawTime
             Type: uint64
             Source: "lastWithdrawTime"
          FunctionCall
             Type: uint64
             Source: "uint64(now)"
            ElementaryTypeNameExpression uint64
               Type: type(uint64)
               Source: "uint64"
            Identifier now
               Type: uint256
               Source: "now"
      ExpressionStatement
         Gas costs: 0
         Source: "mntToken = MNTP(_mntTokenAddress)"
        Assignment using operator =
           Type: contract MNTP
           Source: "mntToken = MNTP(_mntTokenAddress)"
          Identifier mntToken
             Type: contract MNTP
             Source: "mntToken"
          FunctionCall
             Type: contract MNTP
             Source: "MNTP(_mntTokenAddress)"
            Identifier MNTP
               Type: type(contract MNTP)
               Source: "MNTP"
            Identifier _mntTokenAddress
               Type: address
               Source: "_mntTokenAddress"
  FunctionDefinition "withdrawTokens" - public
     Source: "function withdrawTokens() public {\r\n          // 1 - wait for the next month\r\n          uint64 oneMonth = lastWithdrawTime + 30 days;  \r\n          require(uint(now) >= oneMonth);\r\n\r\n          // 2 - calculate amount (only first time)\r\n          if(withdrawsCount==0){\r\n               amountToSend = mntToken.balanceOf(this) / 10;\r\n          }\r\n\r\n          require(amountToSend!=0);\r\n\r\n          // 3 - send 1/10th\r\n          uint currentBalance = mntToken.balanceOf(this);\r\n          if(currentBalance<amountToSend){\r\n             amountToSend = currentBalance;  \r\n          }\r\n          mntToken.transfer(teamAccountAddress,amountToSend);\r\n\r\n          // 4 - update counter\r\n          withdrawsCount++;\r\n          lastWithdrawTime = uint64(now);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n          // 1 - wait for the next month\r\n          uint64 oneMonth = lastWithdrawTime + 30 days;  \r\n          require(uint(now) >= oneMonth);\r\n\r\n          // 2 - calculate amount (only first time)\r\n          if(withdrawsCount==0){\r\n               amountToSend = mntToken.balanceOf(this) / 10;\r\n          }\r\n\r\n          require(amountToSend!=0);\r\n\r\n          // 3 - send 1/10th\r\n          uint currentBalance = mntToken.balanceOf(this);\r\n          if(currentBalance<amountToSend){\r\n             amountToSend = currentBalance;  \r\n          }\r\n          mntToken.transfer(teamAccountAddress,amountToSend);\r\n\r\n          // 4 - update counter\r\n          withdrawsCount++;\r\n          lastWithdrawTime = uint64(now);\r\n     }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint64 oneMonth = lastWithdrawTime + 30 days"
        VariableDeclaration "oneMonth"
           Type: uint64
           Source: "uint64 oneMonth"
          ElementaryTypeName uint64
             Source: "uint64"
        BinaryOperation using operator +
           Type: uint64
           Source: "lastWithdrawTime + 30 days"
          Identifier lastWithdrawTime
             Type: uint64
             Source: "lastWithdrawTime"
          Literal, token: [no token] value: 30
             Type: int_const 2592000
             Source: "30 days"
      ExpressionStatement
         Gas costs: 0
         Source: "require(uint(now) >= oneMonth)"
        FunctionCall
           Type: tuple()
           Source: "require(uint(now) >= oneMonth)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "uint(now) >= oneMonth"
            FunctionCall
               Type: uint256
               Source: "uint(now)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              Identifier now
                 Type: uint256
                 Source: "now"
            Identifier oneMonth
               Type: uint64
               Source: "oneMonth"
      IfStatement
         Source: "if(withdrawsCount==0){\r\n               amountToSend = mntToken.balanceOf(this) / 10;\r\n          }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "withdrawsCount==0"
          Identifier withdrawsCount
             Type: uint256
             Source: "withdrawsCount"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n               amountToSend = mntToken.balanceOf(this) / 10;\r\n          }"
          ExpressionStatement
             Gas costs: 0
             Source: "amountToSend = mntToken.balanceOf(this) / 10"
            Assignment using operator =
               Type: uint256
               Source: "amountToSend = mntToken.balanceOf(this) / 10"
              Identifier amountToSend
                 Type: uint256
                 Source: "amountToSend"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "mntToken.balanceOf(this) / 10"
                FunctionCall
                   Type: uint256
                   Source: "mntToken.balanceOf(this)"
                  MemberAccess to member balanceOf
                     Type: function (address) view external returns (uint256)
                     Source: "mntToken.balanceOf"
                    Identifier mntToken
                       Type: contract MNTP
                       Source: "mntToken"
                  Identifier this
                     Type: contract FoundersVesting
                     Source: "this"
                Literal, token: [no token] value: 10
                   Type: int_const 10
                   Source: "10"
      ExpressionStatement
         Gas costs: 0
         Source: "require(amountToSend!=0)"
        FunctionCall
           Type: tuple()
           Source: "require(amountToSend!=0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "amountToSend!=0"
            Identifier amountToSend
               Type: uint256
               Source: "amountToSend"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint currentBalance = mntToken.balanceOf(this)"
        VariableDeclaration "currentBalance"
           Type: uint256
           Source: "uint currentBalance"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "mntToken.balanceOf(this)"
          MemberAccess to member balanceOf
             Type: function (address) view external returns (uint256)
             Source: "mntToken.balanceOf"
            Identifier mntToken
               Type: contract MNTP
               Source: "mntToken"
          Identifier this
             Type: contract FoundersVesting
             Source: "this"
      IfStatement
         Source: "if(currentBalance<amountToSend){\r\n             amountToSend = currentBalance;  \r\n          }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "currentBalance<amountToSend"
          Identifier currentBalance
             Type: uint256
             Source: "currentBalance"
          Identifier amountToSend
             Type: uint256
             Source: "amountToSend"
        Block
           Source: "{\r\n             amountToSend = currentBalance;  \r\n          }"
          ExpressionStatement
             Gas costs: 0
             Source: "amountToSend = currentBalance"
            Assignment using operator =
               Type: uint256
               Source: "amountToSend = currentBalance"
              Identifier amountToSend
                 Type: uint256
                 Source: "amountToSend"
              Identifier currentBalance
                 Type: uint256
                 Source: "currentBalance"
      ExpressionStatement
         Gas costs: 0
         Source: "mntToken.transfer(teamAccountAddress,amountToSend)"
        FunctionCall
           Type: bool
           Source: "mntToken.transfer(teamAccountAddress,amountToSend)"
          MemberAccess to member transfer
             Type: function (address,uint256) external returns (bool)
             Source: "mntToken.transfer"
            Identifier mntToken
               Type: contract MNTP
               Source: "mntToken"
          Identifier teamAccountAddress
             Type: address
             Source: "teamAccountAddress"
          Identifier amountToSend
             Type: uint256
             Source: "amountToSend"
      ExpressionStatement
         Gas costs: 0
         Source: "withdrawsCount++"
        UnaryOperation (postfix) ++
           Type: uint256
           Source: "withdrawsCount++"
          Identifier withdrawsCount
             Type: uint256
             Source: "withdrawsCount"
      ExpressionStatement
         Gas costs: 0
         Source: "lastWithdrawTime = uint64(now)"
        Assignment using operator =
           Type: uint64
           Source: "lastWithdrawTime = uint64(now)"
          Identifier lastWithdrawTime
             Type: uint64
             Source: "lastWithdrawTime"
          FunctionCall
             Type: uint64
             Source: "uint64(now)"
            ElementaryTypeNameExpression uint64
               Type: type(uint64)
               Source: "uint64"
            Identifier now
               Type: uint256
               Source: "now"
  FunctionDefinition "" - public
     Source: "function() payable {\r\n          revert();\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n          revert();\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "revert()"
        FunctionCall
           Type: tuple()
           Source: "revert()"
          Identifier revert
             Type: function () pure
             Source: "revert"
ContractDefinition "Goldmint"
   Source: "contract Goldmint is SafeMath {\r\n// Constants:\r\n     // These values are HARD CODED!!!\r\n     // For extra security we split single multisig wallet into 10 separate multisig wallets\r\n     //\r\n     // TODO: set real params here\r\n     address[] public multisigs = [\r\n          0x27ce565b1047c6258164062983bb8bc2917f11d2,\r\n          0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6,\r\n          0x7e2a7a10509177db2a7ea41e728743c4eb42f528,\r\n          0x27ce565b1047c6258164062983bb8bc2917f11d2,\r\n          0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6,\r\n          0x7e2a7a10509177db2a7ea41e728743c4eb42f528,\r\n          0x27ce565b1047c6258164062983bb8bc2917f11d2,\r\n          0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6,\r\n          0x7e2a7a10509177db2a7ea41e728743c4eb42f528,\r\n          0xF4Ce80097bf1E584822dBcA84f91D5d7d9df0846\r\n     ];\r\n\r\n     // We count ETH invested by person, for refunds (see below)\r\n     mapping(address => uint) ethInvestedBy;\r\n     // These can be changed before ICO starts ($7USD/MNTP)\r\n     uint constant STD_PRICE_USD_PER_1000_TOKENS = 7000;\r\n     // USD/ETH is fixed for the whole ICO\r\n     // WARNING: if USD/ETH rate changes DURING ICO -> we won't change it\r\n     // coinmarketcap.com 04.09.2017\r\n     uint constant ETH_PRICE_IN_USD = 300;\r\n     // Price changes from block to block\r\n     //uint constant SINGLE_BLOCK_LEN = 700000;\r\n\r\n     uint constant SINGLE_BLOCK_LEN = 100;\r\n\r\n     // 1 000 000 tokens\r\n     uint public constant BONUS_REWARD = 1000000 * 1 ether;\r\n     // 2 000 000 tokens\r\n     uint public constant FOUNDERS_REWARD = 2000000 * 1 ether;\r\n     // 7 000 000 is sold during the ICO\r\n     //uint public constant ICO_TOKEN_SUPPLY_LIMIT = 7000000 * 1 ether;\r\n\r\n     uint public constant ICO_TOKEN_SUPPLY_LIMIT = 150 * 1 ether;\r\n\r\n     // 150 000 tokens soft cap (otherwise - refund)\r\n     uint public constant ICO_TOKEN_SOFT_CAP = 150000 * 1 ether;\r\n\r\n// Fields:\r\n     address public creator = 0x0;\r\n     address public tokenManager = 0x0;\r\n     address public otherCurrenciesChecker = 0x0;\r\n\r\n     uint64 public icoStartedTime = 0;\r\n\r\n     MNTP public mntToken; \r\n\r\n     GoldmintUnsold public unsoldContract;\r\n\r\n     // Total amount of tokens sold during ICO\r\n     uint public icoTokensSold = 0;\r\n     // Total amount of tokens sent to GoldmintUnsold contract after ICO is finished\r\n     uint public icoTokensUnsold = 0;\r\n     // Total number of tokens that were issued by a scripts\r\n     uint public issuedExternallyTokens = 0;\r\n     // This is where FOUNDERS_REWARD will be allocated\r\n     address public foundersRewardsAccount = 0x0;\r\n\r\n     enum State{\r\n          Init,\r\n\r\n          ICORunning,\r\n          ICOPaused,\r\n\r\n          // Collected ETH is transferred to multisigs.\r\n          // Unsold tokens transferred to GoldmintUnsold contract.\r\n          ICOFinished,\r\n\r\n          // We start to refund if Soft Cap is not reached.\r\n          // Then each token holder should request a refund personally from his\r\n          // personal wallet.\r\n          //\r\n          // We will return ETHs only to the original address. If your address is changed\r\n          // or you have lost your keys -> you will not be able to get a refund.\r\n          // \r\n          // There is no any possibility to transfer tokens\r\n          // There is no any possibility to move back\r\n          Refunding,\r\n\r\n          // In this state we lock all MNT tokens forever.\r\n          // We are going to migrate MNTP -> MNT tokens during this stage. \r\n          // \r\n          // There is no any possibility to transfer tokens\r\n          // There is no any possibility to move back\r\n          Migrating\r\n     }\r\n     State public currentState = State.Init;\r\n\r\n// Modifiers:\r\n     modifier onlyCreator() { \r\n          require(msg.sender==creator); \r\n          _; \r\n     }\r\n     modifier onlyTokenManager() { \r\n          require(msg.sender==tokenManager); \r\n          _; \r\n     }\r\n     modifier onlyOtherCurrenciesChecker() { \r\n          require(msg.sender==otherCurrenciesChecker); \r\n          _; \r\n     }\r\n     modifier onlyInState(State state){ \r\n          require(state==currentState); \r\n          _; \r\n     }\r\n\r\n// Events:\r\n     event LogStateSwitch(State newState);\r\n     event LogBuy(address indexed owner, uint value);\r\n     event LogBurn(address indexed owner, uint value);\r\n     \r\n// Functions:\r\n     /// @dev Constructor\r\n     function Goldmint(\r\n          address _tokenManager,\r\n          address _otherCurrenciesChecker,\r\n\r\n          address _mntTokenAddress,\r\n          address _unsoldContractAddress,\r\n          address _foundersVestingAddress)\r\n     {\r\n          creator = msg.sender;\r\n\r\n          tokenManager = _tokenManager;\r\n          otherCurrenciesChecker = _otherCurrenciesChecker; \r\n\r\n          mntToken = MNTP(_mntTokenAddress);\r\n          unsoldContract = GoldmintUnsold(_unsoldContractAddress);\r\n\r\n          // slight rename\r\n          foundersRewardsAccount = _foundersVestingAddress;\r\n\r\n          assert(multisigs.length==10);\r\n     }\r\n\r\n     function startICO() public onlyCreator onlyInState(State.Init) {\r\n          setState(State.ICORunning);\r\n          icoStartedTime = uint64(now);\r\n          mntToken.lockTransfer(true);\r\n          mntToken.issueTokens(foundersRewardsAccount, FOUNDERS_REWARD);\r\n     }\r\n\r\n     function pauseICO() public onlyCreator onlyInState(State.ICORunning) {\r\n          setState(State.ICOPaused);\r\n     }\r\n\r\n     function resumeICO() public onlyCreator onlyInState(State.ICOPaused) {\r\n          setState(State.ICORunning);\r\n     }\r\n\r\n     function startRefunding() public onlyCreator onlyInState(State.ICORunning) {\r\n          // only switch to this state if less than ICO_TOKEN_SOFT_CAP sold\r\n          require(icoTokensSold < ICO_TOKEN_SOFT_CAP);\r\n          setState(State.Refunding);\r\n\r\n          // in this state tokens still shouldn't be transferred\r\n          assert(mntToken.lockTransfers());\r\n     }\r\n\r\n     function startMigration() public onlyCreator onlyInState(State.ICOFinished) {\r\n          // there is no way back...\r\n          setState(State.Migrating);\r\n\r\n          // disable token transfers\r\n          mntToken.lockTransfer(true);\r\n     }\r\n\r\n     /// @dev This function can be called by creator at any time,\r\n     /// or by anyone if ICO has really finished.\r\n     function finishICO() public onlyInState(State.ICORunning) {\r\n          require(msg.sender == creator || isIcoFinished());\r\n          setState(State.ICOFinished);\r\n\r\n          // 1 - lock all transfers\r\n          mntToken.lockTransfer(false);\r\n\r\n          // 2 - move all unsold tokens to unsoldTokens contract\r\n          icoTokensUnsold = safeSub(ICO_TOKEN_SUPPLY_LIMIT,icoTokensSold);\r\n          if(icoTokensUnsold>0){\r\n               mntToken.issueTokens(unsoldContract,icoTokensUnsold);\r\n               unsoldContract.finishIco();\r\n          }\r\n\r\n          // 3 - send all ETH to multisigs\r\n          // we have N separate multisigs for extra security\r\n          uint sendThisAmount = (this.balance / 10);\r\n\r\n          // 3.1 - send to 9 multisigs\r\n          for(uint i=0; i<9; ++i){\r\n               address ms = multisigs[i];\r\n\r\n               if(this.balance>=sendThisAmount){\r\n                    ms.transfer(sendThisAmount);\r\n               }\r\n          }\r\n\r\n          // 3.2 - send everything left to 10th multisig\r\n          if(0!=this.balance){\r\n               address lastMs = multisigs[9];\r\n               lastMs.transfer(this.balance);\r\n          }\r\n     }\r\n\r\n     function setState(State _s) internal {\r\n          currentState = _s;\r\n          LogStateSwitch(_s);\r\n     }\r\n\r\n// Access methods:\r\n     function setTokenManager(address _new) public onlyTokenManager {\r\n          tokenManager = _new;\r\n     }\r\n\r\n     // TODO: stealing creator's key means stealing otherCurrenciesChecker key too!\r\n     /*\r\n     function setOtherCurrenciesChecker(address _new) public onlyCreator {\r\n          otherCurrenciesChecker = _new;\r\n     }\r\n     */\r\n\r\n     // These are used by frontend so we can not remove them\r\n     function getTokensIcoSold() constant public returns (uint){          \r\n          return icoTokensSold;       \r\n     }      \r\n     \r\n     function getTotalIcoTokens() constant public returns (uint){          \r\n          return ICO_TOKEN_SUPPLY_LIMIT;         \r\n     }       \r\n     \r\n     function getMntTokenBalance(address _of) constant public returns (uint){         \r\n          return mntToken.balanceOf(_of);         \r\n     }        \r\n\r\n     function getBlockLength()constant public returns (uint){          \r\n          return SINGLE_BLOCK_LEN;      \r\n     }\r\n\r\n     function getCurrentPrice()constant public returns (uint){\r\n          return getMntTokensPerEth(icoTokensSold);\r\n     }\r\n\r\n/////////////////////////////\r\n     function isIcoFinished() constant public returns(bool) {\r\n          return (icoStartedTime > 0)\r\n            && (now > (icoStartedTime + 30 days) || (icoTokensSold >= ICO_TOKEN_SUPPLY_LIMIT));\r\n     }\r\n\r\n     function getMntTokensPerEth(uint _tokensSold) public constant returns (uint){\r\n          // 10 buckets\r\n          uint priceIndex = (_tokensSold / 1 ether) / SINGLE_BLOCK_LEN;\r\n          assert(priceIndex>=0 && (priceIndex<=9));\r\n          \r\n          uint8[10] memory discountPercents = [20,15,10,8,6,4,2,0,0,0];\r\n\r\n          // We have to multiply by '1 ether' to avoid float truncations\r\n          // Example: ($7000 * 100) / 120 = $5833.33333\r\n          uint pricePer1000tokensUsd = \r\n               ((STD_PRICE_USD_PER_1000_TOKENS * 100) * 1 ether) / (100 + discountPercents[priceIndex]);\r\n\r\n          // Correct: 300000 / 5833.33333333 = 51.42857142\r\n          // We have to multiply by '1 ether' to avoid float truncations\r\n          uint mntPerEth = (ETH_PRICE_IN_USD * 1000 * 1 ether * 1 ether) / pricePer1000tokensUsd;\r\n          return mntPerEth;\r\n     }\r\n\r\n     function buyTokens(address _buyer) public payable onlyInState(State.ICORunning) {\r\n          require(msg.value!=0);\r\n\r\n          // The price is selected based on current sold tokens.\r\n          // Price can 'overlap'. For example:\r\n          //   1. if currently we sold 699950 tokens (the price is 10% discount)\r\n          //   2. buyer buys 1000 tokens\r\n          //   3. the price of all 1000 tokens would be with 10% discount!!!\r\n          uint newTokens = (msg.value * getMntTokensPerEth(icoTokensSold)) / 1 ether;\r\n\r\n          issueTokensInternal(_buyer,newTokens);\r\n\r\n          // Update this only when buying from ETH\r\n          ethInvestedBy[msg.sender] = safeAdd(ethInvestedBy[msg.sender], msg.value);\r\n     }\r\n\r\n     /// @dev This is called by other currency processors to issue new tokens \r\n     function issueTokensFromOtherCurrency(address _to, uint _weiCount) onlyInState(State.ICORunning) public onlyOtherCurrenciesChecker {\r\n          require(_weiCount!=0);\r\n\r\n          uint newTokens = (_weiCount * getMntTokensPerEth(icoTokensSold)) / 1 ether;\r\n          issueTokensInternal(_to,newTokens);\r\n     }\r\n\r\n     /// @dev This can be called to manually issue new tokens \r\n     /// from the bonus reward\r\n     function issueTokensExternal(address _to, uint _tokens) public onlyInState(State.ICOFinished) onlyTokenManager {\r\n          // can not issue more than BONUS_REWARD\r\n          require((issuedExternallyTokens + _tokens)<=BONUS_REWARD);\r\n\r\n          mntToken.issueTokens(_to,_tokens);\r\n\r\n          issuedExternallyTokens = issuedExternallyTokens + _tokens;\r\n     }\r\n\r\n     function issueTokensInternal(address _to, uint _tokens) internal {\r\n          require((icoTokensSold + _tokens)<=ICO_TOKEN_SUPPLY_LIMIT);\r\n\r\n          mntToken.issueTokens(_to,_tokens);\r\n\r\n          icoTokensSold+=_tokens;\r\n\r\n          LogBuy(_to,_tokens);\r\n     }\r\n\r\n     // anyone can call this and get his money back\r\n     function getMyRefund() public onlyInState(State.Refunding) {\r\n          address sender = msg.sender;\r\n          uint ethValue = ethInvestedBy[sender];\r\n\r\n          require(ethValue > 0);\r\n\r\n          // 1 - send money back\r\n          sender.transfer(ethValue);\r\n          ethInvestedBy[sender] = 0;\r\n\r\n          // 2 - burn tokens\r\n          mntToken.burnTokens(sender, mntToken.balanceOf(sender));\r\n     }\r\n\r\n     // Default fallback function\r\n     function() payable {\r\n          // buyTokens -> issueTokensInternal\r\n          buyTokens(msg.sender);\r\n     }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  VariableDeclaration "multisigs"
     Type: address[] storage ref
     Gas costs: [???]
     Source: "address[] public multisigs = [\r\n          0x27ce565b1047c6258164062983bb8bc2917f11d2,\r\n          0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6,\r\n          0x7e2a7a10509177db2a7ea41e728743c4eb42f528,\r\n          0x27ce565b1047c6258164062983bb8bc2917f11d2,\r\n          0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6,\r\n          0x7e2a7a10509177db2a7ea41e728743c4eb42f528,\r\n          0x27ce565b1047c6258164062983bb8bc2917f11d2,\r\n          0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6,\r\n          0x7e2a7a10509177db2a7ea41e728743c4eb42f528,\r\n          0xF4Ce80097bf1E584822dBcA84f91D5d7d9df0846\r\n     ]"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
    TupleExpression
       Type: address[10] memory
       Source: "[\r\n          0x27ce565b1047c6258164062983bb8bc2917f11d2,\r\n          0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6,\r\n          0x7e2a7a10509177db2a7ea41e728743c4eb42f528,\r\n          0x27ce565b1047c6258164062983bb8bc2917f11d2,\r\n          0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6,\r\n          0x7e2a7a10509177db2a7ea41e728743c4eb42f528,\r\n          0x27ce565b1047c6258164062983bb8bc2917f11d2,\r\n          0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6,\r\n          0x7e2a7a10509177db2a7ea41e728743c4eb42f528,\r\n          0xF4Ce80097bf1E584822dBcA84f91D5d7d9df0846\r\n     ]"
      Literal, token: [no token] value: 0x27ce565b1047c6258164062983bb8bc2917f11d2
         Type: int_const 2272...(40 digits omitted)...5250
         Source: "0x27ce565b1047c6258164062983bb8bc2917f11d2"
      Literal, token: [no token] value: 0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6
         Type: int_const 1434...(41 digits omitted)...7990
         Source: "0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6"
      Literal, token: [no token] value: 0x7e2a7a10509177db2a7ea41e728743c4eb42f528
         Type: int_const 7202...(40 digits omitted)...7864
         Source: "0x7e2a7a10509177db2a7ea41e728743c4eb42f528"
      Literal, token: [no token] value: 0x27ce565b1047c6258164062983bb8bc2917f11d2
         Type: int_const 2272...(40 digits omitted)...5250
         Source: "0x27ce565b1047c6258164062983bb8bc2917f11d2"
      Literal, token: [no token] value: 0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6
         Type: int_const 1434...(41 digits omitted)...7990
         Source: "0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6"
      Literal, token: [no token] value: 0x7e2a7a10509177db2a7ea41e728743c4eb42f528
         Type: int_const 7202...(40 digits omitted)...7864
         Source: "0x7e2a7a10509177db2a7ea41e728743c4eb42f528"
      Literal, token: [no token] value: 0x27ce565b1047c6258164062983bb8bc2917f11d2
         Type: int_const 2272...(40 digits omitted)...5250
         Source: "0x27ce565b1047c6258164062983bb8bc2917f11d2"
      Literal, token: [no token] value: 0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6
         Type: int_const 1434...(41 digits omitted)...7990
         Source: "0xfb3afc815894e91fe1ab6e6ef36f8565fbb904f6"
      Literal, token: [no token] value: 0x7e2a7a10509177db2a7ea41e728743c4eb42f528
         Type: int_const 7202...(40 digits omitted)...7864
         Source: "0x7e2a7a10509177db2a7ea41e728743c4eb42f528"
      Literal, token: [no token] value: 0xF4Ce80097bf1E584822dBcA84f91D5d7d9df0846
         Type: address
         Source: "0xF4Ce80097bf1E584822dBcA84f91D5d7d9df0846"
  VariableDeclaration "ethInvestedBy"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint) ethInvestedBy"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "STD_PRICE_USD_PER_1000_TOKENS"
     Type: uint256
     Gas costs: 3
     Source: "uint constant STD_PRICE_USD_PER_1000_TOKENS = 7000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 7000
       Type: int_const 7000
       Source: "7000"
  VariableDeclaration "ETH_PRICE_IN_USD"
     Type: uint256
     Gas costs: 3
     Source: "uint constant ETH_PRICE_IN_USD = 300"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 300
       Type: int_const 300
       Source: "300"
  VariableDeclaration "SINGLE_BLOCK_LEN"
     Type: uint256
     Gas costs: 6
     Source: "uint constant SINGLE_BLOCK_LEN = 100"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 100
       Type: int_const 100
       Source: "100"
  VariableDeclaration "BONUS_REWARD"
     Type: uint256
     Gas costs: [???]
     Source: "uint public constant BONUS_REWARD = 1000000 * 1 ether"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: int_const 1000000000000000000000000
       Source: "1000000 * 1 ether"
      Literal, token: [no token] value: 1000000
         Type: int_const 1000000
         Source: "1000000"
      Literal, token: [no token] value: 1
         Type: int_const 1000000000000000000
         Source: "1 ether"
  VariableDeclaration "FOUNDERS_REWARD"
     Type: uint256
     Gas costs: [???]
     Source: "uint public constant FOUNDERS_REWARD = 2000000 * 1 ether"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: int_const 2000000000000000000000000
       Source: "2000000 * 1 ether"
      Literal, token: [no token] value: 2000000
         Type: int_const 2000000
         Source: "2000000"
      Literal, token: [no token] value: 1
         Type: int_const 1000000000000000000
         Source: "1 ether"
  VariableDeclaration "ICO_TOKEN_SUPPLY_LIMIT"
     Type: uint256
     Gas costs: [???]
     Source: "uint public constant ICO_TOKEN_SUPPLY_LIMIT = 150 * 1 ether"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: int_const 150000000000000000000
       Source: "150 * 1 ether"
      Literal, token: [no token] value: 150
         Type: int_const 150
         Source: "150"
      Literal, token: [no token] value: 1
         Type: int_const 1000000000000000000
         Source: "1 ether"
  VariableDeclaration "ICO_TOKEN_SOFT_CAP"
     Type: uint256
     Gas costs: [???]
     Source: "uint public constant ICO_TOKEN_SOFT_CAP = 150000 * 1 ether"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: int_const 150000000000000000000000
       Source: "150000 * 1 ether"
      Literal, token: [no token] value: 150000
         Type: int_const 150000
         Source: "150000"
      Literal, token: [no token] value: 1
         Type: int_const 1000000000000000000
         Source: "1 ether"
  VariableDeclaration "creator"
     Type: address
     Gas costs: [???]
     Source: "address public creator = 0x0"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x0
       Type: int_const 0
       Source: "0x0"
  VariableDeclaration "tokenManager"
     Type: address
     Gas costs: [???]
     Source: "address public tokenManager = 0x0"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x0
       Type: int_const 0
       Source: "0x0"
  VariableDeclaration "otherCurrenciesChecker"
     Type: address
     Gas costs: [???]
     Source: "address public otherCurrenciesChecker = 0x0"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x0
       Type: int_const 0
       Source: "0x0"
  VariableDeclaration "icoStartedTime"
     Type: uint64
     Gas costs: [???]
     Source: "uint64 public icoStartedTime = 0"
    ElementaryTypeName uint64
       Source: "uint64"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "mntToken"
     Type: contract MNTP
     Gas costs: [???]
     Source: "MNTP public mntToken"
    UserDefinedTypeName "MNTP"
       Source: "MNTP"
  VariableDeclaration "unsoldContract"
     Type: contract GoldmintUnsold
     Gas costs: [???]
     Source: "GoldmintUnsold public unsoldContract"
    UserDefinedTypeName "GoldmintUnsold"
       Source: "GoldmintUnsold"
  VariableDeclaration "icoTokensSold"
     Type: uint256
     Gas costs: [???]
     Source: "uint public icoTokensSold = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "icoTokensUnsold"
     Type: uint256
     Gas costs: [???]
     Source: "uint public icoTokensUnsold = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "issuedExternallyTokens"
     Type: uint256
     Gas costs: [???]
     Source: "uint public issuedExternallyTokens = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "foundersRewardsAccount"
     Type: address
     Gas costs: [???]
     Source: "address public foundersRewardsAccount = 0x0"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x0
       Type: int_const 0
       Source: "0x0"
  EnumDefinition "State"
    EnumValue "Init"
    EnumValue "ICORunning"
    EnumValue "ICOPaused"
    EnumValue "ICOFinished"
    EnumValue "Refunding"
    EnumValue "Migrating"
  VariableDeclaration "currentState"
     Type: enum Goldmint.State
     Gas costs: [???]
     Source: "State public currentState = State.Init"
    UserDefinedTypeName "State"
       Source: "State"
    MemberAccess to member Init
       Type: enum Goldmint.State
       Source: "State.Init"
      Identifier State
         Type: type(enum Goldmint.State)
         Source: "State"
  ModifierDefinition "onlyCreator"
     Source: "modifier onlyCreator() { \r\n          require(msg.sender==creator); \r\n          _; \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ \r\n          require(msg.sender==creator); \r\n          _; \r\n     }"
      ExpressionStatement
         Gas costs: 1410
         Source: "require(msg.sender==creator)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender==creator)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender==creator"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier creator
               Type: address
               Source: "creator"
      PlaceholderStatement
         Gas costs: 10
         Source: "_"
  ModifierDefinition "onlyTokenManager"
     Source: "modifier onlyTokenManager() { \r\n          require(msg.sender==tokenManager); \r\n          _; \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ \r\n          require(msg.sender==tokenManager); \r\n          _; \r\n     }"
      ExpressionStatement
         Gas costs: 564
         Source: "require(msg.sender==tokenManager)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender==tokenManager)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender==tokenManager"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier tokenManager
               Type: address
               Source: "tokenManager"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyOtherCurrenciesChecker"
     Source: "modifier onlyOtherCurrenciesChecker() { \r\n          require(msg.sender==otherCurrenciesChecker); \r\n          _; \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ \r\n          require(msg.sender==otherCurrenciesChecker); \r\n          _; \r\n     }"
      ExpressionStatement
         Gas costs: 282
         Source: "require(msg.sender==otherCurrenciesChecker)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender==otherCurrenciesChecker)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender==otherCurrenciesChecker"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier otherCurrenciesChecker
               Type: address
               Source: "otherCurrenciesChecker"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyInState"
     Source: "modifier onlyInState(State state){ \r\n          require(state==currentState); \r\n          _; \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(State state)"
      VariableDeclaration "state"
         Type: enum Goldmint.State
         Source: "State state"
        UserDefinedTypeName "State"
           Source: "State"
    Block
       Source: "{ \r\n          require(state==currentState); \r\n          _; \r\n     }"
      ExpressionStatement
         Gas costs: 3730
         Source: "require(state==currentState)"
        FunctionCall
           Type: tuple()
           Source: "require(state==currentState)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "state==currentState"
            Identifier state
               Type: enum Goldmint.State
               Source: "state"
            Identifier currentState
               Type: enum Goldmint.State
               Source: "currentState"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  EventDefinition "LogStateSwitch"
     Gas costs: 0
     Source: "event LogStateSwitch(State newState);"
    ParameterList
       Source: "(State newState)"
      VariableDeclaration "newState"
         Type: enum Goldmint.State
         Source: "State newState"
        UserDefinedTypeName "State"
           Source: "State"
  EventDefinition "LogBuy"
     Gas costs: 0
     Source: "event LogBuy(address indexed owner, uint value);"
    ParameterList
       Source: "(address indexed owner, uint value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LogBurn"
     Gas costs: 0
     Source: "event LogBurn(address indexed owner, uint value);"
    ParameterList
       Source: "(address indexed owner, uint value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "Goldmint" - public
     Source: "function Goldmint(\r\n          address _tokenManager,\r\n          address _otherCurrenciesChecker,\r\n\r\n          address _mntTokenAddress,\r\n          address _unsoldContractAddress,\r\n          address _foundersVestingAddress)\r\n     {\r\n          creator = msg.sender;\r\n\r\n          tokenManager = _tokenManager;\r\n          otherCurrenciesChecker = _otherCurrenciesChecker; \r\n\r\n          mntToken = MNTP(_mntTokenAddress);\r\n          unsoldContract = GoldmintUnsold(_unsoldContractAddress);\r\n\r\n          // slight rename\r\n          foundersRewardsAccount = _foundersVestingAddress;\r\n\r\n          assert(multisigs.length==10);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n          address _tokenManager,\r\n          address _otherCurrenciesChecker,\r\n\r\n          address _mntTokenAddress,\r\n          address _unsoldContractAddress,\r\n          address _foundersVestingAddress)"
      VariableDeclaration "_tokenManager"
         Type: address
         Source: "address _tokenManager"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_otherCurrenciesChecker"
         Type: address
         Source: "address _otherCurrenciesChecker"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_mntTokenAddress"
         Type: address
         Source: "address _mntTokenAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_unsoldContractAddress"
         Type: address
         Source: "address _unsoldContractAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_foundersVestingAddress"
         Type: address
         Source: "address _foundersVestingAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n          creator = msg.sender;\r\n\r\n          tokenManager = _tokenManager;\r\n          otherCurrenciesChecker = _otherCurrenciesChecker; \r\n\r\n          mntToken = MNTP(_mntTokenAddress);\r\n          unsoldContract = GoldmintUnsold(_unsoldContractAddress);\r\n\r\n          // slight rename\r\n          foundersRewardsAccount = _foundersVestingAddress;\r\n\r\n          assert(multisigs.length==10);\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "creator = msg.sender"
        Assignment using operator =
           Type: address
           Source: "creator = msg.sender"
          Identifier creator
             Type: address
             Source: "creator"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenManager = _tokenManager"
        Assignment using operator =
           Type: address
           Source: "tokenManager = _tokenManager"
          Identifier tokenManager
             Type: address
             Source: "tokenManager"
          Identifier _tokenManager
             Type: address
             Source: "_tokenManager"
      ExpressionStatement
         Gas costs: 0
         Source: "otherCurrenciesChecker = _otherCurrenciesChecker"
        Assignment using operator =
           Type: address
           Source: "otherCurrenciesChecker = _otherCurrenciesChecker"
          Identifier otherCurrenciesChecker
             Type: address
             Source: "otherCurrenciesChecker"
          Identifier _otherCurrenciesChecker
             Type: address
             Source: "_otherCurrenciesChecker"
      ExpressionStatement
         Gas costs: 0
         Source: "mntToken = MNTP(_mntTokenAddress)"
        Assignment using operator =
           Type: contract MNTP
           Source: "mntToken = MNTP(_mntTokenAddress)"
          Identifier mntToken
             Type: contract MNTP
             Source: "mntToken"
          FunctionCall
             Type: contract MNTP
             Source: "MNTP(_mntTokenAddress)"
            Identifier MNTP
               Type: type(contract MNTP)
               Source: "MNTP"
            Identifier _mntTokenAddress
               Type: address
               Source: "_mntTokenAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "unsoldContract = GoldmintUnsold(_unsoldContractAddress)"
        Assignment using operator =
           Type: contract GoldmintUnsold
           Source: "unsoldContract = GoldmintUnsold(_unsoldContractAddress)"
          Identifier unsoldContract
             Type: contract GoldmintUnsold
             Source: "unsoldContract"
          FunctionCall
             Type: contract GoldmintUnsold
             Source: "GoldmintUnsold(_unsoldContractAddress)"
            Identifier GoldmintUnsold
               Type: type(contract GoldmintUnsold)
               Source: "GoldmintUnsold"
            Identifier _unsoldContractAddress
               Type: address
               Source: "_unsoldContractAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "foundersRewardsAccount = _foundersVestingAddress"
        Assignment using operator =
           Type: address
           Source: "foundersRewardsAccount = _foundersVestingAddress"
          Identifier foundersRewardsAccount
             Type: address
             Source: "foundersRewardsAccount"
          Identifier _foundersVestingAddress
             Type: address
             Source: "_foundersVestingAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(multisigs.length==10)"
        FunctionCall
           Type: tuple()
           Source: "assert(multisigs.length==10)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "multisigs.length==10"
            MemberAccess to member length
               Type: uint256
               Source: "multisigs.length"
              Identifier multisigs
                 Type: address[] storage ref
                 Source: "multisigs"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
  FunctionDefinition "startICO" - public
     Source: "function startICO() public onlyCreator onlyInState(State.Init) {\r\n          setState(State.ICORunning);\r\n          icoStartedTime = uint64(now);\r\n          mntToken.lockTransfer(true);\r\n          mntToken.issueTokens(foundersRewardsAccount, FOUNDERS_REWARD);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyCreator"
       Gas costs: 0
       Source: "onlyCreator"
      Identifier onlyCreator
         Type: modifier ()
         Source: "onlyCreator"
    ModifierInvocation "onlyInState"
       Gas costs: 3
       Source: "onlyInState(State.Init)"
      Identifier onlyInState
         Type: modifier (enum Goldmint.State)
         Source: "onlyInState"
      MemberAccess to member Init
         Type: enum Goldmint.State
         Source: "State.Init"
        Identifier State
           Type: type(enum Goldmint.State)
           Source: "State"
    Block
       Source: "{\r\n          setState(State.ICORunning);\r\n          icoStartedTime = uint64(now);\r\n          mntToken.lockTransfer(true);\r\n          mntToken.issueTokens(foundersRewardsAccount, FOUNDERS_REWARD);\r\n     }"
      ExpressionStatement
         Gas costs: 18
         Source: "setState(State.ICORunning)"
        FunctionCall
           Type: tuple()
           Source: "setState(State.ICORunning)"
          Identifier setState
             Type: function (enum Goldmint.State)
             Source: "setState"
          MemberAccess to member ICORunning
             Type: enum Goldmint.State
             Source: "State.ICORunning"
            Identifier State
               Type: type(enum Goldmint.State)
               Source: "State"
      ExpressionStatement
         Gas costs: 20316
         Source: "icoStartedTime = uint64(now)"
        Assignment using operator =
           Type: uint64
           Source: "icoStartedTime = uint64(now)"
          Identifier icoStartedTime
             Type: uint64
             Source: "icoStartedTime"
          FunctionCall
             Type: uint64
             Source: "uint64(now)"
            ElementaryTypeNameExpression uint64
               Type: type(uint64)
               Source: "uint64"
            Identifier now
               Type: uint256
               Source: "now"
      ExpressionStatement
         Gas costs: [???]
         Source: "mntToken.lockTransfer(true)"
        FunctionCall
           Type: tuple()
           Source: "mntToken.lockTransfer(true)"
          MemberAccess to member lockTransfer
             Type: function (bool) external
             Source: "mntToken.lockTransfer"
            Identifier mntToken
               Type: contract MNTP
               Source: "mntToken"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: [???]
         Source: "mntToken.issueTokens(foundersRewardsAccount, FOUNDERS_REWARD)"
        FunctionCall
           Type: tuple()
           Source: "mntToken.issueTokens(foundersRewardsAccount, FOUNDERS_REWARD)"
          MemberAccess to member issueTokens
             Type: function (address,uint256) external
             Source: "mntToken.issueTokens"
            Identifier mntToken
               Type: contract MNTP
               Source: "mntToken"
          Identifier foundersRewardsAccount
             Type: address
             Source: "foundersRewardsAccount"
          Identifier FOUNDERS_REWARD
             Type: uint256
             Source: "FOUNDERS_REWARD"
  FunctionDefinition "pauseICO" - public
     Source: "function pauseICO() public onlyCreator onlyInState(State.ICORunning) {\r\n          setState(State.ICOPaused);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyCreator"
       Gas costs: 0
       Source: "onlyCreator"
      Identifier onlyCreator
         Type: modifier ()
         Source: "onlyCreator"
    ModifierInvocation "onlyInState"
       Gas costs: 3
       Source: "onlyInState(State.ICORunning)"
      Identifier onlyInState
         Type: modifier (enum Goldmint.State)
         Source: "onlyInState"
      MemberAccess to member ICORunning
         Type: enum Goldmint.State
         Source: "State.ICORunning"
        Identifier State
           Type: type(enum Goldmint.State)
           Source: "State"
    Block
       Source: "{\r\n          setState(State.ICOPaused);\r\n     }"
      ExpressionStatement
         Gas costs: 18
         Source: "setState(State.ICOPaused)"
        FunctionCall
           Type: tuple()
           Source: "setState(State.ICOPaused)"
          Identifier setState
             Type: function (enum Goldmint.State)
             Source: "setState"
          MemberAccess to member ICOPaused
             Type: enum Goldmint.State
             Source: "State.ICOPaused"
            Identifier State
               Type: type(enum Goldmint.State)
               Source: "State"
  FunctionDefinition "resumeICO" - public
     Source: "function resumeICO() public onlyCreator onlyInState(State.ICOPaused) {\r\n          setState(State.ICORunning);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyCreator"
       Gas costs: 0
       Source: "onlyCreator"
      Identifier onlyCreator
         Type: modifier ()
         Source: "onlyCreator"
    ModifierInvocation "onlyInState"
       Gas costs: 3
       Source: "onlyInState(State.ICOPaused)"
      Identifier onlyInState
         Type: modifier (enum Goldmint.State)
         Source: "onlyInState"
      MemberAccess to member ICOPaused
         Type: enum Goldmint.State
         Source: "State.ICOPaused"
        Identifier State
           Type: type(enum Goldmint.State)
           Source: "State"
    Block
       Source: "{\r\n          setState(State.ICORunning);\r\n     }"
      ExpressionStatement
         Gas costs: 18
         Source: "setState(State.ICORunning)"
        FunctionCall
           Type: tuple()
           Source: "setState(State.ICORunning)"
          Identifier setState
             Type: function (enum Goldmint.State)
             Source: "setState"
          MemberAccess to member ICORunning
             Type: enum Goldmint.State
             Source: "State.ICORunning"
            Identifier State
               Type: type(enum Goldmint.State)
               Source: "State"
  FunctionDefinition "startRefunding" - public
     Source: "function startRefunding() public onlyCreator onlyInState(State.ICORunning) {\r\n          // only switch to this state if less than ICO_TOKEN_SOFT_CAP sold\r\n          require(icoTokensSold < ICO_TOKEN_SOFT_CAP);\r\n          setState(State.Refunding);\r\n\r\n          // in this state tokens still shouldn't be transferred\r\n          assert(mntToken.lockTransfers());\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyCreator"
       Gas costs: 0
       Source: "onlyCreator"
      Identifier onlyCreator
         Type: modifier ()
         Source: "onlyCreator"
    ModifierInvocation "onlyInState"
       Gas costs: 3
       Source: "onlyInState(State.ICORunning)"
      Identifier onlyInState
         Type: modifier (enum Goldmint.State)
         Source: "onlyInState"
      MemberAccess to member ICORunning
         Type: enum Goldmint.State
         Source: "State.ICORunning"
        Identifier State
           Type: type(enum Goldmint.State)
           Source: "State"
    Block
       Source: "{\r\n          // only switch to this state if less than ICO_TOKEN_SOFT_CAP sold\r\n          require(icoTokensSold < ICO_TOKEN_SOFT_CAP);\r\n          setState(State.Refunding);\r\n\r\n          // in this state tokens still shouldn't be transferred\r\n          assert(mntToken.lockTransfers());\r\n     }"
      ExpressionStatement
         Gas costs: 232
         Source: "require(icoTokensSold < ICO_TOKEN_SOFT_CAP)"
        FunctionCall
           Type: tuple()
           Source: "require(icoTokensSold < ICO_TOKEN_SOFT_CAP)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "icoTokensSold < ICO_TOKEN_SOFT_CAP"
            Identifier icoTokensSold
               Type: uint256
               Source: "icoTokensSold"
            Identifier ICO_TOKEN_SOFT_CAP
               Type: uint256
               Source: "ICO_TOKEN_SOFT_CAP"
      ExpressionStatement
         Gas costs: 18
         Source: "setState(State.Refunding)"
        FunctionCall
           Type: tuple()
           Source: "setState(State.Refunding)"
          Identifier setState
             Type: function (enum Goldmint.State)
             Source: "setState"
          MemberAccess to member Refunding
             Type: enum Goldmint.State
             Source: "State.Refunding"
            Identifier State
               Type: type(enum Goldmint.State)
               Source: "State"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(mntToken.lockTransfers())"
        FunctionCall
           Type: tuple()
           Source: "assert(mntToken.lockTransfers())"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          FunctionCall
             Type: bool
             Source: "mntToken.lockTransfers()"
            MemberAccess to member lockTransfers
               Type: function () view external returns (bool)
               Source: "mntToken.lockTransfers"
              Identifier mntToken
                 Type: contract MNTP
                 Source: "mntToken"
  FunctionDefinition "startMigration" - public
     Source: "function startMigration() public onlyCreator onlyInState(State.ICOFinished) {\r\n          // there is no way back...\r\n          setState(State.Migrating);\r\n\r\n          // disable token transfers\r\n          mntToken.lockTransfer(true);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyCreator"
       Gas costs: 0
       Source: "onlyCreator"
      Identifier onlyCreator
         Type: modifier ()
         Source: "onlyCreator"
    ModifierInvocation "onlyInState"
       Gas costs: 3
       Source: "onlyInState(State.ICOFinished)"
      Identifier onlyInState
         Type: modifier (enum Goldmint.State)
         Source: "onlyInState"
      MemberAccess to member ICOFinished
         Type: enum Goldmint.State
         Source: "State.ICOFinished"
        Identifier State
           Type: type(enum Goldmint.State)
           Source: "State"
    Block
       Source: "{\r\n          // there is no way back...\r\n          setState(State.Migrating);\r\n\r\n          // disable token transfers\r\n          mntToken.lockTransfer(true);\r\n     }"
      ExpressionStatement
         Gas costs: 7
         Source: "setState(State.Migrating)"
        FunctionCall
           Type: tuple()
           Source: "setState(State.Migrating)"
          Identifier setState
             Type: function (enum Goldmint.State)
             Source: "setState"
          MemberAccess to member Migrating
             Type: enum Goldmint.State
             Source: "State.Migrating"
            Identifier State
               Type: type(enum Goldmint.State)
               Source: "State"
      ExpressionStatement
         Gas costs: [???]
         Source: "mntToken.lockTransfer(true)"
        FunctionCall
           Type: tuple()
           Source: "mntToken.lockTransfer(true)"
          MemberAccess to member lockTransfer
             Type: function (bool) external
             Source: "mntToken.lockTransfer"
            Identifier mntToken
               Type: contract MNTP
               Source: "mntToken"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "finishICO" - public
     Source: "function finishICO() public onlyInState(State.ICORunning) {\r\n          require(msg.sender == creator || isIcoFinished());\r\n          setState(State.ICOFinished);\r\n\r\n          // 1 - lock all transfers\r\n          mntToken.lockTransfer(false);\r\n\r\n          // 2 - move all unsold tokens to unsoldTokens contract\r\n          icoTokensUnsold = safeSub(ICO_TOKEN_SUPPLY_LIMIT,icoTokensSold);\r\n          if(icoTokensUnsold>0){\r\n               mntToken.issueTokens(unsoldContract,icoTokensUnsold);\r\n               unsoldContract.finishIco();\r\n          }\r\n\r\n          // 3 - send all ETH to multisigs\r\n          // we have N separate multisigs for extra security\r\n          uint sendThisAmount = (this.balance / 10);\r\n\r\n          // 3.1 - send to 9 multisigs\r\n          for(uint i=0; i<9; ++i){\r\n               address ms = multisigs[i];\r\n\r\n               if(this.balance>=sendThisAmount){\r\n                    ms.transfer(sendThisAmount);\r\n               }\r\n          }\r\n\r\n          // 3.2 - send everything left to 10th multisig\r\n          if(0!=this.balance){\r\n               address lastMs = multisigs[9];\r\n               lastMs.transfer(this.balance);\r\n          }\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyInState"
       Gas costs: 3
       Source: "onlyInState(State.ICORunning)"
      Identifier onlyInState
         Type: modifier (enum Goldmint.State)
         Source: "onlyInState"
      MemberAccess to member ICORunning
         Type: enum Goldmint.State
         Source: "State.ICORunning"
        Identifier State
           Type: type(enum Goldmint.State)
           Source: "State"
    Block
       Source: "{\r\n          require(msg.sender == creator || isIcoFinished());\r\n          setState(State.ICOFinished);\r\n\r\n          // 1 - lock all transfers\r\n          mntToken.lockTransfer(false);\r\n\r\n          // 2 - move all unsold tokens to unsoldTokens contract\r\n          icoTokensUnsold = safeSub(ICO_TOKEN_SUPPLY_LIMIT,icoTokensSold);\r\n          if(icoTokensUnsold>0){\r\n               mntToken.issueTokens(unsoldContract,icoTokensUnsold);\r\n               unsoldContract.finishIco();\r\n          }\r\n\r\n          // 3 - send all ETH to multisigs\r\n          // we have N separate multisigs for extra security\r\n          uint sendThisAmount = (this.balance / 10);\r\n\r\n          // 3.1 - send to 9 multisigs\r\n          for(uint i=0; i<9; ++i){\r\n               address ms = multisigs[i];\r\n\r\n               if(this.balance>=sendThisAmount){\r\n                    ms.transfer(sendThisAmount);\r\n               }\r\n          }\r\n\r\n          // 3.2 - send everything left to 10th multisig\r\n          if(0!=this.balance){\r\n               address lastMs = multisigs[9];\r\n               lastMs.transfer(this.balance);\r\n          }\r\n     }"
      ExpressionStatement
         Gas costs: 316
         Source: "require(msg.sender == creator || isIcoFinished())"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == creator || isIcoFinished())"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "msg.sender == creator || isIcoFinished()"
            BinaryOperation using operator ==
               Type: bool
               Source: "msg.sender == creator"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier creator
                 Type: address
                 Source: "creator"
            FunctionCall
               Type: bool
               Source: "isIcoFinished()"
              Identifier isIcoFinished
                 Type: function () view returns (bool)
                 Source: "isIcoFinished"
      ExpressionStatement
         Gas costs: 18
         Source: "setState(State.ICOFinished)"
        FunctionCall
           Type: tuple()
           Source: "setState(State.ICOFinished)"
          Identifier setState
             Type: function (enum Goldmint.State)
             Source: "setState"
          MemberAccess to member ICOFinished
             Type: enum Goldmint.State
             Source: "State.ICOFinished"
            Identifier State
               Type: type(enum Goldmint.State)
               Source: "State"
      ExpressionStatement
         Gas costs: [???]
         Source: "mntToken.lockTransfer(false)"
        FunctionCall
           Type: tuple()
           Source: "mntToken.lockTransfer(false)"
          MemberAccess to member lockTransfer
             Type: function (bool) external
             Source: "mntToken.lockTransfer"
            Identifier mntToken
               Type: contract MNTP
               Source: "mntToken"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 20218
         Source: "icoTokensUnsold = safeSub(ICO_TOKEN_SUPPLY_LIMIT,icoTokensSold)"
        Assignment using operator =
           Type: uint256
           Source: "icoTokensUnsold = safeSub(ICO_TOKEN_SUPPLY_LIMIT,icoTokensSold)"
          Identifier icoTokensUnsold
             Type: uint256
             Source: "icoTokensUnsold"
          FunctionCall
             Type: uint256
             Source: "safeSub(ICO_TOKEN_SUPPLY_LIMIT,icoTokensSold)"
            Identifier safeSub
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeSub"
            Identifier ICO_TOKEN_SUPPLY_LIMIT
               Type: uint256
               Source: "ICO_TOKEN_SUPPLY_LIMIT"
            Identifier icoTokensSold
               Type: uint256
               Source: "icoTokensSold"
      IfStatement
         Source: "if(icoTokensUnsold>0){\r\n               mntToken.issueTokens(unsoldContract,icoTokensUnsold);\r\n               unsoldContract.finishIco();\r\n          }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "icoTokensUnsold>0"
          Identifier icoTokensUnsold
             Type: uint256
             Source: "icoTokensUnsold"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n               mntToken.issueTokens(unsoldContract,icoTokensUnsold);\r\n               unsoldContract.finishIco();\r\n          }"
          ExpressionStatement
             Gas costs: [???]
             Source: "mntToken.issueTokens(unsoldContract,icoTokensUnsold)"
            FunctionCall
               Type: tuple()
               Source: "mntToken.issueTokens(unsoldContract,icoTokensUnsold)"
              MemberAccess to member issueTokens
                 Type: function (address,uint256) external
                 Source: "mntToken.issueTokens"
                Identifier mntToken
                   Type: contract MNTP
                   Source: "mntToken"
              Identifier unsoldContract
                 Type: contract GoldmintUnsold
                 Source: "unsoldContract"
              Identifier icoTokensUnsold
                 Type: uint256
                 Source: "icoTokensUnsold"
          ExpressionStatement
             Gas costs: [???]
             Source: "unsoldContract.finishIco()"
            FunctionCall
               Type: tuple()
               Source: "unsoldContract.finishIco()"
              MemberAccess to member finishIco
                 Type: function () external
                 Source: "unsoldContract.finishIco"
                Identifier unsoldContract
                   Type: contract GoldmintUnsold
                   Source: "unsoldContract"
      VariableDeclarationStatement
         Gas costs: 447
         Source: "uint sendThisAmount = (this.balance / 10)"
        VariableDeclaration "sendThisAmount"
           Type: uint256
           Source: "uint sendThisAmount"
          ElementaryTypeName uint
             Source: "uint"
        TupleExpression
           Type: uint256
           Source: "(this.balance / 10)"
          BinaryOperation using operator /
             Type: uint256
             Source: "this.balance / 10"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract Goldmint
                 Source: "this"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
      ForStatement
         Source: "for(uint i=0; i<9; ++i){\r\n               address ms = multisigs[i];\r\n\r\n               if(this.balance>=sendThisAmount){\r\n                    ms.transfer(sendThisAmount);\r\n               }\r\n          }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i<9"
          Identifier i
             Type: uint256
             Source: "i"
          Literal, token: [no token] value: 9
             Type: int_const 9
             Source: "9"
        ExpressionStatement
           Gas costs: 14
           Source: "++i"
          UnaryOperation (prefix) ++
             Type: uint256
             Source: "++i"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n               address ms = multisigs[i];\r\n\r\n               if(this.balance>=sendThisAmount){\r\n                    ms.transfer(sendThisAmount);\r\n               }\r\n          }"
          VariableDeclarationStatement
             Gas costs: 536
             Source: "address ms = multisigs[i]"
            VariableDeclaration "ms"
               Type: address
               Source: "address ms"
              ElementaryTypeName address
                 Source: "address"
            IndexAccess
               Type: address
               Source: "multisigs[i]"
              Identifier multisigs
                 Type: address[] storage ref
                 Source: "multisigs"
              Identifier i
                 Type: uint256
                 Source: "i"
          IfStatement
             Source: "if(this.balance>=sendThisAmount){\r\n                    ms.transfer(sendThisAmount);\r\n               }"
            BinaryOperation using operator >=
               Type: bool
               Gas costs: 417
               Source: "this.balance>=sendThisAmount"
              MemberAccess to member balance
                 Type: uint256
                 Source: "this.balance"
                Identifier this
                   Type: contract Goldmint
                   Source: "this"
              Identifier sendThisAmount
                 Type: uint256
                 Source: "sendThisAmount"
            Block
               Source: "{\r\n                    ms.transfer(sendThisAmount);\r\n               }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "ms.transfer(sendThisAmount)"
                FunctionCall
                   Type: tuple()
                   Source: "ms.transfer(sendThisAmount)"
                  MemberAccess to member transfer
                     Type: function (uint256)
                     Source: "ms.transfer"
                    Identifier ms
                       Type: address
                       Source: "ms"
                  Identifier sendThisAmount
                     Type: uint256
                     Source: "sendThisAmount"
      IfStatement
         Source: "if(0!=this.balance){\r\n               address lastMs = multisigs[9];\r\n               lastMs.transfer(this.balance);\r\n          }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 417
           Source: "0!=this.balance"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract Goldmint
               Source: "this"
        Block
           Source: "{\r\n               address lastMs = multisigs[9];\r\n               lastMs.transfer(this.balance);\r\n          }"
          VariableDeclarationStatement
             Gas costs: 536
             Source: "address lastMs = multisigs[9]"
            VariableDeclaration "lastMs"
               Type: address
               Source: "address lastMs"
              ElementaryTypeName address
                 Source: "address"
            IndexAccess
               Type: address
               Source: "multisigs[9]"
              Identifier multisigs
                 Type: address[] storage ref
                 Source: "multisigs"
              Literal, token: [no token] value: 9
                 Type: int_const 9
                 Source: "9"
          ExpressionStatement
             Gas costs: [???]
             Source: "lastMs.transfer(this.balance)"
            FunctionCall
               Type: tuple()
               Source: "lastMs.transfer(this.balance)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "lastMs.transfer"
                Identifier lastMs
                   Type: address
                   Source: "lastMs"
              MemberAccess to member balance
                 Type: uint256
                 Source: "this.balance"
                Identifier this
                   Type: contract Goldmint
                   Source: "this"
  FunctionDefinition "setState"
     Source: "function setState(State _s) internal {\r\n          currentState = _s;\r\n          LogStateSwitch(_s);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(State _s)"
      VariableDeclaration "_s"
         Type: enum Goldmint.State
         Source: "State _s"
        UserDefinedTypeName "State"
           Source: "State"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n          currentState = _s;\r\n          LogStateSwitch(_s);\r\n     }"
      ExpressionStatement
         Gas costs: 20337
         Source: "currentState = _s"
        Assignment using operator =
           Type: enum Goldmint.State
           Source: "currentState = _s"
          Identifier currentState
             Type: enum Goldmint.State
             Source: "currentState"
          Identifier _s
             Type: enum Goldmint.State
             Source: "_s"
      ExpressionStatement
         Gas costs: [???]
         Source: "LogStateSwitch(_s)"
        FunctionCall
           Type: tuple()
           Source: "LogStateSwitch(_s)"
          Identifier LogStateSwitch
             Type: function (enum Goldmint.State)
             Source: "LogStateSwitch"
          Identifier _s
             Type: enum Goldmint.State
             Source: "_s"
  FunctionDefinition "setTokenManager" - public
     Source: "function setTokenManager(address _new) public onlyTokenManager {\r\n          tokenManager = _new;\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _new)"
      VariableDeclaration "_new"
         Type: address
         Source: "address _new"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyTokenManager"
       Gas costs: 0
       Source: "onlyTokenManager"
      Identifier onlyTokenManager
         Type: modifier ()
         Source: "onlyTokenManager"
    Block
       Source: "{\r\n          tokenManager = _new;\r\n     }"
      ExpressionStatement
         Gas costs: 20267
         Source: "tokenManager = _new"
        Assignment using operator =
           Type: address
           Source: "tokenManager = _new"
          Identifier tokenManager
             Type: address
             Source: "tokenManager"
          Identifier _new
             Type: address
             Source: "_new"
  FunctionDefinition "getTokensIcoSold" - public - const
     Source: "function getTokensIcoSold() constant public returns (uint){          \r\n          return icoTokensSold;       \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{          \r\n          return icoTokensSold;       \r\n     }"
      Return
         Gas costs: 208
         Source: "return icoTokensSold"
        Identifier icoTokensSold
           Type: uint256
           Source: "icoTokensSold"
  FunctionDefinition "getTotalIcoTokens" - public - const
     Source: "function getTotalIcoTokens() constant public returns (uint){          \r\n          return ICO_TOKEN_SUPPLY_LIMIT;         \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{          \r\n          return ICO_TOKEN_SUPPLY_LIMIT;         \r\n     }"
      Return
         Gas costs: 5
         Source: "return ICO_TOKEN_SUPPLY_LIMIT"
        Identifier ICO_TOKEN_SUPPLY_LIMIT
           Type: uint256
           Source: "ICO_TOKEN_SUPPLY_LIMIT"
  FunctionDefinition "getMntTokenBalance" - public - const
     Source: "function getMntTokenBalance(address _of) constant public returns (uint){         \r\n          return mntToken.balanceOf(_of);         \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _of)"
      VariableDeclaration "_of"
         Type: address
         Source: "address _of"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{         \r\n          return mntToken.balanceOf(_of);         \r\n     }"
      Return
         Gas costs: [???]
         Source: "return mntToken.balanceOf(_of)"
        FunctionCall
           Type: uint256
           Source: "mntToken.balanceOf(_of)"
          MemberAccess to member balanceOf
             Type: function (address) view external returns (uint256)
             Source: "mntToken.balanceOf"
            Identifier mntToken
               Type: contract MNTP
               Source: "mntToken"
          Identifier _of
             Type: address
             Source: "_of"
  FunctionDefinition "getBlockLength" - public - const
     Source: "function getBlockLength()constant public returns (uint){          \r\n          return SINGLE_BLOCK_LEN;      \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{          \r\n          return SINGLE_BLOCK_LEN;      \r\n     }"
      Return
         Gas costs: 5
         Source: "return SINGLE_BLOCK_LEN"
        Identifier SINGLE_BLOCK_LEN
           Type: uint256
           Source: "SINGLE_BLOCK_LEN"
  FunctionDefinition "getCurrentPrice" - public - const
     Source: "function getCurrentPrice()constant public returns (uint){\r\n          return getMntTokensPerEth(icoTokensSold);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n          return getMntTokensPerEth(icoTokensSold);\r\n     }"
      Return
         Gas costs: 223
         Source: "return getMntTokensPerEth(icoTokensSold)"
        FunctionCall
           Type: uint256
           Source: "getMntTokensPerEth(icoTokensSold)"
          Identifier getMntTokensPerEth
             Type: function (uint256) view returns (uint256)
             Source: "getMntTokensPerEth"
          Identifier icoTokensSold
             Type: uint256
             Source: "icoTokensSold"
  FunctionDefinition "isIcoFinished" - public - const
     Source: "function isIcoFinished() constant public returns(bool) {\r\n          return (icoStartedTime > 0)\r\n            && (now > (icoStartedTime + 30 days) || (icoTokensSold >= ICO_TOKEN_SUPPLY_LIMIT));\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n          return (icoStartedTime > 0)\r\n            && (now > (icoStartedTime + 30 days) || (icoTokensSold >= ICO_TOKEN_SUPPLY_LIMIT));\r\n     }"
      Return
         Gas costs: 862
         Source: "return (icoStartedTime > 0)\r\n            && (now > (icoStartedTime + 30 days) || (icoTokensSold >= ICO_TOKEN_SUPPLY_LIMIT))"
        BinaryOperation using operator &&
           Type: bool
           Source: "(icoStartedTime > 0)\r\n            && (now > (icoStartedTime + 30 days) || (icoTokensSold >= ICO_TOKEN_SUPPLY_LIMIT))"
          TupleExpression
             Type: bool
             Source: "(icoStartedTime > 0)"
            BinaryOperation using operator >
               Type: bool
               Source: "icoStartedTime > 0"
              Identifier icoStartedTime
                 Type: uint64
                 Source: "icoStartedTime"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          TupleExpression
             Type: bool
             Source: "(now > (icoStartedTime + 30 days) || (icoTokensSold >= ICO_TOKEN_SUPPLY_LIMIT))"
            BinaryOperation using operator ||
               Type: bool
               Source: "now > (icoStartedTime + 30 days) || (icoTokensSold >= ICO_TOKEN_SUPPLY_LIMIT)"
              BinaryOperation using operator >
                 Type: bool
                 Source: "now > (icoStartedTime + 30 days)"
                Identifier now
                   Type: uint256
                   Source: "now"
                TupleExpression
                   Type: uint64
                   Source: "(icoStartedTime + 30 days)"
                  BinaryOperation using operator +
                     Type: uint64
                     Source: "icoStartedTime + 30 days"
                    Identifier icoStartedTime
                       Type: uint64
                       Source: "icoStartedTime"
                    Literal, token: [no token] value: 30
                       Type: int_const 2592000
                       Source: "30 days"
              TupleExpression
                 Type: bool
                 Source: "(icoTokensSold >= ICO_TOKEN_SUPPLY_LIMIT)"
                BinaryOperation using operator >=
                   Type: bool
                   Source: "icoTokensSold >= ICO_TOKEN_SUPPLY_LIMIT"
                  Identifier icoTokensSold
                     Type: uint256
                     Source: "icoTokensSold"
                  Identifier ICO_TOKEN_SUPPLY_LIMIT
                     Type: uint256
                     Source: "ICO_TOKEN_SUPPLY_LIMIT"
  FunctionDefinition "getMntTokensPerEth" - public - const
     Source: "function getMntTokensPerEth(uint _tokensSold) public constant returns (uint){\r\n          // 10 buckets\r\n          uint priceIndex = (_tokensSold / 1 ether) / SINGLE_BLOCK_LEN;\r\n          assert(priceIndex>=0 && (priceIndex<=9));\r\n          \r\n          uint8[10] memory discountPercents = [20,15,10,8,6,4,2,0,0,0];\r\n\r\n          // We have to multiply by '1 ether' to avoid float truncations\r\n          // Example: ($7000 * 100) / 120 = $5833.33333\r\n          uint pricePer1000tokensUsd = \r\n               ((STD_PRICE_USD_PER_1000_TOKENS * 100) * 1 ether) / (100 + discountPercents[priceIndex]);\r\n\r\n          // Correct: 300000 / 5833.33333333 = 51.42857142\r\n          // We have to multiply by '1 ether' to avoid float truncations\r\n          uint mntPerEth = (ETH_PRICE_IN_USD * 1000 * 1 ether * 1 ether) / pricePer1000tokensUsd;\r\n          return mntPerEth;\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint _tokensSold)"
      VariableDeclaration "_tokensSold"
         Type: uint256
         Source: "uint _tokensSold"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n          // 10 buckets\r\n          uint priceIndex = (_tokensSold / 1 ether) / SINGLE_BLOCK_LEN;\r\n          assert(priceIndex>=0 && (priceIndex<=9));\r\n          \r\n          uint8[10] memory discountPercents = [20,15,10,8,6,4,2,0,0,0];\r\n\r\n          // We have to multiply by '1 ether' to avoid float truncations\r\n          // Example: ($7000 * 100) / 120 = $5833.33333\r\n          uint pricePer1000tokensUsd = \r\n               ((STD_PRICE_USD_PER_1000_TOKENS * 100) * 1 ether) / (100 + discountPercents[priceIndex]);\r\n\r\n          // Correct: 300000 / 5833.33333333 = 51.42857142\r\n          // We have to multiply by '1 ether' to avoid float truncations\r\n          uint mntPerEth = (ETH_PRICE_IN_USD * 1000 * 1 ether * 1 ether) / pricePer1000tokensUsd;\r\n          return mntPerEth;\r\n     }"
      VariableDeclarationStatement
         Gas costs: 70
         Source: "uint priceIndex = (_tokensSold / 1 ether) / SINGLE_BLOCK_LEN"
        VariableDeclaration "priceIndex"
           Type: uint256
           Source: "uint priceIndex"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "(_tokensSold / 1 ether) / SINGLE_BLOCK_LEN"
          TupleExpression
             Type: uint256
             Source: "(_tokensSold / 1 ether)"
            BinaryOperation using operator /
               Type: uint256
               Source: "_tokensSold / 1 ether"
              Identifier _tokensSold
                 Type: uint256
                 Source: "_tokensSold"
              Literal, token: [no token] value: 1
                 Type: int_const 1000000000000000000
                 Source: "1 ether"
          Identifier SINGLE_BLOCK_LEN
             Type: uint256
             Source: "SINGLE_BLOCK_LEN"
      ExpressionStatement
         Gas costs: 66
         Source: "assert(priceIndex>=0 && (priceIndex<=9))"
        FunctionCall
           Type: tuple()
           Source: "assert(priceIndex>=0 && (priceIndex<=9))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator &&
             Type: bool
             Source: "priceIndex>=0 && (priceIndex<=9)"
            BinaryOperation using operator >=
               Type: bool
               Source: "priceIndex>=0"
              Identifier priceIndex
                 Type: uint256
                 Source: "priceIndex"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            TupleExpression
               Type: bool
               Source: "(priceIndex<=9)"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "priceIndex<=9"
                Identifier priceIndex
                   Type: uint256
                   Source: "priceIndex"
                Literal, token: [no token] value: 9
                   Type: int_const 9
                   Source: "9"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint8[10] memory discountPercents = [20,15,10,8,6,4,2,0,0,0]"
        VariableDeclaration "discountPercents"
           Type: uint8[10] memory
           Source: "uint8[10] memory discountPercents"
          ArrayTypeName
             Source: "uint8[10]"
            ElementaryTypeName uint8
               Source: "uint8"
            Literal, token: [no token] value: 10
               Type unknown.
               Source: "10"
        TupleExpression
           Type: uint8[10] memory
           Source: "[20,15,10,8,6,4,2,0,0,0]"
          Literal, token: [no token] value: 20
             Type: int_const 20
             Source: "20"
          Literal, token: [no token] value: 15
             Type: int_const 15
             Source: "15"
          Literal, token: [no token] value: 10
             Type: int_const 10
             Source: "10"
          Literal, token: [no token] value: 8
             Type: int_const 8
             Source: "8"
          Literal, token: [no token] value: 6
             Type: int_const 6
             Source: "6"
          Literal, token: [no token] value: 4
             Type: int_const 4
             Source: "4"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint pricePer1000tokensUsd = \r\n               ((STD_PRICE_USD_PER_1000_TOKENS * 100) * 1 ether) / (100 + discountPercents[priceIndex])"
        VariableDeclaration "pricePer1000tokensUsd"
           Type: uint256
           Source: "uint pricePer1000tokensUsd"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "((STD_PRICE_USD_PER_1000_TOKENS * 100) * 1 ether) / (100 + discountPercents[priceIndex])"
          TupleExpression
             Type: uint256
             Source: "((STD_PRICE_USD_PER_1000_TOKENS * 100) * 1 ether)"
            BinaryOperation using operator *
               Type: uint256
               Source: "(STD_PRICE_USD_PER_1000_TOKENS * 100) * 1 ether"
              TupleExpression
                 Type: uint256
                 Source: "(STD_PRICE_USD_PER_1000_TOKENS * 100)"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "STD_PRICE_USD_PER_1000_TOKENS * 100"
                  Identifier STD_PRICE_USD_PER_1000_TOKENS
                     Type: uint256
                     Source: "STD_PRICE_USD_PER_1000_TOKENS"
                  Literal, token: [no token] value: 100
                     Type: int_const 100
                     Source: "100"
              Literal, token: [no token] value: 1
                 Type: int_const 1000000000000000000
                 Source: "1 ether"
          TupleExpression
             Type: uint8
             Source: "(100 + discountPercents[priceIndex])"
            BinaryOperation using operator +
               Type: uint8
               Source: "100 + discountPercents[priceIndex]"
              Literal, token: [no token] value: 100
                 Type: int_const 100
                 Source: "100"
              IndexAccess
                 Type: uint8
                 Source: "discountPercents[priceIndex]"
                Identifier discountPercents
                   Type: uint8[10] memory
                   Source: "discountPercents"
                Identifier priceIndex
                   Type: uint256
                   Source: "priceIndex"
      VariableDeclarationStatement
         Gas costs: 63
         Source: "uint mntPerEth = (ETH_PRICE_IN_USD * 1000 * 1 ether * 1 ether) / pricePer1000tokensUsd"
        VariableDeclaration "mntPerEth"
           Type: uint256
           Source: "uint mntPerEth"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "(ETH_PRICE_IN_USD * 1000 * 1 ether * 1 ether) / pricePer1000tokensUsd"
          TupleExpression
             Type: uint256
             Source: "(ETH_PRICE_IN_USD * 1000 * 1 ether * 1 ether)"
            BinaryOperation using operator *
               Type: uint256
               Source: "ETH_PRICE_IN_USD * 1000 * 1 ether * 1 ether"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "ETH_PRICE_IN_USD * 1000 * 1 ether"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "ETH_PRICE_IN_USD * 1000"
                  Identifier ETH_PRICE_IN_USD
                     Type: uint256
                     Source: "ETH_PRICE_IN_USD"
                  Literal, token: [no token] value: 1000
                     Type: int_const 1000
                     Source: "1000"
                Literal, token: [no token] value: 1
                   Type: int_const 1000000000000000000
                   Source: "1 ether"
              Literal, token: [no token] value: 1
                 Type: int_const 1000000000000000000
                 Source: "1 ether"
          Identifier pricePer1000tokensUsd
             Type: uint256
             Source: "pricePer1000tokensUsd"
      Return
         Gas costs: 8
         Source: "return mntPerEth"
        Identifier mntPerEth
           Type: uint256
           Source: "mntPerEth"
  FunctionDefinition "buyTokens" - public
     Source: "function buyTokens(address _buyer) public payable onlyInState(State.ICORunning) {\r\n          require(msg.value!=0);\r\n\r\n          // The price is selected based on current sold tokens.\r\n          // Price can 'overlap'. For example:\r\n          //   1. if currently we sold 699950 tokens (the price is 10% discount)\r\n          //   2. buyer buys 1000 tokens\r\n          //   3. the price of all 1000 tokens would be with 10% discount!!!\r\n          uint newTokens = (msg.value * getMntTokensPerEth(icoTokensSold)) / 1 ether;\r\n\r\n          issueTokensInternal(_buyer,newTokens);\r\n\r\n          // Update this only when buying from ETH\r\n          ethInvestedBy[msg.sender] = safeAdd(ethInvestedBy[msg.sender], msg.value);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _buyer)"
      VariableDeclaration "_buyer"
         Type: address
         Source: "address _buyer"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyInState"
       Gas costs: 3
       Source: "onlyInState(State.ICORunning)"
      Identifier onlyInState
         Type: modifier (enum Goldmint.State)
         Source: "onlyInState"
      MemberAccess to member ICORunning
         Type: enum Goldmint.State
         Source: "State.ICORunning"
        Identifier State
           Type: type(enum Goldmint.State)
           Source: "State"
    Block
       Source: "{\r\n          require(msg.value!=0);\r\n\r\n          // The price is selected based on current sold tokens.\r\n          // Price can 'overlap'. For example:\r\n          //   1. if currently we sold 699950 tokens (the price is 10% discount)\r\n          //   2. buyer buys 1000 tokens\r\n          //   3. the price of all 1000 tokens would be with 10% discount!!!\r\n          uint newTokens = (msg.value * getMntTokensPerEth(icoTokensSold)) / 1 ether;\r\n\r\n          issueTokensInternal(_buyer,newTokens);\r\n\r\n          // Update this only when buying from ETH\r\n          ethInvestedBy[msg.sender] = safeAdd(ethInvestedBy[msg.sender], msg.value);\r\n     }"
      ExpressionStatement
         Gas costs: 37
         Source: "require(msg.value!=0)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value!=0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "msg.value!=0"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 264
         Source: "uint newTokens = (msg.value * getMntTokensPerEth(icoTokensSold)) / 1 ether"
        VariableDeclaration "newTokens"
           Type: uint256
           Source: "uint newTokens"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "(msg.value * getMntTokensPerEth(icoTokensSold)) / 1 ether"
          TupleExpression
             Type: uint256
             Source: "(msg.value * getMntTokensPerEth(icoTokensSold))"
            BinaryOperation using operator *
               Type: uint256
               Source: "msg.value * getMntTokensPerEth(icoTokensSold)"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
              FunctionCall
                 Type: uint256
                 Source: "getMntTokensPerEth(icoTokensSold)"
                Identifier getMntTokensPerEth
                   Type: function (uint256) view returns (uint256)
                   Source: "getMntTokensPerEth"
                Identifier icoTokensSold
                   Type: uint256
                   Source: "icoTokensSold"
          Literal, token: [no token] value: 1
             Type: int_const 1000000000000000000
             Source: "1 ether"
      ExpressionStatement
         Gas costs: 10
         Source: "issueTokensInternal(_buyer,newTokens)"
        FunctionCall
           Type: tuple()
           Source: "issueTokensInternal(_buyer,newTokens)"
          Identifier issueTokensInternal
             Type: function (address,uint256)
             Source: "issueTokensInternal"
          Identifier _buyer
             Type: address
             Source: "_buyer"
          Identifier newTokens
             Type: uint256
             Source: "newTokens"
      ExpressionStatement
         Gas costs: 20410
         Source: "ethInvestedBy[msg.sender] = safeAdd(ethInvestedBy[msg.sender], msg.value)"
        Assignment using operator =
           Type: uint256
           Source: "ethInvestedBy[msg.sender] = safeAdd(ethInvestedBy[msg.sender], msg.value)"
          IndexAccess
             Type: uint256
             Source: "ethInvestedBy[msg.sender]"
            Identifier ethInvestedBy
               Type: mapping(address => uint256)
               Source: "ethInvestedBy"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "safeAdd(ethInvestedBy[msg.sender], msg.value)"
            Identifier safeAdd
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeAdd"
            IndexAccess
               Type: uint256
               Source: "ethInvestedBy[msg.sender]"
              Identifier ethInvestedBy
                 Type: mapping(address => uint256)
                 Source: "ethInvestedBy"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "issueTokensFromOtherCurrency" - public
     Source: "function issueTokensFromOtherCurrency(address _to, uint _weiCount) onlyInState(State.ICORunning) public onlyOtherCurrenciesChecker {\r\n          require(_weiCount!=0);\r\n\r\n          uint newTokens = (_weiCount * getMntTokensPerEth(icoTokensSold)) / 1 ether;\r\n          issueTokensInternal(_to,newTokens);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _weiCount)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_weiCount"
         Type: uint256
         Source: "uint _weiCount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyInState"
       Gas costs: 3
       Source: "onlyInState(State.ICORunning)"
      Identifier onlyInState
         Type: modifier (enum Goldmint.State)
         Source: "onlyInState"
      MemberAccess to member ICORunning
         Type: enum Goldmint.State
         Source: "State.ICORunning"
        Identifier State
           Type: type(enum Goldmint.State)
           Source: "State"
    ModifierInvocation "onlyOtherCurrenciesChecker"
       Gas costs: 0
       Source: "onlyOtherCurrenciesChecker"
      Identifier onlyOtherCurrenciesChecker
         Type: modifier ()
         Source: "onlyOtherCurrenciesChecker"
    Block
       Source: "{\r\n          require(_weiCount!=0);\r\n\r\n          uint newTokens = (_weiCount * getMntTokensPerEth(icoTokensSold)) / 1 ether;\r\n          issueTokensInternal(_to,newTokens);\r\n     }"
      ExpressionStatement
         Gas costs: 38
         Source: "require(_weiCount!=0)"
        FunctionCall
           Type: tuple()
           Source: "require(_weiCount!=0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_weiCount!=0"
            Identifier _weiCount
               Type: uint256
               Source: "_weiCount"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 265
         Source: "uint newTokens = (_weiCount * getMntTokensPerEth(icoTokensSold)) / 1 ether"
        VariableDeclaration "newTokens"
           Type: uint256
           Source: "uint newTokens"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "(_weiCount * getMntTokensPerEth(icoTokensSold)) / 1 ether"
          TupleExpression
             Type: uint256
             Source: "(_weiCount * getMntTokensPerEth(icoTokensSold))"
            BinaryOperation using operator *
               Type: uint256
               Source: "_weiCount * getMntTokensPerEth(icoTokensSold)"
              Identifier _weiCount
                 Type: uint256
                 Source: "_weiCount"
              FunctionCall
                 Type: uint256
                 Source: "getMntTokensPerEth(icoTokensSold)"
                Identifier getMntTokensPerEth
                   Type: function (uint256) view returns (uint256)
                   Source: "getMntTokensPerEth"
                Identifier icoTokensSold
                   Type: uint256
                   Source: "icoTokensSold"
          Literal, token: [no token] value: 1
             Type: int_const 1000000000000000000
             Source: "1 ether"
      ExpressionStatement
         Gas costs: 21
         Source: "issueTokensInternal(_to,newTokens)"
        FunctionCall
           Type: tuple()
           Source: "issueTokensInternal(_to,newTokens)"
          Identifier issueTokensInternal
             Type: function (address,uint256)
             Source: "issueTokensInternal"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier newTokens
             Type: uint256
             Source: "newTokens"
  FunctionDefinition "issueTokensExternal" - public
     Source: "function issueTokensExternal(address _to, uint _tokens) public onlyInState(State.ICOFinished) onlyTokenManager {\r\n          // can not issue more than BONUS_REWARD\r\n          require((issuedExternallyTokens + _tokens)<=BONUS_REWARD);\r\n\r\n          mntToken.issueTokens(_to,_tokens);\r\n\r\n          issuedExternallyTokens = issuedExternallyTokens + _tokens;\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _tokens)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyInState"
       Gas costs: 3
       Source: "onlyInState(State.ICOFinished)"
      Identifier onlyInState
         Type: modifier (enum Goldmint.State)
         Source: "onlyInState"
      MemberAccess to member ICOFinished
         Type: enum Goldmint.State
         Source: "State.ICOFinished"
        Identifier State
           Type: type(enum Goldmint.State)
           Source: "State"
    ModifierInvocation "onlyTokenManager"
       Gas costs: 0
       Source: "onlyTokenManager"
      Identifier onlyTokenManager
         Type: modifier ()
         Source: "onlyTokenManager"
    Block
       Source: "{\r\n          // can not issue more than BONUS_REWARD\r\n          require((issuedExternallyTokens + _tokens)<=BONUS_REWARD);\r\n\r\n          mntToken.issueTokens(_to,_tokens);\r\n\r\n          issuedExternallyTokens = issuedExternallyTokens + _tokens;\r\n     }"
      ExpressionStatement
         Gas costs: 241
         Source: "require((issuedExternallyTokens + _tokens)<=BONUS_REWARD)"
        FunctionCall
           Type: tuple()
           Source: "require((issuedExternallyTokens + _tokens)<=BONUS_REWARD)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "(issuedExternallyTokens + _tokens)<=BONUS_REWARD"
            TupleExpression
               Type: uint256
               Source: "(issuedExternallyTokens + _tokens)"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "issuedExternallyTokens + _tokens"
                Identifier issuedExternallyTokens
                   Type: uint256
                   Source: "issuedExternallyTokens"
                Identifier _tokens
                   Type: uint256
                   Source: "_tokens"
            Identifier BONUS_REWARD
               Type: uint256
               Source: "BONUS_REWARD"
      ExpressionStatement
         Gas costs: [???]
         Source: "mntToken.issueTokens(_to,_tokens)"
        FunctionCall
           Type: tuple()
           Source: "mntToken.issueTokens(_to,_tokens)"
          MemberAccess to member issueTokens
             Type: function (address,uint256) external
             Source: "mntToken.issueTokens"
            Identifier mntToken
               Type: contract MNTP
               Source: "mntToken"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _tokens
             Type: uint256
             Source: "_tokens"
      ExpressionStatement
         Gas costs: 20220
         Source: "issuedExternallyTokens = issuedExternallyTokens + _tokens"
        Assignment using operator =
           Type: uint256
           Source: "issuedExternallyTokens = issuedExternallyTokens + _tokens"
          Identifier issuedExternallyTokens
             Type: uint256
             Source: "issuedExternallyTokens"
          BinaryOperation using operator +
             Type: uint256
             Source: "issuedExternallyTokens + _tokens"
            Identifier issuedExternallyTokens
               Type: uint256
               Source: "issuedExternallyTokens"
            Identifier _tokens
               Type: uint256
               Source: "_tokens"
  FunctionDefinition "issueTokensInternal"
     Source: "function issueTokensInternal(address _to, uint _tokens) internal {\r\n          require((icoTokensSold + _tokens)<=ICO_TOKEN_SUPPLY_LIMIT);\r\n\r\n          mntToken.issueTokens(_to,_tokens);\r\n\r\n          icoTokensSold+=_tokens;\r\n\r\n          LogBuy(_to,_tokens);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _tokens)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n          require((icoTokensSold + _tokens)<=ICO_TOKEN_SUPPLY_LIMIT);\r\n\r\n          mntToken.issueTokens(_to,_tokens);\r\n\r\n          icoTokensSold+=_tokens;\r\n\r\n          LogBuy(_to,_tokens);\r\n     }"
      ExpressionStatement
         Gas costs: 241
         Source: "require((icoTokensSold + _tokens)<=ICO_TOKEN_SUPPLY_LIMIT)"
        FunctionCall
           Type: tuple()
           Source: "require((icoTokensSold + _tokens)<=ICO_TOKEN_SUPPLY_LIMIT)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "(icoTokensSold + _tokens)<=ICO_TOKEN_SUPPLY_LIMIT"
            TupleExpression
               Type: uint256
               Source: "(icoTokensSold + _tokens)"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "icoTokensSold + _tokens"
                Identifier icoTokensSold
                   Type: uint256
                   Source: "icoTokensSold"
                Identifier _tokens
                   Type: uint256
                   Source: "_tokens"
            Identifier ICO_TOKEN_SUPPLY_LIMIT
               Type: uint256
               Source: "ICO_TOKEN_SUPPLY_LIMIT"
      ExpressionStatement
         Gas costs: [???]
         Source: "mntToken.issueTokens(_to,_tokens)"
        FunctionCall
           Type: tuple()
           Source: "mntToken.issueTokens(_to,_tokens)"
          MemberAccess to member issueTokens
             Type: function (address,uint256) external
             Source: "mntToken.issueTokens"
            Identifier mntToken
               Type: contract MNTP
               Source: "mntToken"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _tokens
             Type: uint256
             Source: "_tokens"
      ExpressionStatement
         Gas costs: 20233
         Source: "icoTokensSold+=_tokens"
        Assignment using operator +=
           Type: uint256
           Source: "icoTokensSold+=_tokens"
          Identifier icoTokensSold
             Type: uint256
             Source: "icoTokensSold"
          Identifier _tokens
             Type: uint256
             Source: "_tokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "LogBuy(_to,_tokens)"
        FunctionCall
           Type: tuple()
           Source: "LogBuy(_to,_tokens)"
          Identifier LogBuy
             Type: function (address,uint256)
             Source: "LogBuy"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _tokens
             Type: uint256
             Source: "_tokens"
  FunctionDefinition "getMyRefund" - public
     Source: "function getMyRefund() public onlyInState(State.Refunding) {\r\n          address sender = msg.sender;\r\n          uint ethValue = ethInvestedBy[sender];\r\n\r\n          require(ethValue > 0);\r\n\r\n          // 1 - send money back\r\n          sender.transfer(ethValue);\r\n          ethInvestedBy[sender] = 0;\r\n\r\n          // 2 - burn tokens\r\n          mntToken.burnTokens(sender, mntToken.balanceOf(sender));\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyInState"
       Gas costs: 3
       Source: "onlyInState(State.Refunding)"
      Identifier onlyInState
         Type: modifier (enum Goldmint.State)
         Source: "onlyInState"
      MemberAccess to member Refunding
         Type: enum Goldmint.State
         Source: "State.Refunding"
        Identifier State
           Type: type(enum Goldmint.State)
           Source: "State"
    Block
       Source: "{\r\n          address sender = msg.sender;\r\n          uint ethValue = ethInvestedBy[sender];\r\n\r\n          require(ethValue > 0);\r\n\r\n          // 1 - send money back\r\n          sender.transfer(ethValue);\r\n          ethInvestedBy[sender] = 0;\r\n\r\n          // 2 - burn tokens\r\n          mntToken.burnTokens(sender, mntToken.balanceOf(sender));\r\n     }"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "address sender = msg.sender"
        VariableDeclaration "sender"
           Type: address
           Source: "address sender"
          ElementaryTypeName address
             Source: "address"
        MemberAccess to member sender
           Type: address
           Source: "msg.sender"
          Identifier msg
             Type: msg
             Source: "msg"
      VariableDeclarationStatement
         Gas costs: 307
         Source: "uint ethValue = ethInvestedBy[sender]"
        VariableDeclaration "ethValue"
           Type: uint256
           Source: "uint ethValue"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "ethInvestedBy[sender]"
          Identifier ethInvestedBy
             Type: mapping(address => uint256)
             Source: "ethInvestedBy"
          Identifier sender
             Type: address
             Source: "sender"
      ExpressionStatement
         Gas costs: 35
         Source: "require(ethValue > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(ethValue > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "ethValue > 0"
            Identifier ethValue
               Type: uint256
               Source: "ethValue"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "sender.transfer(ethValue)"
        FunctionCall
           Type: tuple()
           Source: "sender.transfer(ethValue)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "sender.transfer"
            Identifier sender
               Type: address
               Source: "sender"
          Identifier ethValue
             Type: uint256
             Source: "ethValue"
      ExpressionStatement
         Gas costs: 5110
         Source: "ethInvestedBy[sender] = 0"
        Assignment using operator =
           Type: uint256
           Source: "ethInvestedBy[sender] = 0"
          IndexAccess
             Type: uint256
             Source: "ethInvestedBy[sender]"
            Identifier ethInvestedBy
               Type: mapping(address => uint256)
               Source: "ethInvestedBy"
            Identifier sender
               Type: address
               Source: "sender"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "mntToken.burnTokens(sender, mntToken.balanceOf(sender))"
        FunctionCall
           Type: tuple()
           Source: "mntToken.burnTokens(sender, mntToken.balanceOf(sender))"
          MemberAccess to member burnTokens
             Type: function (address,uint256) external
             Source: "mntToken.burnTokens"
            Identifier mntToken
               Type: contract MNTP
               Source: "mntToken"
          Identifier sender
             Type: address
             Source: "sender"
          FunctionCall
             Type: uint256
             Source: "mntToken.balanceOf(sender)"
            MemberAccess to member balanceOf
               Type: function (address) view external returns (uint256)
               Source: "mntToken.balanceOf"
              Identifier mntToken
                 Type: contract MNTP
                 Source: "mntToken"
            Identifier sender
               Type: address
               Source: "sender"
  FunctionDefinition "" - public
     Source: "function() payable {\r\n          // buyTokens -> issueTokensInternal\r\n          buyTokens(msg.sender);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n          // buyTokens -> issueTokensInternal\r\n          buyTokens(msg.sender);\r\n     }"
      ExpressionStatement
         Gas costs: 6
         Source: "buyTokens(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "buyTokens(msg.sender)"
          Identifier buyTokens
             Type: function (address)
             Source: "buyTokens"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
