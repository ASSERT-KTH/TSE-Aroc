Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x6de20d9d444354ff9b271a6ea6f9274f2467df35.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "Owned"
   Source: "contract Owned {\r\n\r\n    address public owner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _newOwner) onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "Owned" - public
     Source: "function Owned() {\r\n        owner = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 1128
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "setOwner" - public
     Source: "function setOwner(address _newOwner) onlyOwner {\r\n        owner = _newOwner;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _newOwner)"
      VariableDeclaration "_newOwner"
         Type: address
         Source: "address _newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        owner = _newOwner;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = _newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = _newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier _newOwner
             Type: address
             Source: "_newOwner"
ContractDefinition "Token"
   Gas costs: 0
   Source: "contract Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    //uint256 public totalSupply;\r\n    function totalSupply() constant returns (uint256 supply);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() constant returns (uint256 supply);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256 supply)"
      VariableDeclaration "supply"
         Type: uint256
         Source: "uint256 supply"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function toUINT112(uint256 a) internal constant returns(uint112) {\r\n    assert(uint112(a) == a);\r\n    return uint112(a);\r\n  }\r\n\r\n  function toUINT120(uint256 a) internal constant returns(uint120) {\r\n    assert(uint120(a) == a);\r\n    return uint120(a);\r\n  }\r\n\r\n  function toUINT128(uint256 a) internal constant returns(uint128) {\r\n    assert(uint128(a) == a);\r\n    return uint128(a);\r\n  }\r\n}"
  FunctionDefinition "mul" - const
     Source: "function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div" - const
     Source: "function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub" - const
     Source: "function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 0
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add" - const
     Source: "function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "toUINT112" - const
     Source: "function toUINT112(uint256 a) internal constant returns(uint112) {\r\n    assert(uint112(a) == a);\r\n    return uint112(a);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint112)"
      VariableDeclaration ""
         Type: uint112
         Source: "uint112"
        ElementaryTypeName uint112
           Source: "uint112"
    Block
       Source: "{\r\n    assert(uint112(a) == a);\r\n    return uint112(a);\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(uint112(a) == a)"
        FunctionCall
           Type: tuple()
           Source: "assert(uint112(a) == a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "uint112(a) == a"
            FunctionCall
               Type: uint112
               Source: "uint112(a)"
              ElementaryTypeNameExpression uint112
                 Type: type(uint112)
                 Source: "uint112"
              Identifier a
                 Type: uint256
                 Source: "a"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 0
         Source: "return uint112(a)"
        FunctionCall
           Type: uint112
           Source: "uint112(a)"
          ElementaryTypeNameExpression uint112
             Type: type(uint112)
             Source: "uint112"
          Identifier a
             Type: uint256
             Source: "a"
  FunctionDefinition "toUINT120" - const
     Source: "function toUINT120(uint256 a) internal constant returns(uint120) {\r\n    assert(uint120(a) == a);\r\n    return uint120(a);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint120)"
      VariableDeclaration ""
         Type: uint120
         Source: "uint120"
        ElementaryTypeName uint120
           Source: "uint120"
    Block
       Source: "{\r\n    assert(uint120(a) == a);\r\n    return uint120(a);\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(uint120(a) == a)"
        FunctionCall
           Type: tuple()
           Source: "assert(uint120(a) == a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "uint120(a) == a"
            FunctionCall
               Type: uint120
               Source: "uint120(a)"
              ElementaryTypeNameExpression uint120
                 Type: type(uint120)
                 Source: "uint120"
              Identifier a
                 Type: uint256
                 Source: "a"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 0
         Source: "return uint120(a)"
        FunctionCall
           Type: uint120
           Source: "uint120(a)"
          ElementaryTypeNameExpression uint120
             Type: type(uint120)
             Source: "uint120"
          Identifier a
             Type: uint256
             Source: "a"
  FunctionDefinition "toUINT128" - const
     Source: "function toUINT128(uint256 a) internal constant returns(uint128) {\r\n    assert(uint128(a) == a);\r\n    return uint128(a);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint128)"
      VariableDeclaration ""
         Type: uint128
         Source: "uint128"
        ElementaryTypeName uint128
           Source: "uint128"
    Block
       Source: "{\r\n    assert(uint128(a) == a);\r\n    return uint128(a);\r\n  }"
      ExpressionStatement
         Gas costs: 35
         Source: "assert(uint128(a) == a)"
        FunctionCall
           Type: tuple()
           Source: "assert(uint128(a) == a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "uint128(a) == a"
            FunctionCall
               Type: uint128
               Source: "uint128(a)"
              ElementaryTypeNameExpression uint128
                 Type: type(uint128)
                 Source: "uint128"
              Identifier a
                 Type: uint256
                 Source: "a"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return uint128(a)"
        FunctionCall
           Type: uint128
           Source: "uint128(a)"
          ElementaryTypeNameExpression uint128
             Type: type(uint128)
             Source: "uint128"
          Identifier a
             Type: uint256
             Source: "a"
ContractDefinition "ApprovalReceiver"
   Gas costs: 0
   Source: "contract ApprovalReceiver {\r\n    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData);\r\n}"
  FunctionDefinition "receiveApproval" - public
     Source: "function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData);"
    ParameterList
       Source: "(address _from, uint256 _value, address _tokenContract, bytes _extraData)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_tokenContract"
         Type: address
         Source: "address _tokenContract"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: ""
ContractDefinition "Rollback"
   Source: "contract Rollback is Owned, ApprovalReceiver {\r\n\r\n    event onSetCredit(address account , uint256 amount);\r\n    event onReturned(address who, uint256 tokenAmount, uint256 ethAmount);\r\n\r\n\r\n    using SafeMath for uint256;\r\n    \r\n    Token public token = Token(0xD850942eF8811f2A866692A623011bDE52a462C1);\r\n\r\n    uint256 public totalSetCredit;                  //set ven that should be returned\r\n    uint256 public totalReturnedCredit;             //returned ven  \r\n\r\n    struct Credit {\r\n        uint128 total;\r\n        uint128 used;\r\n    }\r\n\r\n    mapping(address => Credit)  credits;           //public\r\n\r\n    function Rollback() {\r\n    }\r\n\r\n    function() payable {\r\n    }\r\n\r\n    function withdrawETH(address _address,uint256 _amount) onlyOwner {\r\n        require(_address != 0);\r\n        _address.transfer(_amount);\r\n    }\r\n\r\n    function withdrawToken(address _address, uint256 _amount) onlyOwner {\r\n        require(_address != 0);\r\n        token.transfer(_address, _amount);\r\n    }\r\n\r\n    function setCredit(address _account, uint256 _amount) onlyOwner { \r\n\r\n        totalSetCredit += _amount;\r\n        totalSetCredit -= credits[_account].total;        \r\n\r\n        credits[_account].total = _amount.toUINT128();\r\n        require(credits[_account].total >= credits[_account].used);\r\n        onSetCredit(_account, _amount);\r\n    }\r\n\r\n    function getCredit(address _account) constant returns (uint256 total, uint256 used) {\r\n        return (credits[_account].total, credits[_account].used);\r\n    }    \r\n\r\n    function receiveApproval(address _from, uint256 _value, address /*_tokenContract*/, bytes /*_extraData*/) {\r\n        require(msg.sender == address(token));\r\n\r\n        require(credits[_from].total >= credits[_from].used);\r\n        uint256 remainedCredit = credits[_from].total - credits[_from].used;\r\n\r\n        if(_value > remainedCredit)\r\n            _value = remainedCredit;  \r\n\r\n        uint256 balance = token.balanceOf(_from);\r\n        if(_value > balance)\r\n            _value = balance;\r\n\r\n        require(_value > 0);\r\n\r\n        require(token.transferFrom(_from, this, _value));\r\n\r\n        uint256 ethAmount = _value / 4025;\r\n        require(ethAmount > 0);\r\n\r\n        credits[_from].used += _value.toUINT128();\r\n        totalReturnedCredit +=_value;\r\n\r\n        _from.transfer(ethAmount);\r\n        \r\n        onReturned(_from, _value, ethAmount);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Owned"
    UserDefinedTypeName "Owned"
       Source: "Owned"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ApprovalReceiver"
    UserDefinedTypeName "ApprovalReceiver"
       Source: "ApprovalReceiver"
  EventDefinition "onSetCredit"
     Gas costs: 0
     Source: "event onSetCredit(address account , uint256 amount);"
    ParameterList
       Source: "(address account , uint256 amount)"
      VariableDeclaration "account"
         Type: address
         Source: "address account"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "onReturned"
     Gas costs: 0
     Source: "event onReturned(address who, uint256 tokenAmount, uint256 ethAmount);"
    ParameterList
       Source: "(address who, uint256 tokenAmount, uint256 ethAmount)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "tokenAmount"
         Type: uint256
         Source: "uint256 tokenAmount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "ethAmount"
         Type: uint256
         Source: "uint256 ethAmount"
        ElementaryTypeName uint256
           Source: "uint256"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "token"
     Type: contract Token
     Gas costs: [???]
     Source: "Token public token = Token(0xD850942eF8811f2A866692A623011bDE52a462C1)"
    UserDefinedTypeName "Token"
       Source: "Token"
    FunctionCall
       Type: contract Token
       Source: "Token(0xD850942eF8811f2A866692A623011bDE52a462C1)"
      Identifier Token
         Type: type(contract Token)
         Source: "Token"
      Literal, token: [no token] value: 0xD850942eF8811f2A866692A623011bDE52a462C1
         Type: address
         Source: "0xD850942eF8811f2A866692A623011bDE52a462C1"
  VariableDeclaration "totalSetCredit"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public totalSetCredit"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "totalReturnedCredit"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public totalReturnedCredit"
    ElementaryTypeName uint256
       Source: "uint256"
  StructDefinition "Credit"
     Gas costs: 0
     Source: "struct Credit {\r\n        uint128 total;\r\n        uint128 used;\r\n    }"
    VariableDeclaration "total"
       Type: uint128
       Source: "uint128 total"
      ElementaryTypeName uint128
         Source: "uint128"
    VariableDeclaration "used"
       Type: uint128
       Source: "uint128 used"
      ElementaryTypeName uint128
         Source: "uint128"
  VariableDeclaration "credits"
     Type: mapping(address => struct Rollback.Credit storage ref)
     Gas costs: 0
     Source: "mapping(address => Credit)  credits"
    Mapping
       Source: "mapping(address => Credit)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "Credit"
         Source: "Credit"
  FunctionDefinition "Rollback" - public
     Source: "function Rollback() {\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Gas costs: 0
       Source: "{\r\n    }"
  FunctionDefinition "" - public
     Source: "function() payable {\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Gas costs: 0
       Source: "{\r\n    }"
  FunctionDefinition "withdrawETH" - public
     Source: "function withdrawETH(address _address,uint256 _amount) onlyOwner {\r\n        require(_address != 0);\r\n        _address.transfer(_amount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address,uint256 _amount)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_address != 0);\r\n        _address.transfer(_amount);\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "require(_address != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_address != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_address != 0"
            Identifier _address
               Type: address
               Source: "_address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "_address.transfer(_amount)"
        FunctionCall
           Type: tuple()
           Source: "_address.transfer(_amount)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "_address.transfer"
            Identifier _address
               Type: address
               Source: "_address"
          Identifier _amount
             Type: uint256
             Source: "_amount"
  FunctionDefinition "withdrawToken" - public
     Source: "function withdrawToken(address _address, uint256 _amount) onlyOwner {\r\n        require(_address != 0);\r\n        token.transfer(_address, _amount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address, uint256 _amount)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_address != 0);\r\n        token.transfer(_address, _amount);\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "require(_address != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_address != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_address != 0"
            Identifier _address
               Type: address
               Source: "_address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.transfer(_address, _amount)"
        FunctionCall
           Type: bool
           Source: "token.transfer(_address, _amount)"
          MemberAccess to member transfer
             Type: function (address,uint256) external returns (bool)
             Source: "token.transfer"
            Identifier token
               Type: contract Token
               Source: "token"
          Identifier _address
             Type: address
             Source: "_address"
          Identifier _amount
             Type: uint256
             Source: "_amount"
  FunctionDefinition "setCredit" - public
     Source: "function setCredit(address _account, uint256 _amount) onlyOwner { \r\n\r\n        totalSetCredit += _amount;\r\n        totalSetCredit -= credits[_account].total;        \r\n\r\n        credits[_account].total = _amount.toUINT128();\r\n        require(credits[_account].total >= credits[_account].used);\r\n        onSetCredit(_account, _amount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _account, uint256 _amount)"
      VariableDeclaration "_account"
         Type: address
         Source: "address _account"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{ \r\n\r\n        totalSetCredit += _amount;\r\n        totalSetCredit -= credits[_account].total;        \r\n\r\n        credits[_account].total = _amount.toUINT128();\r\n        require(credits[_account].total >= credits[_account].used);\r\n        onSetCredit(_account, _amount);\r\n    }"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSetCredit += _amount"
        Assignment using operator +=
           Type: uint256
           Source: "totalSetCredit += _amount"
          Identifier totalSetCredit
             Type: uint256
             Source: "totalSetCredit"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: 20577
         Source: "totalSetCredit -= credits[_account].total"
        Assignment using operator -=
           Type: uint256
           Source: "totalSetCredit -= credits[_account].total"
          Identifier totalSetCredit
             Type: uint256
             Source: "totalSetCredit"
          MemberAccess to member total
             Type: uint128
             Source: "credits[_account].total"
            IndexAccess
               Type: struct Rollback.Credit storage ref
               Source: "credits[_account]"
              Identifier credits
                 Type: mapping(address => struct Rollback.Credit storage ref)
                 Source: "credits"
              Identifier _account
                 Type: address
                 Source: "_account"
      ExpressionStatement
         Gas costs: 20384
         Source: "credits[_account].total = _amount.toUINT128()"
        Assignment using operator =
           Type: uint128
           Source: "credits[_account].total = _amount.toUINT128()"
          MemberAccess to member total
             Type: uint128
             Source: "credits[_account].total"
            IndexAccess
               Type: struct Rollback.Credit storage ref
               Source: "credits[_account]"
              Identifier credits
                 Type: mapping(address => struct Rollback.Credit storage ref)
                 Source: "credits"
              Identifier _account
                 Type: address
                 Source: "_account"
          FunctionCall
             Type: uint128
             Source: "_amount.toUINT128()"
            MemberAccess to member toUINT128
               Type: function (uint256) view returns (uint128)
               Source: "_amount.toUINT128"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
      ExpressionStatement
         Gas costs: 764
         Source: "require(credits[_account].total >= credits[_account].used)"
        FunctionCall
           Type: tuple()
           Source: "require(credits[_account].total >= credits[_account].used)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "credits[_account].total >= credits[_account].used"
            MemberAccess to member total
               Type: uint128
               Source: "credits[_account].total"
              IndexAccess
                 Type: struct Rollback.Credit storage ref
                 Source: "credits[_account]"
                Identifier credits
                   Type: mapping(address => struct Rollback.Credit storage ref)
                   Source: "credits"
                Identifier _account
                   Type: address
                   Source: "_account"
            MemberAccess to member used
               Type: uint128
               Source: "credits[_account].used"
              IndexAccess
                 Type: struct Rollback.Credit storage ref
                 Source: "credits[_account]"
                Identifier credits
                   Type: mapping(address => struct Rollback.Credit storage ref)
                   Source: "credits"
                Identifier _account
                   Type: address
                   Source: "_account"
      ExpressionStatement
         Gas costs: [???]
         Source: "onSetCredit(_account, _amount)"
        FunctionCall
           Type: tuple()
           Source: "onSetCredit(_account, _amount)"
          Identifier onSetCredit
             Type: function (address,uint256)
             Source: "onSetCredit"
          Identifier _account
             Type: address
             Source: "_account"
          Identifier _amount
             Type: uint256
             Source: "_amount"
  FunctionDefinition "getCredit" - public - const
     Source: "function getCredit(address _account) constant returns (uint256 total, uint256 used) {\r\n        return (credits[_account].total, credits[_account].used);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _account)"
      VariableDeclaration "_account"
         Type: address
         Source: "address _account"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 6
       Source: "(uint256 total, uint256 used)"
      VariableDeclaration "total"
         Type: uint256
         Source: "uint256 total"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "used"
         Type: uint256
         Source: "uint256 used"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return (credits[_account].total, credits[_account].used);\r\n    }"
      Return
         Gas costs: 764
         Source: "return (credits[_account].total, credits[_account].used)"
        TupleExpression
           Type: tuple(uint128,uint128)
           Source: "(credits[_account].total, credits[_account].used)"
          MemberAccess to member total
             Type: uint128
             Source: "credits[_account].total"
            IndexAccess
               Type: struct Rollback.Credit storage ref
               Source: "credits[_account]"
              Identifier credits
                 Type: mapping(address => struct Rollback.Credit storage ref)
                 Source: "credits"
              Identifier _account
                 Type: address
                 Source: "_account"
          MemberAccess to member used
             Type: uint128
             Source: "credits[_account].used"
            IndexAccess
               Type: struct Rollback.Credit storage ref
               Source: "credits[_account]"
              Identifier credits
                 Type: mapping(address => struct Rollback.Credit storage ref)
                 Source: "credits"
              Identifier _account
                 Type: address
                 Source: "_account"
  FunctionDefinition "receiveApproval" - public
     Source: "function receiveApproval(address _from, uint256 _value, address /*_tokenContract*/, bytes /*_extraData*/) {\r\n        require(msg.sender == address(token));\r\n\r\n        require(credits[_from].total >= credits[_from].used);\r\n        uint256 remainedCredit = credits[_from].total - credits[_from].used;\r\n\r\n        if(_value > remainedCredit)\r\n            _value = remainedCredit;  \r\n\r\n        uint256 balance = token.balanceOf(_from);\r\n        if(_value > balance)\r\n            _value = balance;\r\n\r\n        require(_value > 0);\r\n\r\n        require(token.transferFrom(_from, this, _value));\r\n\r\n        uint256 ethAmount = _value / 4025;\r\n        require(ethAmount > 0);\r\n\r\n        credits[_from].used += _value.toUINT128();\r\n        totalReturnedCredit +=_value;\r\n\r\n        _from.transfer(ethAmount);\r\n        \r\n        onReturned(_from, _value, ethAmount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, uint256 _value, address /*_tokenContract*/, bytes /*_extraData*/)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration ""
         Type: bytes memory
         Source: "bytes"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(msg.sender == address(token));\r\n\r\n        require(credits[_from].total >= credits[_from].used);\r\n        uint256 remainedCredit = credits[_from].total - credits[_from].used;\r\n\r\n        if(_value > remainedCredit)\r\n            _value = remainedCredit;  \r\n\r\n        uint256 balance = token.balanceOf(_from);\r\n        if(_value > balance)\r\n            _value = balance;\r\n\r\n        require(_value > 0);\r\n\r\n        require(token.transferFrom(_from, this, _value));\r\n\r\n        uint256 ethAmount = _value / 4025;\r\n        require(ethAmount > 0);\r\n\r\n        credits[_from].used += _value.toUINT128();\r\n        totalReturnedCredit +=_value;\r\n\r\n        _from.transfer(ethAmount);\r\n        \r\n        onReturned(_from, _value, ethAmount);\r\n    }"
      ExpressionStatement
         Gas costs: 282
         Source: "require(msg.sender == address(token))"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == address(token))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == address(token)"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            FunctionCall
               Type: address
               Source: "address(token)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Identifier token
                 Type: contract Token
                 Source: "token"
      ExpressionStatement
         Gas costs: 770
         Source: "require(credits[_from].total >= credits[_from].used)"
        FunctionCall
           Type: tuple()
           Source: "require(credits[_from].total >= credits[_from].used)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "credits[_from].total >= credits[_from].used"
            MemberAccess to member total
               Type: uint128
               Source: "credits[_from].total"
              IndexAccess
                 Type: struct Rollback.Credit storage ref
                 Source: "credits[_from]"
                Identifier credits
                   Type: mapping(address => struct Rollback.Credit storage ref)
                   Source: "credits"
                Identifier _from
                   Type: address
                   Source: "_from"
            MemberAccess to member used
               Type: uint128
               Source: "credits[_from].used"
              IndexAccess
                 Type: struct Rollback.Credit storage ref
                 Source: "credits[_from]"
                Identifier credits
                   Type: mapping(address => struct Rollback.Credit storage ref)
                   Source: "credits"
                Identifier _from
                   Type: address
                   Source: "_from"
      VariableDeclarationStatement
         Gas costs: 743
         Source: "uint256 remainedCredit = credits[_from].total - credits[_from].used"
        VariableDeclaration "remainedCredit"
           Type: uint256
           Source: "uint256 remainedCredit"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator -
           Type: uint128
           Source: "credits[_from].total - credits[_from].used"
          MemberAccess to member total
             Type: uint128
             Source: "credits[_from].total"
            IndexAccess
               Type: struct Rollback.Credit storage ref
               Source: "credits[_from]"
              Identifier credits
                 Type: mapping(address => struct Rollback.Credit storage ref)
                 Source: "credits"
              Identifier _from
                 Type: address
                 Source: "_from"
          MemberAccess to member used
             Type: uint128
             Source: "credits[_from].used"
            IndexAccess
               Type: struct Rollback.Credit storage ref
               Source: "credits[_from]"
              Identifier credits
                 Type: mapping(address => struct Rollback.Credit storage ref)
                 Source: "credits"
              Identifier _from
                 Type: address
                 Source: "_from"
      IfStatement
         Source: "if(_value > remainedCredit)\r\n            _value = remainedCredit"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "_value > remainedCredit"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier remainedCredit
             Type: uint256
             Source: "remainedCredit"
        ExpressionStatement
           Gas costs: 8
           Source: "_value = remainedCredit"
          Assignment using operator =
             Type: uint256
             Source: "_value = remainedCredit"
            Identifier _value
               Type: uint256
               Source: "_value"
            Identifier remainedCredit
               Type: uint256
               Source: "remainedCredit"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint256 balance = token.balanceOf(_from)"
        VariableDeclaration "balance"
           Type: uint256
           Source: "uint256 balance"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "token.balanceOf(_from)"
          MemberAccess to member balanceOf
             Type: function (address) view external returns (uint256)
             Source: "token.balanceOf"
            Identifier token
               Type: contract Token
               Source: "token"
          Identifier _from
             Type: address
             Source: "_from"
      IfStatement
         Source: "if(_value > balance)\r\n            _value = balance"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "_value > balance"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier balance
             Type: uint256
             Source: "balance"
        ExpressionStatement
           Gas costs: 8
           Source: "_value = balance"
          Assignment using operator =
             Type: uint256
             Source: "_value = balance"
            Identifier _value
               Type: uint256
               Source: "_value"
            Identifier balance
               Type: uint256
               Source: "balance"
      ExpressionStatement
         Gas costs: 35
         Source: "require(_value > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_value > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "_value > 0"
            Identifier _value
               Type: uint256
               Source: "_value"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(token.transferFrom(_from, this, _value))"
        FunctionCall
           Type: tuple()
           Source: "require(token.transferFrom(_from, this, _value))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "token.transferFrom(_from, this, _value)"
            MemberAccess to member transferFrom
               Type: function (address,address,uint256) external returns (bool)
               Source: "token.transferFrom"
              Identifier token
                 Type: contract Token
                 Source: "token"
            Identifier _from
               Type: address
               Source: "_from"
            Identifier this
               Type: contract Rollback
               Source: "this"
            Identifier _value
               Type: uint256
               Source: "_value"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint256 ethAmount = _value / 4025"
        VariableDeclaration "ethAmount"
           Type: uint256
           Source: "uint256 ethAmount"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "_value / 4025"
          Identifier _value
             Type: uint256
             Source: "_value"
          Literal, token: [no token] value: 4025
             Type: int_const 4025
             Source: "4025"
      ExpressionStatement
         Gas costs: 35
         Source: "require(ethAmount > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(ethAmount > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "ethAmount > 0"
            Identifier ethAmount
               Type: uint256
               Source: "ethAmount"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20723
         Source: "credits[_from].used += _value.toUINT128()"
        Assignment using operator +=
           Type: uint128
           Source: "credits[_from].used += _value.toUINT128()"
          MemberAccess to member used
             Type: uint128
             Source: "credits[_from].used"
            IndexAccess
               Type: struct Rollback.Credit storage ref
               Source: "credits[_from]"
              Identifier credits
                 Type: mapping(address => struct Rollback.Credit storage ref)
                 Source: "credits"
              Identifier _from
                 Type: address
                 Source: "_from"
          FunctionCall
             Type: uint128
             Source: "_value.toUINT128()"
            MemberAccess to member toUINT128
               Type: function (uint256) view returns (uint128)
               Source: "_value.toUINT128"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalReturnedCredit +=_value"
        Assignment using operator +=
           Type: uint256
           Source: "totalReturnedCredit +=_value"
          Identifier totalReturnedCredit
             Type: uint256
             Source: "totalReturnedCredit"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "_from.transfer(ethAmount)"
        FunctionCall
           Type: tuple()
           Source: "_from.transfer(ethAmount)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "_from.transfer"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier ethAmount
             Type: uint256
             Source: "ethAmount"
      ExpressionStatement
         Gas costs: [???]
         Source: "onReturned(_from, _value, ethAmount)"
        FunctionCall
           Type: tuple()
           Source: "onReturned(_from, _value, ethAmount)"
          Identifier onReturned
             Type: function (address,uint256,uint256)
             Source: "onReturned"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier ethAmount
             Type: uint256
             Source: "ethAmount"
