Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xdd1d5ce9f8e26a3f768b1c1e5c68db10a05d5fc0.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.16;"
ContractDefinition "WeBetCrypto"
   Source: "contract WeBetCrypto {\r\n    string public name = \"We Bet Crypto\";\r\n    string public symbol = \"WBC\";\r\n\t\r\n    address public selfAddress;\r\n    address public admin;\r\n    address[] private users;\r\n\t\r\n    uint8 public decimals = 7;\r\n    uint256 public relativeDateSave;\r\n    uint256 public totalFunds;\r\n    uint256 public totalSupply = 300000000000000;\r\n    uint256 public pricePerEther;\r\n    uint256 private amountInCirculation;\r\n    uint256 private currentProfits;\r\n    uint256 private currentIteration;\r\n\tuint256 private actualProfitSplit;\r\n\t\r\n    bool public DAppReady;\r\n    bool public isFrozen;\r\n\tbool public splitInService = true;\r\n\tbool private hasICORun;\r\n    bool private running;\r\n\tbool[4] private devApprovals;\r\n\t\r\n    mapping(address => uint256) balances;\r\n    mapping(address => uint256) monthlyLimit;\r\n\t\r\n    mapping(address => bool) isAdded;\r\n    mapping(address => bool) freezeUser;\r\n\t\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\tmapping (address => mapping (address => uint256)) cooldown;\r\n\t\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event CurrentTLSNProof(address indexed _from, string _proof);\r\n    \r\n\t/**\r\n\t * @notice Ensures admin is caller\r\n\t */\r\n    modifier isAdmin() {\r\n        require(msg.sender == admin);\r\n        //Continue executing rest of method body\r\n        _;\r\n    }\r\n    \r\n    /**\r\n\t * @notice Re-entry protection\r\n\t */\r\n    modifier isRunning() {\r\n        require(!running);\r\n        running = true;\r\n        _;\r\n        running = false;\r\n    }\r\n    \r\n\t/**\r\n\t * @notice Ensures system isn't frozen\r\n\t */\r\n    modifier requireThaw() {\r\n        require(!isFrozen);\r\n        _;\r\n    }\r\n    \r\n\t/**\r\n\t * @notice Ensures player isn't logged in on platform\r\n\t */\r\n    modifier userNotPlaying(address _user) {\r\n        require(!freezeUser[_user]);\r\n        _;\r\n    }\r\n\t\r\n\t/**\r\n\t * @notice Ensures function runs only once\r\n\t */\r\n\tmodifier oneTime() {\r\n\t\trequire(!hasICORun);\r\n\t\t_;\r\n\t}\r\n    \r\n\t/**\r\n\t * @notice Ensures WBC DApp is online\r\n\t */\r\n    modifier DAppOnline() {\r\n        require(DAppReady);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n\t * @notice SafeMath Library safeSub Import\r\n\t * @dev \r\n\t        Since we are dealing with a limited currency\r\n\t        circulation of 30 million tokens and values\r\n\t        that will not surpass the uint256 limit, only\r\n\t        safeSub is required to prevent underflows.\r\n\t */\r\n    function safeSub(uint256 a, uint256 b) internal constant returns (uint256 z) {\r\n        assert((z = a - b) <= a);\r\n    }\r\n\t\r\n\t/**\r\n\t * @notice WBC Constructor\r\n\t * @dev \r\n\t        Constructor function containing proper initializations such as \r\n\t        token distribution to the team members and pushing the first \r\n\t        profit split to 6 months when the DApp will already be live.\r\n\t */\r\n    function WeBetCrypto() {\r\n        admin = msg.sender;\r\n        balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = 22500000000000;\r\n        addUser(0x166Cb48973C2447dafFA8EFd3526da18076088de);\r\n        balances[0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF] = 15000000000000;\r\n        addUser(0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF);\r\n        balances[0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d] = 5000000000000;\r\n        addUser(0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d);\r\n        balances[0x06908Df389Cf2589375b6908D0b1c8FcC34721B5] = 2500000000000;\r\n        addUser(0x06908Df389Cf2589375b6908D0b1c8FcC34721B5);\r\n        balances[0xEdBd4c6757DC425321584a91bDB355Ce65c42b13] = 2500000000000;\r\n        addUser(0xEdBd4c6757DC425321584a91bDB355Ce65c42b13);\r\n        balances[0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858] = 2500000000000;\r\n        addUser(0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858);\r\n        selfAddress = this;\r\n        relativeDateSave = now + 180 days;\r\n        pricePerEther = 33209;\r\n        balances[selfAddress] = 250000000000000;\r\n    }\r\n    \r\n    /**\r\n     * @notice Check the name of the token ~ ERC-20 Standard\r\n     * @return {\r\n\t\t\t\t\t\"_name\": \"The token name\"\r\n\t\t\t\t}\r\n     */\r\n    function name() external constant returns (string _name) {\r\n        return name;\r\n    }\r\n    \r\n\t/**\r\n     * @notice Check the symbol of the token ~ ERC-20 Standard\r\n     * @return {\r\n\t\t\t\t\t\"_symbol\": \"The token symbol\"\r\n\t\t\t\t}\r\n     */\r\n    function symbol() external constant returns (string _symbol) {\r\n        return symbol;\r\n    }\r\n    \r\n    /**\r\n     * @notice Check the decimals of the token ~ ERC-20 Standard\r\n     * @return {\r\n\t\t\t\t\t\"_decimals\": \"The token decimals\"\r\n\t\t\t\t}\r\n     */\r\n    function decimals() external constant returns (uint8 _decimals) {\r\n        return decimals;\r\n    }\r\n    \r\n    /**\r\n     * @notice Check the total supply of the token ~ ERC-20 Standard\r\n     * @return {\r\n\t\t\t\t\t\"_totalSupply\": \"Total supply of tokens\"\r\n\t\t\t\t}\r\n     */\r\n    function totalSupply() external constant returns (uint256 _totalSupply) {\r\n        return totalSupply;\r\n    }\r\n    \r\n    /**\r\n     * @notice Query the available balance of an address ~ ERC-20 Standard\r\n\t * @param _owner The address whose balance we wish to retrieve\r\n     * @return {\r\n\t\t\t\t\t\"balance\": \"Balance of the address\"\r\n\t\t\t\t}\r\n     */\r\n    function balanceOf(address _owner) external constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\t\r\n\t/**\r\n\t * @notice Query the amount of tokens the spender address can withdraw from the owner address ~ ERC-20 Standard\r\n\t * @param _owner The address who owns the tokens\r\n\t * @param _spender The address who can withdraw the tokens\r\n\t * @return {\r\n\t\t\t\t\t\"remaining\": \"Remaining withdrawal amount\"\r\n\t\t\t\t}\r\n     */\r\n    function allowance(address _owner, address _spender) external constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    /**\r\n     * @notice Transfer tokens from an address to another ~ ERC-20 Standard\r\n\t * @dev \r\n\t        Adjusts the monthly limit in case the _from address is the Casino\r\n\t        and ensures that the user isn't logged in when retrieving funds\r\n\t        so as to prevent against a race attack with the Casino.\r\n     * @param _from The address whose balance we will transfer\r\n     * @param _to The recipient address\r\n\t * @param _value The amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) external requireThaw userNotPlaying(_to) {\r\n\t\trequire(cooldown[_from][_to] <= now);\r\n        var _allowance = allowed[_from][_to];\r\n        if (_from == selfAddress) {\r\n            monthlyLimit[_to] = safeSub(monthlyLimit[_to], _value);\r\n        }\r\n        balances[_to] = balances[_to]+_value;\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        allowed[_from][_to] = safeSub(_allowance, _value);\r\n        addUser(_to);\r\n        bytes memory empty;\r\n        Transfer(_from, _to, _value, empty);\r\n    }\r\n    \r\n    /**\r\n\t * @notice Authorize an address to retrieve funds from you ~ ERC-20 Standard\r\n\t * @dev \r\n\t        Each approval comes with a default cooldown of 30 minutes\r\n\t        to prevent against the ERC-20 race attack.\r\n\t * @param _spender The address you wish to authorize\r\n\t * @param _value The amount of tokens you wish to authorize\r\n\t */\r\n    function approve(address _spender, uint256 _value) external {\r\n        allowed[msg.sender][_spender] = _value;\r\n\t\tcooldown[msg.sender][_spender] = now + 30 minutes;\r\n        Approval(msg.sender, _spender, _value);\r\n    }\r\n\t\r\n\t/**\r\n\t * @notice Authorize an address to retrieve funds from you with a custom cooldown ~ ERC-20 Standard\r\n\t * @dev Allowing custom cooldown for the ERC-20 race attack prevention.\r\n\t * @param _spender The address you wish to authorize\r\n\t * @param _value The amount of tokens you wish to authorize\r\n\t * @param _cooldown The amount of seconds the recipient needs to wait before withdrawing the balance\r\n\t */\r\n    function approve(address _spender, uint256 _value, uint256 _cooldown) external {\r\n        allowed[msg.sender][_spender] = _value;\r\n\t\tcooldown[msg.sender][_spender] = now + _cooldown;\r\n        Approval(msg.sender, _spender, _value);\r\n    }\r\n    \r\n    /**\r\n\t * @notice Transfer the specified amount to the target address ~ ERC-20 Standard\r\n\t * @dev \r\n\t        A boolean is returned so that callers of the function \r\n\t        will know if their transaction went through.\r\n\t * @param _to The address you wish to send the tokens to\r\n\t * @param _value The amount of tokens you wish to send\r\n\t * @return {\r\n\t\t\t\t\t\"success\": \"Transaction success\"\r\n\t\t\t\t}\r\n     */\r\n    function transfer(address _to, uint256 _value) external isRunning requireThaw returns (bool success){\r\n        bytes memory empty;\r\n        if (_to == selfAddress) {\r\n            return transferToSelf(_value, empty);\r\n        } else if (isContract(_to)) {\r\n            return transferToContract(_to, _value, empty);\r\n        } else {\r\n            return transferToAddress(_to, _value, empty);\r\n        }\r\n    }\r\n    \r\n    /**\r\n\t * @notice Check whether address is a contract ~ ERC-223 Proposed Standard\r\n\t * @param _address The address to check\r\n\t * @return {\r\n\t\t\t\t\t\"is_contract\": \"Result of query\"\r\n\t\t\t\t}\r\n     */\r\n    function isContract(address _address) internal returns (bool is_contract) {\r\n        uint length;\r\n        assembly {\r\n            length := extcodesize(_address)\r\n        }\r\n        return length > 0;\r\n    }\r\n    \r\n    /**\r\n\t * @notice Transfer the specified amount to the target address with embedded bytes data ~ ERC-223 Proposed Standard\r\n\t * @dev Includes an extra transferToSelf function to handle Casino deposits\r\n\t * @param _to The address to transfer to\r\n\t * @param _value The amount of tokens to transfer\r\n\t * @param _data Any extra embedded data of the transaction\r\n\t * @return {\r\n\t\t\t\t\t\"success\": \"Transaction success\"\r\n\t\t\t\t}\r\n     */\r\n    function transfer(address _to, uint256 _value, bytes _data) external isRunning requireThaw returns (bool success){\r\n        if (_to == selfAddress) {\r\n            return transferToSelf(_value, _data);\r\n        } else if (isContract(_to)) {\r\n            return transferToContract(_to, _value, _data);\r\n        } else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }\r\n    \r\n    /**\r\n\t * @notice Handles transfer to an ECA (Externally Controlled Account), a normal account ~ ERC-223 Proposed Standard\r\n\t * @param _to The address to transfer to\r\n\t * @param _value The amount of tokens to transfer\r\n\t * @param _data Any extra embedded data of the transaction\r\n\t * @return {\r\n\t\t\t\t\t\"success\": \"Transaction success\"\r\n\t\t\t\t}\r\n     */\r\n    function transferToAddress(address _to, uint256 _value, bytes _data) internal returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = balances[_to]+_value;\r\n        addUser(_to);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n\t * @notice Handles transfer to a contract ~ ERC-223 Proposed Standard\r\n\t * @param _to The address to transfer to\r\n\t * @param _value The amount of tokens to transfer\r\n\t * @param _data Any extra embedded data of the transaction\r\n\t * @return {\r\n\t\t\t\t\t\"success\": \"Transaction success\"\r\n\t\t\t\t}\r\n     */\r\n    function transferToContract(address _to, uint256 _value, bytes _data) internal returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = balances[_to]+_value;\r\n        WeBetCrypto rec = WeBetCrypto(_to);\r\n        rec.tokenFallback(msg.sender, _value, _data);\r\n        addUser(_to);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n\t * @notice Handles Casino deposits ~ Custom ERC-223 Proposed Standard Addition\r\n\t * @param _value The amount of tokens to transfer\r\n\t * @param _data Any extra embedded data of the transaction\r\n\t * @return {\r\n\t\t\t\t\t\"success\": \"Transaction success\"\r\n\t\t\t\t}\r\n     */\r\n    function transferToSelf(uint256 _value, bytes _data) internal returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[selfAddress] = balances[selfAddress]+_value;\r\n        Transfer(msg.sender, selfAddress, _value, _data);\r\n\t\tallowed[selfAddress][msg.sender] = _value + allowed[selfAddress][msg.sender];\r\n\t\tApproval(selfAddress, msg.sender, allowed[selfAddress][msg.sender]);\r\n        return true;\r\n    }\r\n\t\r\n\t/**\r\n\t * @notice Empty tokenFallback method to ensure ERC-223 compatibility\r\n\t * @param _sender The address who sent the ERC-223 tokens\r\n\t * @param _value The amount of tokens the address sent to this contract\r\n\t * @param _data Any embedded data of the transaction\r\n\t */\r\n\tfunction tokenFallback(address _sender, uint256 _value, bytes _data) {}\r\n\t\r\n\t/**\r\n\t * @notice Check the cooldown remaining until the allowee can withdraw the balance\r\n\t * @param _allower The holder of the balance\r\n\t * @param _allowee The recipient of the balance\r\n\t * @return {\r\n\t\t\t\t\t\"remaining\": \"Cooldown remaining in seconds\"\r\n\t\t\t\t}\r\n     */\r\n\tfunction checkCooldown(address _allower, address _allowee) external constant returns (uint256 remaining) {\r\n\t\tif (cooldown[_allower][_allowee] > now) {\r\n\t\t\treturn (cooldown[_allower][_allowee] - now);\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * @notice Check how much Casino withdrawal balance remains for address\r\n\t * @param _owner The address to check\r\n\t * @return {\r\n\t\t\t\t\t\"remaining\": \"Withdrawal balance remaining\"\r\n\t\t\t\t}\r\n     */\r\n    function checkMonthlyLimit(address _owner) external constant returns (uint256 remaining) {\r\n        return monthlyLimit[_owner];\r\n    }\r\n\t\r\n\t/**\r\n\t * @notice Retrieve ERC Tokens sent to contract\r\n\t * @dev Feel free to contact us and retrieve your ERC tokens should you wish so.\r\n\t * @param _token The token contract address\r\n\t */\r\n    function claimTokens(address _token) isAdmin external { \r\n\t\trequire(_token != selfAddress);\r\n        WeBetCrypto token = WeBetCrypto(_token); \r\n        uint balance = token.balanceOf(selfAddress); \r\n        token.transfer(admin, balance); \r\n    }\r\n    \r\n\t/**\r\n\t * @notice Freeze token circulation - splitProfits internal\r\n\t * @dev \r\n\t        Ensures that one doesn't transfer his total balance mid-split to \r\n\t        an account later in the split queue in order to receive twice the\r\n\t        monthly profits\r\n\t */\r\n    function assetFreeze() internal {\r\n        isFrozen = true;\r\n    }\r\n    \r\n\t/**\r\n\t * @notice Re-enable token circulation - splitProfits internal\r\n\t */\r\n    function assetThaw() internal {\r\n        isFrozen = false;\r\n    }\r\n    \r\n\t/**\r\n\t * @notice Freeze token circulation\r\n\t * @dev To be used only in extreme circumstances.\r\n\t */\r\n    function emergencyFreeze() isAdmin external {\r\n        isFrozen = true;\r\n    }\r\n    \r\n\t/**\r\n\t * @notice Re-enable token circulation\r\n\t * @dev To be used only in extreme circumstances\r\n\t */\r\n    function emergencyThaw() isAdmin external {\r\n        isFrozen = false;\r\n    }\r\n\t\r\n\t/**\r\n\t * @notice Disable the splitting function\r\n\t * @dev \r\n\t        To be used in case the system is upgraded to a \r\n\t        node.js operated profit reward system via the \r\n\t\t\talterBankBalance function. Ensures scalability \r\n\t\t\tin case userbase gets too big.\r\n\t */\r\n\tfunction emergencySplitToggle() external {\r\n\t\tsplitInService = !splitInService;\r\n\t}\r\n    \r\n\t/**\r\n\t * @notice Adjust the price of Ether according to Coin Market Cap's API\r\n\t * @dev \r\n\t        The subfolder is public domain so anyone can verify that we indeed got the price\r\n\t        from a trusted source at the time we updated it. 2 decimal precision is achieved\r\n\t        by multiplying the price of Ether by 100 and then offsetting the multiplication\r\n\t        in the calculation the price is used in. The TLSNotaryProof string can be added\r\n\t        to the end of https://webetcrypto.io/TLSNotary/ to get the perspective TLS proof.\r\n\t * @param newPrice The new Ethereum price with 2 decimal precision\r\n\t * @param TLSNotaryProof The webetcrypto.io subfolder the TLSNotary proof is stored\r\n\t */\r\n    function setPriceOfEther(uint256 newPrice, string TLSNotaryProof) external isAdmin {\r\n        pricePerEther = newPrice;\r\n        CurrentTLSNProof(selfAddress, TLSNotaryProof);\r\n    }\r\n\t\r\n\t/**\r\n\t * @notice Get the current 2-decimal precision price per token\r\n\t * @dev \r\n\t        The price retains the 2 decimal precision by multiplying it with\r\n\t        100 and offsetting that in the calculations the price is used in.\r\n\t        For example 50 means each token costs 0.50$.\r\n\t * @return {\r\n\t\t\t\t\t\"price\": \"Price of a single WBC Token\"\r\n\t\t\t\t}\r\n     */\r\n\tfunction getPricePerToken() public constant returns (uint256 price) {\r\n        if (balances[selfAddress] > 200000000000000) {\r\n            return 50;\r\n        } else if (balances[selfAddress] > 150000000000000) {\r\n\t\t\treturn 200;\r\n\t\t} else if (balances[selfAddress] > 100000000000000) {\r\n\t\t\treturn 400;\r\n\t\t} else {\r\n\t\t\treturn 550;\r\n        }\r\n    }\r\n\t\r\n\t/**\r\n\t * @notice Convert Wei to WBC tokens\r\n\t * @dev \r\n\t\t    The _value is multiplied by 10^7 because of the 7 decimal precision\r\n\t\t\tof WBC and to ensure that a user can invest less than 1 ether and \r\n\t\t\tstill get his WBC tokens, preventing rounding errors. A hard cap\r\n\t\t\tof 500k WBC tokens per purchase is enforced so as to prevent users\r\n\t\t\tfrom buying large amounts at a higher or lower Ether price due to \r\n\t\t\thourly price updates.\r\n\t * @param _value The amount of Wei to convert\r\n\t * @return {\r\n\t\t\t\t\t\"tokenAmount\": \"Amount of WBC Tokens input is worth\"\r\n\t\t\t\t}\r\n     */\r\n\tfunction calculateTokenAmount(uint256 _value) internal returns (uint256 tokenAmount) {\r\n\t\ttokenAmount = ((_value*(10**7)/1 ether)*pricePerEther)/getPricePerToken();\r\n\t\tassert(tokenAmount <= 5000000000000);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @notice Add the address to the user list \r\n\t * @dev Used for the splitting function to take it into account\r\n\t * @param _user User to add to database\r\n\t */\r\n\tfunction addUser(address _user) internal {\r\n\t\tif (!isAdded[_user]) {\r\n            users.push(_user);\r\n            monthlyLimit[_user] = 5000000000000;\r\n            isAdded[_user] = true;\r\n        }\r\n\t}\r\n    \r\n\t/**\r\n\t * @notice Split the monthly profits of the Casino to the users\r\n\t * @dev \r\n\t\t\tThe formula that calculates the profit a user is owed can be seen on \r\n\t\t\tthe white paper. The actualProfitSplit variable stores the actual values\r\n\t   \t\tthat are distributed to the users to prevent rounding errors from burning \r\n\t\t\ttokens. Since gas requirements will spike the more users use our platform,\r\n\t\t\ta loop-state-save is implemented to ensure scalability.\r\n\t */\r\n    function splitProfits() external {\r\n\t\trequire(splitInService);\r\n        bytes memory empty;\r\n        uint i;\r\n        if (!isFrozen) {\r\n            require(now >= relativeDateSave);\r\n            assetFreeze();\r\n            require(balances[selfAddress] > 30000000000000);\r\n            relativeDateSave = now + 30 days;\r\n            currentProfits = ((balances[selfAddress]-30000000000000)/10)*7; \r\n            amountInCirculation = safeSub(300000000000000, balances[selfAddress]);\r\n            currentIteration = 0;\r\n\t\t\tactualProfitSplit = 0;\r\n        } else {\r\n            for (i = currentIteration; i < users.length; i++) {\r\n                monthlyLimit[users[i]] = 5000000000000;\r\n                if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }\r\n\t\t\t\tif (allowed[selfAddress][users[i]] == 0) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if ((balances[users[i]]/allowed[selfAddress][users[i]]) < 19) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n                    continue;\r\n                }\r\n                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tcheckSplitEnd(i);\r\n                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty);\r\n            }\r\n        }\r\n    }\r\n\t\r\n\t/**\r\n\t * @notice Change variables on split end\r\n\t * @param i The current index of the split loop\r\n\t */\r\n\tfunction checkSplitEnd(uint256 i) internal {\r\n\t\tif (i == users.length-1) {\r\n\t\t\tassetThaw();\r\n\t\t\tbalances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] + currentProfits/22;\r\n\t\t\tbalances[selfAddress] = balances[selfAddress] - actualProfitSplit - currentProfits/22;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * @notice Split the unsold WBC of the ICO\r\n\t * @dev \r\n\t\t\tOne time function to distribute the unsold tokens.\r\n\t */\r\n    function ICOSplit() external isAdmin oneTime {\r\n        bytes memory empty;\r\n        uint i;\r\n        if (!isFrozen) {\r\n            require((relativeDateSave - now) >= (relativeDateSave - 150 days));\r\n            assetFreeze();\r\n            require(balances[selfAddress] > 50000000000000);\r\n            currentProfits = ((balances[selfAddress] - 50000000000000) / 10) * 7; \r\n            amountInCirculation = safeSub(300000000000000, balances[selfAddress]);\r\n            currentIteration = 0;\r\n\t\t\tactualProfitSplit = 0;\r\n        } else {\r\n            for (i = currentIteration; i < users.length; i++) {\r\n                if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }\r\n                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n                if (i == users.length-1) {\r\n                    assetThaw();\r\n                    balances[selfAddress] = balances[selfAddress] - actualProfitSplit;\r\n\t\t\t\t\thasICORun = true;\r\n                }\r\n                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty);\r\n            }\r\n        }\r\n    }\r\n\t\r\n\t/**\r\n\t * @notice Sign that the DApp is ready\r\n\t * @dev \r\n\t        Only the core team members have access to this function. This is \r\n\t        created as an extra layer of security for investors and users of \r\n\t\t\tthe coin, since a multi-signature approval is required before the \r\n\t\t\tfunction that alters the Casino balance is used.\r\n\t */\r\n    function assureDAppIsReady() external {\r\n        if (msg.sender == 0x166Cb48973C2447dafFA8EFd3526da18076088de) {\r\n            devApprovals[0] = true;\r\n        } else if (msg.sender == 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d) {\r\n            devApprovals[1] = true;\r\n        } else if (msg.sender == 0xEC5a48d6F11F8a981aa3D913DA0A69194280cDBc) {\r\n            devApprovals[2] = true;\r\n        } else if (msg.sender == 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF) {\r\n            devApprovals[3] = true;\r\n        } else {\r\n\t\t\trevert();\r\n\t\t}\r\n    }\r\n\t\r\n\t/**\r\n     * @notice Verify that the DApp is ready\r\n\t * @dev \r\n\t\t\tSince iterating through the devApprovals array costs gas\r\n\t\t\tand the functions with the DAppOnline modifier are going\r\n\t\t\tto be repetitively used, it is better to store the DApp\r\n\t\t\tstate in a variable that needs to be altered once.\r\n\t */\r\n    function isDAppReady() external isAdmin {\r\n        uint8 numOfApprovals = 0;\r\n        for (uint i = 0; i < devApprovals.length; i++) {\r\n            if (devApprovals[i]) {\r\n                numOfApprovals++;\r\n            }\r\n        }\r\n        DAppReady = (numOfApprovals>=2);\r\n    }\r\n    \r\n\t/**\r\n\t * @notice Rise or lower user bank balance - Backend Function\r\n\t * @dev \r\n\t        This allows real-time adjustment of the balance a user has within the Casino to\r\n\t\t\trepresent earnings and losses. Underflow impossible since only bets can lower the\r\n\t\t\tbalance.\r\n\t * @param _toAlter The address whose Casino balance to alter\r\n\t * @param _amount The amount to alter it by\r\n\t */\r\n    function alterBankBalance(address _toAlter, uint256 _amount, bool sign) external DAppOnline isAdmin {\r\n        if (sign && (_amount+allowed[selfAddress][_toAlter]) > allowed[selfAddress][_toAlter]) {\r\n\t\t\tallowed[selfAddress][_toAlter] = _amount + allowed[selfAddress][_toAlter];\r\n\t\t\tApproval(selfAddress, _toAlter, allowed[selfAddress][_toAlter]);\r\n        } else {\r\n            allowed[selfAddress][_toAlter] = safeSub(allowed[selfAddress][_toAlter], _amount);\r\n\t\t\tApproval(selfAddress, _toAlter, allowed[selfAddress][_toAlter]);\r\n        }\r\n    }\r\n    \r\n\t/**\r\n\t * @notice Freeze user during platform use - Backend Function\r\n\t * @dev Prevents against the ERC-20 race attack on the Casino\r\n\t * @param _user The user to freeze\r\n\t */\r\n    function loginUser(address _user) external DAppOnline isAdmin {\r\n        freezeUser[_user] = true;\r\n    }\r\n\t\r\n\t/**\r\n\t * @notice De-Freeze user - Backend Function\r\n     * @dev Used when a user logs out or loses connection with the DApp\r\n\t * @param _user The user to de-freeze\r\n\t */\r\n\tfunction logoutUser(address _user) external DAppOnline isAdmin {\r\n\t\tfreezeUser[_user] = false;\r\n\t}\r\n    \r\n    /**\r\n\t * @notice Fallback function \r\n\t * @dev Triggered when Ether is sent to the contract. Throws intentionally to refund the sender.\r\n\t */\r\n    function() payable {\r\n\t\trevert();\r\n    }\r\n\t\r\n\t/**\r\n\t * @notice Purchase WBC Tokens for Address - ICO\r\n\t * @param _recipient The recipient of the WBC tokens\r\n\t */\r\n\tfunction buyTokensForAddress(address _recipient) external payable {\r\n        totalFunds = totalFunds + msg.value;\r\n        require(msg.value > 0);\r\n\t\trequire(_recipient != admin);\r\n\t\trequire((totalFunds/1 ether)*pricePerEther < 6000000000);\r\n        addUser(_recipient);\r\n        bytes memory empty;\r\n\t\tuint tokenAmount = calculateTokenAmount(msg.value);\r\n\t\tbalances[selfAddress] = balances[selfAddress] - tokenAmount;\r\n\t\tassert(balances[selfAddress] >= 50000000000000);\r\n        balances[_recipient] = balances[_recipient] + tokenAmount;\r\n        Transfer(selfAddress, _recipient, tokenAmount, empty);\r\n        address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de;\r\n        etherTransfer.transfer(msg.value);\r\n    }\r\n\t\r\n\t/**\r\n\t * @notice Purchase WBC Tokens for Self - ICO\r\n\t */\r\n\tfunction buyTokensForSelf() external payable {\r\n        totalFunds = totalFunds + msg.value;\r\n\t\taddress etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de;\r\n        require(msg.value > 0);\r\n\t\trequire(msg.sender != etherTransfer);\r\n\t\trequire((totalFunds/1 ether)*pricePerEther < 6000000000);\r\n        addUser(msg.sender);\r\n        bytes memory empty;\r\n\t\tuint tokenAmount = calculateTokenAmount(msg.value);\r\n\t\tbalances[selfAddress] = balances[selfAddress] - tokenAmount;\r\n\t\tassert(balances[selfAddress] >= 50000000000000);\r\n        balances[msg.sender] = balances[msg.sender] + tokenAmount;\r\n        Transfer(selfAddress, msg.sender, tokenAmount, empty);\r\n        etherTransfer.transfer(msg.value);\r\n    }\r\n}"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: 0
     Source: "string public name = \"We Bet Crypto\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: We Bet Crypto
       Type: literal_string "We Bet Crypto"
       Source: "\"We Bet Crypto\""
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: 0
     Source: "string public symbol = \"WBC\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: WBC
       Type: literal_string "WBC"
       Source: "\"WBC\""
  VariableDeclaration "selfAddress"
     Type: address
     Gas costs: [???]
     Source: "address public selfAddress"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "admin"
     Type: address
     Gas costs: [???]
     Source: "address public admin"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "users"
     Type: address[] storage ref
     Gas costs: 0
     Source: "address[] private users"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: 0
     Source: "uint8 public decimals = 7"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 7
       Type: int_const 7
       Source: "7"
  VariableDeclaration "relativeDateSave"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public relativeDateSave"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "totalFunds"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public totalFunds"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "totalSupply"
     Type: uint256
     Gas costs: 0
     Source: "uint256 public totalSupply = 300000000000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 300000000000000
       Type: int_const 300000000000000
       Source: "300000000000000"
  VariableDeclaration "pricePerEther"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public pricePerEther"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "amountInCirculation"
     Type: uint256
     Gas costs: 0
     Source: "uint256 private amountInCirculation"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "currentProfits"
     Type: uint256
     Gas costs: 0
     Source: "uint256 private currentProfits"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "currentIteration"
     Type: uint256
     Gas costs: 0
     Source: "uint256 private currentIteration"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "actualProfitSplit"
     Type: uint256
     Gas costs: 0
     Source: "uint256 private actualProfitSplit"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "DAppReady"
     Type: bool
     Gas costs: [???]
     Source: "bool public DAppReady"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "isFrozen"
     Type: bool
     Gas costs: [???]
     Source: "bool public isFrozen"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "splitInService"
     Type: bool
     Gas costs: [???]
     Source: "bool public splitInService = true"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: true value: true
       Type: bool
       Source: "true"
  VariableDeclaration "hasICORun"
     Type: bool
     Gas costs: 0
     Source: "bool private hasICORun"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "running"
     Type: bool
     Gas costs: 0
     Source: "bool private running"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "devApprovals"
     Type: bool[4] storage ref
     Gas costs: 0
     Source: "bool[4] private devApprovals"
    ArrayTypeName
       Source: "bool[4]"
      ElementaryTypeName bool
         Source: "bool"
      Literal, token: [no token] value: 4
         Type unknown.
         Source: "4"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) balances"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "monthlyLimit"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) monthlyLimit"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "isAdded"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping(address => bool) isAdded"
    Mapping
       Source: "mapping(address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "freezeUser"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping(address => bool) freezeUser"
    Mapping
       Source: "mapping(address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "cooldown"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) cooldown"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Gas costs: 0
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value, bytes _data)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
  EventDefinition "Approval"
     Gas costs: 0
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "CurrentTLSNProof"
     Gas costs: 0
     Source: "event CurrentTLSNProof(address indexed _from, string _proof);"
    ParameterList
       Source: "(address indexed _from, string _proof)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_proof"
         Type: string memory
         Source: "string _proof"
        ElementaryTypeName string
           Source: "string"
  ModifierDefinition "isAdmin"
     Source: "modifier isAdmin() {\r\n        require(msg.sender == admin);\r\n        //Continue executing rest of method body\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(msg.sender == admin);\r\n        //Continue executing rest of method body\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 2538
         Source: "require(msg.sender == admin)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == admin)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == admin"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier admin
               Type: address
               Source: "admin"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "isRunning"
     Source: "modifier isRunning() {\r\n        require(!running);\r\n        running = true;\r\n        _;\r\n        running = false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(!running);\r\n        running = true;\r\n        _;\r\n        running = false;\r\n    }"
      ExpressionStatement
         Gas costs: 636
         Source: "require(!running)"
        FunctionCall
           Type: tuple()
           Source: "require(!running)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!running"
            Identifier running
               Type: bool
               Source: "running"
      ExpressionStatement
         Gas costs: 40634
         Source: "running = true"
        Assignment using operator =
           Type: bool
           Source: "running = true"
          Identifier running
             Type: bool
             Source: "running"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
      ExpressionStatement
         Gas costs: 40634
         Source: "running = false"
        Assignment using operator =
           Type: bool
           Source: "running = false"
          Identifier running
             Type: bool
             Source: "running"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  ModifierDefinition "requireThaw"
     Source: "modifier requireThaw() {\r\n        require(!isFrozen);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(!isFrozen);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 954
         Source: "require(!isFrozen)"
        FunctionCall
           Type: tuple()
           Source: "require(!isFrozen)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!isFrozen"
            Identifier isFrozen
               Type: bool
               Source: "isFrozen"
      PlaceholderStatement
         Gas costs: 4
         Source: "_"
  ModifierDefinition "userNotPlaying"
     Source: "modifier userNotPlaying(address _user) {\r\n        require(!freezeUser[_user]);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _user)"
      VariableDeclaration "_user"
         Type: address
         Source: "address _user"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        require(!freezeUser[_user]);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 364
         Source: "require(!freezeUser[_user])"
        FunctionCall
           Type: tuple()
           Source: "require(!freezeUser[_user])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!freezeUser[_user]"
            IndexAccess
               Type: bool
               Source: "freezeUser[_user]"
              Identifier freezeUser
                 Type: mapping(address => bool)
                 Source: "freezeUser"
              Identifier _user
                 Type: address
                 Source: "_user"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "oneTime"
     Source: "modifier oneTime() {\r\n\t\trequire(!hasICORun);\r\n\t\t_;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n\t\trequire(!hasICORun);\r\n\t\t_;\r\n\t}"
      ExpressionStatement
         Gas costs: 318
         Source: "require(!hasICORun)"
        FunctionCall
           Type: tuple()
           Source: "require(!hasICORun)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!hasICORun"
            Identifier hasICORun
               Type: bool
               Source: "hasICORun"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "DAppOnline"
     Source: "modifier DAppOnline() {\r\n        require(DAppReady);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(DAppReady);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 795
         Source: "require(DAppReady)"
        FunctionCall
           Type: tuple()
           Source: "require(DAppReady)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier DAppReady
             Type: bool
             Source: "DAppReady"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "safeSub" - const
     Source: "function safeSub(uint256 a, uint256 b) internal constant returns (uint256 z) {\r\n        assert((z = a - b) <= a);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 z)"
      VariableDeclaration "z"
         Type: uint256
         Source: "uint256 z"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        assert((z = a - b) <= a);\r\n    }"
      ExpressionStatement
         Gas costs: 46
         Source: "assert((z = a - b) <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert((z = a - b) <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "(z = a - b) <= a"
            TupleExpression
               Type: uint256
               Source: "(z = a - b)"
              Assignment using operator =
                 Type: uint256
                 Source: "z = a - b"
                Identifier z
                   Type: uint256
                   Source: "z"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "a - b"
                  Identifier a
                     Type: uint256
                     Source: "a"
                  Identifier b
                     Type: uint256
                     Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
  FunctionDefinition "WeBetCrypto" - public
     Source: "function WeBetCrypto() {\r\n        admin = msg.sender;\r\n        balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = 22500000000000;\r\n        addUser(0x166Cb48973C2447dafFA8EFd3526da18076088de);\r\n        balances[0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF] = 15000000000000;\r\n        addUser(0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF);\r\n        balances[0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d] = 5000000000000;\r\n        addUser(0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d);\r\n        balances[0x06908Df389Cf2589375b6908D0b1c8FcC34721B5] = 2500000000000;\r\n        addUser(0x06908Df389Cf2589375b6908D0b1c8FcC34721B5);\r\n        balances[0xEdBd4c6757DC425321584a91bDB355Ce65c42b13] = 2500000000000;\r\n        addUser(0xEdBd4c6757DC425321584a91bDB355Ce65c42b13);\r\n        balances[0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858] = 2500000000000;\r\n        addUser(0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858);\r\n        selfAddress = this;\r\n        relativeDateSave = now + 180 days;\r\n        pricePerEther = 33209;\r\n        balances[selfAddress] = 250000000000000;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        admin = msg.sender;\r\n        balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = 22500000000000;\r\n        addUser(0x166Cb48973C2447dafFA8EFd3526da18076088de);\r\n        balances[0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF] = 15000000000000;\r\n        addUser(0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF);\r\n        balances[0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d] = 5000000000000;\r\n        addUser(0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d);\r\n        balances[0x06908Df389Cf2589375b6908D0b1c8FcC34721B5] = 2500000000000;\r\n        addUser(0x06908Df389Cf2589375b6908D0b1c8FcC34721B5);\r\n        balances[0xEdBd4c6757DC425321584a91bDB355Ce65c42b13] = 2500000000000;\r\n        addUser(0xEdBd4c6757DC425321584a91bDB355Ce65c42b13);\r\n        balances[0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858] = 2500000000000;\r\n        addUser(0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858);\r\n        selfAddress = this;\r\n        relativeDateSave = now + 180 days;\r\n        pricePerEther = 33209;\r\n        balances[selfAddress] = 250000000000000;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "admin = msg.sender"
        Assignment using operator =
           Type: address
           Source: "admin = msg.sender"
          Identifier admin
             Type: address
             Source: "admin"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = 22500000000000"
        Assignment using operator =
           Type: uint256
           Source: "balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = 22500000000000"
          IndexAccess
             Type: uint256
             Source: "balances[0x166Cb48973C2447dafFA8EFd3526da18076088de]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Literal, token: [no token] value: 0x166Cb48973C2447dafFA8EFd3526da18076088de
               Type: address
               Source: "0x166Cb48973C2447dafFA8EFd3526da18076088de"
          Literal, token: [no token] value: 22500000000000
             Type: int_const 22500000000000
             Source: "22500000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "addUser(0x166Cb48973C2447dafFA8EFd3526da18076088de)"
        FunctionCall
           Type: tuple()
           Source: "addUser(0x166Cb48973C2447dafFA8EFd3526da18076088de)"
          Identifier addUser
             Type: function (address)
             Source: "addUser"
          Literal, token: [no token] value: 0x166Cb48973C2447dafFA8EFd3526da18076088de
             Type: address
             Source: "0x166Cb48973C2447dafFA8EFd3526da18076088de"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF] = 15000000000000"
        Assignment using operator =
           Type: uint256
           Source: "balances[0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF] = 15000000000000"
          IndexAccess
             Type: uint256
             Source: "balances[0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Literal, token: [no token] value: 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF
               Type: address
               Source: "0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF"
          Literal, token: [no token] value: 15000000000000
             Type: int_const 15000000000000
             Source: "15000000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "addUser(0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF)"
        FunctionCall
           Type: tuple()
           Source: "addUser(0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF)"
          Identifier addUser
             Type: function (address)
             Source: "addUser"
          Literal, token: [no token] value: 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF
             Type: address
             Source: "0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d] = 5000000000000"
        Assignment using operator =
           Type: uint256
           Source: "balances[0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d] = 5000000000000"
          IndexAccess
             Type: uint256
             Source: "balances[0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Literal, token: [no token] value: 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d
               Type: address
               Source: "0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d"
          Literal, token: [no token] value: 5000000000000
             Type: int_const 5000000000000
             Source: "5000000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "addUser(0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d)"
        FunctionCall
           Type: tuple()
           Source: "addUser(0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d)"
          Identifier addUser
             Type: function (address)
             Source: "addUser"
          Literal, token: [no token] value: 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d
             Type: address
             Source: "0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[0x06908Df389Cf2589375b6908D0b1c8FcC34721B5] = 2500000000000"
        Assignment using operator =
           Type: uint256
           Source: "balances[0x06908Df389Cf2589375b6908D0b1c8FcC34721B5] = 2500000000000"
          IndexAccess
             Type: uint256
             Source: "balances[0x06908Df389Cf2589375b6908D0b1c8FcC34721B5]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Literal, token: [no token] value: 0x06908Df389Cf2589375b6908D0b1c8FcC34721B5
               Type: address
               Source: "0x06908Df389Cf2589375b6908D0b1c8FcC34721B5"
          Literal, token: [no token] value: 2500000000000
             Type: int_const 2500000000000
             Source: "2500000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "addUser(0x06908Df389Cf2589375b6908D0b1c8FcC34721B5)"
        FunctionCall
           Type: tuple()
           Source: "addUser(0x06908Df389Cf2589375b6908D0b1c8FcC34721B5)"
          Identifier addUser
             Type: function (address)
             Source: "addUser"
          Literal, token: [no token] value: 0x06908Df389Cf2589375b6908D0b1c8FcC34721B5
             Type: address
             Source: "0x06908Df389Cf2589375b6908D0b1c8FcC34721B5"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[0xEdBd4c6757DC425321584a91bDB355Ce65c42b13] = 2500000000000"
        Assignment using operator =
           Type: uint256
           Source: "balances[0xEdBd4c6757DC425321584a91bDB355Ce65c42b13] = 2500000000000"
          IndexAccess
             Type: uint256
             Source: "balances[0xEdBd4c6757DC425321584a91bDB355Ce65c42b13]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Literal, token: [no token] value: 0xEdBd4c6757DC425321584a91bDB355Ce65c42b13
               Type: address
               Source: "0xEdBd4c6757DC425321584a91bDB355Ce65c42b13"
          Literal, token: [no token] value: 2500000000000
             Type: int_const 2500000000000
             Source: "2500000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "addUser(0xEdBd4c6757DC425321584a91bDB355Ce65c42b13)"
        FunctionCall
           Type: tuple()
           Source: "addUser(0xEdBd4c6757DC425321584a91bDB355Ce65c42b13)"
          Identifier addUser
             Type: function (address)
             Source: "addUser"
          Literal, token: [no token] value: 0xEdBd4c6757DC425321584a91bDB355Ce65c42b13
             Type: address
             Source: "0xEdBd4c6757DC425321584a91bDB355Ce65c42b13"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858] = 2500000000000"
        Assignment using operator =
           Type: uint256
           Source: "balances[0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858] = 2500000000000"
          IndexAccess
             Type: uint256
             Source: "balances[0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Literal, token: [no token] value: 0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858
               Type: address
               Source: "0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858"
          Literal, token: [no token] value: 2500000000000
             Type: int_const 2500000000000
             Source: "2500000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "addUser(0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858)"
        FunctionCall
           Type: tuple()
           Source: "addUser(0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858)"
          Identifier addUser
             Type: function (address)
             Source: "addUser"
          Literal, token: [no token] value: 0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858
             Type: address
             Source: "0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858"
      ExpressionStatement
         Gas costs: 0
         Source: "selfAddress = this"
        Assignment using operator =
           Type: address
           Source: "selfAddress = this"
          Identifier selfAddress
             Type: address
             Source: "selfAddress"
          Identifier this
             Type: contract WeBetCrypto
             Source: "this"
      ExpressionStatement
         Gas costs: 0
         Source: "relativeDateSave = now + 180 days"
        Assignment using operator =
           Type: uint256
           Source: "relativeDateSave = now + 180 days"
          Identifier relativeDateSave
             Type: uint256
             Source: "relativeDateSave"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + 180 days"
            Identifier now
               Type: uint256
               Source: "now"
            Literal, token: [no token] value: 180
               Type: int_const 15552000
               Source: "180 days"
      ExpressionStatement
         Gas costs: 0
         Source: "pricePerEther = 33209"
        Assignment using operator =
           Type: uint256
           Source: "pricePerEther = 33209"
          Identifier pricePerEther
             Type: uint256
             Source: "pricePerEther"
          Literal, token: [no token] value: 33209
             Type: int_const 33209
             Source: "33209"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[selfAddress] = 250000000000000"
        Assignment using operator =
           Type: uint256
           Source: "balances[selfAddress] = 250000000000000"
          IndexAccess
             Type: uint256
             Source: "balances[selfAddress]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier selfAddress
               Type: address
               Source: "selfAddress"
          Literal, token: [no token] value: 250000000000000
             Type: int_const 250000000000000
             Source: "250000000000000"
  FunctionDefinition "name" - public - const
     Source: "function name() external constant returns (string _name) {\r\n        return name;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(string _name)"
      VariableDeclaration "_name"
         Type: string memory
         Source: "string _name"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n        return name;\r\n    }"
      Return
         Gas costs: [???]
         Source: "return name"
        Identifier name
           Type: string storage ref
           Source: "name"
  FunctionDefinition "symbol" - public - const
     Source: "function symbol() external constant returns (string _symbol) {\r\n        return symbol;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(string _symbol)"
      VariableDeclaration "_symbol"
         Type: string memory
         Source: "string _symbol"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n        return symbol;\r\n    }"
      Return
         Gas costs: [???]
         Source: "return symbol"
        Identifier symbol
           Type: string storage ref
           Source: "symbol"
  FunctionDefinition "decimals" - public - const
     Source: "function decimals() external constant returns (uint8 _decimals) {\r\n        return decimals;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint8 _decimals)"
      VariableDeclaration "_decimals"
         Type: uint8
         Source: "uint8 _decimals"
        ElementaryTypeName uint8
           Source: "uint8"
    Block
       Source: "{\r\n        return decimals;\r\n    }"
      Return
         Gas costs: 244
         Source: "return decimals"
        Identifier decimals
           Type: uint8
           Source: "decimals"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() external constant returns (uint256 _totalSupply) {\r\n        return totalSupply;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256 _totalSupply)"
      VariableDeclaration "_totalSupply"
         Type: uint256
         Source: "uint256 _totalSupply"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return totalSupply;\r\n    }"
      Return
         Gas costs: 208
         Source: "return totalSupply"
        Identifier totalSupply
           Type: uint256
           Source: "totalSupply"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) external constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balances[_owner];\r\n    }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) external constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) external requireThaw userNotPlaying(_to) {\r\n\t\trequire(cooldown[_from][_to] <= now);\r\n        var _allowance = allowed[_from][_to];\r\n        if (_from == selfAddress) {\r\n            monthlyLimit[_to] = safeSub(monthlyLimit[_to], _value);\r\n        }\r\n        balances[_to] = balances[_to]+_value;\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        allowed[_from][_to] = safeSub(_allowance, _value);\r\n        addUser(_to);\r\n        bytes memory empty;\r\n        Transfer(_from, _to, _value, empty);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "requireThaw"
       Gas costs: 0
       Source: "requireThaw"
      Identifier requireThaw
         Type: modifier ()
         Source: "requireThaw"
    ModifierInvocation "userNotPlaying"
       Gas costs: 3
       Source: "userNotPlaying(_to)"
      Identifier userNotPlaying
         Type: modifier (address)
         Source: "userNotPlaying"
      Identifier _to
         Type: address
         Source: "_to"
    Block
       Source: "{\r\n\t\trequire(cooldown[_from][_to] <= now);\r\n        var _allowance = allowed[_from][_to];\r\n        if (_from == selfAddress) {\r\n            monthlyLimit[_to] = safeSub(monthlyLimit[_to], _value);\r\n        }\r\n        balances[_to] = balances[_to]+_value;\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        allowed[_from][_to] = safeSub(_allowance, _value);\r\n        addUser(_to);\r\n        bytes memory empty;\r\n        Transfer(_from, _to, _value, empty);\r\n    }"
      ExpressionStatement
         Gas costs: 423
         Source: "require(cooldown[_from][_to] <= now)"
        FunctionCall
           Type: tuple()
           Source: "require(cooldown[_from][_to] <= now)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "cooldown[_from][_to] <= now"
            IndexAccess
               Type: uint256
               Source: "cooldown[_from][_to]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "cooldown[_from]"
                Identifier cooldown
                   Type: mapping(address => mapping(address => uint256))
                   Source: "cooldown"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier now
               Type: uint256
               Source: "now"
      VariableDeclarationStatement
         Gas costs: 397
         Source: "var _allowance = allowed[_from][_to]"
        VariableDeclaration "_allowance"
           Type: uint256
           Source: "var _allowance"
        IndexAccess
           Type: uint256
           Source: "allowed[_from][_to]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_from]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
      IfStatement
         Source: "if (_from == selfAddress) {\r\n            monthlyLimit[_to] = safeSub(monthlyLimit[_to], _value);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 257
           Source: "_from == selfAddress"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier selfAddress
             Type: address
             Source: "selfAddress"
        Block
           Source: "{\r\n            monthlyLimit[_to] = safeSub(monthlyLimit[_to], _value);\r\n        }"
          ExpressionStatement
             Gas costs: 20424
             Source: "monthlyLimit[_to] = safeSub(monthlyLimit[_to], _value)"
            Assignment using operator =
               Type: uint256
               Source: "monthlyLimit[_to] = safeSub(monthlyLimit[_to], _value)"
              IndexAccess
                 Type: uint256
                 Source: "monthlyLimit[_to]"
                Identifier monthlyLimit
                   Type: mapping(address => uint256)
                   Source: "monthlyLimit"
                Identifier _to
                   Type: address
                   Source: "_to"
              FunctionCall
                 Type: uint256
                 Source: "safeSub(monthlyLimit[_to], _value)"
                Identifier safeSub
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "safeSub"
                IndexAccess
                   Type: uint256
                   Source: "monthlyLimit[_to]"
                  Identifier monthlyLimit
                     Type: mapping(address => uint256)
                     Source: "monthlyLimit"
                  Identifier _to
                     Type: address
                     Source: "_to"
                Identifier _value
                   Type: uint256
                   Source: "_value"
      ExpressionStatement
         Gas costs: 20406
         Source: "balances[_to] = balances[_to]+_value"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to]+_value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          BinaryOperation using operator +
             Type: uint256
             Source: "balances[_to]+_value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20418
         Source: "balances[_from] = safeSub(balances[_from], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_from] = safeSub(balances[_from], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "safeSub(balances[_from], _value)"
            Identifier safeSub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "safeSub"
            IndexAccess
               Type: uint256
               Source: "balances[_from]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20218
         Source: "allowed[_from][_to] = safeSub(_allowance, _value)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[_from][_to] = safeSub(_allowance, _value)"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][_to]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "safeSub(_allowance, _value)"
            Identifier safeSub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "safeSub"
            Identifier _allowance
               Type: uint256
               Source: "_allowance"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 7
         Source: "addUser(_to)"
        FunctionCall
           Type: tuple()
           Source: "addUser(_to)"
          Identifier addUser
             Type: function (address)
             Source: "addUser"
          Identifier _to
             Type: address
             Source: "_to"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "bytes memory empty"
        VariableDeclaration "empty"
           Type: bytes memory
           Source: "bytes memory empty"
          ElementaryTypeName bytes
             Source: "bytes"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value, empty)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value, empty)"
          Identifier Transfer
             Type: function (address,address,uint256,bytes memory)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier empty
             Type: bytes memory
             Source: "empty"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) external {\r\n        allowed[msg.sender][_spender] = _value;\r\n\t\tcooldown[msg.sender][_spender] = now + 30 minutes;\r\n        Approval(msg.sender, _spender, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        allowed[msg.sender][_spender] = _value;\r\n\t\tcooldown[msg.sender][_spender] = now + 30 minutes;\r\n        Approval(msg.sender, _spender, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20198
         Source: "cooldown[msg.sender][_spender] = now + 30 minutes"
        Assignment using operator =
           Type: uint256
           Source: "cooldown[msg.sender][_spender] = now + 30 minutes"
          IndexAccess
             Type: uint256
             Source: "cooldown[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "cooldown[msg.sender]"
              Identifier cooldown
                 Type: mapping(address => mapping(address => uint256))
                 Source: "cooldown"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + 30 minutes"
            Identifier now
               Type: uint256
               Source: "now"
            Literal, token: [no token] value: 30
               Type: int_const 1800
               Source: "30 minutes"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value, uint256 _cooldown) external {\r\n        allowed[msg.sender][_spender] = _value;\r\n\t\tcooldown[msg.sender][_spender] = now + _cooldown;\r\n        Approval(msg.sender, _spender, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value, uint256 _cooldown)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_cooldown"
         Type: uint256
         Source: "uint256 _cooldown"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        allowed[msg.sender][_spender] = _value;\r\n\t\tcooldown[msg.sender][_spender] = now + _cooldown;\r\n        Approval(msg.sender, _spender, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20198
         Source: "cooldown[msg.sender][_spender] = now + _cooldown"
        Assignment using operator =
           Type: uint256
           Source: "cooldown[msg.sender][_spender] = now + _cooldown"
          IndexAccess
             Type: uint256
             Source: "cooldown[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "cooldown[msg.sender]"
              Identifier cooldown
                 Type: mapping(address => mapping(address => uint256))
                 Source: "cooldown"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + _cooldown"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier _cooldown
               Type: uint256
               Source: "_cooldown"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) external isRunning requireThaw returns (bool success){\r\n        bytes memory empty;\r\n        if (_to == selfAddress) {\r\n            return transferToSelf(_value, empty);\r\n        } else if (isContract(_to)) {\r\n            return transferToContract(_to, _value, empty);\r\n        } else {\r\n            return transferToAddress(_to, _value, empty);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "isRunning"
       Gas costs: 0
       Source: "isRunning"
      Identifier isRunning
         Type: modifier ()
         Source: "isRunning"
    ModifierInvocation "requireThaw"
       Gas costs: 0
       Source: "requireThaw"
      Identifier requireThaw
         Type: modifier ()
         Source: "requireThaw"
    Block
       Source: "{\r\n        bytes memory empty;\r\n        if (_to == selfAddress) {\r\n            return transferToSelf(_value, empty);\r\n        } else if (isContract(_to)) {\r\n            return transferToContract(_to, _value, empty);\r\n        } else {\r\n            return transferToAddress(_to, _value, empty);\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "bytes memory empty"
        VariableDeclaration "empty"
           Type: bytes memory
           Source: "bytes memory empty"
          ElementaryTypeName bytes
             Source: "bytes"
      IfStatement
         Source: "if (_to == selfAddress) {\r\n            return transferToSelf(_value, empty);\r\n        } else if (isContract(_to)) {\r\n            return transferToContract(_to, _value, empty);\r\n        } else {\r\n            return transferToAddress(_to, _value, empty);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 257
           Source: "_to == selfAddress"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier selfAddress
             Type: address
             Source: "selfAddress"
        Block
           Source: "{\r\n            return transferToSelf(_value, empty);\r\n        }"
          Return
             Gas costs: 26
             Source: "return transferToSelf(_value, empty)"
            FunctionCall
               Type: bool
               Source: "transferToSelf(_value, empty)"
              Identifier transferToSelf
                 Type: function (uint256,bytes memory) returns (bool)
                 Source: "transferToSelf"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier empty
                 Type: bytes memory
                 Source: "empty"
        IfStatement
           Source: "if (isContract(_to)) {\r\n            return transferToContract(_to, _value, empty);\r\n        } else {\r\n            return transferToAddress(_to, _value, empty);\r\n        }"
          FunctionCall
             Type: bool
             Gas costs: 7
             Source: "isContract(_to)"
            Identifier isContract
               Type: function (address) returns (bool)
               Source: "isContract"
            Identifier _to
               Type: address
               Source: "_to"
          Block
             Source: "{\r\n            return transferToContract(_to, _value, empty);\r\n        }"
            Return
               Gas costs: 29
               Source: "return transferToContract(_to, _value, empty)"
              FunctionCall
                 Type: bool
                 Source: "transferToContract(_to, _value, empty)"
                Identifier transferToContract
                   Type: function (address,uint256,bytes memory) returns (bool)
                   Source: "transferToContract"
                Identifier _to
                   Type: address
                   Source: "_to"
                Identifier _value
                   Type: uint256
                   Source: "_value"
                Identifier empty
                   Type: bytes memory
                   Source: "empty"
          Block
             Source: "{\r\n            return transferToAddress(_to, _value, empty);\r\n        }"
            Return
               Gas costs: 18
               Source: "return transferToAddress(_to, _value, empty)"
              FunctionCall
                 Type: bool
                 Source: "transferToAddress(_to, _value, empty)"
                Identifier transferToAddress
                   Type: function (address,uint256,bytes memory) returns (bool)
                   Source: "transferToAddress"
                Identifier _to
                   Type: address
                   Source: "_to"
                Identifier _value
                   Type: uint256
                   Source: "_value"
                Identifier empty
                   Type: bytes memory
                   Source: "empty"
  FunctionDefinition "isContract"
     Source: "function isContract(address _address) internal returns (bool is_contract) {\r\n        uint length;\r\n        assembly {\r\n            length := extcodesize(_address)\r\n        }\r\n        return length > 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool is_contract)"
      VariableDeclaration "is_contract"
         Type: bool
         Source: "bool is_contract"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        uint length;\r\n        assembly {\r\n            length := extcodesize(_address)\r\n        }\r\n        return length > 0;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint length"
        VariableDeclaration "length"
           Type: uint256
           Source: "uint length"
          ElementaryTypeName uint
             Source: "uint"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {\r\n            length := extcodesize(_address)\r\n        }\r\n        return"
      Return
         Gas costs: 14
         Source: "return length > 0"
        BinaryOperation using operator >
           Type: bool
           Source: "length > 0"
          Identifier length
             Type: uint256
             Source: "length"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value, bytes _data) external isRunning requireThaw returns (bool success){\r\n        if (_to == selfAddress) {\r\n            return transferToSelf(_value, _data);\r\n        } else if (isContract(_to)) {\r\n            return transferToContract(_to, _value, _data);\r\n        } else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value, bytes _data)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_data"
         Type: bytes calldata
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "isRunning"
       Gas costs: 0
       Source: "isRunning"
      Identifier isRunning
         Type: modifier ()
         Source: "isRunning"
    ModifierInvocation "requireThaw"
       Gas costs: 0
       Source: "requireThaw"
      Identifier requireThaw
         Type: modifier ()
         Source: "requireThaw"
    Block
       Source: "{\r\n        if (_to == selfAddress) {\r\n            return transferToSelf(_value, _data);\r\n        } else if (isContract(_to)) {\r\n            return transferToContract(_to, _value, _data);\r\n        } else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }"
      IfStatement
         Source: "if (_to == selfAddress) {\r\n            return transferToSelf(_value, _data);\r\n        } else if (isContract(_to)) {\r\n            return transferToContract(_to, _value, _data);\r\n        } else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 257
           Source: "_to == selfAddress"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier selfAddress
             Type: address
             Source: "selfAddress"
        Block
           Source: "{\r\n            return transferToSelf(_value, _data);\r\n        }"
          Return
             Gas costs: [???]
             Source: "return transferToSelf(_value, _data)"
            FunctionCall
               Type: bool
               Source: "transferToSelf(_value, _data)"
              Identifier transferToSelf
                 Type: function (uint256,bytes memory) returns (bool)
                 Source: "transferToSelf"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier _data
                 Type: bytes calldata
                 Source: "_data"
        IfStatement
           Source: "if (isContract(_to)) {\r\n            return transferToContract(_to, _value, _data);\r\n        } else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }"
          FunctionCall
             Type: bool
             Gas costs: 18
             Source: "isContract(_to)"
            Identifier isContract
               Type: function (address) returns (bool)
               Source: "isContract"
            Identifier _to
               Type: address
               Source: "_to"
          Block
             Source: "{\r\n            return transferToContract(_to, _value, _data);\r\n        }"
            Return
               Gas costs: [???]
               Source: "return transferToContract(_to, _value, _data)"
              FunctionCall
                 Type: bool
                 Source: "transferToContract(_to, _value, _data)"
                Identifier transferToContract
                   Type: function (address,uint256,bytes memory) returns (bool)
                   Source: "transferToContract"
                Identifier _to
                   Type: address
                   Source: "_to"
                Identifier _value
                   Type: uint256
                   Source: "_value"
                Identifier _data
                   Type: bytes calldata
                   Source: "_data"
          Block
             Source: "{\r\n            return transferToAddress(_to, _value, _data);\r\n        }"
            Return
               Gas costs: [???]
               Source: "return transferToAddress(_to, _value, _data)"
              FunctionCall
                 Type: bool
                 Source: "transferToAddress(_to, _value, _data)"
                Identifier transferToAddress
                   Type: function (address,uint256,bytes memory) returns (bool)
                   Source: "transferToAddress"
                Identifier _to
                   Type: address
                   Source: "_to"
                Identifier _value
                   Type: uint256
                   Source: "_value"
                Identifier _data
                   Type: bytes calldata
                   Source: "_data"
  FunctionDefinition "transferToAddress"
     Source: "function transferToAddress(address _to, uint256 _value, bytes _data) internal returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = balances[_to]+_value;\r\n        addUser(_to);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value, bytes _data)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = balances[_to]+_value;\r\n        addUser(_to);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20422
         Source: "balances[msg.sender] = safeSub(balances[msg.sender], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = safeSub(balances[msg.sender], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "safeSub(balances[msg.sender], _value)"
            Identifier safeSub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "safeSub"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20400
         Source: "balances[_to] = balances[_to]+_value"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to]+_value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          BinaryOperation using operator +
             Type: uint256
             Source: "balances[_to]+_value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 18
         Source: "addUser(_to)"
        FunctionCall
           Type: tuple()
           Source: "addUser(_to)"
          Identifier addUser
             Type: function (address)
             Source: "addUser"
          Identifier _to
             Type: address
             Source: "_to"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value, _data)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value, _data)"
          Identifier Transfer
             Type: function (address,address,uint256,bytes memory)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier _data
             Type: bytes memory
             Source: "_data"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferToContract"
     Source: "function transferToContract(address _to, uint256 _value, bytes _data) internal returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = balances[_to]+_value;\r\n        WeBetCrypto rec = WeBetCrypto(_to);\r\n        rec.tokenFallback(msg.sender, _value, _data);\r\n        addUser(_to);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value, bytes _data)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = balances[_to]+_value;\r\n        WeBetCrypto rec = WeBetCrypto(_to);\r\n        rec.tokenFallback(msg.sender, _value, _data);\r\n        addUser(_to);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20422
         Source: "balances[msg.sender] = safeSub(balances[msg.sender], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = safeSub(balances[msg.sender], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "safeSub(balances[msg.sender], _value)"
            Identifier safeSub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "safeSub"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20400
         Source: "balances[_to] = balances[_to]+_value"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to]+_value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          BinaryOperation using operator +
             Type: uint256
             Source: "balances[_to]+_value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "WeBetCrypto rec = WeBetCrypto(_to)"
        VariableDeclaration "rec"
           Type: contract WeBetCrypto
           Source: "WeBetCrypto rec"
          UserDefinedTypeName "WeBetCrypto"
             Source: "WeBetCrypto"
        FunctionCall
           Type: contract WeBetCrypto
           Source: "WeBetCrypto(_to)"
          Identifier WeBetCrypto
             Type: type(contract WeBetCrypto)
             Source: "WeBetCrypto"
          Identifier _to
             Type: address
             Source: "_to"
      ExpressionStatement
         Gas costs: [???]
         Source: "rec.tokenFallback(msg.sender, _value, _data)"
        FunctionCall
           Type: tuple()
           Source: "rec.tokenFallback(msg.sender, _value, _data)"
          MemberAccess to member tokenFallback
             Type: function (address,uint256,bytes memory) external
             Source: "rec.tokenFallback"
            Identifier rec
               Type: contract WeBetCrypto
               Source: "rec"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier _data
             Type: bytes memory
             Source: "_data"
      ExpressionStatement
         Gas costs: 18
         Source: "addUser(_to)"
        FunctionCall
           Type: tuple()
           Source: "addUser(_to)"
          Identifier addUser
             Type: function (address)
             Source: "addUser"
          Identifier _to
             Type: address
             Source: "_to"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value, _data)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value, _data)"
          Identifier Transfer
             Type: function (address,address,uint256,bytes memory)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier _data
             Type: bytes memory
             Source: "_data"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferToSelf"
     Source: "function transferToSelf(uint256 _value, bytes _data) internal returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[selfAddress] = balances[selfAddress]+_value;\r\n        Transfer(msg.sender, selfAddress, _value, _data);\r\n\t\tallowed[selfAddress][msg.sender] = _value + allowed[selfAddress][msg.sender];\r\n\t\tApproval(selfAddress, msg.sender, allowed[selfAddress][msg.sender]);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _value, bytes _data)"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[selfAddress] = balances[selfAddress]+_value;\r\n        Transfer(msg.sender, selfAddress, _value, _data);\r\n\t\tallowed[selfAddress][msg.sender] = _value + allowed[selfAddress][msg.sender];\r\n\t\tApproval(selfAddress, msg.sender, allowed[selfAddress][msg.sender]);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20422
         Source: "balances[msg.sender] = safeSub(balances[msg.sender], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = safeSub(balances[msg.sender], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "safeSub(balances[msg.sender], _value)"
            Identifier safeSub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "safeSub"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20872
         Source: "balances[selfAddress] = balances[selfAddress]+_value"
        Assignment using operator =
           Type: uint256
           Source: "balances[selfAddress] = balances[selfAddress]+_value"
          IndexAccess
             Type: uint256
             Source: "balances[selfAddress]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier selfAddress
               Type: address
               Source: "selfAddress"
          BinaryOperation using operator +
             Type: uint256
             Source: "balances[selfAddress]+_value"
            IndexAccess
               Type: uint256
               Source: "balances[selfAddress]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier selfAddress
                 Type: address
                 Source: "selfAddress"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, selfAddress, _value, _data)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, selfAddress, _value, _data)"
          Identifier Transfer
             Type: function (address,address,uint256,bytes memory)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier selfAddress
             Type: address
             Source: "selfAddress"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier _data
             Type: bytes memory
             Source: "_data"
      ExpressionStatement
         Gas costs: 21050
         Source: "allowed[selfAddress][msg.sender] = _value + allowed[selfAddress][msg.sender]"
        Assignment using operator =
           Type: uint256
           Source: "allowed[selfAddress][msg.sender] = _value + allowed[selfAddress][msg.sender]"
          IndexAccess
             Type: uint256
             Source: "allowed[selfAddress][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[selfAddress]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier selfAddress
                 Type: address
                 Source: "selfAddress"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          BinaryOperation using operator +
             Type: uint256
             Source: "_value + allowed[selfAddress][msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "allowed[selfAddress][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[selfAddress]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                Identifier selfAddress
                   Type: address
                   Source: "selfAddress"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(selfAddress, msg.sender, allowed[selfAddress][msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "Approval(selfAddress, msg.sender, allowed[selfAddress][msg.sender])"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          Identifier selfAddress
             Type: address
             Source: "selfAddress"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          IndexAccess
             Type: uint256
             Source: "allowed[selfAddress][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[selfAddress]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier selfAddress
                 Type: address
                 Source: "selfAddress"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "tokenFallback" - public
     Source: "function tokenFallback(address _sender, uint256 _value, bytes _data) {}"
    ParameterList
       Gas costs: 0
       Source: "(address _sender, uint256 _value, bytes _data)"
      VariableDeclaration "_sender"
         Type: address
         Source: "address _sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "checkCooldown" - public - const
     Source: "function checkCooldown(address _allower, address _allowee) external constant returns (uint256 remaining) {\r\n\t\tif (cooldown[_allower][_allowee] > now) {\r\n\t\t\treturn (cooldown[_allower][_allowee] - now);\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address _allower, address _allowee)"
      VariableDeclaration "_allower"
         Type: address
         Source: "address _allower"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_allowee"
         Type: address
         Source: "address _allowee"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n\t\tif (cooldown[_allower][_allowee] > now) {\r\n\t\t\treturn (cooldown[_allower][_allowee] - now);\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}"
      IfStatement
         Source: "if (cooldown[_allower][_allowee] > now) {\r\n\t\t\treturn (cooldown[_allower][_allowee] - now);\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 394
           Source: "cooldown[_allower][_allowee] > now"
          IndexAccess
             Type: uint256
             Source: "cooldown[_allower][_allowee]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "cooldown[_allower]"
              Identifier cooldown
                 Type: mapping(address => mapping(address => uint256))
                 Source: "cooldown"
              Identifier _allower
                 Type: address
                 Source: "_allower"
            Identifier _allowee
               Type: address
               Source: "_allowee"
          Identifier now
             Type: uint256
             Source: "now"
        Block
           Source: "{\r\n\t\t\treturn (cooldown[_allower][_allowee] - now);\r\n\t\t}"
          Return
             Gas costs: 410
             Source: "return (cooldown[_allower][_allowee] - now)"
            TupleExpression
               Type: uint256
               Source: "(cooldown[_allower][_allowee] - now)"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "cooldown[_allower][_allowee] - now"
                IndexAccess
                   Type: uint256
                   Source: "cooldown[_allower][_allowee]"
                  IndexAccess
                     Type: mapping(address => uint256)
                     Source: "cooldown[_allower]"
                    Identifier cooldown
                       Type: mapping(address => mapping(address => uint256))
                       Source: "cooldown"
                    Identifier _allower
                       Type: address
                       Source: "_allower"
                  Identifier _allowee
                     Type: address
                     Source: "_allowee"
                Identifier now
                   Type: uint256
                   Source: "now"
        Block
           Source: "{\r\n\t\t\treturn 0;\r\n\t\t}"
          Return
             Gas costs: 8
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "checkMonthlyLimit" - public - const
     Source: "function checkMonthlyLimit(address _owner) external constant returns (uint256 remaining) {\r\n        return monthlyLimit[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return monthlyLimit[_owner];\r\n    }"
      Return
         Gas costs: 304
         Source: "return monthlyLimit[_owner]"
        IndexAccess
           Type: uint256
           Source: "monthlyLimit[_owner]"
          Identifier monthlyLimit
             Type: mapping(address => uint256)
             Source: "monthlyLimit"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "claimTokens" - public
     Source: "function claimTokens(address _token) isAdmin external { \r\n\t\trequire(_token != selfAddress);\r\n        WeBetCrypto token = WeBetCrypto(_token); \r\n        uint balance = token.balanceOf(selfAddress); \r\n        token.transfer(admin, balance); \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _token)"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "isAdmin"
       Gas costs: 0
       Source: "isAdmin"
      Identifier isAdmin
         Type: modifier ()
         Source: "isAdmin"
    Block
       Source: "{ \r\n\t\trequire(_token != selfAddress);\r\n        WeBetCrypto token = WeBetCrypto(_token); \r\n        uint balance = token.balanceOf(selfAddress); \r\n        token.transfer(admin, balance); \r\n    }"
      ExpressionStatement
         Gas costs: 286
         Source: "require(_token != selfAddress)"
        FunctionCall
           Type: tuple()
           Source: "require(_token != selfAddress)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_token != selfAddress"
            Identifier _token
               Type: address
               Source: "_token"
            Identifier selfAddress
               Type: address
               Source: "selfAddress"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "WeBetCrypto token = WeBetCrypto(_token)"
        VariableDeclaration "token"
           Type: contract WeBetCrypto
           Source: "WeBetCrypto token"
          UserDefinedTypeName "WeBetCrypto"
             Source: "WeBetCrypto"
        FunctionCall
           Type: contract WeBetCrypto
           Source: "WeBetCrypto(_token)"
          Identifier WeBetCrypto
             Type: type(contract WeBetCrypto)
             Source: "WeBetCrypto"
          Identifier _token
             Type: address
             Source: "_token"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint balance = token.balanceOf(selfAddress)"
        VariableDeclaration "balance"
           Type: uint256
           Source: "uint balance"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "token.balanceOf(selfAddress)"
          MemberAccess to member balanceOf
             Type: function (address) view external returns (uint256)
             Source: "token.balanceOf"
            Identifier token
               Type: contract WeBetCrypto
               Source: "token"
          Identifier selfAddress
             Type: address
             Source: "selfAddress"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.transfer(admin, balance)"
        FunctionCall
           Type: bool
           Source: "token.transfer(admin, balance)"
          MemberAccess to member transfer
             Type: function (address,uint256) external returns (bool)
             Source: "token.transfer"
            Identifier token
               Type: contract WeBetCrypto
               Source: "token"
          Identifier admin
             Type: address
             Source: "admin"
          Identifier balance
             Type: uint256
             Source: "balance"
  FunctionDefinition "assetFreeze"
     Source: "function assetFreeze() internal {\r\n        isFrozen = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        isFrozen = true;\r\n    }"
      ExpressionStatement
         Gas costs: 20317
         Source: "isFrozen = true"
        Assignment using operator =
           Type: bool
           Source: "isFrozen = true"
          Identifier isFrozen
             Type: bool
             Source: "isFrozen"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "assetThaw"
     Source: "function assetThaw() internal {\r\n        isFrozen = false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        isFrozen = false;\r\n    }"
      ExpressionStatement
         Gas costs: 20317
         Source: "isFrozen = false"
        Assignment using operator =
           Type: bool
           Source: "isFrozen = false"
          Identifier isFrozen
             Type: bool
             Source: "isFrozen"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "emergencyFreeze" - public
     Source: "function emergencyFreeze() isAdmin external {\r\n        isFrozen = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "isAdmin"
       Gas costs: 0
       Source: "isAdmin"
      Identifier isAdmin
         Type: modifier ()
         Source: "isAdmin"
    Block
       Source: "{\r\n        isFrozen = true;\r\n    }"
      ExpressionStatement
         Gas costs: 20317
         Source: "isFrozen = true"
        Assignment using operator =
           Type: bool
           Source: "isFrozen = true"
          Identifier isFrozen
             Type: bool
             Source: "isFrozen"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "emergencyThaw" - public
     Source: "function emergencyThaw() isAdmin external {\r\n        isFrozen = false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "isAdmin"
       Gas costs: 0
       Source: "isAdmin"
      Identifier isAdmin
         Type: modifier ()
         Source: "isAdmin"
    Block
       Source: "{\r\n        isFrozen = false;\r\n    }"
      ExpressionStatement
         Gas costs: 20317
         Source: "isFrozen = false"
        Assignment using operator =
           Type: bool
           Source: "isFrozen = false"
          Identifier isFrozen
             Type: bool
             Source: "isFrozen"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "emergencySplitToggle" - public
     Source: "function emergencySplitToggle() external {\r\n\t\tsplitInService = !splitInService;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tsplitInService = !splitInService;\r\n\t}"
      ExpressionStatement
         Gas costs: 20606
         Source: "splitInService = !splitInService"
        Assignment using operator =
           Type: bool
           Source: "splitInService = !splitInService"
          Identifier splitInService
             Type: bool
             Source: "splitInService"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!splitInService"
            Identifier splitInService
               Type: bool
               Source: "splitInService"
  FunctionDefinition "setPriceOfEther" - public
     Source: "function setPriceOfEther(uint256 newPrice, string TLSNotaryProof) external isAdmin {\r\n        pricePerEther = newPrice;\r\n        CurrentTLSNProof(selfAddress, TLSNotaryProof);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 newPrice, string TLSNotaryProof)"
      VariableDeclaration "newPrice"
         Type: uint256
         Source: "uint256 newPrice"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "TLSNotaryProof"
         Type: string calldata
         Source: "string TLSNotaryProof"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "isAdmin"
       Gas costs: 0
       Source: "isAdmin"
      Identifier isAdmin
         Type: modifier ()
         Source: "isAdmin"
    Block
       Source: "{\r\n        pricePerEther = newPrice;\r\n        CurrentTLSNProof(selfAddress, TLSNotaryProof);\r\n    }"
      ExpressionStatement
         Gas costs: 20014
         Source: "pricePerEther = newPrice"
        Assignment using operator =
           Type: uint256
           Source: "pricePerEther = newPrice"
          Identifier pricePerEther
             Type: uint256
             Source: "pricePerEther"
          Identifier newPrice
             Type: uint256
             Source: "newPrice"
      ExpressionStatement
         Gas costs: [???]
         Source: "CurrentTLSNProof(selfAddress, TLSNotaryProof)"
        FunctionCall
           Type: tuple()
           Source: "CurrentTLSNProof(selfAddress, TLSNotaryProof)"
          Identifier CurrentTLSNProof
             Type: function (address,string memory)
             Source: "CurrentTLSNProof"
          Identifier selfAddress
             Type: address
             Source: "selfAddress"
          Identifier TLSNotaryProof
             Type: string calldata
             Source: "TLSNotaryProof"
  FunctionDefinition "getPricePerToken" - public - const
     Source: "function getPricePerToken() public constant returns (uint256 price) {\r\n        if (balances[selfAddress] > 200000000000000) {\r\n            return 50;\r\n        } else if (balances[selfAddress] > 150000000000000) {\r\n\t\t\treturn 200;\r\n\t\t} else if (balances[selfAddress] > 100000000000000) {\r\n\t\t\treturn 400;\r\n\t\t} else {\r\n\t\t\treturn 550;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256 price)"
      VariableDeclaration "price"
         Type: uint256
         Source: "uint256 price"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        if (balances[selfAddress] > 200000000000000) {\r\n            return 50;\r\n        } else if (balances[selfAddress] > 150000000000000) {\r\n\t\t\treturn 200;\r\n\t\t} else if (balances[selfAddress] > 100000000000000) {\r\n\t\t\treturn 400;\r\n\t\t} else {\r\n\t\t\treturn 550;\r\n        }\r\n    }"
      IfStatement
         Source: "if (balances[selfAddress] > 200000000000000) {\r\n            return 50;\r\n        } else if (balances[selfAddress] > 150000000000000) {\r\n\t\t\treturn 200;\r\n\t\t} else if (balances[selfAddress] > 100000000000000) {\r\n\t\t\treturn 400;\r\n\t\t} else {\r\n\t\t\treturn 550;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 541
           Source: "balances[selfAddress] > 200000000000000"
          IndexAccess
             Type: uint256
             Source: "balances[selfAddress]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier selfAddress
               Type: address
               Source: "selfAddress"
          Literal, token: [no token] value: 200000000000000
             Type: int_const 200000000000000
             Source: "200000000000000"
        Block
           Source: "{\r\n            return 50;\r\n        }"
          Return
             Gas costs: 19
             Source: "return 50"
            Literal, token: [no token] value: 50
               Type: int_const 50
               Source: "50"
        IfStatement
           Source: "if (balances[selfAddress] > 150000000000000) {\r\n\t\t\treturn 200;\r\n\t\t} else if (balances[selfAddress] > 100000000000000) {\r\n\t\t\treturn 400;\r\n\t\t} else {\r\n\t\t\treturn 550;\r\n        }"
          BinaryOperation using operator >
             Type: bool
             Gas costs: 541
             Source: "balances[selfAddress] > 150000000000000"
            IndexAccess
               Type: uint256
               Source: "balances[selfAddress]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier selfAddress
                 Type: address
                 Source: "selfAddress"
            Literal, token: [no token] value: 150000000000000
               Type: int_const 150000000000000
               Source: "150000000000000"
          Block
             Source: "{\r\n\t\t\treturn 200;\r\n\t\t}"
            Return
               Gas costs: 19
               Source: "return 200"
              Literal, token: [no token] value: 200
                 Type: int_const 200
                 Source: "200"
          IfStatement
             Source: "if (balances[selfAddress] > 100000000000000) {\r\n\t\t\treturn 400;\r\n\t\t} else {\r\n\t\t\treturn 550;\r\n        }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 541
               Source: "balances[selfAddress] > 100000000000000"
              IndexAccess
                 Type: uint256
                 Source: "balances[selfAddress]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier selfAddress
                   Type: address
                   Source: "selfAddress"
              Literal, token: [no token] value: 100000000000000
                 Type: int_const 100000000000000
                 Source: "100000000000000"
            Block
               Source: "{\r\n\t\t\treturn 400;\r\n\t\t}"
              Return
                 Gas costs: 19
                 Source: "return 400"
                Literal, token: [no token] value: 400
                   Type: int_const 400
                   Source: "400"
            Block
               Source: "{\r\n\t\t\treturn 550;\r\n        }"
              Return
                 Gas costs: 8
                 Source: "return 550"
                Literal, token: [no token] value: 550
                   Type: int_const 550
                   Source: "550"
  FunctionDefinition "calculateTokenAmount"
     Source: "function calculateTokenAmount(uint256 _value) internal returns (uint256 tokenAmount) {\r\n\t\ttokenAmount = ((_value*(10**7)/1 ether)*pricePerEther)/getPricePerToken();\r\n\t\tassert(tokenAmount <= 5000000000000);\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _value)"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 tokenAmount)"
      VariableDeclaration "tokenAmount"
         Type: uint256
         Source: "uint256 tokenAmount"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n\t\ttokenAmount = ((_value*(10**7)/1 ether)*pricePerEther)/getPricePerToken();\r\n\t\tassert(tokenAmount <= 5000000000000);\r\n\t}"
      ExpressionStatement
         Gas costs: 298
         Source: "tokenAmount = ((_value*(10**7)/1 ether)*pricePerEther)/getPricePerToken()"
        Assignment using operator =
           Type: uint256
           Source: "tokenAmount = ((_value*(10**7)/1 ether)*pricePerEther)/getPricePerToken()"
          Identifier tokenAmount
             Type: uint256
             Source: "tokenAmount"
          BinaryOperation using operator /
             Type: uint256
             Source: "((_value*(10**7)/1 ether)*pricePerEther)/getPricePerToken()"
            TupleExpression
               Type: uint256
               Source: "((_value*(10**7)/1 ether)*pricePerEther)"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "(_value*(10**7)/1 ether)*pricePerEther"
                TupleExpression
                   Type: uint256
                   Source: "(_value*(10**7)/1 ether)"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "_value*(10**7)/1 ether"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "_value*(10**7)"
                      Identifier _value
                         Type: uint256
                         Source: "_value"
                      TupleExpression
                         Type: int_const 10000000
                         Source: "(10**7)"
                        BinaryOperation using operator **
                           Type: int_const 10000000
                           Source: "10**7"
                          Literal, token: [no token] value: 10
                             Type: int_const 10
                             Source: "10"
                          Literal, token: [no token] value: 7
                             Type: int_const 7
                             Source: "7"
                    Literal, token: [no token] value: 1
                       Type: int_const 1000000000000000000
                       Source: "1 ether"
                Identifier pricePerEther
                   Type: uint256
                   Source: "pricePerEther"
            FunctionCall
               Type: uint256
               Source: "getPricePerToken()"
              Identifier getPricePerToken
                 Type: function () view returns (uint256)
                 Source: "getPricePerToken"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(tokenAmount <= 5000000000000)"
        FunctionCall
           Type: tuple()
           Source: "assert(tokenAmount <= 5000000000000)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "tokenAmount <= 5000000000000"
            Identifier tokenAmount
               Type: uint256
               Source: "tokenAmount"
            Literal, token: [no token] value: 5000000000000
               Type: int_const 5000000000000
               Source: "5000000000000"
  FunctionDefinition "addUser"
     Source: "function addUser(address _user) internal {\r\n\t\tif (!isAdded[_user]) {\r\n            users.push(_user);\r\n            monthlyLimit[_user] = 5000000000000;\r\n            isAdded[_user] = true;\r\n        }\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address _user)"
      VariableDeclaration "_user"
         Type: address
         Source: "address _user"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tif (!isAdded[_user]) {\r\n            users.push(_user);\r\n            monthlyLimit[_user] = 5000000000000;\r\n            isAdded[_user] = true;\r\n        }\r\n\t}"
      IfStatement
         Source: "if (!isAdded[_user]) {\r\n            users.push(_user);\r\n            monthlyLimit[_user] = 5000000000000;\r\n            isAdded[_user] = true;\r\n        }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 338
           Source: "!isAdded[_user]"
          IndexAccess
             Type: bool
             Source: "isAdded[_user]"
            Identifier isAdded
               Type: mapping(address => bool)
               Source: "isAdded"
            Identifier _user
               Type: address
               Source: "_user"
        Block
           Source: "{\r\n            users.push(_user);\r\n            monthlyLimit[_user] = 5000000000000;\r\n            isAdded[_user] = true;\r\n        }"
          ExpressionStatement
             Gas costs: 20365
             Source: "users.push(_user)"
            FunctionCall
               Type: uint256
               Source: "users.push(_user)"
              MemberAccess to member push
                 Type: function (address) returns (uint256)
                 Source: "users.push"
                Identifier users
                   Type: address[] storage ref
                   Source: "users"
              Identifier _user
                 Type: address
                 Source: "_user"
          ExpressionStatement
             Gas costs: 20107
             Source: "monthlyLimit[_user] = 5000000000000"
            Assignment using operator =
               Type: uint256
               Source: "monthlyLimit[_user] = 5000000000000"
              IndexAccess
                 Type: uint256
                 Source: "monthlyLimit[_user]"
                Identifier monthlyLimit
                   Type: mapping(address => uint256)
                   Source: "monthlyLimit"
                Identifier _user
                   Type: address
                   Source: "_user"
              Literal, token: [no token] value: 5000000000000
                 Type: int_const 5000000000000
                 Source: "5000000000000"
          ExpressionStatement
             Gas costs: 20357
             Source: "isAdded[_user] = true"
            Assignment using operator =
               Type: bool
               Source: "isAdded[_user] = true"
              IndexAccess
                 Type: bool
                 Source: "isAdded[_user]"
                Identifier isAdded
                   Type: mapping(address => bool)
                   Source: "isAdded"
                Identifier _user
                   Type: address
                   Source: "_user"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
  FunctionDefinition "splitProfits" - public
     Source: "function splitProfits() external {\r\n\t\trequire(splitInService);\r\n        bytes memory empty;\r\n        uint i;\r\n        if (!isFrozen) {\r\n            require(now >= relativeDateSave);\r\n            assetFreeze();\r\n            require(balances[selfAddress] > 30000000000000);\r\n            relativeDateSave = now + 30 days;\r\n            currentProfits = ((balances[selfAddress]-30000000000000)/10)*7; \r\n            amountInCirculation = safeSub(300000000000000, balances[selfAddress]);\r\n            currentIteration = 0;\r\n\t\t\tactualProfitSplit = 0;\r\n        } else {\r\n            for (i = currentIteration; i < users.length; i++) {\r\n                monthlyLimit[users[i]] = 5000000000000;\r\n                if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }\r\n\t\t\t\tif (allowed[selfAddress][users[i]] == 0) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if ((balances[users[i]]/allowed[selfAddress][users[i]]) < 19) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n                    continue;\r\n                }\r\n                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tcheckSplitEnd(i);\r\n                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty);\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\trequire(splitInService);\r\n        bytes memory empty;\r\n        uint i;\r\n        if (!isFrozen) {\r\n            require(now >= relativeDateSave);\r\n            assetFreeze();\r\n            require(balances[selfAddress] > 30000000000000);\r\n            relativeDateSave = now + 30 days;\r\n            currentProfits = ((balances[selfAddress]-30000000000000)/10)*7; \r\n            amountInCirculation = safeSub(300000000000000, balances[selfAddress]);\r\n            currentIteration = 0;\r\n\t\t\tactualProfitSplit = 0;\r\n        } else {\r\n            for (i = currentIteration; i < users.length; i++) {\r\n                monthlyLimit[users[i]] = 5000000000000;\r\n                if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }\r\n\t\t\t\tif (allowed[selfAddress][users[i]] == 0) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if ((balances[users[i]]/allowed[selfAddress][users[i]]) < 19) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n                    continue;\r\n                }\r\n                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tcheckSplitEnd(i);\r\n                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty);\r\n            }\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 315
         Source: "require(splitInService)"
        FunctionCall
           Type: tuple()
           Source: "require(splitInService)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier splitInService
             Type: bool
             Source: "splitInService"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "bytes memory empty"
        VariableDeclaration "empty"
           Type: bytes memory
           Source: "bytes memory empty"
          ElementaryTypeName bytes
             Source: "bytes"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint i"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint i"
          ElementaryTypeName uint
             Source: "uint"
      IfStatement
         Source: "if (!isFrozen) {\r\n            require(now >= relativeDateSave);\r\n            assetFreeze();\r\n            require(balances[selfAddress] > 30000000000000);\r\n            relativeDateSave = now + 30 days;\r\n            currentProfits = ((balances[selfAddress]-30000000000000)/10)*7; \r\n            amountInCirculation = safeSub(300000000000000, balances[selfAddress]);\r\n            currentIteration = 0;\r\n\t\t\tactualProfitSplit = 0;\r\n        } else {\r\n            for (i = currentIteration; i < users.length; i++) {\r\n                monthlyLimit[users[i]] = 5000000000000;\r\n                if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }\r\n\t\t\t\tif (allowed[selfAddress][users[i]] == 0) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if ((balances[users[i]]/allowed[selfAddress][users[i]]) < 19) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n                    continue;\r\n                }\r\n                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tcheckSplitEnd(i);\r\n                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty);\r\n            }\r\n        }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 292
           Source: "!isFrozen"
          Identifier isFrozen
             Type: bool
             Source: "isFrozen"
        Block
           Source: "{\r\n            require(now >= relativeDateSave);\r\n            assetFreeze();\r\n            require(balances[selfAddress] > 30000000000000);\r\n            relativeDateSave = now + 30 days;\r\n            currentProfits = ((balances[selfAddress]-30000000000000)/10)*7; \r\n            amountInCirculation = safeSub(300000000000000, balances[selfAddress]);\r\n            currentIteration = 0;\r\n\t\t\tactualProfitSplit = 0;\r\n        }"
          ExpressionStatement
             Gas costs: 237
             Source: "require(now >= relativeDateSave)"
            FunctionCall
               Type: tuple()
               Source: "require(now >= relativeDateSave)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "now >= relativeDateSave"
                Identifier now
                   Type: uint256
                   Source: "now"
                Identifier relativeDateSave
                   Type: uint256
                   Source: "relativeDateSave"
          ExpressionStatement
             Gas costs: 4
             Source: "assetFreeze()"
            FunctionCall
               Type: tuple()
               Source: "assetFreeze()"
              Identifier assetFreeze
                 Type: function ()
                 Source: "assetFreeze"
          ExpressionStatement
             Gas costs: 567
             Source: "require(balances[selfAddress] > 30000000000000)"
            FunctionCall
               Type: tuple()
               Source: "require(balances[selfAddress] > 30000000000000)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator >
                 Type: bool
                 Source: "balances[selfAddress] > 30000000000000"
                IndexAccess
                   Type: uint256
                   Source: "balances[selfAddress]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  Identifier selfAddress
                     Type: address
                     Source: "selfAddress"
                Literal, token: [no token] value: 30000000000000
                   Type: int_const 30000000000000
                   Source: "30000000000000"
          ExpressionStatement
             Gas costs: 20019
             Source: "relativeDateSave = now + 30 days"
            Assignment using operator =
               Type: uint256
               Source: "relativeDateSave = now + 30 days"
              Identifier relativeDateSave
                 Type: uint256
                 Source: "relativeDateSave"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "now + 30 days"
                Identifier now
                   Type: uint256
                   Source: "now"
                Literal, token: [no token] value: 30
                   Type: int_const 2592000
                   Source: "30 days"
          ExpressionStatement
             Gas costs: 20591
             Source: "currentProfits = ((balances[selfAddress]-30000000000000)/10)*7"
            Assignment using operator =
               Type: uint256
               Source: "currentProfits = ((balances[selfAddress]-30000000000000)/10)*7"
              Identifier currentProfits
                 Type: uint256
                 Source: "currentProfits"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "((balances[selfAddress]-30000000000000)/10)*7"
                TupleExpression
                   Type: uint256
                   Source: "((balances[selfAddress]-30000000000000)/10)"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "(balances[selfAddress]-30000000000000)/10"
                    TupleExpression
                       Type: uint256
                       Source: "(balances[selfAddress]-30000000000000)"
                      BinaryOperation using operator -
                         Type: uint256
                         Source: "balances[selfAddress]-30000000000000"
                        IndexAccess
                           Type: uint256
                           Source: "balances[selfAddress]"
                          Identifier balances
                             Type: mapping(address => uint256)
                             Source: "balances"
                          Identifier selfAddress
                             Type: address
                             Source: "selfAddress"
                        Literal, token: [no token] value: 30000000000000
                           Type: int_const 30000000000000
                           Source: "30000000000000"
                    Literal, token: [no token] value: 10
                       Type: int_const 10
                       Source: "10"
                Literal, token: [no token] value: 7
                   Type: int_const 7
                   Source: "7"
          ExpressionStatement
             Gas costs: 20553
             Source: "amountInCirculation = safeSub(300000000000000, balances[selfAddress])"
            Assignment using operator =
               Type: uint256
               Source: "amountInCirculation = safeSub(300000000000000, balances[selfAddress])"
              Identifier amountInCirculation
                 Type: uint256
                 Source: "amountInCirculation"
              FunctionCall
                 Type: uint256
                 Source: "safeSub(300000000000000, balances[selfAddress])"
                Identifier safeSub
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "safeSub"
                Literal, token: [no token] value: 300000000000000
                   Type: int_const 300000000000000
                   Source: "300000000000000"
                IndexAccess
                   Type: uint256
                   Source: "balances[selfAddress]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  Identifier selfAddress
                     Type: address
                     Source: "selfAddress"
          ExpressionStatement
             Gas costs: 5014
             Source: "currentIteration = 0"
            Assignment using operator =
               Type: uint256
               Source: "currentIteration = 0"
              Identifier currentIteration
                 Type: uint256
                 Source: "currentIteration"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          ExpressionStatement
             Gas costs: 5014
             Source: "actualProfitSplit = 0"
            Assignment using operator =
               Type: uint256
               Source: "actualProfitSplit = 0"
              Identifier actualProfitSplit
                 Type: uint256
                 Source: "actualProfitSplit"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\r\n            for (i = currentIteration; i < users.length; i++) {\r\n                monthlyLimit[users[i]] = 5000000000000;\r\n                if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }\r\n\t\t\t\tif (allowed[selfAddress][users[i]] == 0) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if ((balances[users[i]]/allowed[selfAddress][users[i]]) < 19) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n                    continue;\r\n                }\r\n                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tcheckSplitEnd(i);\r\n                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty);\r\n            }\r\n        }"
          ForStatement
             Source: "for (i = currentIteration; i < users.length; i++) {\r\n                monthlyLimit[users[i]] = 5000000000000;\r\n                if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }\r\n\t\t\t\tif (allowed[selfAddress][users[i]] == 0) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if ((balances[users[i]]/allowed[selfAddress][users[i]]) < 19) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n                    continue;\r\n                }\r\n                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tcheckSplitEnd(i);\r\n                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty);\r\n            }"
            ExpressionStatement
               Gas costs: 208
               Source: "i = currentIteration"
              Assignment using operator =
                 Type: uint256
                 Source: "i = currentIteration"
                Identifier i
                   Type: uint256
                   Source: "i"
                Identifier currentIteration
                   Type: uint256
                   Source: "currentIteration"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 217
               Source: "i < users.length"
              Identifier i
                 Type: uint256
                 Source: "i"
              MemberAccess to member length
                 Type: uint256
                 Source: "users.length"
                Identifier users
                   Type: address[] storage ref
                   Source: "users"
            ExpressionStatement
               Gas costs: 19
               Source: "i++"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "i++"
                Identifier i
                   Type: uint256
                   Source: "i"
            Block
               Source: "{\r\n                monthlyLimit[users[i]] = 5000000000000;\r\n                if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }\r\n\t\t\t\tif (allowed[selfAddress][users[i]] == 0) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if ((balances[users[i]]/allowed[selfAddress][users[i]]) < 19) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n                    continue;\r\n                }\r\n                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tcheckSplitEnd(i);\r\n                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty);\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "monthlyLimit[users[i]] = 5000000000000"
                Assignment using operator =
                   Type: uint256
                   Source: "monthlyLimit[users[i]] = 5000000000000"
                  IndexAccess
                     Type: uint256
                     Source: "monthlyLimit[users[i]]"
                    Identifier monthlyLimit
                       Type: mapping(address => uint256)
                       Source: "monthlyLimit"
                    IndexAccess
                       Type: address
                       Source: "users[i]"
                      Identifier users
                         Type: address[] storage ref
                         Source: "users"
                      Identifier i
                         Type: uint256
                         Source: "i"
                  Literal, token: [no token] value: 5000000000000
                     Type: int_const 5000000000000
                     Source: "5000000000000"
              IfStatement
                 Source: "if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }"
                BinaryOperation using operator <
                   Type: bool
                   Gas costs: 8
                   Source: "msg.gas < 240000"
                  MemberAccess to member gas
                     Type: uint256
                     Source: "msg.gas"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Literal, token: [no token] value: 240000
                     Type: int_const 240000
                     Source: "240000"
                Block
                   Source: "{\r\n                    currentIteration = i;\r\n                    break;\r\n                }"
                  ExpressionStatement
                     Gas costs: 20014
                     Source: "currentIteration = i"
                    Assignment using operator =
                       Type: uint256
                       Source: "currentIteration = i"
                      Identifier currentIteration
                         Type: uint256
                         Source: "currentIteration"
                      Identifier i
                         Type: uint256
                         Source: "i"
                  Break
                     Gas costs: 0
                     Source: "break"
              IfStatement
                 Source: "if (allowed[selfAddress][users[i]] == 0) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if ((balances[users[i]]/allowed[selfAddress][users[i]]) < 19) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n                    continue;\r\n                }"
                BinaryOperation using operator ==
                   Type: bool
                   Gas costs: [???]
                   Source: "allowed[selfAddress][users[i]] == 0"
                  IndexAccess
                     Type: uint256
                     Source: "allowed[selfAddress][users[i]]"
                    IndexAccess
                       Type: mapping(address => uint256)
                       Source: "allowed[selfAddress]"
                      Identifier allowed
                         Type: mapping(address => mapping(address => uint256))
                         Source: "allowed"
                      Identifier selfAddress
                         Type: address
                         Source: "selfAddress"
                    IndexAccess
                       Type: address
                       Source: "users[i]"
                      Identifier users
                         Type: address[] storage ref
                         Source: "users"
                      Identifier i
                         Type: uint256
                         Source: "i"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                Block
                   Source: "{\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}"
                  ExpressionStatement
                     Gas costs: 18
                     Source: "checkSplitEnd(i)"
                    FunctionCall
                       Type: tuple()
                       Source: "checkSplitEnd(i)"
                      Identifier checkSplitEnd
                         Type: function (uint256)
                         Source: "checkSplitEnd"
                      Identifier i
                         Type: uint256
                         Source: "i"
                  Continue
                     Gas costs: 11
                     Source: "continue"
                IfStatement
                   Source: "if ((balances[users[i]]/allowed[selfAddress][users[i]]) < 19) {\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n                    continue;\r\n                }"
                  BinaryOperation using operator <
                     Type: bool
                     Gas costs: [???]
                     Source: "(balances[users[i]]/allowed[selfAddress][users[i]]) < 19"
                    TupleExpression
                       Type: uint256
                       Source: "(balances[users[i]]/allowed[selfAddress][users[i]])"
                      BinaryOperation using operator /
                         Type: uint256
                         Source: "balances[users[i]]/allowed[selfAddress][users[i]]"
                        IndexAccess
                           Type: uint256
                           Source: "balances[users[i]]"
                          Identifier balances
                             Type: mapping(address => uint256)
                             Source: "balances"
                          IndexAccess
                             Type: address
                             Source: "users[i]"
                            Identifier users
                               Type: address[] storage ref
                               Source: "users"
                            Identifier i
                               Type: uint256
                               Source: "i"
                        IndexAccess
                           Type: uint256
                           Source: "allowed[selfAddress][users[i]]"
                          IndexAccess
                             Type: mapping(address => uint256)
                             Source: "allowed[selfAddress]"
                            Identifier allowed
                               Type: mapping(address => mapping(address => uint256))
                               Source: "allowed"
                            Identifier selfAddress
                               Type: address
                               Source: "selfAddress"
                          IndexAccess
                             Type: address
                             Source: "users[i]"
                            Identifier users
                               Type: address[] storage ref
                               Source: "users"
                            Identifier i
                               Type: uint256
                               Source: "i"
                    Literal, token: [no token] value: 19
                       Type: int_const 19
                       Source: "19"
                  Block
                     Source: "{\r\n\t\t\t\t\tcheckSplitEnd(i);\r\n                    continue;\r\n                }"
                    ExpressionStatement
                       Gas costs: 18
                       Source: "checkSplitEnd(i)"
                      FunctionCall
                         Type: tuple()
                         Source: "checkSplitEnd(i)"
                        Identifier checkSplitEnd
                           Type: function (uint256)
                           Source: "checkSplitEnd"
                        Identifier i
                           Type: uint256
                           Source: "i"
                    Continue
                       Gas costs: 11
                       Source: "continue"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation"
                Assignment using operator +=
                   Type: uint256
                   Source: "balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation"
                  IndexAccess
                     Type: uint256
                     Source: "balances[users[i]]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    IndexAccess
                       Type: address
                       Source: "users[i]"
                      Identifier users
                         Type: address[] storage ref
                         Source: "users"
                      Identifier i
                         Type: uint256
                         Source: "i"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "(balances[users[i]]*currentProfits)/amountInCirculation"
                    TupleExpression
                       Type: uint256
                       Source: "(balances[users[i]]*currentProfits)"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "balances[users[i]]*currentProfits"
                        IndexAccess
                           Type: uint256
                           Source: "balances[users[i]]"
                          Identifier balances
                             Type: mapping(address => uint256)
                             Source: "balances"
                          IndexAccess
                             Type: address
                             Source: "users[i]"
                            Identifier users
                               Type: address[] storage ref
                               Source: "users"
                            Identifier i
                               Type: uint256
                               Source: "i"
                        Identifier currentProfits
                           Type: uint256
                           Source: "currentProfits"
                    Identifier amountInCirculation
                       Type: uint256
                       Source: "amountInCirculation"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "actualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation"
                Assignment using operator +=
                   Type: uint256
                   Source: "actualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation"
                  Identifier actualProfitSplit
                     Type: uint256
                     Source: "actualProfitSplit"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "(balances[users[i]]*currentProfits)/amountInCirculation"
                    TupleExpression
                       Type: uint256
                       Source: "(balances[users[i]]*currentProfits)"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "balances[users[i]]*currentProfits"
                        IndexAccess
                           Type: uint256
                           Source: "balances[users[i]]"
                          Identifier balances
                             Type: mapping(address => uint256)
                             Source: "balances"
                          IndexAccess
                             Type: address
                             Source: "users[i]"
                            Identifier users
                               Type: address[] storage ref
                               Source: "users"
                            Identifier i
                               Type: uint256
                               Source: "i"
                        Identifier currentProfits
                           Type: uint256
                           Source: "currentProfits"
                    Identifier amountInCirculation
                       Type: uint256
                       Source: "amountInCirculation"
              ExpressionStatement
                 Gas costs: 7
                 Source: "checkSplitEnd(i)"
                FunctionCall
                   Type: tuple()
                   Source: "checkSplitEnd(i)"
                  Identifier checkSplitEnd
                     Type: function (uint256)
                     Source: "checkSplitEnd"
                  Identifier i
                     Type: uint256
                     Source: "i"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty)"
                FunctionCall
                   Type: tuple()
                   Source: "Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty)"
                  Identifier Transfer
                     Type: function (address,address,uint256,bytes memory)
                     Source: "Transfer"
                  Identifier selfAddress
                     Type: address
                     Source: "selfAddress"
                  IndexAccess
                     Type: address
                     Source: "users[i]"
                    Identifier users
                       Type: address[] storage ref
                       Source: "users"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "(balances[users[i]]/amountInCirculation)*currentProfits"
                    TupleExpression
                       Type: uint256
                       Source: "(balances[users[i]]/amountInCirculation)"
                      BinaryOperation using operator /
                         Type: uint256
                         Source: "balances[users[i]]/amountInCirculation"
                        IndexAccess
                           Type: uint256
                           Source: "balances[users[i]]"
                          Identifier balances
                             Type: mapping(address => uint256)
                             Source: "balances"
                          IndexAccess
                             Type: address
                             Source: "users[i]"
                            Identifier users
                               Type: address[] storage ref
                               Source: "users"
                            Identifier i
                               Type: uint256
                               Source: "i"
                        Identifier amountInCirculation
                           Type: uint256
                           Source: "amountInCirculation"
                    Identifier currentProfits
                       Type: uint256
                       Source: "currentProfits"
                  Identifier empty
                     Type: bytes memory
                     Source: "empty"
  FunctionDefinition "checkSplitEnd"
     Source: "function checkSplitEnd(uint256 i) internal {\r\n\t\tif (i == users.length-1) {\r\n\t\t\tassetThaw();\r\n\t\t\tbalances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] + currentProfits/22;\r\n\t\t\tbalances[selfAddress] = balances[selfAddress] - actualProfitSplit - currentProfits/22;\r\n\t\t}\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint256 i)"
      VariableDeclaration "i"
         Type: uint256
         Source: "uint256 i"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tif (i == users.length-1) {\r\n\t\t\tassetThaw();\r\n\t\t\tbalances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] + currentProfits/22;\r\n\t\t\tbalances[selfAddress] = balances[selfAddress] - actualProfitSplit - currentProfits/22;\r\n\t\t}\r\n\t}"
      IfStatement
         Source: "if (i == users.length-1) {\r\n\t\t\tassetThaw();\r\n\t\t\tbalances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] + currentProfits/22;\r\n\t\t\tbalances[selfAddress] = balances[selfAddress] - actualProfitSplit - currentProfits/22;\r\n\t\t}"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 223
           Source: "i == users.length-1"
          Identifier i
             Type: uint256
             Source: "i"
          BinaryOperation using operator -
             Type: uint256
             Source: "users.length-1"
            MemberAccess to member length
               Type: uint256
               Source: "users.length"
              Identifier users
                 Type: address[] storage ref
                 Source: "users"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
        Block
           Source: "{\r\n\t\t\tassetThaw();\r\n\t\t\tbalances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] + currentProfits/22;\r\n\t\t\tbalances[selfAddress] = balances[selfAddress] - actualProfitSplit - currentProfits/22;\r\n\t\t}"
          ExpressionStatement
             Gas costs: 15
             Source: "assetThaw()"
            FunctionCall
               Type: tuple()
               Source: "assetThaw()"
              Identifier assetThaw
                 Type: function ()
                 Source: "assetThaw"
          ExpressionStatement
             Gas costs: 20637
             Source: "balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] + currentProfits/22"
            Assignment using operator =
               Type: uint256
               Source: "balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] + currentProfits/22"
              IndexAccess
                 Type: uint256
                 Source: "balances[0x166Cb48973C2447dafFA8EFd3526da18076088de]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Literal, token: [no token] value: 0x166Cb48973C2447dafFA8EFd3526da18076088de
                   Type: address
                   Source: "0x166Cb48973C2447dafFA8EFd3526da18076088de"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] + currentProfits/22"
                IndexAccess
                   Type: uint256
                   Source: "balances[0x166Cb48973C2447dafFA8EFd3526da18076088de]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  Literal, token: [no token] value: 0x166Cb48973C2447dafFA8EFd3526da18076088de
                     Type: address
                     Source: "0x166Cb48973C2447dafFA8EFd3526da18076088de"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "currentProfits/22"
                  Identifier currentProfits
                     Type: uint256
                     Source: "currentProfits"
                  Literal, token: [no token] value: 22
                     Type: int_const 22
                     Source: "22"
          ExpressionStatement
             Gas costs: 21315
             Source: "balances[selfAddress] = balances[selfAddress] - actualProfitSplit - currentProfits/22"
            Assignment using operator =
               Type: uint256
               Source: "balances[selfAddress] = balances[selfAddress] - actualProfitSplit - currentProfits/22"
              IndexAccess
                 Type: uint256
                 Source: "balances[selfAddress]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier selfAddress
                   Type: address
                   Source: "selfAddress"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "balances[selfAddress] - actualProfitSplit - currentProfits/22"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "balances[selfAddress] - actualProfitSplit"
                  IndexAccess
                     Type: uint256
                     Source: "balances[selfAddress]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    Identifier selfAddress
                       Type: address
                       Source: "selfAddress"
                  Identifier actualProfitSplit
                     Type: uint256
                     Source: "actualProfitSplit"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "currentProfits/22"
                  Identifier currentProfits
                     Type: uint256
                     Source: "currentProfits"
                  Literal, token: [no token] value: 22
                     Type: int_const 22
                     Source: "22"
  FunctionDefinition "ICOSplit" - public
     Source: "function ICOSplit() external isAdmin oneTime {\r\n        bytes memory empty;\r\n        uint i;\r\n        if (!isFrozen) {\r\n            require((relativeDateSave - now) >= (relativeDateSave - 150 days));\r\n            assetFreeze();\r\n            require(balances[selfAddress] > 50000000000000);\r\n            currentProfits = ((balances[selfAddress] - 50000000000000) / 10) * 7; \r\n            amountInCirculation = safeSub(300000000000000, balances[selfAddress]);\r\n            currentIteration = 0;\r\n\t\t\tactualProfitSplit = 0;\r\n        } else {\r\n            for (i = currentIteration; i < users.length; i++) {\r\n                if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }\r\n                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n                if (i == users.length-1) {\r\n                    assetThaw();\r\n                    balances[selfAddress] = balances[selfAddress] - actualProfitSplit;\r\n\t\t\t\t\thasICORun = true;\r\n                }\r\n                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty);\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "isAdmin"
       Gas costs: 0
       Source: "isAdmin"
      Identifier isAdmin
         Type: modifier ()
         Source: "isAdmin"
    ModifierInvocation "oneTime"
       Gas costs: 0
       Source: "oneTime"
      Identifier oneTime
         Type: modifier ()
         Source: "oneTime"
    Block
       Source: "{\r\n        bytes memory empty;\r\n        uint i;\r\n        if (!isFrozen) {\r\n            require((relativeDateSave - now) >= (relativeDateSave - 150 days));\r\n            assetFreeze();\r\n            require(balances[selfAddress] > 50000000000000);\r\n            currentProfits = ((balances[selfAddress] - 50000000000000) / 10) * 7; \r\n            amountInCirculation = safeSub(300000000000000, balances[selfAddress]);\r\n            currentIteration = 0;\r\n\t\t\tactualProfitSplit = 0;\r\n        } else {\r\n            for (i = currentIteration; i < users.length; i++) {\r\n                if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }\r\n                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n                if (i == users.length-1) {\r\n                    assetThaw();\r\n                    balances[selfAddress] = balances[selfAddress] - actualProfitSplit;\r\n\t\t\t\t\thasICORun = true;\r\n                }\r\n                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty);\r\n            }\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "bytes memory empty"
        VariableDeclaration "empty"
           Type: bytes memory
           Source: "bytes memory empty"
          ElementaryTypeName bytes
             Source: "bytes"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint i"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint i"
          ElementaryTypeName uint
             Source: "uint"
      IfStatement
         Source: "if (!isFrozen) {\r\n            require((relativeDateSave - now) >= (relativeDateSave - 150 days));\r\n            assetFreeze();\r\n            require(balances[selfAddress] > 50000000000000);\r\n            currentProfits = ((balances[selfAddress] - 50000000000000) / 10) * 7; \r\n            amountInCirculation = safeSub(300000000000000, balances[selfAddress]);\r\n            currentIteration = 0;\r\n\t\t\tactualProfitSplit = 0;\r\n        } else {\r\n            for (i = currentIteration; i < users.length; i++) {\r\n                if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }\r\n                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n                if (i == users.length-1) {\r\n                    assetThaw();\r\n                    balances[selfAddress] = balances[selfAddress] - actualProfitSplit;\r\n\t\t\t\t\thasICORun = true;\r\n                }\r\n                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty);\r\n            }\r\n        }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 292
           Source: "!isFrozen"
          Identifier isFrozen
             Type: bool
             Source: "isFrozen"
        Block
           Source: "{\r\n            require((relativeDateSave - now) >= (relativeDateSave - 150 days));\r\n            assetFreeze();\r\n            require(balances[selfAddress] > 50000000000000);\r\n            currentProfits = ((balances[selfAddress] - 50000000000000) / 10) * 7; \r\n            amountInCirculation = safeSub(300000000000000, balances[selfAddress]);\r\n            currentIteration = 0;\r\n\t\t\tactualProfitSplit = 0;\r\n        }"
          ExpressionStatement
             Gas costs: 449
             Source: "require((relativeDateSave - now) >= (relativeDateSave - 150 days))"
            FunctionCall
               Type: tuple()
               Source: "require((relativeDateSave - now) >= (relativeDateSave - 150 days))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "(relativeDateSave - now) >= (relativeDateSave - 150 days)"
                TupleExpression
                   Type: uint256
                   Source: "(relativeDateSave - now)"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "relativeDateSave - now"
                    Identifier relativeDateSave
                       Type: uint256
                       Source: "relativeDateSave"
                    Identifier now
                       Type: uint256
                       Source: "now"
                TupleExpression
                   Type: uint256
                   Source: "(relativeDateSave - 150 days)"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "relativeDateSave - 150 days"
                    Identifier relativeDateSave
                       Type: uint256
                       Source: "relativeDateSave"
                    Literal, token: [no token] value: 150
                       Type: int_const 12960000
                       Source: "150 days"
          ExpressionStatement
             Gas costs: 15
             Source: "assetFreeze()"
            FunctionCall
               Type: tuple()
               Source: "assetFreeze()"
              Identifier assetFreeze
                 Type: function ()
                 Source: "assetFreeze"
          ExpressionStatement
             Gas costs: 567
             Source: "require(balances[selfAddress] > 50000000000000)"
            FunctionCall
               Type: tuple()
               Source: "require(balances[selfAddress] > 50000000000000)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator >
                 Type: bool
                 Source: "balances[selfAddress] > 50000000000000"
                IndexAccess
                   Type: uint256
                   Source: "balances[selfAddress]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  Identifier selfAddress
                     Type: address
                     Source: "selfAddress"
                Literal, token: [no token] value: 50000000000000
                   Type: int_const 50000000000000
                   Source: "50000000000000"
          ExpressionStatement
             Gas costs: 20591
             Source: "currentProfits = ((balances[selfAddress] - 50000000000000) / 10) * 7"
            Assignment using operator =
               Type: uint256
               Source: "currentProfits = ((balances[selfAddress] - 50000000000000) / 10) * 7"
              Identifier currentProfits
                 Type: uint256
                 Source: "currentProfits"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "((balances[selfAddress] - 50000000000000) / 10) * 7"
                TupleExpression
                   Type: uint256
                   Source: "((balances[selfAddress] - 50000000000000) / 10)"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "(balances[selfAddress] - 50000000000000) / 10"
                    TupleExpression
                       Type: uint256
                       Source: "(balances[selfAddress] - 50000000000000)"
                      BinaryOperation using operator -
                         Type: uint256
                         Source: "balances[selfAddress] - 50000000000000"
                        IndexAccess
                           Type: uint256
                           Source: "balances[selfAddress]"
                          Identifier balances
                             Type: mapping(address => uint256)
                             Source: "balances"
                          Identifier selfAddress
                             Type: address
                             Source: "selfAddress"
                        Literal, token: [no token] value: 50000000000000
                           Type: int_const 50000000000000
                           Source: "50000000000000"
                    Literal, token: [no token] value: 10
                       Type: int_const 10
                       Source: "10"
                Literal, token: [no token] value: 7
                   Type: int_const 7
                   Source: "7"
          ExpressionStatement
             Gas costs: 20564
             Source: "amountInCirculation = safeSub(300000000000000, balances[selfAddress])"
            Assignment using operator =
               Type: uint256
               Source: "amountInCirculation = safeSub(300000000000000, balances[selfAddress])"
              Identifier amountInCirculation
                 Type: uint256
                 Source: "amountInCirculation"
              FunctionCall
                 Type: uint256
                 Source: "safeSub(300000000000000, balances[selfAddress])"
                Identifier safeSub
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "safeSub"
                Literal, token: [no token] value: 300000000000000
                   Type: int_const 300000000000000
                   Source: "300000000000000"
                IndexAccess
                   Type: uint256
                   Source: "balances[selfAddress]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  Identifier selfAddress
                     Type: address
                     Source: "selfAddress"
          ExpressionStatement
             Gas costs: 5014
             Source: "currentIteration = 0"
            Assignment using operator =
               Type: uint256
               Source: "currentIteration = 0"
              Identifier currentIteration
                 Type: uint256
                 Source: "currentIteration"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          ExpressionStatement
             Gas costs: 5014
             Source: "actualProfitSplit = 0"
            Assignment using operator =
               Type: uint256
               Source: "actualProfitSplit = 0"
              Identifier actualProfitSplit
                 Type: uint256
                 Source: "actualProfitSplit"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\r\n            for (i = currentIteration; i < users.length; i++) {\r\n                if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }\r\n                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n                if (i == users.length-1) {\r\n                    assetThaw();\r\n                    balances[selfAddress] = balances[selfAddress] - actualProfitSplit;\r\n\t\t\t\t\thasICORun = true;\r\n                }\r\n                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty);\r\n            }\r\n        }"
          ForStatement
             Source: "for (i = currentIteration; i < users.length; i++) {\r\n                if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }\r\n                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n                if (i == users.length-1) {\r\n                    assetThaw();\r\n                    balances[selfAddress] = balances[selfAddress] - actualProfitSplit;\r\n\t\t\t\t\thasICORun = true;\r\n                }\r\n                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty);\r\n            }"
            ExpressionStatement
               Gas costs: 208
               Source: "i = currentIteration"
              Assignment using operator =
                 Type: uint256
                 Source: "i = currentIteration"
                Identifier i
                   Type: uint256
                   Source: "i"
                Identifier currentIteration
                   Type: uint256
                   Source: "currentIteration"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 217
               Source: "i < users.length"
              Identifier i
                 Type: uint256
                 Source: "i"
              MemberAccess to member length
                 Type: uint256
                 Source: "users.length"
                Identifier users
                   Type: address[] storage ref
                   Source: "users"
            ExpressionStatement
               Gas costs: 19
               Source: "i++"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "i++"
                Identifier i
                   Type: uint256
                   Source: "i"
            Block
               Source: "{\r\n                if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }\r\n                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\r\n                if (i == users.length-1) {\r\n                    assetThaw();\r\n                    balances[selfAddress] = balances[selfAddress] - actualProfitSplit;\r\n\t\t\t\t\thasICORun = true;\r\n                }\r\n                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty);\r\n            }"
              IfStatement
                 Source: "if (msg.gas < 240000) {\r\n                    currentIteration = i;\r\n                    break;\r\n                }"
                BinaryOperation using operator <
                   Type: bool
                   Gas costs: 8
                   Source: "msg.gas < 240000"
                  MemberAccess to member gas
                     Type: uint256
                     Source: "msg.gas"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Literal, token: [no token] value: 240000
                     Type: int_const 240000
                     Source: "240000"
                Block
                   Source: "{\r\n                    currentIteration = i;\r\n                    break;\r\n                }"
                  ExpressionStatement
                     Gas costs: 20014
                     Source: "currentIteration = i"
                    Assignment using operator =
                       Type: uint256
                       Source: "currentIteration = i"
                      Identifier currentIteration
                         Type: uint256
                         Source: "currentIteration"
                      Identifier i
                         Type: uint256
                         Source: "i"
                  Break
                     Gas costs: 0
                     Source: "break"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation"
                Assignment using operator +=
                   Type: uint256
                   Source: "balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation"
                  IndexAccess
                     Type: uint256
                     Source: "balances[users[i]]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    IndexAccess
                       Type: address
                       Source: "users[i]"
                      Identifier users
                         Type: address[] storage ref
                         Source: "users"
                      Identifier i
                         Type: uint256
                         Source: "i"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "(balances[users[i]]*currentProfits)/amountInCirculation"
                    TupleExpression
                       Type: uint256
                       Source: "(balances[users[i]]*currentProfits)"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "balances[users[i]]*currentProfits"
                        IndexAccess
                           Type: uint256
                           Source: "balances[users[i]]"
                          Identifier balances
                             Type: mapping(address => uint256)
                             Source: "balances"
                          IndexAccess
                             Type: address
                             Source: "users[i]"
                            Identifier users
                               Type: address[] storage ref
                               Source: "users"
                            Identifier i
                               Type: uint256
                               Source: "i"
                        Identifier currentProfits
                           Type: uint256
                           Source: "currentProfits"
                    Identifier amountInCirculation
                       Type: uint256
                       Source: "amountInCirculation"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "actualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation"
                Assignment using operator +=
                   Type: uint256
                   Source: "actualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation"
                  Identifier actualProfitSplit
                     Type: uint256
                     Source: "actualProfitSplit"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "(balances[users[i]]*currentProfits)/amountInCirculation"
                    TupleExpression
                       Type: uint256
                       Source: "(balances[users[i]]*currentProfits)"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "balances[users[i]]*currentProfits"
                        IndexAccess
                           Type: uint256
                           Source: "balances[users[i]]"
                          Identifier balances
                             Type: mapping(address => uint256)
                             Source: "balances"
                          IndexAccess
                             Type: address
                             Source: "users[i]"
                            Identifier users
                               Type: address[] storage ref
                               Source: "users"
                            Identifier i
                               Type: uint256
                               Source: "i"
                        Identifier currentProfits
                           Type: uint256
                           Source: "currentProfits"
                    Identifier amountInCirculation
                       Type: uint256
                       Source: "amountInCirculation"
              IfStatement
                 Source: "if (i == users.length-1) {\r\n                    assetThaw();\r\n                    balances[selfAddress] = balances[selfAddress] - actualProfitSplit;\r\n\t\t\t\t\thasICORun = true;\r\n                }"
                BinaryOperation using operator ==
                   Type: bool
                   Gas costs: 223
                   Source: "i == users.length-1"
                  Identifier i
                     Type: uint256
                     Source: "i"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "users.length-1"
                    MemberAccess to member length
                       Type: uint256
                       Source: "users.length"
                      Identifier users
                         Type: address[] storage ref
                         Source: "users"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
                Block
                   Source: "{\r\n                    assetThaw();\r\n                    balances[selfAddress] = balances[selfAddress] - actualProfitSplit;\r\n\t\t\t\t\thasICORun = true;\r\n                }"
                  ExpressionStatement
                     Gas costs: 4
                     Source: "assetThaw()"
                    FunctionCall
                       Type: tuple()
                       Source: "assetThaw()"
                      Identifier assetThaw
                         Type: function ()
                         Source: "assetThaw"
                  ExpressionStatement
                     Gas costs: 21078
                     Source: "balances[selfAddress] = balances[selfAddress] - actualProfitSplit"
                    Assignment using operator =
                       Type: uint256
                       Source: "balances[selfAddress] = balances[selfAddress] - actualProfitSplit"
                      IndexAccess
                         Type: uint256
                         Source: "balances[selfAddress]"
                        Identifier balances
                           Type: mapping(address => uint256)
                           Source: "balances"
                        Identifier selfAddress
                           Type: address
                           Source: "selfAddress"
                      BinaryOperation using operator -
                         Type: uint256
                         Source: "balances[selfAddress] - actualProfitSplit"
                        IndexAccess
                           Type: uint256
                           Source: "balances[selfAddress]"
                          Identifier balances
                             Type: mapping(address => uint256)
                             Source: "balances"
                          Identifier selfAddress
                             Type: address
                             Source: "selfAddress"
                        Identifier actualProfitSplit
                           Type: uint256
                           Source: "actualProfitSplit"
                  ExpressionStatement
                     Gas costs: 20317
                     Source: "hasICORun = true"
                    Assignment using operator =
                       Type: bool
                       Source: "hasICORun = true"
                      Identifier hasICORun
                         Type: bool
                         Source: "hasICORun"
                      Literal, token: true value: true
                         Type: bool
                         Source: "true"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty)"
                FunctionCall
                   Type: tuple()
                   Source: "Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits, empty)"
                  Identifier Transfer
                     Type: function (address,address,uint256,bytes memory)
                     Source: "Transfer"
                  Identifier selfAddress
                     Type: address
                     Source: "selfAddress"
                  IndexAccess
                     Type: address
                     Source: "users[i]"
                    Identifier users
                       Type: address[] storage ref
                       Source: "users"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "(balances[users[i]]/amountInCirculation)*currentProfits"
                    TupleExpression
                       Type: uint256
                       Source: "(balances[users[i]]/amountInCirculation)"
                      BinaryOperation using operator /
                         Type: uint256
                         Source: "balances[users[i]]/amountInCirculation"
                        IndexAccess
                           Type: uint256
                           Source: "balances[users[i]]"
                          Identifier balances
                             Type: mapping(address => uint256)
                             Source: "balances"
                          IndexAccess
                             Type: address
                             Source: "users[i]"
                            Identifier users
                               Type: address[] storage ref
                               Source: "users"
                            Identifier i
                               Type: uint256
                               Source: "i"
                        Identifier amountInCirculation
                           Type: uint256
                           Source: "amountInCirculation"
                    Identifier currentProfits
                       Type: uint256
                       Source: "currentProfits"
                  Identifier empty
                     Type: bytes memory
                     Source: "empty"
  FunctionDefinition "assureDAppIsReady" - public
     Source: "function assureDAppIsReady() external {\r\n        if (msg.sender == 0x166Cb48973C2447dafFA8EFd3526da18076088de) {\r\n            devApprovals[0] = true;\r\n        } else if (msg.sender == 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d) {\r\n            devApprovals[1] = true;\r\n        } else if (msg.sender == 0xEC5a48d6F11F8a981aa3D913DA0A69194280cDBc) {\r\n            devApprovals[2] = true;\r\n        } else if (msg.sender == 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF) {\r\n            devApprovals[3] = true;\r\n        } else {\r\n\t\t\trevert();\r\n\t\t}\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (msg.sender == 0x166Cb48973C2447dafFA8EFd3526da18076088de) {\r\n            devApprovals[0] = true;\r\n        } else if (msg.sender == 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d) {\r\n            devApprovals[1] = true;\r\n        } else if (msg.sender == 0xEC5a48d6F11F8a981aa3D913DA0A69194280cDBc) {\r\n            devApprovals[2] = true;\r\n        } else if (msg.sender == 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF) {\r\n            devApprovals[3] = true;\r\n        } else {\r\n\t\t\trevert();\r\n\t\t}\r\n    }"
      IfStatement
         Source: "if (msg.sender == 0x166Cb48973C2447dafFA8EFd3526da18076088de) {\r\n            devApprovals[0] = true;\r\n        } else if (msg.sender == 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d) {\r\n            devApprovals[1] = true;\r\n        } else if (msg.sender == 0xEC5a48d6F11F8a981aa3D913DA0A69194280cDBc) {\r\n            devApprovals[2] = true;\r\n        } else if (msg.sender == 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF) {\r\n            devApprovals[3] = true;\r\n        } else {\r\n\t\t\trevert();\r\n\t\t}"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 20
           Source: "msg.sender == 0x166Cb48973C2447dafFA8EFd3526da18076088de"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0x166Cb48973C2447dafFA8EFd3526da18076088de
             Type: address
             Source: "0x166Cb48973C2447dafFA8EFd3526da18076088de"
        Block
           Source: "{\r\n            devApprovals[0] = true;\r\n        }"
          ExpressionStatement
             Gas costs: 21927
             Source: "devApprovals[0] = true"
            Assignment using operator =
               Type: bool
               Source: "devApprovals[0] = true"
              IndexAccess
                 Type: bool
                 Source: "devApprovals[0]"
                Identifier devApprovals
                   Type: bool[4] storage ref
                   Source: "devApprovals"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
        IfStatement
           Source: "if (msg.sender == 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d) {\r\n            devApprovals[1] = true;\r\n        } else if (msg.sender == 0xEC5a48d6F11F8a981aa3D913DA0A69194280cDBc) {\r\n            devApprovals[2] = true;\r\n        } else if (msg.sender == 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF) {\r\n            devApprovals[3] = true;\r\n        } else {\r\n\t\t\trevert();\r\n\t\t}"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 20
             Source: "msg.sender == 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d
               Type: address
               Source: "0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d"
          Block
             Source: "{\r\n            devApprovals[1] = true;\r\n        }"
            ExpressionStatement
               Gas costs: 21927
               Source: "devApprovals[1] = true"
              Assignment using operator =
                 Type: bool
                 Source: "devApprovals[1] = true"
                IndexAccess
                   Type: bool
                   Source: "devApprovals[1]"
                  Identifier devApprovals
                     Type: bool[4] storage ref
                     Source: "devApprovals"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
                Literal, token: true value: true
                   Type: bool
                   Source: "true"
          IfStatement
             Source: "if (msg.sender == 0xEC5a48d6F11F8a981aa3D913DA0A69194280cDBc) {\r\n            devApprovals[2] = true;\r\n        } else if (msg.sender == 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF) {\r\n            devApprovals[3] = true;\r\n        } else {\r\n\t\t\trevert();\r\n\t\t}"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 20
               Source: "msg.sender == 0xEC5a48d6F11F8a981aa3D913DA0A69194280cDBc"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Literal, token: [no token] value: 0xEC5a48d6F11F8a981aa3D913DA0A69194280cDBc
                 Type: address
                 Source: "0xEC5a48d6F11F8a981aa3D913DA0A69194280cDBc"
            Block
               Source: "{\r\n            devApprovals[2] = true;\r\n        }"
              ExpressionStatement
                 Gas costs: 21927
                 Source: "devApprovals[2] = true"
                Assignment using operator =
                   Type: bool
                   Source: "devApprovals[2] = true"
                  IndexAccess
                     Type: bool
                     Source: "devApprovals[2]"
                    Identifier devApprovals
                       Type: bool[4] storage ref
                       Source: "devApprovals"
                    Literal, token: [no token] value: 2
                       Type: int_const 2
                       Source: "2"
                  Literal, token: true value: true
                     Type: bool
                     Source: "true"
            IfStatement
               Source: "if (msg.sender == 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF) {\r\n            devApprovals[3] = true;\r\n        } else {\r\n\t\t\trevert();\r\n\t\t}"
              BinaryOperation using operator ==
                 Type: bool
                 Gas costs: 20
                 Source: "msg.sender == 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Literal, token: [no token] value: 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF
                   Type: address
                   Source: "0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF"
              Block
                 Source: "{\r\n            devApprovals[3] = true;\r\n        }"
                ExpressionStatement
                   Gas costs: 21927
                   Source: "devApprovals[3] = true"
                  Assignment using operator =
                     Type: bool
                     Source: "devApprovals[3] = true"
                    IndexAccess
                       Type: bool
                       Source: "devApprovals[3]"
                      Identifier devApprovals
                         Type: bool[4] storage ref
                         Source: "devApprovals"
                      Literal, token: [no token] value: 3
                         Type: int_const 3
                         Source: "3"
                    Literal, token: true value: true
                       Type: bool
                       Source: "true"
              Block
                 Source: "{\r\n\t\t\trevert();\r\n\t\t}"
                ExpressionStatement
                   Gas costs: 6
                   Source: "revert()"
                  FunctionCall
                     Type: tuple()
                     Source: "revert()"
                    Identifier revert
                       Type: function () pure
                       Source: "revert"
  FunctionDefinition "isDAppReady" - public
     Source: "function isDAppReady() external isAdmin {\r\n        uint8 numOfApprovals = 0;\r\n        for (uint i = 0; i < devApprovals.length; i++) {\r\n            if (devApprovals[i]) {\r\n                numOfApprovals++;\r\n            }\r\n        }\r\n        DAppReady = (numOfApprovals>=2);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "isAdmin"
       Gas costs: 0
       Source: "isAdmin"
      Identifier isAdmin
         Type: modifier ()
         Source: "isAdmin"
    Block
       Source: "{\r\n        uint8 numOfApprovals = 0;\r\n        for (uint i = 0; i < devApprovals.length; i++) {\r\n            if (devApprovals[i]) {\r\n                numOfApprovals++;\r\n            }\r\n        }\r\n        DAppReady = (numOfApprovals>=2);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint8 numOfApprovals = 0"
        VariableDeclaration "numOfApprovals"
           Type: uint8
           Source: "uint8 numOfApprovals"
          ElementaryTypeName uint8
             Source: "uint8"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for (uint i = 0; i < devApprovals.length; i++) {\r\n            if (devApprovals[i]) {\r\n                numOfApprovals++;\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < devApprovals.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "devApprovals.length"
            Identifier devApprovals
               Type: bool[4] storage ref
               Source: "devApprovals"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (devApprovals[i]) {\r\n                numOfApprovals++;\r\n            }\r\n        }"
          IfStatement
             Source: "if (devApprovals[i]) {\r\n                numOfApprovals++;\r\n            }"
            IndexAccess
               Type: bool
               Gas costs: 1899
               Source: "devApprovals[i]"
              Identifier devApprovals
                 Type: bool[4] storage ref
                 Source: "devApprovals"
              Identifier i
                 Type: uint256
                 Source: "i"
            Block
               Source: "{\r\n                numOfApprovals++;\r\n            }"
              ExpressionStatement
                 Gas costs: 19
                 Source: "numOfApprovals++"
                UnaryOperation (postfix) ++
                   Type: uint8
                   Source: "numOfApprovals++"
                  Identifier numOfApprovals
                     Type: uint8
                     Source: "numOfApprovals"
      ExpressionStatement
         Gas costs: 20282
         Source: "DAppReady = (numOfApprovals>=2)"
        Assignment using operator =
           Type: bool
           Source: "DAppReady = (numOfApprovals>=2)"
          Identifier DAppReady
             Type: bool
             Source: "DAppReady"
          TupleExpression
             Type: bool
             Source: "(numOfApprovals>=2)"
            BinaryOperation using operator >=
               Type: bool
               Source: "numOfApprovals>=2"
              Identifier numOfApprovals
                 Type: uint8
                 Source: "numOfApprovals"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
  FunctionDefinition "alterBankBalance" - public
     Source: "function alterBankBalance(address _toAlter, uint256 _amount, bool sign) external DAppOnline isAdmin {\r\n        if (sign && (_amount+allowed[selfAddress][_toAlter]) > allowed[selfAddress][_toAlter]) {\r\n\t\t\tallowed[selfAddress][_toAlter] = _amount + allowed[selfAddress][_toAlter];\r\n\t\t\tApproval(selfAddress, _toAlter, allowed[selfAddress][_toAlter]);\r\n        } else {\r\n            allowed[selfAddress][_toAlter] = safeSub(allowed[selfAddress][_toAlter], _amount);\r\n\t\t\tApproval(selfAddress, _toAlter, allowed[selfAddress][_toAlter]);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _toAlter, uint256 _amount, bool sign)"
      VariableDeclaration "_toAlter"
         Type: address
         Source: "address _toAlter"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "sign"
         Type: bool
         Source: "bool sign"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "DAppOnline"
       Gas costs: 0
       Source: "DAppOnline"
      Identifier DAppOnline
         Type: modifier ()
         Source: "DAppOnline"
    ModifierInvocation "isAdmin"
       Gas costs: 0
       Source: "isAdmin"
      Identifier isAdmin
         Type: modifier ()
         Source: "isAdmin"
    Block
       Source: "{\r\n        if (sign && (_amount+allowed[selfAddress][_toAlter]) > allowed[selfAddress][_toAlter]) {\r\n\t\t\tallowed[selfAddress][_toAlter] = _amount + allowed[selfAddress][_toAlter];\r\n\t\t\tApproval(selfAddress, _toAlter, allowed[selfAddress][_toAlter]);\r\n        } else {\r\n            allowed[selfAddress][_toAlter] = safeSub(allowed[selfAddress][_toAlter], _amount);\r\n\t\t\tApproval(selfAddress, _toAlter, allowed[selfAddress][_toAlter]);\r\n        }\r\n    }"
      IfStatement
         Source: "if (sign && (_amount+allowed[selfAddress][_toAlter]) > allowed[selfAddress][_toAlter]) {\r\n\t\t\tallowed[selfAddress][_toAlter] = _amount + allowed[selfAddress][_toAlter];\r\n\t\t\tApproval(selfAddress, _toAlter, allowed[selfAddress][_toAlter]);\r\n        } else {\r\n            allowed[selfAddress][_toAlter] = safeSub(allowed[selfAddress][_toAlter], _amount);\r\n\t\t\tApproval(selfAddress, _toAlter, allowed[selfAddress][_toAlter]);\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 1278
           Source: "sign && (_amount+allowed[selfAddress][_toAlter]) > allowed[selfAddress][_toAlter]"
          Identifier sign
             Type: bool
             Source: "sign"
          BinaryOperation using operator >
             Type: bool
             Source: "(_amount+allowed[selfAddress][_toAlter]) > allowed[selfAddress][_toAlter]"
            TupleExpression
               Type: uint256
               Source: "(_amount+allowed[selfAddress][_toAlter])"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "_amount+allowed[selfAddress][_toAlter]"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
                IndexAccess
                   Type: uint256
                   Source: "allowed[selfAddress][_toAlter]"
                  IndexAccess
                     Type: mapping(address => uint256)
                     Source: "allowed[selfAddress]"
                    Identifier allowed
                       Type: mapping(address => mapping(address => uint256))
                       Source: "allowed"
                    Identifier selfAddress
                       Type: address
                       Source: "selfAddress"
                  Identifier _toAlter
                     Type: address
                     Source: "_toAlter"
            IndexAccess
               Type: uint256
               Source: "allowed[selfAddress][_toAlter]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[selfAddress]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                Identifier selfAddress
                   Type: address
                   Source: "selfAddress"
              Identifier _toAlter
                 Type: address
                 Source: "_toAlter"
        Block
           Source: "{\r\n\t\t\tallowed[selfAddress][_toAlter] = _amount + allowed[selfAddress][_toAlter];\r\n\t\t\tApproval(selfAddress, _toAlter, allowed[selfAddress][_toAlter]);\r\n        }"
          ExpressionStatement
             Gas costs: 21058
             Source: "allowed[selfAddress][_toAlter] = _amount + allowed[selfAddress][_toAlter]"
            Assignment using operator =
               Type: uint256
               Source: "allowed[selfAddress][_toAlter] = _amount + allowed[selfAddress][_toAlter]"
              IndexAccess
                 Type: uint256
                 Source: "allowed[selfAddress][_toAlter]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[selfAddress]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier selfAddress
                     Type: address
                     Source: "selfAddress"
                Identifier _toAlter
                   Type: address
                   Source: "_toAlter"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "_amount + allowed[selfAddress][_toAlter]"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
                IndexAccess
                   Type: uint256
                   Source: "allowed[selfAddress][_toAlter]"
                  IndexAccess
                     Type: mapping(address => uint256)
                     Source: "allowed[selfAddress]"
                    Identifier allowed
                       Type: mapping(address => mapping(address => uint256))
                       Source: "allowed"
                    Identifier selfAddress
                       Type: address
                       Source: "selfAddress"
                  Identifier _toAlter
                     Type: address
                     Source: "_toAlter"
          ExpressionStatement
             Gas costs: [???]
             Source: "Approval(selfAddress, _toAlter, allowed[selfAddress][_toAlter])"
            FunctionCall
               Type: tuple()
               Source: "Approval(selfAddress, _toAlter, allowed[selfAddress][_toAlter])"
              Identifier Approval
                 Type: function (address,address,uint256)
                 Source: "Approval"
              Identifier selfAddress
                 Type: address
                 Source: "selfAddress"
              Identifier _toAlter
                 Type: address
                 Source: "_toAlter"
              IndexAccess
                 Type: uint256
                 Source: "allowed[selfAddress][_toAlter]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[selfAddress]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier selfAddress
                     Type: address
                     Source: "selfAddress"
                Identifier _toAlter
                   Type: address
                   Source: "_toAlter"
        Block
           Source: "{\r\n            allowed[selfAddress][_toAlter] = safeSub(allowed[selfAddress][_toAlter], _amount);\r\n\t\t\tApproval(selfAddress, _toAlter, allowed[selfAddress][_toAlter]);\r\n        }"
          ExpressionStatement
             Gas costs: 21076
             Source: "allowed[selfAddress][_toAlter] = safeSub(allowed[selfAddress][_toAlter], _amount)"
            Assignment using operator =
               Type: uint256
               Source: "allowed[selfAddress][_toAlter] = safeSub(allowed[selfAddress][_toAlter], _amount)"
              IndexAccess
                 Type: uint256
                 Source: "allowed[selfAddress][_toAlter]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[selfAddress]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier selfAddress
                     Type: address
                     Source: "selfAddress"
                Identifier _toAlter
                   Type: address
                   Source: "_toAlter"
              FunctionCall
                 Type: uint256
                 Source: "safeSub(allowed[selfAddress][_toAlter], _amount)"
                Identifier safeSub
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "safeSub"
                IndexAccess
                   Type: uint256
                   Source: "allowed[selfAddress][_toAlter]"
                  IndexAccess
                     Type: mapping(address => uint256)
                     Source: "allowed[selfAddress]"
                    Identifier allowed
                       Type: mapping(address => mapping(address => uint256))
                       Source: "allowed"
                    Identifier selfAddress
                       Type: address
                       Source: "selfAddress"
                  Identifier _toAlter
                     Type: address
                     Source: "_toAlter"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
          ExpressionStatement
             Gas costs: [???]
             Source: "Approval(selfAddress, _toAlter, allowed[selfAddress][_toAlter])"
            FunctionCall
               Type: tuple()
               Source: "Approval(selfAddress, _toAlter, allowed[selfAddress][_toAlter])"
              Identifier Approval
                 Type: function (address,address,uint256)
                 Source: "Approval"
              Identifier selfAddress
                 Type: address
                 Source: "selfAddress"
              Identifier _toAlter
                 Type: address
                 Source: "_toAlter"
              IndexAccess
                 Type: uint256
                 Source: "allowed[selfAddress][_toAlter]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[selfAddress]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier selfAddress
                     Type: address
                     Source: "selfAddress"
                Identifier _toAlter
                   Type: address
                   Source: "_toAlter"
  FunctionDefinition "loginUser" - public
     Source: "function loginUser(address _user) external DAppOnline isAdmin {\r\n        freezeUser[_user] = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _user)"
      VariableDeclaration "_user"
         Type: address
         Source: "address _user"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "DAppOnline"
       Gas costs: 0
       Source: "DAppOnline"
      Identifier DAppOnline
         Type: modifier ()
         Source: "DAppOnline"
    ModifierInvocation "isAdmin"
       Gas costs: 0
       Source: "isAdmin"
      Identifier isAdmin
         Type: modifier ()
         Source: "isAdmin"
    Block
       Source: "{\r\n        freezeUser[_user] = true;\r\n    }"
      ExpressionStatement
         Gas costs: 20363
         Source: "freezeUser[_user] = true"
        Assignment using operator =
           Type: bool
           Source: "freezeUser[_user] = true"
          IndexAccess
             Type: bool
             Source: "freezeUser[_user]"
            Identifier freezeUser
               Type: mapping(address => bool)
               Source: "freezeUser"
            Identifier _user
               Type: address
               Source: "_user"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "logoutUser" - public
     Source: "function logoutUser(address _user) external DAppOnline isAdmin {\r\n\t\tfreezeUser[_user] = false;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address _user)"
      VariableDeclaration "_user"
         Type: address
         Source: "address _user"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "DAppOnline"
       Gas costs: 0
       Source: "DAppOnline"
      Identifier DAppOnline
         Type: modifier ()
         Source: "DAppOnline"
    ModifierInvocation "isAdmin"
       Gas costs: 0
       Source: "isAdmin"
      Identifier isAdmin
         Type: modifier ()
         Source: "isAdmin"
    Block
       Source: "{\r\n\t\tfreezeUser[_user] = false;\r\n\t}"
      ExpressionStatement
         Gas costs: 20363
         Source: "freezeUser[_user] = false"
        Assignment using operator =
           Type: bool
           Source: "freezeUser[_user] = false"
          IndexAccess
             Type: bool
             Source: "freezeUser[_user]"
            Identifier freezeUser
               Type: mapping(address => bool)
               Source: "freezeUser"
            Identifier _user
               Type: address
               Source: "_user"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "" - public
     Source: "function() payable {\r\n\t\trevert();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\trevert();\r\n    }"
      ExpressionStatement
         Gas costs: 6
         Source: "revert()"
        FunctionCall
           Type: tuple()
           Source: "revert()"
          Identifier revert
             Type: function () pure
             Source: "revert"
  FunctionDefinition "buyTokensForAddress" - public
     Source: "function buyTokensForAddress(address _recipient) external payable {\r\n        totalFunds = totalFunds + msg.value;\r\n        require(msg.value > 0);\r\n\t\trequire(_recipient != admin);\r\n\t\trequire((totalFunds/1 ether)*pricePerEther < 6000000000);\r\n        addUser(_recipient);\r\n        bytes memory empty;\r\n\t\tuint tokenAmount = calculateTokenAmount(msg.value);\r\n\t\tbalances[selfAddress] = balances[selfAddress] - tokenAmount;\r\n\t\tassert(balances[selfAddress] >= 50000000000000);\r\n        balances[_recipient] = balances[_recipient] + tokenAmount;\r\n        Transfer(selfAddress, _recipient, tokenAmount, empty);\r\n        address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de;\r\n        etherTransfer.transfer(msg.value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _recipient)"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        totalFunds = totalFunds + msg.value;\r\n        require(msg.value > 0);\r\n\t\trequire(_recipient != admin);\r\n\t\trequire((totalFunds/1 ether)*pricePerEther < 6000000000);\r\n        addUser(_recipient);\r\n        bytes memory empty;\r\n\t\tuint tokenAmount = calculateTokenAmount(msg.value);\r\n\t\tbalances[selfAddress] = balances[selfAddress] - tokenAmount;\r\n\t\tassert(balances[selfAddress] >= 50000000000000);\r\n        balances[_recipient] = balances[_recipient] + tokenAmount;\r\n        Transfer(selfAddress, _recipient, tokenAmount, empty);\r\n        address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de;\r\n        etherTransfer.transfer(msg.value);\r\n    }"
      ExpressionStatement
         Gas costs: 20219
         Source: "totalFunds = totalFunds + msg.value"
        Assignment using operator =
           Type: uint256
           Source: "totalFunds = totalFunds + msg.value"
          Identifier totalFunds
             Type: uint256
             Source: "totalFunds"
          BinaryOperation using operator +
             Type: uint256
             Source: "totalFunds + msg.value"
            Identifier totalFunds
               Type: uint256
               Source: "totalFunds"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 34
         Source: "require(msg.value > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "msg.value > 0"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 286
         Source: "require(_recipient != admin)"
        FunctionCall
           Type: tuple()
           Source: "require(_recipient != admin)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_recipient != admin"
            Identifier _recipient
               Type: address
               Source: "_recipient"
            Identifier admin
               Type: address
               Source: "admin"
      ExpressionStatement
         Gas costs: 474
         Source: "require((totalFunds/1 ether)*pricePerEther < 6000000000)"
        FunctionCall
           Type: tuple()
           Source: "require((totalFunds/1 ether)*pricePerEther < 6000000000)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "(totalFunds/1 ether)*pricePerEther < 6000000000"
            BinaryOperation using operator *
               Type: uint256
               Source: "(totalFunds/1 ether)*pricePerEther"
              TupleExpression
                 Type: uint256
                 Source: "(totalFunds/1 ether)"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "totalFunds/1 ether"
                  Identifier totalFunds
                     Type: uint256
                     Source: "totalFunds"
                  Literal, token: [no token] value: 1
                     Type: int_const 1000000000000000000
                     Source: "1 ether"
              Identifier pricePerEther
                 Type: uint256
                 Source: "pricePerEther"
            Literal, token: [no token] value: 6000000000
               Type: int_const 6000000000
               Source: "6000000000"
      ExpressionStatement
         Gas costs: 18
         Source: "addUser(_recipient)"
        FunctionCall
           Type: tuple()
           Source: "addUser(_recipient)"
          Identifier addUser
             Type: function (address)
             Source: "addUser"
          Identifier _recipient
             Type: address
             Source: "_recipient"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "bytes memory empty"
        VariableDeclaration "empty"
           Type: bytes memory
           Source: "bytes memory empty"
          ElementaryTypeName bytes
             Source: "bytes"
      VariableDeclarationStatement
         Gas costs: 14
         Source: "uint tokenAmount = calculateTokenAmount(msg.value)"
        VariableDeclaration "tokenAmount"
           Type: uint256
           Source: "uint tokenAmount"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "calculateTokenAmount(msg.value)"
          Identifier calculateTokenAmount
             Type: function (uint256) returns (uint256)
             Source: "calculateTokenAmount"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20878
         Source: "balances[selfAddress] = balances[selfAddress] - tokenAmount"
        Assignment using operator =
           Type: uint256
           Source: "balances[selfAddress] = balances[selfAddress] - tokenAmount"
          IndexAccess
             Type: uint256
             Source: "balances[selfAddress]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier selfAddress
               Type: address
               Source: "selfAddress"
          BinaryOperation using operator -
             Type: uint256
             Source: "balances[selfAddress] - tokenAmount"
            IndexAccess
               Type: uint256
               Source: "balances[selfAddress]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier selfAddress
                 Type: address
                 Source: "selfAddress"
            Identifier tokenAmount
               Type: uint256
               Source: "tokenAmount"
      ExpressionStatement
         Gas costs: 558
         Source: "assert(balances[selfAddress] >= 50000000000000)"
        FunctionCall
           Type: tuple()
           Source: "assert(balances[selfAddress] >= 50000000000000)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[selfAddress] >= 50000000000000"
            IndexAccess
               Type: uint256
               Source: "balances[selfAddress]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier selfAddress
                 Type: address
                 Source: "selfAddress"
            Literal, token: [no token] value: 50000000000000
               Type: int_const 50000000000000
               Source: "50000000000000"
      ExpressionStatement
         Gas costs: 20406
         Source: "balances[_recipient] = balances[_recipient] + tokenAmount"
        Assignment using operator =
           Type: uint256
           Source: "balances[_recipient] = balances[_recipient] + tokenAmount"
          IndexAccess
             Type: uint256
             Source: "balances[_recipient]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _recipient
               Type: address
               Source: "_recipient"
          BinaryOperation using operator +
             Type: uint256
             Source: "balances[_recipient] + tokenAmount"
            IndexAccess
               Type: uint256
               Source: "balances[_recipient]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _recipient
                 Type: address
                 Source: "_recipient"
            Identifier tokenAmount
               Type: uint256
               Source: "tokenAmount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(selfAddress, _recipient, tokenAmount, empty)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(selfAddress, _recipient, tokenAmount, empty)"
          Identifier Transfer
             Type: function (address,address,uint256,bytes memory)
             Source: "Transfer"
          Identifier selfAddress
             Type: address
             Source: "selfAddress"
          Identifier _recipient
             Type: address
             Source: "_recipient"
          Identifier tokenAmount
             Type: uint256
             Source: "tokenAmount"
          Identifier empty
             Type: bytes memory
             Source: "empty"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de"
        VariableDeclaration "etherTransfer"
           Type: address
           Source: "address etherTransfer"
          ElementaryTypeName address
             Source: "address"
        Literal, token: [no token] value: 0x166Cb48973C2447dafFA8EFd3526da18076088de
           Type: address
           Source: "0x166Cb48973C2447dafFA8EFd3526da18076088de"
      ExpressionStatement
         Gas costs: [???]
         Source: "etherTransfer.transfer(msg.value)"
        FunctionCall
           Type: tuple()
           Source: "etherTransfer.transfer(msg.value)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "etherTransfer.transfer"
            Identifier etherTransfer
               Type: address
               Source: "etherTransfer"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "buyTokensForSelf" - public
     Source: "function buyTokensForSelf() external payable {\r\n        totalFunds = totalFunds + msg.value;\r\n\t\taddress etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de;\r\n        require(msg.value > 0);\r\n\t\trequire(msg.sender != etherTransfer);\r\n\t\trequire((totalFunds/1 ether)*pricePerEther < 6000000000);\r\n        addUser(msg.sender);\r\n        bytes memory empty;\r\n\t\tuint tokenAmount = calculateTokenAmount(msg.value);\r\n\t\tbalances[selfAddress] = balances[selfAddress] - tokenAmount;\r\n\t\tassert(balances[selfAddress] >= 50000000000000);\r\n        balances[msg.sender] = balances[msg.sender] + tokenAmount;\r\n        Transfer(selfAddress, msg.sender, tokenAmount, empty);\r\n        etherTransfer.transfer(msg.value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        totalFunds = totalFunds + msg.value;\r\n\t\taddress etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de;\r\n        require(msg.value > 0);\r\n\t\trequire(msg.sender != etherTransfer);\r\n\t\trequire((totalFunds/1 ether)*pricePerEther < 6000000000);\r\n        addUser(msg.sender);\r\n        bytes memory empty;\r\n\t\tuint tokenAmount = calculateTokenAmount(msg.value);\r\n\t\tbalances[selfAddress] = balances[selfAddress] - tokenAmount;\r\n\t\tassert(balances[selfAddress] >= 50000000000000);\r\n        balances[msg.sender] = balances[msg.sender] + tokenAmount;\r\n        Transfer(selfAddress, msg.sender, tokenAmount, empty);\r\n        etherTransfer.transfer(msg.value);\r\n    }"
      ExpressionStatement
         Gas costs: 20219
         Source: "totalFunds = totalFunds + msg.value"
        Assignment using operator =
           Type: uint256
           Source: "totalFunds = totalFunds + msg.value"
          Identifier totalFunds
             Type: uint256
             Source: "totalFunds"
          BinaryOperation using operator +
             Type: uint256
             Source: "totalFunds + msg.value"
            Identifier totalFunds
               Type: uint256
               Source: "totalFunds"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de"
        VariableDeclaration "etherTransfer"
           Type: address
           Source: "address etherTransfer"
          ElementaryTypeName address
             Source: "address"
        Literal, token: [no token] value: 0x166Cb48973C2447dafFA8EFd3526da18076088de
           Type: address
           Source: "0x166Cb48973C2447dafFA8EFd3526da18076088de"
      ExpressionStatement
         Gas costs: 34
         Source: "require(msg.value > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "msg.value > 0"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 49
         Source: "require(msg.sender != etherTransfer)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender != etherTransfer)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "msg.sender != etherTransfer"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier etherTransfer
               Type: address
               Source: "etherTransfer"
      ExpressionStatement
         Gas costs: 474
         Source: "require((totalFunds/1 ether)*pricePerEther < 6000000000)"
        FunctionCall
           Type: tuple()
           Source: "require((totalFunds/1 ether)*pricePerEther < 6000000000)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "(totalFunds/1 ether)*pricePerEther < 6000000000"
            BinaryOperation using operator *
               Type: uint256
               Source: "(totalFunds/1 ether)*pricePerEther"
              TupleExpression
                 Type: uint256
                 Source: "(totalFunds/1 ether)"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "totalFunds/1 ether"
                  Identifier totalFunds
                     Type: uint256
                     Source: "totalFunds"
                  Literal, token: [no token] value: 1
                     Type: int_const 1000000000000000000
                     Source: "1 ether"
              Identifier pricePerEther
                 Type: uint256
                 Source: "pricePerEther"
            Literal, token: [no token] value: 6000000000
               Type: int_const 6000000000
               Source: "6000000000"
      ExpressionStatement
         Gas costs: 17
         Source: "addUser(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "addUser(msg.sender)"
          Identifier addUser
             Type: function (address)
             Source: "addUser"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "bytes memory empty"
        VariableDeclaration "empty"
           Type: bytes memory
           Source: "bytes memory empty"
          ElementaryTypeName bytes
             Source: "bytes"
      VariableDeclarationStatement
         Gas costs: 25
         Source: "uint tokenAmount = calculateTokenAmount(msg.value)"
        VariableDeclaration "tokenAmount"
           Type: uint256
           Source: "uint tokenAmount"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "calculateTokenAmount(msg.value)"
          Identifier calculateTokenAmount
             Type: function (uint256) returns (uint256)
             Source: "calculateTokenAmount"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20878
         Source: "balances[selfAddress] = balances[selfAddress] - tokenAmount"
        Assignment using operator =
           Type: uint256
           Source: "balances[selfAddress] = balances[selfAddress] - tokenAmount"
          IndexAccess
             Type: uint256
             Source: "balances[selfAddress]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier selfAddress
               Type: address
               Source: "selfAddress"
          BinaryOperation using operator -
             Type: uint256
             Source: "balances[selfAddress] - tokenAmount"
            IndexAccess
               Type: uint256
               Source: "balances[selfAddress]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier selfAddress
                 Type: address
                 Source: "selfAddress"
            Identifier tokenAmount
               Type: uint256
               Source: "tokenAmount"
      ExpressionStatement
         Gas costs: 558
         Source: "assert(balances[selfAddress] >= 50000000000000)"
        FunctionCall
           Type: tuple()
           Source: "assert(balances[selfAddress] >= 50000000000000)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[selfAddress] >= 50000000000000"
            IndexAccess
               Type: uint256
               Source: "balances[selfAddress]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier selfAddress
                 Type: address
                 Source: "selfAddress"
            Literal, token: [no token] value: 50000000000000
               Type: int_const 50000000000000
               Source: "50000000000000"
      ExpressionStatement
         Gas costs: 20404
         Source: "balances[msg.sender] = balances[msg.sender] + tokenAmount"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = balances[msg.sender] + tokenAmount"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          BinaryOperation using operator +
             Type: uint256
             Source: "balances[msg.sender] + tokenAmount"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier tokenAmount
               Type: uint256
               Source: "tokenAmount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(selfAddress, msg.sender, tokenAmount, empty)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(selfAddress, msg.sender, tokenAmount, empty)"
          Identifier Transfer
             Type: function (address,address,uint256,bytes memory)
             Source: "Transfer"
          Identifier selfAddress
             Type: address
             Source: "selfAddress"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier tokenAmount
             Type: uint256
             Source: "tokenAmount"
          Identifier empty
             Type: bytes memory
             Source: "empty"
      ExpressionStatement
         Gas costs: [???]
         Source: "etherTransfer.transfer(msg.value)"
        FunctionCall
           Type: tuple()
           Source: "etherTransfer.transfer(msg.value)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "etherTransfer.transfer"
            Identifier etherTransfer
               Type: address
               Source: "etherTransfer"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
