Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x31b88320c5f5a45813d4a6f96f1d292c4f4383a2.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "ERC20Token"
   Gas costs: 0
   Source: "contract ERC20Token {\r\n\tfunction totalSupply() constant returns (uint supply);\r\n\r\n\t/// @param _owner The address from which the balance will be retrieved\r\n\t/// @return The balance\r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n\t/// @notice send `_value` token to `_to` from `msg.sender`\r\n\t/// @param _to The address of the recipient\r\n\t/// @param _value The amount of token to be transferred\r\n\t/// @return Whether the transfer was successful or not\r\n\tfunction transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n\t/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n\t/// @param _from The address of the sender\r\n\t/// @param _to The address of the recipient\r\n\t/// @param _value The amount of token to be transferred\r\n\t/// @return Whether the transfer was successful or not\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n\t/// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n\t/// @param _spender The address of the account able to transfer the tokens\r\n\t/// @param _value The amount of tokens to be approved for transfer\r\n\t/// @return Whether the approval was successful or not\r\n\tfunction approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n\t/// @param _owner The address of the account owning tokens\r\n\t/// @param _spender The address of the account able to transfer the tokens\r\n\t/// @return Amount of remaining tokens allowed to spent\r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() constant returns (uint supply);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint supply)"
      VariableDeclaration "supply"
         Type: uint256
         Source: "uint supply"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "TokenController"
   Gas costs: 0
   Source: "contract TokenController {\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) payable returns(bool);\r\n\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) returns(bool);\r\n\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount)\r\n        returns(bool);\r\n}"
  FunctionDefinition "proxyPayment" - public
     Source: "function proxyPayment(address _owner) payable returns(bool);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "onTransfer" - public
     Source: "function onTransfer(address _from, address _to, uint _amount) returns(bool);"
    ParameterList
       Source: "(address _from, address _to, uint _amount)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "onApprove" - public
     Source: "function onApprove(address _owner, address _spender, uint _amount)\r\n        returns(bool);"
    ParameterList
       Source: "(address _owner, address _spender, uint _amount)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
ContractDefinition "Controlled"
   Source: "contract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController { if (msg.sender != controller) throw; _; }\r\n\r\n    address public controller;\r\n\r\n    function Controlled() { controller = msg.sender;}\r\n\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) onlyController {\r\n        controller = _newController;\r\n    }\r\n}"
  ModifierDefinition "onlyController"
     Source: "modifier onlyController { if (msg.sender != controller) throw; _; }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ if (msg.sender != controller) throw; _; }"
      IfStatement
         Source: "if (msg.sender != controller) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 518
           Source: "msg.sender != controller"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier controller
             Type: address
             Source: "controller"
        Throw
           Gas costs: 12
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  VariableDeclaration "controller"
     Type: address
     Gas costs: [???]
     Source: "address public controller"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "Controlled" - public
     Source: "function Controlled() { controller = msg.sender;}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ controller = msg.sender;}"
      ExpressionStatement
         Gas costs: 0
         Source: "controller = msg.sender"
        Assignment using operator =
           Type: address
           Source: "controller = msg.sender"
          Identifier controller
             Type: address
             Source: "controller"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "changeController" - public
     Source: "function changeController(address _newController) onlyController {\r\n        controller = _newController;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _newController)"
      VariableDeclaration "_newController"
         Type: address
         Source: "address _newController"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        controller = _newController;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "controller = _newController"
        Assignment using operator =
           Type: address
           Source: "controller = _newController"
          Identifier controller
             Type: address
             Source: "controller"
          Identifier _newController
             Type: address
             Source: "_newController"
ContractDefinition "ApproveAndCallFallBack"
   Gas costs: 0
   Source: "contract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data);\r\n}"
  FunctionDefinition "receiveApproval" - public
     Source: "function receiveApproval(address from, uint256 _amount, address _token, bytes _data);"
    ParameterList
       Source: "(address from, uint256 _amount, address _token, bytes _data)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: ""
ContractDefinition "MiniMeToken"
   Source: "contract MiniMeToken is Controlled, ERC20Token {\r\n\r\n    string public name;                //The Token's name: e.g. DigixDAO Tokens\r\n    uint8 public decimals;             //Number of decimals of the smallest unit\r\n    string public symbol;              //An identifier: e.g. REP\r\n    string public version = 'MMT_0.1'; //An arbitrary versioning scheme\r\n\r\n    /// @dev `Checkpoint` is the structure that attaches a block number to a\r\n    ///  given value, the block number attached is the one that last changed the\r\n    ///  value\r\n    struct  Checkpoint {\r\n\r\n        // `fromBlock` is the block number that the value was generated from\r\n        uint128 fromBlock;\r\n\r\n        // `value` is the amount of tokens at a specific block number\r\n        uint128 value;\r\n    }\r\n\r\n    // `parentToken` is the Token address that was cloned to produce this token;\r\n    //  it will be 0x0 for a token that was not cloned\r\n    MiniMeToken public parentToken;\r\n\r\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\r\n    //  used to determine the initial distribution of the Clone Token\r\n    uint public parentSnapShotBlock;\r\n\r\n    // `creationBlock` is the block number that the Clone Token was created\r\n    uint public creationBlock;\r\n\r\n    // `balances` is the map that tracks the balance of each address, in this\r\n    //  contract when the balance changes the block number that the change\r\n    //  occurred is also included in the map\r\n    mapping (address => Checkpoint[]) balances;\r\n\r\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    // Tracks the history of the `totalSupply` of the token\r\n    Checkpoint[] totalSupplyHistory;\r\n\r\n    // Flag that determines if the token is transferable or not.\r\n    bool public transfersEnabled;\r\n\r\n    // The factory used to create new clone tokens\r\n    MiniMeTokenFactory public tokenFactory;\r\n\r\n////////////////\r\n// Constructor\r\n////////////////\r\n\r\n    /// @notice Constructor to create a MiniMeToken\r\n    /// @param _tokenFactory The address of the MiniMeTokenFactory contract that\r\n    ///  will create the Clone token contracts, the token factory needs to be\r\n    ///  deployed first\r\n    /// @param _parentToken Address of the parent token, set to 0x0 if it is a\r\n    ///  new token\r\n    /// @param _parentSnapShotBlock Block of the parent token that will\r\n    ///  determine the initial distribution of the clone token, set to 0 if it\r\n    ///  is a new token\r\n    /// @param _tokenName Name of the new token\r\n    /// @param _decimalUnits Number of decimals of the new token\r\n    /// @param _tokenSymbol Token Symbol for the new token\r\n    /// @param _transfersEnabled If true, tokens will be able to be transferred\r\n    function MiniMeToken(\r\n        address _tokenFactory,\r\n        address _parentToken,\r\n        uint _parentSnapShotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) {\r\n        tokenFactory = MiniMeTokenFactory(_tokenFactory);\r\n        name = _tokenName;                                 // Set the name\r\n        decimals = _decimalUnits;                          // Set the decimals\r\n        symbol = _tokenSymbol;                             // Set the symbol\r\n        parentToken = MiniMeToken(_parentToken);\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\n        transfersEnabled = _transfersEnabled;\r\n        creationBlock = block.number;\r\n    }\r\n\r\n\r\n///////////////////\r\n// ERC20 Methods\r\n///////////////////\r\n\r\n\t/**\r\n\t*\r\n\t* Fix for the ERC20 short address attack\r\n\t*\r\n\t* http://vessenes.com/the-erc20-short-address-attack-explained/\r\n\t*/\r\n\tmodifier onlyPayloadSize(uint size) {\r\n\t\tif(msg.data.length != size + 4) {\r\n\t\tthrow;\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/// @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n\t/// @param _to The address of the recipient\r\n\t/// @param _amount The amount of tokens to be transferred\r\n\t/// @return Whether the transfer was successful or not\r\n\tfunction transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) returns (bool success) {\r\n\t\tif (!transfersEnabled) throw;\r\n\t\treturn doTransfer(msg.sender, _to, _amount);\r\n    }\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    ///  is approved by `_from`\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(address _from, address _to, uint256 _amount\r\n    ) returns (bool success) {\r\n\r\n        // The controller of this contract can move tokens around at will,\r\n        //  this is important to recognize! Confirm that you trust the\r\n        //  controller of this contract, which in most situations should be\r\n        //  another open source smart contract or 0x0\r\n        if (msg.sender != controller) {\r\n            if (!transfersEnabled) throw;\r\n\r\n            // The standard ERC 20 transferFrom functionality\r\n            if (allowed[_from][msg.sender] < _amount) return false;\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        return doTransfer(_from, _to, _amount);\r\n    }\r\n\r\n    /// @dev This is the actual transfer function in the token contract, it can\r\n    ///  only be called by other functions in this contract.\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function doTransfer(address _from, address _to, uint _amount\r\n    ) internal returns(bool) {\r\n\r\n           if (_amount == 0) {\r\n               return true;\r\n           }\r\n\r\n           if (parentSnapShotBlock >= block.number) throw;\r\n\r\n           // Do not allow transfer to 0x0 or the token contract itself\r\n           if ((_to == 0) || (_to == address(this))) throw;\r\n\r\n           // If the amount being transfered is more than the balance of the\r\n           //  account the transfer returns false\r\n           var previousBalanceFrom = balanceOfAt(_from, block.number);\r\n           if (previousBalanceFrom < _amount) {\r\n               return false;\r\n           }\r\n\r\n           // Alerts the token controller of the transfer\r\n           if (isContract(controller)) {\r\n               if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\n               throw;\r\n           }\r\n\r\n           // First update the balance array with the new value for the address\r\n           //  sending the tokens\r\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n\r\n           // Then update the balance array with the new value for the address\r\n           //  receiving the tokens\r\n           var previousBalanceTo = balanceOfAt(_to, block.number);\r\n           if (previousBalanceTo + _amount < previousBalanceTo) throw; // Check for overflow\r\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n\r\n           // An event to make the transfer easy to find on the blockchain\r\n           Transfer(_from, _to, _amount);\r\n\r\n           return true;\r\n    }\r\n\r\n    /// @param _owner The address that's balance is being requested\r\n    /// @return The balance of `_owner` at the current block\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  to be a little bit safer\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        if (!transfersEnabled) throw;\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        if ((_amount!=0) && (allowed[msg.sender][_spender] !=0)) throw;\r\n\r\n        // Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\r\n                throw;\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to read the `allowed[]` map\r\n    /// @param _owner The address of the account that owns the token\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    ///  to spend\r\n    function allowance(address _owner, address _spender\r\n    ) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `_spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param _spender The address of the contract able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\n    ) returns (bool success) {\r\n        if (!approve(_spender, _amount)) throw;\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply() constant returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n\r\n\r\n////////////////\r\n// Query balance and totalSupply in History\r\n////////////////\r\n\r\n    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @param _blockNumber The block number when the balance is queried\r\n    /// @return The balance at `_blockNumber`\r\n    function balanceOfAt(address _owner, uint _blockNumber) constant\r\n        returns (uint) {\r\n\r\n        // These next few lines are used when the balance of the token is\r\n        //  requested before a check point was ever created for this token, it\r\n        //  requires that the `parentToken.balanceOfAt` be queried at the\r\n        //  genesis block for that token as this contains initial balance of\r\n        //  this token\r\n        if ((balances[_owner].length == 0)\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                // Has no parent\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected balance during normal situations\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    /// @notice Total amount of tokens at a specific `_blockNumber`.\r\n    /// @param _blockNumber The block number when the totalSupply is queried\r\n    /// @return The total amount of tokens at `_blockNumber`\r\n    function totalSupplyAt(uint _blockNumber) constant returns(uint) {\r\n\r\n        // These next few lines are used when the totalSupply of the token is\r\n        //  requested before a check point was ever created for this token, it\r\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\r\n        //  genesis block for this token as that contains totalSupply of this\r\n        //  token at this block number.\r\n        if ((totalSupplyHistory.length == 0)\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n////////////////\r\n// Clone Token Method\r\n////////////////\r\n\r\n    /// @notice Creates a new clone token with the initial distribution being\r\n    ///  this token at `_snapshotBlock`\r\n    /// @param _cloneTokenName Name of the clone token\r\n    /// @param _cloneDecimalUnits Number of decimals of the smallest unit\r\n    /// @param _cloneTokenSymbol Symbol of the clone token\r\n    /// @param _snapshotBlock Block when the distribution of the parent token is\r\n    ///  copied to set the initial distribution of the new clone token;\r\n    ///  if the block is zero than the actual block, the current block is used\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    /// @return The address of the new MiniMeToken Contract\r\n    function createCloneToken(\r\n        string _cloneTokenName,\r\n        uint8 _cloneDecimalUnits,\r\n        string _cloneTokenSymbol,\r\n        uint _snapshotBlock,\r\n        bool _transfersEnabled\r\n        ) onlyController returns(address) {\r\n        if (_snapshotBlock == 0) _snapshotBlock = block.number;\r\n        MiniMeToken cloneToken = tokenFactory.createCloneToken(\r\n            this,\r\n            _snapshotBlock,\r\n            _cloneTokenName,\r\n            _cloneDecimalUnits,\r\n            _cloneTokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        cloneToken.changeController(msg.sender);\r\n\r\n        // An event to make the token easy to find on the blockchain\r\n        NewCloneToken(address(cloneToken), _snapshotBlock);\r\n        return address(cloneToken);\r\n    }\r\n\r\n////////////////\r\n// Generate and destroy tokens\r\n////////////////\r\n\r\n    /// @notice Generates `_amount` tokens that are assigned to `_owner`\r\n    /// @param _owner The address that will be assigned the new tokens\r\n    /// @param _amount The quantity of tokens generated\r\n    /// @return True if the tokens are generated correctly\r\n    function generateTokens(address _owner, uint _amount) onlyController returns (bool) {\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n        if (curTotalSupply + _amount < curTotalSupply) throw; // Check for overflow\r\n\t\t\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\n        var previousBalanceTo = balanceOf(_owner);\r\n        if (previousBalanceTo + _amount < previousBalanceTo) throw; // Check for overflow\r\n\t\t\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @notice Burns `_amount` tokens from `_owner`\r\n    /// @param _owner The address that will lose the tokens\r\n    /// @param _amount The quantity of tokens to burn\r\n    /// @return True if the tokens are burned correctly\r\n    function destroyTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n        if (curTotalSupply < _amount) throw;\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        var previousBalanceFrom = balanceOf(_owner);\r\n        if (previousBalanceFrom < _amount) throw;\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }\r\n\r\n////////////////\r\n// Enable tokens transfers\r\n////////////////\r\n\r\n\r\n    /// @notice Enables token holders to transfer their tokens freely if true\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    function enableTransfers(bool _transfersEnabled) onlyController {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n////////////////\r\n// Internal helper functions to query and set a value in a snapshot array\r\n////////////////\r\n\r\n    /// @dev `getValueAt` retrieves the number of tokens at a given block number\r\n    /// @param checkpoints The history of values being queried\r\n    /// @param _block The block number to retrieve the value at\r\n    /// @return The number of tokens being queried\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block\r\n    ) constant internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        // Shortcut for the actual value\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n\r\n        // Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    /// @dev `updateValueAtNow` used to update the `balances` map and the\r\n    ///  `totalSupplyHistory`\r\n    /// @param checkpoints The history of data being updated\r\n    /// @param _value The new number of tokens\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\r\n    ) internal  {\r\n        if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               Checkpoint newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n           } else {\r\n               Checkpoint oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }\r\n    }\r\n\r\n    /// @dev Internal function to determine if an address is a contract\r\n    /// @param _addr The address being queried\r\n    /// @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    /// @dev Helper function to return a min betwen the two uints\r\n    function min(uint a, uint b) internal returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /// @notice The fallback function: If the contract's controller has not been\r\n    ///  set to 0, then the `proxyPayment` method is called which relays the\r\n    ///  ether and creates tokens as described in the token controller contract\r\n    function ()  payable {\r\n        if (isContract(controller)) {\r\n            if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\r\n                throw;\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n\r\n\t////////////////\r\n\t// Events\r\n\t////////////////\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n\tevent NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _amount);\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Controlled"
    UserDefinedTypeName "Controlled"
       Source: "Controlled"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20Token"
    UserDefinedTypeName "ERC20Token"
       Source: "ERC20Token"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: 0
     Source: "string public name"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: 0
     Source: "uint8 public decimals"
    ElementaryTypeName uint8
       Source: "uint8"
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: 0
     Source: "string public symbol"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "version"
     Type: string storage ref
     Gas costs: 0
     Source: "string public version = 'MMT_0.1'"
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: MMT_0.1
       Type: literal_string "MMT_0.1"
       Source: "'MMT_0.1'"
  StructDefinition "Checkpoint"
     Gas costs: 0
     Source: "struct  Checkpoint {\r\n\r\n        // `fromBlock` is the block number that the value was generated from\r\n        uint128 fromBlock;\r\n\r\n        // `value` is the amount of tokens at a specific block number\r\n        uint128 value;\r\n    }"
    VariableDeclaration "fromBlock"
       Type: uint128
       Source: "uint128 fromBlock"
      ElementaryTypeName uint128
         Source: "uint128"
    VariableDeclaration "value"
       Type: uint128
       Source: "uint128 value"
      ElementaryTypeName uint128
         Source: "uint128"
  VariableDeclaration "parentToken"
     Type: contract MiniMeToken
     Gas costs: 0
     Source: "MiniMeToken public parentToken"
    UserDefinedTypeName "MiniMeToken"
       Source: "MiniMeToken"
  VariableDeclaration "parentSnapShotBlock"
     Type: uint256
     Gas costs: 0
     Source: "uint public parentSnapShotBlock"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "creationBlock"
     Type: uint256
     Gas costs: 0
     Source: "uint public creationBlock"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "balances"
     Type: mapping(address => struct MiniMeToken.Checkpoint storage ref[] storage ref)
     Gas costs: 0
     Source: "mapping (address => Checkpoint[]) balances"
    Mapping
       Source: "mapping (address => Checkpoint[])"
      ElementaryTypeName address
         Source: "address"
      ArrayTypeName
         Source: "Checkpoint[]"
        UserDefinedTypeName "Checkpoint"
           Source: "Checkpoint"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "totalSupplyHistory"
     Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
     Gas costs: 0
     Source: "Checkpoint[] totalSupplyHistory"
    ArrayTypeName
       Source: "Checkpoint[]"
      UserDefinedTypeName "Checkpoint"
         Source: "Checkpoint"
  VariableDeclaration "transfersEnabled"
     Type: bool
     Gas costs: 0
     Source: "bool public transfersEnabled"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "tokenFactory"
     Type: contract MiniMeTokenFactory
     Gas costs: 0
     Source: "MiniMeTokenFactory public tokenFactory"
    UserDefinedTypeName "MiniMeTokenFactory"
       Source: "MiniMeTokenFactory"
  FunctionDefinition "MiniMeToken" - public
     Source: "function MiniMeToken(\r\n        address _tokenFactory,\r\n        address _parentToken,\r\n        uint _parentSnapShotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) {\r\n        tokenFactory = MiniMeTokenFactory(_tokenFactory);\r\n        name = _tokenName;                                 // Set the name\r\n        decimals = _decimalUnits;                          // Set the decimals\r\n        symbol = _tokenSymbol;                             // Set the symbol\r\n        parentToken = MiniMeToken(_parentToken);\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\n        transfersEnabled = _transfersEnabled;\r\n        creationBlock = block.number;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _tokenFactory,\r\n        address _parentToken,\r\n        uint _parentSnapShotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    )"
      VariableDeclaration "_tokenFactory"
         Type: address
         Source: "address _tokenFactory"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_parentToken"
         Type: address
         Source: "address _parentToken"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_parentSnapShotBlock"
         Type: uint256
         Source: "uint _parentSnapShotBlock"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_tokenName"
         Type: string memory
         Source: "string _tokenName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_decimalUnits"
         Type: uint8
         Source: "uint8 _decimalUnits"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "_tokenSymbol"
         Type: string memory
         Source: "string _tokenSymbol"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_transfersEnabled"
         Type: bool
         Source: "bool _transfersEnabled"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        tokenFactory = MiniMeTokenFactory(_tokenFactory);\r\n        name = _tokenName;                                 // Set the name\r\n        decimals = _decimalUnits;                          // Set the decimals\r\n        symbol = _tokenSymbol;                             // Set the symbol\r\n        parentToken = MiniMeToken(_parentToken);\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\n        transfersEnabled = _transfersEnabled;\r\n        creationBlock = block.number;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenFactory = MiniMeTokenFactory(_tokenFactory)"
        Assignment using operator =
           Type: contract MiniMeTokenFactory
           Source: "tokenFactory = MiniMeTokenFactory(_tokenFactory)"
          Identifier tokenFactory
             Type: contract MiniMeTokenFactory
             Source: "tokenFactory"
          FunctionCall
             Type: contract MiniMeTokenFactory
             Source: "MiniMeTokenFactory(_tokenFactory)"
            Identifier MiniMeTokenFactory
               Type: type(contract MiniMeTokenFactory)
               Source: "MiniMeTokenFactory"
            Identifier _tokenFactory
               Type: address
               Source: "_tokenFactory"
      ExpressionStatement
         Gas costs: 0
         Source: "name = _tokenName"
        Assignment using operator =
           Type: string storage ref
           Source: "name = _tokenName"
          Identifier name
             Type: string storage ref
             Source: "name"
          Identifier _tokenName
             Type: string memory
             Source: "_tokenName"
      ExpressionStatement
         Gas costs: 0
         Source: "decimals = _decimalUnits"
        Assignment using operator =
           Type: uint8
           Source: "decimals = _decimalUnits"
          Identifier decimals
             Type: uint8
             Source: "decimals"
          Identifier _decimalUnits
             Type: uint8
             Source: "_decimalUnits"
      ExpressionStatement
         Gas costs: 0
         Source: "symbol = _tokenSymbol"
        Assignment using operator =
           Type: string storage ref
           Source: "symbol = _tokenSymbol"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
          Identifier _tokenSymbol
             Type: string memory
             Source: "_tokenSymbol"
      ExpressionStatement
         Gas costs: 0
         Source: "parentToken = MiniMeToken(_parentToken)"
        Assignment using operator =
           Type: contract MiniMeToken
           Source: "parentToken = MiniMeToken(_parentToken)"
          Identifier parentToken
             Type: contract MiniMeToken
             Source: "parentToken"
          FunctionCall
             Type: contract MiniMeToken
             Source: "MiniMeToken(_parentToken)"
            Identifier MiniMeToken
               Type: type(contract MiniMeToken)
               Source: "MiniMeToken"
            Identifier _parentToken
               Type: address
               Source: "_parentToken"
      ExpressionStatement
         Gas costs: 0
         Source: "parentSnapShotBlock = _parentSnapShotBlock"
        Assignment using operator =
           Type: uint256
           Source: "parentSnapShotBlock = _parentSnapShotBlock"
          Identifier parentSnapShotBlock
             Type: uint256
             Source: "parentSnapShotBlock"
          Identifier _parentSnapShotBlock
             Type: uint256
             Source: "_parentSnapShotBlock"
      ExpressionStatement
         Gas costs: 0
         Source: "transfersEnabled = _transfersEnabled"
        Assignment using operator =
           Type: bool
           Source: "transfersEnabled = _transfersEnabled"
          Identifier transfersEnabled
             Type: bool
             Source: "transfersEnabled"
          Identifier _transfersEnabled
             Type: bool
             Source: "_transfersEnabled"
      ExpressionStatement
         Gas costs: 0
         Source: "creationBlock = block.number"
        Assignment using operator =
           Type: uint256
           Source: "creationBlock = block.number"
          Identifier creationBlock
             Type: uint256
             Source: "creationBlock"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
  ModifierDefinition "onlyPayloadSize"
     Source: "modifier onlyPayloadSize(uint size) {\r\n\t\tif(msg.data.length != size + 4) {\r\n\t\tthrow;\r\n\t\t}\r\n\t\t_;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint size)"
      VariableDeclaration "size"
         Type: uint256
         Source: "uint size"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\t\tif(msg.data.length != size + 4) {\r\n\t\tthrow;\r\n\t\t}\r\n\t\t_;\r\n\t}"
      IfStatement
         Source: "if(msg.data.length != size + 4) {\r\n\t\tthrow;\r\n\t\t}"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "msg.data.length != size + 4"
          MemberAccess to member length
             Type: uint256
             Source: "msg.data.length"
            MemberAccess to member data
               Type: bytes calldata
               Source: "msg.data"
              Identifier msg
                 Type: msg
                 Source: "msg"
          BinaryOperation using operator +
             Type: uint256
             Source: "size + 4"
            Identifier size
               Type: uint256
               Source: "size"
            Literal, token: [no token] value: 4
               Type: int_const 4
               Source: "4"
        Block
           Source: "{\r\n\t\tthrow;\r\n\t\t}"
          Throw
             Gas costs: 0
             Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) returns (bool success) {\r\n\t\tif (!transfersEnabled) throw;\r\n\t\treturn doTransfer(msg.sender, _to, _amount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _amount)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 0
       Source: "onlyPayloadSize(2 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 64
         Source: "2 * 32"
        Literal, token: [no token] value: 2
           Type: int_const 2
           Source: "2"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n\t\tif (!transfersEnabled) throw;\r\n\t\treturn doTransfer(msg.sender, _to, _amount);\r\n    }"
      IfStatement
         Source: "if (!transfersEnabled) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 0
           Source: "!transfersEnabled"
          Identifier transfersEnabled
             Type: bool
             Source: "transfersEnabled"
        Throw
           Gas costs: 0
           Source: "throw"
      Return
         Gas costs: 0
         Source: "return doTransfer(msg.sender, _to, _amount)"
        FunctionCall
           Type: bool
           Source: "doTransfer(msg.sender, _to, _amount)"
          Identifier doTransfer
             Type: function (address,address,uint256) returns (bool)
             Source: "doTransfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _amount\r\n    ) returns (bool success) {\r\n\r\n        // The controller of this contract can move tokens around at will,\r\n        //  this is important to recognize! Confirm that you trust the\r\n        //  controller of this contract, which in most situations should be\r\n        //  another open source smart contract or 0x0\r\n        if (msg.sender != controller) {\r\n            if (!transfersEnabled) throw;\r\n\r\n            // The standard ERC 20 transferFrom functionality\r\n            if (allowed[_from][msg.sender] < _amount) return false;\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        return doTransfer(_from, _to, _amount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _amount\r\n    )"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n        // The controller of this contract can move tokens around at will,\r\n        //  this is important to recognize! Confirm that you trust the\r\n        //  controller of this contract, which in most situations should be\r\n        //  another open source smart contract or 0x0\r\n        if (msg.sender != controller) {\r\n            if (!transfersEnabled) throw;\r\n\r\n            // The standard ERC 20 transferFrom functionality\r\n            if (allowed[_from][msg.sender] < _amount) return false;\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        return doTransfer(_from, _to, _amount);\r\n    }"
      IfStatement
         Source: "if (msg.sender != controller) {\r\n            if (!transfersEnabled) throw;\r\n\r\n            // The standard ERC 20 transferFrom functionality\r\n            if (allowed[_from][msg.sender] < _amount) return false;\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "msg.sender != controller"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier controller
             Type: address
             Source: "controller"
        Block
           Source: "{\r\n            if (!transfersEnabled) throw;\r\n\r\n            // The standard ERC 20 transferFrom functionality\r\n            if (allowed[_from][msg.sender] < _amount) return false;\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }"
          IfStatement
             Source: "if (!transfersEnabled) throw"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: 0
               Source: "!transfersEnabled"
              Identifier transfersEnabled
                 Type: bool
                 Source: "transfersEnabled"
            Throw
               Gas costs: 0
               Source: "throw"
          IfStatement
             Source: "if (allowed[_from][msg.sender] < _amount) return false"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 0
               Source: "allowed[_from][msg.sender] < _amount"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
            Return
               Gas costs: 0
               Source: "return false"
              Literal, token: false value: false
                 Type: bool
                 Source: "false"
          ExpressionStatement
             Gas costs: 0
             Source: "allowed[_from][msg.sender] -= _amount"
            Assignment using operator -=
               Type: uint256
               Source: "allowed[_from][msg.sender] -= _amount"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
      Return
         Gas costs: 0
         Source: "return doTransfer(_from, _to, _amount)"
        FunctionCall
           Type: bool
           Source: "doTransfer(_from, _to, _amount)"
          Identifier doTransfer
             Type: function (address,address,uint256) returns (bool)
             Source: "doTransfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
  FunctionDefinition "doTransfer"
     Source: "function doTransfer(address _from, address _to, uint _amount\r\n    ) internal returns(bool) {\r\n\r\n           if (_amount == 0) {\r\n               return true;\r\n           }\r\n\r\n           if (parentSnapShotBlock >= block.number) throw;\r\n\r\n           // Do not allow transfer to 0x0 or the token contract itself\r\n           if ((_to == 0) || (_to == address(this))) throw;\r\n\r\n           // If the amount being transfered is more than the balance of the\r\n           //  account the transfer returns false\r\n           var previousBalanceFrom = balanceOfAt(_from, block.number);\r\n           if (previousBalanceFrom < _amount) {\r\n               return false;\r\n           }\r\n\r\n           // Alerts the token controller of the transfer\r\n           if (isContract(controller)) {\r\n               if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\n               throw;\r\n           }\r\n\r\n           // First update the balance array with the new value for the address\r\n           //  sending the tokens\r\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n\r\n           // Then update the balance array with the new value for the address\r\n           //  receiving the tokens\r\n           var previousBalanceTo = balanceOfAt(_to, block.number);\r\n           if (previousBalanceTo + _amount < previousBalanceTo) throw; // Check for overflow\r\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n\r\n           // An event to make the transfer easy to find on the blockchain\r\n           Transfer(_from, _to, _amount);\r\n\r\n           return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _amount\r\n    )"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n           if (_amount == 0) {\r\n               return true;\r\n           }\r\n\r\n           if (parentSnapShotBlock >= block.number) throw;\r\n\r\n           // Do not allow transfer to 0x0 or the token contract itself\r\n           if ((_to == 0) || (_to == address(this))) throw;\r\n\r\n           // If the amount being transfered is more than the balance of the\r\n           //  account the transfer returns false\r\n           var previousBalanceFrom = balanceOfAt(_from, block.number);\r\n           if (previousBalanceFrom < _amount) {\r\n               return false;\r\n           }\r\n\r\n           // Alerts the token controller of the transfer\r\n           if (isContract(controller)) {\r\n               if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\n               throw;\r\n           }\r\n\r\n           // First update the balance array with the new value for the address\r\n           //  sending the tokens\r\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n\r\n           // Then update the balance array with the new value for the address\r\n           //  receiving the tokens\r\n           var previousBalanceTo = balanceOfAt(_to, block.number);\r\n           if (previousBalanceTo + _amount < previousBalanceTo) throw; // Check for overflow\r\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n\r\n           // An event to make the transfer easy to find on the blockchain\r\n           Transfer(_from, _to, _amount);\r\n\r\n           return true;\r\n    }"
      IfStatement
         Source: "if (_amount == 0) {\r\n               return true;\r\n           }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "_amount == 0"
          Identifier _amount
             Type: uint256
             Source: "_amount"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n               return true;\r\n           }"
          Return
             Gas costs: 0
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      IfStatement
         Source: "if (parentSnapShotBlock >= block.number) throw"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 0
           Source: "parentSnapShotBlock >= block.number"
          Identifier parentSnapShotBlock
             Type: uint256
             Source: "parentSnapShotBlock"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if ((_to == 0) || (_to == address(this))) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 0
           Source: "(_to == 0) || (_to == address(this))"
          TupleExpression
             Type: bool
             Source: "(_to == 0)"
            BinaryOperation using operator ==
               Type: bool
               Source: "_to == 0"
              Identifier _to
                 Type: address
                 Source: "_to"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          TupleExpression
             Type: bool
             Source: "(_to == address(this))"
            BinaryOperation using operator ==
               Type: bool
               Source: "_to == address(this)"
              Identifier _to
                 Type: address
                 Source: "_to"
              FunctionCall
                 Type: address
                 Source: "address(this)"
                ElementaryTypeNameExpression address
                   Type: type(address)
                   Source: "address"
                Identifier this
                   Type: contract MiniMeToken
                   Source: "this"
        Throw
           Gas costs: 0
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "var previousBalanceFrom = balanceOfAt(_from, block.number)"
        VariableDeclaration "previousBalanceFrom"
           Type: uint256
           Source: "var previousBalanceFrom"
        FunctionCall
           Type: uint256
           Source: "balanceOfAt(_from, block.number)"
          Identifier balanceOfAt
             Type: function (address,uint256) view returns (uint256)
             Source: "balanceOfAt"
          Identifier _from
             Type: address
             Source: "_from"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
      IfStatement
         Source: "if (previousBalanceFrom < _amount) {\r\n               return false;\r\n           }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "previousBalanceFrom < _amount"
          Identifier previousBalanceFrom
             Type: uint256
             Source: "previousBalanceFrom"
          Identifier _amount
             Type: uint256
             Source: "_amount"
        Block
           Source: "{\r\n               return false;\r\n           }"
          Return
             Gas costs: 0
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      IfStatement
         Source: "if (isContract(controller)) {\r\n               if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\n               throw;\r\n           }"
        FunctionCall
           Type: bool
           Gas costs: 0
           Source: "isContract(controller)"
          Identifier isContract
             Type: function (address) view returns (bool)
             Source: "isContract"
          Identifier controller
             Type: address
             Source: "controller"
        Block
           Source: "{\r\n               if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\n               throw;\r\n           }"
          IfStatement
             Source: "if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\n               throw"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: 0
               Source: "!TokenController(controller).onTransfer(_from, _to, _amount)"
              FunctionCall
                 Type: bool
                 Source: "TokenController(controller).onTransfer(_from, _to, _amount)"
                MemberAccess to member onTransfer
                   Type: function (address,address,uint256) external returns (bool)
                   Source: "TokenController(controller).onTransfer"
                  FunctionCall
                     Type: contract TokenController
                     Source: "TokenController(controller)"
                    Identifier TokenController
                       Type: type(contract TokenController)
                       Source: "TokenController"
                    Identifier controller
                       Type: address
                       Source: "controller"
                Identifier _from
                   Type: address
                   Source: "_from"
                Identifier _to
                   Type: address
                   Source: "_to"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
            Throw
               Gas costs: 0
               Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "updateValueAtNow(balances[_from], previousBalanceFrom - _amount)"
        FunctionCall
           Type: tuple()
           Source: "updateValueAtNow(balances[_from], previousBalanceFrom - _amount)"
          Identifier updateValueAtNow
             Type: function (struct MiniMeToken.Checkpoint storage ref[] storage pointer,uint256)
             Source: "updateValueAtNow"
          IndexAccess
             Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => struct MiniMeToken.Checkpoint storage ref[] storage ref)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          BinaryOperation using operator -
             Type: uint256
             Source: "previousBalanceFrom - _amount"
            Identifier previousBalanceFrom
               Type: uint256
               Source: "previousBalanceFrom"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "var previousBalanceTo = balanceOfAt(_to, block.number)"
        VariableDeclaration "previousBalanceTo"
           Type: uint256
           Source: "var previousBalanceTo"
        FunctionCall
           Type: uint256
           Source: "balanceOfAt(_to, block.number)"
          Identifier balanceOfAt
             Type: function (address,uint256) view returns (uint256)
             Source: "balanceOfAt"
          Identifier _to
             Type: address
             Source: "_to"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
      IfStatement
         Source: "if (previousBalanceTo + _amount < previousBalanceTo) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "previousBalanceTo + _amount < previousBalanceTo"
          BinaryOperation using operator +
             Type: uint256
             Source: "previousBalanceTo + _amount"
            Identifier previousBalanceTo
               Type: uint256
               Source: "previousBalanceTo"
            Identifier _amount
               Type: uint256
               Source: "_amount"
          Identifier previousBalanceTo
             Type: uint256
             Source: "previousBalanceTo"
        Throw
           Gas costs: 0
           Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "updateValueAtNow(balances[_to], previousBalanceTo + _amount)"
        FunctionCall
           Type: tuple()
           Source: "updateValueAtNow(balances[_to], previousBalanceTo + _amount)"
          Identifier updateValueAtNow
             Type: function (struct MiniMeToken.Checkpoint storage ref[] storage pointer,uint256)
             Source: "updateValueAtNow"
          IndexAccess
             Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => struct MiniMeToken.Checkpoint storage ref[] storage ref)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          BinaryOperation using operator +
             Type: uint256
             Source: "previousBalanceTo + _amount"
            Identifier previousBalanceTo
               Type: uint256
               Source: "previousBalanceTo"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(_from, _to, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balanceOfAt(_owner, block.number);\r\n    }"
      Return
         Gas costs: 0
         Source: "return balanceOfAt(_owner, block.number)"
        FunctionCall
           Type: uint256
           Source: "balanceOfAt(_owner, block.number)"
          Identifier balanceOfAt
             Type: function (address,uint256) view returns (uint256)
             Source: "balanceOfAt"
          Identifier _owner
             Type: address
             Source: "_owner"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        if (!transfersEnabled) throw;\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        if ((_amount!=0) && (allowed[msg.sender][_spender] !=0)) throw;\r\n\r\n        // Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\r\n                throw;\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _amount)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if (!transfersEnabled) throw;\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        if ((_amount!=0) && (allowed[msg.sender][_spender] !=0)) throw;\r\n\r\n        // Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\r\n                throw;\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (!transfersEnabled) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 0
           Source: "!transfersEnabled"
          Identifier transfersEnabled
             Type: bool
             Source: "transfersEnabled"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if ((_amount!=0) && (allowed[msg.sender][_spender] !=0)) throw"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "(_amount!=0) && (allowed[msg.sender][_spender] !=0)"
          TupleExpression
             Type: bool
             Source: "(_amount!=0)"
            BinaryOperation using operator !=
               Type: bool
               Source: "_amount!=0"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          TupleExpression
             Type: bool
             Source: "(allowed[msg.sender][_spender] !=0)"
            BinaryOperation using operator !=
               Type: bool
               Source: "allowed[msg.sender][_spender] !=0"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (isContract(controller)) {\r\n            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\r\n                throw;\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 0
           Source: "isContract(controller)"
          Identifier isContract
             Type: function (address) view returns (bool)
             Source: "isContract"
          Identifier controller
             Type: address
             Source: "controller"
        Block
           Source: "{\r\n            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\r\n                throw;\r\n        }"
          IfStatement
             Source: "if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\r\n                throw"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: 0
               Source: "!TokenController(controller).onApprove(msg.sender, _spender, _amount)"
              FunctionCall
                 Type: bool
                 Source: "TokenController(controller).onApprove(msg.sender, _spender, _amount)"
                MemberAccess to member onApprove
                   Type: function (address,address,uint256) external returns (bool)
                   Source: "TokenController(controller).onApprove"
                  FunctionCall
                     Type: contract TokenController
                     Source: "TokenController(controller)"
                    Identifier TokenController
                       Type: type(contract TokenController)
                       Source: "TokenController"
                    Identifier controller
                       Type: address
                       Source: "controller"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
            Throw
               Gas costs: 0
               Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[msg.sender][_spender] = _amount"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _amount"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(msg.sender, _spender, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _amount)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender\r\n    ) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender\r\n    )"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 0
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  FunctionDefinition "approveAndCall" - public
     Source: "function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\n    ) returns (bool success) {\r\n        if (!approve(_spender, _amount)) throw;\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _amount, bytes _extraData\r\n    )"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if (!approve(_spender, _amount)) throw;\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (!approve(_spender, _amount)) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 0
           Source: "!approve(_spender, _amount)"
          FunctionCall
             Type: bool
             Source: "approve(_spender, _amount)"
            Identifier approve
               Type: function (address,uint256) returns (bool)
               Source: "approve"
            Identifier _spender
               Type: address
               Source: "_spender"
            Identifier _amount
               Type: uint256
               Source: "_amount"
        Throw
           Gas costs: 0
           Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        )"
          MemberAccess to member receiveApproval
             Type: function (address,uint256,address,bytes memory) external
             Source: "ApproveAndCallFallBack(_spender).receiveApproval"
            FunctionCall
               Type: contract ApproveAndCallFallBack
               Source: "ApproveAndCallFallBack(_spender)"
              Identifier ApproveAndCallFallBack
                 Type: type(contract ApproveAndCallFallBack)
                 Source: "ApproveAndCallFallBack"
              Identifier _spender
                 Type: address
                 Source: "_spender"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _amount
             Type: uint256
             Source: "_amount"
          Identifier this
             Type: contract MiniMeToken
             Source: "this"
          Identifier _extraData
             Type: bytes memory
             Source: "_extraData"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() constant returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return totalSupplyAt(block.number);\r\n    }"
      Return
         Gas costs: 0
         Source: "return totalSupplyAt(block.number)"
        FunctionCall
           Type: uint256
           Source: "totalSupplyAt(block.number)"
          Identifier totalSupplyAt
             Type: function (uint256) view returns (uint256)
             Source: "totalSupplyAt"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
  FunctionDefinition "balanceOfAt" - public - const
     Source: "function balanceOfAt(address _owner, uint _blockNumber) constant\r\n        returns (uint) {\r\n\r\n        // These next few lines are used when the balance of the token is\r\n        //  requested before a check point was ever created for this token, it\r\n        //  requires that the `parentToken.balanceOfAt` be queried at the\r\n        //  genesis block for that token as this contains initial balance of\r\n        //  this token\r\n        if ((balances[_owner].length == 0)\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                // Has no parent\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected balance during normal situations\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, uint _blockNumber)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_blockNumber"
         Type: uint256
         Source: "uint _blockNumber"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        // These next few lines are used when the balance of the token is\r\n        //  requested before a check point was ever created for this token, it\r\n        //  requires that the `parentToken.balanceOfAt` be queried at the\r\n        //  genesis block for that token as this contains initial balance of\r\n        //  this token\r\n        if ((balances[_owner].length == 0)\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                // Has no parent\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected balance during normal situations\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }"
      IfStatement
         Source: "if ((balances[_owner].length == 0)\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                // Has no parent\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected balance during normal situations\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 0
           Source: "(balances[_owner].length == 0)\r\n            || (balances[_owner][0].fromBlock > _blockNumber)"
          TupleExpression
             Type: bool
             Source: "(balances[_owner].length == 0)"
            BinaryOperation using operator ==
               Type: bool
               Source: "balances[_owner].length == 0"
              MemberAccess to member length
                 Type: uint256
                 Source: "balances[_owner].length"
                IndexAccess
                   Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
                   Source: "balances[_owner]"
                  Identifier balances
                     Type: mapping(address => struct MiniMeToken.Checkpoint storage ref[] storage ref)
                     Source: "balances"
                  Identifier _owner
                     Type: address
                     Source: "_owner"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          TupleExpression
             Type: bool
             Source: "(balances[_owner][0].fromBlock > _blockNumber)"
            BinaryOperation using operator >
               Type: bool
               Source: "balances[_owner][0].fromBlock > _blockNumber"
              MemberAccess to member fromBlock
                 Type: uint128
                 Source: "balances[_owner][0].fromBlock"
                IndexAccess
                   Type: struct MiniMeToken.Checkpoint storage ref
                   Source: "balances[_owner][0]"
                  IndexAccess
                     Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
                     Source: "balances[_owner]"
                    Identifier balances
                       Type: mapping(address => struct MiniMeToken.Checkpoint storage ref[] storage ref)
                       Source: "balances"
                    Identifier _owner
                       Type: address
                       Source: "_owner"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              Identifier _blockNumber
                 Type: uint256
                 Source: "_blockNumber"
        Block
           Source: "{\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                // Has no parent\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected balance during normal situations\r\n        }"
          IfStatement
             Source: "if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                // Has no parent\r\n                return 0;\r\n            }"
            BinaryOperation using operator !=
               Type: bool
               Gas costs: 0
               Source: "address(parentToken) != 0"
              FunctionCall
                 Type: address
                 Source: "address(parentToken)"
                ElementaryTypeNameExpression address
                   Type: type(address)
                   Source: "address"
                Identifier parentToken
                   Type: contract MiniMeToken
                   Source: "parentToken"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            }"
              Return
                 Gas costs: 0
                 Source: "return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock))"
                FunctionCall
                   Type: uint256
                   Source: "parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock))"
                  MemberAccess to member balanceOfAt
                     Type: function (address,uint256) view external returns (uint256)
                     Source: "parentToken.balanceOfAt"
                    Identifier parentToken
                       Type: contract MiniMeToken
                       Source: "parentToken"
                  Identifier _owner
                     Type: address
                     Source: "_owner"
                  FunctionCall
                     Type: uint256
                     Source: "min(_blockNumber, parentSnapShotBlock)"
                    Identifier min
                       Type: function (uint256,uint256) returns (uint256)
                       Source: "min"
                    Identifier _blockNumber
                       Type: uint256
                       Source: "_blockNumber"
                    Identifier parentSnapShotBlock
                       Type: uint256
                       Source: "parentSnapShotBlock"
            Block
               Source: "{\r\n                // Has no parent\r\n                return 0;\r\n            }"
              Return
                 Gas costs: 0
                 Source: "return 0"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
        Block
           Source: "{\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }"
          Return
             Gas costs: 0
             Source: "return getValueAt(balances[_owner], _blockNumber)"
            FunctionCall
               Type: uint256
               Source: "getValueAt(balances[_owner], _blockNumber)"
              Identifier getValueAt
                 Type: function (struct MiniMeToken.Checkpoint storage ref[] storage pointer,uint256) view returns (uint256)
                 Source: "getValueAt"
              IndexAccess
                 Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
                 Source: "balances[_owner]"
                Identifier balances
                   Type: mapping(address => struct MiniMeToken.Checkpoint storage ref[] storage ref)
                   Source: "balances"
                Identifier _owner
                   Type: address
                   Source: "_owner"
              Identifier _blockNumber
                 Type: uint256
                 Source: "_blockNumber"
  FunctionDefinition "totalSupplyAt" - public - const
     Source: "function totalSupplyAt(uint _blockNumber) constant returns(uint) {\r\n\r\n        // These next few lines are used when the totalSupply of the token is\r\n        //  requested before a check point was ever created for this token, it\r\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\r\n        //  genesis block for this token as that contains totalSupply of this\r\n        //  token at this block number.\r\n        if ((totalSupplyHistory.length == 0)\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _blockNumber)"
      VariableDeclaration "_blockNumber"
         Type: uint256
         Source: "uint _blockNumber"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        // These next few lines are used when the totalSupply of the token is\r\n        //  requested before a check point was ever created for this token, it\r\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\r\n        //  genesis block for this token as that contains totalSupply of this\r\n        //  token at this block number.\r\n        if ((totalSupplyHistory.length == 0)\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }"
      IfStatement
         Source: "if ((totalSupplyHistory.length == 0)\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 0
           Source: "(totalSupplyHistory.length == 0)\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)"
          TupleExpression
             Type: bool
             Source: "(totalSupplyHistory.length == 0)"
            BinaryOperation using operator ==
               Type: bool
               Source: "totalSupplyHistory.length == 0"
              MemberAccess to member length
                 Type: uint256
                 Source: "totalSupplyHistory.length"
                Identifier totalSupplyHistory
                   Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
                   Source: "totalSupplyHistory"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          TupleExpression
             Type: bool
             Source: "(totalSupplyHistory[0].fromBlock > _blockNumber)"
            BinaryOperation using operator >
               Type: bool
               Source: "totalSupplyHistory[0].fromBlock > _blockNumber"
              MemberAccess to member fromBlock
                 Type: uint128
                 Source: "totalSupplyHistory[0].fromBlock"
                IndexAccess
                   Type: struct MiniMeToken.Checkpoint storage ref
                   Source: "totalSupplyHistory[0]"
                  Identifier totalSupplyHistory
                     Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
                     Source: "totalSupplyHistory"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              Identifier _blockNumber
                 Type: uint256
                 Source: "_blockNumber"
        Block
           Source: "{\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected totalSupply during normal situations\r\n        }"
          IfStatement
             Source: "if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }"
            BinaryOperation using operator !=
               Type: bool
               Gas costs: 0
               Source: "address(parentToken) != 0"
              FunctionCall
                 Type: address
                 Source: "address(parentToken)"
                ElementaryTypeNameExpression address
                   Type: type(address)
                   Source: "address"
                Identifier parentToken
                   Type: contract MiniMeToken
                   Source: "parentToken"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            }"
              Return
                 Gas costs: 0
                 Source: "return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock))"
                FunctionCall
                   Type: uint256
                   Source: "parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock))"
                  MemberAccess to member totalSupplyAt
                     Type: function (uint256) view external returns (uint256)
                     Source: "parentToken.totalSupplyAt"
                    Identifier parentToken
                       Type: contract MiniMeToken
                       Source: "parentToken"
                  FunctionCall
                     Type: uint256
                     Source: "min(_blockNumber, parentSnapShotBlock)"
                    Identifier min
                       Type: function (uint256,uint256) returns (uint256)
                       Source: "min"
                    Identifier _blockNumber
                       Type: uint256
                       Source: "_blockNumber"
                    Identifier parentSnapShotBlock
                       Type: uint256
                       Source: "parentSnapShotBlock"
            Block
               Source: "{\r\n                return 0;\r\n            }"
              Return
                 Gas costs: 0
                 Source: "return 0"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
        Block
           Source: "{\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }"
          Return
             Gas costs: 0
             Source: "return getValueAt(totalSupplyHistory, _blockNumber)"
            FunctionCall
               Type: uint256
               Source: "getValueAt(totalSupplyHistory, _blockNumber)"
              Identifier getValueAt
                 Type: function (struct MiniMeToken.Checkpoint storage ref[] storage pointer,uint256) view returns (uint256)
                 Source: "getValueAt"
              Identifier totalSupplyHistory
                 Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
                 Source: "totalSupplyHistory"
              Identifier _blockNumber
                 Type: uint256
                 Source: "_blockNumber"
  FunctionDefinition "createCloneToken" - public
     Source: "function createCloneToken(\r\n        string _cloneTokenName,\r\n        uint8 _cloneDecimalUnits,\r\n        string _cloneTokenSymbol,\r\n        uint _snapshotBlock,\r\n        bool _transfersEnabled\r\n        ) onlyController returns(address) {\r\n        if (_snapshotBlock == 0) _snapshotBlock = block.number;\r\n        MiniMeToken cloneToken = tokenFactory.createCloneToken(\r\n            this,\r\n            _snapshotBlock,\r\n            _cloneTokenName,\r\n            _cloneDecimalUnits,\r\n            _cloneTokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        cloneToken.changeController(msg.sender);\r\n\r\n        // An event to make the token easy to find on the blockchain\r\n        NewCloneToken(address(cloneToken), _snapshotBlock);\r\n        return address(cloneToken);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        string _cloneTokenName,\r\n        uint8 _cloneDecimalUnits,\r\n        string _cloneTokenSymbol,\r\n        uint _snapshotBlock,\r\n        bool _transfersEnabled\r\n        )"
      VariableDeclaration "_cloneTokenName"
         Type: string memory
         Source: "string _cloneTokenName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_cloneDecimalUnits"
         Type: uint8
         Source: "uint8 _cloneDecimalUnits"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "_cloneTokenSymbol"
         Type: string memory
         Source: "string _cloneTokenSymbol"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_snapshotBlock"
         Type: uint256
         Source: "uint _snapshotBlock"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_transfersEnabled"
         Type: bool
         Source: "bool _transfersEnabled"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        if (_snapshotBlock == 0) _snapshotBlock = block.number;\r\n        MiniMeToken cloneToken = tokenFactory.createCloneToken(\r\n            this,\r\n            _snapshotBlock,\r\n            _cloneTokenName,\r\n            _cloneDecimalUnits,\r\n            _cloneTokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        cloneToken.changeController(msg.sender);\r\n\r\n        // An event to make the token easy to find on the blockchain\r\n        NewCloneToken(address(cloneToken), _snapshotBlock);\r\n        return address(cloneToken);\r\n    }"
      IfStatement
         Source: "if (_snapshotBlock == 0) _snapshotBlock = block.number"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "_snapshotBlock == 0"
          Identifier _snapshotBlock
             Type: uint256
             Source: "_snapshotBlock"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 0
           Source: "_snapshotBlock = block.number"
          Assignment using operator =
             Type: uint256
             Source: "_snapshotBlock = block.number"
            Identifier _snapshotBlock
               Type: uint256
               Source: "_snapshotBlock"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "MiniMeToken cloneToken = tokenFactory.createCloneToken(\r\n            this,\r\n            _snapshotBlock,\r\n            _cloneTokenName,\r\n            _cloneDecimalUnits,\r\n            _cloneTokenSymbol,\r\n            _transfersEnabled\r\n            )"
        VariableDeclaration "cloneToken"
           Type: contract MiniMeToken
           Source: "MiniMeToken cloneToken"
          UserDefinedTypeName "MiniMeToken"
             Source: "MiniMeToken"
        FunctionCall
           Type: contract MiniMeToken
           Source: "tokenFactory.createCloneToken(\r\n            this,\r\n            _snapshotBlock,\r\n            _cloneTokenName,\r\n            _cloneDecimalUnits,\r\n            _cloneTokenSymbol,\r\n            _transfersEnabled\r\n            )"
          MemberAccess to member createCloneToken
             Type: function (address,uint256,string memory,uint8,string memory,bool) external returns (contract MiniMeToken)
             Source: "tokenFactory.createCloneToken"
            Identifier tokenFactory
               Type: contract MiniMeTokenFactory
               Source: "tokenFactory"
          Identifier this
             Type: contract MiniMeToken
             Source: "this"
          Identifier _snapshotBlock
             Type: uint256
             Source: "_snapshotBlock"
          Identifier _cloneTokenName
             Type: string memory
             Source: "_cloneTokenName"
          Identifier _cloneDecimalUnits
             Type: uint8
             Source: "_cloneDecimalUnits"
          Identifier _cloneTokenSymbol
             Type: string memory
             Source: "_cloneTokenSymbol"
          Identifier _transfersEnabled
             Type: bool
             Source: "_transfersEnabled"
      ExpressionStatement
         Gas costs: 0
         Source: "cloneToken.changeController(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "cloneToken.changeController(msg.sender)"
          MemberAccess to member changeController
             Type: function (address) external
             Source: "cloneToken.changeController"
            Identifier cloneToken
               Type: contract MiniMeToken
               Source: "cloneToken"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "NewCloneToken(address(cloneToken), _snapshotBlock)"
        FunctionCall
           Type: tuple()
           Source: "NewCloneToken(address(cloneToken), _snapshotBlock)"
          Identifier NewCloneToken
             Type: function (address,uint256)
             Source: "NewCloneToken"
          FunctionCall
             Type: address
             Source: "address(cloneToken)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier cloneToken
               Type: contract MiniMeToken
               Source: "cloneToken"
          Identifier _snapshotBlock
             Type: uint256
             Source: "_snapshotBlock"
      Return
         Gas costs: 0
         Source: "return address(cloneToken)"
        FunctionCall
           Type: address
           Source: "address(cloneToken)"
          ElementaryTypeNameExpression address
             Type: type(address)
             Source: "address"
          Identifier cloneToken
             Type: contract MiniMeToken
             Source: "cloneToken"
  FunctionDefinition "generateTokens" - public
     Source: "function generateTokens(address _owner, uint _amount) onlyController returns (bool) {\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n        if (curTotalSupply + _amount < curTotalSupply) throw; // Check for overflow\r\n\t\t\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\n        var previousBalanceTo = balanceOf(_owner);\r\n        if (previousBalanceTo + _amount < previousBalanceTo) throw; // Check for overflow\r\n\t\t\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, uint _amount)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n        if (curTotalSupply + _amount < curTotalSupply) throw; // Check for overflow\r\n\t\t\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\n        var previousBalanceTo = balanceOf(_owner);\r\n        if (previousBalanceTo + _amount < previousBalanceTo) throw; // Check for overflow\r\n\t\t\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint curTotalSupply = getValueAt(totalSupplyHistory, block.number)"
        VariableDeclaration "curTotalSupply"
           Type: uint256
           Source: "uint curTotalSupply"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getValueAt(totalSupplyHistory, block.number)"
          Identifier getValueAt
             Type: function (struct MiniMeToken.Checkpoint storage ref[] storage pointer,uint256) view returns (uint256)
             Source: "getValueAt"
          Identifier totalSupplyHistory
             Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
             Source: "totalSupplyHistory"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
      IfStatement
         Source: "if (curTotalSupply + _amount < curTotalSupply) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "curTotalSupply + _amount < curTotalSupply"
          BinaryOperation using operator +
             Type: uint256
             Source: "curTotalSupply + _amount"
            Identifier curTotalSupply
               Type: uint256
               Source: "curTotalSupply"
            Identifier _amount
               Type: uint256
               Source: "_amount"
          Identifier curTotalSupply
             Type: uint256
             Source: "curTotalSupply"
        Throw
           Gas costs: 0
           Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount)"
        FunctionCall
           Type: tuple()
           Source: "updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount)"
          Identifier updateValueAtNow
             Type: function (struct MiniMeToken.Checkpoint storage ref[] storage pointer,uint256)
             Source: "updateValueAtNow"
          Identifier totalSupplyHistory
             Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
             Source: "totalSupplyHistory"
          BinaryOperation using operator +
             Type: uint256
             Source: "curTotalSupply + _amount"
            Identifier curTotalSupply
               Type: uint256
               Source: "curTotalSupply"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "var previousBalanceTo = balanceOf(_owner)"
        VariableDeclaration "previousBalanceTo"
           Type: uint256
           Source: "var previousBalanceTo"
        FunctionCall
           Type: uint256
           Source: "balanceOf(_owner)"
          Identifier balanceOf
             Type: function (address) view returns (uint256)
             Source: "balanceOf"
          Identifier _owner
             Type: address
             Source: "_owner"
      IfStatement
         Source: "if (previousBalanceTo + _amount < previousBalanceTo) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "previousBalanceTo + _amount < previousBalanceTo"
          BinaryOperation using operator +
             Type: uint256
             Source: "previousBalanceTo + _amount"
            Identifier previousBalanceTo
               Type: uint256
               Source: "previousBalanceTo"
            Identifier _amount
               Type: uint256
               Source: "_amount"
          Identifier previousBalanceTo
             Type: uint256
             Source: "previousBalanceTo"
        Throw
           Gas costs: 0
           Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "updateValueAtNow(balances[_owner], previousBalanceTo + _amount)"
        FunctionCall
           Type: tuple()
           Source: "updateValueAtNow(balances[_owner], previousBalanceTo + _amount)"
          Identifier updateValueAtNow
             Type: function (struct MiniMeToken.Checkpoint storage ref[] storage pointer,uint256)
             Source: "updateValueAtNow"
          IndexAccess
             Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
             Source: "balances[_owner]"
            Identifier balances
               Type: mapping(address => struct MiniMeToken.Checkpoint storage ref[] storage ref)
               Source: "balances"
            Identifier _owner
               Type: address
               Source: "_owner"
          BinaryOperation using operator +
             Type: uint256
             Source: "previousBalanceTo + _amount"
            Identifier previousBalanceTo
               Type: uint256
               Source: "previousBalanceTo"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(0, _owner, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(0, _owner, _amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Identifier _owner
             Type: address
             Source: "_owner"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "destroyTokens" - public
     Source: "function destroyTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n        if (curTotalSupply < _amount) throw;\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        var previousBalanceFrom = balanceOf(_owner);\r\n        if (previousBalanceFrom < _amount) throw;\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, uint _amount\r\n    )"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n        if (curTotalSupply < _amount) throw;\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        var previousBalanceFrom = balanceOf(_owner);\r\n        if (previousBalanceFrom < _amount) throw;\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint curTotalSupply = getValueAt(totalSupplyHistory, block.number)"
        VariableDeclaration "curTotalSupply"
           Type: uint256
           Source: "uint curTotalSupply"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getValueAt(totalSupplyHistory, block.number)"
          Identifier getValueAt
             Type: function (struct MiniMeToken.Checkpoint storage ref[] storage pointer,uint256) view returns (uint256)
             Source: "getValueAt"
          Identifier totalSupplyHistory
             Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
             Source: "totalSupplyHistory"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
      IfStatement
         Source: "if (curTotalSupply < _amount) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "curTotalSupply < _amount"
          Identifier curTotalSupply
             Type: uint256
             Source: "curTotalSupply"
          Identifier _amount
             Type: uint256
             Source: "_amount"
        Throw
           Gas costs: 0
           Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount)"
        FunctionCall
           Type: tuple()
           Source: "updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount)"
          Identifier updateValueAtNow
             Type: function (struct MiniMeToken.Checkpoint storage ref[] storage pointer,uint256)
             Source: "updateValueAtNow"
          Identifier totalSupplyHistory
             Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
             Source: "totalSupplyHistory"
          BinaryOperation using operator -
             Type: uint256
             Source: "curTotalSupply - _amount"
            Identifier curTotalSupply
               Type: uint256
               Source: "curTotalSupply"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "var previousBalanceFrom = balanceOf(_owner)"
        VariableDeclaration "previousBalanceFrom"
           Type: uint256
           Source: "var previousBalanceFrom"
        FunctionCall
           Type: uint256
           Source: "balanceOf(_owner)"
          Identifier balanceOf
             Type: function (address) view returns (uint256)
             Source: "balanceOf"
          Identifier _owner
             Type: address
             Source: "_owner"
      IfStatement
         Source: "if (previousBalanceFrom < _amount) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "previousBalanceFrom < _amount"
          Identifier previousBalanceFrom
             Type: uint256
             Source: "previousBalanceFrom"
          Identifier _amount
             Type: uint256
             Source: "_amount"
        Throw
           Gas costs: 0
           Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "updateValueAtNow(balances[_owner], previousBalanceFrom - _amount)"
        FunctionCall
           Type: tuple()
           Source: "updateValueAtNow(balances[_owner], previousBalanceFrom - _amount)"
          Identifier updateValueAtNow
             Type: function (struct MiniMeToken.Checkpoint storage ref[] storage pointer,uint256)
             Source: "updateValueAtNow"
          IndexAccess
             Type: struct MiniMeToken.Checkpoint storage ref[] storage ref
             Source: "balances[_owner]"
            Identifier balances
               Type: mapping(address => struct MiniMeToken.Checkpoint storage ref[] storage ref)
               Source: "balances"
            Identifier _owner
               Type: address
               Source: "_owner"
          BinaryOperation using operator -
             Type: uint256
             Source: "previousBalanceFrom - _amount"
            Identifier previousBalanceFrom
               Type: uint256
               Source: "previousBalanceFrom"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(_owner, 0, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_owner, 0, _amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _owner
             Type: address
             Source: "_owner"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "enableTransfers" - public
     Source: "function enableTransfers(bool _transfersEnabled) onlyController {\r\n        transfersEnabled = _transfersEnabled;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bool _transfersEnabled)"
      VariableDeclaration "_transfersEnabled"
         Type: bool
         Source: "bool _transfersEnabled"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        transfersEnabled = _transfersEnabled;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "transfersEnabled = _transfersEnabled"
        Assignment using operator =
           Type: bool
           Source: "transfersEnabled = _transfersEnabled"
          Identifier transfersEnabled
             Type: bool
             Source: "transfersEnabled"
          Identifier _transfersEnabled
             Type: bool
             Source: "_transfersEnabled"
  FunctionDefinition "getValueAt" - const
     Source: "function getValueAt(Checkpoint[] storage checkpoints, uint _block\r\n    ) constant internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        // Shortcut for the actual value\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n\r\n        // Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Checkpoint[] storage checkpoints, uint _block\r\n    )"
      VariableDeclaration "checkpoints"
         Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
         Source: "Checkpoint[] storage checkpoints"
        ArrayTypeName
           Source: "Checkpoint[]"
          UserDefinedTypeName "Checkpoint"
             Source: "Checkpoint"
      VariableDeclaration "_block"
         Type: uint256
         Source: "uint _block"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        // Shortcut for the actual value\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n\r\n        // Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }"
      IfStatement
         Source: "if (checkpoints.length == 0) return 0"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "checkpoints.length == 0"
          MemberAccess to member length
             Type: uint256
             Source: "checkpoints.length"
            Identifier checkpoints
               Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
               Source: "checkpoints"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      IfStatement
         Source: "if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 0
           Source: "_block >= checkpoints[checkpoints.length-1].fromBlock"
          Identifier _block
             Type: uint256
             Source: "_block"
          MemberAccess to member fromBlock
             Type: uint128
             Source: "checkpoints[checkpoints.length-1].fromBlock"
            IndexAccess
               Type: struct MiniMeToken.Checkpoint storage ref
               Source: "checkpoints[checkpoints.length-1]"
              Identifier checkpoints
                 Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
                 Source: "checkpoints"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "checkpoints.length-1"
                MemberAccess to member length
                   Type: uint256
                   Source: "checkpoints.length"
                  Identifier checkpoints
                     Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
                     Source: "checkpoints"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
        Return
           Gas costs: 0
           Source: "return checkpoints[checkpoints.length-1].value"
          MemberAccess to member value
             Type: uint128
             Source: "checkpoints[checkpoints.length-1].value"
            IndexAccess
               Type: struct MiniMeToken.Checkpoint storage ref
               Source: "checkpoints[checkpoints.length-1]"
              Identifier checkpoints
                 Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
                 Source: "checkpoints"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "checkpoints.length-1"
                MemberAccess to member length
                   Type: uint256
                   Source: "checkpoints.length"
                  Identifier checkpoints
                     Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
                     Source: "checkpoints"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      IfStatement
         Source: "if (_block < checkpoints[0].fromBlock) return 0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "_block < checkpoints[0].fromBlock"
          Identifier _block
             Type: uint256
             Source: "_block"
          MemberAccess to member fromBlock
             Type: uint128
             Source: "checkpoints[0].fromBlock"
            IndexAccess
               Type: struct MiniMeToken.Checkpoint storage ref
               Source: "checkpoints[0]"
              Identifier checkpoints
                 Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
                 Source: "checkpoints"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint min = 0"
        VariableDeclaration "min"
           Type: uint256
           Source: "uint min"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint max = checkpoints.length-1"
        VariableDeclaration "max"
           Type: uint256
           Source: "uint max"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator -
           Type: uint256
           Source: "checkpoints.length-1"
          MemberAccess to member length
             Type: uint256
             Source: "checkpoints.length"
            Identifier checkpoints
               Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
               Source: "checkpoints"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      WhileStatement
         Source: "while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "max > min"
          Identifier max
             Type: uint256
             Source: "max"
          Identifier min
             Type: uint256
             Source: "min"
        Block
           Source: "{\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "uint mid = (max + min + 1)/ 2"
            VariableDeclaration "mid"
               Type: uint256
               Source: "uint mid"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator /
               Type: uint256
               Source: "(max + min + 1)/ 2"
              TupleExpression
                 Type: uint256
                 Source: "(max + min + 1)"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "max + min + 1"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "max + min"
                    Identifier max
                       Type: uint256
                       Source: "max"
                    Identifier min
                       Type: uint256
                       Source: "min"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
          IfStatement
             Source: "if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }"
            BinaryOperation using operator <=
               Type: bool
               Gas costs: 0
               Source: "checkpoints[mid].fromBlock<=_block"
              MemberAccess to member fromBlock
                 Type: uint128
                 Source: "checkpoints[mid].fromBlock"
                IndexAccess
                   Type: struct MiniMeToken.Checkpoint storage ref
                   Source: "checkpoints[mid]"
                  Identifier checkpoints
                     Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
                     Source: "checkpoints"
                  Identifier mid
                     Type: uint256
                     Source: "mid"
              Identifier _block
                 Type: uint256
                 Source: "_block"
            Block
               Source: "{\r\n                min = mid;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "min = mid"
                Assignment using operator =
                   Type: uint256
                   Source: "min = mid"
                  Identifier min
                     Type: uint256
                     Source: "min"
                  Identifier mid
                     Type: uint256
                     Source: "mid"
            Block
               Source: "{\r\n                max = mid-1;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "max = mid-1"
                Assignment using operator =
                   Type: uint256
                   Source: "max = mid-1"
                  Identifier max
                     Type: uint256
                     Source: "max"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "mid-1"
                    Identifier mid
                       Type: uint256
                       Source: "mid"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
      Return
         Gas costs: 0
         Source: "return checkpoints[min].value"
        MemberAccess to member value
           Type: uint128
           Source: "checkpoints[min].value"
          IndexAccess
             Type: struct MiniMeToken.Checkpoint storage ref
             Source: "checkpoints[min]"
            Identifier checkpoints
               Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
               Source: "checkpoints"
            Identifier min
               Type: uint256
               Source: "min"
  FunctionDefinition "updateValueAtNow"
     Source: "function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\r\n    ) internal  {\r\n        if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               Checkpoint newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n           } else {\r\n               Checkpoint oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Checkpoint[] storage checkpoints, uint _value\r\n    )"
      VariableDeclaration "checkpoints"
         Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
         Source: "Checkpoint[] storage checkpoints"
        ArrayTypeName
           Source: "Checkpoint[]"
          UserDefinedTypeName "Checkpoint"
             Source: "Checkpoint"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               Checkpoint newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n           } else {\r\n               Checkpoint oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }\r\n    }"
      IfStatement
         Source: "if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               Checkpoint newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n           } else {\r\n               Checkpoint oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 0
           Source: "(checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)"
          TupleExpression
             Type: bool
             Source: "(checkpoints.length == 0)"
            BinaryOperation using operator ==
               Type: bool
               Source: "checkpoints.length == 0"
              MemberAccess to member length
                 Type: uint256
                 Source: "checkpoints.length"
                Identifier checkpoints
                   Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
                   Source: "checkpoints"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          TupleExpression
             Type: bool
             Source: "(checkpoints[checkpoints.length -1].fromBlock < block.number)"
            BinaryOperation using operator <
               Type: bool
               Source: "checkpoints[checkpoints.length -1].fromBlock < block.number"
              MemberAccess to member fromBlock
                 Type: uint128
                 Source: "checkpoints[checkpoints.length -1].fromBlock"
                IndexAccess
                   Type: struct MiniMeToken.Checkpoint storage ref
                   Source: "checkpoints[checkpoints.length -1]"
                  Identifier checkpoints
                     Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
                     Source: "checkpoints"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "checkpoints.length -1"
                    MemberAccess to member length
                       Type: uint256
                       Source: "checkpoints.length"
                      Identifier checkpoints
                         Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
                         Source: "checkpoints"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
        Block
           Source: "{\r\n               Checkpoint newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n           }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "Checkpoint newCheckPoint = checkpoints[ checkpoints.length++ ]"
            VariableDeclaration "newCheckPoint"
               Type: struct MiniMeToken.Checkpoint storage pointer
               Source: "Checkpoint newCheckPoint"
              UserDefinedTypeName "Checkpoint"
                 Source: "Checkpoint"
            IndexAccess
               Type: struct MiniMeToken.Checkpoint storage ref
               Source: "checkpoints[ checkpoints.length++ ]"
              Identifier checkpoints
                 Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
                 Source: "checkpoints"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "checkpoints.length++"
                MemberAccess to member length
                   Type: uint256
                   Source: "checkpoints.length"
                  Identifier checkpoints
                     Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
                     Source: "checkpoints"
          ExpressionStatement
             Gas costs: 0
             Source: "newCheckPoint.fromBlock =  uint128(block.number)"
            Assignment using operator =
               Type: uint128
               Source: "newCheckPoint.fromBlock =  uint128(block.number)"
              MemberAccess to member fromBlock
                 Type: uint128
                 Source: "newCheckPoint.fromBlock"
                Identifier newCheckPoint
                   Type: struct MiniMeToken.Checkpoint storage pointer
                   Source: "newCheckPoint"
              FunctionCall
                 Type: uint128
                 Source: "uint128(block.number)"
                ElementaryTypeNameExpression uint128
                   Type: type(uint128)
                   Source: "uint128"
                MemberAccess to member number
                   Type: uint256
                   Source: "block.number"
                  Identifier block
                     Type: block
                     Source: "block"
          ExpressionStatement
             Gas costs: 0
             Source: "newCheckPoint.value = uint128(_value)"
            Assignment using operator =
               Type: uint128
               Source: "newCheckPoint.value = uint128(_value)"
              MemberAccess to member value
                 Type: uint128
                 Source: "newCheckPoint.value"
                Identifier newCheckPoint
                   Type: struct MiniMeToken.Checkpoint storage pointer
                   Source: "newCheckPoint"
              FunctionCall
                 Type: uint128
                 Source: "uint128(_value)"
                ElementaryTypeNameExpression uint128
                   Type: type(uint128)
                   Source: "uint128"
                Identifier _value
                   Type: uint256
                   Source: "_value"
        Block
           Source: "{\r\n               Checkpoint oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "Checkpoint oldCheckPoint = checkpoints[checkpoints.length-1]"
            VariableDeclaration "oldCheckPoint"
               Type: struct MiniMeToken.Checkpoint storage pointer
               Source: "Checkpoint oldCheckPoint"
              UserDefinedTypeName "Checkpoint"
                 Source: "Checkpoint"
            IndexAccess
               Type: struct MiniMeToken.Checkpoint storage ref
               Source: "checkpoints[checkpoints.length-1]"
              Identifier checkpoints
                 Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
                 Source: "checkpoints"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "checkpoints.length-1"
                MemberAccess to member length
                   Type: uint256
                   Source: "checkpoints.length"
                  Identifier checkpoints
                     Type: struct MiniMeToken.Checkpoint storage ref[] storage pointer
                     Source: "checkpoints"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
          ExpressionStatement
             Gas costs: 0
             Source: "oldCheckPoint.value = uint128(_value)"
            Assignment using operator =
               Type: uint128
               Source: "oldCheckPoint.value = uint128(_value)"
              MemberAccess to member value
                 Type: uint128
                 Source: "oldCheckPoint.value"
                Identifier oldCheckPoint
                   Type: struct MiniMeToken.Checkpoint storage pointer
                   Source: "oldCheckPoint"
              FunctionCall
                 Type: uint128
                 Source: "uint128(_value)"
                ElementaryTypeNameExpression uint128
                   Type: type(uint128)
                   Source: "uint128"
                Identifier _value
                   Type: uint256
                   Source: "_value"
  FunctionDefinition "isContract" - const
     Source: "function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _addr)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint size"
        VariableDeclaration "size"
           Type: uint256
           Source: "uint size"
          ElementaryTypeName uint
             Source: "uint"
      IfStatement
         Source: "if (_addr == 0) return false"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "_addr == 0"
          Identifier _addr
             Type: address
             Source: "_addr"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 0
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return"
      Return
         Gas costs: 0
         Source: "return size>0"
        BinaryOperation using operator >
           Type: bool
           Source: "size>0"
          Identifier size
             Type: uint256
             Source: "size"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "min"
     Source: "function min(uint a, uint b) internal returns (uint) {\r\n        return a < b ? a : b;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return a < b ? a : b;\r\n    }"
      Return
         Gas costs: 0
         Source: "return a < b ? a : b"
        Conditional
           Type: uint256
           Source: "a < b ? a : b"
          BinaryOperation using operator <
             Type: bool
             Source: "a < b"
            Identifier a
               Type: uint256
               Source: "a"
            Identifier b
               Type: uint256
               Source: "b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "" - public
     Source: "function ()  payable {\r\n        if (isContract(controller)) {\r\n            if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\r\n                throw;\r\n        } else {\r\n            throw;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (isContract(controller)) {\r\n            if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\r\n                throw;\r\n        } else {\r\n            throw;\r\n        }\r\n    }"
      IfStatement
         Source: "if (isContract(controller)) {\r\n            if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\r\n                throw;\r\n        } else {\r\n            throw;\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 0
           Source: "isContract(controller)"
          Identifier isContract
             Type: function (address) view returns (bool)
             Source: "isContract"
          Identifier controller
             Type: address
             Source: "controller"
        Block
           Source: "{\r\n            if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\r\n                throw;\r\n        }"
          IfStatement
             Source: "if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\r\n                throw"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: 0
               Source: "! TokenController(controller).proxyPayment.value(msg.value)(msg.sender)"
              FunctionCall
                 Type: bool
                 Source: "TokenController(controller).proxyPayment.value(msg.value)(msg.sender)"
                FunctionCall
                   Type: function (address) payable external returns (bool)
                   Source: "TokenController(controller).proxyPayment.value(msg.value)"
                  MemberAccess to member value
                     Type: function (uint256) returns (function (address) payable external returns (bool))
                     Source: "TokenController(controller).proxyPayment.value"
                    MemberAccess to member proxyPayment
                       Type: function (address) payable external returns (bool)
                       Source: "TokenController(controller).proxyPayment"
                      FunctionCall
                         Type: contract TokenController
                         Source: "TokenController(controller)"
                        Identifier TokenController
                           Type: type(contract TokenController)
                           Source: "TokenController"
                        Identifier controller
                           Type: address
                           Source: "controller"
                  MemberAccess to member value
                     Type: uint256
                     Source: "msg.value"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Throw
               Gas costs: 0
               Source: "throw"
        Block
           Source: "{\r\n            throw;\r\n        }"
          Throw
             Gas costs: 0
             Source: "throw"
  EventDefinition "Transfer"
     Gas costs: 0
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _amount);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _amount)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "NewCloneToken"
     Gas costs: 0
     Source: "event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);"
    ParameterList
       Source: "(address indexed _cloneToken, uint _snapshotBlock)"
      VariableDeclaration "_cloneToken"
         Type: address
         Source: "address indexed _cloneToken"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_snapshotBlock"
         Type: uint256
         Source: "uint _snapshotBlock"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Approval"
     Gas costs: 0
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _amount);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _amount)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "MiniMeTokenFactory"
   Source: "contract MiniMeTokenFactory {\r\n\r\n    /// @notice Update the DApp by creating a new token with new functionalities\r\n    ///  the msg.sender becomes the controller of this clone token\r\n    /// @param _parentToken Address of the token being cloned\r\n    /// @param _snapshotBlock Block of the parent token that will\r\n    ///  determine the initial distribution of the clone token\r\n    /// @param _tokenName Name of the new token\r\n    /// @param _decimalUnits Number of decimals of the new token\r\n    /// @param _tokenSymbol Token Symbol for the new token\r\n    /// @param _transfersEnabled If true, tokens will be able to be transferred\r\n    /// @return The address of the new token contract\r\n    function createCloneToken(\r\n        address _parentToken,\r\n        uint _snapshotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) returns (MiniMeToken) {\r\n        MiniMeToken newToken = new MiniMeToken(\r\n            this,\r\n            _parentToken,\r\n            _snapshotBlock,\r\n            _tokenName,\r\n            _decimalUnits,\r\n            _tokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        newToken.changeController(msg.sender);\r\n        return newToken;\r\n    }\r\n}"
  FunctionDefinition "createCloneToken" - public
     Source: "function createCloneToken(\r\n        address _parentToken,\r\n        uint _snapshotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) returns (MiniMeToken) {\r\n        MiniMeToken newToken = new MiniMeToken(\r\n            this,\r\n            _parentToken,\r\n            _snapshotBlock,\r\n            _tokenName,\r\n            _decimalUnits,\r\n            _tokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        newToken.changeController(msg.sender);\r\n        return newToken;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _parentToken,\r\n        uint _snapshotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    )"
      VariableDeclaration "_parentToken"
         Type: address
         Source: "address _parentToken"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_snapshotBlock"
         Type: uint256
         Source: "uint _snapshotBlock"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_tokenName"
         Type: string memory
         Source: "string _tokenName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_decimalUnits"
         Type: uint8
         Source: "uint8 _decimalUnits"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "_tokenSymbol"
         Type: string memory
         Source: "string _tokenSymbol"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_transfersEnabled"
         Type: bool
         Source: "bool _transfersEnabled"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: "(MiniMeToken)"
      VariableDeclaration ""
         Type: contract MiniMeToken
         Source: "MiniMeToken"
        UserDefinedTypeName "MiniMeToken"
           Source: "MiniMeToken"
    Block
       Source: "{\r\n        MiniMeToken newToken = new MiniMeToken(\r\n            this,\r\n            _parentToken,\r\n            _snapshotBlock,\r\n            _tokenName,\r\n            _decimalUnits,\r\n            _tokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        newToken.changeController(msg.sender);\r\n        return newToken;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "MiniMeToken newToken = new MiniMeToken(\r\n            this,\r\n            _parentToken,\r\n            _snapshotBlock,\r\n            _tokenName,\r\n            _decimalUnits,\r\n            _tokenSymbol,\r\n            _transfersEnabled\r\n            )"
        VariableDeclaration "newToken"
           Type: contract MiniMeToken
           Source: "MiniMeToken newToken"
          UserDefinedTypeName "MiniMeToken"
             Source: "MiniMeToken"
        FunctionCall
           Type: contract MiniMeToken
           Source: "new MiniMeToken(\r\n            this,\r\n            _parentToken,\r\n            _snapshotBlock,\r\n            _tokenName,\r\n            _decimalUnits,\r\n            _tokenSymbol,\r\n            _transfersEnabled\r\n            )"
          NewExpression
             Type: function (address,address,uint256,string memory,uint8,string memory,bool) returns (contract MiniMeToken)
             Source: "new MiniMeToken"
            UserDefinedTypeName "MiniMeToken"
               Source: "MiniMeToken"
          Identifier this
             Type: contract MiniMeTokenFactory
             Source: "this"
          Identifier _parentToken
             Type: address
             Source: "_parentToken"
          Identifier _snapshotBlock
             Type: uint256
             Source: "_snapshotBlock"
          Identifier _tokenName
             Type: string memory
             Source: "_tokenName"
          Identifier _decimalUnits
             Type: uint8
             Source: "_decimalUnits"
          Identifier _tokenSymbol
             Type: string memory
             Source: "_tokenSymbol"
          Identifier _transfersEnabled
             Type: bool
             Source: "_transfersEnabled"
      ExpressionStatement
         Gas costs: 0
         Source: "newToken.changeController(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "newToken.changeController(msg.sender)"
          MemberAccess to member changeController
             Type: function (address) external
             Source: "newToken.changeController"
            Identifier newToken
               Type: contract MiniMeToken
               Source: "newToken"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      Return
         Gas costs: 0
         Source: "return newToken"
        Identifier newToken
           Type: contract MiniMeToken
           Source: "newToken"
ContractDefinition "ClitCoinToken"
   Source: "contract ClitCoinToken is MiniMeToken {\r\n\r\n\r\n\tfunction ClitCoinToken(\r\n\t\t//address _tokenFactory\r\n\t) MiniMeToken(\r\n\t\t0x0,\r\n\t\t0x0,            // no parent token\r\n\t\t0,              // no snapshot block number from parent\r\n\t\t\"CLIT Token\", \t// Token name\r\n\t\t0,              // Decimals\r\n\t\t\"CLIT\",         // Symbol\r\n\t\tfalse            // Enable transfers\r\n\t) {\r\n\t\tversion = \"CLIT 1.0\";\r\n\t}\r\n\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "MiniMeToken"
    UserDefinedTypeName "MiniMeToken"
       Source: "MiniMeToken"
  FunctionDefinition "ClitCoinToken" - public
     Source: "function ClitCoinToken(\r\n\t\t//address _tokenFactory\r\n\t) MiniMeToken(\r\n\t\t0x0,\r\n\t\t0x0,            // no parent token\r\n\t\t0,              // no snapshot block number from parent\r\n\t\t\"CLIT Token\", \t// Token name\r\n\t\t0,              // Decimals\r\n\t\t\"CLIT\",         // Symbol\r\n\t\tfalse            // Enable transfers\r\n\t) {\r\n\t\tversion = \"CLIT 1.0\";\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(\r\n\t\t//address _tokenFactory\r\n\t)"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "MiniMeToken"
       Gas costs: 0
       Source: "MiniMeToken(\r\n\t\t0x0,\r\n\t\t0x0,            // no parent token\r\n\t\t0,              // no snapshot block number from parent\r\n\t\t\"CLIT Token\", \t// Token name\r\n\t\t0,              // Decimals\r\n\t\t\"CLIT\",         // Symbol\r\n\t\tfalse            // Enable transfers\r\n\t)"
      Identifier MiniMeToken
         Type: type(contract MiniMeToken)
         Source: "MiniMeToken"
      Literal, token: [no token] value: 0x0
         Type: int_const 0
         Source: "0x0"
      Literal, token: [no token] value: 0x0
         Type: int_const 0
         Source: "0x0"
      Literal, token: [no token] value: 0
         Type: int_const 0
         Source: "0"
      Literal, token: [no token] value: CLIT Token
         Type: literal_string "CLIT Token"
         Source: "\"CLIT Token\""
      Literal, token: [no token] value: 0
         Type: int_const 0
         Source: "0"
      Literal, token: [no token] value: CLIT
         Type: literal_string "CLIT"
         Source: "\"CLIT\""
      Literal, token: false value: false
         Type: bool
         Source: "false"
    Block
       Source: "{\r\n\t\tversion = \"CLIT 1.0\";\r\n\t}"
      ExpressionStatement
         Gas costs: 0
         Source: "version = \"CLIT 1.0\""
        Assignment using operator =
           Type: string storage ref
           Source: "version = \"CLIT 1.0\""
          Identifier version
             Type: string storage ref
             Source: "version"
          Literal, token: [no token] value: CLIT 1.0
             Type: literal_string "CLIT 1.0"
             Source: "\"CLIT 1.0\""
ContractDefinition "SafeMath"
   Source: "contract SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "mul"
     Source: "function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div"
     Source: "function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(b > 0)"
        FunctionCall
           Type: tuple()
           Source: "assert(b > 0)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >
             Type: bool
             Source: "b > 0"
            Identifier b
               Type: uint256
               Source: "b"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(a == b * c + a % b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == b * c + a % b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "a == b * c + a % b"
            Identifier a
               Type: uint256
               Source: "a"
            BinaryOperation using operator +
               Type: uint256
               Source: "b * c + a % b"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "b * c"
                Identifier b
                   Type: uint256
                   Source: "b"
                Identifier c
                   Type: uint256
                   Source: "c"
              BinaryOperation using operator %
                 Type: uint256
                 Source: "a % b"
                Identifier a
                   Type: uint256
                   Source: "a"
                Identifier b
                   Type: uint256
                   Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub"
     Source: "function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 0
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add"
     Source: "function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "ClitCrowdFunder"
   Source: "contract ClitCrowdFunder is Controlled, SafeMath {\r\n\r\n\taddress public creator;\r\n    address public fundRecipient;\r\n\t\r\n\t// State variables\r\n    State public state = State.Fundraising; // initialize on create\t\r\n    uint public fundingGoal; \r\n\tuint public totalRaised;\r\n\tuint public currentBalance;\r\n\tuint public issuedTokenBalance;\r\n\tuint public totalTokensIssued;\r\n\tuint public capTokenAmount;\r\n\tuint public startBlockNumber;\r\n\tuint public endBlockNumber;\r\n\tuint public eolBlockNumber;\r\n\t\r\n\tuint public firstExchangeRatePeriod;\r\n\tuint public secondExchangeRatePeriod;\r\n\tuint public thirdExchangeRatePeriod;\r\n\tuint public fourthExchangeRatePeriod;\r\n\t\r\n\tuint public firstTokenExchangeRate;\r\n\tuint public secondTokenExchangeRate;\r\n\tuint public thirdTokenExchangeRate;\r\n\tuint public fourthTokenExchangeRate;\r\n\tuint public finalTokenExchangeRate;\t\r\n\t\r\n\tbool public fundingGoalReached;\r\n\t\r\n    ClitCoinToken public exchangeToken;\r\n\t\r\n\t/* This generates a public event on the blockchain that will notify clients */\r\n\tevent HardCapReached(address fundRecipient, uint amountRaised);\r\n\tevent GoalReached(address fundRecipient, uint amountRaised);\r\n\tevent FundTransfer(address backer, uint amount, bool isContribution);\t\r\n\tevent FrozenFunds(address target, bool frozen);\r\n\tevent RefundPeriodStarted();\r\n\r\n\t/* data structure to hold information about campaign contributors */\r\n\tmapping(address => uint256) private balanceOf;\r\n\tmapping (address => bool) private frozenAccount;\r\n\t\r\n\t// Data structures\r\n    enum State {\r\n\t\tFundraising,\r\n\t\tExpiredRefund,\r\n\t\tSuccessful,\r\n\t\tClosed\r\n\t}\r\n\t\r\n\t/*\r\n     *  Modifiers\r\n     */\r\n\r\n\tmodifier inState(State _state) {\r\n        if (state != _state) throw;\r\n        _;\r\n    }\r\n\t\r\n\t// Add one week to endBlockNumber\r\n\tmodifier atEndOfLifecycle() {\r\n        if(!((state == State.ExpiredRefund && block.number > eolBlockNumber) || state == State.Successful)) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\t\r\n\tmodifier accountNotFrozen() {\r\n        if (frozenAccount[msg.sender] == true) throw;\r\n        _;\r\n    }\r\n\t\r\n    modifier minInvestment() {\r\n      // User has to send at least 0.01 Eth\r\n      require(msg.value >= 10 ** 16);\r\n      _;\r\n    }\r\n\t\r\n\tmodifier isStarted() {\r\n\t\trequire(block.number >= startBlockNumber);\r\n\t\t_;\r\n\t}\r\n\r\n\t/*  at initialization, setup the owner */\r\n\tfunction ClitCrowdFunder(\r\n\t\taddress _fundRecipient,\r\n\t\tuint _delayStartHours,\r\n\t\tClitCoinToken _addressOfExchangeToken\r\n\t) {\r\n\t\tcreator = msg.sender;\r\n\t\t\r\n\t\tfundRecipient = _fundRecipient;\r\n\t\tfundingGoal = 7000 * 1 ether;\r\n\t\tcapTokenAmount = 140 * 10 ** 6;\r\n\t\tstate = State.Fundraising;\r\n\t\tfundingGoalReached = false;\r\n\t\t\r\n\t\ttotalRaised = 0;\r\n\t\tcurrentBalance = 0;\r\n\t\ttotalTokensIssued = 0;\r\n\t\tissuedTokenBalance = 0;\r\n\t\t\r\n\t\tstartBlockNumber = block.number + div(mul(3600, _delayStartHours), 14);\r\n\t\tendBlockNumber = startBlockNumber + div(mul(3600, 1080), 14); // 45 days \r\n\t\teolBlockNumber = endBlockNumber + div(mul(3600, 168), 14);  // one week - contract end of life\r\n\r\n\t\tfirstExchangeRatePeriod = startBlockNumber + div(mul(3600, 24), 14);   // First 24 hour sale \r\n\t\tsecondExchangeRatePeriod = firstExchangeRatePeriod + div(mul(3600, 240), 14); // Next 10 days\r\n\t\tthirdExchangeRatePeriod = secondExchangeRatePeriod + div(mul(3600, 240), 14); // Next 10 days\r\n\t\tfourthExchangeRatePeriod = thirdExchangeRatePeriod + div(mul(3600, 240), 14); // Next 10 days\r\n\t\t\r\n\t\tuint _tokenExchangeRate = 1000;\r\n\t\tfirstTokenExchangeRate = (_tokenExchangeRate + 1000);\t\r\n\t\tsecondTokenExchangeRate = (_tokenExchangeRate + 500);\r\n\t\tthirdTokenExchangeRate = (_tokenExchangeRate + 300);\r\n\t\tfourthTokenExchangeRate = (_tokenExchangeRate + 100);\r\n\t\tfinalTokenExchangeRate = _tokenExchangeRate;\r\n\t\t\r\n\t\texchangeToken = ClitCoinToken(_addressOfExchangeToken);\r\n\t}\r\n\t\r\n\tfunction freezeAccount(address target, bool freeze) onlyController {\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }\t\r\n\t\r\n\tfunction getCurrentExchangeRate(uint amount) public constant returns(uint) {\r\n\t\tif (block.number <= firstExchangeRatePeriod) {\r\n\t\t\treturn firstTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= secondExchangeRatePeriod) {\r\n\t\t\treturn secondTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= thirdExchangeRatePeriod) {\r\n\t\t\treturn thirdTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= fourthExchangeRatePeriod) {\r\n\t\t\treturn fourthTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= endBlockNumber) {\r\n\t\t\treturn finalTokenExchangeRate * amount / 1 ether;\r\n\t\t}\r\n\t\t\r\n\t\treturn finalTokenExchangeRate * amount / 1 ether;\r\n\t}\r\n\r\n\tfunction investment() public inState(State.Fundraising) isStarted accountNotFrozen minInvestment payable returns(uint)  {\r\n\t\t\r\n\t\tuint amount = msg.value;\r\n\t\tif (amount == 0) throw;\r\n\t\t\r\n\t\tbalanceOf[msg.sender] += amount;\t\r\n\t\t\r\n\t\ttotalRaised += amount;\r\n\t\tcurrentBalance += amount;\r\n\t\t\t\t\t\t\r\n\t\tuint tokenAmount = getCurrentExchangeRate(amount);\r\n\t\texchangeToken.generateTokens(msg.sender, tokenAmount);\r\n\t\ttotalTokensIssued += tokenAmount;\r\n\t\tissuedTokenBalance += tokenAmount;\r\n\t\t\r\n\t\tFundTransfer(msg.sender, amount, true); \r\n\t\t\r\n\t\tcheckIfFundingCompleteOrExpired();\r\n\t\t\r\n\t\treturn balanceOf[msg.sender];\r\n\t}\r\n\r\n\tfunction checkIfFundingCompleteOrExpired() {\r\n\t\tif (block.number > endBlockNumber || totalTokensIssued >= capTokenAmount ) {\r\n\t\t\t// Hard limit reached\r\n\t\t\tif (currentBalance > fundingGoal || fundingGoalReached == true) {\r\n\t\t\t\tstate = State.Successful;\r\n\t\t\t\tpayOut();\r\n\t\t\t\t\r\n\t\t\t\tHardCapReached(fundRecipient, totalRaised);\r\n\t\t\t\t\r\n\t\t\t\t// Contract can be immediately closed out\r\n\t\t\t\tremoveContract();\r\n\r\n\t\t\t} else  {\r\n\t\t\t\tstate = State.ExpiredRefund; // backers can now collect refunds by calling getRefund()\r\n\t\t\t\t\r\n\t\t\t\tRefundPeriodStarted();\r\n\t\t\t}\r\n\t\t} else if (currentBalance > fundingGoal && fundingGoalReached == false) {\r\n\t\t\t// Once goal reached\r\n\t\t\tfundingGoalReached = true;\r\n\t\t\t\r\n\t\t\tstate = State.Successful;\r\n\t\t\tpayOut();\r\n\t\t\t\r\n\t\t\t// Continue allowing users to buy in\r\n\t\t\tstate = State.Fundraising;\r\n\t\t\t\r\n\t\t\t// currentBalance is zero after pay out\r\n\t\t\tGoalReached(fundRecipient, totalRaised);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction payOut() public inState(State.Successful) {\r\n\t\t// Ethereum balance\r\n\t\tvar amount = currentBalance;\r\n\t\tcurrentBalance = 0;\r\n\r\n\t\tfundRecipient.transfer(amount);\r\n\t\t\r\n\t\t// Update the token reserve amount so that 50% of tokens remain in reserve\r\n\t\tvar tokenCount = issuedTokenBalance;\r\n\t\tissuedTokenBalance = 0;\r\n\t\t\r\n\t\texchangeToken.generateTokens(fundRecipient, tokenCount);\t\t\r\n\t}\r\n\r\n\tfunction getRefund() public inState(State.ExpiredRefund) {\t\r\n\t\tuint amountToRefund = balanceOf[msg.sender];\r\n\t\tbalanceOf[msg.sender] = 0;\r\n\t\t\r\n\t\t// throws error if fails\r\n\t\tmsg.sender.transfer(amountToRefund);\r\n\t\tcurrentBalance -= amountToRefund;\r\n\t\t\r\n\t\tFundTransfer(msg.sender, amountToRefund, false);\r\n\t}\r\n\t\r\n\tfunction removeContract() public atEndOfLifecycle {\t\t\r\n\t\tstate = State.Closed;\r\n\t\t\r\n\t\t// Allow clit owners to freely trade coins on the open market\r\n\t\texchangeToken.enableTransfers(true);\r\n\t\t\r\n\t\t// Restore ownership to controller\r\n\t\texchangeToken.changeController(controller);\r\n\r\n\t\tselfdestruct(msg.sender);\r\n\t}\r\n\t\r\n\t/* The function without name is the default function that is called whenever anyone sends funds to a contract */\r\n\tfunction () payable { \r\n\t\tinvestment(); \r\n\t}\t\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Controlled"
    UserDefinedTypeName "Controlled"
       Source: "Controlled"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  VariableDeclaration "creator"
     Type: address
     Gas costs: [???]
     Source: "address public creator"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "fundRecipient"
     Type: address
     Gas costs: [???]
     Source: "address public fundRecipient"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "state"
     Type: enum ClitCrowdFunder.State
     Gas costs: [???]
     Source: "State public state = State.Fundraising"
    UserDefinedTypeName "State"
       Source: "State"
    MemberAccess to member Fundraising
       Type: enum ClitCrowdFunder.State
       Source: "State.Fundraising"
      Identifier State
         Type: type(enum ClitCrowdFunder.State)
         Source: "State"
  VariableDeclaration "fundingGoal"
     Type: uint256
     Gas costs: [???]
     Source: "uint public fundingGoal"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "totalRaised"
     Type: uint256
     Gas costs: [???]
     Source: "uint public totalRaised"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "currentBalance"
     Type: uint256
     Gas costs: [???]
     Source: "uint public currentBalance"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "issuedTokenBalance"
     Type: uint256
     Gas costs: [???]
     Source: "uint public issuedTokenBalance"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "totalTokensIssued"
     Type: uint256
     Gas costs: [???]
     Source: "uint public totalTokensIssued"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "capTokenAmount"
     Type: uint256
     Gas costs: [???]
     Source: "uint public capTokenAmount"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "startBlockNumber"
     Type: uint256
     Gas costs: [???]
     Source: "uint public startBlockNumber"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "endBlockNumber"
     Type: uint256
     Gas costs: [???]
     Source: "uint public endBlockNumber"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "eolBlockNumber"
     Type: uint256
     Gas costs: [???]
     Source: "uint public eolBlockNumber"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "firstExchangeRatePeriod"
     Type: uint256
     Gas costs: [???]
     Source: "uint public firstExchangeRatePeriod"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "secondExchangeRatePeriod"
     Type: uint256
     Gas costs: [???]
     Source: "uint public secondExchangeRatePeriod"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "thirdExchangeRatePeriod"
     Type: uint256
     Gas costs: [???]
     Source: "uint public thirdExchangeRatePeriod"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "fourthExchangeRatePeriod"
     Type: uint256
     Gas costs: [???]
     Source: "uint public fourthExchangeRatePeriod"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "firstTokenExchangeRate"
     Type: uint256
     Gas costs: [???]
     Source: "uint public firstTokenExchangeRate"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "secondTokenExchangeRate"
     Type: uint256
     Gas costs: [???]
     Source: "uint public secondTokenExchangeRate"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "thirdTokenExchangeRate"
     Type: uint256
     Gas costs: [???]
     Source: "uint public thirdTokenExchangeRate"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "fourthTokenExchangeRate"
     Type: uint256
     Gas costs: [???]
     Source: "uint public fourthTokenExchangeRate"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "finalTokenExchangeRate"
     Type: uint256
     Gas costs: [???]
     Source: "uint public finalTokenExchangeRate"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "fundingGoalReached"
     Type: bool
     Gas costs: [???]
     Source: "bool public fundingGoalReached"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "exchangeToken"
     Type: contract ClitCoinToken
     Gas costs: [???]
     Source: "ClitCoinToken public exchangeToken"
    UserDefinedTypeName "ClitCoinToken"
       Source: "ClitCoinToken"
  EventDefinition "HardCapReached"
     Gas costs: 0
     Source: "event HardCapReached(address fundRecipient, uint amountRaised);"
    ParameterList
       Source: "(address fundRecipient, uint amountRaised)"
      VariableDeclaration "fundRecipient"
         Type: address
         Source: "address fundRecipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amountRaised"
         Type: uint256
         Source: "uint amountRaised"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "GoalReached"
     Gas costs: 0
     Source: "event GoalReached(address fundRecipient, uint amountRaised);"
    ParameterList
       Source: "(address fundRecipient, uint amountRaised)"
      VariableDeclaration "fundRecipient"
         Type: address
         Source: "address fundRecipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amountRaised"
         Type: uint256
         Source: "uint amountRaised"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "FundTransfer"
     Gas costs: 0
     Source: "event FundTransfer(address backer, uint amount, bool isContribution);"
    ParameterList
       Source: "(address backer, uint amount, bool isContribution)"
      VariableDeclaration "backer"
         Type: address
         Source: "address backer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "isContribution"
         Type: bool
         Source: "bool isContribution"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "FrozenFunds"
     Gas costs: 0
     Source: "event FrozenFunds(address target, bool frozen);"
    ParameterList
       Source: "(address target, bool frozen)"
      VariableDeclaration "target"
         Type: address
         Source: "address target"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "frozen"
         Type: bool
         Source: "bool frozen"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "RefundPeriodStarted"
     Gas costs: 0
     Source: "event RefundPeriodStarted();"
    ParameterList
       Source: "()"
  VariableDeclaration "balanceOf"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) private balanceOf"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "frozenAccount"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping (address => bool) private frozenAccount"
    Mapping
       Source: "mapping (address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  EnumDefinition "State"
    EnumValue "Fundraising"
    EnumValue "ExpiredRefund"
    EnumValue "Successful"
    EnumValue "Closed"
  ModifierDefinition "inState"
     Source: "modifier inState(State _state) {\r\n        if (state != _state) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(State _state)"
      VariableDeclaration "_state"
         Type: enum ClitCrowdFunder.State
         Source: "State _state"
        UserDefinedTypeName "State"
           Source: "State"
    Block
       Source: "{\r\n        if (state != _state) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (state != _state) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 1050
           Source: "state != _state"
          Identifier state
             Type: enum ClitCrowdFunder.State
             Source: "state"
          Identifier _state
             Type: enum ClitCrowdFunder.State
             Source: "_state"
        Throw
           Gas costs: 18
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "atEndOfLifecycle"
     Source: "modifier atEndOfLifecycle() {\r\n        if(!((state == State.ExpiredRefund && block.number > eolBlockNumber) || state == State.Successful)) {\r\n            throw;\r\n        }\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        if(!((state == State.ExpiredRefund && block.number > eolBlockNumber) || state == State.Successful)) {\r\n            throw;\r\n        }\r\n        _;\r\n    }"
      IfStatement
         Source: "if(!((state == State.ExpiredRefund && block.number > eolBlockNumber) || state == State.Successful)) {\r\n            throw;\r\n        }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 946
           Source: "!((state == State.ExpiredRefund && block.number > eolBlockNumber) || state == State.Successful)"
          TupleExpression
             Type: bool
             Source: "((state == State.ExpiredRefund && block.number > eolBlockNumber) || state == State.Successful)"
            BinaryOperation using operator ||
               Type: bool
               Source: "(state == State.ExpiredRefund && block.number > eolBlockNumber) || state == State.Successful"
              TupleExpression
                 Type: bool
                 Source: "(state == State.ExpiredRefund && block.number > eolBlockNumber)"
                BinaryOperation using operator &&
                   Type: bool
                   Source: "state == State.ExpiredRefund && block.number > eolBlockNumber"
                  BinaryOperation using operator ==
                     Type: bool
                     Source: "state == State.ExpiredRefund"
                    Identifier state
                       Type: enum ClitCrowdFunder.State
                       Source: "state"
                    MemberAccess to member ExpiredRefund
                       Type: enum ClitCrowdFunder.State
                       Source: "State.ExpiredRefund"
                      Identifier State
                         Type: type(enum ClitCrowdFunder.State)
                         Source: "State"
                  BinaryOperation using operator >
                     Type: bool
                     Source: "block.number > eolBlockNumber"
                    MemberAccess to member number
                       Type: uint256
                       Source: "block.number"
                      Identifier block
                         Type: block
                         Source: "block"
                    Identifier eolBlockNumber
                       Type: uint256
                       Source: "eolBlockNumber"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "state == State.Successful"
                Identifier state
                   Type: enum ClitCrowdFunder.State
                   Source: "state"
                MemberAccess to member Successful
                   Type: enum ClitCrowdFunder.State
                   Source: "State.Successful"
                  Identifier State
                     Type: type(enum ClitCrowdFunder.State)
                     Source: "State"
        Block
           Source: "{\r\n            throw;\r\n        }"
          Throw
             Gas costs: 6
             Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "accountNotFrozen"
     Source: "modifier accountNotFrozen() {\r\n        if (frozenAccount[msg.sender] == true) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        if (frozenAccount[msg.sender] == true) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (frozenAccount[msg.sender] == true) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 352
           Source: "frozenAccount[msg.sender] == true"
          IndexAccess
             Type: bool
             Source: "frozenAccount[msg.sender]"
            Identifier frozenAccount
               Type: mapping(address => bool)
               Source: "frozenAccount"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: true value: true
             Type: bool
             Source: "true"
        Throw
           Gas costs: 6
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "minInvestment"
     Source: "modifier minInvestment() {\r\n      // User has to send at least 0.01 Eth\r\n      require(msg.value >= 10 ** 16);\r\n      _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n      // User has to send at least 0.01 Eth\r\n      require(msg.value >= 10 ** 16);\r\n      _;\r\n    }"
      ExpressionStatement
         Gas costs: 37
         Source: "require(msg.value >= 10 ** 16)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value >= 10 ** 16)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.value >= 10 ** 16"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            BinaryOperation using operator **
               Type: int_const 10000000000000000
               Source: "10 ** 16"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Literal, token: [no token] value: 16
                 Type: int_const 16
                 Source: "16"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "isStarted"
     Source: "modifier isStarted() {\r\n\t\trequire(block.number >= startBlockNumber);\r\n\t\t_;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n\t\trequire(block.number >= startBlockNumber);\r\n\t\t_;\r\n\t}"
      ExpressionStatement
         Gas costs: 237
         Source: "require(block.number >= startBlockNumber)"
        FunctionCall
           Type: tuple()
           Source: "require(block.number >= startBlockNumber)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "block.number >= startBlockNumber"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier startBlockNumber
               Type: uint256
               Source: "startBlockNumber"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "ClitCrowdFunder" - public
     Source: "function ClitCrowdFunder(\r\n\t\taddress _fundRecipient,\r\n\t\tuint _delayStartHours,\r\n\t\tClitCoinToken _addressOfExchangeToken\r\n\t) {\r\n\t\tcreator = msg.sender;\r\n\t\t\r\n\t\tfundRecipient = _fundRecipient;\r\n\t\tfundingGoal = 7000 * 1 ether;\r\n\t\tcapTokenAmount = 140 * 10 ** 6;\r\n\t\tstate = State.Fundraising;\r\n\t\tfundingGoalReached = false;\r\n\t\t\r\n\t\ttotalRaised = 0;\r\n\t\tcurrentBalance = 0;\r\n\t\ttotalTokensIssued = 0;\r\n\t\tissuedTokenBalance = 0;\r\n\t\t\r\n\t\tstartBlockNumber = block.number + div(mul(3600, _delayStartHours), 14);\r\n\t\tendBlockNumber = startBlockNumber + div(mul(3600, 1080), 14); // 45 days \r\n\t\teolBlockNumber = endBlockNumber + div(mul(3600, 168), 14);  // one week - contract end of life\r\n\r\n\t\tfirstExchangeRatePeriod = startBlockNumber + div(mul(3600, 24), 14);   // First 24 hour sale \r\n\t\tsecondExchangeRatePeriod = firstExchangeRatePeriod + div(mul(3600, 240), 14); // Next 10 days\r\n\t\tthirdExchangeRatePeriod = secondExchangeRatePeriod + div(mul(3600, 240), 14); // Next 10 days\r\n\t\tfourthExchangeRatePeriod = thirdExchangeRatePeriod + div(mul(3600, 240), 14); // Next 10 days\r\n\t\t\r\n\t\tuint _tokenExchangeRate = 1000;\r\n\t\tfirstTokenExchangeRate = (_tokenExchangeRate + 1000);\t\r\n\t\tsecondTokenExchangeRate = (_tokenExchangeRate + 500);\r\n\t\tthirdTokenExchangeRate = (_tokenExchangeRate + 300);\r\n\t\tfourthTokenExchangeRate = (_tokenExchangeRate + 100);\r\n\t\tfinalTokenExchangeRate = _tokenExchangeRate;\r\n\t\t\r\n\t\texchangeToken = ClitCoinToken(_addressOfExchangeToken);\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(\r\n\t\taddress _fundRecipient,\r\n\t\tuint _delayStartHours,\r\n\t\tClitCoinToken _addressOfExchangeToken\r\n\t)"
      VariableDeclaration "_fundRecipient"
         Type: address
         Source: "address _fundRecipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_delayStartHours"
         Type: uint256
         Source: "uint _delayStartHours"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_addressOfExchangeToken"
         Type: contract ClitCoinToken
         Source: "ClitCoinToken _addressOfExchangeToken"
        UserDefinedTypeName "ClitCoinToken"
           Source: "ClitCoinToken"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tcreator = msg.sender;\r\n\t\t\r\n\t\tfundRecipient = _fundRecipient;\r\n\t\tfundingGoal = 7000 * 1 ether;\r\n\t\tcapTokenAmount = 140 * 10 ** 6;\r\n\t\tstate = State.Fundraising;\r\n\t\tfundingGoalReached = false;\r\n\t\t\r\n\t\ttotalRaised = 0;\r\n\t\tcurrentBalance = 0;\r\n\t\ttotalTokensIssued = 0;\r\n\t\tissuedTokenBalance = 0;\r\n\t\t\r\n\t\tstartBlockNumber = block.number + div(mul(3600, _delayStartHours), 14);\r\n\t\tendBlockNumber = startBlockNumber + div(mul(3600, 1080), 14); // 45 days \r\n\t\teolBlockNumber = endBlockNumber + div(mul(3600, 168), 14);  // one week - contract end of life\r\n\r\n\t\tfirstExchangeRatePeriod = startBlockNumber + div(mul(3600, 24), 14);   // First 24 hour sale \r\n\t\tsecondExchangeRatePeriod = firstExchangeRatePeriod + div(mul(3600, 240), 14); // Next 10 days\r\n\t\tthirdExchangeRatePeriod = secondExchangeRatePeriod + div(mul(3600, 240), 14); // Next 10 days\r\n\t\tfourthExchangeRatePeriod = thirdExchangeRatePeriod + div(mul(3600, 240), 14); // Next 10 days\r\n\t\t\r\n\t\tuint _tokenExchangeRate = 1000;\r\n\t\tfirstTokenExchangeRate = (_tokenExchangeRate + 1000);\t\r\n\t\tsecondTokenExchangeRate = (_tokenExchangeRate + 500);\r\n\t\tthirdTokenExchangeRate = (_tokenExchangeRate + 300);\r\n\t\tfourthTokenExchangeRate = (_tokenExchangeRate + 100);\r\n\t\tfinalTokenExchangeRate = _tokenExchangeRate;\r\n\t\t\r\n\t\texchangeToken = ClitCoinToken(_addressOfExchangeToken);\r\n\t}"
      ExpressionStatement
         Gas costs: 0
         Source: "creator = msg.sender"
        Assignment using operator =
           Type: address
           Source: "creator = msg.sender"
          Identifier creator
             Type: address
             Source: "creator"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "fundRecipient = _fundRecipient"
        Assignment using operator =
           Type: address
           Source: "fundRecipient = _fundRecipient"
          Identifier fundRecipient
             Type: address
             Source: "fundRecipient"
          Identifier _fundRecipient
             Type: address
             Source: "_fundRecipient"
      ExpressionStatement
         Gas costs: 0
         Source: "fundingGoal = 7000 * 1 ether"
        Assignment using operator =
           Type: uint256
           Source: "fundingGoal = 7000 * 1 ether"
          Identifier fundingGoal
             Type: uint256
             Source: "fundingGoal"
          BinaryOperation using operator *
             Type: int_const 7000000000000000000000
             Source: "7000 * 1 ether"
            Literal, token: [no token] value: 7000
               Type: int_const 7000
               Source: "7000"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
      ExpressionStatement
         Gas costs: 0
         Source: "capTokenAmount = 140 * 10 ** 6"
        Assignment using operator =
           Type: uint256
           Source: "capTokenAmount = 140 * 10 ** 6"
          Identifier capTokenAmount
             Type: uint256
             Source: "capTokenAmount"
          BinaryOperation using operator *
             Type: int_const 140000000
             Source: "140 * 10 ** 6"
            Literal, token: [no token] value: 140
               Type: int_const 140
               Source: "140"
            BinaryOperation using operator **
               Type: int_const 1000000
               Source: "10 ** 6"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Literal, token: [no token] value: 6
                 Type: int_const 6
                 Source: "6"
      ExpressionStatement
         Gas costs: 0
         Source: "state = State.Fundraising"
        Assignment using operator =
           Type: enum ClitCrowdFunder.State
           Source: "state = State.Fundraising"
          Identifier state
             Type: enum ClitCrowdFunder.State
             Source: "state"
          MemberAccess to member Fundraising
             Type: enum ClitCrowdFunder.State
             Source: "State.Fundraising"
            Identifier State
               Type: type(enum ClitCrowdFunder.State)
               Source: "State"
      ExpressionStatement
         Gas costs: 0
         Source: "fundingGoalReached = false"
        Assignment using operator =
           Type: bool
           Source: "fundingGoalReached = false"
          Identifier fundingGoalReached
             Type: bool
             Source: "fundingGoalReached"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 0
         Source: "totalRaised = 0"
        Assignment using operator =
           Type: uint256
           Source: "totalRaised = 0"
          Identifier totalRaised
             Type: uint256
             Source: "totalRaised"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "currentBalance = 0"
        Assignment using operator =
           Type: uint256
           Source: "currentBalance = 0"
          Identifier currentBalance
             Type: uint256
             Source: "currentBalance"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "totalTokensIssued = 0"
        Assignment using operator =
           Type: uint256
           Source: "totalTokensIssued = 0"
          Identifier totalTokensIssued
             Type: uint256
             Source: "totalTokensIssued"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "issuedTokenBalance = 0"
        Assignment using operator =
           Type: uint256
           Source: "issuedTokenBalance = 0"
          Identifier issuedTokenBalance
             Type: uint256
             Source: "issuedTokenBalance"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "startBlockNumber = block.number + div(mul(3600, _delayStartHours), 14)"
        Assignment using operator =
           Type: uint256
           Source: "startBlockNumber = block.number + div(mul(3600, _delayStartHours), 14)"
          Identifier startBlockNumber
             Type: uint256
             Source: "startBlockNumber"
          BinaryOperation using operator +
             Type: uint256
             Source: "block.number + div(mul(3600, _delayStartHours), 14)"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            FunctionCall
               Type: uint256
               Source: "div(mul(3600, _delayStartHours), 14)"
              Identifier div
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "div"
              FunctionCall
                 Type: uint256
                 Source: "mul(3600, _delayStartHours)"
                Identifier mul
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "mul"
                Literal, token: [no token] value: 3600
                   Type: int_const 3600
                   Source: "3600"
                Identifier _delayStartHours
                   Type: uint256
                   Source: "_delayStartHours"
              Literal, token: [no token] value: 14
                 Type: int_const 14
                 Source: "14"
      ExpressionStatement
         Gas costs: 0
         Source: "endBlockNumber = startBlockNumber + div(mul(3600, 1080), 14)"
        Assignment using operator =
           Type: uint256
           Source: "endBlockNumber = startBlockNumber + div(mul(3600, 1080), 14)"
          Identifier endBlockNumber
             Type: uint256
             Source: "endBlockNumber"
          BinaryOperation using operator +
             Type: uint256
             Source: "startBlockNumber + div(mul(3600, 1080), 14)"
            Identifier startBlockNumber
               Type: uint256
               Source: "startBlockNumber"
            FunctionCall
               Type: uint256
               Source: "div(mul(3600, 1080), 14)"
              Identifier div
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "div"
              FunctionCall
                 Type: uint256
                 Source: "mul(3600, 1080)"
                Identifier mul
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "mul"
                Literal, token: [no token] value: 3600
                   Type: int_const 3600
                   Source: "3600"
                Literal, token: [no token] value: 1080
                   Type: int_const 1080
                   Source: "1080"
              Literal, token: [no token] value: 14
                 Type: int_const 14
                 Source: "14"
      ExpressionStatement
         Gas costs: 0
         Source: "eolBlockNumber = endBlockNumber + div(mul(3600, 168), 14)"
        Assignment using operator =
           Type: uint256
           Source: "eolBlockNumber = endBlockNumber + div(mul(3600, 168), 14)"
          Identifier eolBlockNumber
             Type: uint256
             Source: "eolBlockNumber"
          BinaryOperation using operator +
             Type: uint256
             Source: "endBlockNumber + div(mul(3600, 168), 14)"
            Identifier endBlockNumber
               Type: uint256
               Source: "endBlockNumber"
            FunctionCall
               Type: uint256
               Source: "div(mul(3600, 168), 14)"
              Identifier div
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "div"
              FunctionCall
                 Type: uint256
                 Source: "mul(3600, 168)"
                Identifier mul
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "mul"
                Literal, token: [no token] value: 3600
                   Type: int_const 3600
                   Source: "3600"
                Literal, token: [no token] value: 168
                   Type: int_const 168
                   Source: "168"
              Literal, token: [no token] value: 14
                 Type: int_const 14
                 Source: "14"
      ExpressionStatement
         Gas costs: 0
         Source: "firstExchangeRatePeriod = startBlockNumber + div(mul(3600, 24), 14)"
        Assignment using operator =
           Type: uint256
           Source: "firstExchangeRatePeriod = startBlockNumber + div(mul(3600, 24), 14)"
          Identifier firstExchangeRatePeriod
             Type: uint256
             Source: "firstExchangeRatePeriod"
          BinaryOperation using operator +
             Type: uint256
             Source: "startBlockNumber + div(mul(3600, 24), 14)"
            Identifier startBlockNumber
               Type: uint256
               Source: "startBlockNumber"
            FunctionCall
               Type: uint256
               Source: "div(mul(3600, 24), 14)"
              Identifier div
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "div"
              FunctionCall
                 Type: uint256
                 Source: "mul(3600, 24)"
                Identifier mul
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "mul"
                Literal, token: [no token] value: 3600
                   Type: int_const 3600
                   Source: "3600"
                Literal, token: [no token] value: 24
                   Type: int_const 24
                   Source: "24"
              Literal, token: [no token] value: 14
                 Type: int_const 14
                 Source: "14"
      ExpressionStatement
         Gas costs: 0
         Source: "secondExchangeRatePeriod = firstExchangeRatePeriod + div(mul(3600, 240), 14)"
        Assignment using operator =
           Type: uint256
           Source: "secondExchangeRatePeriod = firstExchangeRatePeriod + div(mul(3600, 240), 14)"
          Identifier secondExchangeRatePeriod
             Type: uint256
             Source: "secondExchangeRatePeriod"
          BinaryOperation using operator +
             Type: uint256
             Source: "firstExchangeRatePeriod + div(mul(3600, 240), 14)"
            Identifier firstExchangeRatePeriod
               Type: uint256
               Source: "firstExchangeRatePeriod"
            FunctionCall
               Type: uint256
               Source: "div(mul(3600, 240), 14)"
              Identifier div
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "div"
              FunctionCall
                 Type: uint256
                 Source: "mul(3600, 240)"
                Identifier mul
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "mul"
                Literal, token: [no token] value: 3600
                   Type: int_const 3600
                   Source: "3600"
                Literal, token: [no token] value: 240
                   Type: int_const 240
                   Source: "240"
              Literal, token: [no token] value: 14
                 Type: int_const 14
                 Source: "14"
      ExpressionStatement
         Gas costs: 0
         Source: "thirdExchangeRatePeriod = secondExchangeRatePeriod + div(mul(3600, 240), 14)"
        Assignment using operator =
           Type: uint256
           Source: "thirdExchangeRatePeriod = secondExchangeRatePeriod + div(mul(3600, 240), 14)"
          Identifier thirdExchangeRatePeriod
             Type: uint256
             Source: "thirdExchangeRatePeriod"
          BinaryOperation using operator +
             Type: uint256
             Source: "secondExchangeRatePeriod + div(mul(3600, 240), 14)"
            Identifier secondExchangeRatePeriod
               Type: uint256
               Source: "secondExchangeRatePeriod"
            FunctionCall
               Type: uint256
               Source: "div(mul(3600, 240), 14)"
              Identifier div
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "div"
              FunctionCall
                 Type: uint256
                 Source: "mul(3600, 240)"
                Identifier mul
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "mul"
                Literal, token: [no token] value: 3600
                   Type: int_const 3600
                   Source: "3600"
                Literal, token: [no token] value: 240
                   Type: int_const 240
                   Source: "240"
              Literal, token: [no token] value: 14
                 Type: int_const 14
                 Source: "14"
      ExpressionStatement
         Gas costs: 0
         Source: "fourthExchangeRatePeriod = thirdExchangeRatePeriod + div(mul(3600, 240), 14)"
        Assignment using operator =
           Type: uint256
           Source: "fourthExchangeRatePeriod = thirdExchangeRatePeriod + div(mul(3600, 240), 14)"
          Identifier fourthExchangeRatePeriod
             Type: uint256
             Source: "fourthExchangeRatePeriod"
          BinaryOperation using operator +
             Type: uint256
             Source: "thirdExchangeRatePeriod + div(mul(3600, 240), 14)"
            Identifier thirdExchangeRatePeriod
               Type: uint256
               Source: "thirdExchangeRatePeriod"
            FunctionCall
               Type: uint256
               Source: "div(mul(3600, 240), 14)"
              Identifier div
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "div"
              FunctionCall
                 Type: uint256
                 Source: "mul(3600, 240)"
                Identifier mul
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "mul"
                Literal, token: [no token] value: 3600
                   Type: int_const 3600
                   Source: "3600"
                Literal, token: [no token] value: 240
                   Type: int_const 240
                   Source: "240"
              Literal, token: [no token] value: 14
                 Type: int_const 14
                 Source: "14"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint _tokenExchangeRate = 1000"
        VariableDeclaration "_tokenExchangeRate"
           Type: uint256
           Source: "uint _tokenExchangeRate"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 1000
           Type: int_const 1000
           Source: "1000"
      ExpressionStatement
         Gas costs: 0
         Source: "firstTokenExchangeRate = (_tokenExchangeRate + 1000)"
        Assignment using operator =
           Type: uint256
           Source: "firstTokenExchangeRate = (_tokenExchangeRate + 1000)"
          Identifier firstTokenExchangeRate
             Type: uint256
             Source: "firstTokenExchangeRate"
          TupleExpression
             Type: uint256
             Source: "(_tokenExchangeRate + 1000)"
            BinaryOperation using operator +
               Type: uint256
               Source: "_tokenExchangeRate + 1000"
              Identifier _tokenExchangeRate
                 Type: uint256
                 Source: "_tokenExchangeRate"
              Literal, token: [no token] value: 1000
                 Type: int_const 1000
                 Source: "1000"
      ExpressionStatement
         Gas costs: 0
         Source: "secondTokenExchangeRate = (_tokenExchangeRate + 500)"
        Assignment using operator =
           Type: uint256
           Source: "secondTokenExchangeRate = (_tokenExchangeRate + 500)"
          Identifier secondTokenExchangeRate
             Type: uint256
             Source: "secondTokenExchangeRate"
          TupleExpression
             Type: uint256
             Source: "(_tokenExchangeRate + 500)"
            BinaryOperation using operator +
               Type: uint256
               Source: "_tokenExchangeRate + 500"
              Identifier _tokenExchangeRate
                 Type: uint256
                 Source: "_tokenExchangeRate"
              Literal, token: [no token] value: 500
                 Type: int_const 500
                 Source: "500"
      ExpressionStatement
         Gas costs: 0
         Source: "thirdTokenExchangeRate = (_tokenExchangeRate + 300)"
        Assignment using operator =
           Type: uint256
           Source: "thirdTokenExchangeRate = (_tokenExchangeRate + 300)"
          Identifier thirdTokenExchangeRate
             Type: uint256
             Source: "thirdTokenExchangeRate"
          TupleExpression
             Type: uint256
             Source: "(_tokenExchangeRate + 300)"
            BinaryOperation using operator +
               Type: uint256
               Source: "_tokenExchangeRate + 300"
              Identifier _tokenExchangeRate
                 Type: uint256
                 Source: "_tokenExchangeRate"
              Literal, token: [no token] value: 300
                 Type: int_const 300
                 Source: "300"
      ExpressionStatement
         Gas costs: 0
         Source: "fourthTokenExchangeRate = (_tokenExchangeRate + 100)"
        Assignment using operator =
           Type: uint256
           Source: "fourthTokenExchangeRate = (_tokenExchangeRate + 100)"
          Identifier fourthTokenExchangeRate
             Type: uint256
             Source: "fourthTokenExchangeRate"
          TupleExpression
             Type: uint256
             Source: "(_tokenExchangeRate + 100)"
            BinaryOperation using operator +
               Type: uint256
               Source: "_tokenExchangeRate + 100"
              Identifier _tokenExchangeRate
                 Type: uint256
                 Source: "_tokenExchangeRate"
              Literal, token: [no token] value: 100
                 Type: int_const 100
                 Source: "100"
      ExpressionStatement
         Gas costs: 0
         Source: "finalTokenExchangeRate = _tokenExchangeRate"
        Assignment using operator =
           Type: uint256
           Source: "finalTokenExchangeRate = _tokenExchangeRate"
          Identifier finalTokenExchangeRate
             Type: uint256
             Source: "finalTokenExchangeRate"
          Identifier _tokenExchangeRate
             Type: uint256
             Source: "_tokenExchangeRate"
      ExpressionStatement
         Gas costs: 0
         Source: "exchangeToken = ClitCoinToken(_addressOfExchangeToken)"
        Assignment using operator =
           Type: contract ClitCoinToken
           Source: "exchangeToken = ClitCoinToken(_addressOfExchangeToken)"
          Identifier exchangeToken
             Type: contract ClitCoinToken
             Source: "exchangeToken"
          FunctionCall
             Type: contract ClitCoinToken
             Source: "ClitCoinToken(_addressOfExchangeToken)"
            Identifier ClitCoinToken
               Type: type(contract ClitCoinToken)
               Source: "ClitCoinToken"
            Identifier _addressOfExchangeToken
               Type: contract ClitCoinToken
               Source: "_addressOfExchangeToken"
  FunctionDefinition "freezeAccount" - public
     Source: "function freezeAccount(address target, bool freeze) onlyController {\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address target, bool freeze)"
      VariableDeclaration "target"
         Type: address
         Source: "address target"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "freeze"
         Type: bool
         Source: "bool freeze"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }"
      ExpressionStatement
         Gas costs: 20363
         Source: "frozenAccount[target] = freeze"
        Assignment using operator =
           Type: bool
           Source: "frozenAccount[target] = freeze"
          IndexAccess
             Type: bool
             Source: "frozenAccount[target]"
            Identifier frozenAccount
               Type: mapping(address => bool)
               Source: "frozenAccount"
            Identifier target
               Type: address
               Source: "target"
          Identifier freeze
             Type: bool
             Source: "freeze"
      ExpressionStatement
         Gas costs: [???]
         Source: "FrozenFunds(target, freeze)"
        FunctionCall
           Type: tuple()
           Source: "FrozenFunds(target, freeze)"
          Identifier FrozenFunds
             Type: function (address,bool)
             Source: "FrozenFunds"
          Identifier target
             Type: address
             Source: "target"
          Identifier freeze
             Type: bool
             Source: "freeze"
  FunctionDefinition "getCurrentExchangeRate" - public - const
     Source: "function getCurrentExchangeRate(uint amount) public constant returns(uint) {\r\n\t\tif (block.number <= firstExchangeRatePeriod) {\r\n\t\t\treturn firstTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= secondExchangeRatePeriod) {\r\n\t\t\treturn secondTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= thirdExchangeRatePeriod) {\r\n\t\t\treturn thirdTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= fourthExchangeRatePeriod) {\r\n\t\t\treturn fourthTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= endBlockNumber) {\r\n\t\t\treturn finalTokenExchangeRate * amount / 1 ether;\r\n\t\t}\r\n\t\t\r\n\t\treturn finalTokenExchangeRate * amount / 1 ether;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\t\tif (block.number <= firstExchangeRatePeriod) {\r\n\t\t\treturn firstTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= secondExchangeRatePeriod) {\r\n\t\t\treturn secondTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= thirdExchangeRatePeriod) {\r\n\t\t\treturn thirdTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= fourthExchangeRatePeriod) {\r\n\t\t\treturn fourthTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= endBlockNumber) {\r\n\t\t\treturn finalTokenExchangeRate * amount / 1 ether;\r\n\t\t}\r\n\t\t\r\n\t\treturn finalTokenExchangeRate * amount / 1 ether;\r\n\t}"
      IfStatement
         Source: "if (block.number <= firstExchangeRatePeriod) {\r\n\t\t\treturn firstTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= secondExchangeRatePeriod) {\r\n\t\t\treturn secondTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= thirdExchangeRatePeriod) {\r\n\t\t\treturn thirdTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= fourthExchangeRatePeriod) {\r\n\t\t\treturn fourthTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= endBlockNumber) {\r\n\t\t\treturn finalTokenExchangeRate * amount / 1 ether;\r\n\t\t}"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 211
           Source: "block.number <= firstExchangeRatePeriod"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          Identifier firstExchangeRatePeriod
             Type: uint256
             Source: "firstExchangeRatePeriod"
        Block
           Source: "{\r\n\t\t\treturn firstTokenExchangeRate * amount / 1 ether;\r\n\t\t}"
          Return
             Gas costs: 258
             Source: "return firstTokenExchangeRate * amount / 1 ether"
            BinaryOperation using operator /
               Type: uint256
               Source: "firstTokenExchangeRate * amount / 1 ether"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "firstTokenExchangeRate * amount"
                Identifier firstTokenExchangeRate
                   Type: uint256
                   Source: "firstTokenExchangeRate"
                Identifier amount
                   Type: uint256
                   Source: "amount"
              Literal, token: [no token] value: 1
                 Type: int_const 1000000000000000000
                 Source: "1 ether"
        IfStatement
           Source: "if (block.number <= secondExchangeRatePeriod) {\r\n\t\t\treturn secondTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= thirdExchangeRatePeriod) {\r\n\t\t\treturn thirdTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= fourthExchangeRatePeriod) {\r\n\t\t\treturn fourthTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= endBlockNumber) {\r\n\t\t\treturn finalTokenExchangeRate * amount / 1 ether;\r\n\t\t}"
          BinaryOperation using operator <=
             Type: bool
             Gas costs: 211
             Source: "block.number <= secondExchangeRatePeriod"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier secondExchangeRatePeriod
               Type: uint256
               Source: "secondExchangeRatePeriod"
          Block
             Source: "{\r\n\t\t\treturn secondTokenExchangeRate * amount / 1 ether;\r\n\t\t}"
            Return
               Gas costs: 258
               Source: "return secondTokenExchangeRate * amount / 1 ether"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "secondTokenExchangeRate * amount / 1 ether"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "secondTokenExchangeRate * amount"
                  Identifier secondTokenExchangeRate
                     Type: uint256
                     Source: "secondTokenExchangeRate"
                  Identifier amount
                     Type: uint256
                     Source: "amount"
                Literal, token: [no token] value: 1
                   Type: int_const 1000000000000000000
                   Source: "1 ether"
          IfStatement
             Source: "if (block.number <= thirdExchangeRatePeriod) {\r\n\t\t\treturn thirdTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= fourthExchangeRatePeriod) {\r\n\t\t\treturn fourthTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= endBlockNumber) {\r\n\t\t\treturn finalTokenExchangeRate * amount / 1 ether;\r\n\t\t}"
            BinaryOperation using operator <=
               Type: bool
               Gas costs: 211
               Source: "block.number <= thirdExchangeRatePeriod"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              Identifier thirdExchangeRatePeriod
                 Type: uint256
                 Source: "thirdExchangeRatePeriod"
            Block
               Source: "{\r\n\t\t\treturn thirdTokenExchangeRate * amount / 1 ether;\r\n\t\t}"
              Return
                 Gas costs: 258
                 Source: "return thirdTokenExchangeRate * amount / 1 ether"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "thirdTokenExchangeRate * amount / 1 ether"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "thirdTokenExchangeRate * amount"
                    Identifier thirdTokenExchangeRate
                       Type: uint256
                       Source: "thirdTokenExchangeRate"
                    Identifier amount
                       Type: uint256
                       Source: "amount"
                  Literal, token: [no token] value: 1
                     Type: int_const 1000000000000000000
                     Source: "1 ether"
            IfStatement
               Source: "if (block.number <= fourthExchangeRatePeriod) {\r\n\t\t\treturn fourthTokenExchangeRate * amount / 1 ether;\r\n\t\t} else if (block.number <= endBlockNumber) {\r\n\t\t\treturn finalTokenExchangeRate * amount / 1 ether;\r\n\t\t}"
              BinaryOperation using operator <=
                 Type: bool
                 Gas costs: 211
                 Source: "block.number <= fourthExchangeRatePeriod"
                MemberAccess to member number
                   Type: uint256
                   Source: "block.number"
                  Identifier block
                     Type: block
                     Source: "block"
                Identifier fourthExchangeRatePeriod
                   Type: uint256
                   Source: "fourthExchangeRatePeriod"
              Block
                 Source: "{\r\n\t\t\treturn fourthTokenExchangeRate * amount / 1 ether;\r\n\t\t}"
                Return
                   Gas costs: 258
                   Source: "return fourthTokenExchangeRate * amount / 1 ether"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "fourthTokenExchangeRate * amount / 1 ether"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "fourthTokenExchangeRate * amount"
                      Identifier fourthTokenExchangeRate
                         Type: uint256
                         Source: "fourthTokenExchangeRate"
                      Identifier amount
                         Type: uint256
                         Source: "amount"
                    Literal, token: [no token] value: 1
                       Type: int_const 1000000000000000000
                       Source: "1 ether"
              IfStatement
                 Source: "if (block.number <= endBlockNumber) {\r\n\t\t\treturn finalTokenExchangeRate * amount / 1 ether;\r\n\t\t}"
                BinaryOperation using operator <=
                   Type: bool
                   Gas costs: 211
                   Source: "block.number <= endBlockNumber"
                  MemberAccess to member number
                     Type: uint256
                     Source: "block.number"
                    Identifier block
                       Type: block
                       Source: "block"
                  Identifier endBlockNumber
                     Type: uint256
                     Source: "endBlockNumber"
                Block
                   Source: "{\r\n\t\t\treturn finalTokenExchangeRate * amount / 1 ether;\r\n\t\t}"
                  Return
                     Gas costs: 258
                     Source: "return finalTokenExchangeRate * amount / 1 ether"
                    BinaryOperation using operator /
                       Type: uint256
                       Source: "finalTokenExchangeRate * amount / 1 ether"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "finalTokenExchangeRate * amount"
                        Identifier finalTokenExchangeRate
                           Type: uint256
                           Source: "finalTokenExchangeRate"
                        Identifier amount
                           Type: uint256
                           Source: "amount"
                      Literal, token: [no token] value: 1
                         Type: int_const 1000000000000000000
                         Source: "1 ether"
      Return
         Gas costs: 247
         Source: "return finalTokenExchangeRate * amount / 1 ether"
        BinaryOperation using operator /
           Type: uint256
           Source: "finalTokenExchangeRate * amount / 1 ether"
          BinaryOperation using operator *
             Type: uint256
             Source: "finalTokenExchangeRate * amount"
            Identifier finalTokenExchangeRate
               Type: uint256
               Source: "finalTokenExchangeRate"
            Identifier amount
               Type: uint256
               Source: "amount"
          Literal, token: [no token] value: 1
             Type: int_const 1000000000000000000
             Source: "1 ether"
  FunctionDefinition "investment" - public
     Source: "function investment() public inState(State.Fundraising) isStarted accountNotFrozen minInvestment payable returns(uint)  {\r\n\t\t\r\n\t\tuint amount = msg.value;\r\n\t\tif (amount == 0) throw;\r\n\t\t\r\n\t\tbalanceOf[msg.sender] += amount;\t\r\n\t\t\r\n\t\ttotalRaised += amount;\r\n\t\tcurrentBalance += amount;\r\n\t\t\t\t\t\t\r\n\t\tuint tokenAmount = getCurrentExchangeRate(amount);\r\n\t\texchangeToken.generateTokens(msg.sender, tokenAmount);\r\n\t\ttotalTokensIssued += tokenAmount;\r\n\t\tissuedTokenBalance += tokenAmount;\r\n\t\t\r\n\t\tFundTransfer(msg.sender, amount, true); \r\n\t\t\r\n\t\tcheckIfFundingCompleteOrExpired();\r\n\t\t\r\n\t\treturn balanceOf[msg.sender];\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "inState"
       Gas costs: 3
       Source: "inState(State.Fundraising)"
      Identifier inState
         Type: modifier (enum ClitCrowdFunder.State)
         Source: "inState"
      MemberAccess to member Fundraising
         Type: enum ClitCrowdFunder.State
         Source: "State.Fundraising"
        Identifier State
           Type: type(enum ClitCrowdFunder.State)
           Source: "State"
    ModifierInvocation "isStarted"
       Gas costs: 0
       Source: "isStarted"
      Identifier isStarted
         Type: modifier ()
         Source: "isStarted"
    ModifierInvocation "accountNotFrozen"
       Gas costs: 0
       Source: "accountNotFrozen"
      Identifier accountNotFrozen
         Type: modifier ()
         Source: "accountNotFrozen"
    ModifierInvocation "minInvestment"
       Gas costs: 0
       Source: "minInvestment"
      Identifier minInvestment
         Type: modifier ()
         Source: "minInvestment"
    Block
       Source: "{\r\n\t\t\r\n\t\tuint amount = msg.value;\r\n\t\tif (amount == 0) throw;\r\n\t\t\r\n\t\tbalanceOf[msg.sender] += amount;\t\r\n\t\t\r\n\t\ttotalRaised += amount;\r\n\t\tcurrentBalance += amount;\r\n\t\t\t\t\t\t\r\n\t\tuint tokenAmount = getCurrentExchangeRate(amount);\r\n\t\texchangeToken.generateTokens(msg.sender, tokenAmount);\r\n\t\ttotalTokensIssued += tokenAmount;\r\n\t\tissuedTokenBalance += tokenAmount;\r\n\t\t\r\n\t\tFundTransfer(msg.sender, amount, true); \r\n\t\t\r\n\t\tcheckIfFundingCompleteOrExpired();\r\n\t\t\r\n\t\treturn balanceOf[msg.sender];\r\n\t}"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint amount = msg.value"
        VariableDeclaration "amount"
           Type: uint256
           Source: "uint amount"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member value
           Type: uint256
           Source: "msg.value"
          Identifier msg
             Type: msg
             Source: "msg"
      IfStatement
         Source: "if (amount == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "amount == 0"
          Identifier amount
             Type: uint256
             Source: "amount"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20328
         Source: "balanceOf[msg.sender] += amount"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[msg.sender] += amount"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalRaised += amount"
        Assignment using operator +=
           Type: uint256
           Source: "totalRaised += amount"
          Identifier totalRaised
             Type: uint256
             Source: "totalRaised"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Gas costs: 20233
         Source: "currentBalance += amount"
        Assignment using operator +=
           Type: uint256
           Source: "currentBalance += amount"
          Identifier currentBalance
             Type: uint256
             Source: "currentBalance"
          Identifier amount
             Type: uint256
             Source: "amount"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint tokenAmount = getCurrentExchangeRate(amount)"
        VariableDeclaration "tokenAmount"
           Type: uint256
           Source: "uint tokenAmount"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getCurrentExchangeRate(amount)"
          Identifier getCurrentExchangeRate
             Type: function (uint256) view returns (uint256)
             Source: "getCurrentExchangeRate"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "exchangeToken.generateTokens(msg.sender, tokenAmount)"
        FunctionCall
           Type: bool
           Source: "exchangeToken.generateTokens(msg.sender, tokenAmount)"
          MemberAccess to member generateTokens
             Type: function (address,uint256) external returns (bool)
             Source: "exchangeToken.generateTokens"
            Identifier exchangeToken
               Type: contract ClitCoinToken
               Source: "exchangeToken"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier tokenAmount
             Type: uint256
             Source: "tokenAmount"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalTokensIssued += tokenAmount"
        Assignment using operator +=
           Type: uint256
           Source: "totalTokensIssued += tokenAmount"
          Identifier totalTokensIssued
             Type: uint256
             Source: "totalTokensIssued"
          Identifier tokenAmount
             Type: uint256
             Source: "tokenAmount"
      ExpressionStatement
         Gas costs: 20233
         Source: "issuedTokenBalance += tokenAmount"
        Assignment using operator +=
           Type: uint256
           Source: "issuedTokenBalance += tokenAmount"
          Identifier issuedTokenBalance
             Type: uint256
             Source: "issuedTokenBalance"
          Identifier tokenAmount
             Type: uint256
             Source: "tokenAmount"
      ExpressionStatement
         Gas costs: [???]
         Source: "FundTransfer(msg.sender, amount, true)"
        FunctionCall
           Type: tuple()
           Source: "FundTransfer(msg.sender, amount, true)"
          Identifier FundTransfer
             Type: function (address,uint256,bool)
             Source: "FundTransfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier amount
             Type: uint256
             Source: "amount"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 15
         Source: "checkIfFundingCompleteOrExpired()"
        FunctionCall
           Type: tuple()
           Source: "checkIfFundingCompleteOrExpired()"
          Identifier checkIfFundingCompleteOrExpired
             Type: function ()
             Source: "checkIfFundingCompleteOrExpired"
      Return
         Gas costs: 303
         Source: "return balanceOf[msg.sender]"
        IndexAccess
           Type: uint256
           Source: "balanceOf[msg.sender]"
          Identifier balanceOf
             Type: mapping(address => uint256)
             Source: "balanceOf"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "checkIfFundingCompleteOrExpired" - public
     Source: "function checkIfFundingCompleteOrExpired() {\r\n\t\tif (block.number > endBlockNumber || totalTokensIssued >= capTokenAmount ) {\r\n\t\t\t// Hard limit reached\r\n\t\t\tif (currentBalance > fundingGoal || fundingGoalReached == true) {\r\n\t\t\t\tstate = State.Successful;\r\n\t\t\t\tpayOut();\r\n\t\t\t\t\r\n\t\t\t\tHardCapReached(fundRecipient, totalRaised);\r\n\t\t\t\t\r\n\t\t\t\t// Contract can be immediately closed out\r\n\t\t\t\tremoveContract();\r\n\r\n\t\t\t} else  {\r\n\t\t\t\tstate = State.ExpiredRefund; // backers can now collect refunds by calling getRefund()\r\n\t\t\t\t\r\n\t\t\t\tRefundPeriodStarted();\r\n\t\t\t}\r\n\t\t} else if (currentBalance > fundingGoal && fundingGoalReached == false) {\r\n\t\t\t// Once goal reached\r\n\t\t\tfundingGoalReached = true;\r\n\t\t\t\r\n\t\t\tstate = State.Successful;\r\n\t\t\tpayOut();\r\n\t\t\t\r\n\t\t\t// Continue allowing users to buy in\r\n\t\t\tstate = State.Fundraising;\r\n\t\t\t\r\n\t\t\t// currentBalance is zero after pay out\r\n\t\t\tGoalReached(fundRecipient, totalRaised);\r\n\t\t}\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tif (block.number > endBlockNumber || totalTokensIssued >= capTokenAmount ) {\r\n\t\t\t// Hard limit reached\r\n\t\t\tif (currentBalance > fundingGoal || fundingGoalReached == true) {\r\n\t\t\t\tstate = State.Successful;\r\n\t\t\t\tpayOut();\r\n\t\t\t\t\r\n\t\t\t\tHardCapReached(fundRecipient, totalRaised);\r\n\t\t\t\t\r\n\t\t\t\t// Contract can be immediately closed out\r\n\t\t\t\tremoveContract();\r\n\r\n\t\t\t} else  {\r\n\t\t\t\tstate = State.ExpiredRefund; // backers can now collect refunds by calling getRefund()\r\n\t\t\t\t\r\n\t\t\t\tRefundPeriodStarted();\r\n\t\t\t}\r\n\t\t} else if (currentBalance > fundingGoal && fundingGoalReached == false) {\r\n\t\t\t// Once goal reached\r\n\t\t\tfundingGoalReached = true;\r\n\t\t\t\r\n\t\t\tstate = State.Successful;\r\n\t\t\tpayOut();\r\n\t\t\t\r\n\t\t\t// Continue allowing users to buy in\r\n\t\t\tstate = State.Fundraising;\r\n\t\t\t\r\n\t\t\t// currentBalance is zero after pay out\r\n\t\t\tGoalReached(fundRecipient, totalRaised);\r\n\t\t}\r\n\t}"
      IfStatement
         Source: "if (block.number > endBlockNumber || totalTokensIssued >= capTokenAmount ) {\r\n\t\t\t// Hard limit reached\r\n\t\t\tif (currentBalance > fundingGoal || fundingGoalReached == true) {\r\n\t\t\t\tstate = State.Successful;\r\n\t\t\t\tpayOut();\r\n\t\t\t\t\r\n\t\t\t\tHardCapReached(fundRecipient, totalRaised);\r\n\t\t\t\t\r\n\t\t\t\t// Contract can be immediately closed out\r\n\t\t\t\tremoveContract();\r\n\r\n\t\t\t} else  {\r\n\t\t\t\tstate = State.ExpiredRefund; // backers can now collect refunds by calling getRefund()\r\n\t\t\t\t\r\n\t\t\t\tRefundPeriodStarted();\r\n\t\t\t}\r\n\t\t} else if (currentBalance > fundingGoal && fundingGoalReached == false) {\r\n\t\t\t// Once goal reached\r\n\t\t\tfundingGoalReached = true;\r\n\t\t\t\r\n\t\t\tstate = State.Successful;\r\n\t\t\tpayOut();\r\n\t\t\t\r\n\t\t\t// Continue allowing users to buy in\r\n\t\t\tstate = State.Fundraising;\r\n\t\t\t\r\n\t\t\t// currentBalance is zero after pay out\r\n\t\t\tGoalReached(fundRecipient, totalRaised);\r\n\t\t}"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 639
           Source: "block.number > endBlockNumber || totalTokensIssued >= capTokenAmount"
          BinaryOperation using operator >
             Type: bool
             Source: "block.number > endBlockNumber"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier endBlockNumber
               Type: uint256
               Source: "endBlockNumber"
          BinaryOperation using operator >=
             Type: bool
             Source: "totalTokensIssued >= capTokenAmount"
            Identifier totalTokensIssued
               Type: uint256
               Source: "totalTokensIssued"
            Identifier capTokenAmount
               Type: uint256
               Source: "capTokenAmount"
        Block
           Source: "{\r\n\t\t\t// Hard limit reached\r\n\t\t\tif (currentBalance > fundingGoal || fundingGoalReached == true) {\r\n\t\t\t\tstate = State.Successful;\r\n\t\t\t\tpayOut();\r\n\t\t\t\t\r\n\t\t\t\tHardCapReached(fundRecipient, totalRaised);\r\n\t\t\t\t\r\n\t\t\t\t// Contract can be immediately closed out\r\n\t\t\t\tremoveContract();\r\n\r\n\t\t\t} else  {\r\n\t\t\t\tstate = State.ExpiredRefund; // backers can now collect refunds by calling getRefund()\r\n\t\t\t\t\r\n\t\t\t\tRefundPeriodStarted();\r\n\t\t\t}\r\n\t\t}"
          IfStatement
             Source: "if (currentBalance > fundingGoal || fundingGoalReached == true) {\r\n\t\t\t\tstate = State.Successful;\r\n\t\t\t\tpayOut();\r\n\t\t\t\t\r\n\t\t\t\tHardCapReached(fundRecipient, totalRaised);\r\n\t\t\t\t\r\n\t\t\t\t// Contract can be immediately closed out\r\n\t\t\t\tremoveContract();\r\n\r\n\t\t\t} else  {\r\n\t\t\t\tstate = State.ExpiredRefund; // backers can now collect refunds by calling getRefund()\r\n\t\t\t\t\r\n\t\t\t\tRefundPeriodStarted();\r\n\t\t\t}"
            BinaryOperation using operator ||
               Type: bool
               Gas costs: 685
               Source: "currentBalance > fundingGoal || fundingGoalReached == true"
              BinaryOperation using operator >
                 Type: bool
                 Source: "currentBalance > fundingGoal"
                Identifier currentBalance
                   Type: uint256
                   Source: "currentBalance"
                Identifier fundingGoal
                   Type: uint256
                   Source: "fundingGoal"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "fundingGoalReached == true"
                Identifier fundingGoalReached
                   Type: bool
                   Source: "fundingGoalReached"
                Literal, token: true value: true
                   Type: bool
                   Source: "true"
            Block
               Source: "{\r\n\t\t\t\tstate = State.Successful;\r\n\t\t\t\tpayOut();\r\n\t\t\t\t\r\n\t\t\t\tHardCapReached(fundRecipient, totalRaised);\r\n\t\t\t\t\r\n\t\t\t\t// Contract can be immediately closed out\r\n\t\t\t\tremoveContract();\r\n\r\n\t\t\t}"
              ExpressionStatement
                 Gas costs: 20337
                 Source: "state = State.Successful"
                Assignment using operator =
                   Type: enum ClitCrowdFunder.State
                   Source: "state = State.Successful"
                  Identifier state
                     Type: enum ClitCrowdFunder.State
                     Source: "state"
                  MemberAccess to member Successful
                     Type: enum ClitCrowdFunder.State
                     Source: "State.Successful"
                    Identifier State
                       Type: type(enum ClitCrowdFunder.State)
                       Source: "State"
              ExpressionStatement
                 Gas costs: 15
                 Source: "payOut()"
                FunctionCall
                   Type: tuple()
                   Source: "payOut()"
                  Identifier payOut
                     Type: function ()
                     Source: "payOut"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "HardCapReached(fundRecipient, totalRaised)"
                FunctionCall
                   Type: tuple()
                   Source: "HardCapReached(fundRecipient, totalRaised)"
                  Identifier HardCapReached
                     Type: function (address,uint256)
                     Source: "HardCapReached"
                  Identifier fundRecipient
                     Type: address
                     Source: "fundRecipient"
                  Identifier totalRaised
                     Type: uint256
                     Source: "totalRaised"
              ExpressionStatement
                 Gas costs: 15
                 Source: "removeContract()"
                FunctionCall
                   Type: tuple()
                   Source: "removeContract()"
                  Identifier removeContract
                     Type: function ()
                     Source: "removeContract"
            Block
               Source: "{\r\n\t\t\t\tstate = State.ExpiredRefund; // backers can now collect refunds by calling getRefund()\r\n\t\t\t\t\r\n\t\t\t\tRefundPeriodStarted();\r\n\t\t\t}"
              ExpressionStatement
                 Gas costs: 20337
                 Source: "state = State.ExpiredRefund"
                Assignment using operator =
                   Type: enum ClitCrowdFunder.State
                   Source: "state = State.ExpiredRefund"
                  Identifier state
                     Type: enum ClitCrowdFunder.State
                     Source: "state"
                  MemberAccess to member ExpiredRefund
                     Type: enum ClitCrowdFunder.State
                     Source: "State.ExpiredRefund"
                    Identifier State
                       Type: type(enum ClitCrowdFunder.State)
                       Source: "State"
              ExpressionStatement
                 Gas costs: 786
                 Source: "RefundPeriodStarted()"
                FunctionCall
                   Type: tuple()
                   Source: "RefundPeriodStarted()"
                  Identifier RefundPeriodStarted
                     Type: function ()
                     Source: "RefundPeriodStarted"
        IfStatement
           Source: "if (currentBalance > fundingGoal && fundingGoalReached == false) {\r\n\t\t\t// Once goal reached\r\n\t\t\tfundingGoalReached = true;\r\n\t\t\t\r\n\t\t\tstate = State.Successful;\r\n\t\t\tpayOut();\r\n\t\t\t\r\n\t\t\t// Continue allowing users to buy in\r\n\t\t\tstate = State.Fundraising;\r\n\t\t\t\r\n\t\t\t// currentBalance is zero after pay out\r\n\t\t\tGoalReached(fundRecipient, totalRaised);\r\n\t\t}"
          BinaryOperation using operator &&
             Type: bool
             Gas costs: 688
             Source: "currentBalance > fundingGoal && fundingGoalReached == false"
            BinaryOperation using operator >
               Type: bool
               Source: "currentBalance > fundingGoal"
              Identifier currentBalance
                 Type: uint256
                 Source: "currentBalance"
              Identifier fundingGoal
                 Type: uint256
                 Source: "fundingGoal"
            BinaryOperation using operator ==
               Type: bool
               Source: "fundingGoalReached == false"
              Identifier fundingGoalReached
                 Type: bool
                 Source: "fundingGoalReached"
              Literal, token: false value: false
                 Type: bool
                 Source: "false"
          Block
             Source: "{\r\n\t\t\t// Once goal reached\r\n\t\t\tfundingGoalReached = true;\r\n\t\t\t\r\n\t\t\tstate = State.Successful;\r\n\t\t\tpayOut();\r\n\t\t\t\r\n\t\t\t// Continue allowing users to buy in\r\n\t\t\tstate = State.Fundraising;\r\n\t\t\t\r\n\t\t\t// currentBalance is zero after pay out\r\n\t\t\tGoalReached(fundRecipient, totalRaised);\r\n\t\t}"
            ExpressionStatement
               Gas costs: 20267
               Source: "fundingGoalReached = true"
              Assignment using operator =
                 Type: bool
                 Source: "fundingGoalReached = true"
                Identifier fundingGoalReached
                   Type: bool
                   Source: "fundingGoalReached"
                Literal, token: true value: true
                   Type: bool
                   Source: "true"
            ExpressionStatement
               Gas costs: 20337
               Source: "state = State.Successful"
              Assignment using operator =
                 Type: enum ClitCrowdFunder.State
                 Source: "state = State.Successful"
                Identifier state
                   Type: enum ClitCrowdFunder.State
                   Source: "state"
                MemberAccess to member Successful
                   Type: enum ClitCrowdFunder.State
                   Source: "State.Successful"
                  Identifier State
                     Type: type(enum ClitCrowdFunder.State)
                     Source: "State"
            ExpressionStatement
               Gas costs: 15
               Source: "payOut()"
              FunctionCall
                 Type: tuple()
                 Source: "payOut()"
                Identifier payOut
                   Type: function ()
                   Source: "payOut"
            ExpressionStatement
               Gas costs: 20337
               Source: "state = State.Fundraising"
              Assignment using operator =
                 Type: enum ClitCrowdFunder.State
                 Source: "state = State.Fundraising"
                Identifier state
                   Type: enum ClitCrowdFunder.State
                   Source: "state"
                MemberAccess to member Fundraising
                   Type: enum ClitCrowdFunder.State
                   Source: "State.Fundraising"
                  Identifier State
                     Type: type(enum ClitCrowdFunder.State)
                     Source: "State"
            ExpressionStatement
               Gas costs: [???]
               Source: "GoalReached(fundRecipient, totalRaised)"
              FunctionCall
                 Type: tuple()
                 Source: "GoalReached(fundRecipient, totalRaised)"
                Identifier GoalReached
                   Type: function (address,uint256)
                   Source: "GoalReached"
                Identifier fundRecipient
                   Type: address
                   Source: "fundRecipient"
                Identifier totalRaised
                   Type: uint256
                   Source: "totalRaised"
  FunctionDefinition "payOut" - public
     Source: "function payOut() public inState(State.Successful) {\r\n\t\t// Ethereum balance\r\n\t\tvar amount = currentBalance;\r\n\t\tcurrentBalance = 0;\r\n\r\n\t\tfundRecipient.transfer(amount);\r\n\t\t\r\n\t\t// Update the token reserve amount so that 50% of tokens remain in reserve\r\n\t\tvar tokenCount = issuedTokenBalance;\r\n\t\tissuedTokenBalance = 0;\r\n\t\t\r\n\t\texchangeToken.generateTokens(fundRecipient, tokenCount);\t\t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "inState"
       Gas costs: 3
       Source: "inState(State.Successful)"
      Identifier inState
         Type: modifier (enum ClitCrowdFunder.State)
         Source: "inState"
      MemberAccess to member Successful
         Type: enum ClitCrowdFunder.State
         Source: "State.Successful"
        Identifier State
           Type: type(enum ClitCrowdFunder.State)
           Source: "State"
    Block
       Source: "{\r\n\t\t// Ethereum balance\r\n\t\tvar amount = currentBalance;\r\n\t\tcurrentBalance = 0;\r\n\r\n\t\tfundRecipient.transfer(amount);\r\n\t\t\r\n\t\t// Update the token reserve amount so that 50% of tokens remain in reserve\r\n\t\tvar tokenCount = issuedTokenBalance;\r\n\t\tissuedTokenBalance = 0;\r\n\t\t\r\n\t\texchangeToken.generateTokens(fundRecipient, tokenCount);\t\t\r\n\t}"
      VariableDeclarationStatement
         Gas costs: 211
         Source: "var amount = currentBalance"
        VariableDeclaration "amount"
           Type: uint256
           Source: "var amount"
        Identifier currentBalance
           Type: uint256
           Source: "currentBalance"
      ExpressionStatement
         Gas costs: 5014
         Source: "currentBalance = 0"
        Assignment using operator =
           Type: uint256
           Source: "currentBalance = 0"
          Identifier currentBalance
             Type: uint256
             Source: "currentBalance"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "fundRecipient.transfer(amount)"
        FunctionCall
           Type: tuple()
           Source: "fundRecipient.transfer(amount)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "fundRecipient.transfer"
            Identifier fundRecipient
               Type: address
               Source: "fundRecipient"
          Identifier amount
             Type: uint256
             Source: "amount"
      VariableDeclarationStatement
         Gas costs: 211
         Source: "var tokenCount = issuedTokenBalance"
        VariableDeclaration "tokenCount"
           Type: uint256
           Source: "var tokenCount"
        Identifier issuedTokenBalance
           Type: uint256
           Source: "issuedTokenBalance"
      ExpressionStatement
         Gas costs: 5014
         Source: "issuedTokenBalance = 0"
        Assignment using operator =
           Type: uint256
           Source: "issuedTokenBalance = 0"
          Identifier issuedTokenBalance
             Type: uint256
             Source: "issuedTokenBalance"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "exchangeToken.generateTokens(fundRecipient, tokenCount)"
        FunctionCall
           Type: bool
           Source: "exchangeToken.generateTokens(fundRecipient, tokenCount)"
          MemberAccess to member generateTokens
             Type: function (address,uint256) external returns (bool)
             Source: "exchangeToken.generateTokens"
            Identifier exchangeToken
               Type: contract ClitCoinToken
               Source: "exchangeToken"
          Identifier fundRecipient
             Type: address
             Source: "fundRecipient"
          Identifier tokenCount
             Type: uint256
             Source: "tokenCount"
  FunctionDefinition "getRefund" - public
     Source: "function getRefund() public inState(State.ExpiredRefund) {\t\r\n\t\tuint amountToRefund = balanceOf[msg.sender];\r\n\t\tbalanceOf[msg.sender] = 0;\r\n\t\t\r\n\t\t// throws error if fails\r\n\t\tmsg.sender.transfer(amountToRefund);\r\n\t\tcurrentBalance -= amountToRefund;\r\n\t\t\r\n\t\tFundTransfer(msg.sender, amountToRefund, false);\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "inState"
       Gas costs: 3
       Source: "inState(State.ExpiredRefund)"
      Identifier inState
         Type: modifier (enum ClitCrowdFunder.State)
         Source: "inState"
      MemberAccess to member ExpiredRefund
         Type: enum ClitCrowdFunder.State
         Source: "State.ExpiredRefund"
        Identifier State
           Type: type(enum ClitCrowdFunder.State)
           Source: "State"
    Block
       Source: "{\t\r\n\t\tuint amountToRefund = balanceOf[msg.sender];\r\n\t\tbalanceOf[msg.sender] = 0;\r\n\t\t\r\n\t\t// throws error if fails\r\n\t\tmsg.sender.transfer(amountToRefund);\r\n\t\tcurrentBalance -= amountToRefund;\r\n\t\t\r\n\t\tFundTransfer(msg.sender, amountToRefund, false);\r\n\t}"
      VariableDeclarationStatement
         Gas costs: 306
         Source: "uint amountToRefund = balanceOf[msg.sender]"
        VariableDeclaration "amountToRefund"
           Type: uint256
           Source: "uint amountToRefund"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "balanceOf[msg.sender]"
          Identifier balanceOf
             Type: mapping(address => uint256)
             Source: "balanceOf"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 5103
         Source: "balanceOf[msg.sender] = 0"
        Assignment using operator =
           Type: uint256
           Source: "balanceOf[msg.sender] = 0"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "msg.sender.transfer(amountToRefund)"
        FunctionCall
           Type: tuple()
           Source: "msg.sender.transfer(amountToRefund)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "msg.sender.transfer"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier amountToRefund
             Type: uint256
             Source: "amountToRefund"
      ExpressionStatement
         Gas costs: 20233
         Source: "currentBalance -= amountToRefund"
        Assignment using operator -=
           Type: uint256
           Source: "currentBalance -= amountToRefund"
          Identifier currentBalance
             Type: uint256
             Source: "currentBalance"
          Identifier amountToRefund
             Type: uint256
             Source: "amountToRefund"
      ExpressionStatement
         Gas costs: [???]
         Source: "FundTransfer(msg.sender, amountToRefund, false)"
        FunctionCall
           Type: tuple()
           Source: "FundTransfer(msg.sender, amountToRefund, false)"
          Identifier FundTransfer
             Type: function (address,uint256,bool)
             Source: "FundTransfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier amountToRefund
             Type: uint256
             Source: "amountToRefund"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "removeContract" - public
     Source: "function removeContract() public atEndOfLifecycle {\t\t\r\n\t\tstate = State.Closed;\r\n\t\t\r\n\t\t// Allow clit owners to freely trade coins on the open market\r\n\t\texchangeToken.enableTransfers(true);\r\n\t\t\r\n\t\t// Restore ownership to controller\r\n\t\texchangeToken.changeController(controller);\r\n\r\n\t\tselfdestruct(msg.sender);\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "atEndOfLifecycle"
       Gas costs: 0
       Source: "atEndOfLifecycle"
      Identifier atEndOfLifecycle
         Type: modifier ()
         Source: "atEndOfLifecycle"
    Block
       Source: "{\t\t\r\n\t\tstate = State.Closed;\r\n\t\t\r\n\t\t// Allow clit owners to freely trade coins on the open market\r\n\t\texchangeToken.enableTransfers(true);\r\n\t\t\r\n\t\t// Restore ownership to controller\r\n\t\texchangeToken.changeController(controller);\r\n\r\n\t\tselfdestruct(msg.sender);\r\n\t}"
      ExpressionStatement
         Gas costs: 20337
         Source: "state = State.Closed"
        Assignment using operator =
           Type: enum ClitCrowdFunder.State
           Source: "state = State.Closed"
          Identifier state
             Type: enum ClitCrowdFunder.State
             Source: "state"
          MemberAccess to member Closed
             Type: enum ClitCrowdFunder.State
             Source: "State.Closed"
            Identifier State
               Type: type(enum ClitCrowdFunder.State)
               Source: "State"
      ExpressionStatement
         Gas costs: [???]
         Source: "exchangeToken.enableTransfers(true)"
        FunctionCall
           Type: tuple()
           Source: "exchangeToken.enableTransfers(true)"
          MemberAccess to member enableTransfers
             Type: function (bool) external
             Source: "exchangeToken.enableTransfers"
            Identifier exchangeToken
               Type: contract ClitCoinToken
               Source: "exchangeToken"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: [???]
         Source: "exchangeToken.changeController(controller)"
        FunctionCall
           Type: tuple()
           Source: "exchangeToken.changeController(controller)"
          MemberAccess to member changeController
             Type: function (address) external
             Source: "exchangeToken.changeController"
            Identifier exchangeToken
               Type: contract ClitCoinToken
               Source: "exchangeToken"
          Identifier controller
             Type: address
             Source: "controller"
      ExpressionStatement
         Gas costs: 30008
         Source: "selfdestruct(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "selfdestruct(msg.sender)"
          Identifier selfdestruct
             Type: function (address)
             Source: "selfdestruct"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "" - public
     Source: "function () payable { \r\n\t\tinvestment(); \r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ \r\n\t\tinvestment(); \r\n\t}"
      ExpressionStatement
         Gas costs: 6
         Source: "investment()"
        FunctionCall
           Type: uint256
           Source: "investment()"
          Identifier investment
             Type: function () returns (uint256)
             Source: "investment"
