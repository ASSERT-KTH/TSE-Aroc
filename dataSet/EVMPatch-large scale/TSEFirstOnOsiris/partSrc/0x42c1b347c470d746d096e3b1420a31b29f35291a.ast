Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x42c1b347c470d746d096e3b1420a31b29f35291a.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.14;"
ContractDefinition "MultiSigWallet"
   Source: "contract MultiSigWallet {\r\n\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint required);\r\n\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n\r\n    modifier onlyWallet() {\r\n        if (msg.sender != address(this))\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        if (isOwner[owner])\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        if (!isOwner[owner])\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        if (transactions[transactionId].destination == 0)\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        if (!confirmations[transactionId][owner])\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        if (confirmations[transactionId][owner])\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        if (transactions[transactionId].executed)\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        if (_address == 0)\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        if (   ownerCount > MAX_OWNER_COUNT\r\n            || _required > ownerCount\r\n            || _required == 0\r\n            || ownerCount == 0)\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function allows to deposit ether.\r\n    function()\r\n        payable\r\n    {\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    function MultiSigWallet(address[] _owners, uint _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            if (isOwner[_owners[i]] || _owners[i] == 0)\r\n                throw;\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of new owner.\r\n    function addOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerDoesNotExist(owner)\r\n        notNull(owner)\r\n        validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAddition(owner);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner.\r\n    function removeOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        OwnerRemoval(owner);\r\n    }\r\n\r\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner to be replaced.\r\n    /// @param owner Address of new owner.\r\n    function replaceOwner(address owner, address newOwner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n        ownerDoesNotExist(newOwner)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        OwnerRemoval(owner);\r\n        OwnerAddition(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n    /// @param _required Number of required confirmations.\r\n    function changeRequirement(uint _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        RequirementChange(_required);\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes data)\r\n        public\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n        public\r\n        notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction tx = transactions[transactionId];\r\n            tx.executed = true;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes data)\r\n        internal\r\n        notNull(destination)\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        Submission(transactionId);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n        public\r\n        constant\r\n        returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n}"
  VariableDeclaration "MAX_OWNER_COUNT"
     Type: uint256
     Gas costs: [???]
     Source: "uint constant public MAX_OWNER_COUNT = 50"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 50
       Type: int_const 50
       Source: "50"
  EventDefinition "Confirmation"
     Gas costs: 0
     Source: "event Confirmation(address indexed sender, uint indexed transactionId);"
    ParameterList
       Source: "(address indexed sender, uint indexed transactionId)"
      VariableDeclaration "sender"
         Type: address
         Source: "address indexed sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint indexed transactionId"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Revocation"
     Gas costs: 0
     Source: "event Revocation(address indexed sender, uint indexed transactionId);"
    ParameterList
       Source: "(address indexed sender, uint indexed transactionId)"
      VariableDeclaration "sender"
         Type: address
         Source: "address indexed sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint indexed transactionId"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Submission"
     Gas costs: 0
     Source: "event Submission(uint indexed transactionId);"
    ParameterList
       Source: "(uint indexed transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint indexed transactionId"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Execution"
     Gas costs: 0
     Source: "event Execution(uint indexed transactionId);"
    ParameterList
       Source: "(uint indexed transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint indexed transactionId"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "ExecutionFailure"
     Gas costs: 0
     Source: "event ExecutionFailure(uint indexed transactionId);"
    ParameterList
       Source: "(uint indexed transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint indexed transactionId"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Deposit"
     Gas costs: 0
     Source: "event Deposit(address indexed sender, uint value);"
    ParameterList
       Source: "(address indexed sender, uint value)"
      VariableDeclaration "sender"
         Type: address
         Source: "address indexed sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "OwnerAddition"
     Gas costs: 0
     Source: "event OwnerAddition(address indexed owner);"
    ParameterList
       Source: "(address indexed owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "OwnerRemoval"
     Gas costs: 0
     Source: "event OwnerRemoval(address indexed owner);"
    ParameterList
       Source: "(address indexed owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "RequirementChange"
     Gas costs: 0
     Source: "event RequirementChange(uint required);"
    ParameterList
       Source: "(uint required)"
      VariableDeclaration "required"
         Type: uint256
         Source: "uint required"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "transactions"
     Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
     Gas costs: [???]
     Source: "mapping (uint => Transaction) public transactions"
    Mapping
       Source: "mapping (uint => Transaction)"
      ElementaryTypeName uint
         Source: "uint"
      UserDefinedTypeName "Transaction"
         Source: "Transaction"
  VariableDeclaration "confirmations"
     Type: mapping(uint256 => mapping(address => bool))
     Gas costs: [???]
     Source: "mapping (uint => mapping (address => bool)) public confirmations"
    Mapping
       Source: "mapping (uint => mapping (address => bool))"
      ElementaryTypeName uint
         Source: "uint"
      Mapping
         Source: "mapping (address => bool)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName bool
           Source: "bool"
  VariableDeclaration "isOwner"
     Type: mapping(address => bool)
     Gas costs: [???]
     Source: "mapping (address => bool) public isOwner"
    Mapping
       Source: "mapping (address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "owners"
     Type: address[] storage ref
     Gas costs: [???]
     Source: "address[] public owners"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "required"
     Type: uint256
     Gas costs: [???]
     Source: "uint public required"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "transactionCount"
     Type: uint256
     Gas costs: [???]
     Source: "uint public transactionCount"
    ElementaryTypeName uint
       Source: "uint"
  StructDefinition "Transaction"
     Gas costs: 0
     Source: "struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }"
    VariableDeclaration "destination"
       Type: address
       Source: "address destination"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "value"
       Type: uint256
       Source: "uint value"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "data"
       Type: bytes storage pointer
       Source: "bytes data"
      ElementaryTypeName bytes
         Source: "bytes"
    VariableDeclaration "executed"
       Type: bool
       Source: "bool executed"
      ElementaryTypeName bool
         Source: "bool"
  ModifierDefinition "onlyWallet"
     Source: "modifier onlyWallet() {\r\n        if (msg.sender != address(this))\r\n            throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        if (msg.sender != address(this))\r\n            throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (msg.sender != address(this))\r\n            throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 110
           Source: "msg.sender != address(this)"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          FunctionCall
             Type: address
             Source: "address(this)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier this
               Type: contract MultiSigWallet
               Source: "this"
        Throw
           Gas costs: 30
           Source: "throw"
      PlaceholderStatement
         Gas costs: 10
         Source: "_"
  ModifierDefinition "ownerDoesNotExist"
     Source: "modifier ownerDoesNotExist(address owner) {\r\n        if (isOwner[owner])\r\n            throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        if (isOwner[owner])\r\n            throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (isOwner[owner])\r\n            throw"
        IndexAccess
           Type: bool
           Gas costs: 670
           Source: "isOwner[owner]"
          Identifier isOwner
             Type: mapping(address => bool)
             Source: "isOwner"
          Identifier owner
             Type: address
             Source: "owner"
        Throw
           Gas costs: 12
           Source: "throw"
      PlaceholderStatement
         Gas costs: 2
         Source: "_"
  ModifierDefinition "ownerExists"
     Source: "modifier ownerExists(address owner) {\r\n        if (!isOwner[owner])\r\n            throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        if (!isOwner[owner])\r\n            throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (!isOwner[owner])\r\n            throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 1352
           Source: "!isOwner[owner]"
          IndexAccess
             Type: bool
             Source: "isOwner[owner]"
            Identifier isOwner
               Type: mapping(address => bool)
               Source: "isOwner"
            Identifier owner
               Type: address
               Source: "owner"
        Throw
           Gas costs: 24
           Source: "throw"
      PlaceholderStatement
         Gas costs: 8
         Source: "_"
  ModifierDefinition "transactionExists"
     Source: "modifier transactionExists(uint transactionId) {\r\n        if (transactions[transactionId].destination == 0)\r\n            throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (transactions[transactionId].destination == 0)\r\n            throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (transactions[transactionId].destination == 0)\r\n            throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 341
           Source: "transactions[transactionId].destination == 0"
          MemberAccess to member destination
             Type: address
             Source: "transactions[transactionId].destination"
            IndexAccess
               Type: struct MultiSigWallet.Transaction storage ref
               Source: "transactions[transactionId]"
              Identifier transactions
                 Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
                 Source: "transactions"
              Identifier transactionId
                 Type: uint256
                 Source: "transactionId"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      PlaceholderStatement
         Gas costs: 4
         Source: "_"
  ModifierDefinition "confirmed"
     Source: "modifier confirmed(uint transactionId, address owner) {\r\n        if (!confirmations[transactionId][owner])\r\n            throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId, address owner)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        if (!confirmations[transactionId][owner])\r\n            throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (!confirmations[transactionId][owner])\r\n            throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 416
           Source: "!confirmations[transactionId][owner]"
          IndexAccess
             Type: bool
             Source: "confirmations[transactionId][owner]"
            IndexAccess
               Type: mapping(address => bool)
               Source: "confirmations[transactionId]"
              Identifier confirmations
                 Type: mapping(uint256 => mapping(address => bool))
                 Source: "confirmations"
              Identifier transactionId
                 Type: uint256
                 Source: "transactionId"
            Identifier owner
               Type: address
               Source: "owner"
        Throw
           Gas costs: 6
           Source: "throw"
      PlaceholderStatement
         Gas costs: 2
         Source: "_"
  ModifierDefinition "notConfirmed"
     Source: "modifier notConfirmed(uint transactionId, address owner) {\r\n        if (confirmations[transactionId][owner])\r\n            throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId, address owner)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        if (confirmations[transactionId][owner])\r\n            throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (confirmations[transactionId][owner])\r\n            throw"
        IndexAccess
           Type: bool
           Gas costs: 413
           Source: "confirmations[transactionId][owner]"
          IndexAccess
             Type: mapping(address => bool)
             Source: "confirmations[transactionId]"
            Identifier confirmations
               Type: mapping(uint256 => mapping(address => bool))
               Source: "confirmations"
            Identifier transactionId
               Type: uint256
               Source: "transactionId"
          Identifier owner
             Type: address
             Source: "owner"
        Throw
           Gas costs: 6
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "notExecuted"
     Source: "modifier notExecuted(uint transactionId) {\r\n        if (transactions[transactionId].executed)\r\n            throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (transactions[transactionId].executed)\r\n            throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (transactions[transactionId].executed)\r\n            throw"
        MemberAccess to member executed
           Type: bool
           Gas costs: 658
           Source: "transactions[transactionId].executed"
          IndexAccess
             Type: struct MultiSigWallet.Transaction storage ref
             Source: "transactions[transactionId]"
            Identifier transactions
               Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
               Source: "transactions"
            Identifier transactionId
               Type: uint256
               Source: "transactionId"
        Throw
           Gas costs: 12
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "notNull"
     Source: "modifier notNull(address _address) {\r\n        if (_address == 0)\r\n            throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        if (_address == 0)\r\n            throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (_address == 0)\r\n            throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 30
           Source: "_address == 0"
          Identifier _address
             Type: address
             Source: "_address"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 12
           Source: "throw"
      PlaceholderStatement
         Gas costs: 4
         Source: "_"
  ModifierDefinition "validRequirement"
     Source: "modifier validRequirement(uint ownerCount, uint _required) {\r\n        if (   ownerCount > MAX_OWNER_COUNT\r\n            || _required > ownerCount\r\n            || _required == 0\r\n            || ownerCount == 0)\r\n            throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint ownerCount, uint _required)"
      VariableDeclaration "ownerCount"
         Type: uint256
         Source: "uint ownerCount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_required"
         Type: uint256
         Source: "uint _required"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (   ownerCount > MAX_OWNER_COUNT\r\n            || _required > ownerCount\r\n            || _required == 0\r\n            || ownerCount == 0)\r\n            throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (   ownerCount > MAX_OWNER_COUNT\r\n            || _required > ownerCount\r\n            || _required == 0\r\n            || ownerCount == 0)\r\n            throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 180
           Source: "ownerCount > MAX_OWNER_COUNT\r\n            || _required > ownerCount\r\n            || _required == 0\r\n            || ownerCount == 0"
          BinaryOperation using operator ||
             Type: bool
             Source: "ownerCount > MAX_OWNER_COUNT\r\n            || _required > ownerCount\r\n            || _required == 0"
            BinaryOperation using operator ||
               Type: bool
               Source: "ownerCount > MAX_OWNER_COUNT\r\n            || _required > ownerCount"
              BinaryOperation using operator >
                 Type: bool
                 Source: "ownerCount > MAX_OWNER_COUNT"
                Identifier ownerCount
                   Type: uint256
                   Source: "ownerCount"
                Identifier MAX_OWNER_COUNT
                   Type: uint256
                   Source: "MAX_OWNER_COUNT"
              BinaryOperation using operator >
                 Type: bool
                 Source: "_required > ownerCount"
                Identifier _required
                   Type: uint256
                   Source: "_required"
                Identifier ownerCount
                   Type: uint256
                   Source: "ownerCount"
            BinaryOperation using operator ==
               Type: bool
               Source: "_required == 0"
              Identifier _required
                 Type: uint256
                 Source: "_required"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          BinaryOperation using operator ==
             Type: bool
             Source: "ownerCount == 0"
            Identifier ownerCount
               Type: uint256
               Source: "ownerCount"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Throw
           Gas costs: 12
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "" - public
     Source: "function()\r\n        payable\r\n    {\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }"
      IfStatement
         Source: "if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value)"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 8
           Source: "msg.value > 0"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: [???]
           Source: "Deposit(msg.sender, msg.value)"
          FunctionCall
             Type: tuple()
             Source: "Deposit(msg.sender, msg.value)"
            Identifier Deposit
               Type: function (address,uint256)
               Source: "Deposit"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "MultiSigWallet" - public
     Source: "function MultiSigWallet(address[] _owners, uint _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            if (isOwner[_owners[i]] || _owners[i] == 0)\r\n                throw;\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _owners, uint _required)"
      VariableDeclaration "_owners"
         Type: address[] memory
         Source: "address[] _owners"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_required"
         Type: uint256
         Source: "uint _required"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "validRequirement"
       Gas costs: 0
       Source: "validRequirement(_owners.length, _required)"
      Identifier validRequirement
         Type: modifier (uint256,uint256)
         Source: "validRequirement"
      MemberAccess to member length
         Type: uint256
         Source: "_owners.length"
        Identifier _owners
           Type: address[] memory
           Source: "_owners"
      Identifier _required
         Type: uint256
         Source: "_required"
    Block
       Source: "{\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            if (isOwner[_owners[i]] || _owners[i] == 0)\r\n                throw;\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }"
      ForStatement
         Source: "for (uint i=0; i<_owners.length; i++) {\r\n            if (isOwner[_owners[i]] || _owners[i] == 0)\r\n                throw;\r\n            isOwner[_owners[i]] = true;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i<_owners.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_owners.length"
            Identifier _owners
               Type: address[] memory
               Source: "_owners"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (isOwner[_owners[i]] || _owners[i] == 0)\r\n                throw;\r\n            isOwner[_owners[i]] = true;\r\n        }"
          IfStatement
             Source: "if (isOwner[_owners[i]] || _owners[i] == 0)\r\n                throw"
            BinaryOperation using operator ||
               Type: bool
               Gas costs: 0
               Source: "isOwner[_owners[i]] || _owners[i] == 0"
              IndexAccess
                 Type: bool
                 Source: "isOwner[_owners[i]]"
                Identifier isOwner
                   Type: mapping(address => bool)
                   Source: "isOwner"
                IndexAccess
                   Type: address
                   Source: "_owners[i]"
                  Identifier _owners
                     Type: address[] memory
                     Source: "_owners"
                  Identifier i
                     Type: uint256
                     Source: "i"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "_owners[i] == 0"
                IndexAccess
                   Type: address
                   Source: "_owners[i]"
                  Identifier _owners
                     Type: address[] memory
                     Source: "_owners"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            Throw
               Gas costs: 0
               Source: "throw"
          ExpressionStatement
             Gas costs: 0
             Source: "isOwner[_owners[i]] = true"
            Assignment using operator =
               Type: bool
               Source: "isOwner[_owners[i]] = true"
              IndexAccess
                 Type: bool
                 Source: "isOwner[_owners[i]]"
                Identifier isOwner
                   Type: mapping(address => bool)
                   Source: "isOwner"
                IndexAccess
                   Type: address
                   Source: "_owners[i]"
                  Identifier _owners
                     Type: address[] memory
                     Source: "_owners"
                  Identifier i
                     Type: uint256
                     Source: "i"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "owners = _owners"
        Assignment using operator =
           Type: address[] storage ref
           Source: "owners = _owners"
          Identifier owners
             Type: address[] storage ref
             Source: "owners"
          Identifier _owners
             Type: address[] memory
             Source: "_owners"
      ExpressionStatement
         Gas costs: 0
         Source: "required = _required"
        Assignment using operator =
           Type: uint256
           Source: "required = _required"
          Identifier required
             Type: uint256
             Source: "required"
          Identifier _required
             Type: uint256
             Source: "_required"
  FunctionDefinition "addOwner" - public
     Source: "function addOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerDoesNotExist(owner)\r\n        notNull(owner)\r\n        validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAddition(owner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyWallet"
       Gas costs: 0
       Source: "onlyWallet"
      Identifier onlyWallet
         Type: modifier ()
         Source: "onlyWallet"
    ModifierInvocation "ownerDoesNotExist"
       Gas costs: 3
       Source: "ownerDoesNotExist(owner)"
      Identifier ownerDoesNotExist
         Type: modifier (address)
         Source: "ownerDoesNotExist"
      Identifier owner
         Type: address
         Source: "owner"
    ModifierInvocation "notNull"
       Gas costs: 3
       Source: "notNull(owner)"
      Identifier notNull
         Type: modifier (address)
         Source: "notNull"
      Identifier owner
         Type: address
         Source: "owner"
    ModifierInvocation "validRequirement"
       Gas costs: 420
       Source: "validRequirement(owners.length + 1, required)"
      Identifier validRequirement
         Type: modifier (uint256,uint256)
         Source: "validRequirement"
      BinaryOperation using operator +
         Type: uint256
         Source: "owners.length + 1"
        MemberAccess to member length
           Type: uint256
           Source: "owners.length"
          Identifier owners
             Type: address[] storage ref
             Source: "owners"
        Literal, token: [no token] value: 1
           Type: int_const 1
           Source: "1"
      Identifier required
         Type: uint256
         Source: "required"
    Block
       Source: "{\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAddition(owner);\r\n    }"
      ExpressionStatement
         Gas costs: 20363
         Source: "isOwner[owner] = true"
        Assignment using operator =
           Type: bool
           Source: "isOwner[owner] = true"
          IndexAccess
             Type: bool
             Source: "isOwner[owner]"
            Identifier isOwner
               Type: mapping(address => bool)
               Source: "isOwner"
            Identifier owner
               Type: address
               Source: "owner"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 20362
         Source: "owners.push(owner)"
        FunctionCall
           Type: uint256
           Source: "owners.push(owner)"
          MemberAccess to member push
             Type: function (address) returns (uint256)
             Source: "owners.push"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
          Identifier owner
             Type: address
             Source: "owner"
      ExpressionStatement
         Gas costs: 1164
         Source: "OwnerAddition(owner)"
        FunctionCall
           Type: tuple()
           Source: "OwnerAddition(owner)"
          Identifier OwnerAddition
             Type: function (address)
             Source: "OwnerAddition"
          Identifier owner
             Type: address
             Source: "owner"
  FunctionDefinition "removeOwner" - public
     Source: "function removeOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        OwnerRemoval(owner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyWallet"
       Gas costs: 0
       Source: "onlyWallet"
      Identifier onlyWallet
         Type: modifier ()
         Source: "onlyWallet"
    ModifierInvocation "ownerExists"
       Gas costs: 3
       Source: "ownerExists(owner)"
      Identifier ownerExists
         Type: modifier (address)
         Source: "ownerExists"
      Identifier owner
         Type: address
         Source: "owner"
    Block
       Source: "{\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        OwnerRemoval(owner);\r\n    }"
      ExpressionStatement
         Gas costs: 20363
         Source: "isOwner[owner] = false"
        Assignment using operator =
           Type: bool
           Source: "isOwner[owner] = false"
          IndexAccess
             Type: bool
             Source: "isOwner[owner]"
            Identifier isOwner
               Type: mapping(address => bool)
               Source: "isOwner"
            Identifier owner
               Type: address
               Source: "owner"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ForStatement
         Source: "for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 223
           Source: "i<owners.length - 1"
          Identifier i
             Type: uint256
             Source: "i"
          BinaryOperation using operator -
             Type: uint256
             Source: "owners.length - 1"
            MemberAccess to member length
               Type: uint256
               Source: "owners.length"
              Identifier owners
                 Type: address[] storage ref
                 Source: "owners"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 546
             Source: "owners[i] == owner"
            IndexAccess
               Type: address
               Source: "owners[i]"
              Identifier owners
                 Type: address[] storage ref
                 Source: "owners"
              Identifier i
                 Type: uint256
                 Source: "i"
            Identifier owner
               Type: address
               Source: "owner"
          Block
             Source: "{\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }"
            ExpressionStatement
               Gas costs: 21295
               Source: "owners[i] = owners[owners.length - 1]"
              Assignment using operator =
                 Type: address
                 Source: "owners[i] = owners[owners.length - 1]"
                IndexAccess
                   Type: address
                   Source: "owners[i]"
                  Identifier owners
                     Type: address[] storage ref
                     Source: "owners"
                  Identifier i
                     Type: uint256
                     Source: "i"
                IndexAccess
                   Type: address
                   Source: "owners[owners.length - 1]"
                  Identifier owners
                     Type: address[] storage ref
                     Source: "owners"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "owners.length - 1"
                    MemberAccess to member length
                       Type: uint256
                       Source: "owners.length"
                      Identifier owners
                         Type: address[] storage ref
                         Source: "owners"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
            Break
               Gas costs: 0
               Source: "break"
      ExpressionStatement
         Gas costs: 243
         Source: "owners.length -= 1"
        Assignment using operator -=
           Type: uint256
           Source: "owners.length -= 1"
          MemberAccess to member length
             Type: uint256
             Source: "owners.length"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      IfStatement
         Source: "if (required > owners.length)\r\n            changeRequirement(owners.length)"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 417
           Source: "required > owners.length"
          Identifier required
             Type: uint256
             Source: "required"
          MemberAccess to member length
             Type: uint256
             Source: "owners.length"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
        ExpressionStatement
           Gas costs: 226
           Source: "changeRequirement(owners.length)"
          FunctionCall
             Type: tuple()
             Source: "changeRequirement(owners.length)"
            Identifier changeRequirement
               Type: function (uint256)
               Source: "changeRequirement"
            MemberAccess to member length
               Type: uint256
               Source: "owners.length"
              Identifier owners
                 Type: address[] storage ref
                 Source: "owners"
      ExpressionStatement
         Gas costs: 1170
         Source: "OwnerRemoval(owner)"
        FunctionCall
           Type: tuple()
           Source: "OwnerRemoval(owner)"
          Identifier OwnerRemoval
             Type: function (address)
             Source: "OwnerRemoval"
          Identifier owner
             Type: address
             Source: "owner"
  FunctionDefinition "replaceOwner" - public
     Source: "function replaceOwner(address owner, address newOwner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n        ownerDoesNotExist(newOwner)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        OwnerRemoval(owner);\r\n        OwnerAddition(newOwner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address owner, address newOwner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyWallet"
       Gas costs: 0
       Source: "onlyWallet"
      Identifier onlyWallet
         Type: modifier ()
         Source: "onlyWallet"
    ModifierInvocation "ownerExists"
       Gas costs: 3
       Source: "ownerExists(owner)"
      Identifier ownerExists
         Type: modifier (address)
         Source: "ownerExists"
      Identifier owner
         Type: address
         Source: "owner"
    ModifierInvocation "ownerDoesNotExist"
       Gas costs: 3
       Source: "ownerDoesNotExist(newOwner)"
      Identifier ownerDoesNotExist
         Type: modifier (address)
         Source: "ownerDoesNotExist"
      Identifier newOwner
         Type: address
         Source: "newOwner"
    Block
       Source: "{\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        OwnerRemoval(owner);\r\n        OwnerAddition(newOwner);\r\n    }"
      ForStatement
         Source: "for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 217
           Source: "i<owners.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "owners.length"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 546
             Source: "owners[i] == owner"
            IndexAccess
               Type: address
               Source: "owners[i]"
              Identifier owners
                 Type: address[] storage ref
                 Source: "owners"
              Identifier i
                 Type: uint256
                 Source: "i"
            Identifier owner
               Type: address
               Source: "owner"
          Block
             Source: "{\r\n                owners[i] = newOwner;\r\n                break;\r\n            }"
            ExpressionStatement
               Gas costs: 20556
               Source: "owners[i] = newOwner"
              Assignment using operator =
                 Type: address
                 Source: "owners[i] = newOwner"
                IndexAccess
                   Type: address
                   Source: "owners[i]"
                  Identifier owners
                     Type: address[] storage ref
                     Source: "owners"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Identifier newOwner
                   Type: address
                   Source: "newOwner"
            Break
               Gas costs: 0
               Source: "break"
      ExpressionStatement
         Gas costs: 20363
         Source: "isOwner[owner] = false"
        Assignment using operator =
           Type: bool
           Source: "isOwner[owner] = false"
          IndexAccess
             Type: bool
             Source: "isOwner[owner]"
            Identifier isOwner
               Type: mapping(address => bool)
               Source: "isOwner"
            Identifier owner
               Type: address
               Source: "owner"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 20357
         Source: "isOwner[newOwner] = true"
        Assignment using operator =
           Type: bool
           Source: "isOwner[newOwner] = true"
          IndexAccess
             Type: bool
             Source: "isOwner[newOwner]"
            Identifier isOwner
               Type: mapping(address => bool)
               Source: "isOwner"
            Identifier newOwner
               Type: address
               Source: "newOwner"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 1164
         Source: "OwnerRemoval(owner)"
        FunctionCall
           Type: tuple()
           Source: "OwnerRemoval(owner)"
          Identifier OwnerRemoval
             Type: function (address)
             Source: "OwnerRemoval"
          Identifier owner
             Type: address
             Source: "owner"
      ExpressionStatement
         Gas costs: 1161
         Source: "OwnerAddition(newOwner)"
        FunctionCall
           Type: tuple()
           Source: "OwnerAddition(newOwner)"
          Identifier OwnerAddition
             Type: function (address)
             Source: "OwnerAddition"
          Identifier newOwner
             Type: address
             Source: "newOwner"
  FunctionDefinition "changeRequirement" - public
     Source: "function changeRequirement(uint _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        RequirementChange(_required);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _required)"
      VariableDeclaration "_required"
         Type: uint256
         Source: "uint _required"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyWallet"
       Gas costs: 0
       Source: "onlyWallet"
      Identifier onlyWallet
         Type: modifier ()
         Source: "onlyWallet"
    ModifierInvocation "validRequirement"
       Gas costs: 214
       Source: "validRequirement(owners.length, _required)"
      Identifier validRequirement
         Type: modifier (uint256,uint256)
         Source: "validRequirement"
      MemberAccess to member length
         Type: uint256
         Source: "owners.length"
        Identifier owners
           Type: address[] storage ref
           Source: "owners"
      Identifier _required
         Type: uint256
         Source: "_required"
    Block
       Source: "{\r\n        required = _required;\r\n        RequirementChange(_required);\r\n    }"
      ExpressionStatement
         Gas costs: 20014
         Source: "required = _required"
        Assignment using operator =
           Type: uint256
           Source: "required = _required"
          Identifier required
             Type: uint256
             Source: "required"
          Identifier _required
             Type: uint256
             Source: "_required"
      ExpressionStatement
         Gas costs: [???]
         Source: "RequirementChange(_required)"
        FunctionCall
           Type: tuple()
           Source: "RequirementChange(_required)"
          Identifier RequirementChange
             Type: function (uint256)
             Source: "RequirementChange"
          Identifier _required
             Type: uint256
             Source: "_required"
  FunctionDefinition "submitTransaction" - public
     Source: "function submitTransaction(address destination, uint value, bytes data)\r\n        public\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address destination, uint value, bytes data)"
      VariableDeclaration "destination"
         Type: address
         Source: "address destination"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "data"
         Type: bytes memory
         Source: "bytes data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }"
      ExpressionStatement
         Gas costs: 18
         Source: "transactionId = addTransaction(destination, value, data)"
        Assignment using operator =
           Type: uint256
           Source: "transactionId = addTransaction(destination, value, data)"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
          FunctionCall
             Type: uint256
             Source: "addTransaction(destination, value, data)"
            Identifier addTransaction
               Type: function (address,uint256,bytes memory) returns (uint256)
               Source: "addTransaction"
            Identifier destination
               Type: address
               Source: "destination"
            Identifier value
               Type: uint256
               Source: "value"
            Identifier data
               Type: bytes memory
               Source: "data"
      ExpressionStatement
         Gas costs: 18
         Source: "confirmTransaction(transactionId)"
        FunctionCall
           Type: tuple()
           Source: "confirmTransaction(transactionId)"
          Identifier confirmTransaction
             Type: function (uint256)
             Source: "confirmTransaction"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
  FunctionDefinition "confirmTransaction" - public
     Source: "function confirmTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerExists"
       Gas costs: 2
       Source: "ownerExists(msg.sender)"
      Identifier ownerExists
         Type: modifier (address)
         Source: "ownerExists"
      MemberAccess to member sender
         Type: address
         Source: "msg.sender"
        Identifier msg
           Type: msg
           Source: "msg"
    ModifierInvocation "transactionExists"
       Gas costs: 3
       Source: "transactionExists(transactionId)"
      Identifier transactionExists
         Type: modifier (uint256)
         Source: "transactionExists"
      Identifier transactionId
         Type: uint256
         Source: "transactionId"
    ModifierInvocation "notConfirmed"
       Gas costs: 5
       Source: "notConfirmed(transactionId, msg.sender)"
      Identifier notConfirmed
         Type: modifier (uint256,address)
         Source: "notConfirmed"
      Identifier transactionId
         Type: uint256
         Source: "transactionId"
      MemberAccess to member sender
         Type: address
         Source: "msg.sender"
        Identifier msg
           Type: msg
           Source: "msg"
    Block
       Source: "{\r\n        confirmations[transactionId][msg.sender] = true;\r\n        Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }"
      ExpressionStatement
         Gas costs: 20440
         Source: "confirmations[transactionId][msg.sender] = true"
        Assignment using operator =
           Type: bool
           Source: "confirmations[transactionId][msg.sender] = true"
          IndexAccess
             Type: bool
             Source: "confirmations[transactionId][msg.sender]"
            IndexAccess
               Type: mapping(address => bool)
               Source: "confirmations[transactionId]"
              Identifier confirmations
                 Type: mapping(uint256 => mapping(address => bool))
                 Source: "confirmations"
              Identifier transactionId
                 Type: uint256
                 Source: "transactionId"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 1541
         Source: "Confirmation(msg.sender, transactionId)"
        FunctionCall
           Type: tuple()
           Source: "Confirmation(msg.sender, transactionId)"
          Identifier Confirmation
             Type: function (address,uint256)
             Source: "Confirmation"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
      ExpressionStatement
         Gas costs: 18
         Source: "executeTransaction(transactionId)"
        FunctionCall
           Type: tuple()
           Source: "executeTransaction(transactionId)"
          Identifier executeTransaction
             Type: function (uint256)
             Source: "executeTransaction"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
  FunctionDefinition "revokeConfirmation" - public
     Source: "function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        Revocation(msg.sender, transactionId);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerExists"
       Gas costs: 2
       Source: "ownerExists(msg.sender)"
      Identifier ownerExists
         Type: modifier (address)
         Source: "ownerExists"
      MemberAccess to member sender
         Type: address
         Source: "msg.sender"
        Identifier msg
           Type: msg
           Source: "msg"
    ModifierInvocation "confirmed"
       Gas costs: 5
       Source: "confirmed(transactionId, msg.sender)"
      Identifier confirmed
         Type: modifier (uint256,address)
         Source: "confirmed"
      Identifier transactionId
         Type: uint256
         Source: "transactionId"
      MemberAccess to member sender
         Type: address
         Source: "msg.sender"
        Identifier msg
           Type: msg
           Source: "msg"
    ModifierInvocation "notExecuted"
       Gas costs: 3
       Source: "notExecuted(transactionId)"
      Identifier notExecuted
         Type: modifier (uint256)
         Source: "notExecuted"
      Identifier transactionId
         Type: uint256
         Source: "transactionId"
    Block
       Source: "{\r\n        confirmations[transactionId][msg.sender] = false;\r\n        Revocation(msg.sender, transactionId);\r\n    }"
      ExpressionStatement
         Gas costs: 20440
         Source: "confirmations[transactionId][msg.sender] = false"
        Assignment using operator =
           Type: bool
           Source: "confirmations[transactionId][msg.sender] = false"
          IndexAccess
             Type: bool
             Source: "confirmations[transactionId][msg.sender]"
            IndexAccess
               Type: mapping(address => bool)
               Source: "confirmations[transactionId]"
              Identifier confirmations
                 Type: mapping(uint256 => mapping(address => bool))
                 Source: "confirmations"
              Identifier transactionId
                 Type: uint256
                 Source: "transactionId"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 1541
         Source: "Revocation(msg.sender, transactionId)"
        FunctionCall
           Type: tuple()
           Source: "Revocation(msg.sender, transactionId)"
          Identifier Revocation
             Type: function (address,uint256)
             Source: "Revocation"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
  FunctionDefinition "executeTransaction" - public
     Source: "function executeTransaction(uint transactionId)\r\n        public\r\n        notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction tx = transactions[transactionId];\r\n            tx.executed = true;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "notExecuted"
       Gas costs: 0
       Source: "notExecuted(transactionId)"
      Identifier notExecuted
         Type: modifier (uint256)
         Source: "notExecuted"
      Identifier transactionId
         Type: uint256
         Source: "transactionId"
    Block
       Source: "{\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction tx = transactions[transactionId];\r\n            tx.executed = true;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n            }\r\n        }\r\n    }"
      IfStatement
         Source: "if (isConfirmed(transactionId)) {\r\n            Transaction tx = transactions[transactionId];\r\n            tx.executed = true;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n            }\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 0
           Source: "isConfirmed(transactionId)"
          Identifier isConfirmed
             Type: function (uint256) view returns (bool)
             Source: "isConfirmed"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
        Block
           Source: "{\r\n            Transaction tx = transactions[transactionId];\r\n            tx.executed = true;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n            }\r\n        }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "Transaction tx = transactions[transactionId]"
            VariableDeclaration "tx"
               Type: struct MultiSigWallet.Transaction storage pointer
               Source: "Transaction tx"
              UserDefinedTypeName "Transaction"
                 Source: "Transaction"
            IndexAccess
               Type: struct MultiSigWallet.Transaction storage ref
               Source: "transactions[transactionId]"
              Identifier transactions
                 Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
                 Source: "transactions"
              Identifier transactionId
                 Type: uint256
                 Source: "transactionId"
          ExpressionStatement
             Gas costs: 0
             Source: "tx.executed = true"
            Assignment using operator =
               Type: bool
               Source: "tx.executed = true"
              MemberAccess to member executed
                 Type: bool
                 Source: "tx.executed"
                Identifier tx
                   Type: struct MultiSigWallet.Transaction storage pointer
                   Source: "tx"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
          IfStatement
             Source: "if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n            }"
            FunctionCall
               Type: bool
               Gas costs: 0
               Source: "tx.destination.call.value(tx.value)(tx.data)"
              FunctionCall
                 Type: function () payable returns (bool)
                 Source: "tx.destination.call.value(tx.value)"
                MemberAccess to member value
                   Type: function (uint256) returns (function () payable returns (bool))
                   Source: "tx.destination.call.value"
                  MemberAccess to member call
                     Type: function () payable returns (bool)
                     Source: "tx.destination.call"
                    MemberAccess to member destination
                       Type: address
                       Source: "tx.destination"
                      Identifier tx
                         Type: struct MultiSigWallet.Transaction storage pointer
                         Source: "tx"
                MemberAccess to member value
                   Type: uint256
                   Source: "tx.value"
                  Identifier tx
                     Type: struct MultiSigWallet.Transaction storage pointer
                     Source: "tx"
              MemberAccess to member data
                 Type: bytes storage ref
                 Source: "tx.data"
                Identifier tx
                   Type: struct MultiSigWallet.Transaction storage pointer
                   Source: "tx"
            ExpressionStatement
               Gas costs: 0
               Source: "Execution(transactionId)"
              FunctionCall
                 Type: tuple()
                 Source: "Execution(transactionId)"
                Identifier Execution
                   Type: function (uint256)
                   Source: "Execution"
                Identifier transactionId
                   Type: uint256
                   Source: "transactionId"
            Block
               Source: "{\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "ExecutionFailure(transactionId)"
                FunctionCall
                   Type: tuple()
                   Source: "ExecutionFailure(transactionId)"
                  Identifier ExecutionFailure
                     Type: function (uint256)
                     Source: "ExecutionFailure"
                  Identifier transactionId
                     Type: uint256
                     Source: "transactionId"
              ExpressionStatement
                 Gas costs: 0
                 Source: "tx.executed = false"
                Assignment using operator =
                   Type: bool
                   Source: "tx.executed = false"
                  MemberAccess to member executed
                     Type: bool
                     Source: "tx.executed"
                    Identifier tx
                       Type: struct MultiSigWallet.Transaction storage pointer
                       Source: "tx"
                  Literal, token: false value: false
                     Type: bool
                     Source: "false"
  FunctionDefinition "isConfirmed" - public - const
     Source: "function isConfirmed(uint transactionId)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint count = 0"
        VariableDeclaration "count"
           Type: uint256
           Source: "uint count"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 217
           Source: "i<owners.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "owners.length"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }"
          IfStatement
             Source: "if (confirmations[transactionId][owners[i]])\r\n                count += 1"
            IndexAccess
               Type: bool
               Gas costs: [???]
               Source: "confirmations[transactionId][owners[i]]"
              IndexAccess
                 Type: mapping(address => bool)
                 Source: "confirmations[transactionId]"
                Identifier confirmations
                   Type: mapping(uint256 => mapping(address => bool))
                   Source: "confirmations"
                Identifier transactionId
                   Type: uint256
                   Source: "transactionId"
              IndexAccess
                 Type: address
                 Source: "owners[i]"
                Identifier owners
                   Type: address[] storage ref
                   Source: "owners"
                Identifier i
                   Type: uint256
                   Source: "i"
            ExpressionStatement
               Gas costs: 14
               Source: "count += 1"
              Assignment using operator +=
                 Type: uint256
                 Source: "count += 1"
                Identifier count
                   Type: uint256
                   Source: "count"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
          IfStatement
             Source: "if (count == required)\r\n                return true"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 209
               Source: "count == required"
              Identifier count
                 Type: uint256
                 Source: "count"
              Identifier required
                 Type: uint256
                 Source: "required"
            Return
               Gas costs: 19
               Source: "return true"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
  FunctionDefinition "addTransaction"
     Source: "function addTransaction(address destination, uint value, bytes data)\r\n        internal\r\n        notNull(destination)\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        Submission(transactionId);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address destination, uint value, bytes data)"
      VariableDeclaration "destination"
         Type: address
         Source: "address destination"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "data"
         Type: bytes memory
         Source: "bytes data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "notNull"
       Gas costs: 3
       Source: "notNull(destination)"
      Identifier notNull
         Type: modifier (address)
         Source: "notNull"
      Identifier destination
         Type: address
         Source: "destination"
    Block
       Source: "{\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        Submission(transactionId);\r\n    }"
      ExpressionStatement
         Gas costs: 208
         Source: "transactionId = transactionCount"
        Assignment using operator =
           Type: uint256
           Source: "transactionId = transactionCount"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
          Identifier transactionCount
             Type: uint256
             Source: "transactionCount"
      ExpressionStatement
         Gas costs: [???]
         Source: "transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        })"
        Assignment using operator =
           Type: struct MultiSigWallet.Transaction storage ref
           Source: "transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        })"
          IndexAccess
             Type: struct MultiSigWallet.Transaction storage ref
             Source: "transactions[transactionId]"
            Identifier transactions
               Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
               Source: "transactions"
            Identifier transactionId
               Type: uint256
               Source: "transactionId"
          FunctionCall
             Type: struct MultiSigWallet.Transaction memory
             Source: "Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        })"
            Identifier Transaction
               Type: type(struct MultiSigWallet.Transaction storage pointer)
               Source: "Transaction"
            Identifier destination
               Type: address
               Source: "destination"
            Identifier value
               Type: uint256
               Source: "value"
            Identifier data
               Type: bytes memory
               Source: "data"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      ExpressionStatement
         Gas costs: 20233
         Source: "transactionCount += 1"
        Assignment using operator +=
           Type: uint256
           Source: "transactionCount += 1"
          Identifier transactionCount
             Type: uint256
             Source: "transactionCount"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Gas costs: 1164
         Source: "Submission(transactionId)"
        FunctionCall
           Type: tuple()
           Source: "Submission(transactionId)"
          Identifier Submission
             Type: function (uint256)
             Source: "Submission"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
  FunctionDefinition "getConfirmationCount" - public - const
     Source: "function getConfirmationCount(uint transactionId)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint count)"
      VariableDeclaration "count"
         Type: uint256
         Source: "uint count"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }"
      ForStatement
         Source: "for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 217
           Source: "i<owners.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "owners.length"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (confirmations[transactionId][owners[i]])\r\n                count += 1"
          IndexAccess
             Type: bool
             Gas costs: [???]
             Source: "confirmations[transactionId][owners[i]]"
            IndexAccess
               Type: mapping(address => bool)
               Source: "confirmations[transactionId]"
              Identifier confirmations
                 Type: mapping(uint256 => mapping(address => bool))
                 Source: "confirmations"
              Identifier transactionId
                 Type: uint256
                 Source: "transactionId"
            IndexAccess
               Type: address
               Source: "owners[i]"
              Identifier owners
                 Type: address[] storage ref
                 Source: "owners"
              Identifier i
                 Type: uint256
                 Source: "i"
          ExpressionStatement
             Gas costs: 14
             Source: "count += 1"
            Assignment using operator +=
               Type: uint256
               Source: "count += 1"
              Identifier count
                 Type: uint256
                 Source: "count"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
  FunctionDefinition "getTransactionCount" - public - const
     Source: "function getTransactionCount(bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bool pending, bool executed)"
      VariableDeclaration "pending"
         Type: bool
         Source: "bool pending"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "executed"
         Type: bool
         Source: "bool executed"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 3
       Source: "(uint count)"
      VariableDeclaration "count"
         Type: uint256
         Source: "uint count"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1;\r\n    }"
      ForStatement
         Source: "for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 209
           Source: "i<transactionCount"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier transactionCount
             Type: uint256
             Source: "transactionCount"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1"
          BinaryOperation using operator ||
             Type: bool
             Gas costs: 730
             Source: "pending && !transactions[i].executed\r\n                || executed && transactions[i].executed"
            BinaryOperation using operator &&
               Type: bool
               Source: "pending && !transactions[i].executed"
              Identifier pending
                 Type: bool
                 Source: "pending"
              UnaryOperation (prefix) !
                 Type: bool
                 Source: "!transactions[i].executed"
                MemberAccess to member executed
                   Type: bool
                   Source: "transactions[i].executed"
                  IndexAccess
                     Type: struct MultiSigWallet.Transaction storage ref
                     Source: "transactions[i]"
                    Identifier transactions
                       Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
                       Source: "transactions"
                    Identifier i
                       Type: uint256
                       Source: "i"
            BinaryOperation using operator &&
               Type: bool
               Source: "executed && transactions[i].executed"
              Identifier executed
                 Type: bool
                 Source: "executed"
              MemberAccess to member executed
                 Type: bool
                 Source: "transactions[i].executed"
                IndexAccess
                   Type: struct MultiSigWallet.Transaction storage ref
                   Source: "transactions[i]"
                  Identifier transactions
                     Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
                     Source: "transactions"
                  Identifier i
                     Type: uint256
                     Source: "i"
          ExpressionStatement
             Gas costs: 14
             Source: "count += 1"
            Assignment using operator +=
               Type: uint256
               Source: "count += 1"
              Identifier count
                 Type: uint256
                 Source: "count"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
  FunctionDefinition "getOwners" - public - const
     Source: "function getOwners()\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return owners;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(address[])"
      VariableDeclaration ""
         Type: address[] memory
         Source: "address[]"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\r\n        return owners;\r\n    }"
      Return
         Gas costs: [???]
         Source: "return owners"
        Identifier owners
           Type: address[] storage ref
           Source: "owners"
  FunctionDefinition "getConfirmations" - public - const
     Source: "function getConfirmations(uint transactionId)\r\n        public\r\n        constant\r\n        returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(address[] _confirmations)"
      VariableDeclaration "_confirmations"
         Type: address[] memory
         Source: "address[] _confirmations"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "address[] memory confirmationsTemp = new address[](owners.length)"
        VariableDeclaration "confirmationsTemp"
           Type: address[] memory
           Source: "address[] memory confirmationsTemp"
          ArrayTypeName
             Source: "address[]"
            ElementaryTypeName address
               Source: "address"
        FunctionCall
           Type: address[] memory
           Source: "new address[](owners.length)"
          NewExpression
             Type: function (uint256) pure returns (address[] memory)
             Source: "new address[]"
            ArrayTypeName
               Source: "address[]"
              ElementaryTypeName address
                 Source: "address"
          MemberAccess to member length
             Type: uint256
             Source: "owners.length"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint count = 0"
        VariableDeclaration "count"
           Type: uint256
           Source: "uint count"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint i"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint i"
          ElementaryTypeName uint
             Source: "uint"
      ForStatement
         Source: "for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }"
        ExpressionStatement
           Gas costs: 8
           Source: "i=0"
          Assignment using operator =
             Type: uint256
             Source: "i=0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 217
           Source: "i<owners.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "owners.length"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }"
          IndexAccess
             Type: bool
             Gas costs: [???]
             Source: "confirmations[transactionId][owners[i]]"
            IndexAccess
               Type: mapping(address => bool)
               Source: "confirmations[transactionId]"
              Identifier confirmations
                 Type: mapping(uint256 => mapping(address => bool))
                 Source: "confirmations"
              Identifier transactionId
                 Type: uint256
                 Source: "transactionId"
            IndexAccess
               Type: address
               Source: "owners[i]"
              Identifier owners
                 Type: address[] storage ref
                 Source: "owners"
              Identifier i
                 Type: uint256
                 Source: "i"
          Block
             Source: "{\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }"
            ExpressionStatement
               Gas costs: [???]
               Source: "confirmationsTemp[count] = owners[i]"
              Assignment using operator =
                 Type: address
                 Source: "confirmationsTemp[count] = owners[i]"
                IndexAccess
                   Type: address
                   Source: "confirmationsTemp[count]"
                  Identifier confirmationsTemp
                     Type: address[] memory
                     Source: "confirmationsTemp"
                  Identifier count
                     Type: uint256
                     Source: "count"
                IndexAccess
                   Type: address
                   Source: "owners[i]"
                  Identifier owners
                     Type: address[] storage ref
                     Source: "owners"
                  Identifier i
                     Type: uint256
                     Source: "i"
            ExpressionStatement
               Gas costs: 14
               Source: "count += 1"
              Assignment using operator +=
                 Type: uint256
                 Source: "count += 1"
                Identifier count
                   Type: uint256
                   Source: "count"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      ExpressionStatement
         Gas costs: [???]
         Source: "_confirmations = new address[](count)"
        Assignment using operator =
           Type: address[] memory
           Source: "_confirmations = new address[](count)"
          Identifier _confirmations
             Type: address[] memory
             Source: "_confirmations"
          FunctionCall
             Type: address[] memory
             Source: "new address[](count)"
            NewExpression
               Type: function (uint256) pure returns (address[] memory)
               Source: "new address[]"
              ArrayTypeName
                 Source: "address[]"
                ElementaryTypeName address
                   Source: "address"
            Identifier count
               Type: uint256
               Source: "count"
      ForStatement
         Source: "for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i]"
        ExpressionStatement
           Gas costs: 8
           Source: "i=0"
          Assignment using operator =
             Type: uint256
             Source: "i=0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i<count"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier count
             Type: uint256
             Source: "count"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        ExpressionStatement
           Gas costs: [???]
           Source: "_confirmations[i] = confirmationsTemp[i]"
          Assignment using operator =
             Type: address
             Source: "_confirmations[i] = confirmationsTemp[i]"
            IndexAccess
               Type: address
               Source: "_confirmations[i]"
              Identifier _confirmations
                 Type: address[] memory
                 Source: "_confirmations"
              Identifier i
                 Type: uint256
                 Source: "i"
            IndexAccess
               Type: address
               Source: "confirmationsTemp[i]"
              Identifier confirmationsTemp
                 Type: address[] memory
                 Source: "confirmationsTemp"
              Identifier i
                 Type: uint256
                 Source: "i"
  FunctionDefinition "getTransactionIds" - public - const
     Source: "function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint from, uint to, bool pending, bool executed)"
      VariableDeclaration "from"
         Type: uint256
         Source: "uint from"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "to"
         Type: uint256
         Source: "uint to"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "pending"
         Type: bool
         Source: "bool pending"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "executed"
         Type: bool
         Source: "bool executed"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 3
       Source: "(uint[] _transactionIds)"
      VariableDeclaration "_transactionIds"
         Type: uint256[] memory
         Source: "uint[] _transactionIds"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    Block
       Source: "{\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint[] memory transactionIdsTemp = new uint[](transactionCount)"
        VariableDeclaration "transactionIdsTemp"
           Type: uint256[] memory
           Source: "uint[] memory transactionIdsTemp"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](transactionCount)"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          Identifier transactionCount
             Type: uint256
             Source: "transactionCount"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint count = 0"
        VariableDeclaration "count"
           Type: uint256
           Source: "uint count"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint i"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint i"
          ElementaryTypeName uint
             Source: "uint"
      ForStatement
         Source: "for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }"
        ExpressionStatement
           Gas costs: 8
           Source: "i=0"
          Assignment using operator =
             Type: uint256
             Source: "i=0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 209
           Source: "i<transactionCount"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier transactionCount
             Type: uint256
             Source: "transactionCount"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }"
          BinaryOperation using operator ||
             Type: bool
             Gas costs: 730
             Source: "pending && !transactions[i].executed\r\n                || executed && transactions[i].executed"
            BinaryOperation using operator &&
               Type: bool
               Source: "pending && !transactions[i].executed"
              Identifier pending
                 Type: bool
                 Source: "pending"
              UnaryOperation (prefix) !
                 Type: bool
                 Source: "!transactions[i].executed"
                MemberAccess to member executed
                   Type: bool
                   Source: "transactions[i].executed"
                  IndexAccess
                     Type: struct MultiSigWallet.Transaction storage ref
                     Source: "transactions[i]"
                    Identifier transactions
                       Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
                       Source: "transactions"
                    Identifier i
                       Type: uint256
                       Source: "i"
            BinaryOperation using operator &&
               Type: bool
               Source: "executed && transactions[i].executed"
              Identifier executed
                 Type: bool
                 Source: "executed"
              MemberAccess to member executed
                 Type: bool
                 Source: "transactions[i].executed"
                IndexAccess
                   Type: struct MultiSigWallet.Transaction storage ref
                   Source: "transactions[i]"
                  Identifier transactions
                     Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
                     Source: "transactions"
                  Identifier i
                     Type: uint256
                     Source: "i"
          Block
             Source: "{\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }"
            ExpressionStatement
               Gas costs: [???]
               Source: "transactionIdsTemp[count] = i"
              Assignment using operator =
                 Type: uint256
                 Source: "transactionIdsTemp[count] = i"
                IndexAccess
                   Type: uint256
                   Source: "transactionIdsTemp[count]"
                  Identifier transactionIdsTemp
                     Type: uint256[] memory
                     Source: "transactionIdsTemp"
                  Identifier count
                     Type: uint256
                     Source: "count"
                Identifier i
                   Type: uint256
                   Source: "i"
            ExpressionStatement
               Gas costs: 14
               Source: "count += 1"
              Assignment using operator +=
                 Type: uint256
                 Source: "count += 1"
                Identifier count
                   Type: uint256
                   Source: "count"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      ExpressionStatement
         Gas costs: [???]
         Source: "_transactionIds = new uint[](to - from)"
        Assignment using operator =
           Type: uint256[] memory
           Source: "_transactionIds = new uint[](to - from)"
          Identifier _transactionIds
             Type: uint256[] memory
             Source: "_transactionIds"
          FunctionCall
             Type: uint256[] memory
             Source: "new uint[](to - from)"
            NewExpression
               Type: function (uint256) pure returns (uint256[] memory)
               Source: "new uint[]"
              ArrayTypeName
                 Source: "uint[]"
                ElementaryTypeName uint
                   Source: "uint"
            BinaryOperation using operator -
               Type: uint256
               Source: "to - from"
              Identifier to
                 Type: uint256
                 Source: "to"
              Identifier from
                 Type: uint256
                 Source: "from"
      ForStatement
         Source: "for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i]"
        ExpressionStatement
           Gas costs: 8
           Source: "i=from"
          Assignment using operator =
             Type: uint256
             Source: "i=from"
            Identifier i
               Type: uint256
               Source: "i"
            Identifier from
               Type: uint256
               Source: "from"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i<to"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier to
             Type: uint256
             Source: "to"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        ExpressionStatement
           Gas costs: [???]
           Source: "_transactionIds[i - from] = transactionIdsTemp[i]"
          Assignment using operator =
             Type: uint256
             Source: "_transactionIds[i - from] = transactionIdsTemp[i]"
            IndexAccess
               Type: uint256
               Source: "_transactionIds[i - from]"
              Identifier _transactionIds
                 Type: uint256[] memory
                 Source: "_transactionIds"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "i - from"
                Identifier i
                   Type: uint256
                   Source: "i"
                Identifier from
                   Type: uint256
                   Source: "from"
            IndexAccess
               Type: uint256
               Source: "transactionIdsTemp[i]"
              Identifier transactionIdsTemp
                 Type: uint256[] memory
                 Source: "transactionIdsTemp"
              Identifier i
                 Type: uint256
                 Source: "i"
ContractDefinition "MultiSigWalletWithDailyLimit"
   Source: "contract MultiSigWalletWithDailyLimit is MultiSigWallet {\r\n\r\n    event DailyLimitChange(uint dailyLimit);\r\n\r\n    uint public dailyLimit;\r\n    uint public lastDay;\r\n    uint public spentToday;\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners, required number of confirmations and daily withdraw limit.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    /// @param _dailyLimit Amount in wei, which can be withdrawn without confirmations on a daily basis.\r\n    function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)\r\n        public\r\n        MultiSigWallet(_owners, _required)\r\n    {\r\n        dailyLimit = _dailyLimit;\r\n    }\r\n\r\n    /// @dev Allows to change the daily limit. Transaction has to be sent by wallet.\r\n    /// @param _dailyLimit Amount in wei.\r\n    function changeDailyLimit(uint _dailyLimit)\r\n        public\r\n        onlyWallet\r\n    {\r\n        dailyLimit = _dailyLimit;\r\n        DailyLimitChange(_dailyLimit);\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction or ether withdraws until daily limit is reached.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n        public\r\n        notExecuted(transactionId)\r\n    {\r\n        Transaction tx = transactions[transactionId];\r\n        bool confirmed = isConfirmed(transactionId);\r\n        if (confirmed || tx.data.length == 0 && isUnderLimit(tx.value)) {\r\n            tx.executed = true;\r\n            if (!confirmed)\r\n                spentToday += tx.value;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n                if (!confirmed)\r\n                    spentToday -= tx.value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Returns if amount is within daily limit and resets spentToday after one day.\r\n    /// @param amount Amount to withdraw.\r\n    /// @return Returns if amount is under daily limit.\r\n    function isUnderLimit(uint amount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (now > lastDay + 24 hours) {\r\n            lastDay = now;\r\n            spentToday = 0;\r\n        }\r\n        if (spentToday + amount > dailyLimit || spentToday + amount < spentToday)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns maximum withdraw amount.\r\n    /// @return Returns amount.\r\n    function calcMaxWithdraw()\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        if (now > lastDay + 24 hours)\r\n            return dailyLimit;\r\n        if (dailyLimit < spentToday)\r\n            return 0;\r\n        return dailyLimit - spentToday;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "MultiSigWallet"
    UserDefinedTypeName "MultiSigWallet"
       Source: "MultiSigWallet"
  EventDefinition "DailyLimitChange"
     Gas costs: 0
     Source: "event DailyLimitChange(uint dailyLimit);"
    ParameterList
       Source: "(uint dailyLimit)"
      VariableDeclaration "dailyLimit"
         Type: uint256
         Source: "uint dailyLimit"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "dailyLimit"
     Type: uint256
     Gas costs: [???]
     Source: "uint public dailyLimit"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "lastDay"
     Type: uint256
     Gas costs: [???]
     Source: "uint public lastDay"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "spentToday"
     Type: uint256
     Gas costs: [???]
     Source: "uint public spentToday"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "MultiSigWalletWithDailyLimit" - public
     Source: "function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)\r\n        public\r\n        MultiSigWallet(_owners, _required)\r\n    {\r\n        dailyLimit = _dailyLimit;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _owners, uint _required, uint _dailyLimit)"
      VariableDeclaration "_owners"
         Type: address[] memory
         Source: "address[] _owners"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_required"
         Type: uint256
         Source: "uint _required"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_dailyLimit"
         Type: uint256
         Source: "uint _dailyLimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "MultiSigWallet"
       Gas costs: 0
       Source: "MultiSigWallet(_owners, _required)"
      Identifier MultiSigWallet
         Type: type(contract MultiSigWallet)
         Source: "MultiSigWallet"
      Identifier _owners
         Type: address[] memory
         Source: "_owners"
      Identifier _required
         Type: uint256
         Source: "_required"
    Block
       Source: "{\r\n        dailyLimit = _dailyLimit;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "dailyLimit = _dailyLimit"
        Assignment using operator =
           Type: uint256
           Source: "dailyLimit = _dailyLimit"
          Identifier dailyLimit
             Type: uint256
             Source: "dailyLimit"
          Identifier _dailyLimit
             Type: uint256
             Source: "_dailyLimit"
  FunctionDefinition "changeDailyLimit" - public
     Source: "function changeDailyLimit(uint _dailyLimit)\r\n        public\r\n        onlyWallet\r\n    {\r\n        dailyLimit = _dailyLimit;\r\n        DailyLimitChange(_dailyLimit);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _dailyLimit)"
      VariableDeclaration "_dailyLimit"
         Type: uint256
         Source: "uint _dailyLimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyWallet"
       Gas costs: 0
       Source: "onlyWallet"
      Identifier onlyWallet
         Type: modifier ()
         Source: "onlyWallet"
    Block
       Source: "{\r\n        dailyLimit = _dailyLimit;\r\n        DailyLimitChange(_dailyLimit);\r\n    }"
      ExpressionStatement
         Gas costs: 20014
         Source: "dailyLimit = _dailyLimit"
        Assignment using operator =
           Type: uint256
           Source: "dailyLimit = _dailyLimit"
          Identifier dailyLimit
             Type: uint256
             Source: "dailyLimit"
          Identifier _dailyLimit
             Type: uint256
             Source: "_dailyLimit"
      ExpressionStatement
         Gas costs: [???]
         Source: "DailyLimitChange(_dailyLimit)"
        FunctionCall
           Type: tuple()
           Source: "DailyLimitChange(_dailyLimit)"
          Identifier DailyLimitChange
             Type: function (uint256)
             Source: "DailyLimitChange"
          Identifier _dailyLimit
             Type: uint256
             Source: "_dailyLimit"
  FunctionDefinition "executeTransaction" - public
     Source: "function executeTransaction(uint transactionId)\r\n        public\r\n        notExecuted(transactionId)\r\n    {\r\n        Transaction tx = transactions[transactionId];\r\n        bool confirmed = isConfirmed(transactionId);\r\n        if (confirmed || tx.data.length == 0 && isUnderLimit(tx.value)) {\r\n            tx.executed = true;\r\n            if (!confirmed)\r\n                spentToday += tx.value;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n                if (!confirmed)\r\n                    spentToday -= tx.value;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "notExecuted"
       Gas costs: 3
       Source: "notExecuted(transactionId)"
      Identifier notExecuted
         Type: modifier (uint256)
         Source: "notExecuted"
      Identifier transactionId
         Type: uint256
         Source: "transactionId"
    Block
       Source: "{\r\n        Transaction tx = transactions[transactionId];\r\n        bool confirmed = isConfirmed(transactionId);\r\n        if (confirmed || tx.data.length == 0 && isUnderLimit(tx.value)) {\r\n            tx.executed = true;\r\n            if (!confirmed)\r\n                spentToday += tx.value;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n                if (!confirmed)\r\n                    spentToday -= tx.value;\r\n            }\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 95
         Source: "Transaction tx = transactions[transactionId]"
        VariableDeclaration "tx"
           Type: struct MultiSigWallet.Transaction storage pointer
           Source: "Transaction tx"
          UserDefinedTypeName "Transaction"
             Source: "Transaction"
        IndexAccess
           Type: struct MultiSigWallet.Transaction storage ref
           Source: "transactions[transactionId]"
          Identifier transactions
             Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
             Source: "transactions"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "bool confirmed = isConfirmed(transactionId)"
        VariableDeclaration "confirmed"
           Type: bool
           Source: "bool confirmed"
          ElementaryTypeName bool
             Source: "bool"
        FunctionCall
           Type: bool
           Source: "isConfirmed(transactionId)"
          Identifier isConfirmed
             Type: function (uint256) view returns (bool)
             Source: "isConfirmed"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
      IfStatement
         Source: "if (confirmed || tx.data.length == 0 && isUnderLimit(tx.value)) {\r\n            tx.executed = true;\r\n            if (!confirmed)\r\n                spentToday += tx.value;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n                if (!confirmed)\r\n                    spentToday -= tx.value;\r\n            }\r\n        }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 520
           Source: "confirmed || tx.data.length == 0 && isUnderLimit(tx.value)"
          Identifier confirmed
             Type: bool
             Source: "confirmed"
          BinaryOperation using operator &&
             Type: bool
             Source: "tx.data.length == 0 && isUnderLimit(tx.value)"
            BinaryOperation using operator ==
               Type: bool
               Source: "tx.data.length == 0"
              MemberAccess to member length
                 Type: uint256
                 Source: "tx.data.length"
                MemberAccess to member data
                   Type: bytes storage ref
                   Source: "tx.data"
                  Identifier tx
                     Type: struct MultiSigWallet.Transaction storage pointer
                     Source: "tx"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            FunctionCall
               Type: bool
               Source: "isUnderLimit(tx.value)"
              Identifier isUnderLimit
                 Type: function (uint256) returns (bool)
                 Source: "isUnderLimit"
              MemberAccess to member value
                 Type: uint256
                 Source: "tx.value"
                Identifier tx
                   Type: struct MultiSigWallet.Transaction storage pointer
                   Source: "tx"
        Block
           Source: "{\r\n            tx.executed = true;\r\n            if (!confirmed)\r\n                spentToday += tx.value;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n                if (!confirmed)\r\n                    spentToday -= tx.value;\r\n            }\r\n        }"
          ExpressionStatement
             Gas costs: 20273
             Source: "tx.executed = true"
            Assignment using operator =
               Type: bool
               Source: "tx.executed = true"
              MemberAccess to member executed
                 Type: bool
                 Source: "tx.executed"
                Identifier tx
                   Type: struct MultiSigWallet.Transaction storage pointer
                   Source: "tx"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
          IfStatement
             Source: "if (!confirmed)\r\n                spentToday += tx.value"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: 6
               Source: "!confirmed"
              Identifier confirmed
                 Type: bool
                 Source: "confirmed"
            ExpressionStatement
               Gas costs: 20439
               Source: "spentToday += tx.value"
              Assignment using operator +=
                 Type: uint256
                 Source: "spentToday += tx.value"
                Identifier spentToday
                   Type: uint256
                   Source: "spentToday"
                MemberAccess to member value
                   Type: uint256
                   Source: "tx.value"
                  Identifier tx
                     Type: struct MultiSigWallet.Transaction storage pointer
                     Source: "tx"
          IfStatement
             Source: "if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n                if (!confirmed)\r\n                    spentToday -= tx.value;\r\n            }"
            FunctionCall
               Type: bool
               Gas costs: [???]
               Source: "tx.destination.call.value(tx.value)(tx.data)"
              FunctionCall
                 Type: function () payable returns (bool)
                 Source: "tx.destination.call.value(tx.value)"
                MemberAccess to member value
                   Type: function (uint256) returns (function () payable returns (bool))
                   Source: "tx.destination.call.value"
                  MemberAccess to member call
                     Type: function () payable returns (bool)
                     Source: "tx.destination.call"
                    MemberAccess to member destination
                       Type: address
                       Source: "tx.destination"
                      Identifier tx
                         Type: struct MultiSigWallet.Transaction storage pointer
                         Source: "tx"
                MemberAccess to member value
                   Type: uint256
                   Source: "tx.value"
                  Identifier tx
                     Type: struct MultiSigWallet.Transaction storage pointer
                     Source: "tx"
              MemberAccess to member data
                 Type: bytes storage ref
                 Source: "tx.data"
                Identifier tx
                   Type: struct MultiSigWallet.Transaction storage pointer
                   Source: "tx"
            ExpressionStatement
               Gas costs: 1164
               Source: "Execution(transactionId)"
              FunctionCall
                 Type: tuple()
                 Source: "Execution(transactionId)"
                Identifier Execution
                   Type: function (uint256)
                   Source: "Execution"
                Identifier transactionId
                   Type: uint256
                   Source: "transactionId"
            Block
               Source: "{\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n                if (!confirmed)\r\n                    spentToday -= tx.value;\r\n            }"
              ExpressionStatement
                 Gas costs: 1164
                 Source: "ExecutionFailure(transactionId)"
                FunctionCall
                   Type: tuple()
                   Source: "ExecutionFailure(transactionId)"
                  Identifier ExecutionFailure
                     Type: function (uint256)
                     Source: "ExecutionFailure"
                  Identifier transactionId
                     Type: uint256
                     Source: "transactionId"
              ExpressionStatement
                 Gas costs: 20273
                 Source: "tx.executed = false"
                Assignment using operator =
                   Type: bool
                   Source: "tx.executed = false"
                  MemberAccess to member executed
                     Type: bool
                     Source: "tx.executed"
                    Identifier tx
                       Type: struct MultiSigWallet.Transaction storage pointer
                       Source: "tx"
                  Literal, token: false value: false
                     Type: bool
                     Source: "false"
              IfStatement
                 Source: "if (!confirmed)\r\n                    spentToday -= tx.value"
                UnaryOperation (prefix) !
                   Type: bool
                   Gas costs: 6
                   Source: "!confirmed"
                  Identifier confirmed
                     Type: bool
                     Source: "confirmed"
                ExpressionStatement
                   Gas costs: 20439
                   Source: "spentToday -= tx.value"
                  Assignment using operator -=
                     Type: uint256
                     Source: "spentToday -= tx.value"
                    Identifier spentToday
                       Type: uint256
                       Source: "spentToday"
                    MemberAccess to member value
                       Type: uint256
                       Source: "tx.value"
                      Identifier tx
                         Type: struct MultiSigWallet.Transaction storage pointer
                         Source: "tx"
  FunctionDefinition "isUnderLimit"
     Source: "function isUnderLimit(uint amount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (now > lastDay + 24 hours) {\r\n            lastDay = now;\r\n            spentToday = 0;\r\n        }\r\n        if (spentToday + amount > dailyLimit || spentToday + amount < spentToday)\r\n            return false;\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if (now > lastDay + 24 hours) {\r\n            lastDay = now;\r\n            spentToday = 0;\r\n        }\r\n        if (spentToday + amount > dailyLimit || spentToday + amount < spentToday)\r\n            return false;\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (now > lastDay + 24 hours) {\r\n            lastDay = now;\r\n            spentToday = 0;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 214
           Source: "now > lastDay + 24 hours"
          Identifier now
             Type: uint256
             Source: "now"
          BinaryOperation using operator +
             Type: uint256
             Source: "lastDay + 24 hours"
            Identifier lastDay
               Type: uint256
               Source: "lastDay"
            Literal, token: [no token] value: 24
               Type: int_const 86400
               Source: "24 hours"
        Block
           Source: "{\r\n            lastDay = now;\r\n            spentToday = 0;\r\n        }"
          ExpressionStatement
             Gas costs: 20013
             Source: "lastDay = now"
            Assignment using operator =
               Type: uint256
               Source: "lastDay = now"
              Identifier lastDay
                 Type: uint256
                 Source: "lastDay"
              Identifier now
                 Type: uint256
                 Source: "now"
          ExpressionStatement
             Gas costs: 5014
             Source: "spentToday = 0"
            Assignment using operator =
               Type: uint256
               Source: "spentToday = 0"
              Identifier spentToday
                 Type: uint256
                 Source: "spentToday"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      IfStatement
         Source: "if (spentToday + amount > dailyLimit || spentToday + amount < spentToday)\r\n            return false"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 849
           Source: "spentToday + amount > dailyLimit || spentToday + amount < spentToday"
          BinaryOperation using operator >
             Type: bool
             Source: "spentToday + amount > dailyLimit"
            BinaryOperation using operator +
               Type: uint256
               Source: "spentToday + amount"
              Identifier spentToday
                 Type: uint256
                 Source: "spentToday"
              Identifier amount
                 Type: uint256
                 Source: "amount"
            Identifier dailyLimit
               Type: uint256
               Source: "dailyLimit"
          BinaryOperation using operator <
             Type: bool
             Source: "spentToday + amount < spentToday"
            BinaryOperation using operator +
               Type: uint256
               Source: "spentToday + amount"
              Identifier spentToday
                 Type: uint256
                 Source: "spentToday"
              Identifier amount
                 Type: uint256
                 Source: "amount"
            Identifier spentToday
               Type: uint256
               Source: "spentToday"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "calcMaxWithdraw" - public - const
     Source: "function calcMaxWithdraw()\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        if (now > lastDay + 24 hours)\r\n            return dailyLimit;\r\n        if (dailyLimit < spentToday)\r\n            return 0;\r\n        return dailyLimit - spentToday;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (now > lastDay + 24 hours)\r\n            return dailyLimit;\r\n        if (dailyLimit < spentToday)\r\n            return 0;\r\n        return dailyLimit - spentToday;\r\n    }"
      IfStatement
         Source: "if (now > lastDay + 24 hours)\r\n            return dailyLimit"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 214
           Source: "now > lastDay + 24 hours"
          Identifier now
             Type: uint256
             Source: "now"
          BinaryOperation using operator +
             Type: uint256
             Source: "lastDay + 24 hours"
            Identifier lastDay
               Type: uint256
               Source: "lastDay"
            Literal, token: [no token] value: 24
               Type: int_const 86400
               Source: "24 hours"
        Return
           Gas costs: 219
           Source: "return dailyLimit"
          Identifier dailyLimit
             Type: uint256
             Source: "dailyLimit"
      IfStatement
         Source: "if (dailyLimit < spentToday)\r\n            return 0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 409
           Source: "dailyLimit < spentToday"
          Identifier dailyLimit
             Type: uint256
             Source: "dailyLimit"
          Identifier spentToday
             Type: uint256
             Source: "spentToday"
        Return
           Gas costs: 19
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      Return
         Gas costs: 414
         Source: "return dailyLimit - spentToday"
        BinaryOperation using operator -
           Type: uint256
           Source: "dailyLimit - spentToday"
          Identifier dailyLimit
             Type: uint256
             Source: "dailyLimit"
          Identifier spentToday
             Type: uint256
             Source: "spentToday"
