Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xc2221b777857f4a862a8c528d24b35cc995dd8b1.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "ERC20Protocol"
   Gas costs: 0
   Source: "contract ERC20Protocol {\r\n/* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint supply);\r\n    is replaced with:\r\n    uint public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint public totalSupply"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint balance"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value) returns (bool success);"
    ParameterList
       Source: "(address _to, uint _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value) returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint _value) returns (bool success);"
    ParameterList
       Source: "(address _spender, uint _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint remaining"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}"
  FunctionDefinition "mul"
     Source: "function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div"
     Source: "function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(b > 0)"
        FunctionCall
           Type: tuple()
           Source: "assert(b > 0)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >
             Type: bool
             Source: "b > 0"
            Identifier b
               Type: uint256
               Source: "b"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(a == b * c + a % b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == b * c + a % b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "a == b * c + a % b"
            Identifier a
               Type: uint256
               Source: "a"
            BinaryOperation using operator +
               Type: uint256
               Source: "b * c + a % b"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "b * c"
                Identifier b
                   Type: uint256
                   Source: "b"
                Identifier c
                   Type: uint256
                   Source: "c"
              BinaryOperation using operator %
                 Type: uint256
                 Source: "a % b"
                Identifier a
                   Type: uint256
                   Source: "a"
                Identifier b
                   Type: uint256
                   Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub"
     Source: "function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 0
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add"
     Source: "function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "max64" - const
     Source: "function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint64 a, uint64 b)"
      VariableDeclaration "a"
         Type: uint64
         Source: "uint64 a"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "b"
         Type: uint64
         Source: "uint64 b"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 0
       Source: "(uint64)"
      VariableDeclaration ""
         Type: uint64
         Source: "uint64"
        ElementaryTypeName uint64
           Source: "uint64"
    Block
       Source: "{\r\n    return a >= b ? a : b;\r\n  }"
      Return
         Gas costs: 0
         Source: "return a >= b ? a : b"
        Conditional
           Type: uint64
           Source: "a >= b ? a : b"
          BinaryOperation using operator >=
             Type: bool
             Source: "a >= b"
            Identifier a
               Type: uint64
               Source: "a"
            Identifier b
               Type: uint64
               Source: "b"
          Identifier a
             Type: uint64
             Source: "a"
          Identifier b
             Type: uint64
             Source: "b"
  FunctionDefinition "min64" - const
     Source: "function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint64 a, uint64 b)"
      VariableDeclaration "a"
         Type: uint64
         Source: "uint64 a"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "b"
         Type: uint64
         Source: "uint64 b"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 0
       Source: "(uint64)"
      VariableDeclaration ""
         Type: uint64
         Source: "uint64"
        ElementaryTypeName uint64
           Source: "uint64"
    Block
       Source: "{\r\n    return a < b ? a : b;\r\n  }"
      Return
         Gas costs: 0
         Source: "return a < b ? a : b"
        Conditional
           Type: uint64
           Source: "a < b ? a : b"
          BinaryOperation using operator <
             Type: bool
             Source: "a < b"
            Identifier a
               Type: uint64
               Source: "a"
            Identifier b
               Type: uint64
               Source: "b"
          Identifier a
             Type: uint64
             Source: "a"
          Identifier b
             Type: uint64
             Source: "b"
  FunctionDefinition "max256" - const
     Source: "function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return a >= b ? a : b;\r\n  }"
      Return
         Gas costs: 0
         Source: "return a >= b ? a : b"
        Conditional
           Type: uint256
           Source: "a >= b ? a : b"
          BinaryOperation using operator >=
             Type: bool
             Source: "a >= b"
            Identifier a
               Type: uint256
               Source: "a"
            Identifier b
               Type: uint256
               Source: "b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "min256" - const
     Source: "function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return a < b ? a : b;\r\n  }"
      Return
         Gas costs: 0
         Source: "return a < b ? a : b"
        Conditional
           Type: uint256
           Source: "a < b ? a : b"
          BinaryOperation using operator <
             Type: bool
             Source: "a < b"
            Identifier a
               Type: uint256
               Source: "a"
            Identifier b
               Type: uint256
               Source: "b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
ContractDefinition "Owned"
   Source: "contract Owned {\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    /// @notice The Constructor assigns the message sender to be `owner`\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    address public newOwner;\r\n\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner. 0x0 can be used to create\r\n    ///  an unowned neutral vault, however that cannot be undone\r\n    function changeOwner(address _newOwner) onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n\r\n    function acceptOwnership() {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 282
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "Owned" - public
     Source: "function Owned() {\r\n        owner = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  VariableDeclaration "newOwner"
     Type: address
     Gas costs: [???]
     Source: "address public newOwner"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "changeOwner" - public
     Source: "function changeOwner(address _newOwner) onlyOwner {\r\n        newOwner = _newOwner;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _newOwner)"
      VariableDeclaration "_newOwner"
         Type: address
         Source: "address _newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        newOwner = _newOwner;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "newOwner = _newOwner"
        Assignment using operator =
           Type: address
           Source: "newOwner = _newOwner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
          Identifier _newOwner
             Type: address
             Source: "_newOwner"
  FunctionDefinition "acceptOwnership" - public
     Source: "function acceptOwnership() {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }"
      IfStatement
         Source: "if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 256
           Source: "msg.sender == newOwner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier newOwner
             Type: address
             Source: "newOwner"
        Block
           Source: "{\r\n            owner = newOwner;\r\n        }"
          ExpressionStatement
             Gas costs: 20503
             Source: "owner = newOwner"
            Assignment using operator =
               Type: address
               Source: "owner = newOwner"
              Identifier owner
                 Type: address
                 Source: "owner"
              Identifier newOwner
                 Type: address
                 Source: "newOwner"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is ERC20Protocol {\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n    * @dev Fix for the ERC20 short address attack.\r\n    */\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20Protocol"
    UserDefinedTypeName "ERC20Protocol"
       Source: "ERC20Protocol"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint
       Source: "uint"
  ModifierDefinition "onlyPayloadSize"
     Source: "modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint size)"
      VariableDeclaration "size"
         Type: uint256
         Source: "uint size"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.data.length >= size + 4)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.data.length >= size + 4)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.data.length >= size + 4"
            MemberAccess to member length
               Type: uint256
               Source: "msg.data.length"
              MemberAccess to member data
                 Type: bytes calldata
                 Source: "msg.data"
                Identifier msg
                   Type: msg
                   Source: "msg"
            BinaryOperation using operator +
               Type: uint256
               Source: "size + 4"
              Identifier size
                 Type: uint256
                 Source: "size"
              Literal, token: [no token] value: 4
                 Type: int_const 4
                 Source: "4"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 0
       Source: "onlyPayloadSize(2 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 64
         Source: "2 * 32"
        Literal, token: [no token] value: 2
           Type: int_const 2
           Source: "2"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }"
      IfStatement
         Source: "if (balances[msg.sender] >= _value) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 0
           Source: "balances[msg.sender] >= _value"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
        Block
           Source: "{\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "balances[msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 0
             Source: "balances[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balances[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 0
             Source: "Transfer(msg.sender, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(msg.sender, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 0
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{ return false; }"
          Return
             Gas costs: 0
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 0
       Source: "onlyPayloadSize(3 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 96
         Source: "3 * 32"
        Literal, token: [no token] value: 3
           Type: int_const 3
           Source: "3"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }"
      IfStatement
         Source: "if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "balances[_from] >= _value && allowed[_from][msg.sender] >= _value"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[_from] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[_from]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
          BinaryOperation using operator >=
             Type: bool
             Source: "allowed[_from][msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "allowed[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[_from]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
        Block
           Source: "{\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "balances[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balances[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 0
             Source: "balances[_from] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[_from] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 0
             Source: "allowed[_from][msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "allowed[_from][msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 0
             Source: "Transfer(_from, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(_from, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              Identifier _from
                 Type: address
                 Source: "_from"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 0
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{ return false; }"
          Return
             Gas costs: 0
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint balance"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return balances[_owner];\r\n    }"
      Return
         Gas costs: 0
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 0
       Source: "onlyPayloadSize(2 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 64
         Source: "2 * 32"
        Literal, token: [no token] value: 2
           Type: int_const 2
           Source: "2"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert((_value == 0) || (allowed[msg.sender][_spender] == 0))"
        FunctionCall
           Type: tuple()
           Source: "assert((_value == 0) || (allowed[msg.sender][_spender] == 0))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "(_value == 0) || (allowed[msg.sender][_spender] == 0)"
            TupleExpression
               Type: bool
               Source: "(_value == 0)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "_value == 0"
                Identifier _value
                   Type: uint256
                   Source: "_value"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            TupleExpression
               Type: bool
               Source: "(allowed[msg.sender][_spender] == 0)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "allowed[msg.sender][_spender] == 0"
                IndexAccess
                   Type: uint256
                   Source: "allowed[msg.sender][_spender]"
                  IndexAccess
                     Type: mapping(address => uint256)
                     Source: "allowed[msg.sender]"
                    Identifier allowed
                       Type: mapping(address => mapping(address => uint256))
                       Source: "allowed"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                  Identifier _spender
                     Type: address
                     Source: "_spender"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n      return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint remaining"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n      return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 0
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint) balances"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "tokenRecipient"
   Gas costs: 0
   Source: "contract tokenRecipient { \r\n\tfunction receiveApproval(\r\n\t\taddress _from, \r\n\t\tuint256 _value, \r\n\t\taddress _token, \r\n\t\tbytes _extraData); \r\n}"
  FunctionDefinition "receiveApproval" - public
     Source: "function receiveApproval(\r\n\t\taddress _from, \r\n\t\tuint256 _value, \r\n\t\taddress _token, \r\n\t\tbytes _extraData);"
    ParameterList
       Source: "(\r\n\t\taddress _from, \r\n\t\tuint256 _value, \r\n\t\taddress _token, \r\n\t\tbytes _extraData)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: ""
ContractDefinition "ClipperCoin"
   Source: "contract ClipperCoin is Owned{\r\n    using SafeMath for uint;\r\n\r\n    /// Constant token specific fields\r\n    string public name = \"Clipper Coin\";\r\n    string public symbol = \"CCCT\";\r\n    uint public decimals = 18;\r\n\r\n    /// Total supply of Clipper Coin\r\n    uint public totalSupply = 200000000 ether;\r\n    \r\n    /// Create an array with all balances\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    \r\n    /// Generate public event on the blockchain that will notify clients of transfers\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    /// Generate public event on the blockchain that notifies clients how much CCC has \r\n    /// been destroyed\r\n    event Burn(address indexed from, uint256 value);\r\n    \r\n    /// Initialize contract with initial supply of tokens sent to the creator of the \r\n    /// contract, who is defined as the minter of the coin\r\n    function ClipperCoin(\r\n    \tuint256 initialSupply,\r\n    \tuint8 tokenDecimals,\r\n    \tstring tokenName,\r\n    \tstring tokenSymbol\r\n    \t) {\r\n    \t    \r\n    \t//Give creator all initial tokens\r\n    \tbalanceOf[msg.sender]  = initialSupply;\r\n    \t\r\n    \t// Set the total supply of all Clipper Coins\r\n    \ttotalSupply  = initialSupply;\r\n    \t\r\n    \t// Set the name of Clipper Coins\r\n    \tname = tokenName;\r\n    \t\r\n    \t// Set the symbol of Clipper Coins: CCC\r\n    \tsymbol = tokenSymbol;\r\n    \t\r\n    \t// Set the amount of decimal places present in Clipper Coin: 18\r\n    \t// Note: 18 is the ethereum standard\r\n    \tdecimals = tokenDecimals;\r\n    }\r\n    \r\n    \r\n    /// Internal transfers, which can only be called by this contract.\r\n    function _transfer(\r\n    \taddress _from,\r\n    \taddress _to,\r\n    \tuint _value)\r\n    \tinternal {\r\n    \t    \r\n    \t// Prevent transfers to the 0x0 address. Use burn() instead to \r\n    \t// permanently remove Clipper Coins from the Blockchain\r\n    \trequire (_to != 0x0);\r\n    \t\r\n    \t// Check that the account has enough Clipper Coins to be transferred\r\n        require (balanceOf[_from] > _value);                \r\n        \r\n        // Check that the subraction of coins is not occuring\r\n        require (balanceOf[_to] + _value > balanceOf[_to]); \r\n        balanceOf[_from] -= _value;                         \r\n        balanceOf[_to] += _value;                           \r\n        Transfer(_from, _to, _value);\r\n    }\r\n    \r\n    /// @notice Send `_value` tokens to `_to` from your account\r\n    /// @param _to The address of the recipient\r\n    /// @param _value the amount to send\r\n    function transfer(\r\n    \taddress _to, \r\n    \tuint256 _value) {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /// @notice Send `_value` tokens to `_to` on behalf of `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value the amount to send\r\n    function transferFrom(\r\n    \taddress _from, \r\n    \taddress _to, \r\n    \tuint256 _value) returns (bool success) {\r\n        require (_value < allowance[_from][msg.sender]);     \r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows `_spender` to spend no more than `_value` tokens on your behalf\r\n    /// @param _spender The address authorized to spend\r\n    /// @param _value the max amount they can spend\r\n    function approve(\r\n    \taddress _spender, \r\n    \tuint256 _value) returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows `_spender` to spend no more than `_value` tokens on your behalf, \r\n    ///\t\t\tand then ping the contract about it\r\n    /// @param _spender The address authorized to spend\r\n    /// @param _value the max amount they can spend\r\n    /// @param _extraData some extra information to send to the approved contract\r\n    function approveAndCall(\r\n    \taddress _spender, \r\n    \tuint256 _value, \r\n    \tbytes _extraData) returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }        \r\n\r\n    /// @notice Remove `_value` tokens from the system irreversibly\r\n    /// @param _value the amount of money to burn\r\n    function burn(uint256 _value) returns (bool success) {\r\n        require (balanceOf[msg.sender] > _value);            \r\n        balanceOf[msg.sender] -= _value;                      \r\n        totalSupply -= _value;                                \r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    function burnFrom(\r\n    \taddress _from, \r\n    \tuint256 _value) returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                \r\n        require(_value <= allowance[_from][msg.sender]);    \r\n        balanceOf[_from] -= _value;                         \r\n        allowance[_from][msg.sender] -= _value;             \r\n        totalSupply -= _value;                              \r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Owned"
    UserDefinedTypeName "Owned"
       Source: "Owned"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public name = \"Clipper Coin\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Clipper Coin
       Type: literal_string "Clipper Coin"
       Source: "\"Clipper Coin\""
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public symbol = \"CCCT\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: CCCT
       Type: literal_string "CCCT"
       Source: "\"CCCT\""
  VariableDeclaration "decimals"
     Type: uint256
     Gas costs: [???]
     Source: "uint public decimals = 18"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "totalSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint public totalSupply = 200000000 ether"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 200000000
       Type: int_const 200000000000000000000000000
       Source: "200000000 ether"
  VariableDeclaration "balanceOf"
     Type: mapping(address => uint256)
     Gas costs: [???]
     Source: "mapping (address => uint256) public balanceOf"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowance"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: [???]
     Source: "mapping (address => mapping (address => uint256)) public allowance"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Gas costs: 0
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Burn"
     Gas costs: 0
     Source: "event Burn(address indexed from, uint256 value);"
    ParameterList
       Source: "(address indexed from, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "ClipperCoin" - public
     Source: "function ClipperCoin(\r\n    \tuint256 initialSupply,\r\n    \tuint8 tokenDecimals,\r\n    \tstring tokenName,\r\n    \tstring tokenSymbol\r\n    \t) {\r\n    \t    \r\n    \t//Give creator all initial tokens\r\n    \tbalanceOf[msg.sender]  = initialSupply;\r\n    \t\r\n    \t// Set the total supply of all Clipper Coins\r\n    \ttotalSupply  = initialSupply;\r\n    \t\r\n    \t// Set the name of Clipper Coins\r\n    \tname = tokenName;\r\n    \t\r\n    \t// Set the symbol of Clipper Coins: CCC\r\n    \tsymbol = tokenSymbol;\r\n    \t\r\n    \t// Set the amount of decimal places present in Clipper Coin: 18\r\n    \t// Note: 18 is the ethereum standard\r\n    \tdecimals = tokenDecimals;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n    \tuint256 initialSupply,\r\n    \tuint8 tokenDecimals,\r\n    \tstring tokenName,\r\n    \tstring tokenSymbol\r\n    \t)"
      VariableDeclaration "initialSupply"
         Type: uint256
         Source: "uint256 initialSupply"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "tokenDecimals"
         Type: uint8
         Source: "uint8 tokenDecimals"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "tokenName"
         Type: string memory
         Source: "string tokenName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "tokenSymbol"
         Type: string memory
         Source: "string tokenSymbol"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    \t    \r\n    \t//Give creator all initial tokens\r\n    \tbalanceOf[msg.sender]  = initialSupply;\r\n    \t\r\n    \t// Set the total supply of all Clipper Coins\r\n    \ttotalSupply  = initialSupply;\r\n    \t\r\n    \t// Set the name of Clipper Coins\r\n    \tname = tokenName;\r\n    \t\r\n    \t// Set the symbol of Clipper Coins: CCC\r\n    \tsymbol = tokenSymbol;\r\n    \t\r\n    \t// Set the amount of decimal places present in Clipper Coin: 18\r\n    \t// Note: 18 is the ethereum standard\r\n    \tdecimals = tokenDecimals;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "balanceOf[msg.sender]  = initialSupply"
        Assignment using operator =
           Type: uint256
           Source: "balanceOf[msg.sender]  = initialSupply"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier initialSupply
             Type: uint256
             Source: "initialSupply"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply  = initialSupply"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply  = initialSupply"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier initialSupply
             Type: uint256
             Source: "initialSupply"
      ExpressionStatement
         Gas costs: 0
         Source: "name = tokenName"
        Assignment using operator =
           Type: string storage ref
           Source: "name = tokenName"
          Identifier name
             Type: string storage ref
             Source: "name"
          Identifier tokenName
             Type: string memory
             Source: "tokenName"
      ExpressionStatement
         Gas costs: 0
         Source: "symbol = tokenSymbol"
        Assignment using operator =
           Type: string storage ref
           Source: "symbol = tokenSymbol"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
          Identifier tokenSymbol
             Type: string memory
             Source: "tokenSymbol"
      ExpressionStatement
         Gas costs: 0
         Source: "decimals = tokenDecimals"
        Assignment using operator =
           Type: uint256
           Source: "decimals = tokenDecimals"
          Identifier decimals
             Type: uint256
             Source: "decimals"
          Identifier tokenDecimals
             Type: uint8
             Source: "tokenDecimals"
  FunctionDefinition "_transfer"
     Source: "function _transfer(\r\n    \taddress _from,\r\n    \taddress _to,\r\n    \tuint _value)\r\n    \tinternal {\r\n    \t    \r\n    \t// Prevent transfers to the 0x0 address. Use burn() instead to \r\n    \t// permanently remove Clipper Coins from the Blockchain\r\n    \trequire (_to != 0x0);\r\n    \t\r\n    \t// Check that the account has enough Clipper Coins to be transferred\r\n        require (balanceOf[_from] > _value);                \r\n        \r\n        // Check that the subraction of coins is not occuring\r\n        require (balanceOf[_to] + _value > balanceOf[_to]); \r\n        balanceOf[_from] -= _value;                         \r\n        balanceOf[_to] += _value;                           \r\n        Transfer(_from, _to, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n    \taddress _from,\r\n    \taddress _to,\r\n    \tuint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    \t    \r\n    \t// Prevent transfers to the 0x0 address. Use burn() instead to \r\n    \t// permanently remove Clipper Coins from the Blockchain\r\n    \trequire (_to != 0x0);\r\n    \t\r\n    \t// Check that the account has enough Clipper Coins to be transferred\r\n        require (balanceOf[_from] > _value);                \r\n        \r\n        // Check that the subraction of coins is not occuring\r\n        require (balanceOf[_to] + _value > balanceOf[_to]); \r\n        balanceOf[_from] -= _value;                         \r\n        balanceOf[_to] += _value;                           \r\n        Transfer(_from, _to, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "require (_to != 0x0)"
        FunctionCall
           Type: tuple()
           Source: "require (_to != 0x0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != 0x0"
            Identifier _to
               Type: address
               Source: "_to"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      ExpressionStatement
         Gas costs: 331
         Source: "require (balanceOf[_from] > _value)"
        FunctionCall
           Type: tuple()
           Source: "require (balanceOf[_from] > _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balanceOf[_from] > _value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_from]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 627
         Source: "require (balanceOf[_to] + _value > balanceOf[_to])"
        FunctionCall
           Type: tuple()
           Source: "require (balanceOf[_to] + _value > balanceOf[_to])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balanceOf[_to] + _value > balanceOf[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balanceOf[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[_to]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_to]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _to
                 Type: address
                 Source: "_to"
      ExpressionStatement
         Gas costs: 20329
         Source: "balanceOf[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_from]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balanceOf[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_to]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "transfer" - public
     Source: "function transfer(\r\n    \taddress _to, \r\n    \tuint256 _value) {\r\n        _transfer(msg.sender, _to, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n    \taddress _to, \r\n    \tuint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        _transfer(msg.sender, _to, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 12
         Source: "_transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "_transfer(msg.sender, _to, _value)"
          Identifier _transfer
             Type: function (address,address,uint256)
             Source: "_transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(\r\n    \taddress _from, \r\n    \taddress _to, \r\n    \tuint256 _value) returns (bool success) {\r\n        require (_value < allowance[_from][msg.sender]);     \r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n    \taddress _from, \r\n    \taddress _to, \r\n    \tuint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require (_value < allowance[_from][msg.sender]);     \r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 420
         Source: "require (_value < allowance[_from][msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require (_value < allowance[_from][msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "_value < allowance[_from][msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "allowance[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowance[_from]"
                Identifier allowance
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowance"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 20418
         Source: "allowance[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowance[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowance[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowance[_from]"
              Identifier allowance
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowance"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 24
         Source: "_transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "_transfer(_from, _to, _value)"
          Identifier _transfer
             Type: function (address,address,uint256)
             Source: "_transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approve" - public
     Source: "function approve(\r\n    \taddress _spender, \r\n    \tuint256 _value) returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n    \taddress _spender, \r\n    \tuint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowance[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowance[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowance[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowance[msg.sender]"
              Identifier allowance
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowance"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approveAndCall" - public
     Source: "function approveAndCall(\r\n    \taddress _spender, \r\n    \tuint256 _value, \r\n    \tbytes _extraData) returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n    \taddress _spender, \r\n    \tuint256 _value, \r\n    \tbytes _extraData)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "tokenRecipient spender = tokenRecipient(_spender)"
        VariableDeclaration "spender"
           Type: contract tokenRecipient
           Source: "tokenRecipient spender"
          UserDefinedTypeName "tokenRecipient"
             Source: "tokenRecipient"
        FunctionCall
           Type: contract tokenRecipient
           Source: "tokenRecipient(_spender)"
          Identifier tokenRecipient
             Type: type(contract tokenRecipient)
             Source: "tokenRecipient"
          Identifier _spender
             Type: address
             Source: "_spender"
      IfStatement
         Source: "if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 21
           Source: "approve(_spender, _value)"
          Identifier approve
             Type: function (address,uint256) returns (bool)
             Source: "approve"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
        Block
           Source: "{\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "spender.receiveApproval(msg.sender, _value, this, _extraData)"
            FunctionCall
               Type: tuple()
               Source: "spender.receiveApproval(msg.sender, _value, this, _extraData)"
              MemberAccess to member receiveApproval
                 Type: function (address,uint256,address,bytes memory) external
                 Source: "spender.receiveApproval"
                Identifier spender
                   Type: contract tokenRecipient
                   Source: "spender"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier this
                 Type: contract ClipperCoin
                 Source: "this"
              Identifier _extraData
                 Type: bytes memory
                 Source: "_extraData"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
  FunctionDefinition "burn" - public
     Source: "function burn(uint256 _value) returns (bool success) {\r\n        require (balanceOf[msg.sender] > _value);            \r\n        balanceOf[msg.sender] -= _value;                      \r\n        totalSupply -= _value;                                \r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _value)"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require (balanceOf[msg.sender] > _value);            \r\n        balanceOf[msg.sender] -= _value;                      \r\n        totalSupply -= _value;                                \r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 330
         Source: "require (balanceOf[msg.sender] > _value)"
        FunctionCall
           Type: tuple()
           Source: "require (balanceOf[msg.sender] > _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balanceOf[msg.sender] > _value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[msg.sender]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20328
         Source: "balanceOf[msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= _value"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Burn(msg.sender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Burn(msg.sender, _value)"
          Identifier Burn
             Type: function (address,uint256)
             Source: "Burn"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "burnFrom" - public
     Source: "function burnFrom(\r\n    \taddress _from, \r\n    \tuint256 _value) returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                \r\n        require(_value <= allowance[_from][msg.sender]);    \r\n        balanceOf[_from] -= _value;                         \r\n        allowance[_from][msg.sender] -= _value;             \r\n        totalSupply -= _value;                              \r\n        Burn(_from, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n    \taddress _from, \r\n    \tuint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require(balanceOf[_from] >= _value);                \r\n        require(_value <= allowance[_from][msg.sender]);    \r\n        balanceOf[_from] -= _value;                         \r\n        allowance[_from][msg.sender] -= _value;             \r\n        totalSupply -= _value;                              \r\n        Burn(_from, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 334
         Source: "require(balanceOf[_from] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balanceOf[_from] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balanceOf[_from] >= _value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_from]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 423
         Source: "require(_value <= allowance[_from][msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= allowance[_from][msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= allowance[_from][msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "allowance[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowance[_from]"
                Identifier allowance
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowance"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 20329
         Source: "balanceOf[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_from]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20412
         Source: "allowance[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowance[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowance[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowance[_from]"
              Identifier allowance
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowance"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= _value"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Burn(_from, _value)"
        FunctionCall
           Type: tuple()
           Source: "Burn(_from, _value)"
          Identifier Burn
             Type: function (address,uint256)
             Source: "Burn"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
