Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x7e392f3cec15325e21363aace49575b9196f2464.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.6;"
ContractDefinition "multiowned"
   Source: "contract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has six types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _;\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n\r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n\r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n\r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n\r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n\r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n\r\n    // Gets an owner by 0-indexed position (using numOwners as the count)\r\n    function getOwner(uint ownerIndex) external constant returns (address) {\r\n        return address(m_owners[ownerIndex + 1]);\r\n    }\r\n\r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n\r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        return !(pending.ownersDone & ownerIndexBit == 0);\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n\r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}"
  StructDefinition "PendingState"
     Gas costs: 0
     Source: "struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }"
    VariableDeclaration "yetNeeded"
       Type: uint256
       Source: "uint yetNeeded"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "ownersDone"
       Type: uint256
       Source: "uint ownersDone"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "index"
       Type: uint256
       Source: "uint index"
      ElementaryTypeName uint
         Source: "uint"
  EventDefinition "Confirmation"
     Gas costs: 0
     Source: "event Confirmation(address owner, bytes32 operation);"
    ParameterList
       Source: "(address owner, bytes32 operation)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "operation"
         Type: bytes32
         Source: "bytes32 operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
  EventDefinition "Revoke"
     Gas costs: 0
     Source: "event Revoke(address owner, bytes32 operation);"
    ParameterList
       Source: "(address owner, bytes32 operation)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "operation"
         Type: bytes32
         Source: "bytes32 operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
  EventDefinition "OwnerChanged"
     Gas costs: 0
     Source: "event OwnerChanged(address oldOwner, address newOwner);"
    ParameterList
       Source: "(address oldOwner, address newOwner)"
      VariableDeclaration "oldOwner"
         Type: address
         Source: "address oldOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "OwnerAdded"
     Gas costs: 0
     Source: "event OwnerAdded(address newOwner);"
    ParameterList
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "OwnerRemoved"
     Gas costs: 0
     Source: "event OwnerRemoved(address oldOwner);"
    ParameterList
       Source: "(address oldOwner)"
      VariableDeclaration "oldOwner"
         Type: address
         Source: "address oldOwner"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "RequirementChanged"
     Gas costs: 0
     Source: "event RequirementChanged(uint newRequirement);"
    ParameterList
       Source: "(uint newRequirement)"
      VariableDeclaration "newRequirement"
         Type: uint256
         Source: "uint newRequirement"
        ElementaryTypeName uint
           Source: "uint"
  ModifierDefinition "onlyowner"
     Source: "modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (isOwner(msg.sender))\r\n            _;\r\n    }"
      IfStatement
         Source: "if (isOwner(msg.sender))\r\n            _"
        FunctionCall
           Type: bool
           Gas costs: 34
           Source: "isOwner(msg.sender)"
          Identifier isOwner
             Type: function (address) returns (bool)
             Source: "isOwner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
        PlaceholderStatement
           Gas costs: 2
           Source: "_"
  ModifierDefinition "onlymanyowners"
     Source: "modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        if (confirmAndCheck(_operation))\r\n            _;\r\n    }"
      IfStatement
         Source: "if (confirmAndCheck(_operation))\r\n            _"
        FunctionCall
           Type: bool
           Gas costs: 133
           Source: "confirmAndCheck(_operation)"
          Identifier confirmAndCheck
             Type: function (bytes32) returns (bool)
             Source: "confirmAndCheck"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
        PlaceholderStatement
           Gas costs: 5
           Source: "_"
  FunctionDefinition "multiowned" - public
     Source: "function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _owners, uint _required)"
      VariableDeclaration "_owners"
         Type: address[] memory
         Source: "address[] _owners"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_required"
         Type: uint256
         Source: "uint _required"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "m_numOwners = _owners.length + 1"
        Assignment using operator =
           Type: uint256
           Source: "m_numOwners = _owners.length + 1"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
          BinaryOperation using operator +
             Type: uint256
             Source: "_owners.length + 1"
            MemberAccess to member length
               Type: uint256
               Source: "_owners.length"
              Identifier _owners
                 Type: address[] memory
                 Source: "_owners"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "m_owners[1] = uint(msg.sender)"
        Assignment using operator =
           Type: uint256
           Source: "m_owners[1] = uint(msg.sender)"
          IndexAccess
             Type: uint256
             Source: "m_owners[1]"
            Identifier m_owners
               Type: uint256[256] storage ref
               Source: "m_owners"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          FunctionCall
             Type: uint256
             Source: "uint(msg.sender)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "m_ownerIndex[uint(msg.sender)] = 1"
        Assignment using operator =
           Type: uint256
           Source: "m_ownerIndex[uint(msg.sender)] = 1"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[uint(msg.sender)]"
            Identifier m_ownerIndex
               Type: mapping(uint256 => uint256)
               Source: "m_ownerIndex"
            FunctionCall
               Type: uint256
               Source: "uint(msg.sender)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ForStatement
         Source: "for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < _owners.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_owners.length"
            Identifier _owners
               Type: address[] memory
               Source: "_owners"
        ExpressionStatement
           Gas costs: 0
           Source: "++i"
          UnaryOperation (prefix) ++
             Type: uint256
             Source: "++i"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "m_owners[2 + i] = uint(_owners[i])"
            Assignment using operator =
               Type: uint256
               Source: "m_owners[2 + i] = uint(_owners[i])"
              IndexAccess
                 Type: uint256
                 Source: "m_owners[2 + i]"
                Identifier m_owners
                   Type: uint256[256] storage ref
                   Source: "m_owners"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "2 + i"
                  Literal, token: [no token] value: 2
                     Type: int_const 2
                     Source: "2"
                  Identifier i
                     Type: uint256
                     Source: "i"
              FunctionCall
                 Type: uint256
                 Source: "uint(_owners[i])"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                IndexAccess
                   Type: address
                   Source: "_owners[i]"
                  Identifier _owners
                     Type: address[] memory
                     Source: "_owners"
                  Identifier i
                     Type: uint256
                     Source: "i"
          ExpressionStatement
             Gas costs: 0
             Source: "m_ownerIndex[uint(_owners[i])] = 2 + i"
            Assignment using operator =
               Type: uint256
               Source: "m_ownerIndex[uint(_owners[i])] = 2 + i"
              IndexAccess
                 Type: uint256
                 Source: "m_ownerIndex[uint(_owners[i])]"
                Identifier m_ownerIndex
                   Type: mapping(uint256 => uint256)
                   Source: "m_ownerIndex"
                FunctionCall
                   Type: uint256
                   Source: "uint(_owners[i])"
                  ElementaryTypeNameExpression uint
                     Type: type(uint256)
                     Source: "uint"
                  IndexAccess
                     Type: address
                     Source: "_owners[i]"
                    Identifier _owners
                       Type: address[] memory
                       Source: "_owners"
                    Identifier i
                       Type: uint256
                       Source: "i"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "2 + i"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
                Identifier i
                   Type: uint256
                   Source: "i"
      ExpressionStatement
         Gas costs: 0
         Source: "m_required = _required"
        Assignment using operator =
           Type: uint256
           Source: "m_required = _required"
          Identifier m_required
             Type: uint256
             Source: "m_required"
          Identifier _required
             Type: uint256
             Source: "_required"
  FunctionDefinition "revoke" - public
     Source: "function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 300
         Source: "uint ownerIndex = m_ownerIndex[uint(msg.sender)]"
        VariableDeclaration "ownerIndex"
           Type: uint256
           Source: "uint ownerIndex"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "m_ownerIndex[uint(msg.sender)]"
          Identifier m_ownerIndex
             Type: mapping(uint256 => uint256)
             Source: "m_ownerIndex"
          FunctionCall
             Type: uint256
             Source: "uint(msg.sender)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      IfStatement
         Source: "if (ownerIndex == 0) return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "ownerIndex == 0"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      VariableDeclarationStatement
         Gas costs: 1624
         Source: "uint ownerIndexBit = 2**ownerIndex"
        VariableDeclaration "ownerIndexBit"
           Type: uint256
           Source: "uint ownerIndexBit"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator **
           Type: uint256
           Source: "2**ownerIndex"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
      VariableDeclarationStatement
         Gas costs: 113
         Source: "var pending = m_pending[_operation]"
        VariableDeclaration "pending"
           Type: struct multiowned.PendingState storage pointer
           Source: "var pending"
        IndexAccess
           Type: struct multiowned.PendingState storage ref
           Source: "m_pending[_operation]"
          Identifier m_pending
             Type: mapping(bytes32 => struct multiowned.PendingState storage ref)
             Source: "m_pending"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
      IfStatement
         Source: "if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 221
           Source: "pending.ownersDone & ownerIndexBit > 0"
          BinaryOperation using operator &
             Type: uint256
             Source: "pending.ownersDone & ownerIndexBit"
            MemberAccess to member ownersDone
               Type: uint256
               Source: "pending.ownersDone"
              Identifier pending
                 Type: struct multiowned.PendingState storage pointer
                 Source: "pending"
            Identifier ownerIndexBit
               Type: uint256
               Source: "ownerIndexBit"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }"
          ExpressionStatement
             Gas costs: 20243
             Source: "pending.yetNeeded++"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "pending.yetNeeded++"
              MemberAccess to member yetNeeded
                 Type: uint256
                 Source: "pending.yetNeeded"
                Identifier pending
                   Type: struct multiowned.PendingState storage pointer
                   Source: "pending"
          ExpressionStatement
             Gas costs: 20239
             Source: "pending.ownersDone -= ownerIndexBit"
            Assignment using operator -=
               Type: uint256
               Source: "pending.ownersDone -= ownerIndexBit"
              MemberAccess to member ownersDone
                 Type: uint256
                 Source: "pending.ownersDone"
                Identifier pending
                   Type: struct multiowned.PendingState storage pointer
                   Source: "pending"
              Identifier ownerIndexBit
                 Type: uint256
                 Source: "ownerIndexBit"
          ExpressionStatement
             Gas costs: [???]
             Source: "Revoke(msg.sender, _operation)"
            FunctionCall
               Type: tuple()
               Source: "Revoke(msg.sender, _operation)"
              Identifier Revoke
                 Type: function (address,bytes32)
                 Source: "Revoke"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _operation
                 Type: bytes32
                 Source: "_operation"
  FunctionDefinition "changeOwner" - public
     Source: "function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlymanyowners"
       Gas costs: [???]
       Source: "onlymanyowners(sha3(msg.data))"
      Identifier onlymanyowners
         Type: modifier (bytes32)
         Source: "onlymanyowners"
      FunctionCall
         Type: bytes32
         Source: "sha3(msg.data)"
        Identifier sha3
           Type: function () pure returns (bytes32)
           Source: "sha3"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }"
      IfStatement
         Source: "if (isOwner(_to)) return;"
        FunctionCall
           Type: bool
           Gas costs: 18
           Source: "isOwner(_to)"
          Identifier isOwner
             Type: function (address) returns (bool)
             Source: "isOwner"
          Identifier _to
             Type: address
             Source: "_to"
        Return
           Gas costs: 11
           Source: "return;"
      VariableDeclarationStatement
         Gas costs: 301
         Source: "uint ownerIndex = m_ownerIndex[uint(_from)]"
        VariableDeclaration "ownerIndex"
           Type: uint256
           Source: "uint ownerIndex"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "m_ownerIndex[uint(_from)]"
          Identifier m_ownerIndex
             Type: mapping(uint256 => uint256)
             Source: "m_ownerIndex"
          FunctionCall
             Type: uint256
             Source: "uint(_from)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            Identifier _from
               Type: address
               Source: "_from"
      IfStatement
         Source: "if (ownerIndex == 0) return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "ownerIndex == 0"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 15
         Source: "clearPending()"
        FunctionCall
           Type: tuple()
           Source: "clearPending()"
          Identifier clearPending
             Type: function ()
             Source: "clearPending"
      ExpressionStatement
         Gas costs: 20055
         Source: "m_owners[ownerIndex] = uint(_to)"
        Assignment using operator =
           Type: uint256
           Source: "m_owners[ownerIndex] = uint(_to)"
          IndexAccess
             Type: uint256
             Source: "m_owners[ownerIndex]"
            Identifier m_owners
               Type: uint256[256] storage ref
               Source: "m_owners"
            Identifier ownerIndex
               Type: uint256
               Source: "ownerIndex"
          FunctionCall
             Type: uint256
             Source: "uint(_to)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            Identifier _to
               Type: address
               Source: "_to"
      ExpressionStatement
         Gas costs: 5104
         Source: "m_ownerIndex[uint(_from)] = 0"
        Assignment using operator =
           Type: uint256
           Source: "m_ownerIndex[uint(_from)] = 0"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[uint(_from)]"
            Identifier m_ownerIndex
               Type: mapping(uint256 => uint256)
               Source: "m_ownerIndex"
            FunctionCall
               Type: uint256
               Source: "uint(_from)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              Identifier _from
                 Type: address
                 Source: "_from"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 20098
         Source: "m_ownerIndex[uint(_to)] = ownerIndex"
        Assignment using operator =
           Type: uint256
           Source: "m_ownerIndex[uint(_to)] = ownerIndex"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[uint(_to)]"
            Identifier m_ownerIndex
               Type: mapping(uint256 => uint256)
               Source: "m_ownerIndex"
            FunctionCall
               Type: uint256
               Source: "uint(_to)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              Identifier _to
                 Type: address
                 Source: "_to"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
      ExpressionStatement
         Gas costs: [???]
         Source: "OwnerChanged(_from, _to)"
        FunctionCall
           Type: tuple()
           Source: "OwnerChanged(_from, _to)"
          Identifier OwnerChanged
             Type: function (address,address)
             Source: "OwnerChanged"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
  FunctionDefinition "addOwner" - public
     Source: "function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlymanyowners"
       Gas costs: [???]
       Source: "onlymanyowners(sha3(msg.data))"
      Identifier onlymanyowners
         Type: modifier (bytes32)
         Source: "onlymanyowners"
      FunctionCall
         Type: bytes32
         Source: "sha3(msg.data)"
        Identifier sha3
           Type: function () pure returns (bytes32)
           Source: "sha3"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }"
      IfStatement
         Source: "if (isOwner(_owner)) return;"
        FunctionCall
           Type: bool
           Gas costs: 18
           Source: "isOwner(_owner)"
          Identifier isOwner
             Type: function (address) returns (bool)
             Source: "isOwner"
          Identifier _owner
             Type: address
             Source: "_owner"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 15
         Source: "clearPending()"
        FunctionCall
           Type: tuple()
           Source: "clearPending()"
          Identifier clearPending
             Type: function ()
             Source: "clearPending"
      IfStatement
         Source: "if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners()"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 209
           Source: "m_numOwners >= c_maxOwners"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
          Identifier c_maxOwners
             Type: uint256
             Source: "c_maxOwners"
        ExpressionStatement
           Gas costs: 15
           Source: "reorganizeOwners()"
          FunctionCall
             Type: tuple()
             Source: "reorganizeOwners()"
            Identifier reorganizeOwners
               Type: function ()
               Source: "reorganizeOwners"
      IfStatement
         Source: "if (m_numOwners >= c_maxOwners)\r\n            return;"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 209
           Source: "m_numOwners >= c_maxOwners"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
          Identifier c_maxOwners
             Type: uint256
             Source: "c_maxOwners"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 20237
         Source: "m_numOwners++"
        UnaryOperation (postfix) ++
           Type: uint256
           Source: "m_numOwners++"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
      ExpressionStatement
         Gas costs: 20255
         Source: "m_owners[m_numOwners] = uint(_owner)"
        Assignment using operator =
           Type: uint256
           Source: "m_owners[m_numOwners] = uint(_owner)"
          IndexAccess
             Type: uint256
             Source: "m_owners[m_numOwners]"
            Identifier m_owners
               Type: uint256[256] storage ref
               Source: "m_owners"
            Identifier m_numOwners
               Type: uint256
               Source: "m_numOwners"
          FunctionCall
             Type: uint256
             Source: "uint(_owner)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            Identifier _owner
               Type: address
               Source: "_owner"
      ExpressionStatement
         Gas costs: 20304
         Source: "m_ownerIndex[uint(_owner)] = m_numOwners"
        Assignment using operator =
           Type: uint256
           Source: "m_ownerIndex[uint(_owner)] = m_numOwners"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[uint(_owner)]"
            Identifier m_ownerIndex
               Type: mapping(uint256 => uint256)
               Source: "m_ownerIndex"
            FunctionCall
               Type: uint256
               Source: "uint(_owner)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              Identifier _owner
                 Type: address
                 Source: "_owner"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
      ExpressionStatement
         Gas costs: [???]
         Source: "OwnerAdded(_owner)"
        FunctionCall
           Type: tuple()
           Source: "OwnerAdded(_owner)"
          Identifier OwnerAdded
             Type: function (address)
             Source: "OwnerAdded"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "removeOwner" - public
     Source: "function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlymanyowners"
       Gas costs: [???]
       Source: "onlymanyowners(sha3(msg.data))"
      Identifier onlymanyowners
         Type: modifier (bytes32)
         Source: "onlymanyowners"
      FunctionCall
         Type: bytes32
         Source: "sha3(msg.data)"
        Identifier sha3
           Type: function () pure returns (bytes32)
           Source: "sha3"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 301
         Source: "uint ownerIndex = m_ownerIndex[uint(_owner)]"
        VariableDeclaration "ownerIndex"
           Type: uint256
           Source: "uint ownerIndex"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "m_ownerIndex[uint(_owner)]"
          Identifier m_ownerIndex
             Type: mapping(uint256 => uint256)
             Source: "m_ownerIndex"
          FunctionCall
             Type: uint256
             Source: "uint(_owner)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            Identifier _owner
               Type: address
               Source: "_owner"
      IfStatement
         Source: "if (ownerIndex == 0) return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "ownerIndex == 0"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      IfStatement
         Source: "if (m_required > m_numOwners - 1) return;"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 415
           Source: "m_required > m_numOwners - 1"
          Identifier m_required
             Type: uint256
             Source: "m_required"
          BinaryOperation using operator -
             Type: uint256
             Source: "m_numOwners - 1"
            Identifier m_numOwners
               Type: uint256
               Source: "m_numOwners"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 20049
         Source: "m_owners[ownerIndex] = 0"
        Assignment using operator =
           Type: uint256
           Source: "m_owners[ownerIndex] = 0"
          IndexAccess
             Type: uint256
             Source: "m_owners[ownerIndex]"
            Identifier m_owners
               Type: uint256[256] storage ref
               Source: "m_owners"
            Identifier ownerIndex
               Type: uint256
               Source: "ownerIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 5104
         Source: "m_ownerIndex[uint(_owner)] = 0"
        Assignment using operator =
           Type: uint256
           Source: "m_ownerIndex[uint(_owner)] = 0"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[uint(_owner)]"
            Identifier m_ownerIndex
               Type: mapping(uint256 => uint256)
               Source: "m_ownerIndex"
            FunctionCall
               Type: uint256
               Source: "uint(_owner)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              Identifier _owner
                 Type: address
                 Source: "_owner"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 4
         Source: "clearPending()"
        FunctionCall
           Type: tuple()
           Source: "clearPending()"
          Identifier clearPending
             Type: function ()
             Source: "clearPending"
      ExpressionStatement
         Gas costs: 4
         Source: "reorganizeOwners()"
        FunctionCall
           Type: tuple()
           Source: "reorganizeOwners()"
          Identifier reorganizeOwners
             Type: function ()
             Source: "reorganizeOwners"
      ExpressionStatement
         Gas costs: [???]
         Source: "OwnerRemoved(_owner)"
        FunctionCall
           Type: tuple()
           Source: "OwnerRemoved(_owner)"
          Identifier OwnerRemoved
             Type: function (address)
             Source: "OwnerRemoved"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "changeRequirement" - public
     Source: "function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _newRequired)"
      VariableDeclaration "_newRequired"
         Type: uint256
         Source: "uint _newRequired"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlymanyowners"
       Gas costs: [???]
       Source: "onlymanyowners(sha3(msg.data))"
      Identifier onlymanyowners
         Type: modifier (bytes32)
         Source: "onlymanyowners"
      FunctionCall
         Type: bytes32
         Source: "sha3(msg.data)"
        Identifier sha3
           Type: function () pure returns (bytes32)
           Source: "sha3"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }"
      IfStatement
         Source: "if (_newRequired > m_numOwners) return;"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "_newRequired > m_numOwners"
          Identifier _newRequired
             Type: uint256
             Source: "_newRequired"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 20014
         Source: "m_required = _newRequired"
        Assignment using operator =
           Type: uint256
           Source: "m_required = _newRequired"
          Identifier m_required
             Type: uint256
             Source: "m_required"
          Identifier _newRequired
             Type: uint256
             Source: "_newRequired"
      ExpressionStatement
         Gas costs: 15
         Source: "clearPending()"
        FunctionCall
           Type: tuple()
           Source: "clearPending()"
          Identifier clearPending
             Type: function ()
             Source: "clearPending"
      ExpressionStatement
         Gas costs: [???]
         Source: "RequirementChanged(_newRequired)"
        FunctionCall
           Type: tuple()
           Source: "RequirementChanged(_newRequired)"
          Identifier RequirementChanged
             Type: function (uint256)
             Source: "RequirementChanged"
          Identifier _newRequired
             Type: uint256
             Source: "_newRequired"
  FunctionDefinition "getOwner" - public - const
     Source: "function getOwner(uint ownerIndex) external constant returns (address) {\r\n        return address(m_owners[ownerIndex + 1]);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint ownerIndex)"
      VariableDeclaration "ownerIndex"
         Type: uint256
         Source: "uint ownerIndex"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return address(m_owners[ownerIndex + 1]);\r\n    }"
      Return
         Gas costs: 249
         Source: "return address(m_owners[ownerIndex + 1])"
        FunctionCall
           Type: address
           Source: "address(m_owners[ownerIndex + 1])"
          ElementaryTypeNameExpression address
             Type: type(address)
             Source: "address"
          IndexAccess
             Type: uint256
             Source: "m_owners[ownerIndex + 1]"
            Identifier m_owners
               Type: uint256[256] storage ref
               Source: "m_owners"
            BinaryOperation using operator +
               Type: uint256
               Source: "ownerIndex + 1"
              Identifier ownerIndex
                 Type: uint256
                 Source: "ownerIndex"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
  FunctionDefinition "isOwner" - public
     Source: "function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _addr)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }"
      Return
         Gas costs: 304
         Source: "return m_ownerIndex[uint(_addr)] > 0"
        BinaryOperation using operator >
           Type: bool
           Source: "m_ownerIndex[uint(_addr)] > 0"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[uint(_addr)]"
            Identifier m_ownerIndex
               Type: mapping(uint256 => uint256)
               Source: "m_ownerIndex"
            FunctionCall
               Type: uint256
               Source: "uint(_addr)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              Identifier _addr
                 Type: address
                 Source: "_addr"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "hasConfirmed" - public - const
     Source: "function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        return !(pending.ownersDone & ownerIndexBit == 0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation, address _owner)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        return !(pending.ownersDone & ownerIndexBit == 0);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 113
         Source: "var pending = m_pending[_operation]"
        VariableDeclaration "pending"
           Type: struct multiowned.PendingState storage pointer
           Source: "var pending"
        IndexAccess
           Type: struct multiowned.PendingState storage ref
           Source: "m_pending[_operation]"
          Identifier m_pending
             Type: mapping(bytes32 => struct multiowned.PendingState storage ref)
             Source: "m_pending"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
      VariableDeclarationStatement
         Gas costs: 295
         Source: "uint ownerIndex = m_ownerIndex[uint(_owner)]"
        VariableDeclaration "ownerIndex"
           Type: uint256
           Source: "uint ownerIndex"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "m_ownerIndex[uint(_owner)]"
          Identifier m_ownerIndex
             Type: mapping(uint256 => uint256)
             Source: "m_ownerIndex"
          FunctionCall
             Type: uint256
             Source: "uint(_owner)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            Identifier _owner
               Type: address
               Source: "_owner"
      IfStatement
         Source: "if (ownerIndex == 0) return false"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "ownerIndex == 0"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      VariableDeclarationStatement
         Gas costs: 1624
         Source: "uint ownerIndexBit = 2**ownerIndex"
        VariableDeclaration "ownerIndexBit"
           Type: uint256
           Source: "uint ownerIndexBit"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator **
           Type: uint256
           Source: "2**ownerIndex"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
      Return
         Gas costs: 229
         Source: "return !(pending.ownersDone & ownerIndexBit == 0)"
        UnaryOperation (prefix) !
           Type: bool
           Source: "!(pending.ownersDone & ownerIndexBit == 0)"
          TupleExpression
             Type: bool
             Source: "(pending.ownersDone & ownerIndexBit == 0)"
            BinaryOperation using operator ==
               Type: bool
               Source: "pending.ownersDone & ownerIndexBit == 0"
              BinaryOperation using operator &
                 Type: uint256
                 Source: "pending.ownersDone & ownerIndexBit"
                MemberAccess to member ownersDone
                   Type: uint256
                   Source: "pending.ownersDone"
                  Identifier pending
                     Type: struct multiowned.PendingState storage pointer
                     Source: "pending"
                Identifier ownerIndexBit
                   Type: uint256
                   Source: "ownerIndexBit"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
  FunctionDefinition "confirmAndCheck"
     Source: "function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 300
         Source: "uint ownerIndex = m_ownerIndex[uint(msg.sender)]"
        VariableDeclaration "ownerIndex"
           Type: uint256
           Source: "uint ownerIndex"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "m_ownerIndex[uint(msg.sender)]"
          Identifier m_ownerIndex
             Type: mapping(uint256 => uint256)
             Source: "m_ownerIndex"
          FunctionCall
             Type: uint256
             Source: "uint(msg.sender)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      IfStatement
         Source: "if (ownerIndex == 0) return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "ownerIndex == 0"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      VariableDeclarationStatement
         Gas costs: 113
         Source: "var pending = m_pending[_operation]"
        VariableDeclaration "pending"
           Type: struct multiowned.PendingState storage pointer
           Source: "var pending"
        IndexAccess
           Type: struct multiowned.PendingState storage ref
           Source: "m_pending[_operation]"
          Identifier m_pending
             Type: mapping(bytes32 => struct multiowned.PendingState storage ref)
             Source: "m_pending"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
      IfStatement
         Source: "if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 215
           Source: "pending.yetNeeded == 0"
          MemberAccess to member yetNeeded
             Type: uint256
             Source: "pending.yetNeeded"
            Identifier pending
               Type: struct multiowned.PendingState storage pointer
               Source: "pending"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }"
          ExpressionStatement
             Gas costs: 20220
             Source: "pending.yetNeeded = m_required"
            Assignment using operator =
               Type: uint256
               Source: "pending.yetNeeded = m_required"
              MemberAccess to member yetNeeded
                 Type: uint256
                 Source: "pending.yetNeeded"
                Identifier pending
                   Type: struct multiowned.PendingState storage pointer
                   Source: "pending"
              Identifier m_required
                 Type: uint256
                 Source: "m_required"
          ExpressionStatement
             Gas costs: 5020
             Source: "pending.ownersDone = 0"
            Assignment using operator =
               Type: uint256
               Source: "pending.ownersDone = 0"
              MemberAccess to member ownersDone
                 Type: uint256
                 Source: "pending.ownersDone"
                Identifier pending
                   Type: struct multiowned.PendingState storage pointer
                   Source: "pending"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          ExpressionStatement
             Gas costs: 20248
             Source: "pending.index = m_pendingIndex.length++"
            Assignment using operator =
               Type: uint256
               Source: "pending.index = m_pendingIndex.length++"
              MemberAccess to member index
                 Type: uint256
                 Source: "pending.index"
                Identifier pending
                   Type: struct multiowned.PendingState storage pointer
                   Source: "pending"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "m_pendingIndex.length++"
                MemberAccess to member length
                   Type: uint256
                   Source: "m_pendingIndex.length"
                  Identifier m_pendingIndex
                     Type: bytes32[] storage ref
                     Source: "m_pendingIndex"
          ExpressionStatement
             Gas costs: 20518
             Source: "m_pendingIndex[pending.index] = _operation"
            Assignment using operator =
               Type: bytes32
               Source: "m_pendingIndex[pending.index] = _operation"
              IndexAccess
                 Type: bytes32
                 Source: "m_pendingIndex[pending.index]"
                Identifier m_pendingIndex
                   Type: bytes32[] storage ref
                   Source: "m_pendingIndex"
                MemberAccess to member index
                   Type: uint256
                   Source: "pending.index"
                  Identifier pending
                     Type: struct multiowned.PendingState storage pointer
                     Source: "pending"
              Identifier _operation
                 Type: bytes32
                 Source: "_operation"
      VariableDeclarationStatement
         Gas costs: 1624
         Source: "uint ownerIndexBit = 2**ownerIndex"
        VariableDeclaration "ownerIndexBit"
           Type: uint256
           Source: "uint ownerIndexBit"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator **
           Type: uint256
           Source: "2**ownerIndex"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
      IfStatement
         Source: "if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 221
           Source: "pending.ownersDone & ownerIndexBit == 0"
          BinaryOperation using operator &
             Type: uint256
             Source: "pending.ownersDone & ownerIndexBit"
            MemberAccess to member ownersDone
               Type: uint256
               Source: "pending.ownersDone"
              Identifier pending
                 Type: struct multiowned.PendingState storage pointer
                 Source: "pending"
            Identifier ownerIndexBit
               Type: uint256
               Source: "ownerIndexBit"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "Confirmation(msg.sender, _operation)"
            FunctionCall
               Type: tuple()
               Source: "Confirmation(msg.sender, _operation)"
              Identifier Confirmation
                 Type: function (address,bytes32)
                 Source: "Confirmation"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _operation
                 Type: bytes32
                 Source: "_operation"
          IfStatement
             Source: "if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }"
            BinaryOperation using operator <=
               Type: bool
               Gas costs: 218
               Source: "pending.yetNeeded <= 1"
              MemberAccess to member yetNeeded
                 Type: uint256
                 Source: "pending.yetNeeded"
                Identifier pending
                   Type: struct multiowned.PendingState storage pointer
                   Source: "pending"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            Block
               Source: "{\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }"
              ExpressionStatement
                 Gas costs: 5606
                 Source: "delete m_pendingIndex[m_pending[_operation].index]"
                UnaryOperation (prefix) delete
                   Type: tuple()
                   Source: "delete m_pendingIndex[m_pending[_operation].index]"
                  IndexAccess
                     Type: bytes32
                     Source: "m_pendingIndex[m_pending[_operation].index]"
                    Identifier m_pendingIndex
                       Type: bytes32[] storage ref
                       Source: "m_pendingIndex"
                    MemberAccess to member index
                       Type: uint256
                       Source: "m_pending[_operation].index"
                      IndexAccess
                         Type: struct multiowned.PendingState storage ref
                         Source: "m_pending[_operation]"
                        Identifier m_pending
                           Type: mapping(bytes32 => struct multiowned.PendingState storage ref)
                           Source: "m_pending"
                        Identifier _operation
                           Type: bytes32
                           Source: "_operation"
              ExpressionStatement
                 Gas costs: 15154
                 Source: "delete m_pending[_operation]"
                UnaryOperation (prefix) delete
                   Type: tuple()
                   Source: "delete m_pending[_operation]"
                  IndexAccess
                     Type: struct multiowned.PendingState storage ref
                     Source: "m_pending[_operation]"
                    Identifier m_pending
                       Type: mapping(bytes32 => struct multiowned.PendingState storage ref)
                       Source: "m_pending"
                    Identifier _operation
                       Type: bytes32
                       Source: "_operation"
              Return
                 Gas costs: 19
                 Source: "return true"
                Literal, token: true value: true
                   Type: bool
                   Source: "true"
            Block
               Source: "{\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }"
              ExpressionStatement
                 Gas costs: 20246
                 Source: "pending.yetNeeded--"
                UnaryOperation (postfix) --
                   Type: uint256
                   Source: "pending.yetNeeded--"
                  MemberAccess to member yetNeeded
                     Type: uint256
                     Source: "pending.yetNeeded"
                    Identifier pending
                       Type: struct multiowned.PendingState storage pointer
                       Source: "pending"
              ExpressionStatement
                 Gas costs: 20239
                 Source: "pending.ownersDone |= ownerIndexBit"
                Assignment using operator |=
                   Type: uint256
                   Source: "pending.ownersDone |= ownerIndexBit"
                  MemberAccess to member ownersDone
                     Type: uint256
                     Source: "pending.ownersDone"
                    Identifier pending
                       Type: struct multiowned.PendingState storage pointer
                       Source: "pending"
                  Identifier ownerIndexBit
                     Type: uint256
                     Source: "ownerIndexBit"
  FunctionDefinition "reorganizeOwners"
     Source: "function reorganizeOwners() private {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint free = 1"
        VariableDeclaration "free"
           Type: uint256
           Source: "uint free"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 1
           Type: int_const 1
           Source: "1"
      WhileStatement
         Source: "while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 209
           Source: "free < m_numOwners"
          Identifier free
             Type: uint256
             Source: "free"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
        Block
           Source: "{\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }"
          WhileStatement
             Source: "while (free < m_numOwners && m_owners[free] != 0) free++"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 478
               Source: "free < m_numOwners && m_owners[free] != 0"
              BinaryOperation using operator <
                 Type: bool
                 Source: "free < m_numOwners"
                Identifier free
                   Type: uint256
                   Source: "free"
                Identifier m_numOwners
                   Type: uint256
                   Source: "m_numOwners"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "m_owners[free] != 0"
                IndexAccess
                   Type: uint256
                   Source: "m_owners[free]"
                  Identifier m_owners
                     Type: uint256[256] storage ref
                     Source: "m_owners"
                  Identifier free
                     Type: uint256
                     Source: "free"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            ExpressionStatement
               Gas costs: 19
               Source: "free++"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "free++"
                Identifier free
                   Type: uint256
                   Source: "free"
          WhileStatement
             Source: "while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 675
               Source: "m_numOwners > 1 && m_owners[m_numOwners] == 0"
              BinaryOperation using operator >
                 Type: bool
                 Source: "m_numOwners > 1"
                Identifier m_numOwners
                   Type: uint256
                   Source: "m_numOwners"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "m_owners[m_numOwners] == 0"
                IndexAccess
                   Type: uint256
                   Source: "m_owners[m_numOwners]"
                  Identifier m_owners
                     Type: uint256[256] storage ref
                     Source: "m_owners"
                  Identifier m_numOwners
                     Type: uint256
                     Source: "m_numOwners"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            ExpressionStatement
               Gas costs: 20240
               Source: "m_numOwners--"
              UnaryOperation (postfix) --
                 Type: uint256
                 Source: "m_numOwners--"
                Identifier m_numOwners
                   Type: uint256
                   Source: "m_numOwners"
          IfStatement
             Source: "if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 944
               Source: "free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0"
              BinaryOperation using operator &&
                 Type: bool
                 Source: "free < m_numOwners && m_owners[m_numOwners] != 0"
                BinaryOperation using operator <
                   Type: bool
                   Source: "free < m_numOwners"
                  Identifier free
                     Type: uint256
                     Source: "free"
                  Identifier m_numOwners
                     Type: uint256
                     Source: "m_numOwners"
                BinaryOperation using operator !=
                   Type: bool
                   Source: "m_owners[m_numOwners] != 0"
                  IndexAccess
                     Type: uint256
                     Source: "m_owners[m_numOwners]"
                    Identifier m_owners
                       Type: uint256[256] storage ref
                       Source: "m_owners"
                    Identifier m_numOwners
                       Type: uint256
                       Source: "m_numOwners"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "m_owners[free] == 0"
                IndexAccess
                   Type: uint256
                   Source: "m_owners[free]"
                  Identifier m_owners
                     Type: uint256[256] storage ref
                     Source: "m_owners"
                  Identifier free
                     Type: uint256
                     Source: "free"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            Block
               Source: "{\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }"
              ExpressionStatement
                 Gas costs: 20484
                 Source: "m_owners[free] = m_owners[m_numOwners]"
                Assignment using operator =
                   Type: uint256
                   Source: "m_owners[free] = m_owners[m_numOwners]"
                  IndexAccess
                     Type: uint256
                     Source: "m_owners[free]"
                    Identifier m_owners
                       Type: uint256[256] storage ref
                       Source: "m_owners"
                    Identifier free
                       Type: uint256
                       Source: "free"
                  IndexAccess
                     Type: uint256
                     Source: "m_owners[m_numOwners]"
                    Identifier m_owners
                       Type: uint256[256] storage ref
                       Source: "m_owners"
                    Identifier m_numOwners
                       Type: uint256
                       Source: "m_numOwners"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "m_ownerIndex[m_owners[free]] = free"
                Assignment using operator =
                   Type: uint256
                   Source: "m_ownerIndex[m_owners[free]] = free"
                  IndexAccess
                     Type: uint256
                     Source: "m_ownerIndex[m_owners[free]]"
                    Identifier m_ownerIndex
                       Type: mapping(uint256 => uint256)
                       Source: "m_ownerIndex"
                    IndexAccess
                       Type: uint256
                       Source: "m_owners[free]"
                      Identifier m_owners
                         Type: uint256[256] storage ref
                         Source: "m_owners"
                      Identifier free
                         Type: uint256
                         Source: "free"
                  Identifier free
                     Type: uint256
                     Source: "free"
              ExpressionStatement
                 Gas costs: 20249
                 Source: "m_owners[m_numOwners] = 0"
                Assignment using operator =
                   Type: uint256
                   Source: "m_owners[m_numOwners] = 0"
                  IndexAccess
                     Type: uint256
                     Source: "m_owners[m_numOwners]"
                    Identifier m_owners
                       Type: uint256[256] storage ref
                       Source: "m_owners"
                    Identifier m_numOwners
                       Type: uint256
                       Source: "m_numOwners"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
  FunctionDefinition "clearPending"
     Source: "function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 219
         Source: "uint length = m_pendingIndex.length"
        VariableDeclaration "length"
           Type: uint256
           Source: "uint length"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "m_pendingIndex.length"
          Identifier m_pendingIndex
             Type: bytes32[] storage ref
             Source: "m_pendingIndex"
      ForStatement
         Source: "for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]]"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < length"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier length
             Type: uint256
             Source: "length"
        ExpressionStatement
           Gas costs: 14
           Source: "++i"
          UnaryOperation (prefix) ++
             Type: uint256
             Source: "++i"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]]"
          BinaryOperation using operator !=
             Type: bool
             Gas costs: 518
             Source: "m_pendingIndex[i] != 0"
            IndexAccess
               Type: bytes32
               Source: "m_pendingIndex[i]"
              Identifier m_pendingIndex
                 Type: bytes32[] storage ref
                 Source: "m_pendingIndex"
              Identifier i
                 Type: uint256
                 Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          ExpressionStatement
             Gas costs: [???]
             Source: "delete m_pending[m_pendingIndex[i]]"
            UnaryOperation (prefix) delete
               Type: tuple()
               Source: "delete m_pending[m_pendingIndex[i]]"
              IndexAccess
                 Type: struct multiowned.PendingState storage ref
                 Source: "m_pending[m_pendingIndex[i]]"
                Identifier m_pending
                   Type: mapping(bytes32 => struct multiowned.PendingState storage ref)
                   Source: "m_pending"
                IndexAccess
                   Type: bytes32
                   Source: "m_pendingIndex[i]"
                  Identifier m_pendingIndex
                     Type: bytes32[] storage ref
                     Source: "m_pendingIndex"
                  Identifier i
                     Type: uint256
                     Source: "i"
      ExpressionStatement
         Gas costs: 16
         Source: "delete m_pendingIndex"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete m_pendingIndex"
          Identifier m_pendingIndex
             Type: bytes32[] storage ref
             Source: "m_pendingIndex"
  VariableDeclaration "m_required"
     Type: uint256
     Gas costs: [???]
     Source: "uint public m_required"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "m_numOwners"
     Type: uint256
     Gas costs: [???]
     Source: "uint public m_numOwners"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "m_owners"
     Type: uint256[256] storage ref
     Gas costs: 0
     Source: "uint[256] m_owners"
    ArrayTypeName
       Source: "uint[256]"
      ElementaryTypeName uint
         Source: "uint"
      Literal, token: [no token] value: 256
         Type unknown.
         Source: "256"
  VariableDeclaration "c_maxOwners"
     Type: uint256
     Gas costs: 6
     Source: "uint constant c_maxOwners = 250"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 250
       Type: int_const 250
       Source: "250"
  VariableDeclaration "m_ownerIndex"
     Type: mapping(uint256 => uint256)
     Gas costs: 0
     Source: "mapping(uint => uint) m_ownerIndex"
    Mapping
       Source: "mapping(uint => uint)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "m_pending"
     Type: mapping(bytes32 => struct multiowned.PendingState storage ref)
     Gas costs: 0
     Source: "mapping(bytes32 => PendingState) m_pending"
    Mapping
       Source: "mapping(bytes32 => PendingState)"
      ElementaryTypeName bytes32
         Source: "bytes32"
      UserDefinedTypeName "PendingState"
         Source: "PendingState"
  VariableDeclaration "m_pendingIndex"
     Type: bytes32[] storage ref
     Gas costs: 0
     Source: "bytes32[] m_pendingIndex"
    ArrayTypeName
       Source: "bytes32[]"
      ElementaryTypeName bytes32
         Source: "bytes32"
ContractDefinition "daylimit"
   Source: "contract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // resets the amount already spent today. needs many of the owners to confirm.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data)) external {\r\n        m_spentToday = 0;\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        // overflow protection                    // dailyLimit check\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "multiowned"
    UserDefinedTypeName "multiowned"
       Source: "multiowned"
  ModifierDefinition "limitedDaily"
     Source: "modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _value)"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (underLimit(_value))\r\n            _;\r\n    }"
      IfStatement
         Source: "if (underLimit(_value))\r\n            _"
        FunctionCall
           Type: bool
           Gas costs: 0
           Source: "underLimit(_value)"
          Identifier underLimit
             Type: function (uint256) returns (bool)
             Source: "underLimit"
          Identifier _value
             Type: uint256
             Source: "_value"
        PlaceholderStatement
           Gas costs: 0
           Source: "_"
  FunctionDefinition "daylimit" - public
     Source: "function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _limit)"
      VariableDeclaration "_limit"
         Type: uint256
         Source: "uint _limit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "m_dailyLimit = _limit"
        Assignment using operator =
           Type: uint256
           Source: "m_dailyLimit = _limit"
          Identifier m_dailyLimit
             Type: uint256
             Source: "m_dailyLimit"
          Identifier _limit
             Type: uint256
             Source: "_limit"
      ExpressionStatement
         Gas costs: 0
         Source: "m_lastDay = today()"
        Assignment using operator =
           Type: uint256
           Source: "m_lastDay = today()"
          Identifier m_lastDay
             Type: uint256
             Source: "m_lastDay"
          FunctionCall
             Type: uint256
             Source: "today()"
            Identifier today
               Type: function () view returns (uint256)
               Source: "today"
  FunctionDefinition "setDailyLimit" - public
     Source: "function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _newLimit)"
      VariableDeclaration "_newLimit"
         Type: uint256
         Source: "uint _newLimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlymanyowners"
       Gas costs: [???]
       Source: "onlymanyowners(sha3(msg.data))"
      Identifier onlymanyowners
         Type: modifier (bytes32)
         Source: "onlymanyowners"
      FunctionCall
         Type: bytes32
         Source: "sha3(msg.data)"
        Identifier sha3
           Type: function () pure returns (bytes32)
           Source: "sha3"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        m_dailyLimit = _newLimit;\r\n    }"
      ExpressionStatement
         Gas costs: 20014
         Source: "m_dailyLimit = _newLimit"
        Assignment using operator =
           Type: uint256
           Source: "m_dailyLimit = _newLimit"
          Identifier m_dailyLimit
             Type: uint256
             Source: "m_dailyLimit"
          Identifier _newLimit
             Type: uint256
             Source: "_newLimit"
  FunctionDefinition "resetSpentToday" - public
     Source: "function resetSpentToday() onlymanyowners(sha3(msg.data)) external {\r\n        m_spentToday = 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlymanyowners"
       Gas costs: [???]
       Source: "onlymanyowners(sha3(msg.data))"
      Identifier onlymanyowners
         Type: modifier (bytes32)
         Source: "onlymanyowners"
      FunctionCall
         Type: bytes32
         Source: "sha3(msg.data)"
        Identifier sha3
           Type: function () pure returns (bytes32)
           Source: "sha3"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        m_spentToday = 0;\r\n    }"
      ExpressionStatement
         Gas costs: 5014
         Source: "m_spentToday = 0"
        Assignment using operator =
           Type: uint256
           Source: "m_spentToday = 0"
          Identifier m_spentToday
             Type: uint256
             Source: "m_spentToday"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "underLimit"
     Source: "function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        // overflow protection                    // dailyLimit check\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _value)"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyowner"
       Gas costs: 0
       Source: "onlyowner"
      Identifier onlyowner
         Type: modifier ()
         Source: "onlyowner"
    Block
       Source: "{\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        // overflow protection                    // dailyLimit check\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }"
      IfStatement
         Source: "if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 210
           Source: "today() > m_lastDay"
          FunctionCall
             Type: uint256
             Source: "today()"
            Identifier today
               Type: function () view returns (uint256)
               Source: "today"
          Identifier m_lastDay
             Type: uint256
             Source: "m_lastDay"
        Block
           Source: "{\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }"
          ExpressionStatement
             Gas costs: 5014
             Source: "m_spentToday = 0"
            Assignment using operator =
               Type: uint256
               Source: "m_spentToday = 0"
              Identifier m_spentToday
                 Type: uint256
                 Source: "m_spentToday"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          ExpressionStatement
             Gas costs: 20026
             Source: "m_lastDay = today()"
            Assignment using operator =
               Type: uint256
               Source: "m_lastDay = today()"
              Identifier m_lastDay
                 Type: uint256
                 Source: "m_lastDay"
              FunctionCall
                 Type: uint256
                 Source: "today()"
                Identifier today
                   Type: function () view returns (uint256)
                   Source: "today"
      IfStatement
         Source: "if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 858
           Source: "m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit"
          BinaryOperation using operator >=
             Type: bool
             Source: "m_spentToday + _value >= m_spentToday"
            BinaryOperation using operator +
               Type: uint256
               Source: "m_spentToday + _value"
              Identifier m_spentToday
                 Type: uint256
                 Source: "m_spentToday"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            Identifier m_spentToday
               Type: uint256
               Source: "m_spentToday"
          BinaryOperation using operator <=
             Type: bool
             Source: "m_spentToday + _value <= m_dailyLimit"
            BinaryOperation using operator +
               Type: uint256
               Source: "m_spentToday + _value"
              Identifier m_spentToday
                 Type: uint256
                 Source: "m_spentToday"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            Identifier m_dailyLimit
               Type: uint256
               Source: "m_dailyLimit"
        Block
           Source: "{\r\n            m_spentToday += _value;\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 20233
             Source: "m_spentToday += _value"
            Assignment using operator +=
               Type: uint256
               Source: "m_spentToday += _value"
              Identifier m_spentToday
                 Type: uint256
                 Source: "m_spentToday"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      Return
         Gas costs: 8
         Source: "return false"
        Literal, token: false value: false
           Type: bool
           Source: "false"
  FunctionDefinition "today" - const
     Source: "function today() private constant returns (uint) { return now / 1 days; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{ return now / 1 days; }"
      Return
         Gas costs: 38
         Source: "return now / 1 days"
        BinaryOperation using operator /
           Type: uint256
           Source: "now / 1 days"
          Identifier now
             Type: uint256
             Source: "now"
          Literal, token: [no token] value: 1
             Type: int_const 86400
             Source: "1 days"
  VariableDeclaration "m_dailyLimit"
     Type: uint256
     Gas costs: [???]
     Source: "uint public m_dailyLimit"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "m_spentToday"
     Type: uint256
     Gas costs: [???]
     Source: "uint public m_spentToday"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "m_lastDay"
     Type: uint256
     Gas costs: [???]
     Source: "uint public m_lastDay"
    ElementaryTypeName uint
       Source: "uint"
ContractDefinition "multisig"
   Gas costs: 0
   Source: "contract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address _from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n\r\n    // FUNCTIONS\r\n\r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}"
  EventDefinition "Deposit"
     Source: "event Deposit(address _from, uint value);"
    ParameterList
       Source: "(address _from, uint value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "SingleTransact"
     Source: "event SingleTransact(address owner, uint value, address to, bytes data);"
    ParameterList
       Source: "(address owner, uint value, address to, bytes data)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "data"
         Type: bytes memory
         Source: "bytes data"
        ElementaryTypeName bytes
           Source: "bytes"
  EventDefinition "MultiTransact"
     Source: "event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);"
    ParameterList
       Source: "(address owner, bytes32 operation, uint value, address to, bytes data)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "operation"
         Type: bytes32
         Source: "bytes32 operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "data"
         Type: bytes memory
         Source: "bytes data"
        ElementaryTypeName bytes
           Source: "bytes"
  EventDefinition "ConfirmationNeeded"
     Source: "event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);"
    ParameterList
       Source: "(bytes32 operation, address initiator, uint value, address to, bytes data)"
      VariableDeclaration "operation"
         Type: bytes32
         Source: "bytes32 operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "initiator"
         Type: address
         Source: "address initiator"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "data"
         Type: bytes memory
         Source: "bytes data"
        ElementaryTypeName bytes
           Source: "bytes"
  FunctionDefinition "changeOwner" - public
     Source: "function changeOwner(address _from, address _to) external;"
    ParameterList
       Source: "(address _from, address _to)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: ""
  FunctionDefinition "execute" - public
     Source: "function execute(address _to, uint _value, bytes _data) external returns (bytes32);"
    ParameterList
       Source: "(address _to, uint _value, bytes _data)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_data"
         Type: bytes calldata
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: "(bytes32)"
      VariableDeclaration ""
         Type: bytes32
         Source: "bytes32"
        ElementaryTypeName bytes32
           Source: "bytes32"
  FunctionDefinition "confirm" - public
     Source: "function confirm(bytes32 _h) returns (bool);"
    ParameterList
       Source: "(bytes32 _h)"
      VariableDeclaration "_h"
         Type: bytes32
         Source: "bytes32 _h"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
ContractDefinition "Wallet"
   Source: "contract Wallet is multisig, multiowned, daylimit {\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n\r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data)) external {\r\n        suicide(_to);\r\n    }\r\n\r\n    // gets called when no other function matches\r\n    function() payable {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n\r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "multisig"
    UserDefinedTypeName "multisig"
       Source: "multisig"
  InheritanceSpecifier
     Gas costs: 0
     Source: "multiowned"
    UserDefinedTypeName "multiowned"
       Source: "multiowned"
  InheritanceSpecifier
     Gas costs: 0
     Source: "daylimit"
    UserDefinedTypeName "daylimit"
       Source: "daylimit"
  StructDefinition "Transaction"
     Gas costs: 0
     Source: "struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }"
    VariableDeclaration "to"
       Type: address
       Source: "address to"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "value"
       Type: uint256
       Source: "uint value"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "data"
       Type: bytes storage pointer
       Source: "bytes data"
      ElementaryTypeName bytes
         Source: "bytes"
  FunctionDefinition "Wallet" - public
     Source: "function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _owners, uint _required, uint _daylimit)"
      VariableDeclaration "_owners"
         Type: address[] memory
         Source: "address[] _owners"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_required"
         Type: uint256
         Source: "uint _required"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_daylimit"
         Type: uint256
         Source: "uint _daylimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "multiowned"
       Gas costs: 0
       Source: "multiowned(_owners, _required)"
      Identifier multiowned
         Type: type(contract multiowned)
         Source: "multiowned"
      Identifier _owners
         Type: address[] memory
         Source: "_owners"
      Identifier _required
         Type: uint256
         Source: "_required"
    ModifierInvocation "daylimit"
       Gas costs: 0
       Source: "daylimit(_daylimit)"
      Identifier daylimit
         Type: type(contract daylimit)
         Source: "daylimit"
      Identifier _daylimit
         Type: uint256
         Source: "_daylimit"
    Block
       Gas costs: 0
       Source: "{\r\n    }"
  FunctionDefinition "kill" - public
     Source: "function kill(address _to) onlymanyowners(sha3(msg.data)) external {\r\n        suicide(_to);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlymanyowners"
       Gas costs: [???]
       Source: "onlymanyowners(sha3(msg.data))"
      Identifier onlymanyowners
         Type: modifier (bytes32)
         Source: "onlymanyowners"
      FunctionCall
         Type: bytes32
         Source: "sha3(msg.data)"
        Identifier sha3
           Type: function () pure returns (bytes32)
           Source: "sha3"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        suicide(_to);\r\n    }"
      ExpressionStatement
         Gas costs: 30009
         Source: "suicide(_to)"
        FunctionCall
           Type: tuple()
           Source: "suicide(_to)"
          Identifier suicide
             Type: function (address)
             Source: "suicide"
          Identifier _to
             Type: address
             Source: "_to"
  FunctionDefinition "" - public
     Source: "function() payable {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }"
      IfStatement
         Source: "if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value)"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 8
           Source: "msg.value > 0"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: [???]
           Source: "Deposit(msg.sender, msg.value)"
          FunctionCall
             Type: tuple()
             Source: "Deposit(msg.sender, msg.value)"
            Identifier Deposit
               Type: function (address,uint256)
               Source: "Deposit"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "execute" - public
     Source: "function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value, bytes _data)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_data"
         Type: bytes calldata
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bytes32 _r)"
      VariableDeclaration "_r"
         Type: bytes32
         Source: "bytes32 _r"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ModifierInvocation "onlyowner"
       Gas costs: 0
       Source: "onlyowner"
      Identifier onlyowner
         Type: modifier ()
         Source: "onlyowner"
    Block
       Source: "{\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }"
      IfStatement
         Source: "if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 7
           Source: "underLimit(_value)"
          Identifier underLimit
             Type: function (uint256) returns (bool)
             Source: "underLimit"
          Identifier _value
             Type: uint256
             Source: "_value"
        Block
           Source: "{\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "SingleTransact(msg.sender, _value, _to, _data)"
            FunctionCall
               Type: tuple()
               Source: "SingleTransact(msg.sender, _value, _to, _data)"
              Identifier SingleTransact
                 Type: function (address,uint256,address,bytes memory)
                 Source: "SingleTransact"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _data
                 Type: bytes calldata
                 Source: "_data"
          ExpressionStatement
             Gas costs: [???]
             Source: "_to.call.value(_value)(_data)"
            FunctionCall
               Type: bool
               Source: "_to.call.value(_value)(_data)"
              FunctionCall
                 Type: function () payable returns (bool)
                 Source: "_to.call.value(_value)"
                MemberAccess to member value
                   Type: function (uint256) returns (function () payable returns (bool))
                   Source: "_to.call.value"
                  MemberAccess to member call
                     Type: function () payable returns (bool)
                     Source: "_to.call"
                    Identifier _to
                       Type: address
                       Source: "_to"
                Identifier _value
                   Type: uint256
                   Source: "_value"
              Identifier _data
                 Type: bytes calldata
                 Source: "_data"
          Return
             Gas costs: 27
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "_r = sha3(msg.data, block.number)"
        Assignment using operator =
           Type: bytes32
           Source: "_r = sha3(msg.data, block.number)"
          Identifier _r
             Type: bytes32
             Source: "_r"
          FunctionCall
             Type: bytes32
             Source: "sha3(msg.data, block.number)"
            Identifier sha3
               Type: function () pure returns (bytes32)
               Source: "sha3"
            MemberAccess to member data
               Type: bytes calldata
               Source: "msg.data"
              Identifier msg
                 Type: msg
                 Source: "msg"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
      IfStatement
         Source: "if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 402
           Source: "!confirm(_r) && m_txs[_r].to == 0"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!confirm(_r)"
            FunctionCall
               Type: bool
               Source: "confirm(_r)"
              Identifier confirm
                 Type: function (bytes32) returns (bool)
                 Source: "confirm"
              Identifier _r
                 Type: bytes32
                 Source: "_r"
          BinaryOperation using operator ==
             Type: bool
             Source: "m_txs[_r].to == 0"
            MemberAccess to member to
               Type: address
               Source: "m_txs[_r].to"
              IndexAccess
                 Type: struct Wallet.Transaction storage ref
                 Source: "m_txs[_r]"
                Identifier m_txs
                   Type: mapping(bytes32 => struct Wallet.Transaction storage ref)
                   Source: "m_txs"
                Identifier _r
                   Type: bytes32
                   Source: "_r"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }"
          ExpressionStatement
             Gas costs: 20375
             Source: "m_txs[_r].to = _to"
            Assignment using operator =
               Type: address
               Source: "m_txs[_r].to = _to"
              MemberAccess to member to
                 Type: address
                 Source: "m_txs[_r].to"
                IndexAccess
                   Type: struct Wallet.Transaction storage ref
                   Source: "m_txs[_r]"
                  Identifier m_txs
                     Type: mapping(bytes32 => struct Wallet.Transaction storage ref)
                     Source: "m_txs"
                  Identifier _r
                     Type: bytes32
                     Source: "_r"
              Identifier _to
                 Type: address
                 Source: "_to"
          ExpressionStatement
             Gas costs: 20116
             Source: "m_txs[_r].value = _value"
            Assignment using operator =
               Type: uint256
               Source: "m_txs[_r].value = _value"
              MemberAccess to member value
                 Type: uint256
                 Source: "m_txs[_r].value"
                IndexAccess
                   Type: struct Wallet.Transaction storage ref
                   Source: "m_txs[_r]"
                  Identifier m_txs
                     Type: mapping(bytes32 => struct Wallet.Transaction storage ref)
                     Source: "m_txs"
                  Identifier _r
                     Type: bytes32
                     Source: "_r"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 132
             Source: "m_txs[_r].data = _data"
            Assignment using operator =
               Type: bytes storage ref
               Source: "m_txs[_r].data = _data"
              MemberAccess to member data
                 Type: bytes storage ref
                 Source: "m_txs[_r].data"
                IndexAccess
                   Type: struct Wallet.Transaction storage ref
                   Source: "m_txs[_r]"
                  Identifier m_txs
                     Type: mapping(bytes32 => struct Wallet.Transaction storage ref)
                     Source: "m_txs"
                  Identifier _r
                     Type: bytes32
                     Source: "_r"
              Identifier _data
                 Type: bytes calldata
                 Source: "_data"
          ExpressionStatement
             Gas costs: [???]
             Source: "ConfirmationNeeded(_r, msg.sender, _value, _to, _data)"
            FunctionCall
               Type: tuple()
               Source: "ConfirmationNeeded(_r, msg.sender, _value, _to, _data)"
              Identifier ConfirmationNeeded
                 Type: function (bytes32,address,uint256,address,bytes memory)
                 Source: "ConfirmationNeeded"
              Identifier _r
                 Type: bytes32
                 Source: "_r"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _data
                 Type: bytes calldata
                 Source: "_data"
  FunctionDefinition "confirm" - public
     Source: "function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _h)"
      VariableDeclaration "_h"
         Type: bytes32
         Source: "bytes32 _h"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlymanyowners"
       Gas costs: 3
       Source: "onlymanyowners(_h)"
      Identifier onlymanyowners
         Type: modifier (bytes32)
         Source: "onlymanyowners"
      Identifier _h
         Type: bytes32
         Source: "_h"
    Block
       Source: "{\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }"
      IfStatement
         Source: "if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 362
           Source: "m_txs[_h].to != 0"
          MemberAccess to member to
             Type: address
             Source: "m_txs[_h].to"
            IndexAccess
               Type: struct Wallet.Transaction storage ref
               Source: "m_txs[_h]"
              Identifier m_txs
                 Type: mapping(bytes32 => struct Wallet.Transaction storage ref)
                 Source: "m_txs"
              Identifier _h
                 Type: bytes32
                 Source: "_h"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)"
            FunctionCall
               Type: bool
               Source: "m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)"
              FunctionCall
                 Type: function () payable returns (bool)
                 Source: "m_txs[_h].to.call.value(m_txs[_h].value)"
                MemberAccess to member value
                   Type: function (uint256) returns (function () payable returns (bool))
                   Source: "m_txs[_h].to.call.value"
                  MemberAccess to member call
                     Type: function () payable returns (bool)
                     Source: "m_txs[_h].to.call"
                    MemberAccess to member to
                       Type: address
                       Source: "m_txs[_h].to"
                      IndexAccess
                         Type: struct Wallet.Transaction storage ref
                         Source: "m_txs[_h]"
                        Identifier m_txs
                           Type: mapping(bytes32 => struct Wallet.Transaction storage ref)
                           Source: "m_txs"
                        Identifier _h
                           Type: bytes32
                           Source: "_h"
                MemberAccess to member value
                   Type: uint256
                   Source: "m_txs[_h].value"
                  IndexAccess
                     Type: struct Wallet.Transaction storage ref
                     Source: "m_txs[_h]"
                    Identifier m_txs
                       Type: mapping(bytes32 => struct Wallet.Transaction storage ref)
                       Source: "m_txs"
                    Identifier _h
                       Type: bytes32
                       Source: "_h"
              MemberAccess to member data
                 Type: bytes storage ref
                 Source: "m_txs[_h].data"
                IndexAccess
                   Type: struct Wallet.Transaction storage ref
                   Source: "m_txs[_h]"
                  Identifier m_txs
                     Type: mapping(bytes32 => struct Wallet.Transaction storage ref)
                     Source: "m_txs"
                  Identifier _h
                     Type: bytes32
                     Source: "_h"
          ExpressionStatement
             Gas costs: [???]
             Source: "MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data)"
            FunctionCall
               Type: tuple()
               Source: "MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data)"
              Identifier MultiTransact
                 Type: function (address,bytes32,uint256,address,bytes memory)
                 Source: "MultiTransact"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _h
                 Type: bytes32
                 Source: "_h"
              MemberAccess to member value
                 Type: uint256
                 Source: "m_txs[_h].value"
                IndexAccess
                   Type: struct Wallet.Transaction storage ref
                   Source: "m_txs[_h]"
                  Identifier m_txs
                     Type: mapping(bytes32 => struct Wallet.Transaction storage ref)
                     Source: "m_txs"
                  Identifier _h
                     Type: bytes32
                     Source: "_h"
              MemberAccess to member to
                 Type: address
                 Source: "m_txs[_h].to"
                IndexAccess
                   Type: struct Wallet.Transaction storage ref
                   Source: "m_txs[_h]"
                  Identifier m_txs
                     Type: mapping(bytes32 => struct Wallet.Transaction storage ref)
                     Source: "m_txs"
                  Identifier _h
                     Type: bytes32
                     Source: "_h"
              MemberAccess to member data
                 Type: bytes storage ref
                 Source: "m_txs[_h].data"
                IndexAccess
                   Type: struct Wallet.Transaction storage ref
                   Source: "m_txs[_h]"
                  Identifier m_txs
                     Type: mapping(bytes32 => struct Wallet.Transaction storage ref)
                     Source: "m_txs"
                  Identifier _h
                     Type: bytes32
                     Source: "_h"
          ExpressionStatement
             Gas costs: 25391
             Source: "delete m_txs[_h]"
            UnaryOperation (prefix) delete
               Type: tuple()
               Source: "delete m_txs[_h]"
              IndexAccess
                 Type: struct Wallet.Transaction storage ref
                 Source: "m_txs[_h]"
                Identifier m_txs
                   Type: mapping(bytes32 => struct Wallet.Transaction storage ref)
                   Source: "m_txs"
                Identifier _h
                   Type: bytes32
                   Source: "_h"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
  FunctionDefinition "clearPending"
     Source: "function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }"
      VariableDeclarationStatement
         Gas costs: 219
         Source: "uint length = m_pendingIndex.length"
        VariableDeclaration "length"
           Type: uint256
           Source: "uint length"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "m_pendingIndex.length"
          Identifier m_pendingIndex
             Type: bytes32[] storage ref
             Source: "m_pendingIndex"
      ForStatement
         Source: "for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]]"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < length"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier length
             Type: uint256
             Source: "length"
        ExpressionStatement
           Gas costs: 14
           Source: "++i"
          UnaryOperation (prefix) ++
             Type: uint256
             Source: "++i"
            Identifier i
               Type: uint256
               Source: "i"
        ExpressionStatement
           Gas costs: [???]
           Source: "delete m_txs[m_pendingIndex[i]]"
          UnaryOperation (prefix) delete
             Type: tuple()
             Source: "delete m_txs[m_pendingIndex[i]]"
            IndexAccess
               Type: struct Wallet.Transaction storage ref
               Source: "m_txs[m_pendingIndex[i]]"
              Identifier m_txs
                 Type: mapping(bytes32 => struct Wallet.Transaction storage ref)
                 Source: "m_txs"
              IndexAccess
                 Type: bytes32
                 Source: "m_pendingIndex[i]"
                Identifier m_pendingIndex
                   Type: bytes32[] storage ref
                   Source: "m_pendingIndex"
                Identifier i
                   Type: uint256
                   Source: "i"
      ExpressionStatement
         Gas costs: 4
         Source: "super.clearPending()"
        FunctionCall
           Type: tuple()
           Source: "super.clearPending()"
          MemberAccess to member clearPending
             Type: function ()
             Source: "super.clearPending"
            Identifier super
               Type: contract super Wallet
               Source: "super"
  VariableDeclaration "m_txs"
     Type: mapping(bytes32 => struct Wallet.Transaction storage ref)
     Gas costs: 0
     Source: "mapping (bytes32 => Transaction) m_txs"
    Mapping
       Source: "mapping (bytes32 => Transaction)"
      ElementaryTypeName bytes32
         Source: "bytes32"
      UserDefinedTypeName "Transaction"
         Source: "Transaction"
