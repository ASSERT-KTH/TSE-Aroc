Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x632393de9dd19b5fd0cc0c4ff17aa674b2f0a1c0.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.15;"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "mul" - const
     Source: "function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 88
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div" - const
     Source: "function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub" - const
     Source: "function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add" - const
     Source: "function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "ERC20Basic"
   Gas costs: 0
   Source: "contract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) public constant returns (uint256);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address to, uint256 value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) public constant returns (uint256);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address from, address to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address spender, uint256 value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint256 value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint256 value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "Ownable"
   Source: "contract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  EventDefinition "OwnershipTransferred"
     Gas costs: 0
     Source: "event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);"
    ParameterList
       Source: "(address indexed previousOwner, address indexed newOwner)"
      VariableDeclaration "previousOwner"
         Type: address
         Source: "address indexed previousOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address indexed newOwner"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "Ownable" - public
     Source: "function Ownable() {\r\n    owner = msg.sender;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    owner = msg.sender;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 1974
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(newOwner != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(newOwner != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "newOwner != address(0)"
            Identifier newOwner
               Type: address
               Source: "newOwner"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 1790
         Source: "OwnershipTransferred(owner, newOwner)"
        FunctionCall
           Type: tuple()
           Source: "OwnershipTransferred(owner, newOwner)"
          Identifier OwnershipTransferred
             Type: function (address,address)
             Source: "OwnershipTransferred"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is ERC20Basic {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) internal allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) balances"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_to != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_to != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != address(0)"
            Identifier _to
               Type: address
               Source: "_to"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_value <= balances[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= balances[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= balances[msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "balances[msg.sender].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return balances[_owner];\r\n  }"
      Return
         Gas costs: 0
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_to != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_to != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != address(0)"
            Identifier _to
               Type: address
               Source: "_to"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_value <= balances[_from])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= balances[_from])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= balances[_from]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[_from]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _from
                 Type: address
                 Source: "_from"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_value <= allowed[_from][msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= allowed[_from][msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= allowed[_from][msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "allowed[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[_from]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_from] = balances[_from].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_from] = balances[_from].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "balances[_from].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[_from].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "allowed[_from][msg.sender].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "allowed[_from][msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return allowed[_owner][_spender];\r\n  }"
      Return
         Gas costs: 0
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
ContractDefinition "BurnableToken"
   Source: "contract BurnableToken is StandardToken {\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _value The amount of token to be burned.\r\n     */\r\n    function burn(uint256 _value) public {\r\n        require(_value > 0);\r\n        require(_value <= balances[msg.sender]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  EventDefinition "Burn"
     Gas costs: 0
     Source: "event Burn(address indexed burner, uint256 value);"
    ParameterList
       Source: "(address indexed burner, uint256 value)"
      VariableDeclaration "burner"
         Type: address
         Source: "address indexed burner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "burn" - public
     Source: "function burn(uint256 _value) public {\r\n        require(_value > 0);\r\n        require(_value <= balances[msg.sender]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _value)"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(_value > 0);\r\n        require(_value <= balances[msg.sender]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_value > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_value > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "_value > 0"
            Identifier _value
               Type: uint256
               Source: "_value"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_value <= balances[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= balances[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= balances[msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "address burner = msg.sender"
        VariableDeclaration "burner"
           Type: address
           Source: "address burner"
          ElementaryTypeName address
             Source: "address"
        MemberAccess to member sender
           Type: address
           Source: "msg.sender"
          Identifier msg
             Type: msg
             Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[burner] = balances[burner].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[burner] = balances[burner].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[burner]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier burner
               Type: address
               Source: "burner"
          FunctionCall
             Type: uint256
             Source: "balances[burner].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[burner].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[burner]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier burner
                   Type: address
                   Source: "burner"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = totalSupply.sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = totalSupply.sub(_value)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "totalSupply.sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "totalSupply.sub"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Burn(burner, _value)"
        FunctionCall
           Type: tuple()
           Source: "Burn(burner, _value)"
          Identifier Burn
             Type: function (address,uint256)
             Source: "Burn"
          Identifier burner
             Type: address
             Source: "burner"
          Identifier _value
             Type: uint256
             Source: "_value"
ContractDefinition "MintableToken"
   Source: "contract MintableToken is BurnableToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(0x0, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner public returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "BurnableToken"
    UserDefinedTypeName "BurnableToken"
       Source: "BurnableToken"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  EventDefinition "Mint"
     Gas costs: 0
     Source: "event Mint(address indexed to, uint256 amount);"
    ParameterList
       Source: "(address indexed to, uint256 amount)"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "MintFinished"
     Gas costs: 0
     Source: "event MintFinished();"
    ParameterList
       Source: "()"
  VariableDeclaration "mintingFinished"
     Type: bool
     Gas costs: 0
     Source: "bool public mintingFinished = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  ModifierDefinition "canMint"
     Source: "modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(!mintingFinished);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!mintingFinished)"
        FunctionCall
           Type: tuple()
           Source: "require(!mintingFinished)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!mintingFinished"
            Identifier mintingFinished
               Type: bool
               Source: "mintingFinished"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "mint" - public
     Source: "function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(0x0, _to, _amount);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _amount)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "canMint"
       Gas costs: 0
       Source: "canMint"
      Identifier canMint
         Type: modifier ()
         Source: "canMint"
    Block
       Source: "{\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(0x0, _to, _amount);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = totalSupply.add(_amount)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = totalSupply.add(_amount)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "totalSupply.add(_amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "totalSupply.add"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] = balances[_to].add(_amount)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_amount)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 0
         Source: "Mint(_to, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Mint(_to, _amount)"
          Identifier Mint
             Type: function (address,uint256)
             Source: "Mint"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(0x0, _to, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(0x0, _to, _amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "finishMinting" - public
     Source: "function finishMinting() onlyOwner public returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "mintingFinished = true"
        Assignment using operator =
           Type: bool
           Source: "mintingFinished = true"
          Identifier mintingFinished
             Type: bool
             Source: "mintingFinished"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "MintFinished()"
        FunctionCall
           Type: tuple()
           Source: "MintFinished()"
          Identifier MintFinished
             Type: function ()
             Source: "MintFinished"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
ContractDefinition "Pausable"
   Source: "contract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  EventDefinition "Pause"
     Gas costs: 0
     Source: "event Pause();"
    ParameterList
       Source: "()"
  EventDefinition "Unpause"
     Gas costs: 0
     Source: "event Unpause();"
    ParameterList
       Source: "()"
  VariableDeclaration "paused"
     Type: bool
     Gas costs: 0
     Source: "bool public paused = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  ModifierDefinition "whenNotPaused"
     Source: "modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(!paused);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!paused)"
        FunctionCall
           Type: tuple()
           Source: "require(!paused)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!paused"
            Identifier paused
               Type: bool
               Source: "paused"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "whenPaused"
     Source: "modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(paused);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(paused)"
        FunctionCall
           Type: tuple()
           Source: "require(paused)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier paused
             Type: bool
             Source: "paused"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "pause" - public
     Source: "function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "whenNotPaused"
       Gas costs: 0
       Source: "whenNotPaused"
      Identifier whenNotPaused
         Type: modifier ()
         Source: "whenNotPaused"
    Block
       Source: "{\r\n    paused = true;\r\n    Pause();\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "paused = true"
        Assignment using operator =
           Type: bool
           Source: "paused = true"
          Identifier paused
             Type: bool
             Source: "paused"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "Pause()"
        FunctionCall
           Type: tuple()
           Source: "Pause()"
          Identifier Pause
             Type: function ()
             Source: "Pause"
  FunctionDefinition "unpause" - public
     Source: "function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "whenPaused"
       Gas costs: 0
       Source: "whenPaused"
      Identifier whenPaused
         Type: modifier ()
         Source: "whenPaused"
    Block
       Source: "{\r\n    paused = false;\r\n    Unpause();\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "paused = false"
        Assignment using operator =
           Type: bool
           Source: "paused = false"
          Identifier paused
             Type: bool
             Source: "paused"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 0
         Source: "Unpause()"
        FunctionCall
           Type: tuple()
           Source: "Unpause()"
          Identifier Unpause
             Type: function ()
             Source: "Unpause"
ContractDefinition "PausableToken"
   Source: "contract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Pausable"
    UserDefinedTypeName "Pausable"
       Source: "Pausable"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transfer(_to, _value);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "whenNotPaused"
       Gas costs: 0
       Source: "whenNotPaused"
      Identifier whenNotPaused
         Type: modifier ()
         Source: "whenNotPaused"
    Block
       Source: "{\r\n    return super.transfer(_to, _value);\r\n  }"
      Return
         Gas costs: 0
         Source: "return super.transfer(_to, _value)"
        FunctionCall
           Type: bool
           Source: "super.transfer(_to, _value)"
          MemberAccess to member transfer
             Type: function (address,uint256) returns (bool)
             Source: "super.transfer"
            Identifier super
               Type: contract super PausableToken
               Source: "super"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "whenNotPaused"
       Gas costs: 0
       Source: "whenNotPaused"
      Identifier whenNotPaused
         Type: modifier ()
         Source: "whenNotPaused"
    Block
       Source: "{\r\n    return super.transferFrom(_from, _to, _value);\r\n  }"
      Return
         Gas costs: 0
         Source: "return super.transferFrom(_from, _to, _value)"
        FunctionCall
           Type: bool
           Source: "super.transferFrom(_from, _to, _value)"
          MemberAccess to member transferFrom
             Type: function (address,address,uint256) returns (bool)
             Source: "super.transferFrom"
            Identifier super
               Type: contract super PausableToken
               Source: "super"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.approve(_spender, _value);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "whenNotPaused"
       Gas costs: 0
       Source: "whenNotPaused"
      Identifier whenNotPaused
         Type: modifier ()
         Source: "whenNotPaused"
    Block
       Source: "{\r\n    return super.approve(_spender, _value);\r\n  }"
      Return
         Gas costs: 0
         Source: "return super.approve(_spender, _value)"
        FunctionCall
           Type: bool
           Source: "super.approve(_spender, _value)"
          MemberAccess to member approve
             Type: function (address,uint256) returns (bool)
             Source: "super.approve"
            Identifier super
               Type: contract super PausableToken
               Source: "super"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
ContractDefinition "GESToken"
   Gas costs: 0
   Source: "contract GESToken is MintableToken, PausableToken {\r\n  string public constant name = \"Galaxy eSolutions\";\r\n  string public constant symbol = \"GES\";\r\n  uint8 public constant decimals = 18;\r\n}"
  InheritanceSpecifier
     Source: "MintableToken"
    UserDefinedTypeName "MintableToken"
       Source: "MintableToken"
  InheritanceSpecifier
     Source: "PausableToken"
    UserDefinedTypeName "PausableToken"
       Source: "PausableToken"
  VariableDeclaration "name"
     Type: string memory
     Source: "string public constant name = \"Galaxy eSolutions\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Galaxy eSolutions
       Type: literal_string "Galaxy eSolutions"
       Source: "\"Galaxy eSolutions\""
  VariableDeclaration "symbol"
     Type: string memory
     Source: "string public constant symbol = \"GES\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: GES
       Type: literal_string "GES"
       Source: "\"GES\""
  VariableDeclaration "decimals"
     Type: uint8
     Source: "uint8 public constant decimals = 18"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
ContractDefinition "GESTokenCrowdSale"
   Source: "contract GESTokenCrowdSale is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  struct TimeBonus {\r\n    uint256 bonusPeriodEndTime;\r\n    uint percent;\r\n    uint256 weiCap;\r\n  }\r\n\r\n  /* true for finalised crowdsale */\r\n  bool public isFinalised;\r\n\r\n  /* The token object */\r\n  MintableToken public token;\r\n\r\n  /* Start and end timestamps where investments are allowed (both inclusive) */\r\n  uint256 public mainSaleStartTime;\r\n  uint256 public mainSaleEndTime;\r\n\r\n  /* Address where funds are transferref after collection */\r\n  address public wallet;\r\n\r\n  /* Address where final 10% of funds will be collected */\r\n  address public tokenWallet;\r\n\r\n  /* How many token units a buyer gets per ether */\r\n  uint256 public rate = 100;\r\n\r\n  /* Amount of raised money in wei */\r\n  uint256 public weiRaised;\r\n\r\n  /* Minimum amount of Wei allowed per transaction = 0.1 Ethers */\r\n  uint256 public saleMinimumWei = 100000000000000000; \r\n\r\n  TimeBonus[] public timeBonuses;\r\n\r\n  /**\r\n   * event for token purchase logging\r\n   * event for finalizing the crowdsale\r\n   */\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n  event FinalisedCrowdsale(uint256 totalSupply, uint256 minterBenefit);\r\n\r\n  function GESTokenCrowdSale(uint256 _mainSaleStartTime, address _wallet, address _tokenWallet) public {\r\n\r\n    /* Can't start main sale in the past */\r\n    require(_mainSaleStartTime >= now);\r\n\r\n    /* Confirming wallet addresses as valid */\r\n    require(_wallet != 0x0);\r\n    require(_tokenWallet != 0x0);\r\n\r\n    /* The Crowdsale bonus pattern\r\n     * 1 day = 86400 = 60 * 60 * 24 (Seconds * Minutes * Hours)\r\n     * 1 day * Number of days to close at, Bonus Percentage, Max Wei for which bonus is given  \r\n     */\r\n    timeBonuses.push(TimeBonus(86400 *  7,  30,    2000000000000000000000)); // 0 - 7 Days, 30 %, 2000 ETH\r\n    timeBonuses.push(TimeBonus(86400 *  14, 20,    5000000000000000000000)); // 8 -14 Days, 20 %, 2000ETH + 3000 ETH = 5000 ETH\r\n    timeBonuses.push(TimeBonus(86400 *  21, 10,   10000000000000000000000)); // 15-21 Days, 10 %, 5000 ETH + 5000 ETH = 10000 ETH\r\n    timeBonuses.push(TimeBonus(86400 *  60,  0,   25000000000000000000000)); // 22-60 Days, 0  %, 10000 ETH + 15000 ETH = 25000 ETH\r\n\r\n    token = createTokenContract();\r\n    mainSaleStartTime = _mainSaleStartTime;\r\n    mainSaleEndTime = mainSaleStartTime + 60 days;\r\n    wallet = _wallet;\r\n    tokenWallet = _tokenWallet;\r\n    isFinalised = false;\r\n  }\r\n\r\n  /* Creates the token to be sold */\r\n  function createTokenContract() internal returns (MintableToken) {\r\n    return new GESToken();\r\n  }\r\n\r\n  /* Fallback function can be used to buy tokens */\r\n  function () payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  /* Low level token purchase function */\r\n  function buyTokens(address beneficiary) public payable {\r\n    require(!isFinalised);\r\n    require(beneficiary != 0x0);\r\n    require(msg.value != 0);\r\n    require(now <= mainSaleEndTime && now >= mainSaleStartTime);\r\n    require(msg.value >= saleMinimumWei);\r\n\r\n    /* Add bonus to tokens depends on the period */\r\n    uint256 bonusedTokens = applyBonus(msg.value);\r\n\r\n    /* Update state on the blockchain */\r\n    weiRaised = weiRaised.add(msg.value);\r\n    token.mint(beneficiary, bonusedTokens);\r\n    TokenPurchase(msg.sender, beneficiary, msg.value, bonusedTokens);\r\n\r\n  }\r\n\r\n  /* Finish Crowdsale,\r\n   * Take totalSupply as 89% and mint 11% more to specified owner's wallet\r\n   * then stop minting forever.\r\n   */\r\n\r\n  function finaliseCrowdsale() external onlyOwner returns (bool) {\r\n    require(!isFinalised);\r\n    uint256 totalSupply = token.totalSupply();\r\n    uint256 minterBenefit = totalSupply.mul(10).div(89);\r\n    token.mint(tokenWallet, minterBenefit);\r\n    token.finishMinting();\r\n    forwardFunds();\r\n    FinalisedCrowdsale(totalSupply, minterBenefit);\r\n    isFinalised = true;\r\n    return true;\r\n  }\r\n\r\n  /* Set new dates for main-sale (emergency case) */\r\n  function setMainSaleDates(uint256 _mainSaleStartTime) public onlyOwner returns (bool) {\r\n    require(!isFinalised);\r\n    mainSaleStartTime = _mainSaleStartTime;\r\n    mainSaleEndTime = mainSaleStartTime + 60 days;\r\n    return true;\r\n  }\r\n\r\n  /* Pause the token contract */\r\n  function pauseToken() external onlyOwner {\r\n    require(!isFinalised);\r\n    GESToken(token).pause();\r\n  }\r\n\r\n  /* Unpause the token contract */\r\n  function unpauseToken() external onlyOwner {\r\n    GESToken(token).unpause();\r\n  }\r\n\r\n  /* Transfer token's contract ownership to a new owner */\r\n  function transferTokenOwnership(address newOwner) external onlyOwner {\r\n    GESToken(token).transferOwnership(newOwner);\r\n  }\r\n\r\n  /* @return true if main sale event has ended */\r\n  function mainSaleHasEnded() external constant returns (bool) {\r\n    return now > mainSaleEndTime;\r\n  }\r\n\r\n  /* Send ether to the fund collection wallet */\r\n  function forwardFunds() internal {\r\n    wallet.transfer(this.balance);\r\n  }\r\n\r\n  /* Function to calculate bonus tokens based on current time(now) and maximum cap per tier */\r\n  function applyBonus(uint256 weiAmount) internal constant returns (uint256 bonusedTokens) {\r\n    /* Bonus tokens to be added */\r\n    uint256 tokensToAdd = 0;\r\n\r\n    /* Calculting the amont of tokens to be allocated based on rate and the money transferred*/\r\n    uint256 tokens = weiAmount.mul(rate);\r\n    uint256 diffInSeconds = now.sub(mainSaleStartTime);\r\n\r\n    for (uint i = 0; i < timeBonuses.length; i++) {\r\n      /* If cap[i] is reached then skip */\r\n      if(weiRaised.add(weiAmount) <= timeBonuses[i].weiCap){\r\n        for(uint j = i; j < timeBonuses.length; j++){\r\n          /* Check which week period time it lies and use that percent */\r\n          if (diffInSeconds <= timeBonuses[j].bonusPeriodEndTime) {\r\n            tokensToAdd = tokens.mul(timeBonuses[j].percent).div(100);\r\n            return tokens.add(tokensToAdd);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n  }\r\n\r\n  /*  \r\n  * Function to extract funds as required before finalizing\r\n  */\r\n  function fetchFunds() onlyOwner public {\r\n    wallet.transfer(this.balance);\r\n  }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  StructDefinition "TimeBonus"
     Gas costs: 0
     Source: "struct TimeBonus {\r\n    uint256 bonusPeriodEndTime;\r\n    uint percent;\r\n    uint256 weiCap;\r\n  }"
    VariableDeclaration "bonusPeriodEndTime"
       Type: uint256
       Source: "uint256 bonusPeriodEndTime"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "percent"
       Type: uint256
       Source: "uint percent"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "weiCap"
       Type: uint256
       Source: "uint256 weiCap"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "isFinalised"
     Type: bool
     Gas costs: [???]
     Source: "bool public isFinalised"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "token"
     Type: contract MintableToken
     Gas costs: [???]
     Source: "MintableToken public token"
    UserDefinedTypeName "MintableToken"
       Source: "MintableToken"
  VariableDeclaration "mainSaleStartTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public mainSaleStartTime"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "mainSaleEndTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public mainSaleEndTime"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "wallet"
     Type: address
     Gas costs: [???]
     Source: "address public wallet"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "tokenWallet"
     Type: address
     Gas costs: [???]
     Source: "address public tokenWallet"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "rate"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public rate = 100"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 100
       Type: int_const 100
       Source: "100"
  VariableDeclaration "weiRaised"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public weiRaised"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "saleMinimumWei"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public saleMinimumWei = 100000000000000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 100000000000000000
       Type: int_const 100000000000000000
       Source: "100000000000000000"
  VariableDeclaration "timeBonuses"
     Type: struct GESTokenCrowdSale.TimeBonus storage ref[] storage ref
     Gas costs: [???]
     Source: "TimeBonus[] public timeBonuses"
    ArrayTypeName
       Source: "TimeBonus[]"
      UserDefinedTypeName "TimeBonus"
         Source: "TimeBonus"
  EventDefinition "TokenPurchase"
     Gas costs: 0
     Source: "event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);"
    ParameterList
       Source: "(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount)"
      VariableDeclaration "purchaser"
         Type: address
         Source: "address indexed purchaser"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "beneficiary"
         Type: address
         Source: "address indexed beneficiary"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "FinalisedCrowdsale"
     Gas costs: 0
     Source: "event FinalisedCrowdsale(uint256 totalSupply, uint256 minterBenefit);"
    ParameterList
       Source: "(uint256 totalSupply, uint256 minterBenefit)"
      VariableDeclaration "totalSupply"
         Type: uint256
         Source: "uint256 totalSupply"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "minterBenefit"
         Type: uint256
         Source: "uint256 minterBenefit"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "GESTokenCrowdSale" - public
     Source: "function GESTokenCrowdSale(uint256 _mainSaleStartTime, address _wallet, address _tokenWallet) public {\r\n\r\n    /* Can't start main sale in the past */\r\n    require(_mainSaleStartTime >= now);\r\n\r\n    /* Confirming wallet addresses as valid */\r\n    require(_wallet != 0x0);\r\n    require(_tokenWallet != 0x0);\r\n\r\n    /* The Crowdsale bonus pattern\r\n     * 1 day = 86400 = 60 * 60 * 24 (Seconds * Minutes * Hours)\r\n     * 1 day * Number of days to close at, Bonus Percentage, Max Wei for which bonus is given  \r\n     */\r\n    timeBonuses.push(TimeBonus(86400 *  7,  30,    2000000000000000000000)); // 0 - 7 Days, 30 %, 2000 ETH\r\n    timeBonuses.push(TimeBonus(86400 *  14, 20,    5000000000000000000000)); // 8 -14 Days, 20 %, 2000ETH + 3000 ETH = 5000 ETH\r\n    timeBonuses.push(TimeBonus(86400 *  21, 10,   10000000000000000000000)); // 15-21 Days, 10 %, 5000 ETH + 5000 ETH = 10000 ETH\r\n    timeBonuses.push(TimeBonus(86400 *  60,  0,   25000000000000000000000)); // 22-60 Days, 0  %, 10000 ETH + 15000 ETH = 25000 ETH\r\n\r\n    token = createTokenContract();\r\n    mainSaleStartTime = _mainSaleStartTime;\r\n    mainSaleEndTime = mainSaleStartTime + 60 days;\r\n    wallet = _wallet;\r\n    tokenWallet = _tokenWallet;\r\n    isFinalised = false;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _mainSaleStartTime, address _wallet, address _tokenWallet)"
      VariableDeclaration "_mainSaleStartTime"
         Type: uint256
         Source: "uint256 _mainSaleStartTime"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_wallet"
         Type: address
         Source: "address _wallet"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokenWallet"
         Type: address
         Source: "address _tokenWallet"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\r\n    /* Can't start main sale in the past */\r\n    require(_mainSaleStartTime >= now);\r\n\r\n    /* Confirming wallet addresses as valid */\r\n    require(_wallet != 0x0);\r\n    require(_tokenWallet != 0x0);\r\n\r\n    /* The Crowdsale bonus pattern\r\n     * 1 day = 86400 = 60 * 60 * 24 (Seconds * Minutes * Hours)\r\n     * 1 day * Number of days to close at, Bonus Percentage, Max Wei for which bonus is given  \r\n     */\r\n    timeBonuses.push(TimeBonus(86400 *  7,  30,    2000000000000000000000)); // 0 - 7 Days, 30 %, 2000 ETH\r\n    timeBonuses.push(TimeBonus(86400 *  14, 20,    5000000000000000000000)); // 8 -14 Days, 20 %, 2000ETH + 3000 ETH = 5000 ETH\r\n    timeBonuses.push(TimeBonus(86400 *  21, 10,   10000000000000000000000)); // 15-21 Days, 10 %, 5000 ETH + 5000 ETH = 10000 ETH\r\n    timeBonuses.push(TimeBonus(86400 *  60,  0,   25000000000000000000000)); // 22-60 Days, 0  %, 10000 ETH + 15000 ETH = 25000 ETH\r\n\r\n    token = createTokenContract();\r\n    mainSaleStartTime = _mainSaleStartTime;\r\n    mainSaleEndTime = mainSaleStartTime + 60 days;\r\n    wallet = _wallet;\r\n    tokenWallet = _tokenWallet;\r\n    isFinalised = false;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_mainSaleStartTime >= now)"
        FunctionCall
           Type: tuple()
           Source: "require(_mainSaleStartTime >= now)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "_mainSaleStartTime >= now"
            Identifier _mainSaleStartTime
               Type: uint256
               Source: "_mainSaleStartTime"
            Identifier now
               Type: uint256
               Source: "now"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_wallet != 0x0)"
        FunctionCall
           Type: tuple()
           Source: "require(_wallet != 0x0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_wallet != 0x0"
            Identifier _wallet
               Type: address
               Source: "_wallet"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_tokenWallet != 0x0)"
        FunctionCall
           Type: tuple()
           Source: "require(_tokenWallet != 0x0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_tokenWallet != 0x0"
            Identifier _tokenWallet
               Type: address
               Source: "_tokenWallet"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      ExpressionStatement
         Gas costs: 0
         Source: "timeBonuses.push(TimeBonus(86400 *  7,  30,    2000000000000000000000))"
        FunctionCall
           Type: uint256
           Source: "timeBonuses.push(TimeBonus(86400 *  7,  30,    2000000000000000000000))"
          MemberAccess to member push
             Type: function (struct GESTokenCrowdSale.TimeBonus storage ref) returns (uint256)
             Source: "timeBonuses.push"
            Identifier timeBonuses
               Type: struct GESTokenCrowdSale.TimeBonus storage ref[] storage ref
               Source: "timeBonuses"
          FunctionCall
             Type: struct GESTokenCrowdSale.TimeBonus memory
             Source: "TimeBonus(86400 *  7,  30,    2000000000000000000000)"
            Identifier TimeBonus
               Type: type(struct GESTokenCrowdSale.TimeBonus storage pointer)
               Source: "TimeBonus"
            BinaryOperation using operator *
               Type: int_const 604800
               Source: "86400 *  7"
              Literal, token: [no token] value: 86400
                 Type: int_const 86400
                 Source: "86400"
              Literal, token: [no token] value: 7
                 Type: int_const 7
                 Source: "7"
            Literal, token: [no token] value: 30
               Type: int_const 30
               Source: "30"
            Literal, token: [no token] value: 2000000000000000000000
               Type: int_const 2000000000000000000000
               Source: "2000000000000000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "timeBonuses.push(TimeBonus(86400 *  14, 20,    5000000000000000000000))"
        FunctionCall
           Type: uint256
           Source: "timeBonuses.push(TimeBonus(86400 *  14, 20,    5000000000000000000000))"
          MemberAccess to member push
             Type: function (struct GESTokenCrowdSale.TimeBonus storage ref) returns (uint256)
             Source: "timeBonuses.push"
            Identifier timeBonuses
               Type: struct GESTokenCrowdSale.TimeBonus storage ref[] storage ref
               Source: "timeBonuses"
          FunctionCall
             Type: struct GESTokenCrowdSale.TimeBonus memory
             Source: "TimeBonus(86400 *  14, 20,    5000000000000000000000)"
            Identifier TimeBonus
               Type: type(struct GESTokenCrowdSale.TimeBonus storage pointer)
               Source: "TimeBonus"
            BinaryOperation using operator *
               Type: int_const 1209600
               Source: "86400 *  14"
              Literal, token: [no token] value: 86400
                 Type: int_const 86400
                 Source: "86400"
              Literal, token: [no token] value: 14
                 Type: int_const 14
                 Source: "14"
            Literal, token: [no token] value: 20
               Type: int_const 20
               Source: "20"
            Literal, token: [no token] value: 5000000000000000000000
               Type: int_const 5000000000000000000000
               Source: "5000000000000000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "timeBonuses.push(TimeBonus(86400 *  21, 10,   10000000000000000000000))"
        FunctionCall
           Type: uint256
           Source: "timeBonuses.push(TimeBonus(86400 *  21, 10,   10000000000000000000000))"
          MemberAccess to member push
             Type: function (struct GESTokenCrowdSale.TimeBonus storage ref) returns (uint256)
             Source: "timeBonuses.push"
            Identifier timeBonuses
               Type: struct GESTokenCrowdSale.TimeBonus storage ref[] storage ref
               Source: "timeBonuses"
          FunctionCall
             Type: struct GESTokenCrowdSale.TimeBonus memory
             Source: "TimeBonus(86400 *  21, 10,   10000000000000000000000)"
            Identifier TimeBonus
               Type: type(struct GESTokenCrowdSale.TimeBonus storage pointer)
               Source: "TimeBonus"
            BinaryOperation using operator *
               Type: int_const 1814400
               Source: "86400 *  21"
              Literal, token: [no token] value: 86400
                 Type: int_const 86400
                 Source: "86400"
              Literal, token: [no token] value: 21
                 Type: int_const 21
                 Source: "21"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
            Literal, token: [no token] value: 10000000000000000000000
               Type: int_const 10000000000000000000000
               Source: "10000000000000000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "timeBonuses.push(TimeBonus(86400 *  60,  0,   25000000000000000000000))"
        FunctionCall
           Type: uint256
           Source: "timeBonuses.push(TimeBonus(86400 *  60,  0,   25000000000000000000000))"
          MemberAccess to member push
             Type: function (struct GESTokenCrowdSale.TimeBonus storage ref) returns (uint256)
             Source: "timeBonuses.push"
            Identifier timeBonuses
               Type: struct GESTokenCrowdSale.TimeBonus storage ref[] storage ref
               Source: "timeBonuses"
          FunctionCall
             Type: struct GESTokenCrowdSale.TimeBonus memory
             Source: "TimeBonus(86400 *  60,  0,   25000000000000000000000)"
            Identifier TimeBonus
               Type: type(struct GESTokenCrowdSale.TimeBonus storage pointer)
               Source: "TimeBonus"
            BinaryOperation using operator *
               Type: int_const 5184000
               Source: "86400 *  60"
              Literal, token: [no token] value: 86400
                 Type: int_const 86400
                 Source: "86400"
              Literal, token: [no token] value: 60
                 Type: int_const 60
                 Source: "60"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
            Literal, token: [no token] value: 25000000000000000000000
               Type: int_const 25000000000000000000000
               Source: "25000000000000000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "token = createTokenContract()"
        Assignment using operator =
           Type: contract MintableToken
           Source: "token = createTokenContract()"
          Identifier token
             Type: contract MintableToken
             Source: "token"
          FunctionCall
             Type: contract MintableToken
             Source: "createTokenContract()"
            Identifier createTokenContract
               Type: function () returns (contract MintableToken)
               Source: "createTokenContract"
      ExpressionStatement
         Gas costs: 0
         Source: "mainSaleStartTime = _mainSaleStartTime"
        Assignment using operator =
           Type: uint256
           Source: "mainSaleStartTime = _mainSaleStartTime"
          Identifier mainSaleStartTime
             Type: uint256
             Source: "mainSaleStartTime"
          Identifier _mainSaleStartTime
             Type: uint256
             Source: "_mainSaleStartTime"
      ExpressionStatement
         Gas costs: 0
         Source: "mainSaleEndTime = mainSaleStartTime + 60 days"
        Assignment using operator =
           Type: uint256
           Source: "mainSaleEndTime = mainSaleStartTime + 60 days"
          Identifier mainSaleEndTime
             Type: uint256
             Source: "mainSaleEndTime"
          BinaryOperation using operator +
             Type: uint256
             Source: "mainSaleStartTime + 60 days"
            Identifier mainSaleStartTime
               Type: uint256
               Source: "mainSaleStartTime"
            Literal, token: [no token] value: 60
               Type: int_const 5184000
               Source: "60 days"
      ExpressionStatement
         Gas costs: 0
         Source: "wallet = _wallet"
        Assignment using operator =
           Type: address
           Source: "wallet = _wallet"
          Identifier wallet
             Type: address
             Source: "wallet"
          Identifier _wallet
             Type: address
             Source: "_wallet"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenWallet = _tokenWallet"
        Assignment using operator =
           Type: address
           Source: "tokenWallet = _tokenWallet"
          Identifier tokenWallet
             Type: address
             Source: "tokenWallet"
          Identifier _tokenWallet
             Type: address
             Source: "_tokenWallet"
      ExpressionStatement
         Gas costs: 0
         Source: "isFinalised = false"
        Assignment using operator =
           Type: bool
           Source: "isFinalised = false"
          Identifier isFinalised
             Type: bool
             Source: "isFinalised"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "createTokenContract"
     Source: "function createTokenContract() internal returns (MintableToken) {\r\n    return new GESToken();\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(MintableToken)"
      VariableDeclaration ""
         Type: contract MintableToken
         Source: "MintableToken"
        UserDefinedTypeName "MintableToken"
           Source: "MintableToken"
    Block
       Source: "{\r\n    return new GESToken();\r\n  }"
      Return
         Gas costs: 0
         Source: "return new GESToken()"
        FunctionCall
           Type: contract GESToken
           Source: "new GESToken()"
          NewExpression
             Type: function () returns (contract GESToken)
             Source: "new GESToken"
            UserDefinedTypeName "GESToken"
               Source: "GESToken"
  FunctionDefinition "" - public
     Source: "function () payable {\r\n    buyTokens(msg.sender);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    buyTokens(msg.sender);\r\n  }"
      ExpressionStatement
         Gas costs: 6
         Source: "buyTokens(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "buyTokens(msg.sender)"
          Identifier buyTokens
             Type: function (address)
             Source: "buyTokens"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "buyTokens" - public
     Source: "function buyTokens(address beneficiary) public payable {\r\n    require(!isFinalised);\r\n    require(beneficiary != 0x0);\r\n    require(msg.value != 0);\r\n    require(now <= mainSaleEndTime && now >= mainSaleStartTime);\r\n    require(msg.value >= saleMinimumWei);\r\n\r\n    /* Add bonus to tokens depends on the period */\r\n    uint256 bonusedTokens = applyBonus(msg.value);\r\n\r\n    /* Update state on the blockchain */\r\n    weiRaised = weiRaised.add(msg.value);\r\n    token.mint(beneficiary, bonusedTokens);\r\n    TokenPurchase(msg.sender, beneficiary, msg.value, bonusedTokens);\r\n\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address beneficiary)"
      VariableDeclaration "beneficiary"
         Type: address
         Source: "address beneficiary"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    require(!isFinalised);\r\n    require(beneficiary != 0x0);\r\n    require(msg.value != 0);\r\n    require(now <= mainSaleEndTime && now >= mainSaleStartTime);\r\n    require(msg.value >= saleMinimumWei);\r\n\r\n    /* Add bonus to tokens depends on the period */\r\n    uint256 bonusedTokens = applyBonus(msg.value);\r\n\r\n    /* Update state on the blockchain */\r\n    weiRaised = weiRaised.add(msg.value);\r\n    token.mint(beneficiary, bonusedTokens);\r\n    TokenPurchase(msg.sender, beneficiary, msg.value, bonusedTokens);\r\n\r\n  }"
      ExpressionStatement
         Gas costs: 318
         Source: "require(!isFinalised)"
        FunctionCall
           Type: tuple()
           Source: "require(!isFinalised)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!isFinalised"
            Identifier isFinalised
               Type: bool
               Source: "isFinalised"
      ExpressionStatement
         Gas costs: 44
         Source: "require(beneficiary != 0x0)"
        FunctionCall
           Type: tuple()
           Source: "require(beneficiary != 0x0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "beneficiary != 0x0"
            Identifier beneficiary
               Type: address
               Source: "beneficiary"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      ExpressionStatement
         Gas costs: 37
         Source: "require(msg.value != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "msg.value != 0"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 470
         Source: "require(now <= mainSaleEndTime && now >= mainSaleStartTime)"
        FunctionCall
           Type: tuple()
           Source: "require(now <= mainSaleEndTime && now >= mainSaleStartTime)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "now <= mainSaleEndTime && now >= mainSaleStartTime"
            BinaryOperation using operator <=
               Type: bool
               Source: "now <= mainSaleEndTime"
              Identifier now
                 Type: uint256
                 Source: "now"
              Identifier mainSaleEndTime
                 Type: uint256
                 Source: "mainSaleEndTime"
            BinaryOperation using operator >=
               Type: bool
               Source: "now >= mainSaleStartTime"
              Identifier now
                 Type: uint256
                 Source: "now"
              Identifier mainSaleStartTime
                 Type: uint256
                 Source: "mainSaleStartTime"
      ExpressionStatement
         Gas costs: 237
         Source: "require(msg.value >= saleMinimumWei)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value >= saleMinimumWei)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.value >= saleMinimumWei"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier saleMinimumWei
               Type: uint256
               Source: "saleMinimumWei"
      VariableDeclarationStatement
         Gas costs: 14
         Source: "uint256 bonusedTokens = applyBonus(msg.value)"
        VariableDeclaration "bonusedTokens"
           Type: uint256
           Source: "uint256 bonusedTokens"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "applyBonus(msg.value)"
          Identifier applyBonus
             Type: function (uint256) view returns (uint256)
             Source: "applyBonus"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20246
         Source: "weiRaised = weiRaised.add(msg.value)"
        Assignment using operator =
           Type: uint256
           Source: "weiRaised = weiRaised.add(msg.value)"
          Identifier weiRaised
             Type: uint256
             Source: "weiRaised"
          FunctionCall
             Type: uint256
             Source: "weiRaised.add(msg.value)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "weiRaised.add"
              Identifier weiRaised
                 Type: uint256
                 Source: "weiRaised"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.mint(beneficiary, bonusedTokens)"
        FunctionCall
           Type: bool
           Source: "token.mint(beneficiary, bonusedTokens)"
          MemberAccess to member mint
             Type: function (address,uint256) external returns (bool)
             Source: "token.mint"
            Identifier token
               Type: contract MintableToken
               Source: "token"
          Identifier beneficiary
             Type: address
             Source: "beneficiary"
          Identifier bonusedTokens
             Type: uint256
             Source: "bonusedTokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "TokenPurchase(msg.sender, beneficiary, msg.value, bonusedTokens)"
        FunctionCall
           Type: tuple()
           Source: "TokenPurchase(msg.sender, beneficiary, msg.value, bonusedTokens)"
          Identifier TokenPurchase
             Type: function (address,address,uint256,uint256)
             Source: "TokenPurchase"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier beneficiary
             Type: address
             Source: "beneficiary"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier bonusedTokens
             Type: uint256
             Source: "bonusedTokens"
  FunctionDefinition "finaliseCrowdsale" - public
     Source: "function finaliseCrowdsale() external onlyOwner returns (bool) {\r\n    require(!isFinalised);\r\n    uint256 totalSupply = token.totalSupply();\r\n    uint256 minterBenefit = totalSupply.mul(10).div(89);\r\n    token.mint(tokenWallet, minterBenefit);\r\n    token.finishMinting();\r\n    forwardFunds();\r\n    FinalisedCrowdsale(totalSupply, minterBenefit);\r\n    isFinalised = true;\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(!isFinalised);\r\n    uint256 totalSupply = token.totalSupply();\r\n    uint256 minterBenefit = totalSupply.mul(10).div(89);\r\n    token.mint(tokenWallet, minterBenefit);\r\n    token.finishMinting();\r\n    forwardFunds();\r\n    FinalisedCrowdsale(totalSupply, minterBenefit);\r\n    isFinalised = true;\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 318
         Source: "require(!isFinalised)"
        FunctionCall
           Type: tuple()
           Source: "require(!isFinalised)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!isFinalised"
            Identifier isFinalised
               Type: bool
               Source: "isFinalised"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint256 totalSupply = token.totalSupply()"
        VariableDeclaration "totalSupply"
           Type: uint256
           Source: "uint256 totalSupply"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "token.totalSupply()"
          MemberAccess to member totalSupply
             Type: function () view external returns (uint256)
             Source: "token.totalSupply"
            Identifier token
               Type: contract MintableToken
               Source: "token"
      VariableDeclarationStatement
         Gas costs: 77
         Source: "uint256 minterBenefit = totalSupply.mul(10).div(89)"
        VariableDeclaration "minterBenefit"
           Type: uint256
           Source: "uint256 minterBenefit"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "totalSupply.mul(10).div(89)"
          MemberAccess to member div
             Type: function (uint256,uint256) view returns (uint256)
             Source: "totalSupply.mul(10).div"
            FunctionCall
               Type: uint256
               Source: "totalSupply.mul(10)"
              MemberAccess to member mul
                 Type: function (uint256,uint256) view returns (uint256)
                 Source: "totalSupply.mul"
                Identifier totalSupply
                   Type: uint256
                   Source: "totalSupply"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
          Literal, token: [no token] value: 89
             Type: int_const 89
             Source: "89"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.mint(tokenWallet, minterBenefit)"
        FunctionCall
           Type: bool
           Source: "token.mint(tokenWallet, minterBenefit)"
          MemberAccess to member mint
             Type: function (address,uint256) external returns (bool)
             Source: "token.mint"
            Identifier token
               Type: contract MintableToken
               Source: "token"
          Identifier tokenWallet
             Type: address
             Source: "tokenWallet"
          Identifier minterBenefit
             Type: uint256
             Source: "minterBenefit"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.finishMinting()"
        FunctionCall
           Type: bool
           Source: "token.finishMinting()"
          MemberAccess to member finishMinting
             Type: function () external returns (bool)
             Source: "token.finishMinting"
            Identifier token
               Type: contract MintableToken
               Source: "token"
      ExpressionStatement
         Gas costs: 4
         Source: "forwardFunds()"
        FunctionCall
           Type: tuple()
           Source: "forwardFunds()"
          Identifier forwardFunds
             Type: function ()
             Source: "forwardFunds"
      ExpressionStatement
         Gas costs: [???]
         Source: "FinalisedCrowdsale(totalSupply, minterBenefit)"
        FunctionCall
           Type: tuple()
           Source: "FinalisedCrowdsale(totalSupply, minterBenefit)"
          Identifier FinalisedCrowdsale
             Type: function (uint256,uint256)
             Source: "FinalisedCrowdsale"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier minterBenefit
             Type: uint256
             Source: "minterBenefit"
      ExpressionStatement
         Gas costs: 20317
         Source: "isFinalised = true"
        Assignment using operator =
           Type: bool
           Source: "isFinalised = true"
          Identifier isFinalised
             Type: bool
             Source: "isFinalised"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "setMainSaleDates" - public
     Source: "function setMainSaleDates(uint256 _mainSaleStartTime) public onlyOwner returns (bool) {\r\n    require(!isFinalised);\r\n    mainSaleStartTime = _mainSaleStartTime;\r\n    mainSaleEndTime = mainSaleStartTime + 60 days;\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _mainSaleStartTime)"
      VariableDeclaration "_mainSaleStartTime"
         Type: uint256
         Source: "uint256 _mainSaleStartTime"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(!isFinalised);\r\n    mainSaleStartTime = _mainSaleStartTime;\r\n    mainSaleEndTime = mainSaleStartTime + 60 days;\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 318
         Source: "require(!isFinalised)"
        FunctionCall
           Type: tuple()
           Source: "require(!isFinalised)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!isFinalised"
            Identifier isFinalised
               Type: bool
               Source: "isFinalised"
      ExpressionStatement
         Gas costs: 20014
         Source: "mainSaleStartTime = _mainSaleStartTime"
        Assignment using operator =
           Type: uint256
           Source: "mainSaleStartTime = _mainSaleStartTime"
          Identifier mainSaleStartTime
             Type: uint256
             Source: "mainSaleStartTime"
          Identifier _mainSaleStartTime
             Type: uint256
             Source: "_mainSaleStartTime"
      ExpressionStatement
         Gas costs: 20220
         Source: "mainSaleEndTime = mainSaleStartTime + 60 days"
        Assignment using operator =
           Type: uint256
           Source: "mainSaleEndTime = mainSaleStartTime + 60 days"
          Identifier mainSaleEndTime
             Type: uint256
             Source: "mainSaleEndTime"
          BinaryOperation using operator +
             Type: uint256
             Source: "mainSaleStartTime + 60 days"
            Identifier mainSaleStartTime
               Type: uint256
               Source: "mainSaleStartTime"
            Literal, token: [no token] value: 60
               Type: int_const 5184000
               Source: "60 days"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "pauseToken" - public
     Source: "function pauseToken() external onlyOwner {\r\n    require(!isFinalised);\r\n    GESToken(token).pause();\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(!isFinalised);\r\n    GESToken(token).pause();\r\n  }"
      ExpressionStatement
         Gas costs: 318
         Source: "require(!isFinalised)"
        FunctionCall
           Type: tuple()
           Source: "require(!isFinalised)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!isFinalised"
            Identifier isFinalised
               Type: bool
               Source: "isFinalised"
      ExpressionStatement
         Gas costs: [???]
         Source: "GESToken(token).pause()"
        FunctionCall
           Type: tuple()
           Source: "GESToken(token).pause()"
          MemberAccess to member pause
             Type: function () external
             Source: "GESToken(token).pause"
            FunctionCall
               Type: contract GESToken
               Source: "GESToken(token)"
              Identifier GESToken
                 Type: type(contract GESToken)
                 Source: "GESToken"
              Identifier token
                 Type: contract MintableToken
                 Source: "token"
  FunctionDefinition "unpauseToken" - public
     Source: "function unpauseToken() external onlyOwner {\r\n    GESToken(token).unpause();\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    GESToken(token).unpause();\r\n  }"
      ExpressionStatement
         Gas costs: [???]
         Source: "GESToken(token).unpause()"
        FunctionCall
           Type: tuple()
           Source: "GESToken(token).unpause()"
          MemberAccess to member unpause
             Type: function () external
             Source: "GESToken(token).unpause"
            FunctionCall
               Type: contract GESToken
               Source: "GESToken(token)"
              Identifier GESToken
                 Type: type(contract GESToken)
                 Source: "GESToken"
              Identifier token
                 Type: contract MintableToken
                 Source: "token"
  FunctionDefinition "transferTokenOwnership" - public
     Source: "function transferTokenOwnership(address newOwner) external onlyOwner {\r\n    GESToken(token).transferOwnership(newOwner);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    GESToken(token).transferOwnership(newOwner);\r\n  }"
      ExpressionStatement
         Gas costs: [???]
         Source: "GESToken(token).transferOwnership(newOwner)"
        FunctionCall
           Type: tuple()
           Source: "GESToken(token).transferOwnership(newOwner)"
          MemberAccess to member transferOwnership
             Type: function (address) external
             Source: "GESToken(token).transferOwnership"
            FunctionCall
               Type: contract GESToken
               Source: "GESToken(token)"
              Identifier GESToken
                 Type: type(contract GESToken)
                 Source: "GESToken"
              Identifier token
                 Type: contract MintableToken
                 Source: "token"
          Identifier newOwner
             Type: address
             Source: "newOwner"
  FunctionDefinition "mainSaleHasEnded" - public - const
     Source: "function mainSaleHasEnded() external constant returns (bool) {\r\n    return now > mainSaleEndTime;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    return now > mainSaleEndTime;\r\n  }"
      Return
         Gas costs: 213
         Source: "return now > mainSaleEndTime"
        BinaryOperation using operator >
           Type: bool
           Source: "now > mainSaleEndTime"
          Identifier now
             Type: uint256
             Source: "now"
          Identifier mainSaleEndTime
             Type: uint256
             Source: "mainSaleEndTime"
  FunctionDefinition "forwardFunds"
     Source: "function forwardFunds() internal {\r\n    wallet.transfer(this.balance);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    wallet.transfer(this.balance);\r\n  }"
      ExpressionStatement
         Gas costs: [???]
         Source: "wallet.transfer(this.balance)"
        FunctionCall
           Type: tuple()
           Source: "wallet.transfer(this.balance)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "wallet.transfer"
            Identifier wallet
               Type: address
               Source: "wallet"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract GESTokenCrowdSale
               Source: "this"
  FunctionDefinition "applyBonus" - const
     Source: "function applyBonus(uint256 weiAmount) internal constant returns (uint256 bonusedTokens) {\r\n    /* Bonus tokens to be added */\r\n    uint256 tokensToAdd = 0;\r\n\r\n    /* Calculting the amont of tokens to be allocated based on rate and the money transferred*/\r\n    uint256 tokens = weiAmount.mul(rate);\r\n    uint256 diffInSeconds = now.sub(mainSaleStartTime);\r\n\r\n    for (uint i = 0; i < timeBonuses.length; i++) {\r\n      /* If cap[i] is reached then skip */\r\n      if(weiRaised.add(weiAmount) <= timeBonuses[i].weiCap){\r\n        for(uint j = i; j < timeBonuses.length; j++){\r\n          /* Check which week period time it lies and use that percent */\r\n          if (diffInSeconds <= timeBonuses[j].bonusPeriodEndTime) {\r\n            tokensToAdd = tokens.mul(timeBonuses[j].percent).div(100);\r\n            return tokens.add(tokensToAdd);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 weiAmount)"
      VariableDeclaration "weiAmount"
         Type: uint256
         Source: "uint256 weiAmount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 bonusedTokens)"
      VariableDeclaration "bonusedTokens"
         Type: uint256
         Source: "uint256 bonusedTokens"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    /* Bonus tokens to be added */\r\n    uint256 tokensToAdd = 0;\r\n\r\n    /* Calculting the amont of tokens to be allocated based on rate and the money transferred*/\r\n    uint256 tokens = weiAmount.mul(rate);\r\n    uint256 diffInSeconds = now.sub(mainSaleStartTime);\r\n\r\n    for (uint i = 0; i < timeBonuses.length; i++) {\r\n      /* If cap[i] is reached then skip */\r\n      if(weiRaised.add(weiAmount) <= timeBonuses[i].weiCap){\r\n        for(uint j = i; j < timeBonuses.length; j++){\r\n          /* Check which week period time it lies and use that percent */\r\n          if (diffInSeconds <= timeBonuses[j].bonusPeriodEndTime) {\r\n            tokensToAdd = tokens.mul(timeBonuses[j].percent).div(100);\r\n            return tokens.add(tokensToAdd);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n  }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint256 tokensToAdd = 0"
        VariableDeclaration "tokensToAdd"
           Type: uint256
           Source: "uint256 tokensToAdd"
          ElementaryTypeName uint256
             Source: "uint256"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 244
         Source: "uint256 tokens = weiAmount.mul(rate)"
        VariableDeclaration "tokens"
           Type: uint256
           Source: "uint256 tokens"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "weiAmount.mul(rate)"
          MemberAccess to member mul
             Type: function (uint256,uint256) view returns (uint256)
             Source: "weiAmount.mul"
            Identifier weiAmount
               Type: uint256
               Source: "weiAmount"
          Identifier rate
             Type: uint256
             Source: "rate"
      VariableDeclarationStatement
         Gas costs: 243
         Source: "uint256 diffInSeconds = now.sub(mainSaleStartTime)"
        VariableDeclaration "diffInSeconds"
           Type: uint256
           Source: "uint256 diffInSeconds"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "now.sub(mainSaleStartTime)"
          MemberAccess to member sub
             Type: function (uint256,uint256) view returns (uint256)
             Source: "now.sub"
            Identifier now
               Type: uint256
               Source: "now"
          Identifier mainSaleStartTime
             Type: uint256
             Source: "mainSaleStartTime"
      ForStatement
         Source: "for (uint i = 0; i < timeBonuses.length; i++) {\r\n      /* If cap[i] is reached then skip */\r\n      if(weiRaised.add(weiAmount) <= timeBonuses[i].weiCap){\r\n        for(uint j = i; j < timeBonuses.length; j++){\r\n          /* Check which week period time it lies and use that percent */\r\n          if (diffInSeconds <= timeBonuses[j].bonusPeriodEndTime) {\r\n            tokensToAdd = tokens.mul(timeBonuses[j].percent).div(100);\r\n            return tokens.add(tokensToAdd);\r\n          }\r\n        }\r\n      }\r\n    }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 217
           Source: "i < timeBonuses.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "timeBonuses.length"
            Identifier timeBonuses
               Type: struct GESTokenCrowdSale.TimeBonus storage ref[] storage ref
               Source: "timeBonuses"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n      /* If cap[i] is reached then skip */\r\n      if(weiRaised.add(weiAmount) <= timeBonuses[i].weiCap){\r\n        for(uint j = i; j < timeBonuses.length; j++){\r\n          /* Check which week period time it lies and use that percent */\r\n          if (diffInSeconds <= timeBonuses[j].bonusPeriodEndTime) {\r\n            tokensToAdd = tokens.mul(timeBonuses[j].percent).div(100);\r\n            return tokens.add(tokensToAdd);\r\n          }\r\n        }\r\n      }\r\n    }"
          IfStatement
             Source: "if(weiRaised.add(weiAmount) <= timeBonuses[i].weiCap){\r\n        for(uint j = i; j < timeBonuses.length; j++){\r\n          /* Check which week period time it lies and use that percent */\r\n          if (diffInSeconds <= timeBonuses[j].bonusPeriodEndTime) {\r\n            tokensToAdd = tokens.mul(timeBonuses[j].percent).div(100);\r\n            return tokens.add(tokensToAdd);\r\n          }\r\n        }\r\n      }"
            BinaryOperation using operator <=
               Type: bool
               Gas costs: 751
               Source: "weiRaised.add(weiAmount) <= timeBonuses[i].weiCap"
              FunctionCall
                 Type: uint256
                 Source: "weiRaised.add(weiAmount)"
                MemberAccess to member add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "weiRaised.add"
                  Identifier weiRaised
                     Type: uint256
                     Source: "weiRaised"
                Identifier weiAmount
                   Type: uint256
                   Source: "weiAmount"
              MemberAccess to member weiCap
                 Type: uint256
                 Source: "timeBonuses[i].weiCap"
                IndexAccess
                   Type: struct GESTokenCrowdSale.TimeBonus storage ref
                   Source: "timeBonuses[i]"
                  Identifier timeBonuses
                     Type: struct GESTokenCrowdSale.TimeBonus storage ref[] storage ref
                     Source: "timeBonuses"
                  Identifier i
                     Type: uint256
                     Source: "i"
            Block
               Source: "{\r\n        for(uint j = i; j < timeBonuses.length; j++){\r\n          /* Check which week period time it lies and use that percent */\r\n          if (diffInSeconds <= timeBonuses[j].bonusPeriodEndTime) {\r\n            tokensToAdd = tokens.mul(timeBonuses[j].percent).div(100);\r\n            return tokens.add(tokensToAdd);\r\n          }\r\n        }\r\n      }"
              ForStatement
                 Source: "for(uint j = i; j < timeBonuses.length; j++){\r\n          /* Check which week period time it lies and use that percent */\r\n          if (diffInSeconds <= timeBonuses[j].bonusPeriodEndTime) {\r\n            tokensToAdd = tokens.mul(timeBonuses[j].percent).div(100);\r\n            return tokens.add(tokensToAdd);\r\n          }\r\n        }"
                VariableDeclarationStatement
                   Gas costs: 11
                   Source: "uint j = i"
                  VariableDeclaration "j"
                     Type: uint256
                     Source: "uint j"
                    ElementaryTypeName uint
                       Source: "uint"
                  Identifier i
                     Type: uint256
                     Source: "i"
                BinaryOperation using operator <
                   Type: bool
                   Gas costs: 217
                   Source: "j < timeBonuses.length"
                  Identifier j
                     Type: uint256
                     Source: "j"
                  MemberAccess to member length
                     Type: uint256
                     Source: "timeBonuses.length"
                    Identifier timeBonuses
                       Type: struct GESTokenCrowdSale.TimeBonus storage ref[] storage ref
                       Source: "timeBonuses"
                ExpressionStatement
                   Gas costs: 19
                   Source: "j++"
                  UnaryOperation (postfix) ++
                     Type: uint256
                     Source: "j++"
                    Identifier j
                       Type: uint256
                       Source: "j"
                Block
                   Source: "{\r\n          /* Check which week period time it lies and use that percent */\r\n          if (diffInSeconds <= timeBonuses[j].bonusPeriodEndTime) {\r\n            tokensToAdd = tokens.mul(timeBonuses[j].percent).div(100);\r\n            return tokens.add(tokensToAdd);\r\n          }\r\n        }"
                  IfStatement
                     Source: "if (diffInSeconds <= timeBonuses[j].bonusPeriodEndTime) {\r\n            tokensToAdd = tokens.mul(timeBonuses[j].percent).div(100);\r\n            return tokens.add(tokensToAdd);\r\n          }"
                    BinaryOperation using operator <=
                       Type: bool
                       Gas costs: 518
                       Source: "diffInSeconds <= timeBonuses[j].bonusPeriodEndTime"
                      Identifier diffInSeconds
                         Type: uint256
                         Source: "diffInSeconds"
                      MemberAccess to member bonusPeriodEndTime
                         Type: uint256
                         Source: "timeBonuses[j].bonusPeriodEndTime"
                        IndexAccess
                           Type: struct GESTokenCrowdSale.TimeBonus storage ref
                           Source: "timeBonuses[j]"
                          Identifier timeBonuses
                             Type: struct GESTokenCrowdSale.TimeBonus storage ref[] storage ref
                             Source: "timeBonuses"
                          Identifier j
                             Type: uint256
                             Source: "j"
                    Block
                       Source: "{\r\n            tokensToAdd = tokens.mul(timeBonuses[j].percent).div(100);\r\n            return tokens.add(tokensToAdd);\r\n          }"
                      ExpressionStatement
                         Gas costs: 580
                         Source: "tokensToAdd = tokens.mul(timeBonuses[j].percent).div(100)"
                        Assignment using operator =
                           Type: uint256
                           Source: "tokensToAdd = tokens.mul(timeBonuses[j].percent).div(100)"
                          Identifier tokensToAdd
                             Type: uint256
                             Source: "tokensToAdd"
                          FunctionCall
                             Type: uint256
                             Source: "tokens.mul(timeBonuses[j].percent).div(100)"
                            MemberAccess to member div
                               Type: function (uint256,uint256) view returns (uint256)
                               Source: "tokens.mul(timeBonuses[j].percent).div"
                              FunctionCall
                                 Type: uint256
                                 Source: "tokens.mul(timeBonuses[j].percent)"
                                MemberAccess to member mul
                                   Type: function (uint256,uint256) view returns (uint256)
                                   Source: "tokens.mul"
                                  Identifier tokens
                                     Type: uint256
                                     Source: "tokens"
                                MemberAccess to member percent
                                   Type: uint256
                                   Source: "timeBonuses[j].percent"
                                  IndexAccess
                                     Type: struct GESTokenCrowdSale.TimeBonus storage ref
                                     Source: "timeBonuses[j]"
                                    Identifier timeBonuses
                                       Type: struct GESTokenCrowdSale.TimeBonus storage ref[] storage ref
                                       Source: "timeBonuses"
                                    Identifier j
                                       Type: uint256
                                       Source: "j"
                            Literal, token: [no token] value: 100
                               Type: int_const 100
                               Source: "100"
                      Return
                         Gas costs: 52
                         Source: "return tokens.add(tokensToAdd)"
                        FunctionCall
                           Type: uint256
                           Source: "tokens.add(tokensToAdd)"
                          MemberAccess to member add
                             Type: function (uint256,uint256) view returns (uint256)
                             Source: "tokens.add"
                            Identifier tokens
                               Type: uint256
                               Source: "tokens"
                          Identifier tokensToAdd
                             Type: uint256
                             Source: "tokensToAdd"
  FunctionDefinition "fetchFunds" - public
     Source: "function fetchFunds() onlyOwner public {\r\n    wallet.transfer(this.balance);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    wallet.transfer(this.balance);\r\n  }"
      ExpressionStatement
         Gas costs: [???]
         Source: "wallet.transfer(this.balance)"
        FunctionCall
           Type: tuple()
           Source: "wallet.transfer(this.balance)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "wallet.transfer"
            Identifier wallet
               Type: address
               Source: "wallet"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract GESTokenCrowdSale
               Source: "this"
