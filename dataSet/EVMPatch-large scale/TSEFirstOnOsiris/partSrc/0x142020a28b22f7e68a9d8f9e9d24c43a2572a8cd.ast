Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x142020a28b22f7e68a9d8f9e9d24c43a2572a8cd.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.18;"
ContractDefinition "SafeMath"
   Source: "contract SafeMath {\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }\r\n\r\n}"
  FunctionDefinition "safeAdd"
     Source: "function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 z = x + y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "x + y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
      ExpressionStatement
         Gas costs: 66
         Source: "assert((z >= x) && (z >= y))"
        FunctionCall
           Type: tuple()
           Source: "assert((z >= x) && (z >= y))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator &&
             Type: bool
             Source: "(z >= x) && (z >= y)"
            TupleExpression
               Type: bool
               Source: "(z >= x)"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "z >= x"
                Identifier z
                   Type: uint256
                   Source: "z"
                Identifier x
                   Type: uint256
                   Source: "x"
            TupleExpression
               Type: bool
               Source: "(z >= y)"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "z >= y"
                Identifier z
                   Type: uint256
                   Source: "z"
                Identifier y
                   Type: uint256
                   Source: "y"
      Return
         Gas costs: 8
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
  FunctionDefinition "safeSubtract"
     Source: "function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(x >= y)"
        FunctionCall
           Type: tuple()
           Source: "assert(x >= y)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "x >= y"
            Identifier x
               Type: uint256
               Source: "x"
            Identifier y
               Type: uint256
               Source: "y"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 z = x - y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator -
           Type: uint256
           Source: "x - y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
      Return
         Gas costs: 0
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
  FunctionDefinition "safeMult"
     Source: "function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint256 z = x * y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "x * y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
      ExpressionStatement
         Gas costs: 88
         Source: "assert((x == 0)||(z/x == y))"
        FunctionCall
           Type: tuple()
           Source: "assert((x == 0)||(z/x == y))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "(x == 0)||(z/x == y)"
            TupleExpression
               Type: bool
               Source: "(x == 0)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "x == 0"
                Identifier x
                   Type: uint256
                   Source: "x"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            TupleExpression
               Type: bool
               Source: "(z/x == y)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "z/x == y"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "z/x"
                  Identifier z
                     Type: uint256
                     Source: "z"
                  Identifier x
                     Type: uint256
                     Source: "x"
                Identifier y
                   Type: uint256
                   Source: "y"
      Return
         Gas costs: 8
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
ContractDefinition "Token"
   Gas costs: [???]
   Source: "contract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Token"
    UserDefinedTypeName "Token"
       Source: "Token"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success) {\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }"
      IfStatement
         Source: "if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 338
           Source: "balances[msg.sender] >= _value && _value > 0"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
          BinaryOperation using operator >
             Type: bool
             Source: "_value > 0"
            Identifier _value
               Type: uint256
               Source: "_value"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      }"
          ExpressionStatement
             Gas costs: 20328
             Source: "balances[msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20323
             Source: "balances[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balances[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(msg.sender, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(msg.sender, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{\r\n        return false;\r\n      }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }"
      IfStatement
         Source: "if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 758
           Source: "balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0"
          BinaryOperation using operator &&
             Type: bool
             Source: "balances[_from] >= _value && allowed[_from][msg.sender] >= _value"
            BinaryOperation using operator >=
               Type: bool
               Source: "balances[_from] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            BinaryOperation using operator >=
               Type: bool
               Source: "allowed[_from][msg.sender] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          BinaryOperation using operator >
             Type: bool
             Source: "_value > 0"
            Identifier _value
               Type: uint256
               Source: "_value"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      }"
          ExpressionStatement
             Gas costs: 20329
             Source: "balances[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balances[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20323
             Source: "balances[_from] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[_from] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20412
             Source: "allowed[_from][msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "allowed[_from][msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(_from, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(_from, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              Identifier _from
                 Type: address
                 Source: "_from"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{\r\n        return false;\r\n      }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balances[_owner];\r\n    }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balances"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "Ownable"
   Source: "contract Ownable {\r\n  address public owner;\r\n\r\n/**\r\n* @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n* account.\r\n*/\r\nfunction Ownable() {\r\n  owner = msg.sender;\r\n}\r\n/**\r\n* @dev Throws if called by any account other than the owner.\r\n*/\r\nmodifier onlyOwner() {\r\n  require(msg.sender == owner);\r\n_;\r\n}\r\n/**\r\n* @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n* @param newOwner The address to transfer ownership to.\r\n*/\r\nfunction transferOwnership(address newOwner) onlyOwner {\r\n  if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n  }\r\n}\r\n\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "Ownable" - public
     Source: "function Ownable() {\r\n  owner = msg.sender;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n  owner = msg.sender;\r\n}"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n  require(msg.sender == owner);\r\n_;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n  require(msg.sender == owner);\r\n_;\r\n}"
      ExpressionStatement
         Gas costs: 1410
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) onlyOwner {\r\n  if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n  }\r\n}"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n  if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n  }\r\n}"
      IfStatement
         Source: "if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n  }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 24
           Source: "newOwner != address(0)"
          Identifier newOwner
             Type: address
             Source: "newOwner"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n      owner = newOwner;\r\n  }"
          ExpressionStatement
             Gas costs: 20267
             Source: "owner = newOwner"
            Assignment using operator =
               Type: address
               Source: "owner = newOwner"
              Identifier owner
                 Type: address
                 Source: "owner"
              Identifier newOwner
                 Type: address
                 Source: "newOwner"
ContractDefinition "PPCToken"
   Source: "contract PPCToken is StandardToken,Ownable, SafeMath {\r\n\r\n    // crowdsale parameters\r\n    string  public constant name = \"PPCCoin\";\r\n    string  public constant symbol = \"PPC\";\r\n    uint256 public constant decimals = 18;\r\n    string  public version = \"1.0\";\r\n    address public constant ethFundDeposit= 0x20D9053d3f7fccC069c9a8e7dDEf5374CD22b6C8;                         // Deposit address for ETH\r\n    bool public emergencyFlag;                                      //  Switched to true in  crownsale end  state\r\n    uint256 public fundingStartBlock;                              //   Starting blocknumber\r\n    uint256 public fundingEndBlock;                               //    Ending blocknumber\r\n    uint256 public constant minTokenPurchaseAmount= .008 ether;  //     Minimum purchase\r\n    uint256 public constant tokenPreSaleRate=800;    // PPCCoin per 1 ETH during presale\r\n    uint256 public constant tokenCrowdsaleRate=500; //  PPCCoin per 1 ETH during crowdsale\r\n    uint256 public constant tokenCreationPreSaleCap =  10 * (10**6) * 10**decimals;// 10 million token cap for presale\r\n    uint256 public constant tokenCreationCap =  100 * (10**6) * 10**decimals;      //  100 million token generated\r\n    uint256 public constant preSaleBlockNumber = 169457;\r\n    uint256 public finalBlockNumber =370711;\r\n\r\n\r\n    // events\r\n    event CreatePPC(address indexed _to, uint256 _value);// Return address of buyer and purchase token\r\n    event Mint(address indexed _to,uint256 _value);     //  Reutn address to which we send the mint token and token assigned.\r\n    // Constructor\r\n    function PPCToken(){\r\n      emergencyFlag = false;                             // False at initialization will be false during ICO\r\n      fundingStartBlock = block.number;                 //  Current deploying block number is the starting block number for ICO\r\n      fundingEndBlock=safeAdd(fundingStartBlock,finalBlockNumber);  //   Ending time depending upon the block number\r\n    }\r\n\r\n    /**\r\n    * @dev creates new PPC tokens\r\n    *      It is a internal function it will be called by fallback function or buyToken functions.\r\n    */\r\n    function createTokens() internal  {\r\n      if (emergencyFlag) revert();                     //  Revert when the sale is over before time and emergencyFlag is true.\r\n      if (block.number > fundingEndBlock) revert();   //   If the blocknumber exceed the ending block it will revert\r\n      if (msg.value<minTokenPurchaseAmount)revert();  //    If someone send 0.08 ether it will fail\r\n      uint256 tokenExchangeRate=tokenRate();        //     It will get value depending upon block number and presale cap\r\n      uint256 tokens = safeMult(msg.value, tokenExchangeRate);//  Calculating number of token for sender\r\n      totalSupply = safeAdd(totalSupply, tokens);            //   Add token to total supply\r\n      if(totalSupply>tokenCreationCap)revert();             //    Check the total supply if it is more then hardcap it will throw\r\n      balances[msg.sender] += tokens;                      //     Adding token to sender account\r\n      forwardfunds();                                     //      forwardfunds to the owner\r\n      CreatePPC(msg.sender, tokens);                      //      Logs sender address and  token creation\r\n    }\r\n\r\n    /**\r\n    * @dev people can access contract and choose buyToken function to get token\r\n    *It is used by using myetherwallet\r\n    *It is a payable function it will be called by sender.\r\n    */\r\n    function buyToken() payable external{\r\n      createTokens();   // This will call the internal createToken function to get token\r\n    }\r\n\r\n    /**\r\n    * @dev      it is a internal function called by create function to get the amount according to the blocknumber.\r\n    * @return   It will return the token price at a particular time.\r\n    */\r\n    function tokenRate() internal returns (uint256 _tokenPrice){\r\n      // It is a presale it will return price for presale\r\n      if(block.number<safeAdd(fundingStartBlock,preSaleBlockNumber)&&(totalSupply<tokenCreationPreSaleCap)){\r\n          return tokenPreSaleRate;\r\n        }else\r\n            return tokenCrowdsaleRate;\r\n    }\r\n\r\n    /**\r\n    * @dev     it will  assign token to a particular address by owner only\r\n    * @param   _to the address whom you want to send token to\r\n    * @param   _amount the amount you want to send\r\n    * @return  It will return true if success.\r\n    */\r\n    function mint(address _to, uint256 _amount) external onlyOwner returns (bool) {\r\n      if (emergencyFlag) revert();\r\n      totalSupply = safeAdd(totalSupply,_amount);// Add the minted token to total suppy\r\n      if(totalSupply>tokenCreationCap)revert();\r\n      balances[_to] +=_amount;                 //   Adding token to the input address\r\n      Mint(_to, _amount);                     //    Log the mint with address and token given to particular address\r\n      return true;\r\n    }\r\n\r\n    /**\r\n    * @dev     it will change the ending date of ico and access by owner only\r\n    * @param   _newBlock enter the future blocknumber\r\n    * @return  It will return the blocknumber\r\n    */\r\n    function changeEndBlock(uint256 _newBlock) external onlyOwner returns (uint256 _endblock )\r\n    {   // we are expecting that owner will input number greater than current block.\r\n        require(_newBlock > fundingStartBlock);\r\n        fundingEndBlock = _newBlock;         // New block is assigned to extend the Crowd Sale time\r\n        return fundingEndBlock;\r\n    }\r\n\r\n    /**\r\n    * @dev   it will let Owner withdrawn ether at any time during the ICO\r\n    **/\r\n    function drain() external onlyOwner {\r\n        if (!ethFundDeposit.send(this.balance)) revert();// It will revert if transfer fails.\r\n    }\r\n\r\n    \r\n    \r\n    // Automate the ETH drain\r\n    \r\n    function forwardfunds() internal {\r\n         if (!ethFundDeposit.send(this.balance)) revert(); // It will revert if transfer fails.\r\n        \r\n        \r\n    }\r\n    \r\n    /**\r\n    * @dev  it will let Owner Stop the crowdsale and mint function to work.\r\n    *\r\n    */\r\n    \r\n    function emergencyToggle() external onlyOwner{\r\n      emergencyFlag = !emergencyFlag;\r\n    }\r\n\r\n    // Fallback function let user send ether without calling the buy function.\r\n    function() payable {\r\n      createTokens();\r\n\r\n    }\r\n\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  VariableDeclaration "name"
     Type: string memory
     Gas costs: [???]
     Source: "string  public constant name = \"PPCCoin\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: PPCCoin
       Type: literal_string "PPCCoin"
       Source: "\"PPCCoin\""
  VariableDeclaration "symbol"
     Type: string memory
     Gas costs: [???]
     Source: "string  public constant symbol = \"PPC\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: PPC
       Type: literal_string "PPC"
       Source: "\"PPC\""
  VariableDeclaration "decimals"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant decimals = 18"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "version"
     Type: string storage ref
     Gas costs: [???]
     Source: "string  public version = \"1.0\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: 1.0
       Type: literal_string "1.0"
       Source: "\"1.0\""
  VariableDeclaration "ethFundDeposit"
     Type: address
     Gas costs: [???]
     Source: "address public constant ethFundDeposit= 0x20D9053d3f7fccC069c9a8e7dDEf5374CD22b6C8"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x20D9053d3f7fccC069c9a8e7dDEf5374CD22b6C8
       Type: address
       Source: "0x20D9053d3f7fccC069c9a8e7dDEf5374CD22b6C8"
  VariableDeclaration "emergencyFlag"
     Type: bool
     Gas costs: [???]
     Source: "bool public emergencyFlag"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "fundingStartBlock"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public fundingStartBlock"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "fundingEndBlock"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public fundingEndBlock"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "minTokenPurchaseAmount"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant minTokenPurchaseAmount= .008 ether"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: .008
       Type: int_const 8000000000000000
       Source: ".008 ether"
  VariableDeclaration "tokenPreSaleRate"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant tokenPreSaleRate=800"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 800
       Type: int_const 800
       Source: "800"
  VariableDeclaration "tokenCrowdsaleRate"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant tokenCrowdsaleRate=500"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 500
       Type: int_const 500
       Source: "500"
  VariableDeclaration "tokenCreationPreSaleCap"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant tokenCreationPreSaleCap =  10 * (10**6) * 10**decimals"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator *
       Type: uint256
       Source: "10 * (10**6) * 10**decimals"
      BinaryOperation using operator *
         Type: int_const 10000000
         Source: "10 * (10**6)"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        TupleExpression
           Type: int_const 1000000
           Source: "(10**6)"
          BinaryOperation using operator **
             Type: int_const 1000000
             Source: "10**6"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
            Literal, token: [no token] value: 6
               Type: int_const 6
               Source: "6"
      BinaryOperation using operator **
         Type: uint256
         Source: "10**decimals"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Identifier decimals
           Type: uint256
           Source: "decimals"
  VariableDeclaration "tokenCreationCap"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant tokenCreationCap =  100 * (10**6) * 10**decimals"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator *
       Type: uint256
       Source: "100 * (10**6) * 10**decimals"
      BinaryOperation using operator *
         Type: int_const 100000000
         Source: "100 * (10**6)"
        Literal, token: [no token] value: 100
           Type: int_const 100
           Source: "100"
        TupleExpression
           Type: int_const 1000000
           Source: "(10**6)"
          BinaryOperation using operator **
             Type: int_const 1000000
             Source: "10**6"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
            Literal, token: [no token] value: 6
               Type: int_const 6
               Source: "6"
      BinaryOperation using operator **
         Type: uint256
         Source: "10**decimals"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Identifier decimals
           Type: uint256
           Source: "decimals"
  VariableDeclaration "preSaleBlockNumber"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant preSaleBlockNumber = 169457"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 169457
       Type: int_const 169457
       Source: "169457"
  VariableDeclaration "finalBlockNumber"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public finalBlockNumber =370711"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 370711
       Type: int_const 370711
       Source: "370711"
  EventDefinition "CreatePPC"
     Gas costs: 0
     Source: "event CreatePPC(address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Mint"
     Gas costs: 0
     Source: "event Mint(address indexed _to,uint256 _value);"
    ParameterList
       Source: "(address indexed _to,uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "PPCToken" - public
     Source: "function PPCToken(){\r\n      emergencyFlag = false;                             // False at initialization will be false during ICO\r\n      fundingStartBlock = block.number;                 //  Current deploying block number is the starting block number for ICO\r\n      fundingEndBlock=safeAdd(fundingStartBlock,finalBlockNumber);  //   Ending time depending upon the block number\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n      emergencyFlag = false;                             // False at initialization will be false during ICO\r\n      fundingStartBlock = block.number;                 //  Current deploying block number is the starting block number for ICO\r\n      fundingEndBlock=safeAdd(fundingStartBlock,finalBlockNumber);  //   Ending time depending upon the block number\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "emergencyFlag = false"
        Assignment using operator =
           Type: bool
           Source: "emergencyFlag = false"
          Identifier emergencyFlag
             Type: bool
             Source: "emergencyFlag"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 0
         Source: "fundingStartBlock = block.number"
        Assignment using operator =
           Type: uint256
           Source: "fundingStartBlock = block.number"
          Identifier fundingStartBlock
             Type: uint256
             Source: "fundingStartBlock"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
      ExpressionStatement
         Gas costs: 0
         Source: "fundingEndBlock=safeAdd(fundingStartBlock,finalBlockNumber)"
        Assignment using operator =
           Type: uint256
           Source: "fundingEndBlock=safeAdd(fundingStartBlock,finalBlockNumber)"
          Identifier fundingEndBlock
             Type: uint256
             Source: "fundingEndBlock"
          FunctionCall
             Type: uint256
             Source: "safeAdd(fundingStartBlock,finalBlockNumber)"
            Identifier safeAdd
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeAdd"
            Identifier fundingStartBlock
               Type: uint256
               Source: "fundingStartBlock"
            Identifier finalBlockNumber
               Type: uint256
               Source: "finalBlockNumber"
  FunctionDefinition "createTokens"
     Source: "function createTokens() internal  {\r\n      if (emergencyFlag) revert();                     //  Revert when the sale is over before time and emergencyFlag is true.\r\n      if (block.number > fundingEndBlock) revert();   //   If the blocknumber exceed the ending block it will revert\r\n      if (msg.value<minTokenPurchaseAmount)revert();  //    If someone send 0.08 ether it will fail\r\n      uint256 tokenExchangeRate=tokenRate();        //     It will get value depending upon block number and presale cap\r\n      uint256 tokens = safeMult(msg.value, tokenExchangeRate);//  Calculating number of token for sender\r\n      totalSupply = safeAdd(totalSupply, tokens);            //   Add token to total supply\r\n      if(totalSupply>tokenCreationCap)revert();             //    Check the total supply if it is more then hardcap it will throw\r\n      balances[msg.sender] += tokens;                      //     Adding token to sender account\r\n      forwardfunds();                                     //      forwardfunds to the owner\r\n      CreatePPC(msg.sender, tokens);                      //      Logs sender address and  token creation\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n      if (emergencyFlag) revert();                     //  Revert when the sale is over before time and emergencyFlag is true.\r\n      if (block.number > fundingEndBlock) revert();   //   If the blocknumber exceed the ending block it will revert\r\n      if (msg.value<minTokenPurchaseAmount)revert();  //    If someone send 0.08 ether it will fail\r\n      uint256 tokenExchangeRate=tokenRate();        //     It will get value depending upon block number and presale cap\r\n      uint256 tokens = safeMult(msg.value, tokenExchangeRate);//  Calculating number of token for sender\r\n      totalSupply = safeAdd(totalSupply, tokens);            //   Add token to total supply\r\n      if(totalSupply>tokenCreationCap)revert();             //    Check the total supply if it is more then hardcap it will throw\r\n      balances[msg.sender] += tokens;                      //     Adding token to sender account\r\n      forwardfunds();                                     //      forwardfunds to the owner\r\n      CreatePPC(msg.sender, tokens);                      //      Logs sender address and  token creation\r\n    }"
      IfStatement
         Source: "if (emergencyFlag) revert()"
        Identifier emergencyFlag
           Type: bool
           Gas costs: 239
           Source: "emergencyFlag"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      IfStatement
         Source: "if (block.number > fundingEndBlock) revert()"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 208
           Source: "block.number > fundingEndBlock"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          Identifier fundingEndBlock
             Type: uint256
             Source: "fundingEndBlock"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      IfStatement
         Source: "if (msg.value<minTokenPurchaseAmount)revert()"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 5
           Source: "msg.value<minTokenPurchaseAmount"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier minTokenPurchaseAmount
             Type: uint256
             Source: "minTokenPurchaseAmount"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      VariableDeclarationStatement
         Gas costs: 12
         Source: "uint256 tokenExchangeRate=tokenRate()"
        VariableDeclaration "tokenExchangeRate"
           Type: uint256
           Source: "uint256 tokenExchangeRate"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "tokenRate()"
          Identifier tokenRate
             Type: function () returns (uint256)
             Source: "tokenRate"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 tokens = safeMult(msg.value, tokenExchangeRate)"
        VariableDeclaration "tokens"
           Type: uint256
           Source: "uint256 tokens"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "safeMult(msg.value, tokenExchangeRate)"
          Identifier safeMult
             Type: function (uint256,uint256) returns (uint256)
             Source: "safeMult"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier tokenExchangeRate
             Type: uint256
             Source: "tokenExchangeRate"
      ExpressionStatement
         Gas costs: 20232
         Source: "totalSupply = safeAdd(totalSupply, tokens)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = safeAdd(totalSupply, tokens)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "safeAdd(totalSupply, tokens)"
            Identifier safeAdd
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeAdd"
            Identifier totalSupply
               Type: uint256
               Source: "totalSupply"
            Identifier tokens
               Type: uint256
               Source: "tokens"
      IfStatement
         Source: "if(totalSupply>tokenCreationCap)revert()"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 206
           Source: "totalSupply>tokenCreationCap"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier tokenCreationCap
             Type: uint256
             Source: "tokenCreationCap"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 20328
         Source: "balances[msg.sender] += tokens"
        Assignment using operator +=
           Type: uint256
           Source: "balances[msg.sender] += tokens"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: 4
         Source: "forwardfunds()"
        FunctionCall
           Type: tuple()
           Source: "forwardfunds()"
          Identifier forwardfunds
             Type: function ()
             Source: "forwardfunds"
      ExpressionStatement
         Gas costs: [???]
         Source: "CreatePPC(msg.sender, tokens)"
        FunctionCall
           Type: tuple()
           Source: "CreatePPC(msg.sender, tokens)"
          Identifier CreatePPC
             Type: function (address,uint256)
             Source: "CreatePPC"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier tokens
             Type: uint256
             Source: "tokens"
  FunctionDefinition "buyToken" - public
     Source: "function buyToken() payable external{\r\n      createTokens();   // This will call the internal createToken function to get token\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n      createTokens();   // This will call the internal createToken function to get token\r\n    }"
      ExpressionStatement
         Gas costs: 15
         Source: "createTokens()"
        FunctionCall
           Type: tuple()
           Source: "createTokens()"
          Identifier createTokens
             Type: function ()
             Source: "createTokens"
  FunctionDefinition "tokenRate"
     Source: "function tokenRate() internal returns (uint256 _tokenPrice){\r\n      // It is a presale it will return price for presale\r\n      if(block.number<safeAdd(fundingStartBlock,preSaleBlockNumber)&&(totalSupply<tokenCreationPreSaleCap)){\r\n          return tokenPreSaleRate;\r\n        }else\r\n            return tokenCrowdsaleRate;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256 _tokenPrice)"
      VariableDeclaration "_tokenPrice"
         Type: uint256
         Source: "uint256 _tokenPrice"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      // It is a presale it will return price for presale\r\n      if(block.number<safeAdd(fundingStartBlock,preSaleBlockNumber)&&(totalSupply<tokenCreationPreSaleCap)){\r\n          return tokenPreSaleRate;\r\n        }else\r\n            return tokenCrowdsaleRate;\r\n    }"
      IfStatement
         Source: "if(block.number<safeAdd(fundingStartBlock,preSaleBlockNumber)&&(totalSupply<tokenCreationPreSaleCap)){\r\n          return tokenPreSaleRate;\r\n        }else\r\n            return tokenCrowdsaleRate"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 440
           Source: "block.number<safeAdd(fundingStartBlock,preSaleBlockNumber)&&(totalSupply<tokenCreationPreSaleCap)"
          BinaryOperation using operator <
             Type: bool
             Source: "block.number<safeAdd(fundingStartBlock,preSaleBlockNumber)"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            FunctionCall
               Type: uint256
               Source: "safeAdd(fundingStartBlock,preSaleBlockNumber)"
              Identifier safeAdd
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "safeAdd"
              Identifier fundingStartBlock
                 Type: uint256
                 Source: "fundingStartBlock"
              Identifier preSaleBlockNumber
                 Type: uint256
                 Source: "preSaleBlockNumber"
          TupleExpression
             Type: bool
             Source: "(totalSupply<tokenCreationPreSaleCap)"
            BinaryOperation using operator <
               Type: bool
               Source: "totalSupply<tokenCreationPreSaleCap"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
              Identifier tokenCreationPreSaleCap
                 Type: uint256
                 Source: "tokenCreationPreSaleCap"
        Block
           Source: "{\r\n          return tokenPreSaleRate;\r\n        }"
          Return
             Gas costs: 16
             Source: "return tokenPreSaleRate"
            Identifier tokenPreSaleRate
               Type: uint256
               Source: "tokenPreSaleRate"
        Return
           Gas costs: 5
           Source: "return tokenCrowdsaleRate"
          Identifier tokenCrowdsaleRate
             Type: uint256
             Source: "tokenCrowdsaleRate"
  FunctionDefinition "mint" - public
     Source: "function mint(address _to, uint256 _amount) external onlyOwner returns (bool) {\r\n      if (emergencyFlag) revert();\r\n      totalSupply = safeAdd(totalSupply,_amount);// Add the minted token to total suppy\r\n      if(totalSupply>tokenCreationCap)revert();\r\n      balances[_to] +=_amount;                 //   Adding token to the input address\r\n      Mint(_to, _amount);                     //    Log the mint with address and token given to particular address\r\n      return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _amount)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n      if (emergencyFlag) revert();\r\n      totalSupply = safeAdd(totalSupply,_amount);// Add the minted token to total suppy\r\n      if(totalSupply>tokenCreationCap)revert();\r\n      balances[_to] +=_amount;                 //   Adding token to the input address\r\n      Mint(_to, _amount);                     //    Log the mint with address and token given to particular address\r\n      return true;\r\n    }"
      IfStatement
         Source: "if (emergencyFlag) revert()"
        Identifier emergencyFlag
           Type: bool
           Gas costs: 239
           Source: "emergencyFlag"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 20232
         Source: "totalSupply = safeAdd(totalSupply,_amount)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = safeAdd(totalSupply,_amount)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "safeAdd(totalSupply,_amount)"
            Identifier safeAdd
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeAdd"
            Identifier totalSupply
               Type: uint256
               Source: "totalSupply"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      IfStatement
         Source: "if(totalSupply>tokenCreationCap)revert()"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 206
           Source: "totalSupply>tokenCreationCap"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier tokenCreationCap
             Type: uint256
             Source: "tokenCreationCap"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[_to] +=_amount"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] +=_amount"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Mint(_to, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Mint(_to, _amount)"
          Identifier Mint
             Type: function (address,uint256)
             Source: "Mint"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "changeEndBlock" - public
     Source: "function changeEndBlock(uint256 _newBlock) external onlyOwner returns (uint256 _endblock )\r\n    {   // we are expecting that owner will input number greater than current block.\r\n        require(_newBlock > fundingStartBlock);\r\n        fundingEndBlock = _newBlock;         // New block is assigned to extend the Crowd Sale time\r\n        return fundingEndBlock;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _newBlock)"
      VariableDeclaration "_newBlock"
         Type: uint256
         Source: "uint256 _newBlock"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 _endblock )"
      VariableDeclaration "_endblock"
         Type: uint256
         Source: "uint256 _endblock"
        ElementaryTypeName uint256
           Source: "uint256"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{   // we are expecting that owner will input number greater than current block.\r\n        require(_newBlock > fundingStartBlock);\r\n        fundingEndBlock = _newBlock;         // New block is assigned to extend the Crowd Sale time\r\n        return fundingEndBlock;\r\n    }"
      ExpressionStatement
         Gas costs: 235
         Source: "require(_newBlock > fundingStartBlock)"
        FunctionCall
           Type: tuple()
           Source: "require(_newBlock > fundingStartBlock)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "_newBlock > fundingStartBlock"
            Identifier _newBlock
               Type: uint256
               Source: "_newBlock"
            Identifier fundingStartBlock
               Type: uint256
               Source: "fundingStartBlock"
      ExpressionStatement
         Gas costs: 20014
         Source: "fundingEndBlock = _newBlock"
        Assignment using operator =
           Type: uint256
           Source: "fundingEndBlock = _newBlock"
          Identifier fundingEndBlock
             Type: uint256
             Source: "fundingEndBlock"
          Identifier _newBlock
             Type: uint256
             Source: "_newBlock"
      Return
         Gas costs: 208
         Source: "return fundingEndBlock"
        Identifier fundingEndBlock
           Type: uint256
           Source: "fundingEndBlock"
  FunctionDefinition "drain" - public
     Source: "function drain() external onlyOwner {\r\n        if (!ethFundDeposit.send(this.balance)) revert();// It will revert if transfer fails.\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        if (!ethFundDeposit.send(this.balance)) revert();// It will revert if transfer fails.\r\n    }"
      IfStatement
         Source: "if (!ethFundDeposit.send(this.balance)) revert()"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!ethFundDeposit.send(this.balance)"
          FunctionCall
             Type: bool
             Source: "ethFundDeposit.send(this.balance)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "ethFundDeposit.send"
              Identifier ethFundDeposit
                 Type: address
                 Source: "ethFundDeposit"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract PPCToken
                 Source: "this"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
  FunctionDefinition "forwardfunds"
     Source: "function forwardfunds() internal {\r\n         if (!ethFundDeposit.send(this.balance)) revert(); // It will revert if transfer fails.\r\n        \r\n        \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n         if (!ethFundDeposit.send(this.balance)) revert(); // It will revert if transfer fails.\r\n        \r\n        \r\n    }"
      IfStatement
         Source: "if (!ethFundDeposit.send(this.balance)) revert()"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!ethFundDeposit.send(this.balance)"
          FunctionCall
             Type: bool
             Source: "ethFundDeposit.send(this.balance)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "ethFundDeposit.send"
              Identifier ethFundDeposit
                 Type: address
                 Source: "ethFundDeposit"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract PPCToken
                 Source: "this"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
  FunctionDefinition "emergencyToggle" - public
     Source: "function emergencyToggle() external onlyOwner{\r\n      emergencyFlag = !emergencyFlag;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n      emergencyFlag = !emergencyFlag;\r\n    }"
      ExpressionStatement
         Gas costs: 20506
         Source: "emergencyFlag = !emergencyFlag"
        Assignment using operator =
           Type: bool
           Source: "emergencyFlag = !emergencyFlag"
          Identifier emergencyFlag
             Type: bool
             Source: "emergencyFlag"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!emergencyFlag"
            Identifier emergencyFlag
               Type: bool
               Source: "emergencyFlag"
  FunctionDefinition "" - public
     Source: "function() payable {\r\n      createTokens();\r\n\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n      createTokens();\r\n\r\n    }"
      ExpressionStatement
         Gas costs: 4
         Source: "createTokens()"
        FunctionCall
           Type: tuple()
           Source: "createTokens()"
          Identifier createTokens
             Type: function ()
             Source: "createTokens"
