Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x351d76b3367ba296f8fce864abcdf49969db4f20.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.18;"
ContractDefinition "BurnableToken"
   Gas costs: 0
   Source: "interface BurnableToken {\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool);\r\n    function burnFrom(address _from, uint256 _value) public returns (bool);\r\n}"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value) public returns (bool);"
    ParameterList
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "burnFrom" - public
     Source: "function burnFrom(address _from, uint256 _value) public returns (bool);"
    ParameterList
       Source: "(address _from, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
ContractDefinition "ERC20"
   Gas costs: 0
   Source: "interface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() public view returns (uint supply);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint supply)"
      VariableDeclaration "supply"
         Type: uint256
         Source: "uint supply"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public view returns (uint balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint balance"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value) public returns (bool success);"
    ParameterList
       Source: "(address _to, uint _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value) public returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint _value) public returns (bool success);"
    ParameterList
       Source: "(address _spender, uint _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public view returns (uint remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint remaining"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "decimals" - public - const
     Source: "function decimals() public view returns(uint digits);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint digits)"
      VariableDeclaration "digits"
         Type: uint256
         Source: "uint digits"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "SanityRatesInterface"
   Gas costs: 0
   Source: "interface SanityRatesInterface {\r\n    function getSanityRate(ERC20 src, ERC20 dest) public view returns(uint);\r\n}"
  FunctionDefinition "getSanityRate" - public - const
     Source: "function getSanityRate(ERC20 src, ERC20 dest) public view returns(uint);"
    ParameterList
       Source: "(ERC20 src, ERC20 dest)"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "Utils"
   Source: "contract Utils {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 1B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}"
  VariableDeclaration "ETH_TOKEN_ADDRESS"
     Type: contract ERC20
     Gas costs: 3
     Source: "ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee)"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
    FunctionCall
       Type: contract ERC20
       Source: "ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee)"
      Identifier ERC20
         Type: type(contract ERC20)
         Source: "ERC20"
      Literal, token: [no token] value: 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
         Type: int_const 1364...(41 digits omitted)...0110
         Source: "0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
  VariableDeclaration "PRECISION"
     Type: uint256
     Gas costs: 0
     Source: "uint  constant internal PRECISION = (10**18)"
    ElementaryTypeName uint
       Source: "uint"
    TupleExpression
       Type: int_const 1000000000000000000
       Source: "(10**18)"
      BinaryOperation using operator **
         Type: int_const 1000000000000000000
         Source: "10**18"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Literal, token: [no token] value: 18
           Type: int_const 18
           Source: "18"
  VariableDeclaration "MAX_QTY"
     Type: uint256
     Gas costs: 0
     Source: "uint  constant internal MAX_QTY   = (10**28)"
    ElementaryTypeName uint
       Source: "uint"
    TupleExpression
       Type: int_const 10000000000000000000000000000
       Source: "(10**28)"
      BinaryOperation using operator **
         Type: int_const 10000000000000000000000000000
         Source: "10**28"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Literal, token: [no token] value: 28
           Type: int_const 28
           Source: "28"
  VariableDeclaration "MAX_RATE"
     Type: uint256
     Gas costs: 0
     Source: "uint  constant internal MAX_RATE  = (PRECISION * 10**6)"
    ElementaryTypeName uint
       Source: "uint"
    TupleExpression
       Type: uint256
       Source: "(PRECISION * 10**6)"
      BinaryOperation using operator *
         Type: uint256
         Source: "PRECISION * 10**6"
        Identifier PRECISION
           Type: uint256
           Source: "PRECISION"
        BinaryOperation using operator **
           Type: int_const 1000000
           Source: "10**6"
          Literal, token: [no token] value: 10
             Type: int_const 10
             Source: "10"
          Literal, token: [no token] value: 6
             Type: int_const 6
             Source: "6"
  VariableDeclaration "MAX_DECIMALS"
     Type: uint256
     Gas costs: 0
     Source: "uint  constant internal MAX_DECIMALS = 18"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  FunctionDefinition "calcDstQty"
     Source: "function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate)"
      VariableDeclaration "srcQty"
         Type: uint256
         Source: "uint srcQty"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "srcDecimals"
         Type: uint256
         Source: "uint srcDecimals"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "dstDecimals"
         Type: uint256
         Source: "uint dstDecimals"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "rate"
         Type: uint256
         Source: "uint rate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }"
      IfStatement
         Source: "if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 0
           Source: "dstDecimals >= srcDecimals"
          Identifier dstDecimals
             Type: uint256
             Source: "dstDecimals"
          Identifier srcDecimals
             Type: uint256
             Source: "srcDecimals"
        Block
           Source: "{\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require((dstDecimals - srcDecimals) <= MAX_DECIMALS)"
            FunctionCall
               Type: tuple()
               Source: "require((dstDecimals - srcDecimals) <= MAX_DECIMALS)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "(dstDecimals - srcDecimals) <= MAX_DECIMALS"
                TupleExpression
                   Type: uint256
                   Source: "(dstDecimals - srcDecimals)"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "dstDecimals - srcDecimals"
                    Identifier dstDecimals
                       Type: uint256
                       Source: "dstDecimals"
                    Identifier srcDecimals
                       Type: uint256
                       Source: "srcDecimals"
                Identifier MAX_DECIMALS
                   Type: uint256
                   Source: "MAX_DECIMALS"
          Return
             Gas costs: 0
             Source: "return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION"
            BinaryOperation using operator /
               Type: uint256
               Source: "(srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION"
              TupleExpression
                 Type: uint256
                 Source: "(srcQty * rate * (10**(dstDecimals - srcDecimals)))"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "srcQty * rate * (10**(dstDecimals - srcDecimals))"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "srcQty * rate"
                    Identifier srcQty
                       Type: uint256
                       Source: "srcQty"
                    Identifier rate
                       Type: uint256
                       Source: "rate"
                  TupleExpression
                     Type: uint256
                     Source: "(10**(dstDecimals - srcDecimals))"
                    BinaryOperation using operator **
                       Type: uint256
                       Source: "10**(dstDecimals - srcDecimals)"
                      Literal, token: [no token] value: 10
                         Type: int_const 10
                         Source: "10"
                      TupleExpression
                         Type: uint256
                         Source: "(dstDecimals - srcDecimals)"
                        BinaryOperation using operator -
                           Type: uint256
                           Source: "dstDecimals - srcDecimals"
                          Identifier dstDecimals
                             Type: uint256
                             Source: "dstDecimals"
                          Identifier srcDecimals
                             Type: uint256
                             Source: "srcDecimals"
              Identifier PRECISION
                 Type: uint256
                 Source: "PRECISION"
        Block
           Source: "{\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require((srcDecimals - dstDecimals) <= MAX_DECIMALS)"
            FunctionCall
               Type: tuple()
               Source: "require((srcDecimals - dstDecimals) <= MAX_DECIMALS)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "(srcDecimals - dstDecimals) <= MAX_DECIMALS"
                TupleExpression
                   Type: uint256
                   Source: "(srcDecimals - dstDecimals)"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "srcDecimals - dstDecimals"
                    Identifier srcDecimals
                       Type: uint256
                       Source: "srcDecimals"
                    Identifier dstDecimals
                       Type: uint256
                       Source: "dstDecimals"
                Identifier MAX_DECIMALS
                   Type: uint256
                   Source: "MAX_DECIMALS"
          Return
             Gas costs: 0
             Source: "return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)))"
            BinaryOperation using operator /
               Type: uint256
               Source: "(srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)))"
              TupleExpression
                 Type: uint256
                 Source: "(srcQty * rate)"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "srcQty * rate"
                  Identifier srcQty
                     Type: uint256
                     Source: "srcQty"
                  Identifier rate
                     Type: uint256
                     Source: "rate"
              TupleExpression
                 Type: uint256
                 Source: "(PRECISION * (10**(srcDecimals - dstDecimals)))"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "PRECISION * (10**(srcDecimals - dstDecimals))"
                  Identifier PRECISION
                     Type: uint256
                     Source: "PRECISION"
                  TupleExpression
                     Type: uint256
                     Source: "(10**(srcDecimals - dstDecimals))"
                    BinaryOperation using operator **
                       Type: uint256
                       Source: "10**(srcDecimals - dstDecimals)"
                      Literal, token: [no token] value: 10
                         Type: int_const 10
                         Source: "10"
                      TupleExpression
                         Type: uint256
                         Source: "(srcDecimals - dstDecimals)"
                        BinaryOperation using operator -
                           Type: uint256
                           Source: "srcDecimals - dstDecimals"
                          Identifier srcDecimals
                             Type: uint256
                             Source: "srcDecimals"
                          Identifier dstDecimals
                             Type: uint256
                             Source: "dstDecimals"
  FunctionDefinition "calcSrcQty"
     Source: "function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate)"
      VariableDeclaration "dstQty"
         Type: uint256
         Source: "uint dstQty"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "srcDecimals"
         Type: uint256
         Source: "uint srcDecimals"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "dstDecimals"
         Type: uint256
         Source: "uint dstDecimals"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "rate"
         Type: uint256
         Source: "uint rate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint numerator"
        VariableDeclaration "numerator"
           Type: uint256
           Source: "uint numerator"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint denominator"
        VariableDeclaration "denominator"
           Type: uint256
           Source: "uint denominator"
          ElementaryTypeName uint
             Source: "uint"
      IfStatement
         Source: "if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 0
           Source: "srcDecimals >= dstDecimals"
          Identifier srcDecimals
             Type: uint256
             Source: "srcDecimals"
          Identifier dstDecimals
             Type: uint256
             Source: "dstDecimals"
        Block
           Source: "{\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require((srcDecimals - dstDecimals) <= MAX_DECIMALS)"
            FunctionCall
               Type: tuple()
               Source: "require((srcDecimals - dstDecimals) <= MAX_DECIMALS)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "(srcDecimals - dstDecimals) <= MAX_DECIMALS"
                TupleExpression
                   Type: uint256
                   Source: "(srcDecimals - dstDecimals)"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "srcDecimals - dstDecimals"
                    Identifier srcDecimals
                       Type: uint256
                       Source: "srcDecimals"
                    Identifier dstDecimals
                       Type: uint256
                       Source: "dstDecimals"
                Identifier MAX_DECIMALS
                   Type: uint256
                   Source: "MAX_DECIMALS"
          ExpressionStatement
             Gas costs: 0
             Source: "numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)))"
            Assignment using operator =
               Type: uint256
               Source: "numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)))"
              Identifier numerator
                 Type: uint256
                 Source: "numerator"
              TupleExpression
                 Type: uint256
                 Source: "(PRECISION * dstQty * (10**(srcDecimals - dstDecimals)))"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "PRECISION * dstQty * (10**(srcDecimals - dstDecimals))"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "PRECISION * dstQty"
                    Identifier PRECISION
                       Type: uint256
                       Source: "PRECISION"
                    Identifier dstQty
                       Type: uint256
                       Source: "dstQty"
                  TupleExpression
                     Type: uint256
                     Source: "(10**(srcDecimals - dstDecimals))"
                    BinaryOperation using operator **
                       Type: uint256
                       Source: "10**(srcDecimals - dstDecimals)"
                      Literal, token: [no token] value: 10
                         Type: int_const 10
                         Source: "10"
                      TupleExpression
                         Type: uint256
                         Source: "(srcDecimals - dstDecimals)"
                        BinaryOperation using operator -
                           Type: uint256
                           Source: "srcDecimals - dstDecimals"
                          Identifier srcDecimals
                             Type: uint256
                             Source: "srcDecimals"
                          Identifier dstDecimals
                             Type: uint256
                             Source: "dstDecimals"
          ExpressionStatement
             Gas costs: 0
             Source: "denominator = rate"
            Assignment using operator =
               Type: uint256
               Source: "denominator = rate"
              Identifier denominator
                 Type: uint256
                 Source: "denominator"
              Identifier rate
                 Type: uint256
                 Source: "rate"
        Block
           Source: "{\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require((dstDecimals - srcDecimals) <= MAX_DECIMALS)"
            FunctionCall
               Type: tuple()
               Source: "require((dstDecimals - srcDecimals) <= MAX_DECIMALS)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "(dstDecimals - srcDecimals) <= MAX_DECIMALS"
                TupleExpression
                   Type: uint256
                   Source: "(dstDecimals - srcDecimals)"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "dstDecimals - srcDecimals"
                    Identifier dstDecimals
                       Type: uint256
                       Source: "dstDecimals"
                    Identifier srcDecimals
                       Type: uint256
                       Source: "srcDecimals"
                Identifier MAX_DECIMALS
                   Type: uint256
                   Source: "MAX_DECIMALS"
          ExpressionStatement
             Gas costs: 0
             Source: "numerator = (PRECISION * dstQty)"
            Assignment using operator =
               Type: uint256
               Source: "numerator = (PRECISION * dstQty)"
              Identifier numerator
                 Type: uint256
                 Source: "numerator"
              TupleExpression
                 Type: uint256
                 Source: "(PRECISION * dstQty)"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "PRECISION * dstQty"
                  Identifier PRECISION
                     Type: uint256
                     Source: "PRECISION"
                  Identifier dstQty
                     Type: uint256
                     Source: "dstQty"
          ExpressionStatement
             Gas costs: 0
             Source: "denominator = (rate * (10**(dstDecimals - srcDecimals)))"
            Assignment using operator =
               Type: uint256
               Source: "denominator = (rate * (10**(dstDecimals - srcDecimals)))"
              Identifier denominator
                 Type: uint256
                 Source: "denominator"
              TupleExpression
                 Type: uint256
                 Source: "(rate * (10**(dstDecimals - srcDecimals)))"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "rate * (10**(dstDecimals - srcDecimals))"
                  Identifier rate
                     Type: uint256
                     Source: "rate"
                  TupleExpression
                     Type: uint256
                     Source: "(10**(dstDecimals - srcDecimals))"
                    BinaryOperation using operator **
                       Type: uint256
                       Source: "10**(dstDecimals - srcDecimals)"
                      Literal, token: [no token] value: 10
                         Type: int_const 10
                         Source: "10"
                      TupleExpression
                         Type: uint256
                         Source: "(dstDecimals - srcDecimals)"
                        BinaryOperation using operator -
                           Type: uint256
                           Source: "dstDecimals - srcDecimals"
                          Identifier dstDecimals
                             Type: uint256
                             Source: "dstDecimals"
                          Identifier srcDecimals
                             Type: uint256
                             Source: "srcDecimals"
      Return
         Gas costs: 0
         Source: "return (numerator + denominator - 1) / denominator"
        BinaryOperation using operator /
           Type: uint256
           Source: "(numerator + denominator - 1) / denominator"
          TupleExpression
             Type: uint256
             Source: "(numerator + denominator - 1)"
            BinaryOperation using operator -
               Type: uint256
               Source: "numerator + denominator - 1"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "numerator + denominator"
                Identifier numerator
                   Type: uint256
                   Source: "numerator"
                Identifier denominator
                   Type: uint256
                   Source: "denominator"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          Identifier denominator
             Type: uint256
             Source: "denominator"
ContractDefinition "FeeBurnerInterface"
   Gas costs: 0
   Source: "interface FeeBurnerInterface {\r\n    function handleFees (uint tradeWeiAmount, address reserve, address wallet) public returns(bool);\r\n}"
  FunctionDefinition "handleFees" - public
     Source: "function handleFees (uint tradeWeiAmount, address reserve, address wallet) public returns(bool);"
    ParameterList
       Source: "(uint tradeWeiAmount, address reserve, address wallet)"
      VariableDeclaration "tradeWeiAmount"
         Type: uint256
         Source: "uint tradeWeiAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "reserve"
         Type: address
         Source: "address reserve"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "wallet"
         Type: address
         Source: "address wallet"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
ContractDefinition "ExpectedRateInterface"
   Gas costs: 0
   Source: "interface ExpectedRateInterface {\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\r\n        returns (uint expectedRate, uint slippageRate);\r\n}"
  FunctionDefinition "getExpectedRate" - public - const
     Source: "function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\r\n        returns (uint expectedRate, uint slippageRate);"
    ParameterList
       Source: "(ERC20 src, ERC20 dest, uint srcQty)"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "srcQty"
         Type: uint256
         Source: "uint srcQty"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint expectedRate, uint slippageRate)"
      VariableDeclaration "expectedRate"
         Type: uint256
         Source: "uint expectedRate"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "slippageRate"
         Type: uint256
         Source: "uint slippageRate"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "PermissionGroups"
   Source: "contract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=>bool) internal operators;\r\n    mapping(address=>bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n\r\n    function PermissionGroups() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters () external view returns(address[]) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event AlerterAdded (address newAlerter, bool isAdd);\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
  VariableDeclaration "admin"
     Type: address
     Gas costs: 0
     Source: "address public admin"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "pendingAdmin"
     Type: address
     Gas costs: 0
     Source: "address public pendingAdmin"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "operators"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping(address=>bool) internal operators"
    Mapping
       Source: "mapping(address=>bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "alerters"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping(address=>bool) internal alerters"
    Mapping
       Source: "mapping(address=>bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "operatorsGroup"
     Type: address[] storage ref
     Gas costs: 0
     Source: "address[] internal operatorsGroup"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "alertersGroup"
     Type: address[] storage ref
     Gas costs: 0
     Source: "address[] internal alertersGroup"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  FunctionDefinition "PermissionGroups" - public
     Source: "function PermissionGroups() public {\r\n        admin = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        admin = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "admin = msg.sender"
        Assignment using operator =
           Type: address
           Source: "admin = msg.sender"
          Identifier admin
             Type: address
             Source: "admin"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyAdmin"
     Source: "modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(msg.sender == admin);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.sender == admin)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == admin)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == admin"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier admin
               Type: address
               Source: "admin"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyOperator"
     Source: "modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(operators[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(operators[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          IndexAccess
             Type: bool
             Source: "operators[msg.sender]"
            Identifier operators
               Type: mapping(address => bool)
               Source: "operators"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyAlerter"
     Source: "modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(alerters[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(alerters[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          IndexAccess
             Type: bool
             Source: "alerters[msg.sender]"
            Identifier alerters
               Type: mapping(address => bool)
               Source: "alerters"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "getOperators" - public - const
     Source: "function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address[])"
      VariableDeclaration ""
         Type: address[] memory
         Source: "address[]"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\r\n        return operatorsGroup;\r\n    }"
      Return
         Gas costs: 0
         Source: "return operatorsGroup"
        Identifier operatorsGroup
           Type: address[] storage ref
           Source: "operatorsGroup"
  FunctionDefinition "getAlerters" - public - const
     Source: "function getAlerters () external view returns(address[]) {\r\n        return alertersGroup;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address[])"
      VariableDeclaration ""
         Type: address[] memory
         Source: "address[]"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\r\n        return alertersGroup;\r\n    }"
      Return
         Gas costs: 0
         Source: "return alertersGroup"
        Identifier alertersGroup
           Type: address[] storage ref
           Source: "alertersGroup"
  EventDefinition "TransferAdminPending"
     Gas costs: 0
     Source: "event TransferAdminPending(address pendingAdmin);"
    ParameterList
       Source: "(address pendingAdmin)"
      VariableDeclaration "pendingAdmin"
         Type: address
         Source: "address pendingAdmin"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "transferAdmin" - public
     Source: "function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address newAdmin)"
      VariableDeclaration "newAdmin"
         Type: address
         Source: "address newAdmin"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(newAdmin != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(newAdmin != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "newAdmin != address(0)"
            Identifier newAdmin
               Type: address
               Source: "newAdmin"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "TransferAdminPending(pendingAdmin)"
        FunctionCall
           Type: tuple()
           Source: "TransferAdminPending(pendingAdmin)"
          Identifier TransferAdminPending
             Type: function (address)
             Source: "TransferAdminPending"
          Identifier pendingAdmin
             Type: address
             Source: "pendingAdmin"
      ExpressionStatement
         Gas costs: 0
         Source: "pendingAdmin = newAdmin"
        Assignment using operator =
           Type: address
           Source: "pendingAdmin = newAdmin"
          Identifier pendingAdmin
             Type: address
             Source: "pendingAdmin"
          Identifier newAdmin
             Type: address
             Source: "newAdmin"
  EventDefinition "AdminClaimed"
     Gas costs: 0
     Source: "event AdminClaimed( address newAdmin, address previousAdmin);"
    ParameterList
       Source: "( address newAdmin, address previousAdmin)"
      VariableDeclaration "newAdmin"
         Type: address
         Source: "address newAdmin"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "previousAdmin"
         Type: address
         Source: "address previousAdmin"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "claimAdmin" - public
     Source: "function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(pendingAdmin == msg.sender);\r\n        AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(pendingAdmin == msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "require(pendingAdmin == msg.sender)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "pendingAdmin == msg.sender"
            Identifier pendingAdmin
               Type: address
               Source: "pendingAdmin"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "AdminClaimed(pendingAdmin, admin)"
        FunctionCall
           Type: tuple()
           Source: "AdminClaimed(pendingAdmin, admin)"
          Identifier AdminClaimed
             Type: function (address,address)
             Source: "AdminClaimed"
          Identifier pendingAdmin
             Type: address
             Source: "pendingAdmin"
          Identifier admin
             Type: address
             Source: "admin"
      ExpressionStatement
         Gas costs: 0
         Source: "admin = pendingAdmin"
        Assignment using operator =
           Type: address
           Source: "admin = pendingAdmin"
          Identifier admin
             Type: address
             Source: "admin"
          Identifier pendingAdmin
             Type: address
             Source: "pendingAdmin"
      ExpressionStatement
         Gas costs: 0
         Source: "pendingAdmin = address(0)"
        Assignment using operator =
           Type: address
           Source: "pendingAdmin = address(0)"
          Identifier pendingAdmin
             Type: address
             Source: "pendingAdmin"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  EventDefinition "AlerterAdded"
     Gas costs: 0
     Source: "event AlerterAdded (address newAlerter, bool isAdd);"
    ParameterList
       Source: "(address newAlerter, bool isAdd)"
      VariableDeclaration "newAlerter"
         Type: address
         Source: "address newAlerter"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "isAdd"
         Type: bool
         Source: "bool isAdd"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "addAlerter" - public
     Source: "function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address newAlerter)"
      VariableDeclaration "newAlerter"
         Type: address
         Source: "address newAlerter"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!alerters[newAlerter])"
        FunctionCall
           Type: tuple()
           Source: "require(!alerters[newAlerter])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!alerters[newAlerter]"
            IndexAccess
               Type: bool
               Source: "alerters[newAlerter]"
              Identifier alerters
                 Type: mapping(address => bool)
                 Source: "alerters"
              Identifier newAlerter
                 Type: address
                 Source: "newAlerter"
      ExpressionStatement
         Gas costs: 0
         Source: "AlerterAdded(newAlerter, true)"
        FunctionCall
           Type: tuple()
           Source: "AlerterAdded(newAlerter, true)"
          Identifier AlerterAdded
             Type: function (address,bool)
             Source: "AlerterAdded"
          Identifier newAlerter
             Type: address
             Source: "newAlerter"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "alerters[newAlerter] = true"
        Assignment using operator =
           Type: bool
           Source: "alerters[newAlerter] = true"
          IndexAccess
             Type: bool
             Source: "alerters[newAlerter]"
            Identifier alerters
               Type: mapping(address => bool)
               Source: "alerters"
            Identifier newAlerter
               Type: address
               Source: "newAlerter"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "alertersGroup.push(newAlerter)"
        FunctionCall
           Type: uint256
           Source: "alertersGroup.push(newAlerter)"
          MemberAccess to member push
             Type: function (address) returns (uint256)
             Source: "alertersGroup.push"
            Identifier alertersGroup
               Type: address[] storage ref
               Source: "alertersGroup"
          Identifier newAlerter
             Type: address
             Source: "newAlerter"
  FunctionDefinition "removeAlerter" - public
     Source: "function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address alerter)"
      VariableDeclaration "alerter"
         Type: address
         Source: "address alerter"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(alerters[alerter])"
        FunctionCall
           Type: tuple()
           Source: "require(alerters[alerter])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          IndexAccess
             Type: bool
             Source: "alerters[alerter]"
            Identifier alerters
               Type: mapping(address => bool)
               Source: "alerters"
            Identifier alerter
               Type: address
               Source: "alerter"
      ExpressionStatement
         Gas costs: 0
         Source: "alerters[alerter] = false"
        Assignment using operator =
           Type: bool
           Source: "alerters[alerter] = false"
          IndexAccess
             Type: bool
             Source: "alerters[alerter]"
            Identifier alerters
               Type: mapping(address => bool)
               Source: "alerters"
            Identifier alerter
               Type: address
               Source: "alerter"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ForStatement
         Source: "for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < alertersGroup.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "alertersGroup.length"
            Identifier alertersGroup
               Type: address[] storage ref
               Source: "alertersGroup"
        ExpressionStatement
           Gas costs: 0
           Source: "++i"
          UnaryOperation (prefix) ++
             Type: uint256
             Source: "++i"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }"
          IfStatement
             Source: "if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "alertersGroup[i] == alerter"
              IndexAccess
                 Type: address
                 Source: "alertersGroup[i]"
                Identifier alertersGroup
                   Type: address[] storage ref
                   Source: "alertersGroup"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier alerter
                 Type: address
                 Source: "alerter"
            Block
               Source: "{\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "alertersGroup[i] = alertersGroup[alertersGroup.length - 1]"
                Assignment using operator =
                   Type: address
                   Source: "alertersGroup[i] = alertersGroup[alertersGroup.length - 1]"
                  IndexAccess
                     Type: address
                     Source: "alertersGroup[i]"
                    Identifier alertersGroup
                       Type: address[] storage ref
                       Source: "alertersGroup"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  IndexAccess
                     Type: address
                     Source: "alertersGroup[alertersGroup.length - 1]"
                    Identifier alertersGroup
                       Type: address[] storage ref
                       Source: "alertersGroup"
                    BinaryOperation using operator -
                       Type: uint256
                       Source: "alertersGroup.length - 1"
                      MemberAccess to member length
                         Type: uint256
                         Source: "alertersGroup.length"
                        Identifier alertersGroup
                           Type: address[] storage ref
                           Source: "alertersGroup"
                      Literal, token: [no token] value: 1
                         Type: int_const 1
                         Source: "1"
              ExpressionStatement
                 Gas costs: 0
                 Source: "alertersGroup.length--"
                UnaryOperation (postfix) --
                   Type: uint256
                   Source: "alertersGroup.length--"
                  MemberAccess to member length
                     Type: uint256
                     Source: "alertersGroup.length"
                    Identifier alertersGroup
                       Type: address[] storage ref
                       Source: "alertersGroup"
              ExpressionStatement
                 Gas costs: 0
                 Source: "AlerterAdded(alerter, false)"
                FunctionCall
                   Type: tuple()
                   Source: "AlerterAdded(alerter, false)"
                  Identifier AlerterAdded
                     Type: function (address,bool)
                     Source: "AlerterAdded"
                  Identifier alerter
                     Type: address
                     Source: "alerter"
                  Literal, token: false value: false
                     Type: bool
                     Source: "false"
              Break
                 Gas costs: 0
                 Source: "break"
  EventDefinition "OperatorAdded"
     Gas costs: 0
     Source: "event OperatorAdded(address newOperator, bool isAdd);"
    ParameterList
       Source: "(address newOperator, bool isAdd)"
      VariableDeclaration "newOperator"
         Type: address
         Source: "address newOperator"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "isAdd"
         Type: bool
         Source: "bool isAdd"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "addOperator" - public
     Source: "function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address newOperator)"
      VariableDeclaration "newOperator"
         Type: address
         Source: "address newOperator"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!operators[newOperator])"
        FunctionCall
           Type: tuple()
           Source: "require(!operators[newOperator])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!operators[newOperator]"
            IndexAccess
               Type: bool
               Source: "operators[newOperator]"
              Identifier operators
                 Type: mapping(address => bool)
                 Source: "operators"
              Identifier newOperator
                 Type: address
                 Source: "newOperator"
      ExpressionStatement
         Gas costs: 0
         Source: "OperatorAdded(newOperator, true)"
        FunctionCall
           Type: tuple()
           Source: "OperatorAdded(newOperator, true)"
          Identifier OperatorAdded
             Type: function (address,bool)
             Source: "OperatorAdded"
          Identifier newOperator
             Type: address
             Source: "newOperator"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "operators[newOperator] = true"
        Assignment using operator =
           Type: bool
           Source: "operators[newOperator] = true"
          IndexAccess
             Type: bool
             Source: "operators[newOperator]"
            Identifier operators
               Type: mapping(address => bool)
               Source: "operators"
            Identifier newOperator
               Type: address
               Source: "newOperator"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "operatorsGroup.push(newOperator)"
        FunctionCall
           Type: uint256
           Source: "operatorsGroup.push(newOperator)"
          MemberAccess to member push
             Type: function (address) returns (uint256)
             Source: "operatorsGroup.push"
            Identifier operatorsGroup
               Type: address[] storage ref
               Source: "operatorsGroup"
          Identifier newOperator
             Type: address
             Source: "newOperator"
  FunctionDefinition "removeOperator" - public
     Source: "function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address operator)"
      VariableDeclaration "operator"
         Type: address
         Source: "address operator"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(operators[operator])"
        FunctionCall
           Type: tuple()
           Source: "require(operators[operator])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          IndexAccess
             Type: bool
             Source: "operators[operator]"
            Identifier operators
               Type: mapping(address => bool)
               Source: "operators"
            Identifier operator
               Type: address
               Source: "operator"
      ExpressionStatement
         Gas costs: 0
         Source: "operators[operator] = false"
        Assignment using operator =
           Type: bool
           Source: "operators[operator] = false"
          IndexAccess
             Type: bool
             Source: "operators[operator]"
            Identifier operators
               Type: mapping(address => bool)
               Source: "operators"
            Identifier operator
               Type: address
               Source: "operator"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ForStatement
         Source: "for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < operatorsGroup.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "operatorsGroup.length"
            Identifier operatorsGroup
               Type: address[] storage ref
               Source: "operatorsGroup"
        ExpressionStatement
           Gas costs: 0
           Source: "++i"
          UnaryOperation (prefix) ++
             Type: uint256
             Source: "++i"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }"
          IfStatement
             Source: "if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "operatorsGroup[i] == operator"
              IndexAccess
                 Type: address
                 Source: "operatorsGroup[i]"
                Identifier operatorsGroup
                   Type: address[] storage ref
                   Source: "operatorsGroup"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier operator
                 Type: address
                 Source: "operator"
            Block
               Source: "{\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1]"
                Assignment using operator =
                   Type: address
                   Source: "operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1]"
                  IndexAccess
                     Type: address
                     Source: "operatorsGroup[i]"
                    Identifier operatorsGroup
                       Type: address[] storage ref
                       Source: "operatorsGroup"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  IndexAccess
                     Type: address
                     Source: "operatorsGroup[operatorsGroup.length - 1]"
                    Identifier operatorsGroup
                       Type: address[] storage ref
                       Source: "operatorsGroup"
                    BinaryOperation using operator -
                       Type: uint256
                       Source: "operatorsGroup.length - 1"
                      MemberAccess to member length
                         Type: uint256
                         Source: "operatorsGroup.length"
                        Identifier operatorsGroup
                           Type: address[] storage ref
                           Source: "operatorsGroup"
                      Literal, token: [no token] value: 1
                         Type: int_const 1
                         Source: "1"
              ExpressionStatement
                 Gas costs: 0
                 Source: "operatorsGroup.length -= 1"
                Assignment using operator -=
                   Type: uint256
                   Source: "operatorsGroup.length -= 1"
                  MemberAccess to member length
                     Type: uint256
                     Source: "operatorsGroup.length"
                    Identifier operatorsGroup
                       Type: address[] storage ref
                       Source: "operatorsGroup"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              ExpressionStatement
                 Gas costs: 0
                 Source: "OperatorAdded(operator, false)"
                FunctionCall
                   Type: tuple()
                   Source: "OperatorAdded(operator, false)"
                  Identifier OperatorAdded
                     Type: function (address,bool)
                     Source: "OperatorAdded"
                  Identifier operator
                     Type: address
                     Source: "operator"
                  Literal, token: false value: false
                     Type: bool
                     Source: "false"
              Break
                 Gas costs: 0
                 Source: "break"
ContractDefinition "Withdrawable"
   Source: "contract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        EtherWithdraw(amount, sendTo);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "PermissionGroups"
    UserDefinedTypeName "PermissionGroups"
       Source: "PermissionGroups"
  EventDefinition "TokenWithdraw"
     Gas costs: 0
     Source: "event TokenWithdraw(ERC20 token, uint amount, address sendTo);"
    ParameterList
       Source: "(ERC20 token, uint amount, address sendTo)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "sendTo"
         Type: address
         Source: "address sendTo"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "withdrawToken" - public
     Source: "function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        TokenWithdraw(token, amount, sendTo);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token, uint amount, address sendTo)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "sendTo"
         Type: address
         Source: "address sendTo"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        require(token.transfer(sendTo, amount));\r\n        TokenWithdraw(token, amount, sendTo);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(token.transfer(sendTo, amount))"
        FunctionCall
           Type: tuple()
           Source: "require(token.transfer(sendTo, amount))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "token.transfer(sendTo, amount)"
            MemberAccess to member transfer
               Type: function (address,uint256) external returns (bool)
               Source: "token.transfer"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
            Identifier sendTo
               Type: address
               Source: "sendTo"
            Identifier amount
               Type: uint256
               Source: "amount"
      ExpressionStatement
         Gas costs: 0
         Source: "TokenWithdraw(token, amount, sendTo)"
        FunctionCall
           Type: tuple()
           Source: "TokenWithdraw(token, amount, sendTo)"
          Identifier TokenWithdraw
             Type: function (contract ERC20,uint256,address)
             Source: "TokenWithdraw"
          Identifier token
             Type: contract ERC20
             Source: "token"
          Identifier amount
             Type: uint256
             Source: "amount"
          Identifier sendTo
             Type: address
             Source: "sendTo"
  EventDefinition "EtherWithdraw"
     Gas costs: 0
     Source: "event EtherWithdraw(uint amount, address sendTo);"
    ParameterList
       Source: "(uint amount, address sendTo)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "sendTo"
         Type: address
         Source: "address sendTo"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "withdrawEther" - public
     Source: "function withdrawEther(uint amount, address sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        EtherWithdraw(amount, sendTo);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint amount, address sendTo)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "sendTo"
         Type: address
         Source: "address sendTo"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        sendTo.transfer(amount);\r\n        EtherWithdraw(amount, sendTo);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "sendTo.transfer(amount)"
        FunctionCall
           Type: tuple()
           Source: "sendTo.transfer(amount)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "sendTo.transfer"
            Identifier sendTo
               Type: address
               Source: "sendTo"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Gas costs: 0
         Source: "EtherWithdraw(amount, sendTo)"
        FunctionCall
           Type: tuple()
           Source: "EtherWithdraw(amount, sendTo)"
          Identifier EtherWithdraw
             Type: function (uint256,address)
             Source: "EtherWithdraw"
          Identifier amount
             Type: uint256
             Source: "amount"
          Identifier sendTo
             Type: address
             Source: "sendTo"
ContractDefinition "ExpectedRate"
   Source: "contract ExpectedRate is Withdrawable, ExpectedRateInterface {\r\n\r\n    KyberNetwork internal kyberNetwork;\r\n    uint public quantityFactor = 2;\r\n    uint public minSlippageFactorInBps = 50;\r\n\r\n    function ExpectedRate(KyberNetwork _kyberNetwork, address _admin) public {\r\n        require(_admin != address(0));\r\n        require(_kyberNetwork != address(0));\r\n        kyberNetwork = _kyberNetwork;\r\n        admin = _admin;\r\n    }\r\n\r\n    event QuantityFactorSet (uint newFactor, uint oldFactor, address sender);\r\n\r\n    function setQuantityFactor(uint newFactor) public onlyOperator {\r\n        QuantityFactorSet(quantityFactor, newFactor, msg.sender);\r\n        quantityFactor = newFactor;\r\n    }\r\n\r\n    event MinSlippageFactorSet (uint newMin, uint oldMin, address sender);\r\n\r\n    function setMinSlippageFactor(uint bps) public onlyOperator {\r\n        MinSlippageFactorSet(bps, minSlippageFactorInBps, msg.sender);\r\n        minSlippageFactorInBps = bps;\r\n    }\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\r\n        public view\r\n        returns (uint expectedRate, uint slippageRate)\r\n    {\r\n        require(quantityFactor != 0);\r\n\r\n        uint bestReserve;\r\n        uint minSlippage;\r\n\r\n        (bestReserve, expectedRate) = kyberNetwork.findBestRate(src, dest, srcQty);\r\n        (bestReserve, slippageRate) = kyberNetwork.findBestRate(src, dest, (srcQty * quantityFactor));\r\n\r\n        minSlippage = ((10000 - minSlippageFactorInBps) * expectedRate) / 10000;\r\n        if (slippageRate >= minSlippage) {\r\n            slippageRate = minSlippage;\r\n        }\r\n\r\n        return (expectedRate, slippageRate);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Withdrawable"
    UserDefinedTypeName "Withdrawable"
       Source: "Withdrawable"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ExpectedRateInterface"
    UserDefinedTypeName "ExpectedRateInterface"
       Source: "ExpectedRateInterface"
  VariableDeclaration "kyberNetwork"
     Type: contract KyberNetwork
     Gas costs: 0
     Source: "KyberNetwork internal kyberNetwork"
    UserDefinedTypeName "KyberNetwork"
       Source: "KyberNetwork"
  VariableDeclaration "quantityFactor"
     Type: uint256
     Gas costs: 0
     Source: "uint public quantityFactor = 2"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 2
       Type: int_const 2
       Source: "2"
  VariableDeclaration "minSlippageFactorInBps"
     Type: uint256
     Gas costs: 0
     Source: "uint public minSlippageFactorInBps = 50"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 50
       Type: int_const 50
       Source: "50"
  FunctionDefinition "ExpectedRate" - public
     Source: "function ExpectedRate(KyberNetwork _kyberNetwork, address _admin) public {\r\n        require(_admin != address(0));\r\n        require(_kyberNetwork != address(0));\r\n        kyberNetwork = _kyberNetwork;\r\n        admin = _admin;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(KyberNetwork _kyberNetwork, address _admin)"
      VariableDeclaration "_kyberNetwork"
         Type: contract KyberNetwork
         Source: "KyberNetwork _kyberNetwork"
        UserDefinedTypeName "KyberNetwork"
           Source: "KyberNetwork"
      VariableDeclaration "_admin"
         Type: address
         Source: "address _admin"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(_admin != address(0));\r\n        require(_kyberNetwork != address(0));\r\n        kyberNetwork = _kyberNetwork;\r\n        admin = _admin;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_admin != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_admin != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_admin != address(0)"
            Identifier _admin
               Type: address
               Source: "_admin"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_kyberNetwork != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_kyberNetwork != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_kyberNetwork != address(0)"
            Identifier _kyberNetwork
               Type: contract KyberNetwork
               Source: "_kyberNetwork"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "kyberNetwork = _kyberNetwork"
        Assignment using operator =
           Type: contract KyberNetwork
           Source: "kyberNetwork = _kyberNetwork"
          Identifier kyberNetwork
             Type: contract KyberNetwork
             Source: "kyberNetwork"
          Identifier _kyberNetwork
             Type: contract KyberNetwork
             Source: "_kyberNetwork"
      ExpressionStatement
         Gas costs: 0
         Source: "admin = _admin"
        Assignment using operator =
           Type: address
           Source: "admin = _admin"
          Identifier admin
             Type: address
             Source: "admin"
          Identifier _admin
             Type: address
             Source: "_admin"
  EventDefinition "QuantityFactorSet"
     Gas costs: 0
     Source: "event QuantityFactorSet (uint newFactor, uint oldFactor, address sender);"
    ParameterList
       Source: "(uint newFactor, uint oldFactor, address sender)"
      VariableDeclaration "newFactor"
         Type: uint256
         Source: "uint newFactor"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "oldFactor"
         Type: uint256
         Source: "uint oldFactor"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "setQuantityFactor" - public
     Source: "function setQuantityFactor(uint newFactor) public onlyOperator {\r\n        QuantityFactorSet(quantityFactor, newFactor, msg.sender);\r\n        quantityFactor = newFactor;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint newFactor)"
      VariableDeclaration "newFactor"
         Type: uint256
         Source: "uint newFactor"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOperator"
       Gas costs: 0
       Source: "onlyOperator"
      Identifier onlyOperator
         Type: modifier ()
         Source: "onlyOperator"
    Block
       Source: "{\r\n        QuantityFactorSet(quantityFactor, newFactor, msg.sender);\r\n        quantityFactor = newFactor;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "QuantityFactorSet(quantityFactor, newFactor, msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "QuantityFactorSet(quantityFactor, newFactor, msg.sender)"
          Identifier QuantityFactorSet
             Type: function (uint256,uint256,address)
             Source: "QuantityFactorSet"
          Identifier quantityFactor
             Type: uint256
             Source: "quantityFactor"
          Identifier newFactor
             Type: uint256
             Source: "newFactor"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "quantityFactor = newFactor"
        Assignment using operator =
           Type: uint256
           Source: "quantityFactor = newFactor"
          Identifier quantityFactor
             Type: uint256
             Source: "quantityFactor"
          Identifier newFactor
             Type: uint256
             Source: "newFactor"
  EventDefinition "MinSlippageFactorSet"
     Gas costs: 0
     Source: "event MinSlippageFactorSet (uint newMin, uint oldMin, address sender);"
    ParameterList
       Source: "(uint newMin, uint oldMin, address sender)"
      VariableDeclaration "newMin"
         Type: uint256
         Source: "uint newMin"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "oldMin"
         Type: uint256
         Source: "uint oldMin"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "setMinSlippageFactor" - public
     Source: "function setMinSlippageFactor(uint bps) public onlyOperator {\r\n        MinSlippageFactorSet(bps, minSlippageFactorInBps, msg.sender);\r\n        minSlippageFactorInBps = bps;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint bps)"
      VariableDeclaration "bps"
         Type: uint256
         Source: "uint bps"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOperator"
       Gas costs: 0
       Source: "onlyOperator"
      Identifier onlyOperator
         Type: modifier ()
         Source: "onlyOperator"
    Block
       Source: "{\r\n        MinSlippageFactorSet(bps, minSlippageFactorInBps, msg.sender);\r\n        minSlippageFactorInBps = bps;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "MinSlippageFactorSet(bps, minSlippageFactorInBps, msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "MinSlippageFactorSet(bps, minSlippageFactorInBps, msg.sender)"
          Identifier MinSlippageFactorSet
             Type: function (uint256,uint256,address)
             Source: "MinSlippageFactorSet"
          Identifier bps
             Type: uint256
             Source: "bps"
          Identifier minSlippageFactorInBps
             Type: uint256
             Source: "minSlippageFactorInBps"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "minSlippageFactorInBps = bps"
        Assignment using operator =
           Type: uint256
           Source: "minSlippageFactorInBps = bps"
          Identifier minSlippageFactorInBps
             Type: uint256
             Source: "minSlippageFactorInBps"
          Identifier bps
             Type: uint256
             Source: "bps"
  FunctionDefinition "getExpectedRate" - public - const
     Source: "function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\r\n        public view\r\n        returns (uint expectedRate, uint slippageRate)\r\n    {\r\n        require(quantityFactor != 0);\r\n\r\n        uint bestReserve;\r\n        uint minSlippage;\r\n\r\n        (bestReserve, expectedRate) = kyberNetwork.findBestRate(src, dest, srcQty);\r\n        (bestReserve, slippageRate) = kyberNetwork.findBestRate(src, dest, (srcQty * quantityFactor));\r\n\r\n        minSlippage = ((10000 - minSlippageFactorInBps) * expectedRate) / 10000;\r\n        if (slippageRate >= minSlippage) {\r\n            slippageRate = minSlippage;\r\n        }\r\n\r\n        return (expectedRate, slippageRate);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 src, ERC20 dest, uint srcQty)"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "srcQty"
         Type: uint256
         Source: "uint srcQty"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint expectedRate, uint slippageRate)"
      VariableDeclaration "expectedRate"
         Type: uint256
         Source: "uint expectedRate"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "slippageRate"
         Type: uint256
         Source: "uint slippageRate"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(quantityFactor != 0);\r\n\r\n        uint bestReserve;\r\n        uint minSlippage;\r\n\r\n        (bestReserve, expectedRate) = kyberNetwork.findBestRate(src, dest, srcQty);\r\n        (bestReserve, slippageRate) = kyberNetwork.findBestRate(src, dest, (srcQty * quantityFactor));\r\n\r\n        minSlippage = ((10000 - minSlippageFactorInBps) * expectedRate) / 10000;\r\n        if (slippageRate >= minSlippage) {\r\n            slippageRate = minSlippage;\r\n        }\r\n\r\n        return (expectedRate, slippageRate);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(quantityFactor != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(quantityFactor != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "quantityFactor != 0"
            Identifier quantityFactor
               Type: uint256
               Source: "quantityFactor"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint bestReserve"
        VariableDeclaration "bestReserve"
           Type: uint256
           Source: "uint bestReserve"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint minSlippage"
        VariableDeclaration "minSlippage"
           Type: uint256
           Source: "uint minSlippage"
          ElementaryTypeName uint
             Source: "uint"
      ExpressionStatement
         Gas costs: 0
         Source: "(bestReserve, expectedRate) = kyberNetwork.findBestRate(src, dest, srcQty)"
        Assignment using operator =
           Type: tuple()
           Source: "(bestReserve, expectedRate) = kyberNetwork.findBestRate(src, dest, srcQty)"
          TupleExpression
             Type: tuple(uint256,uint256)
             Source: "(bestReserve, expectedRate)"
            Identifier bestReserve
               Type: uint256
               Source: "bestReserve"
            Identifier expectedRate
               Type: uint256
               Source: "expectedRate"
          FunctionCall
             Type: tuple(uint256,uint256)
             Source: "kyberNetwork.findBestRate(src, dest, srcQty)"
            MemberAccess to member findBestRate
               Type: function (contract ERC20,contract ERC20,uint256) view external returns (uint256,uint256)
               Source: "kyberNetwork.findBestRate"
              Identifier kyberNetwork
                 Type: contract KyberNetwork
                 Source: "kyberNetwork"
            Identifier src
               Type: contract ERC20
               Source: "src"
            Identifier dest
               Type: contract ERC20
               Source: "dest"
            Identifier srcQty
               Type: uint256
               Source: "srcQty"
      ExpressionStatement
         Gas costs: 0
         Source: "(bestReserve, slippageRate) = kyberNetwork.findBestRate(src, dest, (srcQty * quantityFactor))"
        Assignment using operator =
           Type: tuple()
           Source: "(bestReserve, slippageRate) = kyberNetwork.findBestRate(src, dest, (srcQty * quantityFactor))"
          TupleExpression
             Type: tuple(uint256,uint256)
             Source: "(bestReserve, slippageRate)"
            Identifier bestReserve
               Type: uint256
               Source: "bestReserve"
            Identifier slippageRate
               Type: uint256
               Source: "slippageRate"
          FunctionCall
             Type: tuple(uint256,uint256)
             Source: "kyberNetwork.findBestRate(src, dest, (srcQty * quantityFactor))"
            MemberAccess to member findBestRate
               Type: function (contract ERC20,contract ERC20,uint256) view external returns (uint256,uint256)
               Source: "kyberNetwork.findBestRate"
              Identifier kyberNetwork
                 Type: contract KyberNetwork
                 Source: "kyberNetwork"
            Identifier src
               Type: contract ERC20
               Source: "src"
            Identifier dest
               Type: contract ERC20
               Source: "dest"
            TupleExpression
               Type: uint256
               Source: "(srcQty * quantityFactor)"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "srcQty * quantityFactor"
                Identifier srcQty
                   Type: uint256
                   Source: "srcQty"
                Identifier quantityFactor
                   Type: uint256
                   Source: "quantityFactor"
      ExpressionStatement
         Gas costs: 0
         Source: "minSlippage = ((10000 - minSlippageFactorInBps) * expectedRate) / 10000"
        Assignment using operator =
           Type: uint256
           Source: "minSlippage = ((10000 - minSlippageFactorInBps) * expectedRate) / 10000"
          Identifier minSlippage
             Type: uint256
             Source: "minSlippage"
          BinaryOperation using operator /
             Type: uint256
             Source: "((10000 - minSlippageFactorInBps) * expectedRate) / 10000"
            TupleExpression
               Type: uint256
               Source: "((10000 - minSlippageFactorInBps) * expectedRate)"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "(10000 - minSlippageFactorInBps) * expectedRate"
                TupleExpression
                   Type: uint256
                   Source: "(10000 - minSlippageFactorInBps)"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "10000 - minSlippageFactorInBps"
                    Literal, token: [no token] value: 10000
                       Type: int_const 10000
                       Source: "10000"
                    Identifier minSlippageFactorInBps
                       Type: uint256
                       Source: "minSlippageFactorInBps"
                Identifier expectedRate
                   Type: uint256
                   Source: "expectedRate"
            Literal, token: [no token] value: 10000
               Type: int_const 10000
               Source: "10000"
      IfStatement
         Source: "if (slippageRate >= minSlippage) {\r\n            slippageRate = minSlippage;\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 0
           Source: "slippageRate >= minSlippage"
          Identifier slippageRate
             Type: uint256
             Source: "slippageRate"
          Identifier minSlippage
             Type: uint256
             Source: "minSlippage"
        Block
           Source: "{\r\n            slippageRate = minSlippage;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "slippageRate = minSlippage"
            Assignment using operator =
               Type: uint256
               Source: "slippageRate = minSlippage"
              Identifier slippageRate
                 Type: uint256
                 Source: "slippageRate"
              Identifier minSlippage
                 Type: uint256
                 Source: "minSlippage"
      Return
         Gas costs: 0
         Source: "return (expectedRate, slippageRate)"
        TupleExpression
           Type: tuple(uint256,uint256)
           Source: "(expectedRate, slippageRate)"
          Identifier expectedRate
             Type: uint256
             Source: "expectedRate"
          Identifier slippageRate
             Type: uint256
             Source: "slippageRate"
ContractDefinition "VolumeImbalanceRecorder"
   Source: "contract VolumeImbalanceRecorder is Withdrawable {\r\n\r\n    uint constant internal SLIDING_WINDOW_SIZE = 5;\r\n    uint constant internal POW_2_64 = 2 ** 64;\r\n\r\n    struct TokenControlInfo {\r\n        uint minimalRecordResolution; // can be roughly 1 cent\r\n        uint maxPerBlockImbalance; // in twei resolution\r\n        uint maxTotalImbalance; // max total imbalance (between rate updates)\r\n                            // before halting trade\r\n    }\r\n\r\n    mapping(address => TokenControlInfo) internal tokenControlInfo;\r\n\r\n    struct TokenImbalanceData {\r\n        int  lastBlockBuyUnitsImbalance;\r\n        uint lastBlock;\r\n\r\n        int  totalBuyUnitsImbalance;\r\n        uint lastRateUpdateBlock;\r\n    }\r\n\r\n    mapping(address => mapping(uint=>uint)) public tokenImbalanceData;\r\n\r\n    function VolumeImbalanceRecorder(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }\r\n\r\n    function setTokenControlInfo(\r\n        ERC20 token,\r\n        uint minimalRecordResolution,\r\n        uint maxPerBlockImbalance,\r\n        uint maxTotalImbalance\r\n    )\r\n        public\r\n        onlyAdmin\r\n    {\r\n        tokenControlInfo[token] =\r\n            TokenControlInfo(\r\n                minimalRecordResolution,\r\n                maxPerBlockImbalance,\r\n                maxTotalImbalance\r\n            );\r\n    }\r\n\r\n    function getTokenControlInfo(ERC20 token) public view returns(uint, uint, uint) {\r\n        return (tokenControlInfo[token].minimalRecordResolution,\r\n                tokenControlInfo[token].maxPerBlockImbalance,\r\n                tokenControlInfo[token].maxTotalImbalance);\r\n    }\r\n\r\n    function addImbalance(\r\n        ERC20 token,\r\n        int buyAmount,\r\n        uint rateUpdateBlock,\r\n        uint currentBlock\r\n    )\r\n        internal\r\n    {\r\n        uint currentBlockIndex = currentBlock % SLIDING_WINDOW_SIZE;\r\n        int recordedBuyAmount = int(buyAmount / int(tokenControlInfo[token].minimalRecordResolution));\r\n\r\n        int prevImbalance = 0;\r\n\r\n        TokenImbalanceData memory currentBlockData =\r\n            decodeTokenImbalanceData(tokenImbalanceData[token][currentBlockIndex]);\r\n\r\n        // first scenario - this is not the first tx in the current block\r\n        if (currentBlockData.lastBlock == currentBlock) {\r\n            if (uint(currentBlockData.lastRateUpdateBlock) == rateUpdateBlock) {\r\n                // just increase imbalance\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.totalBuyUnitsImbalance += recordedBuyAmount;\r\n            } else {\r\n                // imbalance was changed in the middle of the block\r\n                prevImbalance = getImbalanceInRange(token, rateUpdateBlock, currentBlock);\r\n                currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            }\r\n        } else {\r\n            // first tx in the current block\r\n            int currentBlockImbalance;\r\n            (prevImbalance, currentBlockImbalance) = getImbalanceSinceRateUpdate(token, rateUpdateBlock, currentBlock);\r\n\r\n            currentBlockData.lastBlockBuyUnitsImbalance = recordedBuyAmount;\r\n            currentBlockData.lastBlock = uint(currentBlock);\r\n            currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\r\n        }\r\n\r\n        tokenImbalanceData[token][currentBlockIndex] = encodeTokenImbalanceData(currentBlockData);\r\n    }\r\n\r\n    function setGarbageToVolumeRecorder(ERC20 token) internal {\r\n        for (uint i = 0; i < SLIDING_WINDOW_SIZE; i++) {\r\n            tokenImbalanceData[token][i] = 0x1;\r\n        }\r\n    }\r\n\r\n    function getImbalanceInRange(ERC20 token, uint startBlock, uint endBlock) internal view returns(int buyImbalance) {\r\n        // check the imbalance in the sliding window\r\n        require(startBlock <= endBlock);\r\n\r\n        buyImbalance = 0;\r\n\r\n        for (uint windowInd = 0; windowInd < SLIDING_WINDOW_SIZE; windowInd++) {\r\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\r\n\r\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\r\n                buyImbalance += int(perBlockData.lastBlockBuyUnitsImbalance);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getImbalanceSinceRateUpdate(ERC20 token, uint rateUpdateBlock, uint currentBlock)\r\n        internal view\r\n        returns(int buyImbalance, int currentBlockImbalance)\r\n    {\r\n        buyImbalance = 0;\r\n        currentBlockImbalance = 0;\r\n        uint latestBlock = 0;\r\n        int imbalanceInRange = 0;\r\n        uint startBlock = rateUpdateBlock;\r\n        uint endBlock = currentBlock;\r\n\r\n        for (uint windowInd = 0; windowInd < SLIDING_WINDOW_SIZE; windowInd++) {\r\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\r\n\r\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\r\n                imbalanceInRange += perBlockData.lastBlockBuyUnitsImbalance;\r\n            }\r\n\r\n            if (perBlockData.lastRateUpdateBlock != rateUpdateBlock) continue;\r\n            if (perBlockData.lastBlock < latestBlock) continue;\r\n\r\n            latestBlock = perBlockData.lastBlock;\r\n            buyImbalance = perBlockData.totalBuyUnitsImbalance;\r\n            if (uint(perBlockData.lastBlock) == currentBlock) {\r\n                currentBlockImbalance = perBlockData.lastBlockBuyUnitsImbalance;\r\n            }\r\n        }\r\n\r\n        if (buyImbalance == 0) {\r\n            buyImbalance = imbalanceInRange;\r\n        }\r\n    }\r\n\r\n    function getImbalance(ERC20 token, uint rateUpdateBlock, uint currentBlock)\r\n        internal view\r\n        returns(int totalImbalance, int currentBlockImbalance)\r\n    {\r\n\r\n        int resolution = int(tokenControlInfo[token].minimalRecordResolution);\r\n\r\n        (totalImbalance, currentBlockImbalance) =\r\n            getImbalanceSinceRateUpdate(\r\n                token,\r\n                rateUpdateBlock,\r\n                currentBlock);\r\n\r\n        totalImbalance *= resolution;\r\n        currentBlockImbalance *= resolution;\r\n    }\r\n\r\n    function getMaxPerBlockImbalance(ERC20 token) internal view returns(uint) {\r\n        return tokenControlInfo[token].maxPerBlockImbalance;\r\n    }\r\n\r\n    function getMaxTotalImbalance(ERC20 token) internal view returns(uint) {\r\n        return tokenControlInfo[token].maxTotalImbalance;\r\n    }\r\n\r\n    function encodeTokenImbalanceData(TokenImbalanceData data) internal pure returns(uint) {\r\n        // check for overflows\r\n        require(data.lastBlockBuyUnitsImbalance < int(POW_2_64 / 2));\r\n        require(data.lastBlockBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\r\n        require(data.lastBlock < POW_2_64);\r\n        require(data.totalBuyUnitsImbalance < int(POW_2_64 / 2));\r\n        require(data.totalBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\r\n        require(data.lastRateUpdateBlock < POW_2_64);\r\n\r\n        // do encoding\r\n        uint result = uint(data.lastBlockBuyUnitsImbalance) & (POW_2_64 - 1);\r\n        result |= data.lastBlock * POW_2_64;\r\n        result |= (uint(data.totalBuyUnitsImbalance) & (POW_2_64 - 1)) * POW_2_64 * POW_2_64;\r\n        result |= data.lastRateUpdateBlock * POW_2_64 * POW_2_64 * POW_2_64;\r\n\r\n        return result;\r\n    }\r\n\r\n    function decodeTokenImbalanceData(uint input) internal pure returns(TokenImbalanceData) {\r\n        TokenImbalanceData memory data;\r\n\r\n        data.lastBlockBuyUnitsImbalance = int(int64(input & (POW_2_64 - 1)));\r\n        data.lastBlock = uint(uint64((input / POW_2_64) & (POW_2_64 - 1)));\r\n        data.totalBuyUnitsImbalance = int(int64((input / (POW_2_64 * POW_2_64)) & (POW_2_64 - 1)));\r\n        data.lastRateUpdateBlock = uint(uint64((input / (POW_2_64 * POW_2_64 * POW_2_64))));\r\n\r\n        return data;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Withdrawable"
    UserDefinedTypeName "Withdrawable"
       Source: "Withdrawable"
  VariableDeclaration "SLIDING_WINDOW_SIZE"
     Type: uint256
     Gas costs: 0
     Source: "uint constant internal SLIDING_WINDOW_SIZE = 5"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 5
       Type: int_const 5
       Source: "5"
  VariableDeclaration "POW_2_64"
     Type: uint256
     Gas costs: 0
     Source: "uint constant internal POW_2_64 = 2 ** 64"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator **
       Type: int_const 18446744073709551616
       Source: "2 ** 64"
      Literal, token: [no token] value: 2
         Type: int_const 2
         Source: "2"
      Literal, token: [no token] value: 64
         Type: int_const 64
         Source: "64"
  StructDefinition "TokenControlInfo"
     Gas costs: 0
     Source: "struct TokenControlInfo {\r\n        uint minimalRecordResolution; // can be roughly 1 cent\r\n        uint maxPerBlockImbalance; // in twei resolution\r\n        uint maxTotalImbalance; // max total imbalance (between rate updates)\r\n                            // before halting trade\r\n    }"
    VariableDeclaration "minimalRecordResolution"
       Type: uint256
       Source: "uint minimalRecordResolution"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "maxPerBlockImbalance"
       Type: uint256
       Source: "uint maxPerBlockImbalance"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "maxTotalImbalance"
       Type: uint256
       Source: "uint maxTotalImbalance"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "tokenControlInfo"
     Type: mapping(address => struct VolumeImbalanceRecorder.TokenControlInfo storage ref)
     Gas costs: 0
     Source: "mapping(address => TokenControlInfo) internal tokenControlInfo"
    Mapping
       Source: "mapping(address => TokenControlInfo)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "TokenControlInfo"
         Source: "TokenControlInfo"
  StructDefinition "TokenImbalanceData"
     Gas costs: 0
     Source: "struct TokenImbalanceData {\r\n        int  lastBlockBuyUnitsImbalance;\r\n        uint lastBlock;\r\n\r\n        int  totalBuyUnitsImbalance;\r\n        uint lastRateUpdateBlock;\r\n    }"
    VariableDeclaration "lastBlockBuyUnitsImbalance"
       Type: int256
       Source: "int  lastBlockBuyUnitsImbalance"
      ElementaryTypeName int
         Source: "int"
    VariableDeclaration "lastBlock"
       Type: uint256
       Source: "uint lastBlock"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "totalBuyUnitsImbalance"
       Type: int256
       Source: "int  totalBuyUnitsImbalance"
      ElementaryTypeName int
         Source: "int"
    VariableDeclaration "lastRateUpdateBlock"
       Type: uint256
       Source: "uint lastRateUpdateBlock"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "tokenImbalanceData"
     Type: mapping(address => mapping(uint256 => uint256))
     Gas costs: 0
     Source: "mapping(address => mapping(uint=>uint)) public tokenImbalanceData"
    Mapping
       Source: "mapping(address => mapping(uint=>uint))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping(uint=>uint)"
        ElementaryTypeName uint
           Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "VolumeImbalanceRecorder" - public
     Source: "function VolumeImbalanceRecorder(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _admin)"
      VariableDeclaration "_admin"
         Type: address
         Source: "address _admin"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_admin != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_admin != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_admin != address(0)"
            Identifier _admin
               Type: address
               Source: "_admin"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "admin = _admin"
        Assignment using operator =
           Type: address
           Source: "admin = _admin"
          Identifier admin
             Type: address
             Source: "admin"
          Identifier _admin
             Type: address
             Source: "_admin"
  FunctionDefinition "setTokenControlInfo" - public
     Source: "function setTokenControlInfo(\r\n        ERC20 token,\r\n        uint minimalRecordResolution,\r\n        uint maxPerBlockImbalance,\r\n        uint maxTotalImbalance\r\n    )\r\n        public\r\n        onlyAdmin\r\n    {\r\n        tokenControlInfo[token] =\r\n            TokenControlInfo(\r\n                minimalRecordResolution,\r\n                maxPerBlockImbalance,\r\n                maxTotalImbalance\r\n            );\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        ERC20 token,\r\n        uint minimalRecordResolution,\r\n        uint maxPerBlockImbalance,\r\n        uint maxTotalImbalance\r\n    )"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "minimalRecordResolution"
         Type: uint256
         Source: "uint minimalRecordResolution"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "maxPerBlockImbalance"
         Type: uint256
         Source: "uint maxPerBlockImbalance"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "maxTotalImbalance"
         Type: uint256
         Source: "uint maxTotalImbalance"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        tokenControlInfo[token] =\r\n            TokenControlInfo(\r\n                minimalRecordResolution,\r\n                maxPerBlockImbalance,\r\n                maxTotalImbalance\r\n            );\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenControlInfo[token] =\r\n            TokenControlInfo(\r\n                minimalRecordResolution,\r\n                maxPerBlockImbalance,\r\n                maxTotalImbalance\r\n            )"
        Assignment using operator =
           Type: struct VolumeImbalanceRecorder.TokenControlInfo storage ref
           Source: "tokenControlInfo[token] =\r\n            TokenControlInfo(\r\n                minimalRecordResolution,\r\n                maxPerBlockImbalance,\r\n                maxTotalImbalance\r\n            )"
          IndexAccess
             Type: struct VolumeImbalanceRecorder.TokenControlInfo storage ref
             Source: "tokenControlInfo[token]"
            Identifier tokenControlInfo
               Type: mapping(address => struct VolumeImbalanceRecorder.TokenControlInfo storage ref)
               Source: "tokenControlInfo"
            Identifier token
               Type: contract ERC20
               Source: "token"
          FunctionCall
             Type: struct VolumeImbalanceRecorder.TokenControlInfo memory
             Source: "TokenControlInfo(\r\n                minimalRecordResolution,\r\n                maxPerBlockImbalance,\r\n                maxTotalImbalance\r\n            )"
            Identifier TokenControlInfo
               Type: type(struct VolumeImbalanceRecorder.TokenControlInfo storage pointer)
               Source: "TokenControlInfo"
            Identifier minimalRecordResolution
               Type: uint256
               Source: "minimalRecordResolution"
            Identifier maxPerBlockImbalance
               Type: uint256
               Source: "maxPerBlockImbalance"
            Identifier maxTotalImbalance
               Type: uint256
               Source: "maxTotalImbalance"
  FunctionDefinition "getTokenControlInfo" - public - const
     Source: "function getTokenControlInfo(ERC20 token) public view returns(uint, uint, uint) {\r\n        return (tokenControlInfo[token].minimalRecordResolution,\r\n                tokenControlInfo[token].maxPerBlockImbalance,\r\n                tokenControlInfo[token].maxTotalImbalance);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 0
       Source: "(uint, uint, uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return (tokenControlInfo[token].minimalRecordResolution,\r\n                tokenControlInfo[token].maxPerBlockImbalance,\r\n                tokenControlInfo[token].maxTotalImbalance);\r\n    }"
      Return
         Gas costs: 0
         Source: "return (tokenControlInfo[token].minimalRecordResolution,\r\n                tokenControlInfo[token].maxPerBlockImbalance,\r\n                tokenControlInfo[token].maxTotalImbalance)"
        TupleExpression
           Type: tuple(uint256,uint256,uint256)
           Source: "(tokenControlInfo[token].minimalRecordResolution,\r\n                tokenControlInfo[token].maxPerBlockImbalance,\r\n                tokenControlInfo[token].maxTotalImbalance)"
          MemberAccess to member minimalRecordResolution
             Type: uint256
             Source: "tokenControlInfo[token].minimalRecordResolution"
            IndexAccess
               Type: struct VolumeImbalanceRecorder.TokenControlInfo storage ref
               Source: "tokenControlInfo[token]"
              Identifier tokenControlInfo
                 Type: mapping(address => struct VolumeImbalanceRecorder.TokenControlInfo storage ref)
                 Source: "tokenControlInfo"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
          MemberAccess to member maxPerBlockImbalance
             Type: uint256
             Source: "tokenControlInfo[token].maxPerBlockImbalance"
            IndexAccess
               Type: struct VolumeImbalanceRecorder.TokenControlInfo storage ref
               Source: "tokenControlInfo[token]"
              Identifier tokenControlInfo
                 Type: mapping(address => struct VolumeImbalanceRecorder.TokenControlInfo storage ref)
                 Source: "tokenControlInfo"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
          MemberAccess to member maxTotalImbalance
             Type: uint256
             Source: "tokenControlInfo[token].maxTotalImbalance"
            IndexAccess
               Type: struct VolumeImbalanceRecorder.TokenControlInfo storage ref
               Source: "tokenControlInfo[token]"
              Identifier tokenControlInfo
                 Type: mapping(address => struct VolumeImbalanceRecorder.TokenControlInfo storage ref)
                 Source: "tokenControlInfo"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
  FunctionDefinition "addImbalance"
     Source: "function addImbalance(\r\n        ERC20 token,\r\n        int buyAmount,\r\n        uint rateUpdateBlock,\r\n        uint currentBlock\r\n    )\r\n        internal\r\n    {\r\n        uint currentBlockIndex = currentBlock % SLIDING_WINDOW_SIZE;\r\n        int recordedBuyAmount = int(buyAmount / int(tokenControlInfo[token].minimalRecordResolution));\r\n\r\n        int prevImbalance = 0;\r\n\r\n        TokenImbalanceData memory currentBlockData =\r\n            decodeTokenImbalanceData(tokenImbalanceData[token][currentBlockIndex]);\r\n\r\n        // first scenario - this is not the first tx in the current block\r\n        if (currentBlockData.lastBlock == currentBlock) {\r\n            if (uint(currentBlockData.lastRateUpdateBlock) == rateUpdateBlock) {\r\n                // just increase imbalance\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.totalBuyUnitsImbalance += recordedBuyAmount;\r\n            } else {\r\n                // imbalance was changed in the middle of the block\r\n                prevImbalance = getImbalanceInRange(token, rateUpdateBlock, currentBlock);\r\n                currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            }\r\n        } else {\r\n            // first tx in the current block\r\n            int currentBlockImbalance;\r\n            (prevImbalance, currentBlockImbalance) = getImbalanceSinceRateUpdate(token, rateUpdateBlock, currentBlock);\r\n\r\n            currentBlockData.lastBlockBuyUnitsImbalance = recordedBuyAmount;\r\n            currentBlockData.lastBlock = uint(currentBlock);\r\n            currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\r\n        }\r\n\r\n        tokenImbalanceData[token][currentBlockIndex] = encodeTokenImbalanceData(currentBlockData);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        ERC20 token,\r\n        int buyAmount,\r\n        uint rateUpdateBlock,\r\n        uint currentBlock\r\n    )"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "buyAmount"
         Type: int256
         Source: "int buyAmount"
        ElementaryTypeName int
           Source: "int"
      VariableDeclaration "rateUpdateBlock"
         Type: uint256
         Source: "uint rateUpdateBlock"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "currentBlock"
         Type: uint256
         Source: "uint currentBlock"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint currentBlockIndex = currentBlock % SLIDING_WINDOW_SIZE;\r\n        int recordedBuyAmount = int(buyAmount / int(tokenControlInfo[token].minimalRecordResolution));\r\n\r\n        int prevImbalance = 0;\r\n\r\n        TokenImbalanceData memory currentBlockData =\r\n            decodeTokenImbalanceData(tokenImbalanceData[token][currentBlockIndex]);\r\n\r\n        // first scenario - this is not the first tx in the current block\r\n        if (currentBlockData.lastBlock == currentBlock) {\r\n            if (uint(currentBlockData.lastRateUpdateBlock) == rateUpdateBlock) {\r\n                // just increase imbalance\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.totalBuyUnitsImbalance += recordedBuyAmount;\r\n            } else {\r\n                // imbalance was changed in the middle of the block\r\n                prevImbalance = getImbalanceInRange(token, rateUpdateBlock, currentBlock);\r\n                currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            }\r\n        } else {\r\n            // first tx in the current block\r\n            int currentBlockImbalance;\r\n            (prevImbalance, currentBlockImbalance) = getImbalanceSinceRateUpdate(token, rateUpdateBlock, currentBlock);\r\n\r\n            currentBlockData.lastBlockBuyUnitsImbalance = recordedBuyAmount;\r\n            currentBlockData.lastBlock = uint(currentBlock);\r\n            currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\r\n        }\r\n\r\n        tokenImbalanceData[token][currentBlockIndex] = encodeTokenImbalanceData(currentBlockData);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint currentBlockIndex = currentBlock % SLIDING_WINDOW_SIZE"
        VariableDeclaration "currentBlockIndex"
           Type: uint256
           Source: "uint currentBlockIndex"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator %
           Type: uint256
           Source: "currentBlock % SLIDING_WINDOW_SIZE"
          Identifier currentBlock
             Type: uint256
             Source: "currentBlock"
          Identifier SLIDING_WINDOW_SIZE
             Type: uint256
             Source: "SLIDING_WINDOW_SIZE"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "int recordedBuyAmount = int(buyAmount / int(tokenControlInfo[token].minimalRecordResolution))"
        VariableDeclaration "recordedBuyAmount"
           Type: int256
           Source: "int recordedBuyAmount"
          ElementaryTypeName int
             Source: "int"
        FunctionCall
           Type: int256
           Source: "int(buyAmount / int(tokenControlInfo[token].minimalRecordResolution))"
          ElementaryTypeNameExpression int
             Type: type(int256)
             Source: "int"
          BinaryOperation using operator /
             Type: int256
             Source: "buyAmount / int(tokenControlInfo[token].minimalRecordResolution)"
            Identifier buyAmount
               Type: int256
               Source: "buyAmount"
            FunctionCall
               Type: int256
               Source: "int(tokenControlInfo[token].minimalRecordResolution)"
              ElementaryTypeNameExpression int
                 Type: type(int256)
                 Source: "int"
              MemberAccess to member minimalRecordResolution
                 Type: uint256
                 Source: "tokenControlInfo[token].minimalRecordResolution"
                IndexAccess
                   Type: struct VolumeImbalanceRecorder.TokenControlInfo storage ref
                   Source: "tokenControlInfo[token]"
                  Identifier tokenControlInfo
                     Type: mapping(address => struct VolumeImbalanceRecorder.TokenControlInfo storage ref)
                     Source: "tokenControlInfo"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "int prevImbalance = 0"
        VariableDeclaration "prevImbalance"
           Type: int256
           Source: "int prevImbalance"
          ElementaryTypeName int
             Source: "int"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "TokenImbalanceData memory currentBlockData =\r\n            decodeTokenImbalanceData(tokenImbalanceData[token][currentBlockIndex])"
        VariableDeclaration "currentBlockData"
           Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
           Source: "TokenImbalanceData memory currentBlockData"
          UserDefinedTypeName "TokenImbalanceData"
             Source: "TokenImbalanceData"
        FunctionCall
           Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
           Source: "decodeTokenImbalanceData(tokenImbalanceData[token][currentBlockIndex])"
          Identifier decodeTokenImbalanceData
             Type: function (uint256) pure returns (struct VolumeImbalanceRecorder.TokenImbalanceData memory)
             Source: "decodeTokenImbalanceData"
          IndexAccess
             Type: uint256
             Source: "tokenImbalanceData[token][currentBlockIndex]"
            IndexAccess
               Type: mapping(uint256 => uint256)
               Source: "tokenImbalanceData[token]"
              Identifier tokenImbalanceData
                 Type: mapping(address => mapping(uint256 => uint256))
                 Source: "tokenImbalanceData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
            Identifier currentBlockIndex
               Type: uint256
               Source: "currentBlockIndex"
      IfStatement
         Source: "if (currentBlockData.lastBlock == currentBlock) {\r\n            if (uint(currentBlockData.lastRateUpdateBlock) == rateUpdateBlock) {\r\n                // just increase imbalance\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.totalBuyUnitsImbalance += recordedBuyAmount;\r\n            } else {\r\n                // imbalance was changed in the middle of the block\r\n                prevImbalance = getImbalanceInRange(token, rateUpdateBlock, currentBlock);\r\n                currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            }\r\n        } else {\r\n            // first tx in the current block\r\n            int currentBlockImbalance;\r\n            (prevImbalance, currentBlockImbalance) = getImbalanceSinceRateUpdate(token, rateUpdateBlock, currentBlock);\r\n\r\n            currentBlockData.lastBlockBuyUnitsImbalance = recordedBuyAmount;\r\n            currentBlockData.lastBlock = uint(currentBlock);\r\n            currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "currentBlockData.lastBlock == currentBlock"
          MemberAccess to member lastBlock
             Type: uint256
             Source: "currentBlockData.lastBlock"
            Identifier currentBlockData
               Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
               Source: "currentBlockData"
          Identifier currentBlock
             Type: uint256
             Source: "currentBlock"
        Block
           Source: "{\r\n            if (uint(currentBlockData.lastRateUpdateBlock) == rateUpdateBlock) {\r\n                // just increase imbalance\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.totalBuyUnitsImbalance += recordedBuyAmount;\r\n            } else {\r\n                // imbalance was changed in the middle of the block\r\n                prevImbalance = getImbalanceInRange(token, rateUpdateBlock, currentBlock);\r\n                currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            }\r\n        }"
          IfStatement
             Source: "if (uint(currentBlockData.lastRateUpdateBlock) == rateUpdateBlock) {\r\n                // just increase imbalance\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.totalBuyUnitsImbalance += recordedBuyAmount;\r\n            } else {\r\n                // imbalance was changed in the middle of the block\r\n                prevImbalance = getImbalanceInRange(token, rateUpdateBlock, currentBlock);\r\n                currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "uint(currentBlockData.lastRateUpdateBlock) == rateUpdateBlock"
              FunctionCall
                 Type: uint256
                 Source: "uint(currentBlockData.lastRateUpdateBlock)"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                MemberAccess to member lastRateUpdateBlock
                   Type: uint256
                   Source: "currentBlockData.lastRateUpdateBlock"
                  Identifier currentBlockData
                     Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                     Source: "currentBlockData"
              Identifier rateUpdateBlock
                 Type: uint256
                 Source: "rateUpdateBlock"
            Block
               Source: "{\r\n                // just increase imbalance\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.totalBuyUnitsImbalance += recordedBuyAmount;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount"
                Assignment using operator +=
                   Type: int256
                   Source: "currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount"
                  MemberAccess to member lastBlockBuyUnitsImbalance
                     Type: int256
                     Source: "currentBlockData.lastBlockBuyUnitsImbalance"
                    Identifier currentBlockData
                       Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                       Source: "currentBlockData"
                  Identifier recordedBuyAmount
                     Type: int256
                     Source: "recordedBuyAmount"
              ExpressionStatement
                 Gas costs: 0
                 Source: "currentBlockData.totalBuyUnitsImbalance += recordedBuyAmount"
                Assignment using operator +=
                   Type: int256
                   Source: "currentBlockData.totalBuyUnitsImbalance += recordedBuyAmount"
                  MemberAccess to member totalBuyUnitsImbalance
                     Type: int256
                     Source: "currentBlockData.totalBuyUnitsImbalance"
                    Identifier currentBlockData
                       Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                       Source: "currentBlockData"
                  Identifier recordedBuyAmount
                     Type: int256
                     Source: "recordedBuyAmount"
            Block
               Source: "{\r\n                // imbalance was changed in the middle of the block\r\n                prevImbalance = getImbalanceInRange(token, rateUpdateBlock, currentBlock);\r\n                currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "prevImbalance = getImbalanceInRange(token, rateUpdateBlock, currentBlock)"
                Assignment using operator =
                   Type: int256
                   Source: "prevImbalance = getImbalanceInRange(token, rateUpdateBlock, currentBlock)"
                  Identifier prevImbalance
                     Type: int256
                     Source: "prevImbalance"
                  FunctionCall
                     Type: int256
                     Source: "getImbalanceInRange(token, rateUpdateBlock, currentBlock)"
                    Identifier getImbalanceInRange
                       Type: function (contract ERC20,uint256,uint256) view returns (int256)
                       Source: "getImbalanceInRange"
                    Identifier token
                       Type: contract ERC20
                       Source: "token"
                    Identifier rateUpdateBlock
                       Type: uint256
                       Source: "rateUpdateBlock"
                    Identifier currentBlock
                       Type: uint256
                       Source: "currentBlock"
              ExpressionStatement
                 Gas costs: 0
                 Source: "currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount"
                Assignment using operator =
                   Type: int256
                   Source: "currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount"
                  MemberAccess to member totalBuyUnitsImbalance
                     Type: int256
                     Source: "currentBlockData.totalBuyUnitsImbalance"
                    Identifier currentBlockData
                       Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                       Source: "currentBlockData"
                  BinaryOperation using operator +
                     Type: int256
                     Source: "int(prevImbalance) + recordedBuyAmount"
                    FunctionCall
                       Type: int256
                       Source: "int(prevImbalance)"
                      ElementaryTypeNameExpression int
                         Type: type(int256)
                         Source: "int"
                      Identifier prevImbalance
                         Type: int256
                         Source: "prevImbalance"
                    Identifier recordedBuyAmount
                       Type: int256
                       Source: "recordedBuyAmount"
              ExpressionStatement
                 Gas costs: 0
                 Source: "currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount"
                Assignment using operator +=
                   Type: int256
                   Source: "currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount"
                  MemberAccess to member lastBlockBuyUnitsImbalance
                     Type: int256
                     Source: "currentBlockData.lastBlockBuyUnitsImbalance"
                    Identifier currentBlockData
                       Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                       Source: "currentBlockData"
                  Identifier recordedBuyAmount
                     Type: int256
                     Source: "recordedBuyAmount"
              ExpressionStatement
                 Gas costs: 0
                 Source: "currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock)"
                Assignment using operator =
                   Type: uint256
                   Source: "currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock)"
                  MemberAccess to member lastRateUpdateBlock
                     Type: uint256
                     Source: "currentBlockData.lastRateUpdateBlock"
                    Identifier currentBlockData
                       Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                       Source: "currentBlockData"
                  FunctionCall
                     Type: uint256
                     Source: "uint(rateUpdateBlock)"
                    ElementaryTypeNameExpression uint
                       Type: type(uint256)
                       Source: "uint"
                    Identifier rateUpdateBlock
                       Type: uint256
                       Source: "rateUpdateBlock"
        Block
           Source: "{\r\n            // first tx in the current block\r\n            int currentBlockImbalance;\r\n            (prevImbalance, currentBlockImbalance) = getImbalanceSinceRateUpdate(token, rateUpdateBlock, currentBlock);\r\n\r\n            currentBlockData.lastBlockBuyUnitsImbalance = recordedBuyAmount;\r\n            currentBlockData.lastBlock = uint(currentBlock);\r\n            currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "int currentBlockImbalance"
            VariableDeclaration "currentBlockImbalance"
               Type: int256
               Source: "int currentBlockImbalance"
              ElementaryTypeName int
                 Source: "int"
          ExpressionStatement
             Gas costs: 0
             Source: "(prevImbalance, currentBlockImbalance) = getImbalanceSinceRateUpdate(token, rateUpdateBlock, currentBlock)"
            Assignment using operator =
               Type: tuple()
               Source: "(prevImbalance, currentBlockImbalance) = getImbalanceSinceRateUpdate(token, rateUpdateBlock, currentBlock)"
              TupleExpression
                 Type: tuple(int256,int256)
                 Source: "(prevImbalance, currentBlockImbalance)"
                Identifier prevImbalance
                   Type: int256
                   Source: "prevImbalance"
                Identifier currentBlockImbalance
                   Type: int256
                   Source: "currentBlockImbalance"
              FunctionCall
                 Type: tuple(int256,int256)
                 Source: "getImbalanceSinceRateUpdate(token, rateUpdateBlock, currentBlock)"
                Identifier getImbalanceSinceRateUpdate
                   Type: function (contract ERC20,uint256,uint256) view returns (int256,int256)
                   Source: "getImbalanceSinceRateUpdate"
                Identifier token
                   Type: contract ERC20
                   Source: "token"
                Identifier rateUpdateBlock
                   Type: uint256
                   Source: "rateUpdateBlock"
                Identifier currentBlock
                   Type: uint256
                   Source: "currentBlock"
          ExpressionStatement
             Gas costs: 0
             Source: "currentBlockData.lastBlockBuyUnitsImbalance = recordedBuyAmount"
            Assignment using operator =
               Type: int256
               Source: "currentBlockData.lastBlockBuyUnitsImbalance = recordedBuyAmount"
              MemberAccess to member lastBlockBuyUnitsImbalance
                 Type: int256
                 Source: "currentBlockData.lastBlockBuyUnitsImbalance"
                Identifier currentBlockData
                   Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                   Source: "currentBlockData"
              Identifier recordedBuyAmount
                 Type: int256
                 Source: "recordedBuyAmount"
          ExpressionStatement
             Gas costs: 0
             Source: "currentBlockData.lastBlock = uint(currentBlock)"
            Assignment using operator =
               Type: uint256
               Source: "currentBlockData.lastBlock = uint(currentBlock)"
              MemberAccess to member lastBlock
                 Type: uint256
                 Source: "currentBlockData.lastBlock"
                Identifier currentBlockData
                   Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                   Source: "currentBlockData"
              FunctionCall
                 Type: uint256
                 Source: "uint(currentBlock)"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                Identifier currentBlock
                   Type: uint256
                   Source: "currentBlock"
          ExpressionStatement
             Gas costs: 0
             Source: "currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock)"
            Assignment using operator =
               Type: uint256
               Source: "currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock)"
              MemberAccess to member lastRateUpdateBlock
                 Type: uint256
                 Source: "currentBlockData.lastRateUpdateBlock"
                Identifier currentBlockData
                   Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                   Source: "currentBlockData"
              FunctionCall
                 Type: uint256
                 Source: "uint(rateUpdateBlock)"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                Identifier rateUpdateBlock
                   Type: uint256
                   Source: "rateUpdateBlock"
          ExpressionStatement
             Gas costs: 0
             Source: "currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount"
            Assignment using operator =
               Type: int256
               Source: "currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount"
              MemberAccess to member totalBuyUnitsImbalance
                 Type: int256
                 Source: "currentBlockData.totalBuyUnitsImbalance"
                Identifier currentBlockData
                   Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                   Source: "currentBlockData"
              BinaryOperation using operator +
                 Type: int256
                 Source: "int(prevImbalance) + recordedBuyAmount"
                FunctionCall
                   Type: int256
                   Source: "int(prevImbalance)"
                  ElementaryTypeNameExpression int
                     Type: type(int256)
                     Source: "int"
                  Identifier prevImbalance
                     Type: int256
                     Source: "prevImbalance"
                Identifier recordedBuyAmount
                   Type: int256
                   Source: "recordedBuyAmount"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenImbalanceData[token][currentBlockIndex] = encodeTokenImbalanceData(currentBlockData)"
        Assignment using operator =
           Type: uint256
           Source: "tokenImbalanceData[token][currentBlockIndex] = encodeTokenImbalanceData(currentBlockData)"
          IndexAccess
             Type: uint256
             Source: "tokenImbalanceData[token][currentBlockIndex]"
            IndexAccess
               Type: mapping(uint256 => uint256)
               Source: "tokenImbalanceData[token]"
              Identifier tokenImbalanceData
                 Type: mapping(address => mapping(uint256 => uint256))
                 Source: "tokenImbalanceData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
            Identifier currentBlockIndex
               Type: uint256
               Source: "currentBlockIndex"
          FunctionCall
             Type: uint256
             Source: "encodeTokenImbalanceData(currentBlockData)"
            Identifier encodeTokenImbalanceData
               Type: function (struct VolumeImbalanceRecorder.TokenImbalanceData memory) pure returns (uint256)
               Source: "encodeTokenImbalanceData"
            Identifier currentBlockData
               Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
               Source: "currentBlockData"
  FunctionDefinition "setGarbageToVolumeRecorder"
     Source: "function setGarbageToVolumeRecorder(ERC20 token) internal {\r\n        for (uint i = 0; i < SLIDING_WINDOW_SIZE; i++) {\r\n            tokenImbalanceData[token][i] = 0x1;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        for (uint i = 0; i < SLIDING_WINDOW_SIZE; i++) {\r\n            tokenImbalanceData[token][i] = 0x1;\r\n        }\r\n    }"
      ForStatement
         Source: "for (uint i = 0; i < SLIDING_WINDOW_SIZE; i++) {\r\n            tokenImbalanceData[token][i] = 0x1;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < SLIDING_WINDOW_SIZE"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier SLIDING_WINDOW_SIZE
             Type: uint256
             Source: "SLIDING_WINDOW_SIZE"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            tokenImbalanceData[token][i] = 0x1;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "tokenImbalanceData[token][i] = 0x1"
            Assignment using operator =
               Type: uint256
               Source: "tokenImbalanceData[token][i] = 0x1"
              IndexAccess
                 Type: uint256
                 Source: "tokenImbalanceData[token][i]"
                IndexAccess
                   Type: mapping(uint256 => uint256)
                   Source: "tokenImbalanceData[token]"
                  Identifier tokenImbalanceData
                     Type: mapping(address => mapping(uint256 => uint256))
                     Source: "tokenImbalanceData"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
                Identifier i
                   Type: uint256
                   Source: "i"
              Literal, token: [no token] value: 0x1
                 Type: int_const 1
                 Source: "0x1"
  FunctionDefinition "getImbalanceInRange" - const
     Source: "function getImbalanceInRange(ERC20 token, uint startBlock, uint endBlock) internal view returns(int buyImbalance) {\r\n        // check the imbalance in the sliding window\r\n        require(startBlock <= endBlock);\r\n\r\n        buyImbalance = 0;\r\n\r\n        for (uint windowInd = 0; windowInd < SLIDING_WINDOW_SIZE; windowInd++) {\r\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\r\n\r\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\r\n                buyImbalance += int(perBlockData.lastBlockBuyUnitsImbalance);\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token, uint startBlock, uint endBlock)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "startBlock"
         Type: uint256
         Source: "uint startBlock"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "endBlock"
         Type: uint256
         Source: "uint endBlock"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(int buyImbalance)"
      VariableDeclaration "buyImbalance"
         Type: int256
         Source: "int buyImbalance"
        ElementaryTypeName int
           Source: "int"
    Block
       Source: "{\r\n        // check the imbalance in the sliding window\r\n        require(startBlock <= endBlock);\r\n\r\n        buyImbalance = 0;\r\n\r\n        for (uint windowInd = 0; windowInd < SLIDING_WINDOW_SIZE; windowInd++) {\r\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\r\n\r\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\r\n                buyImbalance += int(perBlockData.lastBlockBuyUnitsImbalance);\r\n            }\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(startBlock <= endBlock)"
        FunctionCall
           Type: tuple()
           Source: "require(startBlock <= endBlock)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "startBlock <= endBlock"
            Identifier startBlock
               Type: uint256
               Source: "startBlock"
            Identifier endBlock
               Type: uint256
               Source: "endBlock"
      ExpressionStatement
         Gas costs: 0
         Source: "buyImbalance = 0"
        Assignment using operator =
           Type: int256
           Source: "buyImbalance = 0"
          Identifier buyImbalance
             Type: int256
             Source: "buyImbalance"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ForStatement
         Source: "for (uint windowInd = 0; windowInd < SLIDING_WINDOW_SIZE; windowInd++) {\r\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\r\n\r\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\r\n                buyImbalance += int(perBlockData.lastBlockBuyUnitsImbalance);\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint windowInd = 0"
          VariableDeclaration "windowInd"
             Type: uint256
             Source: "uint windowInd"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "windowInd < SLIDING_WINDOW_SIZE"
          Identifier windowInd
             Type: uint256
             Source: "windowInd"
          Identifier SLIDING_WINDOW_SIZE
             Type: uint256
             Source: "SLIDING_WINDOW_SIZE"
        ExpressionStatement
           Gas costs: 0
           Source: "windowInd++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "windowInd++"
            Identifier windowInd
               Type: uint256
               Source: "windowInd"
        Block
           Source: "{\r\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\r\n\r\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\r\n                buyImbalance += int(perBlockData.lastBlockBuyUnitsImbalance);\r\n            }\r\n        }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd])"
            VariableDeclaration "perBlockData"
               Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
               Source: "TokenImbalanceData memory perBlockData"
              UserDefinedTypeName "TokenImbalanceData"
                 Source: "TokenImbalanceData"
            FunctionCall
               Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
               Source: "decodeTokenImbalanceData(tokenImbalanceData[token][windowInd])"
              Identifier decodeTokenImbalanceData
                 Type: function (uint256) pure returns (struct VolumeImbalanceRecorder.TokenImbalanceData memory)
                 Source: "decodeTokenImbalanceData"
              IndexAccess
                 Type: uint256
                 Source: "tokenImbalanceData[token][windowInd]"
                IndexAccess
                   Type: mapping(uint256 => uint256)
                   Source: "tokenImbalanceData[token]"
                  Identifier tokenImbalanceData
                     Type: mapping(address => mapping(uint256 => uint256))
                     Source: "tokenImbalanceData"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
                Identifier windowInd
                   Type: uint256
                   Source: "windowInd"
          IfStatement
             Source: "if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\r\n                buyImbalance += int(perBlockData.lastBlockBuyUnitsImbalance);\r\n            }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 0
               Source: "perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "perBlockData.lastBlock <= endBlock"
                MemberAccess to member lastBlock
                   Type: uint256
                   Source: "perBlockData.lastBlock"
                  Identifier perBlockData
                     Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                     Source: "perBlockData"
                Identifier endBlock
                   Type: uint256
                   Source: "endBlock"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "perBlockData.lastBlock >= startBlock"
                MemberAccess to member lastBlock
                   Type: uint256
                   Source: "perBlockData.lastBlock"
                  Identifier perBlockData
                     Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                     Source: "perBlockData"
                Identifier startBlock
                   Type: uint256
                   Source: "startBlock"
            Block
               Source: "{\r\n                buyImbalance += int(perBlockData.lastBlockBuyUnitsImbalance);\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "buyImbalance += int(perBlockData.lastBlockBuyUnitsImbalance)"
                Assignment using operator +=
                   Type: int256
                   Source: "buyImbalance += int(perBlockData.lastBlockBuyUnitsImbalance)"
                  Identifier buyImbalance
                     Type: int256
                     Source: "buyImbalance"
                  FunctionCall
                     Type: int256
                     Source: "int(perBlockData.lastBlockBuyUnitsImbalance)"
                    ElementaryTypeNameExpression int
                       Type: type(int256)
                       Source: "int"
                    MemberAccess to member lastBlockBuyUnitsImbalance
                       Type: int256
                       Source: "perBlockData.lastBlockBuyUnitsImbalance"
                      Identifier perBlockData
                         Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                         Source: "perBlockData"
  FunctionDefinition "getImbalanceSinceRateUpdate" - const
     Source: "function getImbalanceSinceRateUpdate(ERC20 token, uint rateUpdateBlock, uint currentBlock)\r\n        internal view\r\n        returns(int buyImbalance, int currentBlockImbalance)\r\n    {\r\n        buyImbalance = 0;\r\n        currentBlockImbalance = 0;\r\n        uint latestBlock = 0;\r\n        int imbalanceInRange = 0;\r\n        uint startBlock = rateUpdateBlock;\r\n        uint endBlock = currentBlock;\r\n\r\n        for (uint windowInd = 0; windowInd < SLIDING_WINDOW_SIZE; windowInd++) {\r\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\r\n\r\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\r\n                imbalanceInRange += perBlockData.lastBlockBuyUnitsImbalance;\r\n            }\r\n\r\n            if (perBlockData.lastRateUpdateBlock != rateUpdateBlock) continue;\r\n            if (perBlockData.lastBlock < latestBlock) continue;\r\n\r\n            latestBlock = perBlockData.lastBlock;\r\n            buyImbalance = perBlockData.totalBuyUnitsImbalance;\r\n            if (uint(perBlockData.lastBlock) == currentBlock) {\r\n                currentBlockImbalance = perBlockData.lastBlockBuyUnitsImbalance;\r\n            }\r\n        }\r\n\r\n        if (buyImbalance == 0) {\r\n            buyImbalance = imbalanceInRange;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token, uint rateUpdateBlock, uint currentBlock)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "rateUpdateBlock"
         Type: uint256
         Source: "uint rateUpdateBlock"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "currentBlock"
         Type: uint256
         Source: "uint currentBlock"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(int buyImbalance, int currentBlockImbalance)"
      VariableDeclaration "buyImbalance"
         Type: int256
         Source: "int buyImbalance"
        ElementaryTypeName int
           Source: "int"
      VariableDeclaration "currentBlockImbalance"
         Type: int256
         Source: "int currentBlockImbalance"
        ElementaryTypeName int
           Source: "int"
    Block
       Source: "{\r\n        buyImbalance = 0;\r\n        currentBlockImbalance = 0;\r\n        uint latestBlock = 0;\r\n        int imbalanceInRange = 0;\r\n        uint startBlock = rateUpdateBlock;\r\n        uint endBlock = currentBlock;\r\n\r\n        for (uint windowInd = 0; windowInd < SLIDING_WINDOW_SIZE; windowInd++) {\r\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\r\n\r\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\r\n                imbalanceInRange += perBlockData.lastBlockBuyUnitsImbalance;\r\n            }\r\n\r\n            if (perBlockData.lastRateUpdateBlock != rateUpdateBlock) continue;\r\n            if (perBlockData.lastBlock < latestBlock) continue;\r\n\r\n            latestBlock = perBlockData.lastBlock;\r\n            buyImbalance = perBlockData.totalBuyUnitsImbalance;\r\n            if (uint(perBlockData.lastBlock) == currentBlock) {\r\n                currentBlockImbalance = perBlockData.lastBlockBuyUnitsImbalance;\r\n            }\r\n        }\r\n\r\n        if (buyImbalance == 0) {\r\n            buyImbalance = imbalanceInRange;\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "buyImbalance = 0"
        Assignment using operator =
           Type: int256
           Source: "buyImbalance = 0"
          Identifier buyImbalance
             Type: int256
             Source: "buyImbalance"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "currentBlockImbalance = 0"
        Assignment using operator =
           Type: int256
           Source: "currentBlockImbalance = 0"
          Identifier currentBlockImbalance
             Type: int256
             Source: "currentBlockImbalance"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint latestBlock = 0"
        VariableDeclaration "latestBlock"
           Type: uint256
           Source: "uint latestBlock"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "int imbalanceInRange = 0"
        VariableDeclaration "imbalanceInRange"
           Type: int256
           Source: "int imbalanceInRange"
          ElementaryTypeName int
             Source: "int"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint startBlock = rateUpdateBlock"
        VariableDeclaration "startBlock"
           Type: uint256
           Source: "uint startBlock"
          ElementaryTypeName uint
             Source: "uint"
        Identifier rateUpdateBlock
           Type: uint256
           Source: "rateUpdateBlock"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint endBlock = currentBlock"
        VariableDeclaration "endBlock"
           Type: uint256
           Source: "uint endBlock"
          ElementaryTypeName uint
             Source: "uint"
        Identifier currentBlock
           Type: uint256
           Source: "currentBlock"
      ForStatement
         Source: "for (uint windowInd = 0; windowInd < SLIDING_WINDOW_SIZE; windowInd++) {\r\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\r\n\r\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\r\n                imbalanceInRange += perBlockData.lastBlockBuyUnitsImbalance;\r\n            }\r\n\r\n            if (perBlockData.lastRateUpdateBlock != rateUpdateBlock) continue;\r\n            if (perBlockData.lastBlock < latestBlock) continue;\r\n\r\n            latestBlock = perBlockData.lastBlock;\r\n            buyImbalance = perBlockData.totalBuyUnitsImbalance;\r\n            if (uint(perBlockData.lastBlock) == currentBlock) {\r\n                currentBlockImbalance = perBlockData.lastBlockBuyUnitsImbalance;\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint windowInd = 0"
          VariableDeclaration "windowInd"
             Type: uint256
             Source: "uint windowInd"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "windowInd < SLIDING_WINDOW_SIZE"
          Identifier windowInd
             Type: uint256
             Source: "windowInd"
          Identifier SLIDING_WINDOW_SIZE
             Type: uint256
             Source: "SLIDING_WINDOW_SIZE"
        ExpressionStatement
           Gas costs: 0
           Source: "windowInd++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "windowInd++"
            Identifier windowInd
               Type: uint256
               Source: "windowInd"
        Block
           Source: "{\r\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\r\n\r\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\r\n                imbalanceInRange += perBlockData.lastBlockBuyUnitsImbalance;\r\n            }\r\n\r\n            if (perBlockData.lastRateUpdateBlock != rateUpdateBlock) continue;\r\n            if (perBlockData.lastBlock < latestBlock) continue;\r\n\r\n            latestBlock = perBlockData.lastBlock;\r\n            buyImbalance = perBlockData.totalBuyUnitsImbalance;\r\n            if (uint(perBlockData.lastBlock) == currentBlock) {\r\n                currentBlockImbalance = perBlockData.lastBlockBuyUnitsImbalance;\r\n            }\r\n        }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd])"
            VariableDeclaration "perBlockData"
               Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
               Source: "TokenImbalanceData memory perBlockData"
              UserDefinedTypeName "TokenImbalanceData"
                 Source: "TokenImbalanceData"
            FunctionCall
               Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
               Source: "decodeTokenImbalanceData(tokenImbalanceData[token][windowInd])"
              Identifier decodeTokenImbalanceData
                 Type: function (uint256) pure returns (struct VolumeImbalanceRecorder.TokenImbalanceData memory)
                 Source: "decodeTokenImbalanceData"
              IndexAccess
                 Type: uint256
                 Source: "tokenImbalanceData[token][windowInd]"
                IndexAccess
                   Type: mapping(uint256 => uint256)
                   Source: "tokenImbalanceData[token]"
                  Identifier tokenImbalanceData
                     Type: mapping(address => mapping(uint256 => uint256))
                     Source: "tokenImbalanceData"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
                Identifier windowInd
                   Type: uint256
                   Source: "windowInd"
          IfStatement
             Source: "if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\r\n                imbalanceInRange += perBlockData.lastBlockBuyUnitsImbalance;\r\n            }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 0
               Source: "perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "perBlockData.lastBlock <= endBlock"
                MemberAccess to member lastBlock
                   Type: uint256
                   Source: "perBlockData.lastBlock"
                  Identifier perBlockData
                     Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                     Source: "perBlockData"
                Identifier endBlock
                   Type: uint256
                   Source: "endBlock"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "perBlockData.lastBlock >= startBlock"
                MemberAccess to member lastBlock
                   Type: uint256
                   Source: "perBlockData.lastBlock"
                  Identifier perBlockData
                     Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                     Source: "perBlockData"
                Identifier startBlock
                   Type: uint256
                   Source: "startBlock"
            Block
               Source: "{\r\n                imbalanceInRange += perBlockData.lastBlockBuyUnitsImbalance;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "imbalanceInRange += perBlockData.lastBlockBuyUnitsImbalance"
                Assignment using operator +=
                   Type: int256
                   Source: "imbalanceInRange += perBlockData.lastBlockBuyUnitsImbalance"
                  Identifier imbalanceInRange
                     Type: int256
                     Source: "imbalanceInRange"
                  MemberAccess to member lastBlockBuyUnitsImbalance
                     Type: int256
                     Source: "perBlockData.lastBlockBuyUnitsImbalance"
                    Identifier perBlockData
                       Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                       Source: "perBlockData"
          IfStatement
             Source: "if (perBlockData.lastRateUpdateBlock != rateUpdateBlock) continue"
            BinaryOperation using operator !=
               Type: bool
               Gas costs: 0
               Source: "perBlockData.lastRateUpdateBlock != rateUpdateBlock"
              MemberAccess to member lastRateUpdateBlock
                 Type: uint256
                 Source: "perBlockData.lastRateUpdateBlock"
                Identifier perBlockData
                   Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                   Source: "perBlockData"
              Identifier rateUpdateBlock
                 Type: uint256
                 Source: "rateUpdateBlock"
            Continue
               Gas costs: 0
               Source: "continue"
          IfStatement
             Source: "if (perBlockData.lastBlock < latestBlock) continue"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 0
               Source: "perBlockData.lastBlock < latestBlock"
              MemberAccess to member lastBlock
                 Type: uint256
                 Source: "perBlockData.lastBlock"
                Identifier perBlockData
                   Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                   Source: "perBlockData"
              Identifier latestBlock
                 Type: uint256
                 Source: "latestBlock"
            Continue
               Gas costs: 0
               Source: "continue"
          ExpressionStatement
             Gas costs: 0
             Source: "latestBlock = perBlockData.lastBlock"
            Assignment using operator =
               Type: uint256
               Source: "latestBlock = perBlockData.lastBlock"
              Identifier latestBlock
                 Type: uint256
                 Source: "latestBlock"
              MemberAccess to member lastBlock
                 Type: uint256
                 Source: "perBlockData.lastBlock"
                Identifier perBlockData
                   Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                   Source: "perBlockData"
          ExpressionStatement
             Gas costs: 0
             Source: "buyImbalance = perBlockData.totalBuyUnitsImbalance"
            Assignment using operator =
               Type: int256
               Source: "buyImbalance = perBlockData.totalBuyUnitsImbalance"
              Identifier buyImbalance
                 Type: int256
                 Source: "buyImbalance"
              MemberAccess to member totalBuyUnitsImbalance
                 Type: int256
                 Source: "perBlockData.totalBuyUnitsImbalance"
                Identifier perBlockData
                   Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                   Source: "perBlockData"
          IfStatement
             Source: "if (uint(perBlockData.lastBlock) == currentBlock) {\r\n                currentBlockImbalance = perBlockData.lastBlockBuyUnitsImbalance;\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "uint(perBlockData.lastBlock) == currentBlock"
              FunctionCall
                 Type: uint256
                 Source: "uint(perBlockData.lastBlock)"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                MemberAccess to member lastBlock
                   Type: uint256
                   Source: "perBlockData.lastBlock"
                  Identifier perBlockData
                     Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                     Source: "perBlockData"
              Identifier currentBlock
                 Type: uint256
                 Source: "currentBlock"
            Block
               Source: "{\r\n                currentBlockImbalance = perBlockData.lastBlockBuyUnitsImbalance;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "currentBlockImbalance = perBlockData.lastBlockBuyUnitsImbalance"
                Assignment using operator =
                   Type: int256
                   Source: "currentBlockImbalance = perBlockData.lastBlockBuyUnitsImbalance"
                  Identifier currentBlockImbalance
                     Type: int256
                     Source: "currentBlockImbalance"
                  MemberAccess to member lastBlockBuyUnitsImbalance
                     Type: int256
                     Source: "perBlockData.lastBlockBuyUnitsImbalance"
                    Identifier perBlockData
                       Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                       Source: "perBlockData"
      IfStatement
         Source: "if (buyImbalance == 0) {\r\n            buyImbalance = imbalanceInRange;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "buyImbalance == 0"
          Identifier buyImbalance
             Type: int256
             Source: "buyImbalance"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            buyImbalance = imbalanceInRange;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "buyImbalance = imbalanceInRange"
            Assignment using operator =
               Type: int256
               Source: "buyImbalance = imbalanceInRange"
              Identifier buyImbalance
                 Type: int256
                 Source: "buyImbalance"
              Identifier imbalanceInRange
                 Type: int256
                 Source: "imbalanceInRange"
  FunctionDefinition "getImbalance" - const
     Source: "function getImbalance(ERC20 token, uint rateUpdateBlock, uint currentBlock)\r\n        internal view\r\n        returns(int totalImbalance, int currentBlockImbalance)\r\n    {\r\n\r\n        int resolution = int(tokenControlInfo[token].minimalRecordResolution);\r\n\r\n        (totalImbalance, currentBlockImbalance) =\r\n            getImbalanceSinceRateUpdate(\r\n                token,\r\n                rateUpdateBlock,\r\n                currentBlock);\r\n\r\n        totalImbalance *= resolution;\r\n        currentBlockImbalance *= resolution;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token, uint rateUpdateBlock, uint currentBlock)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "rateUpdateBlock"
         Type: uint256
         Source: "uint rateUpdateBlock"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "currentBlock"
         Type: uint256
         Source: "uint currentBlock"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(int totalImbalance, int currentBlockImbalance)"
      VariableDeclaration "totalImbalance"
         Type: int256
         Source: "int totalImbalance"
        ElementaryTypeName int
           Source: "int"
      VariableDeclaration "currentBlockImbalance"
         Type: int256
         Source: "int currentBlockImbalance"
        ElementaryTypeName int
           Source: "int"
    Block
       Source: "{\r\n\r\n        int resolution = int(tokenControlInfo[token].minimalRecordResolution);\r\n\r\n        (totalImbalance, currentBlockImbalance) =\r\n            getImbalanceSinceRateUpdate(\r\n                token,\r\n                rateUpdateBlock,\r\n                currentBlock);\r\n\r\n        totalImbalance *= resolution;\r\n        currentBlockImbalance *= resolution;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "int resolution = int(tokenControlInfo[token].minimalRecordResolution)"
        VariableDeclaration "resolution"
           Type: int256
           Source: "int resolution"
          ElementaryTypeName int
             Source: "int"
        FunctionCall
           Type: int256
           Source: "int(tokenControlInfo[token].minimalRecordResolution)"
          ElementaryTypeNameExpression int
             Type: type(int256)
             Source: "int"
          MemberAccess to member minimalRecordResolution
             Type: uint256
             Source: "tokenControlInfo[token].minimalRecordResolution"
            IndexAccess
               Type: struct VolumeImbalanceRecorder.TokenControlInfo storage ref
               Source: "tokenControlInfo[token]"
              Identifier tokenControlInfo
                 Type: mapping(address => struct VolumeImbalanceRecorder.TokenControlInfo storage ref)
                 Source: "tokenControlInfo"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
      ExpressionStatement
         Gas costs: 0
         Source: "(totalImbalance, currentBlockImbalance) =\r\n            getImbalanceSinceRateUpdate(\r\n                token,\r\n                rateUpdateBlock,\r\n                currentBlock)"
        Assignment using operator =
           Type: tuple()
           Source: "(totalImbalance, currentBlockImbalance) =\r\n            getImbalanceSinceRateUpdate(\r\n                token,\r\n                rateUpdateBlock,\r\n                currentBlock)"
          TupleExpression
             Type: tuple(int256,int256)
             Source: "(totalImbalance, currentBlockImbalance)"
            Identifier totalImbalance
               Type: int256
               Source: "totalImbalance"
            Identifier currentBlockImbalance
               Type: int256
               Source: "currentBlockImbalance"
          FunctionCall
             Type: tuple(int256,int256)
             Source: "getImbalanceSinceRateUpdate(\r\n                token,\r\n                rateUpdateBlock,\r\n                currentBlock)"
            Identifier getImbalanceSinceRateUpdate
               Type: function (contract ERC20,uint256,uint256) view returns (int256,int256)
               Source: "getImbalanceSinceRateUpdate"
            Identifier token
               Type: contract ERC20
               Source: "token"
            Identifier rateUpdateBlock
               Type: uint256
               Source: "rateUpdateBlock"
            Identifier currentBlock
               Type: uint256
               Source: "currentBlock"
      ExpressionStatement
         Gas costs: 0
         Source: "totalImbalance *= resolution"
        Assignment using operator *=
           Type: int256
           Source: "totalImbalance *= resolution"
          Identifier totalImbalance
             Type: int256
             Source: "totalImbalance"
          Identifier resolution
             Type: int256
             Source: "resolution"
      ExpressionStatement
         Gas costs: 0
         Source: "currentBlockImbalance *= resolution"
        Assignment using operator *=
           Type: int256
           Source: "currentBlockImbalance *= resolution"
          Identifier currentBlockImbalance
             Type: int256
             Source: "currentBlockImbalance"
          Identifier resolution
             Type: int256
             Source: "resolution"
  FunctionDefinition "getMaxPerBlockImbalance" - const
     Source: "function getMaxPerBlockImbalance(ERC20 token) internal view returns(uint) {\r\n        return tokenControlInfo[token].maxPerBlockImbalance;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return tokenControlInfo[token].maxPerBlockImbalance;\r\n    }"
      Return
         Gas costs: 0
         Source: "return tokenControlInfo[token].maxPerBlockImbalance"
        MemberAccess to member maxPerBlockImbalance
           Type: uint256
           Source: "tokenControlInfo[token].maxPerBlockImbalance"
          IndexAccess
             Type: struct VolumeImbalanceRecorder.TokenControlInfo storage ref
             Source: "tokenControlInfo[token]"
            Identifier tokenControlInfo
               Type: mapping(address => struct VolumeImbalanceRecorder.TokenControlInfo storage ref)
               Source: "tokenControlInfo"
            Identifier token
               Type: contract ERC20
               Source: "token"
  FunctionDefinition "getMaxTotalImbalance" - const
     Source: "function getMaxTotalImbalance(ERC20 token) internal view returns(uint) {\r\n        return tokenControlInfo[token].maxTotalImbalance;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return tokenControlInfo[token].maxTotalImbalance;\r\n    }"
      Return
         Gas costs: 0
         Source: "return tokenControlInfo[token].maxTotalImbalance"
        MemberAccess to member maxTotalImbalance
           Type: uint256
           Source: "tokenControlInfo[token].maxTotalImbalance"
          IndexAccess
             Type: struct VolumeImbalanceRecorder.TokenControlInfo storage ref
             Source: "tokenControlInfo[token]"
            Identifier tokenControlInfo
               Type: mapping(address => struct VolumeImbalanceRecorder.TokenControlInfo storage ref)
               Source: "tokenControlInfo"
            Identifier token
               Type: contract ERC20
               Source: "token"
  FunctionDefinition "encodeTokenImbalanceData"
     Source: "function encodeTokenImbalanceData(TokenImbalanceData data) internal pure returns(uint) {\r\n        // check for overflows\r\n        require(data.lastBlockBuyUnitsImbalance < int(POW_2_64 / 2));\r\n        require(data.lastBlockBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\r\n        require(data.lastBlock < POW_2_64);\r\n        require(data.totalBuyUnitsImbalance < int(POW_2_64 / 2));\r\n        require(data.totalBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\r\n        require(data.lastRateUpdateBlock < POW_2_64);\r\n\r\n        // do encoding\r\n        uint result = uint(data.lastBlockBuyUnitsImbalance) & (POW_2_64 - 1);\r\n        result |= data.lastBlock * POW_2_64;\r\n        result |= (uint(data.totalBuyUnitsImbalance) & (POW_2_64 - 1)) * POW_2_64 * POW_2_64;\r\n        result |= data.lastRateUpdateBlock * POW_2_64 * POW_2_64 * POW_2_64;\r\n\r\n        return result;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(TokenImbalanceData data)"
      VariableDeclaration "data"
         Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
         Source: "TokenImbalanceData data"
        UserDefinedTypeName "TokenImbalanceData"
           Source: "TokenImbalanceData"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        // check for overflows\r\n        require(data.lastBlockBuyUnitsImbalance < int(POW_2_64 / 2));\r\n        require(data.lastBlockBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\r\n        require(data.lastBlock < POW_2_64);\r\n        require(data.totalBuyUnitsImbalance < int(POW_2_64 / 2));\r\n        require(data.totalBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\r\n        require(data.lastRateUpdateBlock < POW_2_64);\r\n\r\n        // do encoding\r\n        uint result = uint(data.lastBlockBuyUnitsImbalance) & (POW_2_64 - 1);\r\n        result |= data.lastBlock * POW_2_64;\r\n        result |= (uint(data.totalBuyUnitsImbalance) & (POW_2_64 - 1)) * POW_2_64 * POW_2_64;\r\n        result |= data.lastRateUpdateBlock * POW_2_64 * POW_2_64 * POW_2_64;\r\n\r\n        return result;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(data.lastBlockBuyUnitsImbalance < int(POW_2_64 / 2))"
        FunctionCall
           Type: tuple()
           Source: "require(data.lastBlockBuyUnitsImbalance < int(POW_2_64 / 2))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "data.lastBlockBuyUnitsImbalance < int(POW_2_64 / 2)"
            MemberAccess to member lastBlockBuyUnitsImbalance
               Type: int256
               Source: "data.lastBlockBuyUnitsImbalance"
              Identifier data
                 Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                 Source: "data"
            FunctionCall
               Type: int256
               Source: "int(POW_2_64 / 2)"
              ElementaryTypeNameExpression int
                 Type: type(int256)
                 Source: "int"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "POW_2_64 / 2"
                Identifier POW_2_64
                   Type: uint256
                   Source: "POW_2_64"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
      ExpressionStatement
         Gas costs: 0
         Source: "require(data.lastBlockBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2))"
        FunctionCall
           Type: tuple()
           Source: "require(data.lastBlockBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "data.lastBlockBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2)"
            MemberAccess to member lastBlockBuyUnitsImbalance
               Type: int256
               Source: "data.lastBlockBuyUnitsImbalance"
              Identifier data
                 Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                 Source: "data"
            FunctionCall
               Type: int256
               Source: "int(-1 * int(POW_2_64) / 2)"
              ElementaryTypeNameExpression int
                 Type: type(int256)
                 Source: "int"
              BinaryOperation using operator /
                 Type: int256
                 Source: "-1 * int(POW_2_64) / 2"
                BinaryOperation using operator *
                   Type: int256
                   Source: "-1 * int(POW_2_64)"
                  UnaryOperation (prefix) -
                     Type: int_const -1
                     Source: "-1"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
                  FunctionCall
                     Type: int256
                     Source: "int(POW_2_64)"
                    ElementaryTypeNameExpression int
                       Type: type(int256)
                       Source: "int"
                    Identifier POW_2_64
                       Type: uint256
                       Source: "POW_2_64"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
      ExpressionStatement
         Gas costs: 0
         Source: "require(data.lastBlock < POW_2_64)"
        FunctionCall
           Type: tuple()
           Source: "require(data.lastBlock < POW_2_64)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "data.lastBlock < POW_2_64"
            MemberAccess to member lastBlock
               Type: uint256
               Source: "data.lastBlock"
              Identifier data
                 Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                 Source: "data"
            Identifier POW_2_64
               Type: uint256
               Source: "POW_2_64"
      ExpressionStatement
         Gas costs: 0
         Source: "require(data.totalBuyUnitsImbalance < int(POW_2_64 / 2))"
        FunctionCall
           Type: tuple()
           Source: "require(data.totalBuyUnitsImbalance < int(POW_2_64 / 2))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "data.totalBuyUnitsImbalance < int(POW_2_64 / 2)"
            MemberAccess to member totalBuyUnitsImbalance
               Type: int256
               Source: "data.totalBuyUnitsImbalance"
              Identifier data
                 Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                 Source: "data"
            FunctionCall
               Type: int256
               Source: "int(POW_2_64 / 2)"
              ElementaryTypeNameExpression int
                 Type: type(int256)
                 Source: "int"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "POW_2_64 / 2"
                Identifier POW_2_64
                   Type: uint256
                   Source: "POW_2_64"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
      ExpressionStatement
         Gas costs: 0
         Source: "require(data.totalBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2))"
        FunctionCall
           Type: tuple()
           Source: "require(data.totalBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "data.totalBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2)"
            MemberAccess to member totalBuyUnitsImbalance
               Type: int256
               Source: "data.totalBuyUnitsImbalance"
              Identifier data
                 Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                 Source: "data"
            FunctionCall
               Type: int256
               Source: "int(-1 * int(POW_2_64) / 2)"
              ElementaryTypeNameExpression int
                 Type: type(int256)
                 Source: "int"
              BinaryOperation using operator /
                 Type: int256
                 Source: "-1 * int(POW_2_64) / 2"
                BinaryOperation using operator *
                   Type: int256
                   Source: "-1 * int(POW_2_64)"
                  UnaryOperation (prefix) -
                     Type: int_const -1
                     Source: "-1"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
                  FunctionCall
                     Type: int256
                     Source: "int(POW_2_64)"
                    ElementaryTypeNameExpression int
                       Type: type(int256)
                       Source: "int"
                    Identifier POW_2_64
                       Type: uint256
                       Source: "POW_2_64"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
      ExpressionStatement
         Gas costs: 0
         Source: "require(data.lastRateUpdateBlock < POW_2_64)"
        FunctionCall
           Type: tuple()
           Source: "require(data.lastRateUpdateBlock < POW_2_64)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "data.lastRateUpdateBlock < POW_2_64"
            MemberAccess to member lastRateUpdateBlock
               Type: uint256
               Source: "data.lastRateUpdateBlock"
              Identifier data
                 Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                 Source: "data"
            Identifier POW_2_64
               Type: uint256
               Source: "POW_2_64"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint result = uint(data.lastBlockBuyUnitsImbalance) & (POW_2_64 - 1)"
        VariableDeclaration "result"
           Type: uint256
           Source: "uint result"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator &
           Type: uint256
           Source: "uint(data.lastBlockBuyUnitsImbalance) & (POW_2_64 - 1)"
          FunctionCall
             Type: uint256
             Source: "uint(data.lastBlockBuyUnitsImbalance)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            MemberAccess to member lastBlockBuyUnitsImbalance
               Type: int256
               Source: "data.lastBlockBuyUnitsImbalance"
              Identifier data
                 Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                 Source: "data"
          TupleExpression
             Type: uint256
             Source: "(POW_2_64 - 1)"
            BinaryOperation using operator -
               Type: uint256
               Source: "POW_2_64 - 1"
              Identifier POW_2_64
                 Type: uint256
                 Source: "POW_2_64"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "result |= data.lastBlock * POW_2_64"
        Assignment using operator |=
           Type: uint256
           Source: "result |= data.lastBlock * POW_2_64"
          Identifier result
             Type: uint256
             Source: "result"
          BinaryOperation using operator *
             Type: uint256
             Source: "data.lastBlock * POW_2_64"
            MemberAccess to member lastBlock
               Type: uint256
               Source: "data.lastBlock"
              Identifier data
                 Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                 Source: "data"
            Identifier POW_2_64
               Type: uint256
               Source: "POW_2_64"
      ExpressionStatement
         Gas costs: 0
         Source: "result |= (uint(data.totalBuyUnitsImbalance) & (POW_2_64 - 1)) * POW_2_64 * POW_2_64"
        Assignment using operator |=
           Type: uint256
           Source: "result |= (uint(data.totalBuyUnitsImbalance) & (POW_2_64 - 1)) * POW_2_64 * POW_2_64"
          Identifier result
             Type: uint256
             Source: "result"
          BinaryOperation using operator *
             Type: uint256
             Source: "(uint(data.totalBuyUnitsImbalance) & (POW_2_64 - 1)) * POW_2_64 * POW_2_64"
            BinaryOperation using operator *
               Type: uint256
               Source: "(uint(data.totalBuyUnitsImbalance) & (POW_2_64 - 1)) * POW_2_64"
              TupleExpression
                 Type: uint256
                 Source: "(uint(data.totalBuyUnitsImbalance) & (POW_2_64 - 1))"
                BinaryOperation using operator &
                   Type: uint256
                   Source: "uint(data.totalBuyUnitsImbalance) & (POW_2_64 - 1)"
                  FunctionCall
                     Type: uint256
                     Source: "uint(data.totalBuyUnitsImbalance)"
                    ElementaryTypeNameExpression uint
                       Type: type(uint256)
                       Source: "uint"
                    MemberAccess to member totalBuyUnitsImbalance
                       Type: int256
                       Source: "data.totalBuyUnitsImbalance"
                      Identifier data
                         Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                         Source: "data"
                  TupleExpression
                     Type: uint256
                     Source: "(POW_2_64 - 1)"
                    BinaryOperation using operator -
                       Type: uint256
                       Source: "POW_2_64 - 1"
                      Identifier POW_2_64
                         Type: uint256
                         Source: "POW_2_64"
                      Literal, token: [no token] value: 1
                         Type: int_const 1
                         Source: "1"
              Identifier POW_2_64
                 Type: uint256
                 Source: "POW_2_64"
            Identifier POW_2_64
               Type: uint256
               Source: "POW_2_64"
      ExpressionStatement
         Gas costs: 0
         Source: "result |= data.lastRateUpdateBlock * POW_2_64 * POW_2_64 * POW_2_64"
        Assignment using operator |=
           Type: uint256
           Source: "result |= data.lastRateUpdateBlock * POW_2_64 * POW_2_64 * POW_2_64"
          Identifier result
             Type: uint256
             Source: "result"
          BinaryOperation using operator *
             Type: uint256
             Source: "data.lastRateUpdateBlock * POW_2_64 * POW_2_64 * POW_2_64"
            BinaryOperation using operator *
               Type: uint256
               Source: "data.lastRateUpdateBlock * POW_2_64 * POW_2_64"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "data.lastRateUpdateBlock * POW_2_64"
                MemberAccess to member lastRateUpdateBlock
                   Type: uint256
                   Source: "data.lastRateUpdateBlock"
                  Identifier data
                     Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
                     Source: "data"
                Identifier POW_2_64
                   Type: uint256
                   Source: "POW_2_64"
              Identifier POW_2_64
                 Type: uint256
                 Source: "POW_2_64"
            Identifier POW_2_64
               Type: uint256
               Source: "POW_2_64"
      Return
         Gas costs: 0
         Source: "return result"
        Identifier result
           Type: uint256
           Source: "result"
  FunctionDefinition "decodeTokenImbalanceData"
     Source: "function decodeTokenImbalanceData(uint input) internal pure returns(TokenImbalanceData) {\r\n        TokenImbalanceData memory data;\r\n\r\n        data.lastBlockBuyUnitsImbalance = int(int64(input & (POW_2_64 - 1)));\r\n        data.lastBlock = uint(uint64((input / POW_2_64) & (POW_2_64 - 1)));\r\n        data.totalBuyUnitsImbalance = int(int64((input / (POW_2_64 * POW_2_64)) & (POW_2_64 - 1)));\r\n        data.lastRateUpdateBlock = uint(uint64((input / (POW_2_64 * POW_2_64 * POW_2_64))));\r\n\r\n        return data;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint input)"
      VariableDeclaration "input"
         Type: uint256
         Source: "uint input"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(TokenImbalanceData)"
      VariableDeclaration ""
         Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
         Source: "TokenImbalanceData"
        UserDefinedTypeName "TokenImbalanceData"
           Source: "TokenImbalanceData"
    Block
       Source: "{\r\n        TokenImbalanceData memory data;\r\n\r\n        data.lastBlockBuyUnitsImbalance = int(int64(input & (POW_2_64 - 1)));\r\n        data.lastBlock = uint(uint64((input / POW_2_64) & (POW_2_64 - 1)));\r\n        data.totalBuyUnitsImbalance = int(int64((input / (POW_2_64 * POW_2_64)) & (POW_2_64 - 1)));\r\n        data.lastRateUpdateBlock = uint(uint64((input / (POW_2_64 * POW_2_64 * POW_2_64))));\r\n\r\n        return data;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "TokenImbalanceData memory data"
        VariableDeclaration "data"
           Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
           Source: "TokenImbalanceData memory data"
          UserDefinedTypeName "TokenImbalanceData"
             Source: "TokenImbalanceData"
      ExpressionStatement
         Gas costs: 0
         Source: "data.lastBlockBuyUnitsImbalance = int(int64(input & (POW_2_64 - 1)))"
        Assignment using operator =
           Type: int256
           Source: "data.lastBlockBuyUnitsImbalance = int(int64(input & (POW_2_64 - 1)))"
          MemberAccess to member lastBlockBuyUnitsImbalance
             Type: int256
             Source: "data.lastBlockBuyUnitsImbalance"
            Identifier data
               Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
               Source: "data"
          FunctionCall
             Type: int256
             Source: "int(int64(input & (POW_2_64 - 1)))"
            ElementaryTypeNameExpression int
               Type: type(int256)
               Source: "int"
            FunctionCall
               Type: int64
               Source: "int64(input & (POW_2_64 - 1))"
              ElementaryTypeNameExpression int64
                 Type: type(int64)
                 Source: "int64"
              BinaryOperation using operator &
                 Type: uint256
                 Source: "input & (POW_2_64 - 1)"
                Identifier input
                   Type: uint256
                   Source: "input"
                TupleExpression
                   Type: uint256
                   Source: "(POW_2_64 - 1)"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "POW_2_64 - 1"
                    Identifier POW_2_64
                       Type: uint256
                       Source: "POW_2_64"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "data.lastBlock = uint(uint64((input / POW_2_64) & (POW_2_64 - 1)))"
        Assignment using operator =
           Type: uint256
           Source: "data.lastBlock = uint(uint64((input / POW_2_64) & (POW_2_64 - 1)))"
          MemberAccess to member lastBlock
             Type: uint256
             Source: "data.lastBlock"
            Identifier data
               Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
               Source: "data"
          FunctionCall
             Type: uint256
             Source: "uint(uint64((input / POW_2_64) & (POW_2_64 - 1)))"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            FunctionCall
               Type: uint64
               Source: "uint64((input / POW_2_64) & (POW_2_64 - 1))"
              ElementaryTypeNameExpression uint64
                 Type: type(uint64)
                 Source: "uint64"
              BinaryOperation using operator &
                 Type: uint256
                 Source: "(input / POW_2_64) & (POW_2_64 - 1)"
                TupleExpression
                   Type: uint256
                   Source: "(input / POW_2_64)"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "input / POW_2_64"
                    Identifier input
                       Type: uint256
                       Source: "input"
                    Identifier POW_2_64
                       Type: uint256
                       Source: "POW_2_64"
                TupleExpression
                   Type: uint256
                   Source: "(POW_2_64 - 1)"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "POW_2_64 - 1"
                    Identifier POW_2_64
                       Type: uint256
                       Source: "POW_2_64"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "data.totalBuyUnitsImbalance = int(int64((input / (POW_2_64 * POW_2_64)) & (POW_2_64 - 1)))"
        Assignment using operator =
           Type: int256
           Source: "data.totalBuyUnitsImbalance = int(int64((input / (POW_2_64 * POW_2_64)) & (POW_2_64 - 1)))"
          MemberAccess to member totalBuyUnitsImbalance
             Type: int256
             Source: "data.totalBuyUnitsImbalance"
            Identifier data
               Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
               Source: "data"
          FunctionCall
             Type: int256
             Source: "int(int64((input / (POW_2_64 * POW_2_64)) & (POW_2_64 - 1)))"
            ElementaryTypeNameExpression int
               Type: type(int256)
               Source: "int"
            FunctionCall
               Type: int64
               Source: "int64((input / (POW_2_64 * POW_2_64)) & (POW_2_64 - 1))"
              ElementaryTypeNameExpression int64
                 Type: type(int64)
                 Source: "int64"
              BinaryOperation using operator &
                 Type: uint256
                 Source: "(input / (POW_2_64 * POW_2_64)) & (POW_2_64 - 1)"
                TupleExpression
                   Type: uint256
                   Source: "(input / (POW_2_64 * POW_2_64))"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "input / (POW_2_64 * POW_2_64)"
                    Identifier input
                       Type: uint256
                       Source: "input"
                    TupleExpression
                       Type: uint256
                       Source: "(POW_2_64 * POW_2_64)"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "POW_2_64 * POW_2_64"
                        Identifier POW_2_64
                           Type: uint256
                           Source: "POW_2_64"
                        Identifier POW_2_64
                           Type: uint256
                           Source: "POW_2_64"
                TupleExpression
                   Type: uint256
                   Source: "(POW_2_64 - 1)"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "POW_2_64 - 1"
                    Identifier POW_2_64
                       Type: uint256
                       Source: "POW_2_64"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "data.lastRateUpdateBlock = uint(uint64((input / (POW_2_64 * POW_2_64 * POW_2_64))))"
        Assignment using operator =
           Type: uint256
           Source: "data.lastRateUpdateBlock = uint(uint64((input / (POW_2_64 * POW_2_64 * POW_2_64))))"
          MemberAccess to member lastRateUpdateBlock
             Type: uint256
             Source: "data.lastRateUpdateBlock"
            Identifier data
               Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
               Source: "data"
          FunctionCall
             Type: uint256
             Source: "uint(uint64((input / (POW_2_64 * POW_2_64 * POW_2_64))))"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            FunctionCall
               Type: uint64
               Source: "uint64((input / (POW_2_64 * POW_2_64 * POW_2_64)))"
              ElementaryTypeNameExpression uint64
                 Type: type(uint64)
                 Source: "uint64"
              TupleExpression
                 Type: uint256
                 Source: "(input / (POW_2_64 * POW_2_64 * POW_2_64))"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "input / (POW_2_64 * POW_2_64 * POW_2_64)"
                  Identifier input
                     Type: uint256
                     Source: "input"
                  TupleExpression
                     Type: uint256
                     Source: "(POW_2_64 * POW_2_64 * POW_2_64)"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "POW_2_64 * POW_2_64 * POW_2_64"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "POW_2_64 * POW_2_64"
                        Identifier POW_2_64
                           Type: uint256
                           Source: "POW_2_64"
                        Identifier POW_2_64
                           Type: uint256
                           Source: "POW_2_64"
                      Identifier POW_2_64
                         Type: uint256
                         Source: "POW_2_64"
      Return
         Gas costs: 0
         Source: "return data"
        Identifier data
           Type: struct VolumeImbalanceRecorder.TokenImbalanceData memory
           Source: "data"
ContractDefinition "ConversionRates"
   Source: "contract ConversionRates is VolumeImbalanceRecorder, Utils {\r\n\r\n    // bps - basic rate steps. one step is 1 / 10000 of the rate.\r\n    struct StepFunction {\r\n        int[] x; // quantity for each step. Quantity of each step includes previous steps.\r\n        int[] y; // rate change per quantity step  in bps.\r\n    }\r\n\r\n    struct TokenData {\r\n        bool listed;  // was added to reserve\r\n        bool enabled; // whether trade is enabled\r\n\r\n        // position in the compact data\r\n        uint compactDataArrayIndex;\r\n        uint compactDataFieldIndex;\r\n\r\n        // rate data. base and changes according to quantity and reserve balance.\r\n        // generally speaking. Sell rate is 1 / buy rate i.e. the buy in the other direction.\r\n        uint baseBuyRate;  // in PRECISION units. see KyberConstants\r\n        uint baseSellRate; // PRECISION units. without (sell / buy) spread it is 1 / baseBuyRate\r\n        StepFunction buyRateQtyStepFunction; // in bps. higher quantity - bigger the rate.\r\n        StepFunction sellRateQtyStepFunction;// in bps. higher the qua\r\n        StepFunction buyRateImbalanceStepFunction; // in BPS. higher reserve imbalance - bigger the rate.\r\n        StepFunction sellRateImbalanceStepFunction;\r\n    }\r\n\r\n    /*\r\n    this is the data for tokenRatesCompactData\r\n    but solidity compiler optimizer is sub-optimal, and cannot write this structure in a single storage write\r\n    so we represent it as bytes32 and do the byte tricks ourselves.\r\n    struct TokenRatesCompactData {\r\n        bytes14 buy;  // change buy rate of token from baseBuyRate in 10 bps\r\n        bytes14 sell; // change sell rate of token from baseSellRate in 10 bps\r\n\r\n        uint32 blockNumber;\r\n    } */\r\n    uint public validRateDurationInBlocks = 10; // rates are valid for this amount of blocks\r\n    ERC20[] internal listedTokens;\r\n    mapping(address=>TokenData) internal tokenData;\r\n    bytes32[] internal tokenRatesCompactData;\r\n    uint public numTokensInCurrentCompactData = 0;\r\n    address public reserveContract;\r\n    uint constant internal NUM_TOKENS_IN_COMPACT_DATA = 14;\r\n    uint constant internal BYTES_14_OFFSET = (2 ** (8 * NUM_TOKENS_IN_COMPACT_DATA));\r\n\r\n    function ConversionRates(address _admin) public VolumeImbalanceRecorder(_admin)\r\n        { } // solhint-disable-line no-empty-blocks\r\n\r\n    function addToken(ERC20 token) public onlyAdmin {\r\n\r\n        require(!tokenData[token].listed);\r\n        tokenData[token].listed = true;\r\n        listedTokens.push(token);\r\n\r\n        if (numTokensInCurrentCompactData == 0) {\r\n            tokenRatesCompactData.length++; // add new structure\r\n        }\r\n\r\n        tokenData[token].compactDataArrayIndex = tokenRatesCompactData.length - 1;\r\n        tokenData[token].compactDataFieldIndex = numTokensInCurrentCompactData;\r\n\r\n        numTokensInCurrentCompactData = (numTokensInCurrentCompactData + 1) % NUM_TOKENS_IN_COMPACT_DATA;\r\n\r\n        setGarbageToVolumeRecorder(token);\r\n    }\r\n\r\n    function setCompactData(bytes14[] buy, bytes14[] sell, uint blockNumber, uint[] indices) public onlyOperator {\r\n\r\n        require(buy.length == sell.length);\r\n        require(indices.length == buy.length);\r\n        require(blockNumber <= 0xFFFFFFFF);\r\n\r\n        uint bytes14Offset = BYTES_14_OFFSET;\r\n\r\n        for (uint i = 0; i < indices.length; i++) {\r\n            require(indices[i] < tokenRatesCompactData.length);\r\n            uint data = uint(buy[i]) | uint(sell[i]) * bytes14Offset | (blockNumber * (bytes14Offset * bytes14Offset));\r\n            tokenRatesCompactData[indices[i]] = bytes32(data);\r\n        }\r\n    }\r\n\r\n    function setBaseRate(\r\n        ERC20[] tokens,\r\n        uint[] baseBuy,\r\n        uint[] baseSell,\r\n        bytes14[] buy,\r\n        bytes14[] sell,\r\n        uint blockNumber,\r\n        uint[] indices\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(tokens.length == baseBuy.length);\r\n        require(tokens.length == baseSell.length);\r\n        require(sell.length == buy.length);\r\n        require(sell.length == indices.length);\r\n\r\n        for (uint ind = 0; ind < tokens.length; ind++) {\r\n            require(tokenData[tokens[ind]].listed);\r\n            tokenData[tokens[ind]].baseBuyRate = baseBuy[ind];\r\n            tokenData[tokens[ind]].baseSellRate = baseSell[ind];\r\n        }\r\n\r\n        setCompactData(buy, sell, blockNumber, indices);\r\n    }\r\n\r\n    function setQtyStepFunction(\r\n        ERC20 token,\r\n        int[] xBuy,\r\n        int[] yBuy,\r\n        int[] xSell,\r\n        int[] ySell\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(xBuy.length == yBuy.length);\r\n        require(xSell.length == ySell.length);\r\n        require(tokenData[token].listed);\r\n\r\n        tokenData[token].buyRateQtyStepFunction = StepFunction(xBuy, yBuy);\r\n        tokenData[token].sellRateQtyStepFunction = StepFunction(xSell, ySell);\r\n    }\r\n\r\n    function setImbalanceStepFunction(\r\n        ERC20 token,\r\n        int[] xBuy,\r\n        int[] yBuy,\r\n        int[] xSell,\r\n        int[] ySell\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(xBuy.length == yBuy.length);\r\n        require(xSell.length == ySell.length);\r\n        require(tokenData[token].listed);\r\n\r\n        tokenData[token].buyRateImbalanceStepFunction = StepFunction(xBuy, yBuy);\r\n        tokenData[token].sellRateImbalanceStepFunction = StepFunction(xSell, ySell);\r\n    }\r\n\r\n    function setValidRateDurationInBlocks(uint duration) public onlyAdmin {\r\n        validRateDurationInBlocks = duration;\r\n    }\r\n\r\n    function enableTokenTrade(ERC20 token) public onlyAdmin {\r\n        require(tokenData[token].listed);\r\n        require(tokenControlInfo[token].minimalRecordResolution != 0);\r\n        tokenData[token].enabled = true;\r\n    }\r\n\r\n    function disableTokenTrade(ERC20 token) public onlyAlerter {\r\n        require(tokenData[token].listed);\r\n        tokenData[token].enabled = false;\r\n    }\r\n\r\n    function setReserveAddress(address reserve) public onlyAdmin {\r\n        reserveContract = reserve;\r\n    }\r\n\r\n    function recordImbalance(\r\n        ERC20 token,\r\n        int buyAmount,\r\n        uint rateUpdateBlock,\r\n        uint currentBlock\r\n    )\r\n        public\r\n    {\r\n        require(msg.sender == reserveContract);\r\n\r\n        if (rateUpdateBlock == 0) rateUpdateBlock = getRateUpdateBlock(token);\r\n\r\n        return addImbalance(token, buyAmount, rateUpdateBlock, currentBlock);\r\n    }\r\n\r\n    /* solhint-disable function-max-lines */\r\n    function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint) {\r\n        // check if trade is enabled\r\n        if (!tokenData[token].enabled) return 0;\r\n        if (tokenControlInfo[token].minimalRecordResolution == 0) return 0; // token control info not set\r\n\r\n        // get rate update block\r\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\r\n\r\n        uint updateRateBlock = getLast4Bytes(compactData);\r\n        if (currentBlockNumber >= updateRateBlock + validRateDurationInBlocks) return 0; // rate is expired\r\n        // check imbalance\r\n        int totalImbalance;\r\n        int blockImbalance;\r\n        (totalImbalance, blockImbalance) = getImbalance(token, updateRateBlock, currentBlockNumber);\r\n\r\n        // calculate actual rate\r\n        int imbalanceQty;\r\n        int extraBps;\r\n        int8 rateUpdate;\r\n        uint rate;\r\n\r\n        if (buy) {\r\n            // start with base rate\r\n            rate = tokenData[token].baseBuyRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, true);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            qty = getTokenQty(token, rate, qty);\r\n            imbalanceQty = int(qty);\r\n            totalImbalance += imbalanceQty;\r\n\r\n            // add qty overhead\r\n            extraBps = executeStepFunction(tokenData[token].buyRateQtyStepFunction, int(qty));\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(tokenData[token].buyRateImbalanceStepFunction, totalImbalance);\r\n            rate = addBps(rate, extraBps);\r\n        } else {\r\n            // start with base rate\r\n            rate = tokenData[token].baseSellRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, false);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            imbalanceQty = -1 * int(qty);\r\n            totalImbalance += imbalanceQty;\r\n\r\n            // add qty overhead\r\n            extraBps = executeStepFunction(tokenData[token].sellRateQtyStepFunction, int(qty));\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(tokenData[token].sellRateImbalanceStepFunction, totalImbalance);\r\n            rate = addBps(rate, extraBps);\r\n        }\r\n\r\n        if (abs(totalImbalance + imbalanceQty) >= getMaxTotalImbalance(token)) return 0;\r\n        if (abs(blockImbalance + imbalanceQty) >= getMaxPerBlockImbalance(token)) return 0;\r\n\r\n        return rate;\r\n    }\r\n    /* solhint-enable function-max-lines */\r\n\r\n    function getBasicRate(ERC20 token, bool buy) public view returns(uint) {\r\n        if (buy)\r\n            return tokenData[token].baseBuyRate;\r\n        else\r\n            return tokenData[token].baseSellRate;\r\n    }\r\n\r\n    function getCompactData(ERC20 token) public view returns(uint, uint, byte, byte) {\r\n        uint arrayIndex = tokenData[token].compactDataArrayIndex;\r\n        uint fieldOffset = tokenData[token].compactDataFieldIndex;\r\n\r\n        return (\r\n            arrayIndex,\r\n            fieldOffset,\r\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, true)),\r\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, false))\r\n        );\r\n    }\r\n\r\n    function getTokenBasicData(ERC20 token) public view returns(bool, bool) {\r\n        return (tokenData[token].listed, tokenData[token].enabled);\r\n    }\r\n\r\n    /* solhint-disable code-complexity */\r\n    function getStepFunctionData(ERC20 token, uint command, uint param) public view returns(int) {\r\n        if (command == 0) return int(tokenData[token].buyRateQtyStepFunction.x.length);\r\n        if (command == 1) return tokenData[token].buyRateQtyStepFunction.x[param];\r\n        if (command == 2) return int(tokenData[token].buyRateQtyStepFunction.y.length);\r\n        if (command == 3) return tokenData[token].buyRateQtyStepFunction.y[param];\r\n\r\n        if (command == 4) return int(tokenData[token].sellRateQtyStepFunction.x.length);\r\n        if (command == 5) return tokenData[token].sellRateQtyStepFunction.x[param];\r\n        if (command == 6) return int(tokenData[token].sellRateQtyStepFunction.y.length);\r\n        if (command == 7) return tokenData[token].sellRateQtyStepFunction.y[param];\r\n\r\n        if (command == 8) return int(tokenData[token].buyRateImbalanceStepFunction.x.length);\r\n        if (command == 9) return tokenData[token].buyRateImbalanceStepFunction.x[param];\r\n        if (command == 10) return int(tokenData[token].buyRateImbalanceStepFunction.y.length);\r\n        if (command == 11) return tokenData[token].buyRateImbalanceStepFunction.y[param];\r\n\r\n        if (command == 12) return int(tokenData[token].sellRateImbalanceStepFunction.x.length);\r\n        if (command == 13) return tokenData[token].sellRateImbalanceStepFunction.x[param];\r\n        if (command == 14) return int(tokenData[token].sellRateImbalanceStepFunction.y.length);\r\n        if (command == 15) return tokenData[token].sellRateImbalanceStepFunction.y[param];\r\n\r\n        revert();\r\n    }\r\n    /* solhint-enable code-complexity */\r\n\r\n    function getRateUpdateBlock(ERC20 token) public view returns(uint) {\r\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\r\n        return getLast4Bytes(compactData);\r\n    }\r\n\r\n    function getListedTokens() public view returns(ERC20[]) {\r\n        return listedTokens;\r\n    }\r\n\r\n    function getTokenQty(ERC20 token, uint ethQty, uint rate) internal view returns(uint) {\r\n        uint dstDecimals = token.decimals();\r\n        uint srcDecimals = 18;\r\n\r\n        return calcDstQty(ethQty, srcDecimals, dstDecimals, rate);\r\n    }\r\n\r\n    function getLast4Bytes(bytes32 b) internal pure returns(uint) {\r\n        // cannot trust compiler with not turning bit operations into EXP opcode\r\n        return uint(b) / (BYTES_14_OFFSET * BYTES_14_OFFSET);\r\n    }\r\n\r\n    function getRateByteFromCompactData(bytes32 data, ERC20 token, bool buy) internal view returns(int8) {\r\n        uint fieldOffset = tokenData[token].compactDataFieldIndex;\r\n        uint byteOffset;\r\n        if (buy)\r\n            byteOffset = 32 - NUM_TOKENS_IN_COMPACT_DATA + fieldOffset;\r\n        else\r\n            byteOffset = 4 + fieldOffset;\r\n\r\n        return int8(data[byteOffset]);\r\n    }\r\n\r\n    function executeStepFunction(StepFunction f, int x) internal pure returns(int) {\r\n        uint len = f.y.length;\r\n        for (uint ind = 0; ind < len; ind++) {\r\n            if (x <= f.x[ind]) return f.y[ind];\r\n        }\r\n\r\n        return f.y[len-1];\r\n    }\r\n\r\n    function addBps(uint rate, int bps) internal pure returns(uint) {\r\n        uint maxBps = 100 * 100;\r\n        return (rate * uint(int(maxBps) + bps)) / maxBps;\r\n    }\r\n\r\n    function abs(int x) internal pure returns(uint) {\r\n        if (x < 0)\r\n            return uint(-1 * x);\r\n        else\r\n            return uint(x);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "VolumeImbalanceRecorder"
    UserDefinedTypeName "VolumeImbalanceRecorder"
       Source: "VolumeImbalanceRecorder"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Utils"
    UserDefinedTypeName "Utils"
       Source: "Utils"
  StructDefinition "StepFunction"
     Gas costs: 0
     Source: "struct StepFunction {\r\n        int[] x; // quantity for each step. Quantity of each step includes previous steps.\r\n        int[] y; // rate change per quantity step  in bps.\r\n    }"
    VariableDeclaration "x"
       Type: int256[] storage pointer
       Source: "int[] x"
      ArrayTypeName
         Source: "int[]"
        ElementaryTypeName int
           Source: "int"
    VariableDeclaration "y"
       Type: int256[] storage pointer
       Source: "int[] y"
      ArrayTypeName
         Source: "int[]"
        ElementaryTypeName int
           Source: "int"
  StructDefinition "TokenData"
     Gas costs: 0
     Source: "struct TokenData {\r\n        bool listed;  // was added to reserve\r\n        bool enabled; // whether trade is enabled\r\n\r\n        // position in the compact data\r\n        uint compactDataArrayIndex;\r\n        uint compactDataFieldIndex;\r\n\r\n        // rate data. base and changes according to quantity and reserve balance.\r\n        // generally speaking. Sell rate is 1 / buy rate i.e. the buy in the other direction.\r\n        uint baseBuyRate;  // in PRECISION units. see KyberConstants\r\n        uint baseSellRate; // PRECISION units. without (sell / buy) spread it is 1 / baseBuyRate\r\n        StepFunction buyRateQtyStepFunction; // in bps. higher quantity - bigger the rate.\r\n        StepFunction sellRateQtyStepFunction;// in bps. higher the qua\r\n        StepFunction buyRateImbalanceStepFunction; // in BPS. higher reserve imbalance - bigger the rate.\r\n        StepFunction sellRateImbalanceStepFunction;\r\n    }"
    VariableDeclaration "listed"
       Type: bool
       Source: "bool listed"
      ElementaryTypeName bool
         Source: "bool"
    VariableDeclaration "enabled"
       Type: bool
       Source: "bool enabled"
      ElementaryTypeName bool
         Source: "bool"
    VariableDeclaration "compactDataArrayIndex"
       Type: uint256
       Source: "uint compactDataArrayIndex"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "compactDataFieldIndex"
       Type: uint256
       Source: "uint compactDataFieldIndex"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "baseBuyRate"
       Type: uint256
       Source: "uint baseBuyRate"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "baseSellRate"
       Type: uint256
       Source: "uint baseSellRate"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "buyRateQtyStepFunction"
       Type: struct ConversionRates.StepFunction storage pointer
       Source: "StepFunction buyRateQtyStepFunction"
      UserDefinedTypeName "StepFunction"
         Source: "StepFunction"
    VariableDeclaration "sellRateQtyStepFunction"
       Type: struct ConversionRates.StepFunction storage pointer
       Source: "StepFunction sellRateQtyStepFunction"
      UserDefinedTypeName "StepFunction"
         Source: "StepFunction"
    VariableDeclaration "buyRateImbalanceStepFunction"
       Type: struct ConversionRates.StepFunction storage pointer
       Source: "StepFunction buyRateImbalanceStepFunction"
      UserDefinedTypeName "StepFunction"
         Source: "StepFunction"
    VariableDeclaration "sellRateImbalanceStepFunction"
       Type: struct ConversionRates.StepFunction storage pointer
       Source: "StepFunction sellRateImbalanceStepFunction"
      UserDefinedTypeName "StepFunction"
         Source: "StepFunction"
  VariableDeclaration "validRateDurationInBlocks"
     Type: uint256
     Gas costs: 0
     Source: "uint public validRateDurationInBlocks = 10"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 10
       Type: int_const 10
       Source: "10"
  VariableDeclaration "listedTokens"
     Type: contract ERC20[] storage ref
     Gas costs: 0
     Source: "ERC20[] internal listedTokens"
    ArrayTypeName
       Source: "ERC20[]"
      UserDefinedTypeName "ERC20"
         Source: "ERC20"
  VariableDeclaration "tokenData"
     Type: mapping(address => struct ConversionRates.TokenData storage ref)
     Gas costs: 0
     Source: "mapping(address=>TokenData) internal tokenData"
    Mapping
       Source: "mapping(address=>TokenData)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "TokenData"
         Source: "TokenData"
  VariableDeclaration "tokenRatesCompactData"
     Type: bytes32[] storage ref
     Gas costs: 0
     Source: "bytes32[] internal tokenRatesCompactData"
    ArrayTypeName
       Source: "bytes32[]"
      ElementaryTypeName bytes32
         Source: "bytes32"
  VariableDeclaration "numTokensInCurrentCompactData"
     Type: uint256
     Gas costs: 0
     Source: "uint public numTokensInCurrentCompactData = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "reserveContract"
     Type: address
     Gas costs: 0
     Source: "address public reserveContract"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "NUM_TOKENS_IN_COMPACT_DATA"
     Type: uint256
     Gas costs: 0
     Source: "uint constant internal NUM_TOKENS_IN_COMPACT_DATA = 14"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 14
       Type: int_const 14
       Source: "14"
  VariableDeclaration "BYTES_14_OFFSET"
     Type: uint256
     Gas costs: 0
     Source: "uint constant internal BYTES_14_OFFSET = (2 ** (8 * NUM_TOKENS_IN_COMPACT_DATA))"
    ElementaryTypeName uint
       Source: "uint"
    TupleExpression
       Type: uint256
       Source: "(2 ** (8 * NUM_TOKENS_IN_COMPACT_DATA))"
      BinaryOperation using operator **
         Type: uint256
         Source: "2 ** (8 * NUM_TOKENS_IN_COMPACT_DATA)"
        Literal, token: [no token] value: 2
           Type: int_const 2
           Source: "2"
        TupleExpression
           Type: uint256
           Source: "(8 * NUM_TOKENS_IN_COMPACT_DATA)"
          BinaryOperation using operator *
             Type: uint256
             Source: "8 * NUM_TOKENS_IN_COMPACT_DATA"
            Literal, token: [no token] value: 8
               Type: int_const 8
               Source: "8"
            Identifier NUM_TOKENS_IN_COMPACT_DATA
               Type: uint256
               Source: "NUM_TOKENS_IN_COMPACT_DATA"
  FunctionDefinition "ConversionRates" - public
     Source: "function ConversionRates(address _admin) public VolumeImbalanceRecorder(_admin)\r\n        { }"
    ParameterList
       Gas costs: 0
       Source: "(address _admin)"
      VariableDeclaration "_admin"
         Type: address
         Source: "address _admin"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "VolumeImbalanceRecorder"
       Gas costs: 0
       Source: "VolumeImbalanceRecorder(_admin)"
      Identifier VolumeImbalanceRecorder
         Type: type(contract VolumeImbalanceRecorder)
         Source: "VolumeImbalanceRecorder"
      Identifier _admin
         Type: address
         Source: "_admin"
    Block
       Gas costs: 0
       Source: "{ }"
  FunctionDefinition "addToken" - public
     Source: "function addToken(ERC20 token) public onlyAdmin {\r\n\r\n        require(!tokenData[token].listed);\r\n        tokenData[token].listed = true;\r\n        listedTokens.push(token);\r\n\r\n        if (numTokensInCurrentCompactData == 0) {\r\n            tokenRatesCompactData.length++; // add new structure\r\n        }\r\n\r\n        tokenData[token].compactDataArrayIndex = tokenRatesCompactData.length - 1;\r\n        tokenData[token].compactDataFieldIndex = numTokensInCurrentCompactData;\r\n\r\n        numTokensInCurrentCompactData = (numTokensInCurrentCompactData + 1) % NUM_TOKENS_IN_COMPACT_DATA;\r\n\r\n        setGarbageToVolumeRecorder(token);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n\r\n        require(!tokenData[token].listed);\r\n        tokenData[token].listed = true;\r\n        listedTokens.push(token);\r\n\r\n        if (numTokensInCurrentCompactData == 0) {\r\n            tokenRatesCompactData.length++; // add new structure\r\n        }\r\n\r\n        tokenData[token].compactDataArrayIndex = tokenRatesCompactData.length - 1;\r\n        tokenData[token].compactDataFieldIndex = numTokensInCurrentCompactData;\r\n\r\n        numTokensInCurrentCompactData = (numTokensInCurrentCompactData + 1) % NUM_TOKENS_IN_COMPACT_DATA;\r\n\r\n        setGarbageToVolumeRecorder(token);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!tokenData[token].listed)"
        FunctionCall
           Type: tuple()
           Source: "require(!tokenData[token].listed)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!tokenData[token].listed"
            MemberAccess to member listed
               Type: bool
               Source: "tokenData[token].listed"
              IndexAccess
                 Type: struct ConversionRates.TokenData storage ref
                 Source: "tokenData[token]"
                Identifier tokenData
                   Type: mapping(address => struct ConversionRates.TokenData storage ref)
                   Source: "tokenData"
                Identifier token
                   Type: contract ERC20
                   Source: "token"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenData[token].listed = true"
        Assignment using operator =
           Type: bool
           Source: "tokenData[token].listed = true"
          MemberAccess to member listed
             Type: bool
             Source: "tokenData[token].listed"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "listedTokens.push(token)"
        FunctionCall
           Type: uint256
           Source: "listedTokens.push(token)"
          MemberAccess to member push
             Type: function (contract ERC20) returns (uint256)
             Source: "listedTokens.push"
            Identifier listedTokens
               Type: contract ERC20[] storage ref
               Source: "listedTokens"
          Identifier token
             Type: contract ERC20
             Source: "token"
      IfStatement
         Source: "if (numTokensInCurrentCompactData == 0) {\r\n            tokenRatesCompactData.length++; // add new structure\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "numTokensInCurrentCompactData == 0"
          Identifier numTokensInCurrentCompactData
             Type: uint256
             Source: "numTokensInCurrentCompactData"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            tokenRatesCompactData.length++; // add new structure\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "tokenRatesCompactData.length++"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "tokenRatesCompactData.length++"
              MemberAccess to member length
                 Type: uint256
                 Source: "tokenRatesCompactData.length"
                Identifier tokenRatesCompactData
                   Type: bytes32[] storage ref
                   Source: "tokenRatesCompactData"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenData[token].compactDataArrayIndex = tokenRatesCompactData.length - 1"
        Assignment using operator =
           Type: uint256
           Source: "tokenData[token].compactDataArrayIndex = tokenRatesCompactData.length - 1"
          MemberAccess to member compactDataArrayIndex
             Type: uint256
             Source: "tokenData[token].compactDataArrayIndex"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
          BinaryOperation using operator -
             Type: uint256
             Source: "tokenRatesCompactData.length - 1"
            MemberAccess to member length
               Type: uint256
               Source: "tokenRatesCompactData.length"
              Identifier tokenRatesCompactData
                 Type: bytes32[] storage ref
                 Source: "tokenRatesCompactData"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenData[token].compactDataFieldIndex = numTokensInCurrentCompactData"
        Assignment using operator =
           Type: uint256
           Source: "tokenData[token].compactDataFieldIndex = numTokensInCurrentCompactData"
          MemberAccess to member compactDataFieldIndex
             Type: uint256
             Source: "tokenData[token].compactDataFieldIndex"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
          Identifier numTokensInCurrentCompactData
             Type: uint256
             Source: "numTokensInCurrentCompactData"
      ExpressionStatement
         Gas costs: 0
         Source: "numTokensInCurrentCompactData = (numTokensInCurrentCompactData + 1) % NUM_TOKENS_IN_COMPACT_DATA"
        Assignment using operator =
           Type: uint256
           Source: "numTokensInCurrentCompactData = (numTokensInCurrentCompactData + 1) % NUM_TOKENS_IN_COMPACT_DATA"
          Identifier numTokensInCurrentCompactData
             Type: uint256
             Source: "numTokensInCurrentCompactData"
          BinaryOperation using operator %
             Type: uint256
             Source: "(numTokensInCurrentCompactData + 1) % NUM_TOKENS_IN_COMPACT_DATA"
            TupleExpression
               Type: uint256
               Source: "(numTokensInCurrentCompactData + 1)"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "numTokensInCurrentCompactData + 1"
                Identifier numTokensInCurrentCompactData
                   Type: uint256
                   Source: "numTokensInCurrentCompactData"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
            Identifier NUM_TOKENS_IN_COMPACT_DATA
               Type: uint256
               Source: "NUM_TOKENS_IN_COMPACT_DATA"
      ExpressionStatement
         Gas costs: 0
         Source: "setGarbageToVolumeRecorder(token)"
        FunctionCall
           Type: tuple()
           Source: "setGarbageToVolumeRecorder(token)"
          Identifier setGarbageToVolumeRecorder
             Type: function (contract ERC20)
             Source: "setGarbageToVolumeRecorder"
          Identifier token
             Type: contract ERC20
             Source: "token"
  FunctionDefinition "setCompactData" - public
     Source: "function setCompactData(bytes14[] buy, bytes14[] sell, uint blockNumber, uint[] indices) public onlyOperator {\r\n\r\n        require(buy.length == sell.length);\r\n        require(indices.length == buy.length);\r\n        require(blockNumber <= 0xFFFFFFFF);\r\n\r\n        uint bytes14Offset = BYTES_14_OFFSET;\r\n\r\n        for (uint i = 0; i < indices.length; i++) {\r\n            require(indices[i] < tokenRatesCompactData.length);\r\n            uint data = uint(buy[i]) | uint(sell[i]) * bytes14Offset | (blockNumber * (bytes14Offset * bytes14Offset));\r\n            tokenRatesCompactData[indices[i]] = bytes32(data);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes14[] buy, bytes14[] sell, uint blockNumber, uint[] indices)"
      VariableDeclaration "buy"
         Type: bytes14[] memory
         Source: "bytes14[] buy"
        ArrayTypeName
           Source: "bytes14[]"
          ElementaryTypeName bytes14
             Source: "bytes14"
      VariableDeclaration "sell"
         Type: bytes14[] memory
         Source: "bytes14[] sell"
        ArrayTypeName
           Source: "bytes14[]"
          ElementaryTypeName bytes14
             Source: "bytes14"
      VariableDeclaration "blockNumber"
         Type: uint256
         Source: "uint blockNumber"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "indices"
         Type: uint256[] memory
         Source: "uint[] indices"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOperator"
       Gas costs: 0
       Source: "onlyOperator"
      Identifier onlyOperator
         Type: modifier ()
         Source: "onlyOperator"
    Block
       Source: "{\r\n\r\n        require(buy.length == sell.length);\r\n        require(indices.length == buy.length);\r\n        require(blockNumber <= 0xFFFFFFFF);\r\n\r\n        uint bytes14Offset = BYTES_14_OFFSET;\r\n\r\n        for (uint i = 0; i < indices.length; i++) {\r\n            require(indices[i] < tokenRatesCompactData.length);\r\n            uint data = uint(buy[i]) | uint(sell[i]) * bytes14Offset | (blockNumber * (bytes14Offset * bytes14Offset));\r\n            tokenRatesCompactData[indices[i]] = bytes32(data);\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(buy.length == sell.length)"
        FunctionCall
           Type: tuple()
           Source: "require(buy.length == sell.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "buy.length == sell.length"
            MemberAccess to member length
               Type: uint256
               Source: "buy.length"
              Identifier buy
                 Type: bytes14[] memory
                 Source: "buy"
            MemberAccess to member length
               Type: uint256
               Source: "sell.length"
              Identifier sell
                 Type: bytes14[] memory
                 Source: "sell"
      ExpressionStatement
         Gas costs: 0
         Source: "require(indices.length == buy.length)"
        FunctionCall
           Type: tuple()
           Source: "require(indices.length == buy.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "indices.length == buy.length"
            MemberAccess to member length
               Type: uint256
               Source: "indices.length"
              Identifier indices
                 Type: uint256[] memory
                 Source: "indices"
            MemberAccess to member length
               Type: uint256
               Source: "buy.length"
              Identifier buy
                 Type: bytes14[] memory
                 Source: "buy"
      ExpressionStatement
         Gas costs: 0
         Source: "require(blockNumber <= 0xFFFFFFFF)"
        FunctionCall
           Type: tuple()
           Source: "require(blockNumber <= 0xFFFFFFFF)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "blockNumber <= 0xFFFFFFFF"
            Identifier blockNumber
               Type: uint256
               Source: "blockNumber"
            Literal, token: [no token] value: 0xFFFFFFFF
               Type: int_const 4294967295
               Source: "0xFFFFFFFF"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint bytes14Offset = BYTES_14_OFFSET"
        VariableDeclaration "bytes14Offset"
           Type: uint256
           Source: "uint bytes14Offset"
          ElementaryTypeName uint
             Source: "uint"
        Identifier BYTES_14_OFFSET
           Type: uint256
           Source: "BYTES_14_OFFSET"
      ForStatement
         Source: "for (uint i = 0; i < indices.length; i++) {\r\n            require(indices[i] < tokenRatesCompactData.length);\r\n            uint data = uint(buy[i]) | uint(sell[i]) * bytes14Offset | (blockNumber * (bytes14Offset * bytes14Offset));\r\n            tokenRatesCompactData[indices[i]] = bytes32(data);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < indices.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "indices.length"
            Identifier indices
               Type: uint256[] memory
               Source: "indices"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            require(indices[i] < tokenRatesCompactData.length);\r\n            uint data = uint(buy[i]) | uint(sell[i]) * bytes14Offset | (blockNumber * (bytes14Offset * bytes14Offset));\r\n            tokenRatesCompactData[indices[i]] = bytes32(data);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require(indices[i] < tokenRatesCompactData.length)"
            FunctionCall
               Type: tuple()
               Source: "require(indices[i] < tokenRatesCompactData.length)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator <
                 Type: bool
                 Source: "indices[i] < tokenRatesCompactData.length"
                IndexAccess
                   Type: uint256
                   Source: "indices[i]"
                  Identifier indices
                     Type: uint256[] memory
                     Source: "indices"
                  Identifier i
                     Type: uint256
                     Source: "i"
                MemberAccess to member length
                   Type: uint256
                   Source: "tokenRatesCompactData.length"
                  Identifier tokenRatesCompactData
                     Type: bytes32[] storage ref
                     Source: "tokenRatesCompactData"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "uint data = uint(buy[i]) | uint(sell[i]) * bytes14Offset | (blockNumber * (bytes14Offset * bytes14Offset))"
            VariableDeclaration "data"
               Type: uint256
               Source: "uint data"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator |
               Type: uint256
               Source: "uint(buy[i]) | uint(sell[i]) * bytes14Offset | (blockNumber * (bytes14Offset * bytes14Offset))"
              BinaryOperation using operator |
                 Type: uint256
                 Source: "uint(buy[i]) | uint(sell[i]) * bytes14Offset"
                FunctionCall
                   Type: uint256
                   Source: "uint(buy[i])"
                  ElementaryTypeNameExpression uint
                     Type: type(uint256)
                     Source: "uint"
                  IndexAccess
                     Type: bytes14
                     Source: "buy[i]"
                    Identifier buy
                       Type: bytes14[] memory
                       Source: "buy"
                    Identifier i
                       Type: uint256
                       Source: "i"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "uint(sell[i]) * bytes14Offset"
                  FunctionCall
                     Type: uint256
                     Source: "uint(sell[i])"
                    ElementaryTypeNameExpression uint
                       Type: type(uint256)
                       Source: "uint"
                    IndexAccess
                       Type: bytes14
                       Source: "sell[i]"
                      Identifier sell
                         Type: bytes14[] memory
                         Source: "sell"
                      Identifier i
                         Type: uint256
                         Source: "i"
                  Identifier bytes14Offset
                     Type: uint256
                     Source: "bytes14Offset"
              TupleExpression
                 Type: uint256
                 Source: "(blockNumber * (bytes14Offset * bytes14Offset))"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "blockNumber * (bytes14Offset * bytes14Offset)"
                  Identifier blockNumber
                     Type: uint256
                     Source: "blockNumber"
                  TupleExpression
                     Type: uint256
                     Source: "(bytes14Offset * bytes14Offset)"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "bytes14Offset * bytes14Offset"
                      Identifier bytes14Offset
                         Type: uint256
                         Source: "bytes14Offset"
                      Identifier bytes14Offset
                         Type: uint256
                         Source: "bytes14Offset"
          ExpressionStatement
             Gas costs: 0
             Source: "tokenRatesCompactData[indices[i]] = bytes32(data)"
            Assignment using operator =
               Type: bytes32
               Source: "tokenRatesCompactData[indices[i]] = bytes32(data)"
              IndexAccess
                 Type: bytes32
                 Source: "tokenRatesCompactData[indices[i]]"
                Identifier tokenRatesCompactData
                   Type: bytes32[] storage ref
                   Source: "tokenRatesCompactData"
                IndexAccess
                   Type: uint256
                   Source: "indices[i]"
                  Identifier indices
                     Type: uint256[] memory
                     Source: "indices"
                  Identifier i
                     Type: uint256
                     Source: "i"
              FunctionCall
                 Type: bytes32
                 Source: "bytes32(data)"
                ElementaryTypeNameExpression bytes32
                   Type: type(bytes32)
                   Source: "bytes32"
                Identifier data
                   Type: uint256
                   Source: "data"
  FunctionDefinition "setBaseRate" - public
     Source: "function setBaseRate(\r\n        ERC20[] tokens,\r\n        uint[] baseBuy,\r\n        uint[] baseSell,\r\n        bytes14[] buy,\r\n        bytes14[] sell,\r\n        uint blockNumber,\r\n        uint[] indices\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(tokens.length == baseBuy.length);\r\n        require(tokens.length == baseSell.length);\r\n        require(sell.length == buy.length);\r\n        require(sell.length == indices.length);\r\n\r\n        for (uint ind = 0; ind < tokens.length; ind++) {\r\n            require(tokenData[tokens[ind]].listed);\r\n            tokenData[tokens[ind]].baseBuyRate = baseBuy[ind];\r\n            tokenData[tokens[ind]].baseSellRate = baseSell[ind];\r\n        }\r\n\r\n        setCompactData(buy, sell, blockNumber, indices);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        ERC20[] tokens,\r\n        uint[] baseBuy,\r\n        uint[] baseSell,\r\n        bytes14[] buy,\r\n        bytes14[] sell,\r\n        uint blockNumber,\r\n        uint[] indices\r\n    )"
      VariableDeclaration "tokens"
         Type: contract ERC20[] memory
         Source: "ERC20[] tokens"
        ArrayTypeName
           Source: "ERC20[]"
          UserDefinedTypeName "ERC20"
             Source: "ERC20"
      VariableDeclaration "baseBuy"
         Type: uint256[] memory
         Source: "uint[] baseBuy"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclaration "baseSell"
         Type: uint256[] memory
         Source: "uint[] baseSell"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclaration "buy"
         Type: bytes14[] memory
         Source: "bytes14[] buy"
        ArrayTypeName
           Source: "bytes14[]"
          ElementaryTypeName bytes14
             Source: "bytes14"
      VariableDeclaration "sell"
         Type: bytes14[] memory
         Source: "bytes14[] sell"
        ArrayTypeName
           Source: "bytes14[]"
          ElementaryTypeName bytes14
             Source: "bytes14"
      VariableDeclaration "blockNumber"
         Type: uint256
         Source: "uint blockNumber"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "indices"
         Type: uint256[] memory
         Source: "uint[] indices"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOperator"
       Gas costs: 0
       Source: "onlyOperator"
      Identifier onlyOperator
         Type: modifier ()
         Source: "onlyOperator"
    Block
       Source: "{\r\n        require(tokens.length == baseBuy.length);\r\n        require(tokens.length == baseSell.length);\r\n        require(sell.length == buy.length);\r\n        require(sell.length == indices.length);\r\n\r\n        for (uint ind = 0; ind < tokens.length; ind++) {\r\n            require(tokenData[tokens[ind]].listed);\r\n            tokenData[tokens[ind]].baseBuyRate = baseBuy[ind];\r\n            tokenData[tokens[ind]].baseSellRate = baseSell[ind];\r\n        }\r\n\r\n        setCompactData(buy, sell, blockNumber, indices);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(tokens.length == baseBuy.length)"
        FunctionCall
           Type: tuple()
           Source: "require(tokens.length == baseBuy.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "tokens.length == baseBuy.length"
            MemberAccess to member length
               Type: uint256
               Source: "tokens.length"
              Identifier tokens
                 Type: contract ERC20[] memory
                 Source: "tokens"
            MemberAccess to member length
               Type: uint256
               Source: "baseBuy.length"
              Identifier baseBuy
                 Type: uint256[] memory
                 Source: "baseBuy"
      ExpressionStatement
         Gas costs: 0
         Source: "require(tokens.length == baseSell.length)"
        FunctionCall
           Type: tuple()
           Source: "require(tokens.length == baseSell.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "tokens.length == baseSell.length"
            MemberAccess to member length
               Type: uint256
               Source: "tokens.length"
              Identifier tokens
                 Type: contract ERC20[] memory
                 Source: "tokens"
            MemberAccess to member length
               Type: uint256
               Source: "baseSell.length"
              Identifier baseSell
                 Type: uint256[] memory
                 Source: "baseSell"
      ExpressionStatement
         Gas costs: 0
         Source: "require(sell.length == buy.length)"
        FunctionCall
           Type: tuple()
           Source: "require(sell.length == buy.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "sell.length == buy.length"
            MemberAccess to member length
               Type: uint256
               Source: "sell.length"
              Identifier sell
                 Type: bytes14[] memory
                 Source: "sell"
            MemberAccess to member length
               Type: uint256
               Source: "buy.length"
              Identifier buy
                 Type: bytes14[] memory
                 Source: "buy"
      ExpressionStatement
         Gas costs: 0
         Source: "require(sell.length == indices.length)"
        FunctionCall
           Type: tuple()
           Source: "require(sell.length == indices.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "sell.length == indices.length"
            MemberAccess to member length
               Type: uint256
               Source: "sell.length"
              Identifier sell
                 Type: bytes14[] memory
                 Source: "sell"
            MemberAccess to member length
               Type: uint256
               Source: "indices.length"
              Identifier indices
                 Type: uint256[] memory
                 Source: "indices"
      ForStatement
         Source: "for (uint ind = 0; ind < tokens.length; ind++) {\r\n            require(tokenData[tokens[ind]].listed);\r\n            tokenData[tokens[ind]].baseBuyRate = baseBuy[ind];\r\n            tokenData[tokens[ind]].baseSellRate = baseSell[ind];\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint ind = 0"
          VariableDeclaration "ind"
             Type: uint256
             Source: "uint ind"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "ind < tokens.length"
          Identifier ind
             Type: uint256
             Source: "ind"
          MemberAccess to member length
             Type: uint256
             Source: "tokens.length"
            Identifier tokens
               Type: contract ERC20[] memory
               Source: "tokens"
        ExpressionStatement
           Gas costs: 0
           Source: "ind++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "ind++"
            Identifier ind
               Type: uint256
               Source: "ind"
        Block
           Source: "{\r\n            require(tokenData[tokens[ind]].listed);\r\n            tokenData[tokens[ind]].baseBuyRate = baseBuy[ind];\r\n            tokenData[tokens[ind]].baseSellRate = baseSell[ind];\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require(tokenData[tokens[ind]].listed)"
            FunctionCall
               Type: tuple()
               Source: "require(tokenData[tokens[ind]].listed)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              MemberAccess to member listed
                 Type: bool
                 Source: "tokenData[tokens[ind]].listed"
                IndexAccess
                   Type: struct ConversionRates.TokenData storage ref
                   Source: "tokenData[tokens[ind]]"
                  Identifier tokenData
                     Type: mapping(address => struct ConversionRates.TokenData storage ref)
                     Source: "tokenData"
                  IndexAccess
                     Type: contract ERC20
                     Source: "tokens[ind]"
                    Identifier tokens
                       Type: contract ERC20[] memory
                       Source: "tokens"
                    Identifier ind
                       Type: uint256
                       Source: "ind"
          ExpressionStatement
             Gas costs: 0
             Source: "tokenData[tokens[ind]].baseBuyRate = baseBuy[ind]"
            Assignment using operator =
               Type: uint256
               Source: "tokenData[tokens[ind]].baseBuyRate = baseBuy[ind]"
              MemberAccess to member baseBuyRate
                 Type: uint256
                 Source: "tokenData[tokens[ind]].baseBuyRate"
                IndexAccess
                   Type: struct ConversionRates.TokenData storage ref
                   Source: "tokenData[tokens[ind]]"
                  Identifier tokenData
                     Type: mapping(address => struct ConversionRates.TokenData storage ref)
                     Source: "tokenData"
                  IndexAccess
                     Type: contract ERC20
                     Source: "tokens[ind]"
                    Identifier tokens
                       Type: contract ERC20[] memory
                       Source: "tokens"
                    Identifier ind
                       Type: uint256
                       Source: "ind"
              IndexAccess
                 Type: uint256
                 Source: "baseBuy[ind]"
                Identifier baseBuy
                   Type: uint256[] memory
                   Source: "baseBuy"
                Identifier ind
                   Type: uint256
                   Source: "ind"
          ExpressionStatement
             Gas costs: 0
             Source: "tokenData[tokens[ind]].baseSellRate = baseSell[ind]"
            Assignment using operator =
               Type: uint256
               Source: "tokenData[tokens[ind]].baseSellRate = baseSell[ind]"
              MemberAccess to member baseSellRate
                 Type: uint256
                 Source: "tokenData[tokens[ind]].baseSellRate"
                IndexAccess
                   Type: struct ConversionRates.TokenData storage ref
                   Source: "tokenData[tokens[ind]]"
                  Identifier tokenData
                     Type: mapping(address => struct ConversionRates.TokenData storage ref)
                     Source: "tokenData"
                  IndexAccess
                     Type: contract ERC20
                     Source: "tokens[ind]"
                    Identifier tokens
                       Type: contract ERC20[] memory
                       Source: "tokens"
                    Identifier ind
                       Type: uint256
                       Source: "ind"
              IndexAccess
                 Type: uint256
                 Source: "baseSell[ind]"
                Identifier baseSell
                   Type: uint256[] memory
                   Source: "baseSell"
                Identifier ind
                   Type: uint256
                   Source: "ind"
      ExpressionStatement
         Gas costs: 0
         Source: "setCompactData(buy, sell, blockNumber, indices)"
        FunctionCall
           Type: tuple()
           Source: "setCompactData(buy, sell, blockNumber, indices)"
          Identifier setCompactData
             Type: function (bytes14[] memory,bytes14[] memory,uint256,uint256[] memory)
             Source: "setCompactData"
          Identifier buy
             Type: bytes14[] memory
             Source: "buy"
          Identifier sell
             Type: bytes14[] memory
             Source: "sell"
          Identifier blockNumber
             Type: uint256
             Source: "blockNumber"
          Identifier indices
             Type: uint256[] memory
             Source: "indices"
  FunctionDefinition "setQtyStepFunction" - public
     Source: "function setQtyStepFunction(\r\n        ERC20 token,\r\n        int[] xBuy,\r\n        int[] yBuy,\r\n        int[] xSell,\r\n        int[] ySell\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(xBuy.length == yBuy.length);\r\n        require(xSell.length == ySell.length);\r\n        require(tokenData[token].listed);\r\n\r\n        tokenData[token].buyRateQtyStepFunction = StepFunction(xBuy, yBuy);\r\n        tokenData[token].sellRateQtyStepFunction = StepFunction(xSell, ySell);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        ERC20 token,\r\n        int[] xBuy,\r\n        int[] yBuy,\r\n        int[] xSell,\r\n        int[] ySell\r\n    )"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "xBuy"
         Type: int256[] memory
         Source: "int[] xBuy"
        ArrayTypeName
           Source: "int[]"
          ElementaryTypeName int
             Source: "int"
      VariableDeclaration "yBuy"
         Type: int256[] memory
         Source: "int[] yBuy"
        ArrayTypeName
           Source: "int[]"
          ElementaryTypeName int
             Source: "int"
      VariableDeclaration "xSell"
         Type: int256[] memory
         Source: "int[] xSell"
        ArrayTypeName
           Source: "int[]"
          ElementaryTypeName int
             Source: "int"
      VariableDeclaration "ySell"
         Type: int256[] memory
         Source: "int[] ySell"
        ArrayTypeName
           Source: "int[]"
          ElementaryTypeName int
             Source: "int"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOperator"
       Gas costs: 0
       Source: "onlyOperator"
      Identifier onlyOperator
         Type: modifier ()
         Source: "onlyOperator"
    Block
       Source: "{\r\n        require(xBuy.length == yBuy.length);\r\n        require(xSell.length == ySell.length);\r\n        require(tokenData[token].listed);\r\n\r\n        tokenData[token].buyRateQtyStepFunction = StepFunction(xBuy, yBuy);\r\n        tokenData[token].sellRateQtyStepFunction = StepFunction(xSell, ySell);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(xBuy.length == yBuy.length)"
        FunctionCall
           Type: tuple()
           Source: "require(xBuy.length == yBuy.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "xBuy.length == yBuy.length"
            MemberAccess to member length
               Type: uint256
               Source: "xBuy.length"
              Identifier xBuy
                 Type: int256[] memory
                 Source: "xBuy"
            MemberAccess to member length
               Type: uint256
               Source: "yBuy.length"
              Identifier yBuy
                 Type: int256[] memory
                 Source: "yBuy"
      ExpressionStatement
         Gas costs: 0
         Source: "require(xSell.length == ySell.length)"
        FunctionCall
           Type: tuple()
           Source: "require(xSell.length == ySell.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "xSell.length == ySell.length"
            MemberAccess to member length
               Type: uint256
               Source: "xSell.length"
              Identifier xSell
                 Type: int256[] memory
                 Source: "xSell"
            MemberAccess to member length
               Type: uint256
               Source: "ySell.length"
              Identifier ySell
                 Type: int256[] memory
                 Source: "ySell"
      ExpressionStatement
         Gas costs: 0
         Source: "require(tokenData[token].listed)"
        FunctionCall
           Type: tuple()
           Source: "require(tokenData[token].listed)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          MemberAccess to member listed
             Type: bool
             Source: "tokenData[token].listed"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenData[token].buyRateQtyStepFunction = StepFunction(xBuy, yBuy)"
        Assignment using operator =
           Type: struct ConversionRates.StepFunction storage ref
           Source: "tokenData[token].buyRateQtyStepFunction = StepFunction(xBuy, yBuy)"
          MemberAccess to member buyRateQtyStepFunction
             Type: struct ConversionRates.StepFunction storage ref
             Source: "tokenData[token].buyRateQtyStepFunction"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
          FunctionCall
             Type: struct ConversionRates.StepFunction memory
             Source: "StepFunction(xBuy, yBuy)"
            Identifier StepFunction
               Type: type(struct ConversionRates.StepFunction storage pointer)
               Source: "StepFunction"
            Identifier xBuy
               Type: int256[] memory
               Source: "xBuy"
            Identifier yBuy
               Type: int256[] memory
               Source: "yBuy"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenData[token].sellRateQtyStepFunction = StepFunction(xSell, ySell)"
        Assignment using operator =
           Type: struct ConversionRates.StepFunction storage ref
           Source: "tokenData[token].sellRateQtyStepFunction = StepFunction(xSell, ySell)"
          MemberAccess to member sellRateQtyStepFunction
             Type: struct ConversionRates.StepFunction storage ref
             Source: "tokenData[token].sellRateQtyStepFunction"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
          FunctionCall
             Type: struct ConversionRates.StepFunction memory
             Source: "StepFunction(xSell, ySell)"
            Identifier StepFunction
               Type: type(struct ConversionRates.StepFunction storage pointer)
               Source: "StepFunction"
            Identifier xSell
               Type: int256[] memory
               Source: "xSell"
            Identifier ySell
               Type: int256[] memory
               Source: "ySell"
  FunctionDefinition "setImbalanceStepFunction" - public
     Source: "function setImbalanceStepFunction(\r\n        ERC20 token,\r\n        int[] xBuy,\r\n        int[] yBuy,\r\n        int[] xSell,\r\n        int[] ySell\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(xBuy.length == yBuy.length);\r\n        require(xSell.length == ySell.length);\r\n        require(tokenData[token].listed);\r\n\r\n        tokenData[token].buyRateImbalanceStepFunction = StepFunction(xBuy, yBuy);\r\n        tokenData[token].sellRateImbalanceStepFunction = StepFunction(xSell, ySell);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        ERC20 token,\r\n        int[] xBuy,\r\n        int[] yBuy,\r\n        int[] xSell,\r\n        int[] ySell\r\n    )"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "xBuy"
         Type: int256[] memory
         Source: "int[] xBuy"
        ArrayTypeName
           Source: "int[]"
          ElementaryTypeName int
             Source: "int"
      VariableDeclaration "yBuy"
         Type: int256[] memory
         Source: "int[] yBuy"
        ArrayTypeName
           Source: "int[]"
          ElementaryTypeName int
             Source: "int"
      VariableDeclaration "xSell"
         Type: int256[] memory
         Source: "int[] xSell"
        ArrayTypeName
           Source: "int[]"
          ElementaryTypeName int
             Source: "int"
      VariableDeclaration "ySell"
         Type: int256[] memory
         Source: "int[] ySell"
        ArrayTypeName
           Source: "int[]"
          ElementaryTypeName int
             Source: "int"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOperator"
       Gas costs: 0
       Source: "onlyOperator"
      Identifier onlyOperator
         Type: modifier ()
         Source: "onlyOperator"
    Block
       Source: "{\r\n        require(xBuy.length == yBuy.length);\r\n        require(xSell.length == ySell.length);\r\n        require(tokenData[token].listed);\r\n\r\n        tokenData[token].buyRateImbalanceStepFunction = StepFunction(xBuy, yBuy);\r\n        tokenData[token].sellRateImbalanceStepFunction = StepFunction(xSell, ySell);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(xBuy.length == yBuy.length)"
        FunctionCall
           Type: tuple()
           Source: "require(xBuy.length == yBuy.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "xBuy.length == yBuy.length"
            MemberAccess to member length
               Type: uint256
               Source: "xBuy.length"
              Identifier xBuy
                 Type: int256[] memory
                 Source: "xBuy"
            MemberAccess to member length
               Type: uint256
               Source: "yBuy.length"
              Identifier yBuy
                 Type: int256[] memory
                 Source: "yBuy"
      ExpressionStatement
         Gas costs: 0
         Source: "require(xSell.length == ySell.length)"
        FunctionCall
           Type: tuple()
           Source: "require(xSell.length == ySell.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "xSell.length == ySell.length"
            MemberAccess to member length
               Type: uint256
               Source: "xSell.length"
              Identifier xSell
                 Type: int256[] memory
                 Source: "xSell"
            MemberAccess to member length
               Type: uint256
               Source: "ySell.length"
              Identifier ySell
                 Type: int256[] memory
                 Source: "ySell"
      ExpressionStatement
         Gas costs: 0
         Source: "require(tokenData[token].listed)"
        FunctionCall
           Type: tuple()
           Source: "require(tokenData[token].listed)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          MemberAccess to member listed
             Type: bool
             Source: "tokenData[token].listed"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenData[token].buyRateImbalanceStepFunction = StepFunction(xBuy, yBuy)"
        Assignment using operator =
           Type: struct ConversionRates.StepFunction storage ref
           Source: "tokenData[token].buyRateImbalanceStepFunction = StepFunction(xBuy, yBuy)"
          MemberAccess to member buyRateImbalanceStepFunction
             Type: struct ConversionRates.StepFunction storage ref
             Source: "tokenData[token].buyRateImbalanceStepFunction"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
          FunctionCall
             Type: struct ConversionRates.StepFunction memory
             Source: "StepFunction(xBuy, yBuy)"
            Identifier StepFunction
               Type: type(struct ConversionRates.StepFunction storage pointer)
               Source: "StepFunction"
            Identifier xBuy
               Type: int256[] memory
               Source: "xBuy"
            Identifier yBuy
               Type: int256[] memory
               Source: "yBuy"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenData[token].sellRateImbalanceStepFunction = StepFunction(xSell, ySell)"
        Assignment using operator =
           Type: struct ConversionRates.StepFunction storage ref
           Source: "tokenData[token].sellRateImbalanceStepFunction = StepFunction(xSell, ySell)"
          MemberAccess to member sellRateImbalanceStepFunction
             Type: struct ConversionRates.StepFunction storage ref
             Source: "tokenData[token].sellRateImbalanceStepFunction"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
          FunctionCall
             Type: struct ConversionRates.StepFunction memory
             Source: "StepFunction(xSell, ySell)"
            Identifier StepFunction
               Type: type(struct ConversionRates.StepFunction storage pointer)
               Source: "StepFunction"
            Identifier xSell
               Type: int256[] memory
               Source: "xSell"
            Identifier ySell
               Type: int256[] memory
               Source: "ySell"
  FunctionDefinition "setValidRateDurationInBlocks" - public
     Source: "function setValidRateDurationInBlocks(uint duration) public onlyAdmin {\r\n        validRateDurationInBlocks = duration;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint duration)"
      VariableDeclaration "duration"
         Type: uint256
         Source: "uint duration"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        validRateDurationInBlocks = duration;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "validRateDurationInBlocks = duration"
        Assignment using operator =
           Type: uint256
           Source: "validRateDurationInBlocks = duration"
          Identifier validRateDurationInBlocks
             Type: uint256
             Source: "validRateDurationInBlocks"
          Identifier duration
             Type: uint256
             Source: "duration"
  FunctionDefinition "enableTokenTrade" - public
     Source: "function enableTokenTrade(ERC20 token) public onlyAdmin {\r\n        require(tokenData[token].listed);\r\n        require(tokenControlInfo[token].minimalRecordResolution != 0);\r\n        tokenData[token].enabled = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        require(tokenData[token].listed);\r\n        require(tokenControlInfo[token].minimalRecordResolution != 0);\r\n        tokenData[token].enabled = true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(tokenData[token].listed)"
        FunctionCall
           Type: tuple()
           Source: "require(tokenData[token].listed)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          MemberAccess to member listed
             Type: bool
             Source: "tokenData[token].listed"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
      ExpressionStatement
         Gas costs: 0
         Source: "require(tokenControlInfo[token].minimalRecordResolution != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(tokenControlInfo[token].minimalRecordResolution != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "tokenControlInfo[token].minimalRecordResolution != 0"
            MemberAccess to member minimalRecordResolution
               Type: uint256
               Source: "tokenControlInfo[token].minimalRecordResolution"
              IndexAccess
                 Type: struct VolumeImbalanceRecorder.TokenControlInfo storage ref
                 Source: "tokenControlInfo[token]"
                Identifier tokenControlInfo
                   Type: mapping(address => struct VolumeImbalanceRecorder.TokenControlInfo storage ref)
                   Source: "tokenControlInfo"
                Identifier token
                   Type: contract ERC20
                   Source: "token"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenData[token].enabled = true"
        Assignment using operator =
           Type: bool
           Source: "tokenData[token].enabled = true"
          MemberAccess to member enabled
             Type: bool
             Source: "tokenData[token].enabled"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "disableTokenTrade" - public
     Source: "function disableTokenTrade(ERC20 token) public onlyAlerter {\r\n        require(tokenData[token].listed);\r\n        tokenData[token].enabled = false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAlerter"
       Gas costs: 0
       Source: "onlyAlerter"
      Identifier onlyAlerter
         Type: modifier ()
         Source: "onlyAlerter"
    Block
       Source: "{\r\n        require(tokenData[token].listed);\r\n        tokenData[token].enabled = false;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(tokenData[token].listed)"
        FunctionCall
           Type: tuple()
           Source: "require(tokenData[token].listed)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          MemberAccess to member listed
             Type: bool
             Source: "tokenData[token].listed"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenData[token].enabled = false"
        Assignment using operator =
           Type: bool
           Source: "tokenData[token].enabled = false"
          MemberAccess to member enabled
             Type: bool
             Source: "tokenData[token].enabled"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "setReserveAddress" - public
     Source: "function setReserveAddress(address reserve) public onlyAdmin {\r\n        reserveContract = reserve;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address reserve)"
      VariableDeclaration "reserve"
         Type: address
         Source: "address reserve"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        reserveContract = reserve;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "reserveContract = reserve"
        Assignment using operator =
           Type: address
           Source: "reserveContract = reserve"
          Identifier reserveContract
             Type: address
             Source: "reserveContract"
          Identifier reserve
             Type: address
             Source: "reserve"
  FunctionDefinition "recordImbalance" - public
     Source: "function recordImbalance(\r\n        ERC20 token,\r\n        int buyAmount,\r\n        uint rateUpdateBlock,\r\n        uint currentBlock\r\n    )\r\n        public\r\n    {\r\n        require(msg.sender == reserveContract);\r\n\r\n        if (rateUpdateBlock == 0) rateUpdateBlock = getRateUpdateBlock(token);\r\n\r\n        return addImbalance(token, buyAmount, rateUpdateBlock, currentBlock);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        ERC20 token,\r\n        int buyAmount,\r\n        uint rateUpdateBlock,\r\n        uint currentBlock\r\n    )"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "buyAmount"
         Type: int256
         Source: "int buyAmount"
        ElementaryTypeName int
           Source: "int"
      VariableDeclaration "rateUpdateBlock"
         Type: uint256
         Source: "uint rateUpdateBlock"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "currentBlock"
         Type: uint256
         Source: "uint currentBlock"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(msg.sender == reserveContract);\r\n\r\n        if (rateUpdateBlock == 0) rateUpdateBlock = getRateUpdateBlock(token);\r\n\r\n        return addImbalance(token, buyAmount, rateUpdateBlock, currentBlock);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.sender == reserveContract)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == reserveContract)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == reserveContract"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier reserveContract
               Type: address
               Source: "reserveContract"
      IfStatement
         Source: "if (rateUpdateBlock == 0) rateUpdateBlock = getRateUpdateBlock(token)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "rateUpdateBlock == 0"
          Identifier rateUpdateBlock
             Type: uint256
             Source: "rateUpdateBlock"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 0
           Source: "rateUpdateBlock = getRateUpdateBlock(token)"
          Assignment using operator =
             Type: uint256
             Source: "rateUpdateBlock = getRateUpdateBlock(token)"
            Identifier rateUpdateBlock
               Type: uint256
               Source: "rateUpdateBlock"
            FunctionCall
               Type: uint256
               Source: "getRateUpdateBlock(token)"
              Identifier getRateUpdateBlock
                 Type: function (contract ERC20) view returns (uint256)
                 Source: "getRateUpdateBlock"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
      Return
         Gas costs: 0
         Source: "return addImbalance(token, buyAmount, rateUpdateBlock, currentBlock)"
        FunctionCall
           Type: tuple()
           Source: "addImbalance(token, buyAmount, rateUpdateBlock, currentBlock)"
          Identifier addImbalance
             Type: function (contract ERC20,int256,uint256,uint256)
             Source: "addImbalance"
          Identifier token
             Type: contract ERC20
             Source: "token"
          Identifier buyAmount
             Type: int256
             Source: "buyAmount"
          Identifier rateUpdateBlock
             Type: uint256
             Source: "rateUpdateBlock"
          Identifier currentBlock
             Type: uint256
             Source: "currentBlock"
  FunctionDefinition "getRate" - public - const
     Source: "function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint) {\r\n        // check if trade is enabled\r\n        if (!tokenData[token].enabled) return 0;\r\n        if (tokenControlInfo[token].minimalRecordResolution == 0) return 0; // token control info not set\r\n\r\n        // get rate update block\r\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\r\n\r\n        uint updateRateBlock = getLast4Bytes(compactData);\r\n        if (currentBlockNumber >= updateRateBlock + validRateDurationInBlocks) return 0; // rate is expired\r\n        // check imbalance\r\n        int totalImbalance;\r\n        int blockImbalance;\r\n        (totalImbalance, blockImbalance) = getImbalance(token, updateRateBlock, currentBlockNumber);\r\n\r\n        // calculate actual rate\r\n        int imbalanceQty;\r\n        int extraBps;\r\n        int8 rateUpdate;\r\n        uint rate;\r\n\r\n        if (buy) {\r\n            // start with base rate\r\n            rate = tokenData[token].baseBuyRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, true);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            qty = getTokenQty(token, rate, qty);\r\n            imbalanceQty = int(qty);\r\n            totalImbalance += imbalanceQty;\r\n\r\n            // add qty overhead\r\n            extraBps = executeStepFunction(tokenData[token].buyRateQtyStepFunction, int(qty));\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(tokenData[token].buyRateImbalanceStepFunction, totalImbalance);\r\n            rate = addBps(rate, extraBps);\r\n        } else {\r\n            // start with base rate\r\n            rate = tokenData[token].baseSellRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, false);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            imbalanceQty = -1 * int(qty);\r\n            totalImbalance += imbalanceQty;\r\n\r\n            // add qty overhead\r\n            extraBps = executeStepFunction(tokenData[token].sellRateQtyStepFunction, int(qty));\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(tokenData[token].sellRateImbalanceStepFunction, totalImbalance);\r\n            rate = addBps(rate, extraBps);\r\n        }\r\n\r\n        if (abs(totalImbalance + imbalanceQty) >= getMaxTotalImbalance(token)) return 0;\r\n        if (abs(blockImbalance + imbalanceQty) >= getMaxPerBlockImbalance(token)) return 0;\r\n\r\n        return rate;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token, uint currentBlockNumber, bool buy, uint qty)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "currentBlockNumber"
         Type: uint256
         Source: "uint currentBlockNumber"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "buy"
         Type: bool
         Source: "bool buy"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "qty"
         Type: uint256
         Source: "uint qty"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        // check if trade is enabled\r\n        if (!tokenData[token].enabled) return 0;\r\n        if (tokenControlInfo[token].minimalRecordResolution == 0) return 0; // token control info not set\r\n\r\n        // get rate update block\r\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\r\n\r\n        uint updateRateBlock = getLast4Bytes(compactData);\r\n        if (currentBlockNumber >= updateRateBlock + validRateDurationInBlocks) return 0; // rate is expired\r\n        // check imbalance\r\n        int totalImbalance;\r\n        int blockImbalance;\r\n        (totalImbalance, blockImbalance) = getImbalance(token, updateRateBlock, currentBlockNumber);\r\n\r\n        // calculate actual rate\r\n        int imbalanceQty;\r\n        int extraBps;\r\n        int8 rateUpdate;\r\n        uint rate;\r\n\r\n        if (buy) {\r\n            // start with base rate\r\n            rate = tokenData[token].baseBuyRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, true);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            qty = getTokenQty(token, rate, qty);\r\n            imbalanceQty = int(qty);\r\n            totalImbalance += imbalanceQty;\r\n\r\n            // add qty overhead\r\n            extraBps = executeStepFunction(tokenData[token].buyRateQtyStepFunction, int(qty));\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(tokenData[token].buyRateImbalanceStepFunction, totalImbalance);\r\n            rate = addBps(rate, extraBps);\r\n        } else {\r\n            // start with base rate\r\n            rate = tokenData[token].baseSellRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, false);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            imbalanceQty = -1 * int(qty);\r\n            totalImbalance += imbalanceQty;\r\n\r\n            // add qty overhead\r\n            extraBps = executeStepFunction(tokenData[token].sellRateQtyStepFunction, int(qty));\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(tokenData[token].sellRateImbalanceStepFunction, totalImbalance);\r\n            rate = addBps(rate, extraBps);\r\n        }\r\n\r\n        if (abs(totalImbalance + imbalanceQty) >= getMaxTotalImbalance(token)) return 0;\r\n        if (abs(blockImbalance + imbalanceQty) >= getMaxPerBlockImbalance(token)) return 0;\r\n\r\n        return rate;\r\n    }"
      IfStatement
         Source: "if (!tokenData[token].enabled) return 0"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 0
           Source: "!tokenData[token].enabled"
          MemberAccess to member enabled
             Type: bool
             Source: "tokenData[token].enabled"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      IfStatement
         Source: "if (tokenControlInfo[token].minimalRecordResolution == 0) return 0"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "tokenControlInfo[token].minimalRecordResolution == 0"
          MemberAccess to member minimalRecordResolution
             Type: uint256
             Source: "tokenControlInfo[token].minimalRecordResolution"
            IndexAccess
               Type: struct VolumeImbalanceRecorder.TokenControlInfo storage ref
               Source: "tokenControlInfo[token]"
              Identifier tokenControlInfo
                 Type: mapping(address => struct VolumeImbalanceRecorder.TokenControlInfo storage ref)
                 Source: "tokenControlInfo"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex]"
        VariableDeclaration "compactData"
           Type: bytes32
           Source: "bytes32 compactData"
          ElementaryTypeName bytes32
             Source: "bytes32"
        IndexAccess
           Type: bytes32
           Source: "tokenRatesCompactData[tokenData[token].compactDataArrayIndex]"
          Identifier tokenRatesCompactData
             Type: bytes32[] storage ref
             Source: "tokenRatesCompactData"
          MemberAccess to member compactDataArrayIndex
             Type: uint256
             Source: "tokenData[token].compactDataArrayIndex"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint updateRateBlock = getLast4Bytes(compactData)"
        VariableDeclaration "updateRateBlock"
           Type: uint256
           Source: "uint updateRateBlock"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getLast4Bytes(compactData)"
          Identifier getLast4Bytes
             Type: function (bytes32) pure returns (uint256)
             Source: "getLast4Bytes"
          Identifier compactData
             Type: bytes32
             Source: "compactData"
      IfStatement
         Source: "if (currentBlockNumber >= updateRateBlock + validRateDurationInBlocks) return 0"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 0
           Source: "currentBlockNumber >= updateRateBlock + validRateDurationInBlocks"
          Identifier currentBlockNumber
             Type: uint256
             Source: "currentBlockNumber"
          BinaryOperation using operator +
             Type: uint256
             Source: "updateRateBlock + validRateDurationInBlocks"
            Identifier updateRateBlock
               Type: uint256
               Source: "updateRateBlock"
            Identifier validRateDurationInBlocks
               Type: uint256
               Source: "validRateDurationInBlocks"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "int totalImbalance"
        VariableDeclaration "totalImbalance"
           Type: int256
           Source: "int totalImbalance"
          ElementaryTypeName int
             Source: "int"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "int blockImbalance"
        VariableDeclaration "blockImbalance"
           Type: int256
           Source: "int blockImbalance"
          ElementaryTypeName int
             Source: "int"
      ExpressionStatement
         Gas costs: 0
         Source: "(totalImbalance, blockImbalance) = getImbalance(token, updateRateBlock, currentBlockNumber)"
        Assignment using operator =
           Type: tuple()
           Source: "(totalImbalance, blockImbalance) = getImbalance(token, updateRateBlock, currentBlockNumber)"
          TupleExpression
             Type: tuple(int256,int256)
             Source: "(totalImbalance, blockImbalance)"
            Identifier totalImbalance
               Type: int256
               Source: "totalImbalance"
            Identifier blockImbalance
               Type: int256
               Source: "blockImbalance"
          FunctionCall
             Type: tuple(int256,int256)
             Source: "getImbalance(token, updateRateBlock, currentBlockNumber)"
            Identifier getImbalance
               Type: function (contract ERC20,uint256,uint256) view returns (int256,int256)
               Source: "getImbalance"
            Identifier token
               Type: contract ERC20
               Source: "token"
            Identifier updateRateBlock
               Type: uint256
               Source: "updateRateBlock"
            Identifier currentBlockNumber
               Type: uint256
               Source: "currentBlockNumber"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "int imbalanceQty"
        VariableDeclaration "imbalanceQty"
           Type: int256
           Source: "int imbalanceQty"
          ElementaryTypeName int
             Source: "int"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "int extraBps"
        VariableDeclaration "extraBps"
           Type: int256
           Source: "int extraBps"
          ElementaryTypeName int
             Source: "int"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "int8 rateUpdate"
        VariableDeclaration "rateUpdate"
           Type: int8
           Source: "int8 rateUpdate"
          ElementaryTypeName int8
             Source: "int8"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint rate"
        VariableDeclaration "rate"
           Type: uint256
           Source: "uint rate"
          ElementaryTypeName uint
             Source: "uint"
      IfStatement
         Source: "if (buy) {\r\n            // start with base rate\r\n            rate = tokenData[token].baseBuyRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, true);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            qty = getTokenQty(token, rate, qty);\r\n            imbalanceQty = int(qty);\r\n            totalImbalance += imbalanceQty;\r\n\r\n            // add qty overhead\r\n            extraBps = executeStepFunction(tokenData[token].buyRateQtyStepFunction, int(qty));\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(tokenData[token].buyRateImbalanceStepFunction, totalImbalance);\r\n            rate = addBps(rate, extraBps);\r\n        } else {\r\n            // start with base rate\r\n            rate = tokenData[token].baseSellRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, false);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            imbalanceQty = -1 * int(qty);\r\n            totalImbalance += imbalanceQty;\r\n\r\n            // add qty overhead\r\n            extraBps = executeStepFunction(tokenData[token].sellRateQtyStepFunction, int(qty));\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(tokenData[token].sellRateImbalanceStepFunction, totalImbalance);\r\n            rate = addBps(rate, extraBps);\r\n        }"
        Identifier buy
           Type: bool
           Gas costs: 0
           Source: "buy"
        Block
           Source: "{\r\n            // start with base rate\r\n            rate = tokenData[token].baseBuyRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, true);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            qty = getTokenQty(token, rate, qty);\r\n            imbalanceQty = int(qty);\r\n            totalImbalance += imbalanceQty;\r\n\r\n            // add qty overhead\r\n            extraBps = executeStepFunction(tokenData[token].buyRateQtyStepFunction, int(qty));\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(tokenData[token].buyRateImbalanceStepFunction, totalImbalance);\r\n            rate = addBps(rate, extraBps);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "rate = tokenData[token].baseBuyRate"
            Assignment using operator =
               Type: uint256
               Source: "rate = tokenData[token].baseBuyRate"
              Identifier rate
                 Type: uint256
                 Source: "rate"
              MemberAccess to member baseBuyRate
                 Type: uint256
                 Source: "tokenData[token].baseBuyRate"
                IndexAccess
                   Type: struct ConversionRates.TokenData storage ref
                   Source: "tokenData[token]"
                  Identifier tokenData
                     Type: mapping(address => struct ConversionRates.TokenData storage ref)
                     Source: "tokenData"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
          ExpressionStatement
             Gas costs: 0
             Source: "rateUpdate = getRateByteFromCompactData(compactData, token, true)"
            Assignment using operator =
               Type: int8
               Source: "rateUpdate = getRateByteFromCompactData(compactData, token, true)"
              Identifier rateUpdate
                 Type: int8
                 Source: "rateUpdate"
              FunctionCall
                 Type: int8
                 Source: "getRateByteFromCompactData(compactData, token, true)"
                Identifier getRateByteFromCompactData
                   Type: function (bytes32,contract ERC20,bool) view returns (int8)
                   Source: "getRateByteFromCompactData"
                Identifier compactData
                   Type: bytes32
                   Source: "compactData"
                Identifier token
                   Type: contract ERC20
                   Source: "token"
                Literal, token: true value: true
                   Type: bool
                   Source: "true"
          ExpressionStatement
             Gas costs: 0
             Source: "extraBps = int(rateUpdate) * 10"
            Assignment using operator =
               Type: int256
               Source: "extraBps = int(rateUpdate) * 10"
              Identifier extraBps
                 Type: int256
                 Source: "extraBps"
              BinaryOperation using operator *
                 Type: int256
                 Source: "int(rateUpdate) * 10"
                FunctionCall
                   Type: int256
                   Source: "int(rateUpdate)"
                  ElementaryTypeNameExpression int
                     Type: type(int256)
                     Source: "int"
                  Identifier rateUpdate
                     Type: int8
                     Source: "rateUpdate"
                Literal, token: [no token] value: 10
                   Type: int_const 10
                   Source: "10"
          ExpressionStatement
             Gas costs: 0
             Source: "rate = addBps(rate, extraBps)"
            Assignment using operator =
               Type: uint256
               Source: "rate = addBps(rate, extraBps)"
              Identifier rate
                 Type: uint256
                 Source: "rate"
              FunctionCall
                 Type: uint256
                 Source: "addBps(rate, extraBps)"
                Identifier addBps
                   Type: function (uint256,int256) pure returns (uint256)
                   Source: "addBps"
                Identifier rate
                   Type: uint256
                   Source: "rate"
                Identifier extraBps
                   Type: int256
                   Source: "extraBps"
          ExpressionStatement
             Gas costs: 0
             Source: "qty = getTokenQty(token, rate, qty)"
            Assignment using operator =
               Type: uint256
               Source: "qty = getTokenQty(token, rate, qty)"
              Identifier qty
                 Type: uint256
                 Source: "qty"
              FunctionCall
                 Type: uint256
                 Source: "getTokenQty(token, rate, qty)"
                Identifier getTokenQty
                   Type: function (contract ERC20,uint256,uint256) view returns (uint256)
                   Source: "getTokenQty"
                Identifier token
                   Type: contract ERC20
                   Source: "token"
                Identifier rate
                   Type: uint256
                   Source: "rate"
                Identifier qty
                   Type: uint256
                   Source: "qty"
          ExpressionStatement
             Gas costs: 0
             Source: "imbalanceQty = int(qty)"
            Assignment using operator =
               Type: int256
               Source: "imbalanceQty = int(qty)"
              Identifier imbalanceQty
                 Type: int256
                 Source: "imbalanceQty"
              FunctionCall
                 Type: int256
                 Source: "int(qty)"
                ElementaryTypeNameExpression int
                   Type: type(int256)
                   Source: "int"
                Identifier qty
                   Type: uint256
                   Source: "qty"
          ExpressionStatement
             Gas costs: 0
             Source: "totalImbalance += imbalanceQty"
            Assignment using operator +=
               Type: int256
               Source: "totalImbalance += imbalanceQty"
              Identifier totalImbalance
                 Type: int256
                 Source: "totalImbalance"
              Identifier imbalanceQty
                 Type: int256
                 Source: "imbalanceQty"
          ExpressionStatement
             Gas costs: 0
             Source: "extraBps = executeStepFunction(tokenData[token].buyRateQtyStepFunction, int(qty))"
            Assignment using operator =
               Type: int256
               Source: "extraBps = executeStepFunction(tokenData[token].buyRateQtyStepFunction, int(qty))"
              Identifier extraBps
                 Type: int256
                 Source: "extraBps"
              FunctionCall
                 Type: int256
                 Source: "executeStepFunction(tokenData[token].buyRateQtyStepFunction, int(qty))"
                Identifier executeStepFunction
                   Type: function (struct ConversionRates.StepFunction memory,int256) pure returns (int256)
                   Source: "executeStepFunction"
                MemberAccess to member buyRateQtyStepFunction
                   Type: struct ConversionRates.StepFunction storage ref
                   Source: "tokenData[token].buyRateQtyStepFunction"
                  IndexAccess
                     Type: struct ConversionRates.TokenData storage ref
                     Source: "tokenData[token]"
                    Identifier tokenData
                       Type: mapping(address => struct ConversionRates.TokenData storage ref)
                       Source: "tokenData"
                    Identifier token
                       Type: contract ERC20
                       Source: "token"
                FunctionCall
                   Type: int256
                   Source: "int(qty)"
                  ElementaryTypeNameExpression int
                     Type: type(int256)
                     Source: "int"
                  Identifier qty
                     Type: uint256
                     Source: "qty"
          ExpressionStatement
             Gas costs: 0
             Source: "rate = addBps(rate, extraBps)"
            Assignment using operator =
               Type: uint256
               Source: "rate = addBps(rate, extraBps)"
              Identifier rate
                 Type: uint256
                 Source: "rate"
              FunctionCall
                 Type: uint256
                 Source: "addBps(rate, extraBps)"
                Identifier addBps
                   Type: function (uint256,int256) pure returns (uint256)
                   Source: "addBps"
                Identifier rate
                   Type: uint256
                   Source: "rate"
                Identifier extraBps
                   Type: int256
                   Source: "extraBps"
          ExpressionStatement
             Gas costs: 0
             Source: "extraBps = executeStepFunction(tokenData[token].buyRateImbalanceStepFunction, totalImbalance)"
            Assignment using operator =
               Type: int256
               Source: "extraBps = executeStepFunction(tokenData[token].buyRateImbalanceStepFunction, totalImbalance)"
              Identifier extraBps
                 Type: int256
                 Source: "extraBps"
              FunctionCall
                 Type: int256
                 Source: "executeStepFunction(tokenData[token].buyRateImbalanceStepFunction, totalImbalance)"
                Identifier executeStepFunction
                   Type: function (struct ConversionRates.StepFunction memory,int256) pure returns (int256)
                   Source: "executeStepFunction"
                MemberAccess to member buyRateImbalanceStepFunction
                   Type: struct ConversionRates.StepFunction storage ref
                   Source: "tokenData[token].buyRateImbalanceStepFunction"
                  IndexAccess
                     Type: struct ConversionRates.TokenData storage ref
                     Source: "tokenData[token]"
                    Identifier tokenData
                       Type: mapping(address => struct ConversionRates.TokenData storage ref)
                       Source: "tokenData"
                    Identifier token
                       Type: contract ERC20
                       Source: "token"
                Identifier totalImbalance
                   Type: int256
                   Source: "totalImbalance"
          ExpressionStatement
             Gas costs: 0
             Source: "rate = addBps(rate, extraBps)"
            Assignment using operator =
               Type: uint256
               Source: "rate = addBps(rate, extraBps)"
              Identifier rate
                 Type: uint256
                 Source: "rate"
              FunctionCall
                 Type: uint256
                 Source: "addBps(rate, extraBps)"
                Identifier addBps
                   Type: function (uint256,int256) pure returns (uint256)
                   Source: "addBps"
                Identifier rate
                   Type: uint256
                   Source: "rate"
                Identifier extraBps
                   Type: int256
                   Source: "extraBps"
        Block
           Source: "{\r\n            // start with base rate\r\n            rate = tokenData[token].baseSellRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, false);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            imbalanceQty = -1 * int(qty);\r\n            totalImbalance += imbalanceQty;\r\n\r\n            // add qty overhead\r\n            extraBps = executeStepFunction(tokenData[token].sellRateQtyStepFunction, int(qty));\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(tokenData[token].sellRateImbalanceStepFunction, totalImbalance);\r\n            rate = addBps(rate, extraBps);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "rate = tokenData[token].baseSellRate"
            Assignment using operator =
               Type: uint256
               Source: "rate = tokenData[token].baseSellRate"
              Identifier rate
                 Type: uint256
                 Source: "rate"
              MemberAccess to member baseSellRate
                 Type: uint256
                 Source: "tokenData[token].baseSellRate"
                IndexAccess
                   Type: struct ConversionRates.TokenData storage ref
                   Source: "tokenData[token]"
                  Identifier tokenData
                     Type: mapping(address => struct ConversionRates.TokenData storage ref)
                     Source: "tokenData"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
          ExpressionStatement
             Gas costs: 0
             Source: "rateUpdate = getRateByteFromCompactData(compactData, token, false)"
            Assignment using operator =
               Type: int8
               Source: "rateUpdate = getRateByteFromCompactData(compactData, token, false)"
              Identifier rateUpdate
                 Type: int8
                 Source: "rateUpdate"
              FunctionCall
                 Type: int8
                 Source: "getRateByteFromCompactData(compactData, token, false)"
                Identifier getRateByteFromCompactData
                   Type: function (bytes32,contract ERC20,bool) view returns (int8)
                   Source: "getRateByteFromCompactData"
                Identifier compactData
                   Type: bytes32
                   Source: "compactData"
                Identifier token
                   Type: contract ERC20
                   Source: "token"
                Literal, token: false value: false
                   Type: bool
                   Source: "false"
          ExpressionStatement
             Gas costs: 0
             Source: "extraBps = int(rateUpdate) * 10"
            Assignment using operator =
               Type: int256
               Source: "extraBps = int(rateUpdate) * 10"
              Identifier extraBps
                 Type: int256
                 Source: "extraBps"
              BinaryOperation using operator *
                 Type: int256
                 Source: "int(rateUpdate) * 10"
                FunctionCall
                   Type: int256
                   Source: "int(rateUpdate)"
                  ElementaryTypeNameExpression int
                     Type: type(int256)
                     Source: "int"
                  Identifier rateUpdate
                     Type: int8
                     Source: "rateUpdate"
                Literal, token: [no token] value: 10
                   Type: int_const 10
                   Source: "10"
          ExpressionStatement
             Gas costs: 0
             Source: "rate = addBps(rate, extraBps)"
            Assignment using operator =
               Type: uint256
               Source: "rate = addBps(rate, extraBps)"
              Identifier rate
                 Type: uint256
                 Source: "rate"
              FunctionCall
                 Type: uint256
                 Source: "addBps(rate, extraBps)"
                Identifier addBps
                   Type: function (uint256,int256) pure returns (uint256)
                   Source: "addBps"
                Identifier rate
                   Type: uint256
                   Source: "rate"
                Identifier extraBps
                   Type: int256
                   Source: "extraBps"
          ExpressionStatement
             Gas costs: 0
             Source: "imbalanceQty = -1 * int(qty)"
            Assignment using operator =
               Type: int256
               Source: "imbalanceQty = -1 * int(qty)"
              Identifier imbalanceQty
                 Type: int256
                 Source: "imbalanceQty"
              BinaryOperation using operator *
                 Type: int256
                 Source: "-1 * int(qty)"
                UnaryOperation (prefix) -
                   Type: int_const -1
                   Source: "-1"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
                FunctionCall
                   Type: int256
                   Source: "int(qty)"
                  ElementaryTypeNameExpression int
                     Type: type(int256)
                     Source: "int"
                  Identifier qty
                     Type: uint256
                     Source: "qty"
          ExpressionStatement
             Gas costs: 0
             Source: "totalImbalance += imbalanceQty"
            Assignment using operator +=
               Type: int256
               Source: "totalImbalance += imbalanceQty"
              Identifier totalImbalance
                 Type: int256
                 Source: "totalImbalance"
              Identifier imbalanceQty
                 Type: int256
                 Source: "imbalanceQty"
          ExpressionStatement
             Gas costs: 0
             Source: "extraBps = executeStepFunction(tokenData[token].sellRateQtyStepFunction, int(qty))"
            Assignment using operator =
               Type: int256
               Source: "extraBps = executeStepFunction(tokenData[token].sellRateQtyStepFunction, int(qty))"
              Identifier extraBps
                 Type: int256
                 Source: "extraBps"
              FunctionCall
                 Type: int256
                 Source: "executeStepFunction(tokenData[token].sellRateQtyStepFunction, int(qty))"
                Identifier executeStepFunction
                   Type: function (struct ConversionRates.StepFunction memory,int256) pure returns (int256)
                   Source: "executeStepFunction"
                MemberAccess to member sellRateQtyStepFunction
                   Type: struct ConversionRates.StepFunction storage ref
                   Source: "tokenData[token].sellRateQtyStepFunction"
                  IndexAccess
                     Type: struct ConversionRates.TokenData storage ref
                     Source: "tokenData[token]"
                    Identifier tokenData
                       Type: mapping(address => struct ConversionRates.TokenData storage ref)
                       Source: "tokenData"
                    Identifier token
                       Type: contract ERC20
                       Source: "token"
                FunctionCall
                   Type: int256
                   Source: "int(qty)"
                  ElementaryTypeNameExpression int
                     Type: type(int256)
                     Source: "int"
                  Identifier qty
                     Type: uint256
                     Source: "qty"
          ExpressionStatement
             Gas costs: 0
             Source: "rate = addBps(rate, extraBps)"
            Assignment using operator =
               Type: uint256
               Source: "rate = addBps(rate, extraBps)"
              Identifier rate
                 Type: uint256
                 Source: "rate"
              FunctionCall
                 Type: uint256
                 Source: "addBps(rate, extraBps)"
                Identifier addBps
                   Type: function (uint256,int256) pure returns (uint256)
                   Source: "addBps"
                Identifier rate
                   Type: uint256
                   Source: "rate"
                Identifier extraBps
                   Type: int256
                   Source: "extraBps"
          ExpressionStatement
             Gas costs: 0
             Source: "extraBps = executeStepFunction(tokenData[token].sellRateImbalanceStepFunction, totalImbalance)"
            Assignment using operator =
               Type: int256
               Source: "extraBps = executeStepFunction(tokenData[token].sellRateImbalanceStepFunction, totalImbalance)"
              Identifier extraBps
                 Type: int256
                 Source: "extraBps"
              FunctionCall
                 Type: int256
                 Source: "executeStepFunction(tokenData[token].sellRateImbalanceStepFunction, totalImbalance)"
                Identifier executeStepFunction
                   Type: function (struct ConversionRates.StepFunction memory,int256) pure returns (int256)
                   Source: "executeStepFunction"
                MemberAccess to member sellRateImbalanceStepFunction
                   Type: struct ConversionRates.StepFunction storage ref
                   Source: "tokenData[token].sellRateImbalanceStepFunction"
                  IndexAccess
                     Type: struct ConversionRates.TokenData storage ref
                     Source: "tokenData[token]"
                    Identifier tokenData
                       Type: mapping(address => struct ConversionRates.TokenData storage ref)
                       Source: "tokenData"
                    Identifier token
                       Type: contract ERC20
                       Source: "token"
                Identifier totalImbalance
                   Type: int256
                   Source: "totalImbalance"
          ExpressionStatement
             Gas costs: 0
             Source: "rate = addBps(rate, extraBps)"
            Assignment using operator =
               Type: uint256
               Source: "rate = addBps(rate, extraBps)"
              Identifier rate
                 Type: uint256
                 Source: "rate"
              FunctionCall
                 Type: uint256
                 Source: "addBps(rate, extraBps)"
                Identifier addBps
                   Type: function (uint256,int256) pure returns (uint256)
                   Source: "addBps"
                Identifier rate
                   Type: uint256
                   Source: "rate"
                Identifier extraBps
                   Type: int256
                   Source: "extraBps"
      IfStatement
         Source: "if (abs(totalImbalance + imbalanceQty) >= getMaxTotalImbalance(token)) return 0"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 0
           Source: "abs(totalImbalance + imbalanceQty) >= getMaxTotalImbalance(token)"
          FunctionCall
             Type: uint256
             Source: "abs(totalImbalance + imbalanceQty)"
            Identifier abs
               Type: function (int256) pure returns (uint256)
               Source: "abs"
            BinaryOperation using operator +
               Type: int256
               Source: "totalImbalance + imbalanceQty"
              Identifier totalImbalance
                 Type: int256
                 Source: "totalImbalance"
              Identifier imbalanceQty
                 Type: int256
                 Source: "imbalanceQty"
          FunctionCall
             Type: uint256
             Source: "getMaxTotalImbalance(token)"
            Identifier getMaxTotalImbalance
               Type: function (contract ERC20) view returns (uint256)
               Source: "getMaxTotalImbalance"
            Identifier token
               Type: contract ERC20
               Source: "token"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      IfStatement
         Source: "if (abs(blockImbalance + imbalanceQty) >= getMaxPerBlockImbalance(token)) return 0"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 0
           Source: "abs(blockImbalance + imbalanceQty) >= getMaxPerBlockImbalance(token)"
          FunctionCall
             Type: uint256
             Source: "abs(blockImbalance + imbalanceQty)"
            Identifier abs
               Type: function (int256) pure returns (uint256)
               Source: "abs"
            BinaryOperation using operator +
               Type: int256
               Source: "blockImbalance + imbalanceQty"
              Identifier blockImbalance
                 Type: int256
                 Source: "blockImbalance"
              Identifier imbalanceQty
                 Type: int256
                 Source: "imbalanceQty"
          FunctionCall
             Type: uint256
             Source: "getMaxPerBlockImbalance(token)"
            Identifier getMaxPerBlockImbalance
               Type: function (contract ERC20) view returns (uint256)
               Source: "getMaxPerBlockImbalance"
            Identifier token
               Type: contract ERC20
               Source: "token"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      Return
         Gas costs: 0
         Source: "return rate"
        Identifier rate
           Type: uint256
           Source: "rate"
  FunctionDefinition "getBasicRate" - public - const
     Source: "function getBasicRate(ERC20 token, bool buy) public view returns(uint) {\r\n        if (buy)\r\n            return tokenData[token].baseBuyRate;\r\n        else\r\n            return tokenData[token].baseSellRate;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token, bool buy)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "buy"
         Type: bool
         Source: "bool buy"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (buy)\r\n            return tokenData[token].baseBuyRate;\r\n        else\r\n            return tokenData[token].baseSellRate;\r\n    }"
      IfStatement
         Source: "if (buy)\r\n            return tokenData[token].baseBuyRate;\r\n        else\r\n            return tokenData[token].baseSellRate"
        Identifier buy
           Type: bool
           Gas costs: 0
           Source: "buy"
        Return
           Gas costs: 0
           Source: "return tokenData[token].baseBuyRate"
          MemberAccess to member baseBuyRate
             Type: uint256
             Source: "tokenData[token].baseBuyRate"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
        Return
           Gas costs: 0
           Source: "return tokenData[token].baseSellRate"
          MemberAccess to member baseSellRate
             Type: uint256
             Source: "tokenData[token].baseSellRate"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
  FunctionDefinition "getCompactData" - public - const
     Source: "function getCompactData(ERC20 token) public view returns(uint, uint, byte, byte) {\r\n        uint arrayIndex = tokenData[token].compactDataArrayIndex;\r\n        uint fieldOffset = tokenData[token].compactDataFieldIndex;\r\n\r\n        return (\r\n            arrayIndex,\r\n            fieldOffset,\r\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, true)),\r\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, false))\r\n        );\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 0
       Source: "(uint, uint, byte, byte)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: bytes1
         Source: "byte"
        ElementaryTypeName byte
           Source: "byte"
      VariableDeclaration ""
         Type: bytes1
         Source: "byte"
        ElementaryTypeName byte
           Source: "byte"
    Block
       Source: "{\r\n        uint arrayIndex = tokenData[token].compactDataArrayIndex;\r\n        uint fieldOffset = tokenData[token].compactDataFieldIndex;\r\n\r\n        return (\r\n            arrayIndex,\r\n            fieldOffset,\r\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, true)),\r\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, false))\r\n        );\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint arrayIndex = tokenData[token].compactDataArrayIndex"
        VariableDeclaration "arrayIndex"
           Type: uint256
           Source: "uint arrayIndex"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member compactDataArrayIndex
           Type: uint256
           Source: "tokenData[token].compactDataArrayIndex"
          IndexAccess
             Type: struct ConversionRates.TokenData storage ref
             Source: "tokenData[token]"
            Identifier tokenData
               Type: mapping(address => struct ConversionRates.TokenData storage ref)
               Source: "tokenData"
            Identifier token
               Type: contract ERC20
               Source: "token"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint fieldOffset = tokenData[token].compactDataFieldIndex"
        VariableDeclaration "fieldOffset"
           Type: uint256
           Source: "uint fieldOffset"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member compactDataFieldIndex
           Type: uint256
           Source: "tokenData[token].compactDataFieldIndex"
          IndexAccess
             Type: struct ConversionRates.TokenData storage ref
             Source: "tokenData[token]"
            Identifier tokenData
               Type: mapping(address => struct ConversionRates.TokenData storage ref)
               Source: "tokenData"
            Identifier token
               Type: contract ERC20
               Source: "token"
      Return
         Gas costs: 0
         Source: "return (\r\n            arrayIndex,\r\n            fieldOffset,\r\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, true)),\r\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, false))\r\n        )"
        TupleExpression
           Type: tuple(uint256,uint256,bytes1,bytes1)
           Source: "(\r\n            arrayIndex,\r\n            fieldOffset,\r\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, true)),\r\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, false))\r\n        )"
          Identifier arrayIndex
             Type: uint256
             Source: "arrayIndex"
          Identifier fieldOffset
             Type: uint256
             Source: "fieldOffset"
          FunctionCall
             Type: bytes1
             Source: "byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, true))"
            ElementaryTypeNameExpression byte
               Type: type(bytes1)
               Source: "byte"
            FunctionCall
               Type: int8
               Source: "getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, true)"
              Identifier getRateByteFromCompactData
                 Type: function (bytes32,contract ERC20,bool) view returns (int8)
                 Source: "getRateByteFromCompactData"
              IndexAccess
                 Type: bytes32
                 Source: "tokenRatesCompactData[arrayIndex]"
                Identifier tokenRatesCompactData
                   Type: bytes32[] storage ref
                   Source: "tokenRatesCompactData"
                Identifier arrayIndex
                   Type: uint256
                   Source: "arrayIndex"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
          FunctionCall
             Type: bytes1
             Source: "byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, false))"
            ElementaryTypeNameExpression byte
               Type: type(bytes1)
               Source: "byte"
            FunctionCall
               Type: int8
               Source: "getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, false)"
              Identifier getRateByteFromCompactData
                 Type: function (bytes32,contract ERC20,bool) view returns (int8)
                 Source: "getRateByteFromCompactData"
              IndexAccess
                 Type: bytes32
                 Source: "tokenRatesCompactData[arrayIndex]"
                Identifier tokenRatesCompactData
                   Type: bytes32[] storage ref
                   Source: "tokenRatesCompactData"
                Identifier arrayIndex
                   Type: uint256
                   Source: "arrayIndex"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
              Literal, token: false value: false
                 Type: bool
                 Source: "false"
  FunctionDefinition "getTokenBasicData" - public - const
     Source: "function getTokenBasicData(ERC20 token) public view returns(bool, bool) {\r\n        return (tokenData[token].listed, tokenData[token].enabled);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 0
       Source: "(bool, bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        return (tokenData[token].listed, tokenData[token].enabled);\r\n    }"
      Return
         Gas costs: 0
         Source: "return (tokenData[token].listed, tokenData[token].enabled)"
        TupleExpression
           Type: tuple(bool,bool)
           Source: "(tokenData[token].listed, tokenData[token].enabled)"
          MemberAccess to member listed
             Type: bool
             Source: "tokenData[token].listed"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
          MemberAccess to member enabled
             Type: bool
             Source: "tokenData[token].enabled"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
  FunctionDefinition "getStepFunctionData" - public - const
     Source: "function getStepFunctionData(ERC20 token, uint command, uint param) public view returns(int) {\r\n        if (command == 0) return int(tokenData[token].buyRateQtyStepFunction.x.length);\r\n        if (command == 1) return tokenData[token].buyRateQtyStepFunction.x[param];\r\n        if (command == 2) return int(tokenData[token].buyRateQtyStepFunction.y.length);\r\n        if (command == 3) return tokenData[token].buyRateQtyStepFunction.y[param];\r\n\r\n        if (command == 4) return int(tokenData[token].sellRateQtyStepFunction.x.length);\r\n        if (command == 5) return tokenData[token].sellRateQtyStepFunction.x[param];\r\n        if (command == 6) return int(tokenData[token].sellRateQtyStepFunction.y.length);\r\n        if (command == 7) return tokenData[token].sellRateQtyStepFunction.y[param];\r\n\r\n        if (command == 8) return int(tokenData[token].buyRateImbalanceStepFunction.x.length);\r\n        if (command == 9) return tokenData[token].buyRateImbalanceStepFunction.x[param];\r\n        if (command == 10) return int(tokenData[token].buyRateImbalanceStepFunction.y.length);\r\n        if (command == 11) return tokenData[token].buyRateImbalanceStepFunction.y[param];\r\n\r\n        if (command == 12) return int(tokenData[token].sellRateImbalanceStepFunction.x.length);\r\n        if (command == 13) return tokenData[token].sellRateImbalanceStepFunction.x[param];\r\n        if (command == 14) return int(tokenData[token].sellRateImbalanceStepFunction.y.length);\r\n        if (command == 15) return tokenData[token].sellRateImbalanceStepFunction.y[param];\r\n\r\n        revert();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token, uint command, uint param)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "command"
         Type: uint256
         Source: "uint command"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "param"
         Type: uint256
         Source: "uint param"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(int)"
      VariableDeclaration ""
         Type: int256
         Source: "int"
        ElementaryTypeName int
           Source: "int"
    Block
       Source: "{\r\n        if (command == 0) return int(tokenData[token].buyRateQtyStepFunction.x.length);\r\n        if (command == 1) return tokenData[token].buyRateQtyStepFunction.x[param];\r\n        if (command == 2) return int(tokenData[token].buyRateQtyStepFunction.y.length);\r\n        if (command == 3) return tokenData[token].buyRateQtyStepFunction.y[param];\r\n\r\n        if (command == 4) return int(tokenData[token].sellRateQtyStepFunction.x.length);\r\n        if (command == 5) return tokenData[token].sellRateQtyStepFunction.x[param];\r\n        if (command == 6) return int(tokenData[token].sellRateQtyStepFunction.y.length);\r\n        if (command == 7) return tokenData[token].sellRateQtyStepFunction.y[param];\r\n\r\n        if (command == 8) return int(tokenData[token].buyRateImbalanceStepFunction.x.length);\r\n        if (command == 9) return tokenData[token].buyRateImbalanceStepFunction.x[param];\r\n        if (command == 10) return int(tokenData[token].buyRateImbalanceStepFunction.y.length);\r\n        if (command == 11) return tokenData[token].buyRateImbalanceStepFunction.y[param];\r\n\r\n        if (command == 12) return int(tokenData[token].sellRateImbalanceStepFunction.x.length);\r\n        if (command == 13) return tokenData[token].sellRateImbalanceStepFunction.x[param];\r\n        if (command == 14) return int(tokenData[token].sellRateImbalanceStepFunction.y.length);\r\n        if (command == 15) return tokenData[token].sellRateImbalanceStepFunction.y[param];\r\n\r\n        revert();\r\n    }"
      IfStatement
         Source: "if (command == 0) return int(tokenData[token].buyRateQtyStepFunction.x.length)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 0"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 0
           Source: "return int(tokenData[token].buyRateQtyStepFunction.x.length)"
          FunctionCall
             Type: int256
             Source: "int(tokenData[token].buyRateQtyStepFunction.x.length)"
            ElementaryTypeNameExpression int
               Type: type(int256)
               Source: "int"
            MemberAccess to member length
               Type: uint256
               Source: "tokenData[token].buyRateQtyStepFunction.x.length"
              MemberAccess to member x
                 Type: int256[] storage ref
                 Source: "tokenData[token].buyRateQtyStepFunction.x"
                MemberAccess to member buyRateQtyStepFunction
                   Type: struct ConversionRates.StepFunction storage ref
                   Source: "tokenData[token].buyRateQtyStepFunction"
                  IndexAccess
                     Type: struct ConversionRates.TokenData storage ref
                     Source: "tokenData[token]"
                    Identifier tokenData
                       Type: mapping(address => struct ConversionRates.TokenData storage ref)
                       Source: "tokenData"
                    Identifier token
                       Type: contract ERC20
                       Source: "token"
      IfStatement
         Source: "if (command == 1) return tokenData[token].buyRateQtyStepFunction.x[param]"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 1"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        Return
           Gas costs: 0
           Source: "return tokenData[token].buyRateQtyStepFunction.x[param]"
          IndexAccess
             Type: int256
             Source: "tokenData[token].buyRateQtyStepFunction.x[param]"
            MemberAccess to member x
               Type: int256[] storage ref
               Source: "tokenData[token].buyRateQtyStepFunction.x"
              MemberAccess to member buyRateQtyStepFunction
                 Type: struct ConversionRates.StepFunction storage ref
                 Source: "tokenData[token].buyRateQtyStepFunction"
                IndexAccess
                   Type: struct ConversionRates.TokenData storage ref
                   Source: "tokenData[token]"
                  Identifier tokenData
                     Type: mapping(address => struct ConversionRates.TokenData storage ref)
                     Source: "tokenData"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
            Identifier param
               Type: uint256
               Source: "param"
      IfStatement
         Source: "if (command == 2) return int(tokenData[token].buyRateQtyStepFunction.y.length)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 2"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
        Return
           Gas costs: 0
           Source: "return int(tokenData[token].buyRateQtyStepFunction.y.length)"
          FunctionCall
             Type: int256
             Source: "int(tokenData[token].buyRateQtyStepFunction.y.length)"
            ElementaryTypeNameExpression int
               Type: type(int256)
               Source: "int"
            MemberAccess to member length
               Type: uint256
               Source: "tokenData[token].buyRateQtyStepFunction.y.length"
              MemberAccess to member y
                 Type: int256[] storage ref
                 Source: "tokenData[token].buyRateQtyStepFunction.y"
                MemberAccess to member buyRateQtyStepFunction
                   Type: struct ConversionRates.StepFunction storage ref
                   Source: "tokenData[token].buyRateQtyStepFunction"
                  IndexAccess
                     Type: struct ConversionRates.TokenData storage ref
                     Source: "tokenData[token]"
                    Identifier tokenData
                       Type: mapping(address => struct ConversionRates.TokenData storage ref)
                       Source: "tokenData"
                    Identifier token
                       Type: contract ERC20
                       Source: "token"
      IfStatement
         Source: "if (command == 3) return tokenData[token].buyRateQtyStepFunction.y[param]"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 3"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 3
             Type: int_const 3
             Source: "3"
        Return
           Gas costs: 0
           Source: "return tokenData[token].buyRateQtyStepFunction.y[param]"
          IndexAccess
             Type: int256
             Source: "tokenData[token].buyRateQtyStepFunction.y[param]"
            MemberAccess to member y
               Type: int256[] storage ref
               Source: "tokenData[token].buyRateQtyStepFunction.y"
              MemberAccess to member buyRateQtyStepFunction
                 Type: struct ConversionRates.StepFunction storage ref
                 Source: "tokenData[token].buyRateQtyStepFunction"
                IndexAccess
                   Type: struct ConversionRates.TokenData storage ref
                   Source: "tokenData[token]"
                  Identifier tokenData
                     Type: mapping(address => struct ConversionRates.TokenData storage ref)
                     Source: "tokenData"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
            Identifier param
               Type: uint256
               Source: "param"
      IfStatement
         Source: "if (command == 4) return int(tokenData[token].sellRateQtyStepFunction.x.length)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 4"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 4
             Type: int_const 4
             Source: "4"
        Return
           Gas costs: 0
           Source: "return int(tokenData[token].sellRateQtyStepFunction.x.length)"
          FunctionCall
             Type: int256
             Source: "int(tokenData[token].sellRateQtyStepFunction.x.length)"
            ElementaryTypeNameExpression int
               Type: type(int256)
               Source: "int"
            MemberAccess to member length
               Type: uint256
               Source: "tokenData[token].sellRateQtyStepFunction.x.length"
              MemberAccess to member x
                 Type: int256[] storage ref
                 Source: "tokenData[token].sellRateQtyStepFunction.x"
                MemberAccess to member sellRateQtyStepFunction
                   Type: struct ConversionRates.StepFunction storage ref
                   Source: "tokenData[token].sellRateQtyStepFunction"
                  IndexAccess
                     Type: struct ConversionRates.TokenData storage ref
                     Source: "tokenData[token]"
                    Identifier tokenData
                       Type: mapping(address => struct ConversionRates.TokenData storage ref)
                       Source: "tokenData"
                    Identifier token
                       Type: contract ERC20
                       Source: "token"
      IfStatement
         Source: "if (command == 5) return tokenData[token].sellRateQtyStepFunction.x[param]"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 5"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 5
             Type: int_const 5
             Source: "5"
        Return
           Gas costs: 0
           Source: "return tokenData[token].sellRateQtyStepFunction.x[param]"
          IndexAccess
             Type: int256
             Source: "tokenData[token].sellRateQtyStepFunction.x[param]"
            MemberAccess to member x
               Type: int256[] storage ref
               Source: "tokenData[token].sellRateQtyStepFunction.x"
              MemberAccess to member sellRateQtyStepFunction
                 Type: struct ConversionRates.StepFunction storage ref
                 Source: "tokenData[token].sellRateQtyStepFunction"
                IndexAccess
                   Type: struct ConversionRates.TokenData storage ref
                   Source: "tokenData[token]"
                  Identifier tokenData
                     Type: mapping(address => struct ConversionRates.TokenData storage ref)
                     Source: "tokenData"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
            Identifier param
               Type: uint256
               Source: "param"
      IfStatement
         Source: "if (command == 6) return int(tokenData[token].sellRateQtyStepFunction.y.length)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 6"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 6
             Type: int_const 6
             Source: "6"
        Return
           Gas costs: 0
           Source: "return int(tokenData[token].sellRateQtyStepFunction.y.length)"
          FunctionCall
             Type: int256
             Source: "int(tokenData[token].sellRateQtyStepFunction.y.length)"
            ElementaryTypeNameExpression int
               Type: type(int256)
               Source: "int"
            MemberAccess to member length
               Type: uint256
               Source: "tokenData[token].sellRateQtyStepFunction.y.length"
              MemberAccess to member y
                 Type: int256[] storage ref
                 Source: "tokenData[token].sellRateQtyStepFunction.y"
                MemberAccess to member sellRateQtyStepFunction
                   Type: struct ConversionRates.StepFunction storage ref
                   Source: "tokenData[token].sellRateQtyStepFunction"
                  IndexAccess
                     Type: struct ConversionRates.TokenData storage ref
                     Source: "tokenData[token]"
                    Identifier tokenData
                       Type: mapping(address => struct ConversionRates.TokenData storage ref)
                       Source: "tokenData"
                    Identifier token
                       Type: contract ERC20
                       Source: "token"
      IfStatement
         Source: "if (command == 7) return tokenData[token].sellRateQtyStepFunction.y[param]"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 7"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 7
             Type: int_const 7
             Source: "7"
        Return
           Gas costs: 0
           Source: "return tokenData[token].sellRateQtyStepFunction.y[param]"
          IndexAccess
             Type: int256
             Source: "tokenData[token].sellRateQtyStepFunction.y[param]"
            MemberAccess to member y
               Type: int256[] storage ref
               Source: "tokenData[token].sellRateQtyStepFunction.y"
              MemberAccess to member sellRateQtyStepFunction
                 Type: struct ConversionRates.StepFunction storage ref
                 Source: "tokenData[token].sellRateQtyStepFunction"
                IndexAccess
                   Type: struct ConversionRates.TokenData storage ref
                   Source: "tokenData[token]"
                  Identifier tokenData
                     Type: mapping(address => struct ConversionRates.TokenData storage ref)
                     Source: "tokenData"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
            Identifier param
               Type: uint256
               Source: "param"
      IfStatement
         Source: "if (command == 8) return int(tokenData[token].buyRateImbalanceStepFunction.x.length)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 8"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 8
             Type: int_const 8
             Source: "8"
        Return
           Gas costs: 0
           Source: "return int(tokenData[token].buyRateImbalanceStepFunction.x.length)"
          FunctionCall
             Type: int256
             Source: "int(tokenData[token].buyRateImbalanceStepFunction.x.length)"
            ElementaryTypeNameExpression int
               Type: type(int256)
               Source: "int"
            MemberAccess to member length
               Type: uint256
               Source: "tokenData[token].buyRateImbalanceStepFunction.x.length"
              MemberAccess to member x
                 Type: int256[] storage ref
                 Source: "tokenData[token].buyRateImbalanceStepFunction.x"
                MemberAccess to member buyRateImbalanceStepFunction
                   Type: struct ConversionRates.StepFunction storage ref
                   Source: "tokenData[token].buyRateImbalanceStepFunction"
                  IndexAccess
                     Type: struct ConversionRates.TokenData storage ref
                     Source: "tokenData[token]"
                    Identifier tokenData
                       Type: mapping(address => struct ConversionRates.TokenData storage ref)
                       Source: "tokenData"
                    Identifier token
                       Type: contract ERC20
                       Source: "token"
      IfStatement
         Source: "if (command == 9) return tokenData[token].buyRateImbalanceStepFunction.x[param]"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 9"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 9
             Type: int_const 9
             Source: "9"
        Return
           Gas costs: 0
           Source: "return tokenData[token].buyRateImbalanceStepFunction.x[param]"
          IndexAccess
             Type: int256
             Source: "tokenData[token].buyRateImbalanceStepFunction.x[param]"
            MemberAccess to member x
               Type: int256[] storage ref
               Source: "tokenData[token].buyRateImbalanceStepFunction.x"
              MemberAccess to member buyRateImbalanceStepFunction
                 Type: struct ConversionRates.StepFunction storage ref
                 Source: "tokenData[token].buyRateImbalanceStepFunction"
                IndexAccess
                   Type: struct ConversionRates.TokenData storage ref
                   Source: "tokenData[token]"
                  Identifier tokenData
                     Type: mapping(address => struct ConversionRates.TokenData storage ref)
                     Source: "tokenData"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
            Identifier param
               Type: uint256
               Source: "param"
      IfStatement
         Source: "if (command == 10) return int(tokenData[token].buyRateImbalanceStepFunction.y.length)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 10"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 10
             Type: int_const 10
             Source: "10"
        Return
           Gas costs: 0
           Source: "return int(tokenData[token].buyRateImbalanceStepFunction.y.length)"
          FunctionCall
             Type: int256
             Source: "int(tokenData[token].buyRateImbalanceStepFunction.y.length)"
            ElementaryTypeNameExpression int
               Type: type(int256)
               Source: "int"
            MemberAccess to member length
               Type: uint256
               Source: "tokenData[token].buyRateImbalanceStepFunction.y.length"
              MemberAccess to member y
                 Type: int256[] storage ref
                 Source: "tokenData[token].buyRateImbalanceStepFunction.y"
                MemberAccess to member buyRateImbalanceStepFunction
                   Type: struct ConversionRates.StepFunction storage ref
                   Source: "tokenData[token].buyRateImbalanceStepFunction"
                  IndexAccess
                     Type: struct ConversionRates.TokenData storage ref
                     Source: "tokenData[token]"
                    Identifier tokenData
                       Type: mapping(address => struct ConversionRates.TokenData storage ref)
                       Source: "tokenData"
                    Identifier token
                       Type: contract ERC20
                       Source: "token"
      IfStatement
         Source: "if (command == 11) return tokenData[token].buyRateImbalanceStepFunction.y[param]"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 11"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 11
             Type: int_const 11
             Source: "11"
        Return
           Gas costs: 0
           Source: "return tokenData[token].buyRateImbalanceStepFunction.y[param]"
          IndexAccess
             Type: int256
             Source: "tokenData[token].buyRateImbalanceStepFunction.y[param]"
            MemberAccess to member y
               Type: int256[] storage ref
               Source: "tokenData[token].buyRateImbalanceStepFunction.y"
              MemberAccess to member buyRateImbalanceStepFunction
                 Type: struct ConversionRates.StepFunction storage ref
                 Source: "tokenData[token].buyRateImbalanceStepFunction"
                IndexAccess
                   Type: struct ConversionRates.TokenData storage ref
                   Source: "tokenData[token]"
                  Identifier tokenData
                     Type: mapping(address => struct ConversionRates.TokenData storage ref)
                     Source: "tokenData"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
            Identifier param
               Type: uint256
               Source: "param"
      IfStatement
         Source: "if (command == 12) return int(tokenData[token].sellRateImbalanceStepFunction.x.length)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 12"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 12
             Type: int_const 12
             Source: "12"
        Return
           Gas costs: 0
           Source: "return int(tokenData[token].sellRateImbalanceStepFunction.x.length)"
          FunctionCall
             Type: int256
             Source: "int(tokenData[token].sellRateImbalanceStepFunction.x.length)"
            ElementaryTypeNameExpression int
               Type: type(int256)
               Source: "int"
            MemberAccess to member length
               Type: uint256
               Source: "tokenData[token].sellRateImbalanceStepFunction.x.length"
              MemberAccess to member x
                 Type: int256[] storage ref
                 Source: "tokenData[token].sellRateImbalanceStepFunction.x"
                MemberAccess to member sellRateImbalanceStepFunction
                   Type: struct ConversionRates.StepFunction storage ref
                   Source: "tokenData[token].sellRateImbalanceStepFunction"
                  IndexAccess
                     Type: struct ConversionRates.TokenData storage ref
                     Source: "tokenData[token]"
                    Identifier tokenData
                       Type: mapping(address => struct ConversionRates.TokenData storage ref)
                       Source: "tokenData"
                    Identifier token
                       Type: contract ERC20
                       Source: "token"
      IfStatement
         Source: "if (command == 13) return tokenData[token].sellRateImbalanceStepFunction.x[param]"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 13"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 13
             Type: int_const 13
             Source: "13"
        Return
           Gas costs: 0
           Source: "return tokenData[token].sellRateImbalanceStepFunction.x[param]"
          IndexAccess
             Type: int256
             Source: "tokenData[token].sellRateImbalanceStepFunction.x[param]"
            MemberAccess to member x
               Type: int256[] storage ref
               Source: "tokenData[token].sellRateImbalanceStepFunction.x"
              MemberAccess to member sellRateImbalanceStepFunction
                 Type: struct ConversionRates.StepFunction storage ref
                 Source: "tokenData[token].sellRateImbalanceStepFunction"
                IndexAccess
                   Type: struct ConversionRates.TokenData storage ref
                   Source: "tokenData[token]"
                  Identifier tokenData
                     Type: mapping(address => struct ConversionRates.TokenData storage ref)
                     Source: "tokenData"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
            Identifier param
               Type: uint256
               Source: "param"
      IfStatement
         Source: "if (command == 14) return int(tokenData[token].sellRateImbalanceStepFunction.y.length)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 14"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 14
             Type: int_const 14
             Source: "14"
        Return
           Gas costs: 0
           Source: "return int(tokenData[token].sellRateImbalanceStepFunction.y.length)"
          FunctionCall
             Type: int256
             Source: "int(tokenData[token].sellRateImbalanceStepFunction.y.length)"
            ElementaryTypeNameExpression int
               Type: type(int256)
               Source: "int"
            MemberAccess to member length
               Type: uint256
               Source: "tokenData[token].sellRateImbalanceStepFunction.y.length"
              MemberAccess to member y
                 Type: int256[] storage ref
                 Source: "tokenData[token].sellRateImbalanceStepFunction.y"
                MemberAccess to member sellRateImbalanceStepFunction
                   Type: struct ConversionRates.StepFunction storage ref
                   Source: "tokenData[token].sellRateImbalanceStepFunction"
                  IndexAccess
                     Type: struct ConversionRates.TokenData storage ref
                     Source: "tokenData[token]"
                    Identifier tokenData
                       Type: mapping(address => struct ConversionRates.TokenData storage ref)
                       Source: "tokenData"
                    Identifier token
                       Type: contract ERC20
                       Source: "token"
      IfStatement
         Source: "if (command == 15) return tokenData[token].sellRateImbalanceStepFunction.y[param]"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "command == 15"
          Identifier command
             Type: uint256
             Source: "command"
          Literal, token: [no token] value: 15
             Type: int_const 15
             Source: "15"
        Return
           Gas costs: 0
           Source: "return tokenData[token].sellRateImbalanceStepFunction.y[param]"
          IndexAccess
             Type: int256
             Source: "tokenData[token].sellRateImbalanceStepFunction.y[param]"
            MemberAccess to member y
               Type: int256[] storage ref
               Source: "tokenData[token].sellRateImbalanceStepFunction.y"
              MemberAccess to member sellRateImbalanceStepFunction
                 Type: struct ConversionRates.StepFunction storage ref
                 Source: "tokenData[token].sellRateImbalanceStepFunction"
                IndexAccess
                   Type: struct ConversionRates.TokenData storage ref
                   Source: "tokenData[token]"
                  Identifier tokenData
                     Type: mapping(address => struct ConversionRates.TokenData storage ref)
                     Source: "tokenData"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
            Identifier param
               Type: uint256
               Source: "param"
      ExpressionStatement
         Gas costs: 0
         Source: "revert()"
        FunctionCall
           Type: tuple()
           Source: "revert()"
          Identifier revert
             Type: function () pure
             Source: "revert"
  FunctionDefinition "getRateUpdateBlock" - public - const
     Source: "function getRateUpdateBlock(ERC20 token) public view returns(uint) {\r\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\r\n        return getLast4Bytes(compactData);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\r\n        return getLast4Bytes(compactData);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex]"
        VariableDeclaration "compactData"
           Type: bytes32
           Source: "bytes32 compactData"
          ElementaryTypeName bytes32
             Source: "bytes32"
        IndexAccess
           Type: bytes32
           Source: "tokenRatesCompactData[tokenData[token].compactDataArrayIndex]"
          Identifier tokenRatesCompactData
             Type: bytes32[] storage ref
             Source: "tokenRatesCompactData"
          MemberAccess to member compactDataArrayIndex
             Type: uint256
             Source: "tokenData[token].compactDataArrayIndex"
            IndexAccess
               Type: struct ConversionRates.TokenData storage ref
               Source: "tokenData[token]"
              Identifier tokenData
                 Type: mapping(address => struct ConversionRates.TokenData storage ref)
                 Source: "tokenData"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
      Return
         Gas costs: 0
         Source: "return getLast4Bytes(compactData)"
        FunctionCall
           Type: uint256
           Source: "getLast4Bytes(compactData)"
          Identifier getLast4Bytes
             Type: function (bytes32) pure returns (uint256)
             Source: "getLast4Bytes"
          Identifier compactData
             Type: bytes32
             Source: "compactData"
  FunctionDefinition "getListedTokens" - public - const
     Source: "function getListedTokens() public view returns(ERC20[]) {\r\n        return listedTokens;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(ERC20[])"
      VariableDeclaration ""
         Type: contract ERC20[] memory
         Source: "ERC20[]"
        ArrayTypeName
           Source: "ERC20[]"
          UserDefinedTypeName "ERC20"
             Source: "ERC20"
    Block
       Source: "{\r\n        return listedTokens;\r\n    }"
      Return
         Gas costs: 0
         Source: "return listedTokens"
        Identifier listedTokens
           Type: contract ERC20[] storage ref
           Source: "listedTokens"
  FunctionDefinition "getTokenQty" - const
     Source: "function getTokenQty(ERC20 token, uint ethQty, uint rate) internal view returns(uint) {\r\n        uint dstDecimals = token.decimals();\r\n        uint srcDecimals = 18;\r\n\r\n        return calcDstQty(ethQty, srcDecimals, dstDecimals, rate);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token, uint ethQty, uint rate)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "ethQty"
         Type: uint256
         Source: "uint ethQty"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "rate"
         Type: uint256
         Source: "uint rate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint dstDecimals = token.decimals();\r\n        uint srcDecimals = 18;\r\n\r\n        return calcDstQty(ethQty, srcDecimals, dstDecimals, rate);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint dstDecimals = token.decimals()"
        VariableDeclaration "dstDecimals"
           Type: uint256
           Source: "uint dstDecimals"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "token.decimals()"
          MemberAccess to member decimals
             Type: function () view external returns (uint256)
             Source: "token.decimals"
            Identifier token
               Type: contract ERC20
               Source: "token"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint srcDecimals = 18"
        VariableDeclaration "srcDecimals"
           Type: uint256
           Source: "uint srcDecimals"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 18
           Type: int_const 18
           Source: "18"
      Return
         Gas costs: 0
         Source: "return calcDstQty(ethQty, srcDecimals, dstDecimals, rate)"
        FunctionCall
           Type: uint256
           Source: "calcDstQty(ethQty, srcDecimals, dstDecimals, rate)"
          Identifier calcDstQty
             Type: function (uint256,uint256,uint256,uint256) pure returns (uint256)
             Source: "calcDstQty"
          Identifier ethQty
             Type: uint256
             Source: "ethQty"
          Identifier srcDecimals
             Type: uint256
             Source: "srcDecimals"
          Identifier dstDecimals
             Type: uint256
             Source: "dstDecimals"
          Identifier rate
             Type: uint256
             Source: "rate"
  FunctionDefinition "getLast4Bytes"
     Source: "function getLast4Bytes(bytes32 b) internal pure returns(uint) {\r\n        // cannot trust compiler with not turning bit operations into EXP opcode\r\n        return uint(b) / (BYTES_14_OFFSET * BYTES_14_OFFSET);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 b)"
      VariableDeclaration "b"
         Type: bytes32
         Source: "bytes32 b"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        // cannot trust compiler with not turning bit operations into EXP opcode\r\n        return uint(b) / (BYTES_14_OFFSET * BYTES_14_OFFSET);\r\n    }"
      Return
         Gas costs: 0
         Source: "return uint(b) / (BYTES_14_OFFSET * BYTES_14_OFFSET)"
        BinaryOperation using operator /
           Type: uint256
           Source: "uint(b) / (BYTES_14_OFFSET * BYTES_14_OFFSET)"
          FunctionCall
             Type: uint256
             Source: "uint(b)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            Identifier b
               Type: bytes32
               Source: "b"
          TupleExpression
             Type: uint256
             Source: "(BYTES_14_OFFSET * BYTES_14_OFFSET)"
            BinaryOperation using operator *
               Type: uint256
               Source: "BYTES_14_OFFSET * BYTES_14_OFFSET"
              Identifier BYTES_14_OFFSET
                 Type: uint256
                 Source: "BYTES_14_OFFSET"
              Identifier BYTES_14_OFFSET
                 Type: uint256
                 Source: "BYTES_14_OFFSET"
  FunctionDefinition "getRateByteFromCompactData" - const
     Source: "function getRateByteFromCompactData(bytes32 data, ERC20 token, bool buy) internal view returns(int8) {\r\n        uint fieldOffset = tokenData[token].compactDataFieldIndex;\r\n        uint byteOffset;\r\n        if (buy)\r\n            byteOffset = 32 - NUM_TOKENS_IN_COMPACT_DATA + fieldOffset;\r\n        else\r\n            byteOffset = 4 + fieldOffset;\r\n\r\n        return int8(data[byteOffset]);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 data, ERC20 token, bool buy)"
      VariableDeclaration "data"
         Type: bytes32
         Source: "bytes32 data"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "buy"
         Type: bool
         Source: "bool buy"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: "(int8)"
      VariableDeclaration ""
         Type: int8
         Source: "int8"
        ElementaryTypeName int8
           Source: "int8"
    Block
       Source: "{\r\n        uint fieldOffset = tokenData[token].compactDataFieldIndex;\r\n        uint byteOffset;\r\n        if (buy)\r\n            byteOffset = 32 - NUM_TOKENS_IN_COMPACT_DATA + fieldOffset;\r\n        else\r\n            byteOffset = 4 + fieldOffset;\r\n\r\n        return int8(data[byteOffset]);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint fieldOffset = tokenData[token].compactDataFieldIndex"
        VariableDeclaration "fieldOffset"
           Type: uint256
           Source: "uint fieldOffset"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member compactDataFieldIndex
           Type: uint256
           Source: "tokenData[token].compactDataFieldIndex"
          IndexAccess
             Type: struct ConversionRates.TokenData storage ref
             Source: "tokenData[token]"
            Identifier tokenData
               Type: mapping(address => struct ConversionRates.TokenData storage ref)
               Source: "tokenData"
            Identifier token
               Type: contract ERC20
               Source: "token"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint byteOffset"
        VariableDeclaration "byteOffset"
           Type: uint256
           Source: "uint byteOffset"
          ElementaryTypeName uint
             Source: "uint"
      IfStatement
         Source: "if (buy)\r\n            byteOffset = 32 - NUM_TOKENS_IN_COMPACT_DATA + fieldOffset;\r\n        else\r\n            byteOffset = 4 + fieldOffset"
        Identifier buy
           Type: bool
           Gas costs: 0
           Source: "buy"
        ExpressionStatement
           Gas costs: 0
           Source: "byteOffset = 32 - NUM_TOKENS_IN_COMPACT_DATA + fieldOffset"
          Assignment using operator =
             Type: uint256
             Source: "byteOffset = 32 - NUM_TOKENS_IN_COMPACT_DATA + fieldOffset"
            Identifier byteOffset
               Type: uint256
               Source: "byteOffset"
            BinaryOperation using operator +
               Type: uint256
               Source: "32 - NUM_TOKENS_IN_COMPACT_DATA + fieldOffset"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "32 - NUM_TOKENS_IN_COMPACT_DATA"
                Literal, token: [no token] value: 32
                   Type: int_const 32
                   Source: "32"
                Identifier NUM_TOKENS_IN_COMPACT_DATA
                   Type: uint256
                   Source: "NUM_TOKENS_IN_COMPACT_DATA"
              Identifier fieldOffset
                 Type: uint256
                 Source: "fieldOffset"
        ExpressionStatement
           Gas costs: 0
           Source: "byteOffset = 4 + fieldOffset"
          Assignment using operator =
             Type: uint256
             Source: "byteOffset = 4 + fieldOffset"
            Identifier byteOffset
               Type: uint256
               Source: "byteOffset"
            BinaryOperation using operator +
               Type: uint256
               Source: "4 + fieldOffset"
              Literal, token: [no token] value: 4
                 Type: int_const 4
                 Source: "4"
              Identifier fieldOffset
                 Type: uint256
                 Source: "fieldOffset"
      Return
         Gas costs: 0
         Source: "return int8(data[byteOffset])"
        FunctionCall
           Type: int8
           Source: "int8(data[byteOffset])"
          ElementaryTypeNameExpression int8
             Type: type(int8)
             Source: "int8"
          IndexAccess
             Type: bytes1
             Source: "data[byteOffset]"
            Identifier data
               Type: bytes32
               Source: "data"
            Identifier byteOffset
               Type: uint256
               Source: "byteOffset"
  FunctionDefinition "executeStepFunction"
     Source: "function executeStepFunction(StepFunction f, int x) internal pure returns(int) {\r\n        uint len = f.y.length;\r\n        for (uint ind = 0; ind < len; ind++) {\r\n            if (x <= f.x[ind]) return f.y[ind];\r\n        }\r\n\r\n        return f.y[len-1];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(StepFunction f, int x)"
      VariableDeclaration "f"
         Type: struct ConversionRates.StepFunction memory
         Source: "StepFunction f"
        UserDefinedTypeName "StepFunction"
           Source: "StepFunction"
      VariableDeclaration "x"
         Type: int256
         Source: "int x"
        ElementaryTypeName int
           Source: "int"
    ParameterList
       Gas costs: 0
       Source: "(int)"
      VariableDeclaration ""
         Type: int256
         Source: "int"
        ElementaryTypeName int
           Source: "int"
    Block
       Source: "{\r\n        uint len = f.y.length;\r\n        for (uint ind = 0; ind < len; ind++) {\r\n            if (x <= f.x[ind]) return f.y[ind];\r\n        }\r\n\r\n        return f.y[len-1];\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint len = f.y.length"
        VariableDeclaration "len"
           Type: uint256
           Source: "uint len"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "f.y.length"
          MemberAccess to member y
             Type: int256[] memory
             Source: "f.y"
            Identifier f
               Type: struct ConversionRates.StepFunction memory
               Source: "f"
      ForStatement
         Source: "for (uint ind = 0; ind < len; ind++) {\r\n            if (x <= f.x[ind]) return f.y[ind];\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint ind = 0"
          VariableDeclaration "ind"
             Type: uint256
             Source: "uint ind"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "ind < len"
          Identifier ind
             Type: uint256
             Source: "ind"
          Identifier len
             Type: uint256
             Source: "len"
        ExpressionStatement
           Gas costs: 0
           Source: "ind++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "ind++"
            Identifier ind
               Type: uint256
               Source: "ind"
        Block
           Source: "{\r\n            if (x <= f.x[ind]) return f.y[ind];\r\n        }"
          IfStatement
             Source: "if (x <= f.x[ind]) return f.y[ind]"
            BinaryOperation using operator <=
               Type: bool
               Gas costs: 0
               Source: "x <= f.x[ind]"
              Identifier x
                 Type: int256
                 Source: "x"
              IndexAccess
                 Type: int256
                 Source: "f.x[ind]"
                MemberAccess to member x
                   Type: int256[] memory
                   Source: "f.x"
                  Identifier f
                     Type: struct ConversionRates.StepFunction memory
                     Source: "f"
                Identifier ind
                   Type: uint256
                   Source: "ind"
            Return
               Gas costs: 0
               Source: "return f.y[ind]"
              IndexAccess
                 Type: int256
                 Source: "f.y[ind]"
                MemberAccess to member y
                   Type: int256[] memory
                   Source: "f.y"
                  Identifier f
                     Type: struct ConversionRates.StepFunction memory
                     Source: "f"
                Identifier ind
                   Type: uint256
                   Source: "ind"
      Return
         Gas costs: 0
         Source: "return f.y[len-1]"
        IndexAccess
           Type: int256
           Source: "f.y[len-1]"
          MemberAccess to member y
             Type: int256[] memory
             Source: "f.y"
            Identifier f
               Type: struct ConversionRates.StepFunction memory
               Source: "f"
          BinaryOperation using operator -
             Type: uint256
             Source: "len-1"
            Identifier len
               Type: uint256
               Source: "len"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
  FunctionDefinition "addBps"
     Source: "function addBps(uint rate, int bps) internal pure returns(uint) {\r\n        uint maxBps = 100 * 100;\r\n        return (rate * uint(int(maxBps) + bps)) / maxBps;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint rate, int bps)"
      VariableDeclaration "rate"
         Type: uint256
         Source: "uint rate"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "bps"
         Type: int256
         Source: "int bps"
        ElementaryTypeName int
           Source: "int"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint maxBps = 100 * 100;\r\n        return (rate * uint(int(maxBps) + bps)) / maxBps;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint maxBps = 100 * 100"
        VariableDeclaration "maxBps"
           Type: uint256
           Source: "uint maxBps"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: int_const 10000
           Source: "100 * 100"
          Literal, token: [no token] value: 100
             Type: int_const 100
             Source: "100"
          Literal, token: [no token] value: 100
             Type: int_const 100
             Source: "100"
      Return
         Gas costs: 0
         Source: "return (rate * uint(int(maxBps) + bps)) / maxBps"
        BinaryOperation using operator /
           Type: uint256
           Source: "(rate * uint(int(maxBps) + bps)) / maxBps"
          TupleExpression
             Type: uint256
             Source: "(rate * uint(int(maxBps) + bps))"
            BinaryOperation using operator *
               Type: uint256
               Source: "rate * uint(int(maxBps) + bps)"
              Identifier rate
                 Type: uint256
                 Source: "rate"
              FunctionCall
                 Type: uint256
                 Source: "uint(int(maxBps) + bps)"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                BinaryOperation using operator +
                   Type: int256
                   Source: "int(maxBps) + bps"
                  FunctionCall
                     Type: int256
                     Source: "int(maxBps)"
                    ElementaryTypeNameExpression int
                       Type: type(int256)
                       Source: "int"
                    Identifier maxBps
                       Type: uint256
                       Source: "maxBps"
                  Identifier bps
                     Type: int256
                     Source: "bps"
          Identifier maxBps
             Type: uint256
             Source: "maxBps"
  FunctionDefinition "abs"
     Source: "function abs(int x) internal pure returns(uint) {\r\n        if (x < 0)\r\n            return uint(-1 * x);\r\n        else\r\n            return uint(x);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(int x)"
      VariableDeclaration "x"
         Type: int256
         Source: "int x"
        ElementaryTypeName int
           Source: "int"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (x < 0)\r\n            return uint(-1 * x);\r\n        else\r\n            return uint(x);\r\n    }"
      IfStatement
         Source: "if (x < 0)\r\n            return uint(-1 * x);\r\n        else\r\n            return uint(x)"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "x < 0"
          Identifier x
             Type: int256
             Source: "x"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 0
           Source: "return uint(-1 * x)"
          FunctionCall
             Type: uint256
             Source: "uint(-1 * x)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            BinaryOperation using operator *
               Type: int256
               Source: "-1 * x"
              UnaryOperation (prefix) -
                 Type: int_const -1
                 Source: "-1"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              Identifier x
                 Type: int256
                 Source: "x"
        Return
           Gas costs: 0
           Source: "return uint(x)"
          FunctionCall
             Type: uint256
             Source: "uint(x)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            Identifier x
               Type: int256
               Source: "x"
ContractDefinition "KyberNetwork"
   Source: "contract KyberNetwork is Withdrawable, Utils {\r\n\r\n    uint public negligibleRateDiff = 10; // basic rate steps will be in 0.01%\r\n    KyberReserve[] public reserves;\r\n    mapping(address=>bool) public isReserve;\r\n    WhiteList public whiteListContract;\r\n    ExpectedRateInterface public expectedRateContract;\r\n    FeeBurnerInterface    public feeBurnerContract;\r\n    uint                  public maxGasPrice = 50 * 1000 * 1000 * 1000; // 50 gwei\r\n    bool                  public enabled = false; // network is enabled\r\n    mapping(address=>mapping(bytes32=>bool)) public perReserveListedPairs;\r\n\r\n    function KyberNetwork(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }\r\n\r\n    event EtherReceival(address indexed sender, uint amount);\r\n\r\n    /* solhint-disable no-complex-fallback */\r\n    function() public payable {\r\n        require(isReserve[msg.sender]);\r\n        EtherReceival(msg.sender, msg.value);\r\n    }\r\n    /* solhint-enable no-complex-fallback */\r\n\r\n    event ExecuteTrade(address indexed sender, ERC20 src, ERC20 dest, uint actualSrcAmount, uint actualDestAmount);\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev makes a trade between src and dest token and send dest token to destAddress\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param dest   Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param maxDestAmount A limit on the amount of dest tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @param walletId is the wallet ID to send part of the fees\r\n    /// @return amount of actual dest tokens\r\n    function trade(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )\r\n        public\r\n        payable\r\n        returns(uint)\r\n    {\r\n        require(enabled);\r\n\r\n        uint userSrcBalanceBefore;\r\n        uint userSrcBalanceAfter;\r\n        uint userDestBalanceBefore;\r\n        uint userDestBalanceAfter;\r\n\r\n        userSrcBalanceBefore = getBalance(src, msg.sender);\r\n        if (src == ETH_TOKEN_ADDRESS)\r\n            userSrcBalanceBefore += msg.value;\r\n        userDestBalanceBefore = getBalance(dest, destAddress);\r\n\r\n        uint actualDestAmount = doTrade(src,\r\n                                        srcAmount,\r\n                                        dest,\r\n                                        destAddress,\r\n                                        maxDestAmount,\r\n                                        minConversionRate,\r\n                                        walletId\r\n                                        );\r\n        require(actualDestAmount > 0);\r\n\r\n        userSrcBalanceAfter = getBalance(src, msg.sender);\r\n        userDestBalanceAfter = getBalance(dest, destAddress);\r\n\r\n        require(userSrcBalanceAfter <= userSrcBalanceBefore);\r\n        require(userDestBalanceAfter >= userDestBalanceBefore);\r\n\r\n        require((userDestBalanceAfter - userDestBalanceBefore) >=\r\n            calcDstQty((userSrcBalanceBefore - userSrcBalanceAfter), getDecimals(src), getDecimals(dest),\r\n                minConversionRate));\r\n\r\n        return actualDestAmount;\r\n    }\r\n\r\n    event AddReserveToNetwork(KyberReserve reserve, bool add);\r\n\r\n    /// @notice can be called only by admin\r\n    /// @dev add or deletes a reserve to/from the network.\r\n    /// @param reserve The reserve address.\r\n    /// @param add If true, the add reserve. Otherwise delete reserve.\r\n    function addReserve(KyberReserve reserve, bool add) public onlyAdmin {\r\n\r\n        if (add) {\r\n            require(!isReserve[reserve]);\r\n            reserves.push(reserve);\r\n            isReserve[reserve] = true;\r\n            AddReserveToNetwork(reserve, true);\r\n        } else {\r\n            isReserve[reserve] = false;\r\n            // will have trouble if more than 50k reserves...\r\n            for (uint i = 0; i < reserves.length; i++) {\r\n                if (reserves[i] == reserve) {\r\n                    reserves[i] = reserves[reserves.length - 1];\r\n                    reserves.length--;\r\n                    AddReserveToNetwork(reserve, false);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    event ListReservePairs(address reserve, ERC20 src, ERC20 dest, bool add);\r\n\r\n    /// @notice can be called only by admin\r\n    /// @dev allow or prevent a specific reserve to trade a pair of tokens\r\n    /// @param reserve The reserve address.\r\n    /// @param src Src token\r\n    /// @param dest Destination token\r\n    /// @param add If true then enable trade, otherwise delist pair.\r\n    function listPairForReserve(address reserve, ERC20 src, ERC20 dest, bool add) public onlyAdmin {\r\n        (perReserveListedPairs[reserve])[keccak256(src, dest)] = add;\r\n\r\n        if (src != ETH_TOKEN_ADDRESS) {\r\n            if (add) {\r\n                src.approve(reserve, 2**255); // approve infinity\r\n            } else {\r\n                src.approve(reserve, 0);\r\n            }\r\n        }\r\n\r\n        ListReservePairs(reserve, src, dest, add);\r\n    }\r\n\r\n    function setParams(\r\n        WhiteList _whiteList,\r\n        ExpectedRateInterface _expectedRate,\r\n        FeeBurnerInterface    _feeBurner,\r\n        uint                  _maxGasPrice,\r\n        uint                  _negligibleRateDiff\r\n    )\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(_whiteList != address(0));\r\n        require(_feeBurner != address(0));\r\n        require(_expectedRate != address(0));\r\n        whiteListContract = _whiteList;\r\n        expectedRateContract = _expectedRate;\r\n        feeBurnerContract = _feeBurner;\r\n        maxGasPrice = _maxGasPrice;\r\n        negligibleRateDiff = _negligibleRateDiff;\r\n    }\r\n\r\n    function setEnable(bool _enable) public onlyAdmin {\r\n        if (_enable) {\r\n            require(whiteListContract != address(0));\r\n            require(feeBurnerContract != address(0));\r\n            require(expectedRateContract != address(0));\r\n        }\r\n        enabled = _enable;\r\n    }\r\n\r\n    /// @dev returns number of reserves\r\n    /// @return number of reserves\r\n    function getNumReserves() public view returns(uint) {\r\n        return reserves.length;\r\n    }\r\n\r\n    /// @notice should be called off chain with as much gas as needed\r\n    /// @dev get an array of all reserves\r\n    /// @return An array of all reserves\r\n    function getReserves() public view returns(KyberReserve[]) {\r\n        return reserves;\r\n    }\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(ERC20 token, address user) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return user.balance;\r\n        else\r\n            return token.balanceOf(user);\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev best conversion rate for a pair of tokens, if number of reserves have small differences. randomize\r\n    /// @param src Src token\r\n    /// @param dest Destination token\r\n    /* solhint-disable code-complexity */\r\n    function findBestRate(ERC20 src, ERC20 dest, uint srcQty) public view returns(uint, uint) {\r\n        uint bestRate = 0;\r\n        uint bestReserve = 0;\r\n        uint numRelevantReserves = 0;\r\n        uint numReserves = reserves.length;\r\n        uint[] memory rates = new uint[](numReserves);\r\n        uint[] memory reserveCandidates = new uint[](numReserves);\r\n\r\n        for (uint i = 0; i < numReserves; i++) {\r\n            //list all reserves that have this token.\r\n            if (!(perReserveListedPairs[reserves[i]])[keccak256(src, dest)]) continue;\r\n\r\n            rates[i] = reserves[i].getConversionRate(src, dest, srcQty, block.number);\r\n\r\n            if (rates[i] > bestRate) {\r\n                //best rate is highest rate\r\n                bestRate = rates[i];\r\n            }\r\n        }\r\n\r\n        if (bestRate > 0) {\r\n            uint random = 0;\r\n            uint smallestRelevantRate = (bestRate * 10000) / (10000 + negligibleRateDiff);\r\n\r\n            for (i = 0; i < numReserves; i++) {\r\n                if (rates[i] >= smallestRelevantRate) {\r\n                    reserveCandidates[numRelevantReserves++] = i;\r\n                }\r\n            }\r\n\r\n            if (numRelevantReserves > 1) {\r\n                //when encountering small rate diff from bestRate. draw from relevant reserves\r\n                random = uint(block.blockhash(block.number-1)) % numRelevantReserves;\r\n            }\r\n\r\n            bestReserve = reserveCandidates[random];\r\n            bestRate = rates[bestReserve];\r\n        }\r\n\r\n        return (bestReserve, bestRate);\r\n    }\r\n    /* solhint-enable code-complexity */\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\r\n        public view\r\n        returns (uint expectedRate, uint slippageRate)\r\n    {\r\n        require(expectedRateContract != address(0));\r\n        return expectedRateContract.getExpectedRate(src, dest, srcQty);\r\n    }\r\n\r\n    function getUserCapInWei(address user) public view returns(uint) {\r\n        return whiteListContract.getUserCapInWei(user);\r\n    }\r\n\r\n    function doTrade(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )\r\n        internal\r\n        returns(uint)\r\n    {\r\n        require(tx.gasprice <= maxGasPrice);\r\n        require(validateTradeInput(src, srcAmount, destAddress));\r\n\r\n        uint reserveInd;\r\n        uint rate;\r\n\r\n        (reserveInd, rate) = findBestRate(src, dest, srcAmount);\r\n        KyberReserve theReserve = reserves[reserveInd];\r\n        require(rate > 0);\r\n        require(rate < MAX_RATE);\r\n        require(rate >= minConversionRate);\r\n\r\n        uint actualSrcAmount = srcAmount;\r\n        uint actualDestAmount = calcDestAmount(src, dest, actualSrcAmount, rate);\r\n        if (actualDestAmount > maxDestAmount) {\r\n            actualDestAmount = maxDestAmount;\r\n            actualSrcAmount = calcSrcAmount(src, dest, actualDestAmount, rate);\r\n            require(actualSrcAmount <= srcAmount);\r\n        }\r\n\r\n        // do the trade\r\n        // verify trade size is smaller than user cap\r\n        uint ethAmount;\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            ethAmount = actualSrcAmount;\r\n        } else {\r\n            ethAmount = actualDestAmount;\r\n        }\r\n\r\n        require(ethAmount <= getUserCapInWei(msg.sender));\r\n        require(doReserveTrade(\r\n                src,\r\n                actualSrcAmount,\r\n                dest,\r\n                destAddress,\r\n                actualDestAmount,\r\n                theReserve,\r\n                rate,\r\n                true));\r\n\r\n        if ((actualSrcAmount < srcAmount) && (src == ETH_TOKEN_ADDRESS)) {\r\n            msg.sender.transfer(srcAmount - actualSrcAmount);\r\n        }\r\n\r\n        require(feeBurnerContract.handleFees(ethAmount, theReserve, walletId));\r\n\r\n        ExecuteTrade(msg.sender, src, dest, actualSrcAmount, actualDestAmount);\r\n        return actualDestAmount;\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev do one trade with a reserve\r\n    /// @param src Src token\r\n    /// @param amount amount of src tokens\r\n    /// @param dest   Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param reserve Reserve to use\r\n    /// @param validate If true, additional validations are applicable\r\n    /// @return true if trade is successful\r\n    function doReserveTrade(\r\n        ERC20 src,\r\n        uint amount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint expectedDestAmount,\r\n        KyberReserve reserve,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint callValue = 0;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            callValue = amount;\r\n        } else {\r\n            // take src tokens to this contract\r\n            src.transferFrom(msg.sender, this, amount);\r\n        }\r\n\r\n        // reserve sends tokens/eth to network. network sends it to destination\r\n        require(reserve.trade.value(callValue)(src, amount, dest, this, conversionRate, validate));\r\n\r\n        if (dest == ETH_TOKEN_ADDRESS) {\r\n            destAddress.transfer(expectedDestAmount);\r\n        } else {\r\n            require(dest.transfer(destAddress, expectedDestAmount));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return 18;\r\n        return token.decimals();\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev checks that user sent ether/tokens to contract before trade\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @return true if input is valid\r\n    function validateTradeInput(ERC20 src, uint srcAmount, address destAddress) internal view returns(bool) {\r\n        if ((srcAmount >= MAX_QTY) || (srcAmount == 0) || (destAddress == 0))\r\n            return false;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            if (msg.value != srcAmount)\r\n                return false;\r\n        } else {\r\n            if ((msg.value != 0) || (src.allowance(msg.sender, this) < srcAmount))\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Withdrawable"
    UserDefinedTypeName "Withdrawable"
       Source: "Withdrawable"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Utils"
    UserDefinedTypeName "Utils"
       Source: "Utils"
  VariableDeclaration "negligibleRateDiff"
     Type: uint256
     Gas costs: 0
     Source: "uint public negligibleRateDiff = 10"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 10
       Type: int_const 10
       Source: "10"
  VariableDeclaration "reserves"
     Type: contract KyberReserve[] storage ref
     Gas costs: 0
     Source: "KyberReserve[] public reserves"
    ArrayTypeName
       Source: "KyberReserve[]"
      UserDefinedTypeName "KyberReserve"
         Source: "KyberReserve"
  VariableDeclaration "isReserve"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping(address=>bool) public isReserve"
    Mapping
       Source: "mapping(address=>bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "whiteListContract"
     Type: contract WhiteList
     Gas costs: 0
     Source: "WhiteList public whiteListContract"
    UserDefinedTypeName "WhiteList"
       Source: "WhiteList"
  VariableDeclaration "expectedRateContract"
     Type: contract ExpectedRateInterface
     Gas costs: 0
     Source: "ExpectedRateInterface public expectedRateContract"
    UserDefinedTypeName "ExpectedRateInterface"
       Source: "ExpectedRateInterface"
  VariableDeclaration "feeBurnerContract"
     Type: contract FeeBurnerInterface
     Gas costs: 0
     Source: "FeeBurnerInterface    public feeBurnerContract"
    UserDefinedTypeName "FeeBurnerInterface"
       Source: "FeeBurnerInterface"
  VariableDeclaration "maxGasPrice"
     Type: uint256
     Gas costs: 0
     Source: "uint                  public maxGasPrice = 50 * 1000 * 1000 * 1000"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: int_const 50000000000
       Source: "50 * 1000 * 1000 * 1000"
      BinaryOperation using operator *
         Type: int_const 50000000
         Source: "50 * 1000 * 1000"
        BinaryOperation using operator *
           Type: int_const 50000
           Source: "50 * 1000"
          Literal, token: [no token] value: 50
             Type: int_const 50
             Source: "50"
          Literal, token: [no token] value: 1000
             Type: int_const 1000
             Source: "1000"
        Literal, token: [no token] value: 1000
           Type: int_const 1000
           Source: "1000"
      Literal, token: [no token] value: 1000
         Type: int_const 1000
         Source: "1000"
  VariableDeclaration "enabled"
     Type: bool
     Gas costs: 0
     Source: "bool                  public enabled = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "perReserveListedPairs"
     Type: mapping(address => mapping(bytes32 => bool))
     Gas costs: 0
     Source: "mapping(address=>mapping(bytes32=>bool)) public perReserveListedPairs"
    Mapping
       Source: "mapping(address=>mapping(bytes32=>bool))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping(bytes32=>bool)"
        ElementaryTypeName bytes32
           Source: "bytes32"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "KyberNetwork" - public
     Source: "function KyberNetwork(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _admin)"
      VariableDeclaration "_admin"
         Type: address
         Source: "address _admin"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_admin != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_admin != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_admin != address(0)"
            Identifier _admin
               Type: address
               Source: "_admin"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "admin = _admin"
        Assignment using operator =
           Type: address
           Source: "admin = _admin"
          Identifier admin
             Type: address
             Source: "admin"
          Identifier _admin
             Type: address
             Source: "_admin"
  EventDefinition "EtherReceival"
     Gas costs: 0
     Source: "event EtherReceival(address indexed sender, uint amount);"
    ParameterList
       Source: "(address indexed sender, uint amount)"
      VariableDeclaration "sender"
         Type: address
         Source: "address indexed sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "" - public
     Source: "function() public payable {\r\n        require(isReserve[msg.sender]);\r\n        EtherReceival(msg.sender, msg.value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(isReserve[msg.sender]);\r\n        EtherReceival(msg.sender, msg.value);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(isReserve[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(isReserve[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          IndexAccess
             Type: bool
             Source: "isReserve[msg.sender]"
            Identifier isReserve
               Type: mapping(address => bool)
               Source: "isReserve"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "EtherReceival(msg.sender, msg.value)"
        FunctionCall
           Type: tuple()
           Source: "EtherReceival(msg.sender, msg.value)"
          Identifier EtherReceival
             Type: function (address,uint256)
             Source: "EtherReceival"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
  EventDefinition "ExecuteTrade"
     Gas costs: 0
     Source: "event ExecuteTrade(address indexed sender, ERC20 src, ERC20 dest, uint actualSrcAmount, uint actualDestAmount);"
    ParameterList
       Source: "(address indexed sender, ERC20 src, ERC20 dest, uint actualSrcAmount, uint actualDestAmount)"
      VariableDeclaration "sender"
         Type: address
         Source: "address indexed sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "actualSrcAmount"
         Type: uint256
         Source: "uint actualSrcAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "actualDestAmount"
         Type: uint256
         Source: "uint actualDestAmount"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "trade" - public
     Source: "function trade(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )\r\n        public\r\n        payable\r\n        returns(uint)\r\n    {\r\n        require(enabled);\r\n\r\n        uint userSrcBalanceBefore;\r\n        uint userSrcBalanceAfter;\r\n        uint userDestBalanceBefore;\r\n        uint userDestBalanceAfter;\r\n\r\n        userSrcBalanceBefore = getBalance(src, msg.sender);\r\n        if (src == ETH_TOKEN_ADDRESS)\r\n            userSrcBalanceBefore += msg.value;\r\n        userDestBalanceBefore = getBalance(dest, destAddress);\r\n\r\n        uint actualDestAmount = doTrade(src,\r\n                                        srcAmount,\r\n                                        dest,\r\n                                        destAddress,\r\n                                        maxDestAmount,\r\n                                        minConversionRate,\r\n                                        walletId\r\n                                        );\r\n        require(actualDestAmount > 0);\r\n\r\n        userSrcBalanceAfter = getBalance(src, msg.sender);\r\n        userDestBalanceAfter = getBalance(dest, destAddress);\r\n\r\n        require(userSrcBalanceAfter <= userSrcBalanceBefore);\r\n        require(userDestBalanceAfter >= userDestBalanceBefore);\r\n\r\n        require((userDestBalanceAfter - userDestBalanceBefore) >=\r\n            calcDstQty((userSrcBalanceBefore - userSrcBalanceAfter), getDecimals(src), getDecimals(dest),\r\n                minConversionRate));\r\n\r\n        return actualDestAmount;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "srcAmount"
         Type: uint256
         Source: "uint srcAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "destAddress"
         Type: address
         Source: "address destAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "maxDestAmount"
         Type: uint256
         Source: "uint maxDestAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "minConversionRate"
         Type: uint256
         Source: "uint minConversionRate"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "walletId"
         Type: address
         Source: "address walletId"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(enabled);\r\n\r\n        uint userSrcBalanceBefore;\r\n        uint userSrcBalanceAfter;\r\n        uint userDestBalanceBefore;\r\n        uint userDestBalanceAfter;\r\n\r\n        userSrcBalanceBefore = getBalance(src, msg.sender);\r\n        if (src == ETH_TOKEN_ADDRESS)\r\n            userSrcBalanceBefore += msg.value;\r\n        userDestBalanceBefore = getBalance(dest, destAddress);\r\n\r\n        uint actualDestAmount = doTrade(src,\r\n                                        srcAmount,\r\n                                        dest,\r\n                                        destAddress,\r\n                                        maxDestAmount,\r\n                                        minConversionRate,\r\n                                        walletId\r\n                                        );\r\n        require(actualDestAmount > 0);\r\n\r\n        userSrcBalanceAfter = getBalance(src, msg.sender);\r\n        userDestBalanceAfter = getBalance(dest, destAddress);\r\n\r\n        require(userSrcBalanceAfter <= userSrcBalanceBefore);\r\n        require(userDestBalanceAfter >= userDestBalanceBefore);\r\n\r\n        require((userDestBalanceAfter - userDestBalanceBefore) >=\r\n            calcDstQty((userSrcBalanceBefore - userSrcBalanceAfter), getDecimals(src), getDecimals(dest),\r\n                minConversionRate));\r\n\r\n        return actualDestAmount;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(enabled)"
        FunctionCall
           Type: tuple()
           Source: "require(enabled)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier enabled
             Type: bool
             Source: "enabled"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint userSrcBalanceBefore"
        VariableDeclaration "userSrcBalanceBefore"
           Type: uint256
           Source: "uint userSrcBalanceBefore"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint userSrcBalanceAfter"
        VariableDeclaration "userSrcBalanceAfter"
           Type: uint256
           Source: "uint userSrcBalanceAfter"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint userDestBalanceBefore"
        VariableDeclaration "userDestBalanceBefore"
           Type: uint256
           Source: "uint userDestBalanceBefore"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint userDestBalanceAfter"
        VariableDeclaration "userDestBalanceAfter"
           Type: uint256
           Source: "uint userDestBalanceAfter"
          ElementaryTypeName uint
             Source: "uint"
      ExpressionStatement
         Gas costs: 0
         Source: "userSrcBalanceBefore = getBalance(src, msg.sender)"
        Assignment using operator =
           Type: uint256
           Source: "userSrcBalanceBefore = getBalance(src, msg.sender)"
          Identifier userSrcBalanceBefore
             Type: uint256
             Source: "userSrcBalanceBefore"
          FunctionCall
             Type: uint256
             Source: "getBalance(src, msg.sender)"
            Identifier getBalance
               Type: function (contract ERC20,address) view returns (uint256)
               Source: "getBalance"
            Identifier src
               Type: contract ERC20
               Source: "src"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      IfStatement
         Source: "if (src == ETH_TOKEN_ADDRESS)\r\n            userSrcBalanceBefore += msg.value"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "src == ETH_TOKEN_ADDRESS"
          Identifier src
             Type: contract ERC20
             Source: "src"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        ExpressionStatement
           Gas costs: 0
           Source: "userSrcBalanceBefore += msg.value"
          Assignment using operator +=
             Type: uint256
             Source: "userSrcBalanceBefore += msg.value"
            Identifier userSrcBalanceBefore
               Type: uint256
               Source: "userSrcBalanceBefore"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "userDestBalanceBefore = getBalance(dest, destAddress)"
        Assignment using operator =
           Type: uint256
           Source: "userDestBalanceBefore = getBalance(dest, destAddress)"
          Identifier userDestBalanceBefore
             Type: uint256
             Source: "userDestBalanceBefore"
          FunctionCall
             Type: uint256
             Source: "getBalance(dest, destAddress)"
            Identifier getBalance
               Type: function (contract ERC20,address) view returns (uint256)
               Source: "getBalance"
            Identifier dest
               Type: contract ERC20
               Source: "dest"
            Identifier destAddress
               Type: address
               Source: "destAddress"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint actualDestAmount = doTrade(src,\r\n                                        srcAmount,\r\n                                        dest,\r\n                                        destAddress,\r\n                                        maxDestAmount,\r\n                                        minConversionRate,\r\n                                        walletId\r\n                                        )"
        VariableDeclaration "actualDestAmount"
           Type: uint256
           Source: "uint actualDestAmount"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "doTrade(src,\r\n                                        srcAmount,\r\n                                        dest,\r\n                                        destAddress,\r\n                                        maxDestAmount,\r\n                                        minConversionRate,\r\n                                        walletId\r\n                                        )"
          Identifier doTrade
             Type: function (contract ERC20,uint256,contract ERC20,address,uint256,uint256,address) returns (uint256)
             Source: "doTrade"
          Identifier src
             Type: contract ERC20
             Source: "src"
          Identifier srcAmount
             Type: uint256
             Source: "srcAmount"
          Identifier dest
             Type: contract ERC20
             Source: "dest"
          Identifier destAddress
             Type: address
             Source: "destAddress"
          Identifier maxDestAmount
             Type: uint256
             Source: "maxDestAmount"
          Identifier minConversionRate
             Type: uint256
             Source: "minConversionRate"
          Identifier walletId
             Type: address
             Source: "walletId"
      ExpressionStatement
         Gas costs: 0
         Source: "require(actualDestAmount > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(actualDestAmount > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "actualDestAmount > 0"
            Identifier actualDestAmount
               Type: uint256
               Source: "actualDestAmount"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "userSrcBalanceAfter = getBalance(src, msg.sender)"
        Assignment using operator =
           Type: uint256
           Source: "userSrcBalanceAfter = getBalance(src, msg.sender)"
          Identifier userSrcBalanceAfter
             Type: uint256
             Source: "userSrcBalanceAfter"
          FunctionCall
             Type: uint256
             Source: "getBalance(src, msg.sender)"
            Identifier getBalance
               Type: function (contract ERC20,address) view returns (uint256)
               Source: "getBalance"
            Identifier src
               Type: contract ERC20
               Source: "src"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "userDestBalanceAfter = getBalance(dest, destAddress)"
        Assignment using operator =
           Type: uint256
           Source: "userDestBalanceAfter = getBalance(dest, destAddress)"
          Identifier userDestBalanceAfter
             Type: uint256
             Source: "userDestBalanceAfter"
          FunctionCall
             Type: uint256
             Source: "getBalance(dest, destAddress)"
            Identifier getBalance
               Type: function (contract ERC20,address) view returns (uint256)
               Source: "getBalance"
            Identifier dest
               Type: contract ERC20
               Source: "dest"
            Identifier destAddress
               Type: address
               Source: "destAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "require(userSrcBalanceAfter <= userSrcBalanceBefore)"
        FunctionCall
           Type: tuple()
           Source: "require(userSrcBalanceAfter <= userSrcBalanceBefore)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "userSrcBalanceAfter <= userSrcBalanceBefore"
            Identifier userSrcBalanceAfter
               Type: uint256
               Source: "userSrcBalanceAfter"
            Identifier userSrcBalanceBefore
               Type: uint256
               Source: "userSrcBalanceBefore"
      ExpressionStatement
         Gas costs: 0
         Source: "require(userDestBalanceAfter >= userDestBalanceBefore)"
        FunctionCall
           Type: tuple()
           Source: "require(userDestBalanceAfter >= userDestBalanceBefore)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "userDestBalanceAfter >= userDestBalanceBefore"
            Identifier userDestBalanceAfter
               Type: uint256
               Source: "userDestBalanceAfter"
            Identifier userDestBalanceBefore
               Type: uint256
               Source: "userDestBalanceBefore"
      ExpressionStatement
         Gas costs: 0
         Source: "require((userDestBalanceAfter - userDestBalanceBefore) >=\r\n            calcDstQty((userSrcBalanceBefore - userSrcBalanceAfter), getDecimals(src), getDecimals(dest),\r\n                minConversionRate))"
        FunctionCall
           Type: tuple()
           Source: "require((userDestBalanceAfter - userDestBalanceBefore) >=\r\n            calcDstQty((userSrcBalanceBefore - userSrcBalanceAfter), getDecimals(src), getDecimals(dest),\r\n                minConversionRate))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "(userDestBalanceAfter - userDestBalanceBefore) >=\r\n            calcDstQty((userSrcBalanceBefore - userSrcBalanceAfter), getDecimals(src), getDecimals(dest),\r\n                minConversionRate)"
            TupleExpression
               Type: uint256
               Source: "(userDestBalanceAfter - userDestBalanceBefore)"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "userDestBalanceAfter - userDestBalanceBefore"
                Identifier userDestBalanceAfter
                   Type: uint256
                   Source: "userDestBalanceAfter"
                Identifier userDestBalanceBefore
                   Type: uint256
                   Source: "userDestBalanceBefore"
            FunctionCall
               Type: uint256
               Source: "calcDstQty((userSrcBalanceBefore - userSrcBalanceAfter), getDecimals(src), getDecimals(dest),\r\n                minConversionRate)"
              Identifier calcDstQty
                 Type: function (uint256,uint256,uint256,uint256) pure returns (uint256)
                 Source: "calcDstQty"
              TupleExpression
                 Type: uint256
                 Source: "(userSrcBalanceBefore - userSrcBalanceAfter)"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "userSrcBalanceBefore - userSrcBalanceAfter"
                  Identifier userSrcBalanceBefore
                     Type: uint256
                     Source: "userSrcBalanceBefore"
                  Identifier userSrcBalanceAfter
                     Type: uint256
                     Source: "userSrcBalanceAfter"
              FunctionCall
                 Type: uint256
                 Source: "getDecimals(src)"
                Identifier getDecimals
                   Type: function (contract ERC20) view returns (uint256)
                   Source: "getDecimals"
                Identifier src
                   Type: contract ERC20
                   Source: "src"
              FunctionCall
                 Type: uint256
                 Source: "getDecimals(dest)"
                Identifier getDecimals
                   Type: function (contract ERC20) view returns (uint256)
                   Source: "getDecimals"
                Identifier dest
                   Type: contract ERC20
                   Source: "dest"
              Identifier minConversionRate
                 Type: uint256
                 Source: "minConversionRate"
      Return
         Gas costs: 0
         Source: "return actualDestAmount"
        Identifier actualDestAmount
           Type: uint256
           Source: "actualDestAmount"
  EventDefinition "AddReserveToNetwork"
     Gas costs: 0
     Source: "event AddReserveToNetwork(KyberReserve reserve, bool add);"
    ParameterList
       Source: "(KyberReserve reserve, bool add)"
      VariableDeclaration "reserve"
         Type: contract KyberReserve
         Source: "KyberReserve reserve"
        UserDefinedTypeName "KyberReserve"
           Source: "KyberReserve"
      VariableDeclaration "add"
         Type: bool
         Source: "bool add"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "addReserve" - public
     Source: "function addReserve(KyberReserve reserve, bool add) public onlyAdmin {\r\n\r\n        if (add) {\r\n            require(!isReserve[reserve]);\r\n            reserves.push(reserve);\r\n            isReserve[reserve] = true;\r\n            AddReserveToNetwork(reserve, true);\r\n        } else {\r\n            isReserve[reserve] = false;\r\n            // will have trouble if more than 50k reserves...\r\n            for (uint i = 0; i < reserves.length; i++) {\r\n                if (reserves[i] == reserve) {\r\n                    reserves[i] = reserves[reserves.length - 1];\r\n                    reserves.length--;\r\n                    AddReserveToNetwork(reserve, false);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(KyberReserve reserve, bool add)"
      VariableDeclaration "reserve"
         Type: contract KyberReserve
         Source: "KyberReserve reserve"
        UserDefinedTypeName "KyberReserve"
           Source: "KyberReserve"
      VariableDeclaration "add"
         Type: bool
         Source: "bool add"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n\r\n        if (add) {\r\n            require(!isReserve[reserve]);\r\n            reserves.push(reserve);\r\n            isReserve[reserve] = true;\r\n            AddReserveToNetwork(reserve, true);\r\n        } else {\r\n            isReserve[reserve] = false;\r\n            // will have trouble if more than 50k reserves...\r\n            for (uint i = 0; i < reserves.length; i++) {\r\n                if (reserves[i] == reserve) {\r\n                    reserves[i] = reserves[reserves.length - 1];\r\n                    reserves.length--;\r\n                    AddReserveToNetwork(reserve, false);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }"
      IfStatement
         Source: "if (add) {\r\n            require(!isReserve[reserve]);\r\n            reserves.push(reserve);\r\n            isReserve[reserve] = true;\r\n            AddReserveToNetwork(reserve, true);\r\n        } else {\r\n            isReserve[reserve] = false;\r\n            // will have trouble if more than 50k reserves...\r\n            for (uint i = 0; i < reserves.length; i++) {\r\n                if (reserves[i] == reserve) {\r\n                    reserves[i] = reserves[reserves.length - 1];\r\n                    reserves.length--;\r\n                    AddReserveToNetwork(reserve, false);\r\n                    break;\r\n                }\r\n            }\r\n        }"
        Identifier add
           Type: bool
           Gas costs: 0
           Source: "add"
        Block
           Source: "{\r\n            require(!isReserve[reserve]);\r\n            reserves.push(reserve);\r\n            isReserve[reserve] = true;\r\n            AddReserveToNetwork(reserve, true);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require(!isReserve[reserve])"
            FunctionCall
               Type: tuple()
               Source: "require(!isReserve[reserve])"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              UnaryOperation (prefix) !
                 Type: bool
                 Source: "!isReserve[reserve]"
                IndexAccess
                   Type: bool
                   Source: "isReserve[reserve]"
                  Identifier isReserve
                     Type: mapping(address => bool)
                     Source: "isReserve"
                  Identifier reserve
                     Type: contract KyberReserve
                     Source: "reserve"
          ExpressionStatement
             Gas costs: 0
             Source: "reserves.push(reserve)"
            FunctionCall
               Type: uint256
               Source: "reserves.push(reserve)"
              MemberAccess to member push
                 Type: function (contract KyberReserve) returns (uint256)
                 Source: "reserves.push"
                Identifier reserves
                   Type: contract KyberReserve[] storage ref
                   Source: "reserves"
              Identifier reserve
                 Type: contract KyberReserve
                 Source: "reserve"
          ExpressionStatement
             Gas costs: 0
             Source: "isReserve[reserve] = true"
            Assignment using operator =
               Type: bool
               Source: "isReserve[reserve] = true"
              IndexAccess
                 Type: bool
                 Source: "isReserve[reserve]"
                Identifier isReserve
                   Type: mapping(address => bool)
                   Source: "isReserve"
                Identifier reserve
                   Type: contract KyberReserve
                   Source: "reserve"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
          ExpressionStatement
             Gas costs: 0
             Source: "AddReserveToNetwork(reserve, true)"
            FunctionCall
               Type: tuple()
               Source: "AddReserveToNetwork(reserve, true)"
              Identifier AddReserveToNetwork
                 Type: function (contract KyberReserve,bool)
                 Source: "AddReserveToNetwork"
              Identifier reserve
                 Type: contract KyberReserve
                 Source: "reserve"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
        Block
           Source: "{\r\n            isReserve[reserve] = false;\r\n            // will have trouble if more than 50k reserves...\r\n            for (uint i = 0; i < reserves.length; i++) {\r\n                if (reserves[i] == reserve) {\r\n                    reserves[i] = reserves[reserves.length - 1];\r\n                    reserves.length--;\r\n                    AddReserveToNetwork(reserve, false);\r\n                    break;\r\n                }\r\n            }\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "isReserve[reserve] = false"
            Assignment using operator =
               Type: bool
               Source: "isReserve[reserve] = false"
              IndexAccess
                 Type: bool
                 Source: "isReserve[reserve]"
                Identifier isReserve
                   Type: mapping(address => bool)
                   Source: "isReserve"
                Identifier reserve
                   Type: contract KyberReserve
                   Source: "reserve"
              Literal, token: false value: false
                 Type: bool
                 Source: "false"
          ForStatement
             Source: "for (uint i = 0; i < reserves.length; i++) {\r\n                if (reserves[i] == reserve) {\r\n                    reserves[i] = reserves[reserves.length - 1];\r\n                    reserves.length--;\r\n                    AddReserveToNetwork(reserve, false);\r\n                    break;\r\n                }\r\n            }"
            VariableDeclarationStatement
               Gas costs: 0
               Source: "uint i = 0"
              VariableDeclaration "i"
                 Type: uint256
                 Source: "uint i"
                ElementaryTypeName uint
                   Source: "uint"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 0
               Source: "i < reserves.length"
              Identifier i
                 Type: uint256
                 Source: "i"
              MemberAccess to member length
                 Type: uint256
                 Source: "reserves.length"
                Identifier reserves
                   Type: contract KyberReserve[] storage ref
                   Source: "reserves"
            ExpressionStatement
               Gas costs: 0
               Source: "i++"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "i++"
                Identifier i
                   Type: uint256
                   Source: "i"
            Block
               Source: "{\r\n                if (reserves[i] == reserve) {\r\n                    reserves[i] = reserves[reserves.length - 1];\r\n                    reserves.length--;\r\n                    AddReserveToNetwork(reserve, false);\r\n                    break;\r\n                }\r\n            }"
              IfStatement
                 Source: "if (reserves[i] == reserve) {\r\n                    reserves[i] = reserves[reserves.length - 1];\r\n                    reserves.length--;\r\n                    AddReserveToNetwork(reserve, false);\r\n                    break;\r\n                }"
                BinaryOperation using operator ==
                   Type: bool
                   Gas costs: 0
                   Source: "reserves[i] == reserve"
                  IndexAccess
                     Type: contract KyberReserve
                     Source: "reserves[i]"
                    Identifier reserves
                       Type: contract KyberReserve[] storage ref
                       Source: "reserves"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  Identifier reserve
                     Type: contract KyberReserve
                     Source: "reserve"
                Block
                   Source: "{\r\n                    reserves[i] = reserves[reserves.length - 1];\r\n                    reserves.length--;\r\n                    AddReserveToNetwork(reserve, false);\r\n                    break;\r\n                }"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "reserves[i] = reserves[reserves.length - 1]"
                    Assignment using operator =
                       Type: contract KyberReserve
                       Source: "reserves[i] = reserves[reserves.length - 1]"
                      IndexAccess
                         Type: contract KyberReserve
                         Source: "reserves[i]"
                        Identifier reserves
                           Type: contract KyberReserve[] storage ref
                           Source: "reserves"
                        Identifier i
                           Type: uint256
                           Source: "i"
                      IndexAccess
                         Type: contract KyberReserve
                         Source: "reserves[reserves.length - 1]"
                        Identifier reserves
                           Type: contract KyberReserve[] storage ref
                           Source: "reserves"
                        BinaryOperation using operator -
                           Type: uint256
                           Source: "reserves.length - 1"
                          MemberAccess to member length
                             Type: uint256
                             Source: "reserves.length"
                            Identifier reserves
                               Type: contract KyberReserve[] storage ref
                               Source: "reserves"
                          Literal, token: [no token] value: 1
                             Type: int_const 1
                             Source: "1"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "reserves.length--"
                    UnaryOperation (postfix) --
                       Type: uint256
                       Source: "reserves.length--"
                      MemberAccess to member length
                         Type: uint256
                         Source: "reserves.length"
                        Identifier reserves
                           Type: contract KyberReserve[] storage ref
                           Source: "reserves"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "AddReserveToNetwork(reserve, false)"
                    FunctionCall
                       Type: tuple()
                       Source: "AddReserveToNetwork(reserve, false)"
                      Identifier AddReserveToNetwork
                         Type: function (contract KyberReserve,bool)
                         Source: "AddReserveToNetwork"
                      Identifier reserve
                         Type: contract KyberReserve
                         Source: "reserve"
                      Literal, token: false value: false
                         Type: bool
                         Source: "false"
                  Break
                     Gas costs: 0
                     Source: "break"
  EventDefinition "ListReservePairs"
     Gas costs: 0
     Source: "event ListReservePairs(address reserve, ERC20 src, ERC20 dest, bool add);"
    ParameterList
       Source: "(address reserve, ERC20 src, ERC20 dest, bool add)"
      VariableDeclaration "reserve"
         Type: address
         Source: "address reserve"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "add"
         Type: bool
         Source: "bool add"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "listPairForReserve" - public
     Source: "function listPairForReserve(address reserve, ERC20 src, ERC20 dest, bool add) public onlyAdmin {\r\n        (perReserveListedPairs[reserve])[keccak256(src, dest)] = add;\r\n\r\n        if (src != ETH_TOKEN_ADDRESS) {\r\n            if (add) {\r\n                src.approve(reserve, 2**255); // approve infinity\r\n            } else {\r\n                src.approve(reserve, 0);\r\n            }\r\n        }\r\n\r\n        ListReservePairs(reserve, src, dest, add);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address reserve, ERC20 src, ERC20 dest, bool add)"
      VariableDeclaration "reserve"
         Type: address
         Source: "address reserve"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "add"
         Type: bool
         Source: "bool add"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        (perReserveListedPairs[reserve])[keccak256(src, dest)] = add;\r\n\r\n        if (src != ETH_TOKEN_ADDRESS) {\r\n            if (add) {\r\n                src.approve(reserve, 2**255); // approve infinity\r\n            } else {\r\n                src.approve(reserve, 0);\r\n            }\r\n        }\r\n\r\n        ListReservePairs(reserve, src, dest, add);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "(perReserveListedPairs[reserve])[keccak256(src, dest)] = add"
        Assignment using operator =
           Type: bool
           Source: "(perReserveListedPairs[reserve])[keccak256(src, dest)] = add"
          IndexAccess
             Type: bool
             Source: "(perReserveListedPairs[reserve])[keccak256(src, dest)]"
            TupleExpression
               Type: mapping(bytes32 => bool)
               Source: "(perReserveListedPairs[reserve])"
              IndexAccess
                 Type: mapping(bytes32 => bool)
                 Source: "perReserveListedPairs[reserve]"
                Identifier perReserveListedPairs
                   Type: mapping(address => mapping(bytes32 => bool))
                   Source: "perReserveListedPairs"
                Identifier reserve
                   Type: address
                   Source: "reserve"
            FunctionCall
               Type: bytes32
               Source: "keccak256(src, dest)"
              Identifier keccak256
                 Type: function () pure returns (bytes32)
                 Source: "keccak256"
              Identifier src
                 Type: contract ERC20
                 Source: "src"
              Identifier dest
                 Type: contract ERC20
                 Source: "dest"
          Identifier add
             Type: bool
             Source: "add"
      IfStatement
         Source: "if (src != ETH_TOKEN_ADDRESS) {\r\n            if (add) {\r\n                src.approve(reserve, 2**255); // approve infinity\r\n            } else {\r\n                src.approve(reserve, 0);\r\n            }\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "src != ETH_TOKEN_ADDRESS"
          Identifier src
             Type: contract ERC20
             Source: "src"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        Block
           Source: "{\r\n            if (add) {\r\n                src.approve(reserve, 2**255); // approve infinity\r\n            } else {\r\n                src.approve(reserve, 0);\r\n            }\r\n        }"
          IfStatement
             Source: "if (add) {\r\n                src.approve(reserve, 2**255); // approve infinity\r\n            } else {\r\n                src.approve(reserve, 0);\r\n            }"
            Identifier add
               Type: bool
               Gas costs: 0
               Source: "add"
            Block
               Source: "{\r\n                src.approve(reserve, 2**255); // approve infinity\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "src.approve(reserve, 2**255)"
                FunctionCall
                   Type: bool
                   Source: "src.approve(reserve, 2**255)"
                  MemberAccess to member approve
                     Type: function (address,uint256) external returns (bool)
                     Source: "src.approve"
                    Identifier src
                       Type: contract ERC20
                       Source: "src"
                  Identifier reserve
                     Type: address
                     Source: "reserve"
                  BinaryOperation using operator **
                     Type: int_const 5789...(69 digits omitted)...9968
                     Source: "2**255"
                    Literal, token: [no token] value: 2
                       Type: int_const 2
                       Source: "2"
                    Literal, token: [no token] value: 255
                       Type: int_const 255
                       Source: "255"
            Block
               Source: "{\r\n                src.approve(reserve, 0);\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "src.approve(reserve, 0)"
                FunctionCall
                   Type: bool
                   Source: "src.approve(reserve, 0)"
                  MemberAccess to member approve
                     Type: function (address,uint256) external returns (bool)
                     Source: "src.approve"
                    Identifier src
                       Type: contract ERC20
                       Source: "src"
                  Identifier reserve
                     Type: address
                     Source: "reserve"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "ListReservePairs(reserve, src, dest, add)"
        FunctionCall
           Type: tuple()
           Source: "ListReservePairs(reserve, src, dest, add)"
          Identifier ListReservePairs
             Type: function (address,contract ERC20,contract ERC20,bool)
             Source: "ListReservePairs"
          Identifier reserve
             Type: address
             Source: "reserve"
          Identifier src
             Type: contract ERC20
             Source: "src"
          Identifier dest
             Type: contract ERC20
             Source: "dest"
          Identifier add
             Type: bool
             Source: "add"
  FunctionDefinition "setParams" - public
     Source: "function setParams(\r\n        WhiteList _whiteList,\r\n        ExpectedRateInterface _expectedRate,\r\n        FeeBurnerInterface    _feeBurner,\r\n        uint                  _maxGasPrice,\r\n        uint                  _negligibleRateDiff\r\n    )\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(_whiteList != address(0));\r\n        require(_feeBurner != address(0));\r\n        require(_expectedRate != address(0));\r\n        whiteListContract = _whiteList;\r\n        expectedRateContract = _expectedRate;\r\n        feeBurnerContract = _feeBurner;\r\n        maxGasPrice = _maxGasPrice;\r\n        negligibleRateDiff = _negligibleRateDiff;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        WhiteList _whiteList,\r\n        ExpectedRateInterface _expectedRate,\r\n        FeeBurnerInterface    _feeBurner,\r\n        uint                  _maxGasPrice,\r\n        uint                  _negligibleRateDiff\r\n    )"
      VariableDeclaration "_whiteList"
         Type: contract WhiteList
         Source: "WhiteList _whiteList"
        UserDefinedTypeName "WhiteList"
           Source: "WhiteList"
      VariableDeclaration "_expectedRate"
         Type: contract ExpectedRateInterface
         Source: "ExpectedRateInterface _expectedRate"
        UserDefinedTypeName "ExpectedRateInterface"
           Source: "ExpectedRateInterface"
      VariableDeclaration "_feeBurner"
         Type: contract FeeBurnerInterface
         Source: "FeeBurnerInterface    _feeBurner"
        UserDefinedTypeName "FeeBurnerInterface"
           Source: "FeeBurnerInterface"
      VariableDeclaration "_maxGasPrice"
         Type: uint256
         Source: "uint                  _maxGasPrice"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_negligibleRateDiff"
         Type: uint256
         Source: "uint                  _negligibleRateDiff"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        require(_whiteList != address(0));\r\n        require(_feeBurner != address(0));\r\n        require(_expectedRate != address(0));\r\n        whiteListContract = _whiteList;\r\n        expectedRateContract = _expectedRate;\r\n        feeBurnerContract = _feeBurner;\r\n        maxGasPrice = _maxGasPrice;\r\n        negligibleRateDiff = _negligibleRateDiff;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_whiteList != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_whiteList != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_whiteList != address(0)"
            Identifier _whiteList
               Type: contract WhiteList
               Source: "_whiteList"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_feeBurner != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_feeBurner != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_feeBurner != address(0)"
            Identifier _feeBurner
               Type: contract FeeBurnerInterface
               Source: "_feeBurner"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_expectedRate != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_expectedRate != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_expectedRate != address(0)"
            Identifier _expectedRate
               Type: contract ExpectedRateInterface
               Source: "_expectedRate"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "whiteListContract = _whiteList"
        Assignment using operator =
           Type: contract WhiteList
           Source: "whiteListContract = _whiteList"
          Identifier whiteListContract
             Type: contract WhiteList
             Source: "whiteListContract"
          Identifier _whiteList
             Type: contract WhiteList
             Source: "_whiteList"
      ExpressionStatement
         Gas costs: 0
         Source: "expectedRateContract = _expectedRate"
        Assignment using operator =
           Type: contract ExpectedRateInterface
           Source: "expectedRateContract = _expectedRate"
          Identifier expectedRateContract
             Type: contract ExpectedRateInterface
             Source: "expectedRateContract"
          Identifier _expectedRate
             Type: contract ExpectedRateInterface
             Source: "_expectedRate"
      ExpressionStatement
         Gas costs: 0
         Source: "feeBurnerContract = _feeBurner"
        Assignment using operator =
           Type: contract FeeBurnerInterface
           Source: "feeBurnerContract = _feeBurner"
          Identifier feeBurnerContract
             Type: contract FeeBurnerInterface
             Source: "feeBurnerContract"
          Identifier _feeBurner
             Type: contract FeeBurnerInterface
             Source: "_feeBurner"
      ExpressionStatement
         Gas costs: 0
         Source: "maxGasPrice = _maxGasPrice"
        Assignment using operator =
           Type: uint256
           Source: "maxGasPrice = _maxGasPrice"
          Identifier maxGasPrice
             Type: uint256
             Source: "maxGasPrice"
          Identifier _maxGasPrice
             Type: uint256
             Source: "_maxGasPrice"
      ExpressionStatement
         Gas costs: 0
         Source: "negligibleRateDiff = _negligibleRateDiff"
        Assignment using operator =
           Type: uint256
           Source: "negligibleRateDiff = _negligibleRateDiff"
          Identifier negligibleRateDiff
             Type: uint256
             Source: "negligibleRateDiff"
          Identifier _negligibleRateDiff
             Type: uint256
             Source: "_negligibleRateDiff"
  FunctionDefinition "setEnable" - public
     Source: "function setEnable(bool _enable) public onlyAdmin {\r\n        if (_enable) {\r\n            require(whiteListContract != address(0));\r\n            require(feeBurnerContract != address(0));\r\n            require(expectedRateContract != address(0));\r\n        }\r\n        enabled = _enable;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bool _enable)"
      VariableDeclaration "_enable"
         Type: bool
         Source: "bool _enable"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        if (_enable) {\r\n            require(whiteListContract != address(0));\r\n            require(feeBurnerContract != address(0));\r\n            require(expectedRateContract != address(0));\r\n        }\r\n        enabled = _enable;\r\n    }"
      IfStatement
         Source: "if (_enable) {\r\n            require(whiteListContract != address(0));\r\n            require(feeBurnerContract != address(0));\r\n            require(expectedRateContract != address(0));\r\n        }"
        Identifier _enable
           Type: bool
           Gas costs: 0
           Source: "_enable"
        Block
           Source: "{\r\n            require(whiteListContract != address(0));\r\n            require(feeBurnerContract != address(0));\r\n            require(expectedRateContract != address(0));\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require(whiteListContract != address(0))"
            FunctionCall
               Type: tuple()
               Source: "require(whiteListContract != address(0))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "whiteListContract != address(0)"
                Identifier whiteListContract
                   Type: contract WhiteList
                   Source: "whiteListContract"
                FunctionCall
                   Type: address
                   Source: "address(0)"
                  ElementaryTypeNameExpression address
                     Type: type(address)
                     Source: "address"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
          ExpressionStatement
             Gas costs: 0
             Source: "require(feeBurnerContract != address(0))"
            FunctionCall
               Type: tuple()
               Source: "require(feeBurnerContract != address(0))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "feeBurnerContract != address(0)"
                Identifier feeBurnerContract
                   Type: contract FeeBurnerInterface
                   Source: "feeBurnerContract"
                FunctionCall
                   Type: address
                   Source: "address(0)"
                  ElementaryTypeNameExpression address
                     Type: type(address)
                     Source: "address"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
          ExpressionStatement
             Gas costs: 0
             Source: "require(expectedRateContract != address(0))"
            FunctionCall
               Type: tuple()
               Source: "require(expectedRateContract != address(0))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "expectedRateContract != address(0)"
                Identifier expectedRateContract
                   Type: contract ExpectedRateInterface
                   Source: "expectedRateContract"
                FunctionCall
                   Type: address
                   Source: "address(0)"
                  ElementaryTypeNameExpression address
                     Type: type(address)
                     Source: "address"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "enabled = _enable"
        Assignment using operator =
           Type: bool
           Source: "enabled = _enable"
          Identifier enabled
             Type: bool
             Source: "enabled"
          Identifier _enable
             Type: bool
             Source: "_enable"
  FunctionDefinition "getNumReserves" - public - const
     Source: "function getNumReserves() public view returns(uint) {\r\n        return reserves.length;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return reserves.length;\r\n    }"
      Return
         Gas costs: 0
         Source: "return reserves.length"
        MemberAccess to member length
           Type: uint256
           Source: "reserves.length"
          Identifier reserves
             Type: contract KyberReserve[] storage ref
             Source: "reserves"
  FunctionDefinition "getReserves" - public - const
     Source: "function getReserves() public view returns(KyberReserve[]) {\r\n        return reserves;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(KyberReserve[])"
      VariableDeclaration ""
         Type: contract KyberReserve[] memory
         Source: "KyberReserve[]"
        ArrayTypeName
           Source: "KyberReserve[]"
          UserDefinedTypeName "KyberReserve"
             Source: "KyberReserve"
    Block
       Source: "{\r\n        return reserves;\r\n    }"
      Return
         Gas costs: 0
         Source: "return reserves"
        Identifier reserves
           Type: contract KyberReserve[] storage ref
           Source: "reserves"
  FunctionDefinition "getBalance" - public - const
     Source: "function getBalance(ERC20 token, address user) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return user.balance;\r\n        else\r\n            return token.balanceOf(user);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token, address user)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "user"
         Type: address
         Source: "address user"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return user.balance;\r\n        else\r\n            return token.balanceOf(user);\r\n    }"
      IfStatement
         Source: "if (token == ETH_TOKEN_ADDRESS)\r\n            return user.balance;\r\n        else\r\n            return token.balanceOf(user)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "token == ETH_TOKEN_ADDRESS"
          Identifier token
             Type: contract ERC20
             Source: "token"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        Return
           Gas costs: 0
           Source: "return user.balance"
          MemberAccess to member balance
             Type: uint256
             Source: "user.balance"
            Identifier user
               Type: address
               Source: "user"
        Return
           Gas costs: 0
           Source: "return token.balanceOf(user)"
          FunctionCall
             Type: uint256
             Source: "token.balanceOf(user)"
            MemberAccess to member balanceOf
               Type: function (address) view external returns (uint256)
               Source: "token.balanceOf"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
            Identifier user
               Type: address
               Source: "user"
  FunctionDefinition "findBestRate" - public - const
     Source: "function findBestRate(ERC20 src, ERC20 dest, uint srcQty) public view returns(uint, uint) {\r\n        uint bestRate = 0;\r\n        uint bestReserve = 0;\r\n        uint numRelevantReserves = 0;\r\n        uint numReserves = reserves.length;\r\n        uint[] memory rates = new uint[](numReserves);\r\n        uint[] memory reserveCandidates = new uint[](numReserves);\r\n\r\n        for (uint i = 0; i < numReserves; i++) {\r\n            //list all reserves that have this token.\r\n            if (!(perReserveListedPairs[reserves[i]])[keccak256(src, dest)]) continue;\r\n\r\n            rates[i] = reserves[i].getConversionRate(src, dest, srcQty, block.number);\r\n\r\n            if (rates[i] > bestRate) {\r\n                //best rate is highest rate\r\n                bestRate = rates[i];\r\n            }\r\n        }\r\n\r\n        if (bestRate > 0) {\r\n            uint random = 0;\r\n            uint smallestRelevantRate = (bestRate * 10000) / (10000 + negligibleRateDiff);\r\n\r\n            for (i = 0; i < numReserves; i++) {\r\n                if (rates[i] >= smallestRelevantRate) {\r\n                    reserveCandidates[numRelevantReserves++] = i;\r\n                }\r\n            }\r\n\r\n            if (numRelevantReserves > 1) {\r\n                //when encountering small rate diff from bestRate. draw from relevant reserves\r\n                random = uint(block.blockhash(block.number-1)) % numRelevantReserves;\r\n            }\r\n\r\n            bestReserve = reserveCandidates[random];\r\n            bestRate = rates[bestReserve];\r\n        }\r\n\r\n        return (bestReserve, bestRate);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 src, ERC20 dest, uint srcQty)"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "srcQty"
         Type: uint256
         Source: "uint srcQty"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint, uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint bestRate = 0;\r\n        uint bestReserve = 0;\r\n        uint numRelevantReserves = 0;\r\n        uint numReserves = reserves.length;\r\n        uint[] memory rates = new uint[](numReserves);\r\n        uint[] memory reserveCandidates = new uint[](numReserves);\r\n\r\n        for (uint i = 0; i < numReserves; i++) {\r\n            //list all reserves that have this token.\r\n            if (!(perReserveListedPairs[reserves[i]])[keccak256(src, dest)]) continue;\r\n\r\n            rates[i] = reserves[i].getConversionRate(src, dest, srcQty, block.number);\r\n\r\n            if (rates[i] > bestRate) {\r\n                //best rate is highest rate\r\n                bestRate = rates[i];\r\n            }\r\n        }\r\n\r\n        if (bestRate > 0) {\r\n            uint random = 0;\r\n            uint smallestRelevantRate = (bestRate * 10000) / (10000 + negligibleRateDiff);\r\n\r\n            for (i = 0; i < numReserves; i++) {\r\n                if (rates[i] >= smallestRelevantRate) {\r\n                    reserveCandidates[numRelevantReserves++] = i;\r\n                }\r\n            }\r\n\r\n            if (numRelevantReserves > 1) {\r\n                //when encountering small rate diff from bestRate. draw from relevant reserves\r\n                random = uint(block.blockhash(block.number-1)) % numRelevantReserves;\r\n            }\r\n\r\n            bestReserve = reserveCandidates[random];\r\n            bestRate = rates[bestReserve];\r\n        }\r\n\r\n        return (bestReserve, bestRate);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint bestRate = 0"
        VariableDeclaration "bestRate"
           Type: uint256
           Source: "uint bestRate"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint bestReserve = 0"
        VariableDeclaration "bestReserve"
           Type: uint256
           Source: "uint bestReserve"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint numRelevantReserves = 0"
        VariableDeclaration "numRelevantReserves"
           Type: uint256
           Source: "uint numRelevantReserves"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint numReserves = reserves.length"
        VariableDeclaration "numReserves"
           Type: uint256
           Source: "uint numReserves"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "reserves.length"
          Identifier reserves
             Type: contract KyberReserve[] storage ref
             Source: "reserves"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint[] memory rates = new uint[](numReserves)"
        VariableDeclaration "rates"
           Type: uint256[] memory
           Source: "uint[] memory rates"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](numReserves)"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          Identifier numReserves
             Type: uint256
             Source: "numReserves"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint[] memory reserveCandidates = new uint[](numReserves)"
        VariableDeclaration "reserveCandidates"
           Type: uint256[] memory
           Source: "uint[] memory reserveCandidates"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](numReserves)"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          Identifier numReserves
             Type: uint256
             Source: "numReserves"
      ForStatement
         Source: "for (uint i = 0; i < numReserves; i++) {\r\n            //list all reserves that have this token.\r\n            if (!(perReserveListedPairs[reserves[i]])[keccak256(src, dest)]) continue;\r\n\r\n            rates[i] = reserves[i].getConversionRate(src, dest, srcQty, block.number);\r\n\r\n            if (rates[i] > bestRate) {\r\n                //best rate is highest rate\r\n                bestRate = rates[i];\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < numReserves"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier numReserves
             Type: uint256
             Source: "numReserves"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            //list all reserves that have this token.\r\n            if (!(perReserveListedPairs[reserves[i]])[keccak256(src, dest)]) continue;\r\n\r\n            rates[i] = reserves[i].getConversionRate(src, dest, srcQty, block.number);\r\n\r\n            if (rates[i] > bestRate) {\r\n                //best rate is highest rate\r\n                bestRate = rates[i];\r\n            }\r\n        }"
          IfStatement
             Source: "if (!(perReserveListedPairs[reserves[i]])[keccak256(src, dest)]) continue"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: 0
               Source: "!(perReserveListedPairs[reserves[i]])[keccak256(src, dest)]"
              IndexAccess
                 Type: bool
                 Source: "(perReserveListedPairs[reserves[i]])[keccak256(src, dest)]"
                TupleExpression
                   Type: mapping(bytes32 => bool)
                   Source: "(perReserveListedPairs[reserves[i]])"
                  IndexAccess
                     Type: mapping(bytes32 => bool)
                     Source: "perReserveListedPairs[reserves[i]]"
                    Identifier perReserveListedPairs
                       Type: mapping(address => mapping(bytes32 => bool))
                       Source: "perReserveListedPairs"
                    IndexAccess
                       Type: contract KyberReserve
                       Source: "reserves[i]"
                      Identifier reserves
                         Type: contract KyberReserve[] storage ref
                         Source: "reserves"
                      Identifier i
                         Type: uint256
                         Source: "i"
                FunctionCall
                   Type: bytes32
                   Source: "keccak256(src, dest)"
                  Identifier keccak256
                     Type: function () pure returns (bytes32)
                     Source: "keccak256"
                  Identifier src
                     Type: contract ERC20
                     Source: "src"
                  Identifier dest
                     Type: contract ERC20
                     Source: "dest"
            Continue
               Gas costs: 0
               Source: "continue"
          ExpressionStatement
             Gas costs: 0
             Source: "rates[i] = reserves[i].getConversionRate(src, dest, srcQty, block.number)"
            Assignment using operator =
               Type: uint256
               Source: "rates[i] = reserves[i].getConversionRate(src, dest, srcQty, block.number)"
              IndexAccess
                 Type: uint256
                 Source: "rates[i]"
                Identifier rates
                   Type: uint256[] memory
                   Source: "rates"
                Identifier i
                   Type: uint256
                   Source: "i"
              FunctionCall
                 Type: uint256
                 Source: "reserves[i].getConversionRate(src, dest, srcQty, block.number)"
                MemberAccess to member getConversionRate
                   Type: function (contract ERC20,contract ERC20,uint256,uint256) view external returns (uint256)
                   Source: "reserves[i].getConversionRate"
                  IndexAccess
                     Type: contract KyberReserve
                     Source: "reserves[i]"
                    Identifier reserves
                       Type: contract KyberReserve[] storage ref
                       Source: "reserves"
                    Identifier i
                       Type: uint256
                       Source: "i"
                Identifier src
                   Type: contract ERC20
                   Source: "src"
                Identifier dest
                   Type: contract ERC20
                   Source: "dest"
                Identifier srcQty
                   Type: uint256
                   Source: "srcQty"
                MemberAccess to member number
                   Type: uint256
                   Source: "block.number"
                  Identifier block
                     Type: block
                     Source: "block"
          IfStatement
             Source: "if (rates[i] > bestRate) {\r\n                //best rate is highest rate\r\n                bestRate = rates[i];\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 0
               Source: "rates[i] > bestRate"
              IndexAccess
                 Type: uint256
                 Source: "rates[i]"
                Identifier rates
                   Type: uint256[] memory
                   Source: "rates"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier bestRate
                 Type: uint256
                 Source: "bestRate"
            Block
               Source: "{\r\n                //best rate is highest rate\r\n                bestRate = rates[i];\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "bestRate = rates[i]"
                Assignment using operator =
                   Type: uint256
                   Source: "bestRate = rates[i]"
                  Identifier bestRate
                     Type: uint256
                     Source: "bestRate"
                  IndexAccess
                     Type: uint256
                     Source: "rates[i]"
                    Identifier rates
                       Type: uint256[] memory
                       Source: "rates"
                    Identifier i
                       Type: uint256
                       Source: "i"
      IfStatement
         Source: "if (bestRate > 0) {\r\n            uint random = 0;\r\n            uint smallestRelevantRate = (bestRate * 10000) / (10000 + negligibleRateDiff);\r\n\r\n            for (i = 0; i < numReserves; i++) {\r\n                if (rates[i] >= smallestRelevantRate) {\r\n                    reserveCandidates[numRelevantReserves++] = i;\r\n                }\r\n            }\r\n\r\n            if (numRelevantReserves > 1) {\r\n                //when encountering small rate diff from bestRate. draw from relevant reserves\r\n                random = uint(block.blockhash(block.number-1)) % numRelevantReserves;\r\n            }\r\n\r\n            bestReserve = reserveCandidates[random];\r\n            bestRate = rates[bestReserve];\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "bestRate > 0"
          Identifier bestRate
             Type: uint256
             Source: "bestRate"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            uint random = 0;\r\n            uint smallestRelevantRate = (bestRate * 10000) / (10000 + negligibleRateDiff);\r\n\r\n            for (i = 0; i < numReserves; i++) {\r\n                if (rates[i] >= smallestRelevantRate) {\r\n                    reserveCandidates[numRelevantReserves++] = i;\r\n                }\r\n            }\r\n\r\n            if (numRelevantReserves > 1) {\r\n                //when encountering small rate diff from bestRate. draw from relevant reserves\r\n                random = uint(block.blockhash(block.number-1)) % numRelevantReserves;\r\n            }\r\n\r\n            bestReserve = reserveCandidates[random];\r\n            bestRate = rates[bestReserve];\r\n        }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "uint random = 0"
            VariableDeclaration "random"
               Type: uint256
               Source: "uint random"
              ElementaryTypeName uint
                 Source: "uint"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "uint smallestRelevantRate = (bestRate * 10000) / (10000 + negligibleRateDiff)"
            VariableDeclaration "smallestRelevantRate"
               Type: uint256
               Source: "uint smallestRelevantRate"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator /
               Type: uint256
               Source: "(bestRate * 10000) / (10000 + negligibleRateDiff)"
              TupleExpression
                 Type: uint256
                 Source: "(bestRate * 10000)"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "bestRate * 10000"
                  Identifier bestRate
                     Type: uint256
                     Source: "bestRate"
                  Literal, token: [no token] value: 10000
                     Type: int_const 10000
                     Source: "10000"
              TupleExpression
                 Type: uint256
                 Source: "(10000 + negligibleRateDiff)"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "10000 + negligibleRateDiff"
                  Literal, token: [no token] value: 10000
                     Type: int_const 10000
                     Source: "10000"
                  Identifier negligibleRateDiff
                     Type: uint256
                     Source: "negligibleRateDiff"
          ForStatement
             Source: "for (i = 0; i < numReserves; i++) {\r\n                if (rates[i] >= smallestRelevantRate) {\r\n                    reserveCandidates[numRelevantReserves++] = i;\r\n                }\r\n            }"
            ExpressionStatement
               Gas costs: 0
               Source: "i = 0"
              Assignment using operator =
                 Type: uint256
                 Source: "i = 0"
                Identifier i
                   Type: uint256
                   Source: "i"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 0
               Source: "i < numReserves"
              Identifier i
                 Type: uint256
                 Source: "i"
              Identifier numReserves
                 Type: uint256
                 Source: "numReserves"
            ExpressionStatement
               Gas costs: 0
               Source: "i++"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "i++"
                Identifier i
                   Type: uint256
                   Source: "i"
            Block
               Source: "{\r\n                if (rates[i] >= smallestRelevantRate) {\r\n                    reserveCandidates[numRelevantReserves++] = i;\r\n                }\r\n            }"
              IfStatement
                 Source: "if (rates[i] >= smallestRelevantRate) {\r\n                    reserveCandidates[numRelevantReserves++] = i;\r\n                }"
                BinaryOperation using operator >=
                   Type: bool
                   Gas costs: 0
                   Source: "rates[i] >= smallestRelevantRate"
                  IndexAccess
                     Type: uint256
                     Source: "rates[i]"
                    Identifier rates
                       Type: uint256[] memory
                       Source: "rates"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  Identifier smallestRelevantRate
                     Type: uint256
                     Source: "smallestRelevantRate"
                Block
                   Source: "{\r\n                    reserveCandidates[numRelevantReserves++] = i;\r\n                }"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "reserveCandidates[numRelevantReserves++] = i"
                    Assignment using operator =
                       Type: uint256
                       Source: "reserveCandidates[numRelevantReserves++] = i"
                      IndexAccess
                         Type: uint256
                         Source: "reserveCandidates[numRelevantReserves++]"
                        Identifier reserveCandidates
                           Type: uint256[] memory
                           Source: "reserveCandidates"
                        UnaryOperation (postfix) ++
                           Type: uint256
                           Source: "numRelevantReserves++"
                          Identifier numRelevantReserves
                             Type: uint256
                             Source: "numRelevantReserves"
                      Identifier i
                         Type: uint256
                         Source: "i"
          IfStatement
             Source: "if (numRelevantReserves > 1) {\r\n                //when encountering small rate diff from bestRate. draw from relevant reserves\r\n                random = uint(block.blockhash(block.number-1)) % numRelevantReserves;\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 0
               Source: "numRelevantReserves > 1"
              Identifier numRelevantReserves
                 Type: uint256
                 Source: "numRelevantReserves"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            Block
               Source: "{\r\n                //when encountering small rate diff from bestRate. draw from relevant reserves\r\n                random = uint(block.blockhash(block.number-1)) % numRelevantReserves;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "random = uint(block.blockhash(block.number-1)) % numRelevantReserves"
                Assignment using operator =
                   Type: uint256
                   Source: "random = uint(block.blockhash(block.number-1)) % numRelevantReserves"
                  Identifier random
                     Type: uint256
                     Source: "random"
                  BinaryOperation using operator %
                     Type: uint256
                     Source: "uint(block.blockhash(block.number-1)) % numRelevantReserves"
                    FunctionCall
                       Type: uint256
                       Source: "uint(block.blockhash(block.number-1))"
                      ElementaryTypeNameExpression uint
                         Type: type(uint256)
                         Source: "uint"
                      FunctionCall
                         Type: bytes32
                         Source: "block.blockhash(block.number-1)"
                        MemberAccess to member blockhash
                           Type: function (uint256) view returns (bytes32)
                           Source: "block.blockhash"
                          Identifier block
                             Type: block
                             Source: "block"
                        BinaryOperation using operator -
                           Type: uint256
                           Source: "block.number-1"
                          MemberAccess to member number
                             Type: uint256
                             Source: "block.number"
                            Identifier block
                               Type: block
                               Source: "block"
                          Literal, token: [no token] value: 1
                             Type: int_const 1
                             Source: "1"
                    Identifier numRelevantReserves
                       Type: uint256
                       Source: "numRelevantReserves"
          ExpressionStatement
             Gas costs: 0
             Source: "bestReserve = reserveCandidates[random]"
            Assignment using operator =
               Type: uint256
               Source: "bestReserve = reserveCandidates[random]"
              Identifier bestReserve
                 Type: uint256
                 Source: "bestReserve"
              IndexAccess
                 Type: uint256
                 Source: "reserveCandidates[random]"
                Identifier reserveCandidates
                   Type: uint256[] memory
                   Source: "reserveCandidates"
                Identifier random
                   Type: uint256
                   Source: "random"
          ExpressionStatement
             Gas costs: 0
             Source: "bestRate = rates[bestReserve]"
            Assignment using operator =
               Type: uint256
               Source: "bestRate = rates[bestReserve]"
              Identifier bestRate
                 Type: uint256
                 Source: "bestRate"
              IndexAccess
                 Type: uint256
                 Source: "rates[bestReserve]"
                Identifier rates
                   Type: uint256[] memory
                   Source: "rates"
                Identifier bestReserve
                   Type: uint256
                   Source: "bestReserve"
      Return
         Gas costs: 0
         Source: "return (bestReserve, bestRate)"
        TupleExpression
           Type: tuple(uint256,uint256)
           Source: "(bestReserve, bestRate)"
          Identifier bestReserve
             Type: uint256
             Source: "bestReserve"
          Identifier bestRate
             Type: uint256
             Source: "bestRate"
  FunctionDefinition "getExpectedRate" - public - const
     Source: "function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\r\n        public view\r\n        returns (uint expectedRate, uint slippageRate)\r\n    {\r\n        require(expectedRateContract != address(0));\r\n        return expectedRateContract.getExpectedRate(src, dest, srcQty);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 src, ERC20 dest, uint srcQty)"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "srcQty"
         Type: uint256
         Source: "uint srcQty"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint expectedRate, uint slippageRate)"
      VariableDeclaration "expectedRate"
         Type: uint256
         Source: "uint expectedRate"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "slippageRate"
         Type: uint256
         Source: "uint slippageRate"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(expectedRateContract != address(0));\r\n        return expectedRateContract.getExpectedRate(src, dest, srcQty);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(expectedRateContract != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(expectedRateContract != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "expectedRateContract != address(0)"
            Identifier expectedRateContract
               Type: contract ExpectedRateInterface
               Source: "expectedRateContract"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      Return
         Gas costs: 0
         Source: "return expectedRateContract.getExpectedRate(src, dest, srcQty)"
        FunctionCall
           Type: tuple(uint256,uint256)
           Source: "expectedRateContract.getExpectedRate(src, dest, srcQty)"
          MemberAccess to member getExpectedRate
             Type: function (contract ERC20,contract ERC20,uint256) view external returns (uint256,uint256)
             Source: "expectedRateContract.getExpectedRate"
            Identifier expectedRateContract
               Type: contract ExpectedRateInterface
               Source: "expectedRateContract"
          Identifier src
             Type: contract ERC20
             Source: "src"
          Identifier dest
             Type: contract ERC20
             Source: "dest"
          Identifier srcQty
             Type: uint256
             Source: "srcQty"
  FunctionDefinition "getUserCapInWei" - public - const
     Source: "function getUserCapInWei(address user) public view returns(uint) {\r\n        return whiteListContract.getUserCapInWei(user);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address user)"
      VariableDeclaration "user"
         Type: address
         Source: "address user"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return whiteListContract.getUserCapInWei(user);\r\n    }"
      Return
         Gas costs: 0
         Source: "return whiteListContract.getUserCapInWei(user)"
        FunctionCall
           Type: uint256
           Source: "whiteListContract.getUserCapInWei(user)"
          MemberAccess to member getUserCapInWei
             Type: function (address) view external returns (uint256)
             Source: "whiteListContract.getUserCapInWei"
            Identifier whiteListContract
               Type: contract WhiteList
               Source: "whiteListContract"
          Identifier user
             Type: address
             Source: "user"
  FunctionDefinition "doTrade"
     Source: "function doTrade(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )\r\n        internal\r\n        returns(uint)\r\n    {\r\n        require(tx.gasprice <= maxGasPrice);\r\n        require(validateTradeInput(src, srcAmount, destAddress));\r\n\r\n        uint reserveInd;\r\n        uint rate;\r\n\r\n        (reserveInd, rate) = findBestRate(src, dest, srcAmount);\r\n        KyberReserve theReserve = reserves[reserveInd];\r\n        require(rate > 0);\r\n        require(rate < MAX_RATE);\r\n        require(rate >= minConversionRate);\r\n\r\n        uint actualSrcAmount = srcAmount;\r\n        uint actualDestAmount = calcDestAmount(src, dest, actualSrcAmount, rate);\r\n        if (actualDestAmount > maxDestAmount) {\r\n            actualDestAmount = maxDestAmount;\r\n            actualSrcAmount = calcSrcAmount(src, dest, actualDestAmount, rate);\r\n            require(actualSrcAmount <= srcAmount);\r\n        }\r\n\r\n        // do the trade\r\n        // verify trade size is smaller than user cap\r\n        uint ethAmount;\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            ethAmount = actualSrcAmount;\r\n        } else {\r\n            ethAmount = actualDestAmount;\r\n        }\r\n\r\n        require(ethAmount <= getUserCapInWei(msg.sender));\r\n        require(doReserveTrade(\r\n                src,\r\n                actualSrcAmount,\r\n                dest,\r\n                destAddress,\r\n                actualDestAmount,\r\n                theReserve,\r\n                rate,\r\n                true));\r\n\r\n        if ((actualSrcAmount < srcAmount) && (src == ETH_TOKEN_ADDRESS)) {\r\n            msg.sender.transfer(srcAmount - actualSrcAmount);\r\n        }\r\n\r\n        require(feeBurnerContract.handleFees(ethAmount, theReserve, walletId));\r\n\r\n        ExecuteTrade(msg.sender, src, dest, actualSrcAmount, actualDestAmount);\r\n        return actualDestAmount;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "srcAmount"
         Type: uint256
         Source: "uint srcAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "destAddress"
         Type: address
         Source: "address destAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "maxDestAmount"
         Type: uint256
         Source: "uint maxDestAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "minConversionRate"
         Type: uint256
         Source: "uint minConversionRate"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "walletId"
         Type: address
         Source: "address walletId"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(tx.gasprice <= maxGasPrice);\r\n        require(validateTradeInput(src, srcAmount, destAddress));\r\n\r\n        uint reserveInd;\r\n        uint rate;\r\n\r\n        (reserveInd, rate) = findBestRate(src, dest, srcAmount);\r\n        KyberReserve theReserve = reserves[reserveInd];\r\n        require(rate > 0);\r\n        require(rate < MAX_RATE);\r\n        require(rate >= minConversionRate);\r\n\r\n        uint actualSrcAmount = srcAmount;\r\n        uint actualDestAmount = calcDestAmount(src, dest, actualSrcAmount, rate);\r\n        if (actualDestAmount > maxDestAmount) {\r\n            actualDestAmount = maxDestAmount;\r\n            actualSrcAmount = calcSrcAmount(src, dest, actualDestAmount, rate);\r\n            require(actualSrcAmount <= srcAmount);\r\n        }\r\n\r\n        // do the trade\r\n        // verify trade size is smaller than user cap\r\n        uint ethAmount;\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            ethAmount = actualSrcAmount;\r\n        } else {\r\n            ethAmount = actualDestAmount;\r\n        }\r\n\r\n        require(ethAmount <= getUserCapInWei(msg.sender));\r\n        require(doReserveTrade(\r\n                src,\r\n                actualSrcAmount,\r\n                dest,\r\n                destAddress,\r\n                actualDestAmount,\r\n                theReserve,\r\n                rate,\r\n                true));\r\n\r\n        if ((actualSrcAmount < srcAmount) && (src == ETH_TOKEN_ADDRESS)) {\r\n            msg.sender.transfer(srcAmount - actualSrcAmount);\r\n        }\r\n\r\n        require(feeBurnerContract.handleFees(ethAmount, theReserve, walletId));\r\n\r\n        ExecuteTrade(msg.sender, src, dest, actualSrcAmount, actualDestAmount);\r\n        return actualDestAmount;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(tx.gasprice <= maxGasPrice)"
        FunctionCall
           Type: tuple()
           Source: "require(tx.gasprice <= maxGasPrice)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "tx.gasprice <= maxGasPrice"
            MemberAccess to member gasprice
               Type: uint256
               Source: "tx.gasprice"
              Identifier tx
                 Type: tx
                 Source: "tx"
            Identifier maxGasPrice
               Type: uint256
               Source: "maxGasPrice"
      ExpressionStatement
         Gas costs: 0
         Source: "require(validateTradeInput(src, srcAmount, destAddress))"
        FunctionCall
           Type: tuple()
           Source: "require(validateTradeInput(src, srcAmount, destAddress))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "validateTradeInput(src, srcAmount, destAddress)"
            Identifier validateTradeInput
               Type: function (contract ERC20,uint256,address) view returns (bool)
               Source: "validateTradeInput"
            Identifier src
               Type: contract ERC20
               Source: "src"
            Identifier srcAmount
               Type: uint256
               Source: "srcAmount"
            Identifier destAddress
               Type: address
               Source: "destAddress"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint reserveInd"
        VariableDeclaration "reserveInd"
           Type: uint256
           Source: "uint reserveInd"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint rate"
        VariableDeclaration "rate"
           Type: uint256
           Source: "uint rate"
          ElementaryTypeName uint
             Source: "uint"
      ExpressionStatement
         Gas costs: 0
         Source: "(reserveInd, rate) = findBestRate(src, dest, srcAmount)"
        Assignment using operator =
           Type: tuple()
           Source: "(reserveInd, rate) = findBestRate(src, dest, srcAmount)"
          TupleExpression
             Type: tuple(uint256,uint256)
             Source: "(reserveInd, rate)"
            Identifier reserveInd
               Type: uint256
               Source: "reserveInd"
            Identifier rate
               Type: uint256
               Source: "rate"
          FunctionCall
             Type: tuple(uint256,uint256)
             Source: "findBestRate(src, dest, srcAmount)"
            Identifier findBestRate
               Type: function (contract ERC20,contract ERC20,uint256) view returns (uint256,uint256)
               Source: "findBestRate"
            Identifier src
               Type: contract ERC20
               Source: "src"
            Identifier dest
               Type: contract ERC20
               Source: "dest"
            Identifier srcAmount
               Type: uint256
               Source: "srcAmount"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "KyberReserve theReserve = reserves[reserveInd]"
        VariableDeclaration "theReserve"
           Type: contract KyberReserve
           Source: "KyberReserve theReserve"
          UserDefinedTypeName "KyberReserve"
             Source: "KyberReserve"
        IndexAccess
           Type: contract KyberReserve
           Source: "reserves[reserveInd]"
          Identifier reserves
             Type: contract KyberReserve[] storage ref
             Source: "reserves"
          Identifier reserveInd
             Type: uint256
             Source: "reserveInd"
      ExpressionStatement
         Gas costs: 0
         Source: "require(rate > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(rate > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "rate > 0"
            Identifier rate
               Type: uint256
               Source: "rate"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(rate < MAX_RATE)"
        FunctionCall
           Type: tuple()
           Source: "require(rate < MAX_RATE)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "rate < MAX_RATE"
            Identifier rate
               Type: uint256
               Source: "rate"
            Identifier MAX_RATE
               Type: uint256
               Source: "MAX_RATE"
      ExpressionStatement
         Gas costs: 0
         Source: "require(rate >= minConversionRate)"
        FunctionCall
           Type: tuple()
           Source: "require(rate >= minConversionRate)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "rate >= minConversionRate"
            Identifier rate
               Type: uint256
               Source: "rate"
            Identifier minConversionRate
               Type: uint256
               Source: "minConversionRate"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint actualSrcAmount = srcAmount"
        VariableDeclaration "actualSrcAmount"
           Type: uint256
           Source: "uint actualSrcAmount"
          ElementaryTypeName uint
             Source: "uint"
        Identifier srcAmount
           Type: uint256
           Source: "srcAmount"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint actualDestAmount = calcDestAmount(src, dest, actualSrcAmount, rate)"
        VariableDeclaration "actualDestAmount"
           Type: uint256
           Source: "uint actualDestAmount"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "calcDestAmount(src, dest, actualSrcAmount, rate)"
          Identifier calcDestAmount
             Type: function (contract ERC20,contract ERC20,uint256,uint256) view returns (uint256)
             Source: "calcDestAmount"
          Identifier src
             Type: contract ERC20
             Source: "src"
          Identifier dest
             Type: contract ERC20
             Source: "dest"
          Identifier actualSrcAmount
             Type: uint256
             Source: "actualSrcAmount"
          Identifier rate
             Type: uint256
             Source: "rate"
      IfStatement
         Source: "if (actualDestAmount > maxDestAmount) {\r\n            actualDestAmount = maxDestAmount;\r\n            actualSrcAmount = calcSrcAmount(src, dest, actualDestAmount, rate);\r\n            require(actualSrcAmount <= srcAmount);\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "actualDestAmount > maxDestAmount"
          Identifier actualDestAmount
             Type: uint256
             Source: "actualDestAmount"
          Identifier maxDestAmount
             Type: uint256
             Source: "maxDestAmount"
        Block
           Source: "{\r\n            actualDestAmount = maxDestAmount;\r\n            actualSrcAmount = calcSrcAmount(src, dest, actualDestAmount, rate);\r\n            require(actualSrcAmount <= srcAmount);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "actualDestAmount = maxDestAmount"
            Assignment using operator =
               Type: uint256
               Source: "actualDestAmount = maxDestAmount"
              Identifier actualDestAmount
                 Type: uint256
                 Source: "actualDestAmount"
              Identifier maxDestAmount
                 Type: uint256
                 Source: "maxDestAmount"
          ExpressionStatement
             Gas costs: 0
             Source: "actualSrcAmount = calcSrcAmount(src, dest, actualDestAmount, rate)"
            Assignment using operator =
               Type: uint256
               Source: "actualSrcAmount = calcSrcAmount(src, dest, actualDestAmount, rate)"
              Identifier actualSrcAmount
                 Type: uint256
                 Source: "actualSrcAmount"
              FunctionCall
                 Type: uint256
                 Source: "calcSrcAmount(src, dest, actualDestAmount, rate)"
                Identifier calcSrcAmount
                   Type: function (contract ERC20,contract ERC20,uint256,uint256) view returns (uint256)
                   Source: "calcSrcAmount"
                Identifier src
                   Type: contract ERC20
                   Source: "src"
                Identifier dest
                   Type: contract ERC20
                   Source: "dest"
                Identifier actualDestAmount
                   Type: uint256
                   Source: "actualDestAmount"
                Identifier rate
                   Type: uint256
                   Source: "rate"
          ExpressionStatement
             Gas costs: 0
             Source: "require(actualSrcAmount <= srcAmount)"
            FunctionCall
               Type: tuple()
               Source: "require(actualSrcAmount <= srcAmount)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "actualSrcAmount <= srcAmount"
                Identifier actualSrcAmount
                   Type: uint256
                   Source: "actualSrcAmount"
                Identifier srcAmount
                   Type: uint256
                   Source: "srcAmount"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint ethAmount"
        VariableDeclaration "ethAmount"
           Type: uint256
           Source: "uint ethAmount"
          ElementaryTypeName uint
             Source: "uint"
      IfStatement
         Source: "if (src == ETH_TOKEN_ADDRESS) {\r\n            ethAmount = actualSrcAmount;\r\n        } else {\r\n            ethAmount = actualDestAmount;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "src == ETH_TOKEN_ADDRESS"
          Identifier src
             Type: contract ERC20
             Source: "src"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        Block
           Source: "{\r\n            ethAmount = actualSrcAmount;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "ethAmount = actualSrcAmount"
            Assignment using operator =
               Type: uint256
               Source: "ethAmount = actualSrcAmount"
              Identifier ethAmount
                 Type: uint256
                 Source: "ethAmount"
              Identifier actualSrcAmount
                 Type: uint256
                 Source: "actualSrcAmount"
        Block
           Source: "{\r\n            ethAmount = actualDestAmount;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "ethAmount = actualDestAmount"
            Assignment using operator =
               Type: uint256
               Source: "ethAmount = actualDestAmount"
              Identifier ethAmount
                 Type: uint256
                 Source: "ethAmount"
              Identifier actualDestAmount
                 Type: uint256
                 Source: "actualDestAmount"
      ExpressionStatement
         Gas costs: 0
         Source: "require(ethAmount <= getUserCapInWei(msg.sender))"
        FunctionCall
           Type: tuple()
           Source: "require(ethAmount <= getUserCapInWei(msg.sender))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "ethAmount <= getUserCapInWei(msg.sender)"
            Identifier ethAmount
               Type: uint256
               Source: "ethAmount"
            FunctionCall
               Type: uint256
               Source: "getUserCapInWei(msg.sender)"
              Identifier getUserCapInWei
                 Type: function (address) view returns (uint256)
                 Source: "getUserCapInWei"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "require(doReserveTrade(\r\n                src,\r\n                actualSrcAmount,\r\n                dest,\r\n                destAddress,\r\n                actualDestAmount,\r\n                theReserve,\r\n                rate,\r\n                true))"
        FunctionCall
           Type: tuple()
           Source: "require(doReserveTrade(\r\n                src,\r\n                actualSrcAmount,\r\n                dest,\r\n                destAddress,\r\n                actualDestAmount,\r\n                theReserve,\r\n                rate,\r\n                true))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "doReserveTrade(\r\n                src,\r\n                actualSrcAmount,\r\n                dest,\r\n                destAddress,\r\n                actualDestAmount,\r\n                theReserve,\r\n                rate,\r\n                true)"
            Identifier doReserveTrade
               Type: function (contract ERC20,uint256,contract ERC20,address,uint256,contract KyberReserve,uint256,bool) returns (bool)
               Source: "doReserveTrade"
            Identifier src
               Type: contract ERC20
               Source: "src"
            Identifier actualSrcAmount
               Type: uint256
               Source: "actualSrcAmount"
            Identifier dest
               Type: contract ERC20
               Source: "dest"
            Identifier destAddress
               Type: address
               Source: "destAddress"
            Identifier actualDestAmount
               Type: uint256
               Source: "actualDestAmount"
            Identifier theReserve
               Type: contract KyberReserve
               Source: "theReserve"
            Identifier rate
               Type: uint256
               Source: "rate"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      IfStatement
         Source: "if ((actualSrcAmount < srcAmount) && (src == ETH_TOKEN_ADDRESS)) {\r\n            msg.sender.transfer(srcAmount - actualSrcAmount);\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "(actualSrcAmount < srcAmount) && (src == ETH_TOKEN_ADDRESS)"
          TupleExpression
             Type: bool
             Source: "(actualSrcAmount < srcAmount)"
            BinaryOperation using operator <
               Type: bool
               Source: "actualSrcAmount < srcAmount"
              Identifier actualSrcAmount
                 Type: uint256
                 Source: "actualSrcAmount"
              Identifier srcAmount
                 Type: uint256
                 Source: "srcAmount"
          TupleExpression
             Type: bool
             Source: "(src == ETH_TOKEN_ADDRESS)"
            BinaryOperation using operator ==
               Type: bool
               Source: "src == ETH_TOKEN_ADDRESS"
              Identifier src
                 Type: contract ERC20
                 Source: "src"
              Identifier ETH_TOKEN_ADDRESS
                 Type: contract ERC20
                 Source: "ETH_TOKEN_ADDRESS"
        Block
           Source: "{\r\n            msg.sender.transfer(srcAmount - actualSrcAmount);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "msg.sender.transfer(srcAmount - actualSrcAmount)"
            FunctionCall
               Type: tuple()
               Source: "msg.sender.transfer(srcAmount - actualSrcAmount)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "msg.sender.transfer"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "srcAmount - actualSrcAmount"
                Identifier srcAmount
                   Type: uint256
                   Source: "srcAmount"
                Identifier actualSrcAmount
                   Type: uint256
                   Source: "actualSrcAmount"
      ExpressionStatement
         Gas costs: 0
         Source: "require(feeBurnerContract.handleFees(ethAmount, theReserve, walletId))"
        FunctionCall
           Type: tuple()
           Source: "require(feeBurnerContract.handleFees(ethAmount, theReserve, walletId))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "feeBurnerContract.handleFees(ethAmount, theReserve, walletId)"
            MemberAccess to member handleFees
               Type: function (uint256,address,address) external returns (bool)
               Source: "feeBurnerContract.handleFees"
              Identifier feeBurnerContract
                 Type: contract FeeBurnerInterface
                 Source: "feeBurnerContract"
            Identifier ethAmount
               Type: uint256
               Source: "ethAmount"
            Identifier theReserve
               Type: contract KyberReserve
               Source: "theReserve"
            Identifier walletId
               Type: address
               Source: "walletId"
      ExpressionStatement
         Gas costs: 0
         Source: "ExecuteTrade(msg.sender, src, dest, actualSrcAmount, actualDestAmount)"
        FunctionCall
           Type: tuple()
           Source: "ExecuteTrade(msg.sender, src, dest, actualSrcAmount, actualDestAmount)"
          Identifier ExecuteTrade
             Type: function (address,contract ERC20,contract ERC20,uint256,uint256)
             Source: "ExecuteTrade"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier src
             Type: contract ERC20
             Source: "src"
          Identifier dest
             Type: contract ERC20
             Source: "dest"
          Identifier actualSrcAmount
             Type: uint256
             Source: "actualSrcAmount"
          Identifier actualDestAmount
             Type: uint256
             Source: "actualDestAmount"
      Return
         Gas costs: 0
         Source: "return actualDestAmount"
        Identifier actualDestAmount
           Type: uint256
           Source: "actualDestAmount"
  FunctionDefinition "doReserveTrade"
     Source: "function doReserveTrade(\r\n        ERC20 src,\r\n        uint amount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint expectedDestAmount,\r\n        KyberReserve reserve,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint callValue = 0;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            callValue = amount;\r\n        } else {\r\n            // take src tokens to this contract\r\n            src.transferFrom(msg.sender, this, amount);\r\n        }\r\n\r\n        // reserve sends tokens/eth to network. network sends it to destination\r\n        require(reserve.trade.value(callValue)(src, amount, dest, this, conversionRate, validate));\r\n\r\n        if (dest == ETH_TOKEN_ADDRESS) {\r\n            destAddress.transfer(expectedDestAmount);\r\n        } else {\r\n            require(dest.transfer(destAddress, expectedDestAmount));\r\n        }\r\n\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        ERC20 src,\r\n        uint amount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint expectedDestAmount,\r\n        KyberReserve reserve,\r\n        uint conversionRate,\r\n        bool validate\r\n    )"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "destAddress"
         Type: address
         Source: "address destAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "expectedDestAmount"
         Type: uint256
         Source: "uint expectedDestAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "reserve"
         Type: contract KyberReserve
         Source: "KyberReserve reserve"
        UserDefinedTypeName "KyberReserve"
           Source: "KyberReserve"
      VariableDeclaration "conversionRate"
         Type: uint256
         Source: "uint conversionRate"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "validate"
         Type: bool
         Source: "bool validate"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        uint callValue = 0;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            callValue = amount;\r\n        } else {\r\n            // take src tokens to this contract\r\n            src.transferFrom(msg.sender, this, amount);\r\n        }\r\n\r\n        // reserve sends tokens/eth to network. network sends it to destination\r\n        require(reserve.trade.value(callValue)(src, amount, dest, this, conversionRate, validate));\r\n\r\n        if (dest == ETH_TOKEN_ADDRESS) {\r\n            destAddress.transfer(expectedDestAmount);\r\n        } else {\r\n            require(dest.transfer(destAddress, expectedDestAmount));\r\n        }\r\n\r\n        return true;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint callValue = 0"
        VariableDeclaration "callValue"
           Type: uint256
           Source: "uint callValue"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      IfStatement
         Source: "if (src == ETH_TOKEN_ADDRESS) {\r\n            callValue = amount;\r\n        } else {\r\n            // take src tokens to this contract\r\n            src.transferFrom(msg.sender, this, amount);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "src == ETH_TOKEN_ADDRESS"
          Identifier src
             Type: contract ERC20
             Source: "src"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        Block
           Source: "{\r\n            callValue = amount;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "callValue = amount"
            Assignment using operator =
               Type: uint256
               Source: "callValue = amount"
              Identifier callValue
                 Type: uint256
                 Source: "callValue"
              Identifier amount
                 Type: uint256
                 Source: "amount"
        Block
           Source: "{\r\n            // take src tokens to this contract\r\n            src.transferFrom(msg.sender, this, amount);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "src.transferFrom(msg.sender, this, amount)"
            FunctionCall
               Type: bool
               Source: "src.transferFrom(msg.sender, this, amount)"
              MemberAccess to member transferFrom
                 Type: function (address,address,uint256) external returns (bool)
                 Source: "src.transferFrom"
                Identifier src
                   Type: contract ERC20
                   Source: "src"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier this
                 Type: contract KyberNetwork
                 Source: "this"
              Identifier amount
                 Type: uint256
                 Source: "amount"
      ExpressionStatement
         Gas costs: 0
         Source: "require(reserve.trade.value(callValue)(src, amount, dest, this, conversionRate, validate))"
        FunctionCall
           Type: tuple()
           Source: "require(reserve.trade.value(callValue)(src, amount, dest, this, conversionRate, validate))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "reserve.trade.value(callValue)(src, amount, dest, this, conversionRate, validate)"
            FunctionCall
               Type: function (contract ERC20,uint256,contract ERC20,address,uint256,bool) payable external returns (bool)
               Source: "reserve.trade.value(callValue)"
              MemberAccess to member value
                 Type: function (uint256) returns (function (contract ERC20,uint256,contract ERC20,address,uint256,bool) payable external returns (bool))
                 Source: "reserve.trade.value"
                MemberAccess to member trade
                   Type: function (contract ERC20,uint256,contract ERC20,address,uint256,bool) payable external returns (bool)
                   Source: "reserve.trade"
                  Identifier reserve
                     Type: contract KyberReserve
                     Source: "reserve"
              Identifier callValue
                 Type: uint256
                 Source: "callValue"
            Identifier src
               Type: contract ERC20
               Source: "src"
            Identifier amount
               Type: uint256
               Source: "amount"
            Identifier dest
               Type: contract ERC20
               Source: "dest"
            Identifier this
               Type: contract KyberNetwork
               Source: "this"
            Identifier conversionRate
               Type: uint256
               Source: "conversionRate"
            Identifier validate
               Type: bool
               Source: "validate"
      IfStatement
         Source: "if (dest == ETH_TOKEN_ADDRESS) {\r\n            destAddress.transfer(expectedDestAmount);\r\n        } else {\r\n            require(dest.transfer(destAddress, expectedDestAmount));\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "dest == ETH_TOKEN_ADDRESS"
          Identifier dest
             Type: contract ERC20
             Source: "dest"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        Block
           Source: "{\r\n            destAddress.transfer(expectedDestAmount);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "destAddress.transfer(expectedDestAmount)"
            FunctionCall
               Type: tuple()
               Source: "destAddress.transfer(expectedDestAmount)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "destAddress.transfer"
                Identifier destAddress
                   Type: address
                   Source: "destAddress"
              Identifier expectedDestAmount
                 Type: uint256
                 Source: "expectedDestAmount"
        Block
           Source: "{\r\n            require(dest.transfer(destAddress, expectedDestAmount));\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require(dest.transfer(destAddress, expectedDestAmount))"
            FunctionCall
               Type: tuple()
               Source: "require(dest.transfer(destAddress, expectedDestAmount))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "dest.transfer(destAddress, expectedDestAmount)"
                MemberAccess to member transfer
                   Type: function (address,uint256) external returns (bool)
                   Source: "dest.transfer"
                  Identifier dest
                     Type: contract ERC20
                     Source: "dest"
                Identifier destAddress
                   Type: address
                   Source: "destAddress"
                Identifier expectedDestAmount
                   Type: uint256
                   Source: "expectedDestAmount"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "getDecimals" - const
     Source: "function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return 18;\r\n        return token.decimals();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (token == ETH_TOKEN_ADDRESS) return 18;\r\n        return token.decimals();\r\n    }"
      IfStatement
         Source: "if (token == ETH_TOKEN_ADDRESS) return 18"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "token == ETH_TOKEN_ADDRESS"
          Identifier token
             Type: contract ERC20
             Source: "token"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        Return
           Gas costs: 0
           Source: "return 18"
          Literal, token: [no token] value: 18
             Type: int_const 18
             Source: "18"
      Return
         Gas costs: 0
         Source: "return token.decimals()"
        FunctionCall
           Type: uint256
           Source: "token.decimals()"
          MemberAccess to member decimals
             Type: function () view external returns (uint256)
             Source: "token.decimals"
            Identifier token
               Type: contract ERC20
               Source: "token"
  FunctionDefinition "calcDestAmount" - const
     Source: "function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 src, ERC20 dest, uint srcAmount, uint rate)"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "srcAmount"
         Type: uint256
         Source: "uint srcAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "rate"
         Type: uint256
         Source: "uint rate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }"
      Return
         Gas costs: 0
         Source: "return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate)"
        FunctionCall
           Type: uint256
           Source: "calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate)"
          Identifier calcDstQty
             Type: function (uint256,uint256,uint256,uint256) pure returns (uint256)
             Source: "calcDstQty"
          Identifier srcAmount
             Type: uint256
             Source: "srcAmount"
          FunctionCall
             Type: uint256
             Source: "getDecimals(src)"
            Identifier getDecimals
               Type: function (contract ERC20) view returns (uint256)
               Source: "getDecimals"
            Identifier src
               Type: contract ERC20
               Source: "src"
          FunctionCall
             Type: uint256
             Source: "getDecimals(dest)"
            Identifier getDecimals
               Type: function (contract ERC20) view returns (uint256)
               Source: "getDecimals"
            Identifier dest
               Type: contract ERC20
               Source: "dest"
          Identifier rate
             Type: uint256
             Source: "rate"
  FunctionDefinition "calcSrcAmount" - const
     Source: "function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 src, ERC20 dest, uint destAmount, uint rate)"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "destAmount"
         Type: uint256
         Source: "uint destAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "rate"
         Type: uint256
         Source: "uint rate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }"
      Return
         Gas costs: 0
         Source: "return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate)"
        FunctionCall
           Type: uint256
           Source: "calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate)"
          Identifier calcSrcQty
             Type: function (uint256,uint256,uint256,uint256) pure returns (uint256)
             Source: "calcSrcQty"
          Identifier destAmount
             Type: uint256
             Source: "destAmount"
          FunctionCall
             Type: uint256
             Source: "getDecimals(src)"
            Identifier getDecimals
               Type: function (contract ERC20) view returns (uint256)
               Source: "getDecimals"
            Identifier src
               Type: contract ERC20
               Source: "src"
          FunctionCall
             Type: uint256
             Source: "getDecimals(dest)"
            Identifier getDecimals
               Type: function (contract ERC20) view returns (uint256)
               Source: "getDecimals"
            Identifier dest
               Type: contract ERC20
               Source: "dest"
          Identifier rate
             Type: uint256
             Source: "rate"
  FunctionDefinition "validateTradeInput" - const
     Source: "function validateTradeInput(ERC20 src, uint srcAmount, address destAddress) internal view returns(bool) {\r\n        if ((srcAmount >= MAX_QTY) || (srcAmount == 0) || (destAddress == 0))\r\n            return false;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            if (msg.value != srcAmount)\r\n                return false;\r\n        } else {\r\n            if ((msg.value != 0) || (src.allowance(msg.sender, this) < srcAmount))\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 src, uint srcAmount, address destAddress)"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "srcAmount"
         Type: uint256
         Source: "uint srcAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "destAddress"
         Type: address
         Source: "address destAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if ((srcAmount >= MAX_QTY) || (srcAmount == 0) || (destAddress == 0))\r\n            return false;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            if (msg.value != srcAmount)\r\n                return false;\r\n        } else {\r\n            if ((msg.value != 0) || (src.allowance(msg.sender, this) < srcAmount))\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }"
      IfStatement
         Source: "if ((srcAmount >= MAX_QTY) || (srcAmount == 0) || (destAddress == 0))\r\n            return false"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 0
           Source: "(srcAmount >= MAX_QTY) || (srcAmount == 0) || (destAddress == 0)"
          BinaryOperation using operator ||
             Type: bool
             Source: "(srcAmount >= MAX_QTY) || (srcAmount == 0)"
            TupleExpression
               Type: bool
               Source: "(srcAmount >= MAX_QTY)"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "srcAmount >= MAX_QTY"
                Identifier srcAmount
                   Type: uint256
                   Source: "srcAmount"
                Identifier MAX_QTY
                   Type: uint256
                   Source: "MAX_QTY"
            TupleExpression
               Type: bool
               Source: "(srcAmount == 0)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "srcAmount == 0"
                Identifier srcAmount
                   Type: uint256
                   Source: "srcAmount"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
          TupleExpression
             Type: bool
             Source: "(destAddress == 0)"
            BinaryOperation using operator ==
               Type: bool
               Source: "destAddress == 0"
              Identifier destAddress
                 Type: address
                 Source: "destAddress"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Return
           Gas costs: 0
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      IfStatement
         Source: "if (src == ETH_TOKEN_ADDRESS) {\r\n            if (msg.value != srcAmount)\r\n                return false;\r\n        } else {\r\n            if ((msg.value != 0) || (src.allowance(msg.sender, this) < srcAmount))\r\n                return false;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "src == ETH_TOKEN_ADDRESS"
          Identifier src
             Type: contract ERC20
             Source: "src"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        Block
           Source: "{\r\n            if (msg.value != srcAmount)\r\n                return false;\r\n        }"
          IfStatement
             Source: "if (msg.value != srcAmount)\r\n                return false"
            BinaryOperation using operator !=
               Type: bool
               Gas costs: 0
               Source: "msg.value != srcAmount"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier srcAmount
                 Type: uint256
                 Source: "srcAmount"
            Return
               Gas costs: 0
               Source: "return false"
              Literal, token: false value: false
                 Type: bool
                 Source: "false"
        Block
           Source: "{\r\n            if ((msg.value != 0) || (src.allowance(msg.sender, this) < srcAmount))\r\n                return false;\r\n        }"
          IfStatement
             Source: "if ((msg.value != 0) || (src.allowance(msg.sender, this) < srcAmount))\r\n                return false"
            BinaryOperation using operator ||
               Type: bool
               Gas costs: 0
               Source: "(msg.value != 0) || (src.allowance(msg.sender, this) < srcAmount)"
              TupleExpression
                 Type: bool
                 Source: "(msg.value != 0)"
                BinaryOperation using operator !=
                   Type: bool
                   Source: "msg.value != 0"
                  MemberAccess to member value
                     Type: uint256
                     Source: "msg.value"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              TupleExpression
                 Type: bool
                 Source: "(src.allowance(msg.sender, this) < srcAmount)"
                BinaryOperation using operator <
                   Type: bool
                   Source: "src.allowance(msg.sender, this) < srcAmount"
                  FunctionCall
                     Type: uint256
                     Source: "src.allowance(msg.sender, this)"
                    MemberAccess to member allowance
                       Type: function (address,address) view external returns (uint256)
                       Source: "src.allowance"
                      Identifier src
                         Type: contract ERC20
                         Source: "src"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                    Identifier this
                       Type: contract KyberNetwork
                       Source: "this"
                  Identifier srcAmount
                     Type: uint256
                     Source: "srcAmount"
            Return
               Gas costs: 0
               Source: "return false"
              Literal, token: false value: false
                 Type: bool
                 Source: "false"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
ContractDefinition "KyberReserve"
   Source: "contract KyberReserve is Withdrawable, Utils {\r\n\r\n    address public kyberNetwork;\r\n    bool public tradeEnabled;\r\n    ConversionRates public conversionRatesContract;\r\n    SanityRatesInterface public sanityRatesContract;\r\n    mapping(bytes32=>bool) public approvedWithdrawAddresses; // sha3(token,address)=>bool\r\n\r\n    function KyberReserve(address _kyberNetwork, ConversionRates _ratesContract, address _admin) public {\r\n        require(_admin != address(0));\r\n        require(_ratesContract != address(0));\r\n        require(_kyberNetwork != address(0));\r\n        kyberNetwork = _kyberNetwork;\r\n        conversionRatesContract = _ratesContract;\r\n        admin = _admin;\r\n        tradeEnabled = true;\r\n    }\r\n\r\n    event DepositToken(ERC20 token, uint amount);\r\n\r\n    function() public payable {\r\n        DepositToken(ETH_TOKEN_ADDRESS, msg.value);\r\n    }\r\n\r\n    event TradeExecute(\r\n        address indexed origin,\r\n        address src,\r\n        uint srcAmount,\r\n        address destToken,\r\n        uint destAmount,\r\n        address destAddress\r\n    );\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        public\r\n        payable\r\n        returns(bool)\r\n    {\r\n        require(tradeEnabled);\r\n        require(msg.sender == kyberNetwork);\r\n\r\n        require(doTrade(srcToken, srcAmount, destToken, destAddress, conversionRate, validate));\r\n\r\n        return true;\r\n    }\r\n\r\n    event TradeEnabled(bool enable);\r\n\r\n    function enableTrade() public onlyAdmin returns(bool) {\r\n        tradeEnabled = true;\r\n        TradeEnabled(true);\r\n\r\n        return true;\r\n    }\r\n\r\n    function disableTrade() public onlyAlerter returns(bool) {\r\n        tradeEnabled = false;\r\n        TradeEnabled(false);\r\n\r\n        return true;\r\n    }\r\n\r\n    event WithdrawAddressApproved(ERC20 token, address addr, bool approve);\r\n\r\n    function approveWithdrawAddress(ERC20 token, address addr, bool approve) public onlyAdmin {\r\n        approvedWithdrawAddresses[keccak256(token, addr)] = approve;\r\n        WithdrawAddressApproved(token, addr, approve);\r\n    }\r\n\r\n    event WithdrawFunds(ERC20 token, uint amount, address destination);\r\n\r\n    function withdraw(ERC20 token, uint amount, address destination) public onlyOperator returns(bool) {\r\n        require(approvedWithdrawAddresses[keccak256(token, destination)]);\r\n\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            destination.transfer(amount);\r\n        } else {\r\n            require(token.transfer(destination, amount));\r\n        }\r\n\r\n        WithdrawFunds(token, amount, destination);\r\n\r\n        return true;\r\n    }\r\n\r\n    event SetContractAddresses(address network, address rate, address sanity);\r\n\r\n    function setContracts(address _kyberNetwork, ConversionRates _conversionRates, SanityRatesInterface _sanityRates)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(_kyberNetwork != address(0));\r\n        require(_conversionRates != address(0));\r\n\r\n        kyberNetwork = _kyberNetwork;\r\n        conversionRatesContract = _conversionRates;\r\n        sanityRatesContract = _sanityRates;\r\n\r\n        SetContractAddresses(kyberNetwork, conversionRatesContract, sanityRatesContract);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// status functions ///////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    function getBalance(ERC20 token) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return this.balance;\r\n        else\r\n            return token.balanceOf(this);\r\n    }\r\n\r\n    function getDecimals(ERC20 token) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return 18;\r\n        return token.decimals();\r\n    }\r\n\r\n    function getDestQty(ERC20 src, ERC20 dest, uint srcQty, uint rate) public view returns(uint) {\r\n        uint dstDecimals = getDecimals(dest);\r\n        uint srcDecimals = getDecimals(src);\r\n\r\n        return calcDstQty(srcQty, srcDecimals, dstDecimals, rate);\r\n    }\r\n\r\n    function getSrcQty(ERC20 src, ERC20 dest, uint dstQty, uint rate) public view returns(uint) {\r\n        uint dstDecimals = getDecimals(dest);\r\n        uint srcDecimals = getDecimals(src);\r\n\r\n        return calcSrcQty(dstQty, srcDecimals, dstDecimals, rate);\r\n    }\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint) {\r\n        ERC20 token;\r\n        bool  buy;\r\n\r\n        if (!tradeEnabled) return 0;\r\n\r\n        if (ETH_TOKEN_ADDRESS == src) {\r\n            buy = true;\r\n            token = dest;\r\n        } else if (ETH_TOKEN_ADDRESS == dest) {\r\n            buy = false;\r\n            token = src;\r\n        } else {\r\n            return 0; // pair is not listed\r\n        }\r\n\r\n        uint rate = conversionRatesContract.getRate(token, blockNumber, buy, srcQty);\r\n        uint destQty = getDestQty(src, dest, srcQty, rate);\r\n\r\n        if (getBalance(dest) < destQty) return 0;\r\n\r\n        if (sanityRatesContract != address(0)) {\r\n            uint sanityRate = sanityRatesContract.getSanityRate(src, dest);\r\n            if (rate > sanityRate) return 0;\r\n        }\r\n\r\n        return rate;\r\n    }\r\n\r\n    /// @dev do a trade\r\n    /// @param srcToken Src token\r\n    /// @param srcAmount Amount of src token\r\n    /// @param destToken Destination token\r\n    /// @param destAddress Destination address to send tokens to\r\n    /// @param validate If true, additional validations are applicable\r\n    /// @return true iff trade is successful\r\n    function doTrade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        // can skip validation if done at kyber network level\r\n        if (validate) {\r\n            require(conversionRate > 0);\r\n            if (srcToken == ETH_TOKEN_ADDRESS)\r\n                require(msg.value == srcAmount);\r\n            else\r\n                require(msg.value == 0);\r\n        }\r\n\r\n        uint destAmount = getDestQty(srcToken, destToken, srcAmount, conversionRate);\r\n        // sanity check\r\n        require(destAmount > 0);\r\n\r\n        // add to imbalance\r\n        ERC20 token;\r\n        int buy;\r\n        if (srcToken == ETH_TOKEN_ADDRESS) {\r\n            buy = int(destAmount);\r\n            token = destToken;\r\n        } else {\r\n            buy = -1 * int(srcAmount);\r\n            token = srcToken;\r\n        }\r\n\r\n        conversionRatesContract.recordImbalance(\r\n            token,\r\n            buy,\r\n            0,\r\n            block.number\r\n        );\r\n\r\n        // collect src tokens\r\n        if (srcToken != ETH_TOKEN_ADDRESS) {\r\n            require(srcToken.transferFrom(msg.sender, this, srcAmount));\r\n        }\r\n\r\n        // send dest tokens\r\n        if (destToken == ETH_TOKEN_ADDRESS) {\r\n            destAddress.transfer(destAmount);\r\n        } else {\r\n            require(destToken.transfer(destAddress, destAmount));\r\n        }\r\n\r\n        TradeExecute(msg.sender, srcToken, srcAmount, destToken, destAmount, destAddress);\r\n\r\n        return true;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Withdrawable"
    UserDefinedTypeName "Withdrawable"
       Source: "Withdrawable"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Utils"
    UserDefinedTypeName "Utils"
       Source: "Utils"
  VariableDeclaration "kyberNetwork"
     Type: address
     Gas costs: 0
     Source: "address public kyberNetwork"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "tradeEnabled"
     Type: bool
     Gas costs: 0
     Source: "bool public tradeEnabled"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "conversionRatesContract"
     Type: contract ConversionRates
     Gas costs: 0
     Source: "ConversionRates public conversionRatesContract"
    UserDefinedTypeName "ConversionRates"
       Source: "ConversionRates"
  VariableDeclaration "sanityRatesContract"
     Type: contract SanityRatesInterface
     Gas costs: 0
     Source: "SanityRatesInterface public sanityRatesContract"
    UserDefinedTypeName "SanityRatesInterface"
       Source: "SanityRatesInterface"
  VariableDeclaration "approvedWithdrawAddresses"
     Type: mapping(bytes32 => bool)
     Gas costs: 0
     Source: "mapping(bytes32=>bool) public approvedWithdrawAddresses"
    Mapping
       Source: "mapping(bytes32=>bool)"
      ElementaryTypeName bytes32
         Source: "bytes32"
      ElementaryTypeName bool
         Source: "bool"
  FunctionDefinition "KyberReserve" - public
     Source: "function KyberReserve(address _kyberNetwork, ConversionRates _ratesContract, address _admin) public {\r\n        require(_admin != address(0));\r\n        require(_ratesContract != address(0));\r\n        require(_kyberNetwork != address(0));\r\n        kyberNetwork = _kyberNetwork;\r\n        conversionRatesContract = _ratesContract;\r\n        admin = _admin;\r\n        tradeEnabled = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _kyberNetwork, ConversionRates _ratesContract, address _admin)"
      VariableDeclaration "_kyberNetwork"
         Type: address
         Source: "address _kyberNetwork"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_ratesContract"
         Type: contract ConversionRates
         Source: "ConversionRates _ratesContract"
        UserDefinedTypeName "ConversionRates"
           Source: "ConversionRates"
      VariableDeclaration "_admin"
         Type: address
         Source: "address _admin"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(_admin != address(0));\r\n        require(_ratesContract != address(0));\r\n        require(_kyberNetwork != address(0));\r\n        kyberNetwork = _kyberNetwork;\r\n        conversionRatesContract = _ratesContract;\r\n        admin = _admin;\r\n        tradeEnabled = true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_admin != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_admin != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_admin != address(0)"
            Identifier _admin
               Type: address
               Source: "_admin"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_ratesContract != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_ratesContract != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_ratesContract != address(0)"
            Identifier _ratesContract
               Type: contract ConversionRates
               Source: "_ratesContract"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_kyberNetwork != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_kyberNetwork != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_kyberNetwork != address(0)"
            Identifier _kyberNetwork
               Type: address
               Source: "_kyberNetwork"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "kyberNetwork = _kyberNetwork"
        Assignment using operator =
           Type: address
           Source: "kyberNetwork = _kyberNetwork"
          Identifier kyberNetwork
             Type: address
             Source: "kyberNetwork"
          Identifier _kyberNetwork
             Type: address
             Source: "_kyberNetwork"
      ExpressionStatement
         Gas costs: 0
         Source: "conversionRatesContract = _ratesContract"
        Assignment using operator =
           Type: contract ConversionRates
           Source: "conversionRatesContract = _ratesContract"
          Identifier conversionRatesContract
             Type: contract ConversionRates
             Source: "conversionRatesContract"
          Identifier _ratesContract
             Type: contract ConversionRates
             Source: "_ratesContract"
      ExpressionStatement
         Gas costs: 0
         Source: "admin = _admin"
        Assignment using operator =
           Type: address
           Source: "admin = _admin"
          Identifier admin
             Type: address
             Source: "admin"
          Identifier _admin
             Type: address
             Source: "_admin"
      ExpressionStatement
         Gas costs: 0
         Source: "tradeEnabled = true"
        Assignment using operator =
           Type: bool
           Source: "tradeEnabled = true"
          Identifier tradeEnabled
             Type: bool
             Source: "tradeEnabled"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  EventDefinition "DepositToken"
     Gas costs: 0
     Source: "event DepositToken(ERC20 token, uint amount);"
    ParameterList
       Source: "(ERC20 token, uint amount)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "" - public
     Source: "function() public payable {\r\n        DepositToken(ETH_TOKEN_ADDRESS, msg.value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        DepositToken(ETH_TOKEN_ADDRESS, msg.value);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "DepositToken(ETH_TOKEN_ADDRESS, msg.value)"
        FunctionCall
           Type: tuple()
           Source: "DepositToken(ETH_TOKEN_ADDRESS, msg.value)"
          Identifier DepositToken
             Type: function (contract ERC20,uint256)
             Source: "DepositToken"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
  EventDefinition "TradeExecute"
     Gas costs: 0
     Source: "event TradeExecute(\r\n        address indexed origin,\r\n        address src,\r\n        uint srcAmount,\r\n        address destToken,\r\n        uint destAmount,\r\n        address destAddress\r\n    );"
    ParameterList
       Source: "(\r\n        address indexed origin,\r\n        address src,\r\n        uint srcAmount,\r\n        address destToken,\r\n        uint destAmount,\r\n        address destAddress\r\n    )"
      VariableDeclaration "origin"
         Type: address
         Source: "address indexed origin"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "src"
         Type: address
         Source: "address src"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "srcAmount"
         Type: uint256
         Source: "uint srcAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "destToken"
         Type: address
         Source: "address destToken"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "destAmount"
         Type: uint256
         Source: "uint destAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "destAddress"
         Type: address
         Source: "address destAddress"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "trade" - public
     Source: "function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        public\r\n        payable\r\n        returns(bool)\r\n    {\r\n        require(tradeEnabled);\r\n        require(msg.sender == kyberNetwork);\r\n\r\n        require(doTrade(srcToken, srcAmount, destToken, destAddress, conversionRate, validate));\r\n\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )"
      VariableDeclaration "srcToken"
         Type: contract ERC20
         Source: "ERC20 srcToken"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "srcAmount"
         Type: uint256
         Source: "uint srcAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "destToken"
         Type: contract ERC20
         Source: "ERC20 destToken"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "destAddress"
         Type: address
         Source: "address destAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "conversionRate"
         Type: uint256
         Source: "uint conversionRate"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "validate"
         Type: bool
         Source: "bool validate"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require(tradeEnabled);\r\n        require(msg.sender == kyberNetwork);\r\n\r\n        require(doTrade(srcToken, srcAmount, destToken, destAddress, conversionRate, validate));\r\n\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(tradeEnabled)"
        FunctionCall
           Type: tuple()
           Source: "require(tradeEnabled)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier tradeEnabled
             Type: bool
             Source: "tradeEnabled"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.sender == kyberNetwork)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == kyberNetwork)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == kyberNetwork"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier kyberNetwork
               Type: address
               Source: "kyberNetwork"
      ExpressionStatement
         Gas costs: 0
         Source: "require(doTrade(srcToken, srcAmount, destToken, destAddress, conversionRate, validate))"
        FunctionCall
           Type: tuple()
           Source: "require(doTrade(srcToken, srcAmount, destToken, destAddress, conversionRate, validate))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "doTrade(srcToken, srcAmount, destToken, destAddress, conversionRate, validate)"
            Identifier doTrade
               Type: function (contract ERC20,uint256,contract ERC20,address,uint256,bool) returns (bool)
               Source: "doTrade"
            Identifier srcToken
               Type: contract ERC20
               Source: "srcToken"
            Identifier srcAmount
               Type: uint256
               Source: "srcAmount"
            Identifier destToken
               Type: contract ERC20
               Source: "destToken"
            Identifier destAddress
               Type: address
               Source: "destAddress"
            Identifier conversionRate
               Type: uint256
               Source: "conversionRate"
            Identifier validate
               Type: bool
               Source: "validate"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  EventDefinition "TradeEnabled"
     Gas costs: 0
     Source: "event TradeEnabled(bool enable);"
    ParameterList
       Source: "(bool enable)"
      VariableDeclaration "enable"
         Type: bool
         Source: "bool enable"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "enableTrade" - public
     Source: "function enableTrade() public onlyAdmin returns(bool) {\r\n        tradeEnabled = true;\r\n        TradeEnabled(true);\r\n\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        tradeEnabled = true;\r\n        TradeEnabled(true);\r\n\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "tradeEnabled = true"
        Assignment using operator =
           Type: bool
           Source: "tradeEnabled = true"
          Identifier tradeEnabled
             Type: bool
             Source: "tradeEnabled"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "TradeEnabled(true)"
        FunctionCall
           Type: tuple()
           Source: "TradeEnabled(true)"
          Identifier TradeEnabled
             Type: function (bool)
             Source: "TradeEnabled"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "disableTrade" - public
     Source: "function disableTrade() public onlyAlerter returns(bool) {\r\n        tradeEnabled = false;\r\n        TradeEnabled(false);\r\n\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyAlerter"
       Gas costs: 0
       Source: "onlyAlerter"
      Identifier onlyAlerter
         Type: modifier ()
         Source: "onlyAlerter"
    Block
       Source: "{\r\n        tradeEnabled = false;\r\n        TradeEnabled(false);\r\n\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "tradeEnabled = false"
        Assignment using operator =
           Type: bool
           Source: "tradeEnabled = false"
          Identifier tradeEnabled
             Type: bool
             Source: "tradeEnabled"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 0
         Source: "TradeEnabled(false)"
        FunctionCall
           Type: tuple()
           Source: "TradeEnabled(false)"
          Identifier TradeEnabled
             Type: function (bool)
             Source: "TradeEnabled"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  EventDefinition "WithdrawAddressApproved"
     Gas costs: 0
     Source: "event WithdrawAddressApproved(ERC20 token, address addr, bool approve);"
    ParameterList
       Source: "(ERC20 token, address addr, bool approve)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "addr"
         Type: address
         Source: "address addr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "approve"
         Type: bool
         Source: "bool approve"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approveWithdrawAddress" - public
     Source: "function approveWithdrawAddress(ERC20 token, address addr, bool approve) public onlyAdmin {\r\n        approvedWithdrawAddresses[keccak256(token, addr)] = approve;\r\n        WithdrawAddressApproved(token, addr, approve);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token, address addr, bool approve)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "addr"
         Type: address
         Source: "address addr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "approve"
         Type: bool
         Source: "bool approve"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        approvedWithdrawAddresses[keccak256(token, addr)] = approve;\r\n        WithdrawAddressApproved(token, addr, approve);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "approvedWithdrawAddresses[keccak256(token, addr)] = approve"
        Assignment using operator =
           Type: bool
           Source: "approvedWithdrawAddresses[keccak256(token, addr)] = approve"
          IndexAccess
             Type: bool
             Source: "approvedWithdrawAddresses[keccak256(token, addr)]"
            Identifier approvedWithdrawAddresses
               Type: mapping(bytes32 => bool)
               Source: "approvedWithdrawAddresses"
            FunctionCall
               Type: bytes32
               Source: "keccak256(token, addr)"
              Identifier keccak256
                 Type: function () pure returns (bytes32)
                 Source: "keccak256"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
              Identifier addr
                 Type: address
                 Source: "addr"
          Identifier approve
             Type: bool
             Source: "approve"
      ExpressionStatement
         Gas costs: 0
         Source: "WithdrawAddressApproved(token, addr, approve)"
        FunctionCall
           Type: tuple()
           Source: "WithdrawAddressApproved(token, addr, approve)"
          Identifier WithdrawAddressApproved
             Type: function (contract ERC20,address,bool)
             Source: "WithdrawAddressApproved"
          Identifier token
             Type: contract ERC20
             Source: "token"
          Identifier addr
             Type: address
             Source: "addr"
          Identifier approve
             Type: bool
             Source: "approve"
  EventDefinition "WithdrawFunds"
     Gas costs: 0
     Source: "event WithdrawFunds(ERC20 token, uint amount, address destination);"
    ParameterList
       Source: "(ERC20 token, uint amount, address destination)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "destination"
         Type: address
         Source: "address destination"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "withdraw" - public
     Source: "function withdraw(ERC20 token, uint amount, address destination) public onlyOperator returns(bool) {\r\n        require(approvedWithdrawAddresses[keccak256(token, destination)]);\r\n\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            destination.transfer(amount);\r\n        } else {\r\n            require(token.transfer(destination, amount));\r\n        }\r\n\r\n        WithdrawFunds(token, amount, destination);\r\n\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token, uint amount, address destination)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "destination"
         Type: address
         Source: "address destination"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOperator"
       Gas costs: 0
       Source: "onlyOperator"
      Identifier onlyOperator
         Type: modifier ()
         Source: "onlyOperator"
    Block
       Source: "{\r\n        require(approvedWithdrawAddresses[keccak256(token, destination)]);\r\n\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            destination.transfer(amount);\r\n        } else {\r\n            require(token.transfer(destination, amount));\r\n        }\r\n\r\n        WithdrawFunds(token, amount, destination);\r\n\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(approvedWithdrawAddresses[keccak256(token, destination)])"
        FunctionCall
           Type: tuple()
           Source: "require(approvedWithdrawAddresses[keccak256(token, destination)])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          IndexAccess
             Type: bool
             Source: "approvedWithdrawAddresses[keccak256(token, destination)]"
            Identifier approvedWithdrawAddresses
               Type: mapping(bytes32 => bool)
               Source: "approvedWithdrawAddresses"
            FunctionCall
               Type: bytes32
               Source: "keccak256(token, destination)"
              Identifier keccak256
                 Type: function () pure returns (bytes32)
                 Source: "keccak256"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
              Identifier destination
                 Type: address
                 Source: "destination"
      IfStatement
         Source: "if (token == ETH_TOKEN_ADDRESS) {\r\n            destination.transfer(amount);\r\n        } else {\r\n            require(token.transfer(destination, amount));\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "token == ETH_TOKEN_ADDRESS"
          Identifier token
             Type: contract ERC20
             Source: "token"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        Block
           Source: "{\r\n            destination.transfer(amount);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "destination.transfer(amount)"
            FunctionCall
               Type: tuple()
               Source: "destination.transfer(amount)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "destination.transfer"
                Identifier destination
                   Type: address
                   Source: "destination"
              Identifier amount
                 Type: uint256
                 Source: "amount"
        Block
           Source: "{\r\n            require(token.transfer(destination, amount));\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require(token.transfer(destination, amount))"
            FunctionCall
               Type: tuple()
               Source: "require(token.transfer(destination, amount))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "token.transfer(destination, amount)"
                MemberAccess to member transfer
                   Type: function (address,uint256) external returns (bool)
                   Source: "token.transfer"
                  Identifier token
                     Type: contract ERC20
                     Source: "token"
                Identifier destination
                   Type: address
                   Source: "destination"
                Identifier amount
                   Type: uint256
                   Source: "amount"
      ExpressionStatement
         Gas costs: 0
         Source: "WithdrawFunds(token, amount, destination)"
        FunctionCall
           Type: tuple()
           Source: "WithdrawFunds(token, amount, destination)"
          Identifier WithdrawFunds
             Type: function (contract ERC20,uint256,address)
             Source: "WithdrawFunds"
          Identifier token
             Type: contract ERC20
             Source: "token"
          Identifier amount
             Type: uint256
             Source: "amount"
          Identifier destination
             Type: address
             Source: "destination"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  EventDefinition "SetContractAddresses"
     Gas costs: 0
     Source: "event SetContractAddresses(address network, address rate, address sanity);"
    ParameterList
       Source: "(address network, address rate, address sanity)"
      VariableDeclaration "network"
         Type: address
         Source: "address network"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "rate"
         Type: address
         Source: "address rate"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "sanity"
         Type: address
         Source: "address sanity"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "setContracts" - public
     Source: "function setContracts(address _kyberNetwork, ConversionRates _conversionRates, SanityRatesInterface _sanityRates)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(_kyberNetwork != address(0));\r\n        require(_conversionRates != address(0));\r\n\r\n        kyberNetwork = _kyberNetwork;\r\n        conversionRatesContract = _conversionRates;\r\n        sanityRatesContract = _sanityRates;\r\n\r\n        SetContractAddresses(kyberNetwork, conversionRatesContract, sanityRatesContract);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _kyberNetwork, ConversionRates _conversionRates, SanityRatesInterface _sanityRates)"
      VariableDeclaration "_kyberNetwork"
         Type: address
         Source: "address _kyberNetwork"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_conversionRates"
         Type: contract ConversionRates
         Source: "ConversionRates _conversionRates"
        UserDefinedTypeName "ConversionRates"
           Source: "ConversionRates"
      VariableDeclaration "_sanityRates"
         Type: contract SanityRatesInterface
         Source: "SanityRatesInterface _sanityRates"
        UserDefinedTypeName "SanityRatesInterface"
           Source: "SanityRatesInterface"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        require(_kyberNetwork != address(0));\r\n        require(_conversionRates != address(0));\r\n\r\n        kyberNetwork = _kyberNetwork;\r\n        conversionRatesContract = _conversionRates;\r\n        sanityRatesContract = _sanityRates;\r\n\r\n        SetContractAddresses(kyberNetwork, conversionRatesContract, sanityRatesContract);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_kyberNetwork != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_kyberNetwork != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_kyberNetwork != address(0)"
            Identifier _kyberNetwork
               Type: address
               Source: "_kyberNetwork"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_conversionRates != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_conversionRates != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_conversionRates != address(0)"
            Identifier _conversionRates
               Type: contract ConversionRates
               Source: "_conversionRates"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "kyberNetwork = _kyberNetwork"
        Assignment using operator =
           Type: address
           Source: "kyberNetwork = _kyberNetwork"
          Identifier kyberNetwork
             Type: address
             Source: "kyberNetwork"
          Identifier _kyberNetwork
             Type: address
             Source: "_kyberNetwork"
      ExpressionStatement
         Gas costs: 0
         Source: "conversionRatesContract = _conversionRates"
        Assignment using operator =
           Type: contract ConversionRates
           Source: "conversionRatesContract = _conversionRates"
          Identifier conversionRatesContract
             Type: contract ConversionRates
             Source: "conversionRatesContract"
          Identifier _conversionRates
             Type: contract ConversionRates
             Source: "_conversionRates"
      ExpressionStatement
         Gas costs: 0
         Source: "sanityRatesContract = _sanityRates"
        Assignment using operator =
           Type: contract SanityRatesInterface
           Source: "sanityRatesContract = _sanityRates"
          Identifier sanityRatesContract
             Type: contract SanityRatesInterface
             Source: "sanityRatesContract"
          Identifier _sanityRates
             Type: contract SanityRatesInterface
             Source: "_sanityRates"
      ExpressionStatement
         Gas costs: 0
         Source: "SetContractAddresses(kyberNetwork, conversionRatesContract, sanityRatesContract)"
        FunctionCall
           Type: tuple()
           Source: "SetContractAddresses(kyberNetwork, conversionRatesContract, sanityRatesContract)"
          Identifier SetContractAddresses
             Type: function (address,address,address)
             Source: "SetContractAddresses"
          Identifier kyberNetwork
             Type: address
             Source: "kyberNetwork"
          Identifier conversionRatesContract
             Type: contract ConversionRates
             Source: "conversionRatesContract"
          Identifier sanityRatesContract
             Type: contract SanityRatesInterface
             Source: "sanityRatesContract"
  FunctionDefinition "getBalance" - public - const
     Source: "function getBalance(ERC20 token) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return this.balance;\r\n        else\r\n            return token.balanceOf(this);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return this.balance;\r\n        else\r\n            return token.balanceOf(this);\r\n    }"
      IfStatement
         Source: "if (token == ETH_TOKEN_ADDRESS)\r\n            return this.balance;\r\n        else\r\n            return token.balanceOf(this)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "token == ETH_TOKEN_ADDRESS"
          Identifier token
             Type: contract ERC20
             Source: "token"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        Return
           Gas costs: 0
           Source: "return this.balance"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract KyberReserve
               Source: "this"
        Return
           Gas costs: 0
           Source: "return token.balanceOf(this)"
          FunctionCall
             Type: uint256
             Source: "token.balanceOf(this)"
            MemberAccess to member balanceOf
               Type: function (address) view external returns (uint256)
               Source: "token.balanceOf"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
            Identifier this
               Type: contract KyberReserve
               Source: "this"
  FunctionDefinition "getDecimals" - public - const
     Source: "function getDecimals(ERC20 token) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return 18;\r\n        return token.decimals();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 token)"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (token == ETH_TOKEN_ADDRESS) return 18;\r\n        return token.decimals();\r\n    }"
      IfStatement
         Source: "if (token == ETH_TOKEN_ADDRESS) return 18"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "token == ETH_TOKEN_ADDRESS"
          Identifier token
             Type: contract ERC20
             Source: "token"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        Return
           Gas costs: 0
           Source: "return 18"
          Literal, token: [no token] value: 18
             Type: int_const 18
             Source: "18"
      Return
         Gas costs: 0
         Source: "return token.decimals()"
        FunctionCall
           Type: uint256
           Source: "token.decimals()"
          MemberAccess to member decimals
             Type: function () view external returns (uint256)
             Source: "token.decimals"
            Identifier token
               Type: contract ERC20
               Source: "token"
  FunctionDefinition "getDestQty" - public - const
     Source: "function getDestQty(ERC20 src, ERC20 dest, uint srcQty, uint rate) public view returns(uint) {\r\n        uint dstDecimals = getDecimals(dest);\r\n        uint srcDecimals = getDecimals(src);\r\n\r\n        return calcDstQty(srcQty, srcDecimals, dstDecimals, rate);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 src, ERC20 dest, uint srcQty, uint rate)"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "srcQty"
         Type: uint256
         Source: "uint srcQty"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "rate"
         Type: uint256
         Source: "uint rate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint dstDecimals = getDecimals(dest);\r\n        uint srcDecimals = getDecimals(src);\r\n\r\n        return calcDstQty(srcQty, srcDecimals, dstDecimals, rate);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint dstDecimals = getDecimals(dest)"
        VariableDeclaration "dstDecimals"
           Type: uint256
           Source: "uint dstDecimals"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getDecimals(dest)"
          Identifier getDecimals
             Type: function (contract ERC20) view returns (uint256)
             Source: "getDecimals"
          Identifier dest
             Type: contract ERC20
             Source: "dest"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint srcDecimals = getDecimals(src)"
        VariableDeclaration "srcDecimals"
           Type: uint256
           Source: "uint srcDecimals"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getDecimals(src)"
          Identifier getDecimals
             Type: function (contract ERC20) view returns (uint256)
             Source: "getDecimals"
          Identifier src
             Type: contract ERC20
             Source: "src"
      Return
         Gas costs: 0
         Source: "return calcDstQty(srcQty, srcDecimals, dstDecimals, rate)"
        FunctionCall
           Type: uint256
           Source: "calcDstQty(srcQty, srcDecimals, dstDecimals, rate)"
          Identifier calcDstQty
             Type: function (uint256,uint256,uint256,uint256) pure returns (uint256)
             Source: "calcDstQty"
          Identifier srcQty
             Type: uint256
             Source: "srcQty"
          Identifier srcDecimals
             Type: uint256
             Source: "srcDecimals"
          Identifier dstDecimals
             Type: uint256
             Source: "dstDecimals"
          Identifier rate
             Type: uint256
             Source: "rate"
  FunctionDefinition "getSrcQty" - public - const
     Source: "function getSrcQty(ERC20 src, ERC20 dest, uint dstQty, uint rate) public view returns(uint) {\r\n        uint dstDecimals = getDecimals(dest);\r\n        uint srcDecimals = getDecimals(src);\r\n\r\n        return calcSrcQty(dstQty, srcDecimals, dstDecimals, rate);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 src, ERC20 dest, uint dstQty, uint rate)"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dstQty"
         Type: uint256
         Source: "uint dstQty"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "rate"
         Type: uint256
         Source: "uint rate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint dstDecimals = getDecimals(dest);\r\n        uint srcDecimals = getDecimals(src);\r\n\r\n        return calcSrcQty(dstQty, srcDecimals, dstDecimals, rate);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint dstDecimals = getDecimals(dest)"
        VariableDeclaration "dstDecimals"
           Type: uint256
           Source: "uint dstDecimals"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getDecimals(dest)"
          Identifier getDecimals
             Type: function (contract ERC20) view returns (uint256)
             Source: "getDecimals"
          Identifier dest
             Type: contract ERC20
             Source: "dest"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint srcDecimals = getDecimals(src)"
        VariableDeclaration "srcDecimals"
           Type: uint256
           Source: "uint srcDecimals"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getDecimals(src)"
          Identifier getDecimals
             Type: function (contract ERC20) view returns (uint256)
             Source: "getDecimals"
          Identifier src
             Type: contract ERC20
             Source: "src"
      Return
         Gas costs: 0
         Source: "return calcSrcQty(dstQty, srcDecimals, dstDecimals, rate)"
        FunctionCall
           Type: uint256
           Source: "calcSrcQty(dstQty, srcDecimals, dstDecimals, rate)"
          Identifier calcSrcQty
             Type: function (uint256,uint256,uint256,uint256) pure returns (uint256)
             Source: "calcSrcQty"
          Identifier dstQty
             Type: uint256
             Source: "dstQty"
          Identifier srcDecimals
             Type: uint256
             Source: "srcDecimals"
          Identifier dstDecimals
             Type: uint256
             Source: "dstDecimals"
          Identifier rate
             Type: uint256
             Source: "rate"
  FunctionDefinition "getConversionRate" - public - const
     Source: "function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint) {\r\n        ERC20 token;\r\n        bool  buy;\r\n\r\n        if (!tradeEnabled) return 0;\r\n\r\n        if (ETH_TOKEN_ADDRESS == src) {\r\n            buy = true;\r\n            token = dest;\r\n        } else if (ETH_TOKEN_ADDRESS == dest) {\r\n            buy = false;\r\n            token = src;\r\n        } else {\r\n            return 0; // pair is not listed\r\n        }\r\n\r\n        uint rate = conversionRatesContract.getRate(token, blockNumber, buy, srcQty);\r\n        uint destQty = getDestQty(src, dest, srcQty, rate);\r\n\r\n        if (getBalance(dest) < destQty) return 0;\r\n\r\n        if (sanityRatesContract != address(0)) {\r\n            uint sanityRate = sanityRatesContract.getSanityRate(src, dest);\r\n            if (rate > sanityRate) return 0;\r\n        }\r\n\r\n        return rate;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber)"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "srcQty"
         Type: uint256
         Source: "uint srcQty"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "blockNumber"
         Type: uint256
         Source: "uint blockNumber"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        ERC20 token;\r\n        bool  buy;\r\n\r\n        if (!tradeEnabled) return 0;\r\n\r\n        if (ETH_TOKEN_ADDRESS == src) {\r\n            buy = true;\r\n            token = dest;\r\n        } else if (ETH_TOKEN_ADDRESS == dest) {\r\n            buy = false;\r\n            token = src;\r\n        } else {\r\n            return 0; // pair is not listed\r\n        }\r\n\r\n        uint rate = conversionRatesContract.getRate(token, blockNumber, buy, srcQty);\r\n        uint destQty = getDestQty(src, dest, srcQty, rate);\r\n\r\n        if (getBalance(dest) < destQty) return 0;\r\n\r\n        if (sanityRatesContract != address(0)) {\r\n            uint sanityRate = sanityRatesContract.getSanityRate(src, dest);\r\n            if (rate > sanityRate) return 0;\r\n        }\r\n\r\n        return rate;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "ERC20 token"
        VariableDeclaration "token"
           Type: contract ERC20
           Source: "ERC20 token"
          UserDefinedTypeName "ERC20"
             Source: "ERC20"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bool  buy"
        VariableDeclaration "buy"
           Type: bool
           Source: "bool  buy"
          ElementaryTypeName bool
             Source: "bool"
      IfStatement
         Source: "if (!tradeEnabled) return 0"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 0
           Source: "!tradeEnabled"
          Identifier tradeEnabled
             Type: bool
             Source: "tradeEnabled"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      IfStatement
         Source: "if (ETH_TOKEN_ADDRESS == src) {\r\n            buy = true;\r\n            token = dest;\r\n        } else if (ETH_TOKEN_ADDRESS == dest) {\r\n            buy = false;\r\n            token = src;\r\n        } else {\r\n            return 0; // pair is not listed\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "ETH_TOKEN_ADDRESS == src"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
          Identifier src
             Type: contract ERC20
             Source: "src"
        Block
           Source: "{\r\n            buy = true;\r\n            token = dest;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "buy = true"
            Assignment using operator =
               Type: bool
               Source: "buy = true"
              Identifier buy
                 Type: bool
                 Source: "buy"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
          ExpressionStatement
             Gas costs: 0
             Source: "token = dest"
            Assignment using operator =
               Type: contract ERC20
               Source: "token = dest"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
              Identifier dest
                 Type: contract ERC20
                 Source: "dest"
        IfStatement
           Source: "if (ETH_TOKEN_ADDRESS == dest) {\r\n            buy = false;\r\n            token = src;\r\n        } else {\r\n            return 0; // pair is not listed\r\n        }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 0
             Source: "ETH_TOKEN_ADDRESS == dest"
            Identifier ETH_TOKEN_ADDRESS
               Type: contract ERC20
               Source: "ETH_TOKEN_ADDRESS"
            Identifier dest
               Type: contract ERC20
               Source: "dest"
          Block
             Source: "{\r\n            buy = false;\r\n            token = src;\r\n        }"
            ExpressionStatement
               Gas costs: 0
               Source: "buy = false"
              Assignment using operator =
                 Type: bool
                 Source: "buy = false"
                Identifier buy
                   Type: bool
                   Source: "buy"
                Literal, token: false value: false
                   Type: bool
                   Source: "false"
            ExpressionStatement
               Gas costs: 0
               Source: "token = src"
              Assignment using operator =
                 Type: contract ERC20
                 Source: "token = src"
                Identifier token
                   Type: contract ERC20
                   Source: "token"
                Identifier src
                   Type: contract ERC20
                   Source: "src"
          Block
             Source: "{\r\n            return 0; // pair is not listed\r\n        }"
            Return
               Gas costs: 0
               Source: "return 0"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint rate = conversionRatesContract.getRate(token, blockNumber, buy, srcQty)"
        VariableDeclaration "rate"
           Type: uint256
           Source: "uint rate"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "conversionRatesContract.getRate(token, blockNumber, buy, srcQty)"
          MemberAccess to member getRate
             Type: function (contract ERC20,uint256,bool,uint256) view external returns (uint256)
             Source: "conversionRatesContract.getRate"
            Identifier conversionRatesContract
               Type: contract ConversionRates
               Source: "conversionRatesContract"
          Identifier token
             Type: contract ERC20
             Source: "token"
          Identifier blockNumber
             Type: uint256
             Source: "blockNumber"
          Identifier buy
             Type: bool
             Source: "buy"
          Identifier srcQty
             Type: uint256
             Source: "srcQty"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint destQty = getDestQty(src, dest, srcQty, rate)"
        VariableDeclaration "destQty"
           Type: uint256
           Source: "uint destQty"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getDestQty(src, dest, srcQty, rate)"
          Identifier getDestQty
             Type: function (contract ERC20,contract ERC20,uint256,uint256) view returns (uint256)
             Source: "getDestQty"
          Identifier src
             Type: contract ERC20
             Source: "src"
          Identifier dest
             Type: contract ERC20
             Source: "dest"
          Identifier srcQty
             Type: uint256
             Source: "srcQty"
          Identifier rate
             Type: uint256
             Source: "rate"
      IfStatement
         Source: "if (getBalance(dest) < destQty) return 0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "getBalance(dest) < destQty"
          FunctionCall
             Type: uint256
             Source: "getBalance(dest)"
            Identifier getBalance
               Type: function (contract ERC20) view returns (uint256)
               Source: "getBalance"
            Identifier dest
               Type: contract ERC20
               Source: "dest"
          Identifier destQty
             Type: uint256
             Source: "destQty"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      IfStatement
         Source: "if (sanityRatesContract != address(0)) {\r\n            uint sanityRate = sanityRatesContract.getSanityRate(src, dest);\r\n            if (rate > sanityRate) return 0;\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "sanityRatesContract != address(0)"
          Identifier sanityRatesContract
             Type: contract SanityRatesInterface
             Source: "sanityRatesContract"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            uint sanityRate = sanityRatesContract.getSanityRate(src, dest);\r\n            if (rate > sanityRate) return 0;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "uint sanityRate = sanityRatesContract.getSanityRate(src, dest)"
            VariableDeclaration "sanityRate"
               Type: uint256
               Source: "uint sanityRate"
              ElementaryTypeName uint
                 Source: "uint"
            FunctionCall
               Type: uint256
               Source: "sanityRatesContract.getSanityRate(src, dest)"
              MemberAccess to member getSanityRate
                 Type: function (contract ERC20,contract ERC20) view external returns (uint256)
                 Source: "sanityRatesContract.getSanityRate"
                Identifier sanityRatesContract
                   Type: contract SanityRatesInterface
                   Source: "sanityRatesContract"
              Identifier src
                 Type: contract ERC20
                 Source: "src"
              Identifier dest
                 Type: contract ERC20
                 Source: "dest"
          IfStatement
             Source: "if (rate > sanityRate) return 0"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 0
               Source: "rate > sanityRate"
              Identifier rate
                 Type: uint256
                 Source: "rate"
              Identifier sanityRate
                 Type: uint256
                 Source: "sanityRate"
            Return
               Gas costs: 0
               Source: "return 0"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      Return
         Gas costs: 0
         Source: "return rate"
        Identifier rate
           Type: uint256
           Source: "rate"
  FunctionDefinition "doTrade"
     Source: "function doTrade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        // can skip validation if done at kyber network level\r\n        if (validate) {\r\n            require(conversionRate > 0);\r\n            if (srcToken == ETH_TOKEN_ADDRESS)\r\n                require(msg.value == srcAmount);\r\n            else\r\n                require(msg.value == 0);\r\n        }\r\n\r\n        uint destAmount = getDestQty(srcToken, destToken, srcAmount, conversionRate);\r\n        // sanity check\r\n        require(destAmount > 0);\r\n\r\n        // add to imbalance\r\n        ERC20 token;\r\n        int buy;\r\n        if (srcToken == ETH_TOKEN_ADDRESS) {\r\n            buy = int(destAmount);\r\n            token = destToken;\r\n        } else {\r\n            buy = -1 * int(srcAmount);\r\n            token = srcToken;\r\n        }\r\n\r\n        conversionRatesContract.recordImbalance(\r\n            token,\r\n            buy,\r\n            0,\r\n            block.number\r\n        );\r\n\r\n        // collect src tokens\r\n        if (srcToken != ETH_TOKEN_ADDRESS) {\r\n            require(srcToken.transferFrom(msg.sender, this, srcAmount));\r\n        }\r\n\r\n        // send dest tokens\r\n        if (destToken == ETH_TOKEN_ADDRESS) {\r\n            destAddress.transfer(destAmount);\r\n        } else {\r\n            require(destToken.transfer(destAddress, destAmount));\r\n        }\r\n\r\n        TradeExecute(msg.sender, srcToken, srcAmount, destToken, destAmount, destAddress);\r\n\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )"
      VariableDeclaration "srcToken"
         Type: contract ERC20
         Source: "ERC20 srcToken"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "srcAmount"
         Type: uint256
         Source: "uint srcAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "destToken"
         Type: contract ERC20
         Source: "ERC20 destToken"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "destAddress"
         Type: address
         Source: "address destAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "conversionRate"
         Type: uint256
         Source: "uint conversionRate"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "validate"
         Type: bool
         Source: "bool validate"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        // can skip validation if done at kyber network level\r\n        if (validate) {\r\n            require(conversionRate > 0);\r\n            if (srcToken == ETH_TOKEN_ADDRESS)\r\n                require(msg.value == srcAmount);\r\n            else\r\n                require(msg.value == 0);\r\n        }\r\n\r\n        uint destAmount = getDestQty(srcToken, destToken, srcAmount, conversionRate);\r\n        // sanity check\r\n        require(destAmount > 0);\r\n\r\n        // add to imbalance\r\n        ERC20 token;\r\n        int buy;\r\n        if (srcToken == ETH_TOKEN_ADDRESS) {\r\n            buy = int(destAmount);\r\n            token = destToken;\r\n        } else {\r\n            buy = -1 * int(srcAmount);\r\n            token = srcToken;\r\n        }\r\n\r\n        conversionRatesContract.recordImbalance(\r\n            token,\r\n            buy,\r\n            0,\r\n            block.number\r\n        );\r\n\r\n        // collect src tokens\r\n        if (srcToken != ETH_TOKEN_ADDRESS) {\r\n            require(srcToken.transferFrom(msg.sender, this, srcAmount));\r\n        }\r\n\r\n        // send dest tokens\r\n        if (destToken == ETH_TOKEN_ADDRESS) {\r\n            destAddress.transfer(destAmount);\r\n        } else {\r\n            require(destToken.transfer(destAddress, destAmount));\r\n        }\r\n\r\n        TradeExecute(msg.sender, srcToken, srcAmount, destToken, destAmount, destAddress);\r\n\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (validate) {\r\n            require(conversionRate > 0);\r\n            if (srcToken == ETH_TOKEN_ADDRESS)\r\n                require(msg.value == srcAmount);\r\n            else\r\n                require(msg.value == 0);\r\n        }"
        Identifier validate
           Type: bool
           Gas costs: 0
           Source: "validate"
        Block
           Source: "{\r\n            require(conversionRate > 0);\r\n            if (srcToken == ETH_TOKEN_ADDRESS)\r\n                require(msg.value == srcAmount);\r\n            else\r\n                require(msg.value == 0);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require(conversionRate > 0)"
            FunctionCall
               Type: tuple()
               Source: "require(conversionRate > 0)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator >
                 Type: bool
                 Source: "conversionRate > 0"
                Identifier conversionRate
                   Type: uint256
                   Source: "conversionRate"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
          IfStatement
             Source: "if (srcToken == ETH_TOKEN_ADDRESS)\r\n                require(msg.value == srcAmount);\r\n            else\r\n                require(msg.value == 0)"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "srcToken == ETH_TOKEN_ADDRESS"
              Identifier srcToken
                 Type: contract ERC20
                 Source: "srcToken"
              Identifier ETH_TOKEN_ADDRESS
                 Type: contract ERC20
                 Source: "ETH_TOKEN_ADDRESS"
            ExpressionStatement
               Gas costs: 0
               Source: "require(msg.value == srcAmount)"
              FunctionCall
                 Type: tuple()
                 Source: "require(msg.value == srcAmount)"
                Identifier require
                   Type: function (bool) pure
                   Source: "require"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "msg.value == srcAmount"
                  MemberAccess to member value
                     Type: uint256
                     Source: "msg.value"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier srcAmount
                     Type: uint256
                     Source: "srcAmount"
            ExpressionStatement
               Gas costs: 0
               Source: "require(msg.value == 0)"
              FunctionCall
                 Type: tuple()
                 Source: "require(msg.value == 0)"
                Identifier require
                   Type: function (bool) pure
                   Source: "require"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "msg.value == 0"
                  MemberAccess to member value
                     Type: uint256
                     Source: "msg.value"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint destAmount = getDestQty(srcToken, destToken, srcAmount, conversionRate)"
        VariableDeclaration "destAmount"
           Type: uint256
           Source: "uint destAmount"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getDestQty(srcToken, destToken, srcAmount, conversionRate)"
          Identifier getDestQty
             Type: function (contract ERC20,contract ERC20,uint256,uint256) view returns (uint256)
             Source: "getDestQty"
          Identifier srcToken
             Type: contract ERC20
             Source: "srcToken"
          Identifier destToken
             Type: contract ERC20
             Source: "destToken"
          Identifier srcAmount
             Type: uint256
             Source: "srcAmount"
          Identifier conversionRate
             Type: uint256
             Source: "conversionRate"
      ExpressionStatement
         Gas costs: 0
         Source: "require(destAmount > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(destAmount > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "destAmount > 0"
            Identifier destAmount
               Type: uint256
               Source: "destAmount"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "ERC20 token"
        VariableDeclaration "token"
           Type: contract ERC20
           Source: "ERC20 token"
          UserDefinedTypeName "ERC20"
             Source: "ERC20"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "int buy"
        VariableDeclaration "buy"
           Type: int256
           Source: "int buy"
          ElementaryTypeName int
             Source: "int"
      IfStatement
         Source: "if (srcToken == ETH_TOKEN_ADDRESS) {\r\n            buy = int(destAmount);\r\n            token = destToken;\r\n        } else {\r\n            buy = -1 * int(srcAmount);\r\n            token = srcToken;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "srcToken == ETH_TOKEN_ADDRESS"
          Identifier srcToken
             Type: contract ERC20
             Source: "srcToken"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        Block
           Source: "{\r\n            buy = int(destAmount);\r\n            token = destToken;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "buy = int(destAmount)"
            Assignment using operator =
               Type: int256
               Source: "buy = int(destAmount)"
              Identifier buy
                 Type: int256
                 Source: "buy"
              FunctionCall
                 Type: int256
                 Source: "int(destAmount)"
                ElementaryTypeNameExpression int
                   Type: type(int256)
                   Source: "int"
                Identifier destAmount
                   Type: uint256
                   Source: "destAmount"
          ExpressionStatement
             Gas costs: 0
             Source: "token = destToken"
            Assignment using operator =
               Type: contract ERC20
               Source: "token = destToken"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
              Identifier destToken
                 Type: contract ERC20
                 Source: "destToken"
        Block
           Source: "{\r\n            buy = -1 * int(srcAmount);\r\n            token = srcToken;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "buy = -1 * int(srcAmount)"
            Assignment using operator =
               Type: int256
               Source: "buy = -1 * int(srcAmount)"
              Identifier buy
                 Type: int256
                 Source: "buy"
              BinaryOperation using operator *
                 Type: int256
                 Source: "-1 * int(srcAmount)"
                UnaryOperation (prefix) -
                   Type: int_const -1
                   Source: "-1"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
                FunctionCall
                   Type: int256
                   Source: "int(srcAmount)"
                  ElementaryTypeNameExpression int
                     Type: type(int256)
                     Source: "int"
                  Identifier srcAmount
                     Type: uint256
                     Source: "srcAmount"
          ExpressionStatement
             Gas costs: 0
             Source: "token = srcToken"
            Assignment using operator =
               Type: contract ERC20
               Source: "token = srcToken"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
              Identifier srcToken
                 Type: contract ERC20
                 Source: "srcToken"
      ExpressionStatement
         Gas costs: 0
         Source: "conversionRatesContract.recordImbalance(\r\n            token,\r\n            buy,\r\n            0,\r\n            block.number\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "conversionRatesContract.recordImbalance(\r\n            token,\r\n            buy,\r\n            0,\r\n            block.number\r\n        )"
          MemberAccess to member recordImbalance
             Type: function (contract ERC20,int256,uint256,uint256) external
             Source: "conversionRatesContract.recordImbalance"
            Identifier conversionRatesContract
               Type: contract ConversionRates
               Source: "conversionRatesContract"
          Identifier token
             Type: contract ERC20
             Source: "token"
          Identifier buy
             Type: int256
             Source: "buy"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
      IfStatement
         Source: "if (srcToken != ETH_TOKEN_ADDRESS) {\r\n            require(srcToken.transferFrom(msg.sender, this, srcAmount));\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "srcToken != ETH_TOKEN_ADDRESS"
          Identifier srcToken
             Type: contract ERC20
             Source: "srcToken"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        Block
           Source: "{\r\n            require(srcToken.transferFrom(msg.sender, this, srcAmount));\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require(srcToken.transferFrom(msg.sender, this, srcAmount))"
            FunctionCall
               Type: tuple()
               Source: "require(srcToken.transferFrom(msg.sender, this, srcAmount))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "srcToken.transferFrom(msg.sender, this, srcAmount)"
                MemberAccess to member transferFrom
                   Type: function (address,address,uint256) external returns (bool)
                   Source: "srcToken.transferFrom"
                  Identifier srcToken
                     Type: contract ERC20
                     Source: "srcToken"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Identifier this
                   Type: contract KyberReserve
                   Source: "this"
                Identifier srcAmount
                   Type: uint256
                   Source: "srcAmount"
      IfStatement
         Source: "if (destToken == ETH_TOKEN_ADDRESS) {\r\n            destAddress.transfer(destAmount);\r\n        } else {\r\n            require(destToken.transfer(destAddress, destAmount));\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "destToken == ETH_TOKEN_ADDRESS"
          Identifier destToken
             Type: contract ERC20
             Source: "destToken"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        Block
           Source: "{\r\n            destAddress.transfer(destAmount);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "destAddress.transfer(destAmount)"
            FunctionCall
               Type: tuple()
               Source: "destAddress.transfer(destAmount)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "destAddress.transfer"
                Identifier destAddress
                   Type: address
                   Source: "destAddress"
              Identifier destAmount
                 Type: uint256
                 Source: "destAmount"
        Block
           Source: "{\r\n            require(destToken.transfer(destAddress, destAmount));\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require(destToken.transfer(destAddress, destAmount))"
            FunctionCall
               Type: tuple()
               Source: "require(destToken.transfer(destAddress, destAmount))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "destToken.transfer(destAddress, destAmount)"
                MemberAccess to member transfer
                   Type: function (address,uint256) external returns (bool)
                   Source: "destToken.transfer"
                  Identifier destToken
                     Type: contract ERC20
                     Source: "destToken"
                Identifier destAddress
                   Type: address
                   Source: "destAddress"
                Identifier destAmount
                   Type: uint256
                   Source: "destAmount"
      ExpressionStatement
         Gas costs: 0
         Source: "TradeExecute(msg.sender, srcToken, srcAmount, destToken, destAmount, destAddress)"
        FunctionCall
           Type: tuple()
           Source: "TradeExecute(msg.sender, srcToken, srcAmount, destToken, destAmount, destAddress)"
          Identifier TradeExecute
             Type: function (address,address,uint256,address,uint256,address)
             Source: "TradeExecute"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier srcToken
             Type: contract ERC20
             Source: "srcToken"
          Identifier srcAmount
             Type: uint256
             Source: "srcAmount"
          Identifier destToken
             Type: contract ERC20
             Source: "destToken"
          Identifier destAmount
             Type: uint256
             Source: "destAmount"
          Identifier destAddress
             Type: address
             Source: "destAddress"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
ContractDefinition "WhiteList"
   Source: "contract WhiteList is Withdrawable {\r\n\r\n    uint public weiPerSgd; // amount of weis in 1 singapore dollar\r\n    mapping (address=>uint) public userCategory; // each user has a category defining cap on trade. 0 for standard.\r\n    mapping (uint=>uint)    public categoryCap;  // will define cap on trade amount per category in singapore Dollar.\r\n\r\n    function WhiteList(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }\r\n\r\n    function getUserCapInWei(address user) external view returns (uint userCapWei) {\r\n        uint category = userCategory[user];\r\n        return (categoryCap[category] * weiPerSgd);\r\n    }\r\n\r\n    event UserCategorySet(address user, uint category);\r\n\r\n    function setUserCategory(address user, uint category) public onlyOperator {\r\n        userCategory[user] = category;\r\n        UserCategorySet(user, category);\r\n    }\r\n\r\n    event CategoryCapSet (uint category, uint sgdCap);\r\n\r\n    function setCategoryCap(uint category, uint sgdCap) public onlyOperator {\r\n        categoryCap[category] = sgdCap;\r\n        CategoryCapSet(category, sgdCap);\r\n    }\r\n\r\n    event SgdToWeiRateSet (uint rate);\r\n\r\n    function setSgdToEthRate(uint _sgdToWeiRate) public onlyOperator {\r\n        weiPerSgd = _sgdToWeiRate;\r\n        SgdToWeiRateSet(_sgdToWeiRate);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Withdrawable"
    UserDefinedTypeName "Withdrawable"
       Source: "Withdrawable"
  VariableDeclaration "weiPerSgd"
     Type: uint256
     Gas costs: 0
     Source: "uint public weiPerSgd"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "userCategory"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address=>uint) public userCategory"
    Mapping
       Source: "mapping (address=>uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "categoryCap"
     Type: mapping(uint256 => uint256)
     Gas costs: 0
     Source: "mapping (uint=>uint)    public categoryCap"
    Mapping
       Source: "mapping (uint=>uint)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName uint
         Source: "uint"
  FunctionDefinition "WhiteList" - public
     Source: "function WhiteList(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _admin)"
      VariableDeclaration "_admin"
         Type: address
         Source: "address _admin"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_admin != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_admin != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_admin != address(0)"
            Identifier _admin
               Type: address
               Source: "_admin"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "admin = _admin"
        Assignment using operator =
           Type: address
           Source: "admin = _admin"
          Identifier admin
             Type: address
             Source: "admin"
          Identifier _admin
             Type: address
             Source: "_admin"
  FunctionDefinition "getUserCapInWei" - public - const
     Source: "function getUserCapInWei(address user) external view returns (uint userCapWei) {\r\n        uint category = userCategory[user];\r\n        return (categoryCap[category] * weiPerSgd);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address user)"
      VariableDeclaration "user"
         Type: address
         Source: "address user"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint userCapWei)"
      VariableDeclaration "userCapWei"
         Type: uint256
         Source: "uint userCapWei"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint category = userCategory[user];\r\n        return (categoryCap[category] * weiPerSgd);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint category = userCategory[user]"
        VariableDeclaration "category"
           Type: uint256
           Source: "uint category"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "userCategory[user]"
          Identifier userCategory
             Type: mapping(address => uint256)
             Source: "userCategory"
          Identifier user
             Type: address
             Source: "user"
      Return
         Gas costs: 0
         Source: "return (categoryCap[category] * weiPerSgd)"
        TupleExpression
           Type: uint256
           Source: "(categoryCap[category] * weiPerSgd)"
          BinaryOperation using operator *
             Type: uint256
             Source: "categoryCap[category] * weiPerSgd"
            IndexAccess
               Type: uint256
               Source: "categoryCap[category]"
              Identifier categoryCap
                 Type: mapping(uint256 => uint256)
                 Source: "categoryCap"
              Identifier category
                 Type: uint256
                 Source: "category"
            Identifier weiPerSgd
               Type: uint256
               Source: "weiPerSgd"
  EventDefinition "UserCategorySet"
     Gas costs: 0
     Source: "event UserCategorySet(address user, uint category);"
    ParameterList
       Source: "(address user, uint category)"
      VariableDeclaration "user"
         Type: address
         Source: "address user"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "category"
         Type: uint256
         Source: "uint category"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "setUserCategory" - public
     Source: "function setUserCategory(address user, uint category) public onlyOperator {\r\n        userCategory[user] = category;\r\n        UserCategorySet(user, category);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address user, uint category)"
      VariableDeclaration "user"
         Type: address
         Source: "address user"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "category"
         Type: uint256
         Source: "uint category"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOperator"
       Gas costs: 0
       Source: "onlyOperator"
      Identifier onlyOperator
         Type: modifier ()
         Source: "onlyOperator"
    Block
       Source: "{\r\n        userCategory[user] = category;\r\n        UserCategorySet(user, category);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "userCategory[user] = category"
        Assignment using operator =
           Type: uint256
           Source: "userCategory[user] = category"
          IndexAccess
             Type: uint256
             Source: "userCategory[user]"
            Identifier userCategory
               Type: mapping(address => uint256)
               Source: "userCategory"
            Identifier user
               Type: address
               Source: "user"
          Identifier category
             Type: uint256
             Source: "category"
      ExpressionStatement
         Gas costs: 0
         Source: "UserCategorySet(user, category)"
        FunctionCall
           Type: tuple()
           Source: "UserCategorySet(user, category)"
          Identifier UserCategorySet
             Type: function (address,uint256)
             Source: "UserCategorySet"
          Identifier user
             Type: address
             Source: "user"
          Identifier category
             Type: uint256
             Source: "category"
  EventDefinition "CategoryCapSet"
     Gas costs: 0
     Source: "event CategoryCapSet (uint category, uint sgdCap);"
    ParameterList
       Source: "(uint category, uint sgdCap)"
      VariableDeclaration "category"
         Type: uint256
         Source: "uint category"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "sgdCap"
         Type: uint256
         Source: "uint sgdCap"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "setCategoryCap" - public
     Source: "function setCategoryCap(uint category, uint sgdCap) public onlyOperator {\r\n        categoryCap[category] = sgdCap;\r\n        CategoryCapSet(category, sgdCap);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint category, uint sgdCap)"
      VariableDeclaration "category"
         Type: uint256
         Source: "uint category"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "sgdCap"
         Type: uint256
         Source: "uint sgdCap"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOperator"
       Gas costs: 0
       Source: "onlyOperator"
      Identifier onlyOperator
         Type: modifier ()
         Source: "onlyOperator"
    Block
       Source: "{\r\n        categoryCap[category] = sgdCap;\r\n        CategoryCapSet(category, sgdCap);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "categoryCap[category] = sgdCap"
        Assignment using operator =
           Type: uint256
           Source: "categoryCap[category] = sgdCap"
          IndexAccess
             Type: uint256
             Source: "categoryCap[category]"
            Identifier categoryCap
               Type: mapping(uint256 => uint256)
               Source: "categoryCap"
            Identifier category
               Type: uint256
               Source: "category"
          Identifier sgdCap
             Type: uint256
             Source: "sgdCap"
      ExpressionStatement
         Gas costs: 0
         Source: "CategoryCapSet(category, sgdCap)"
        FunctionCall
           Type: tuple()
           Source: "CategoryCapSet(category, sgdCap)"
          Identifier CategoryCapSet
             Type: function (uint256,uint256)
             Source: "CategoryCapSet"
          Identifier category
             Type: uint256
             Source: "category"
          Identifier sgdCap
             Type: uint256
             Source: "sgdCap"
  EventDefinition "SgdToWeiRateSet"
     Gas costs: 0
     Source: "event SgdToWeiRateSet (uint rate);"
    ParameterList
       Source: "(uint rate)"
      VariableDeclaration "rate"
         Type: uint256
         Source: "uint rate"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "setSgdToEthRate" - public
     Source: "function setSgdToEthRate(uint _sgdToWeiRate) public onlyOperator {\r\n        weiPerSgd = _sgdToWeiRate;\r\n        SgdToWeiRateSet(_sgdToWeiRate);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _sgdToWeiRate)"
      VariableDeclaration "_sgdToWeiRate"
         Type: uint256
         Source: "uint _sgdToWeiRate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOperator"
       Gas costs: 0
       Source: "onlyOperator"
      Identifier onlyOperator
         Type: modifier ()
         Source: "onlyOperator"
    Block
       Source: "{\r\n        weiPerSgd = _sgdToWeiRate;\r\n        SgdToWeiRateSet(_sgdToWeiRate);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "weiPerSgd = _sgdToWeiRate"
        Assignment using operator =
           Type: uint256
           Source: "weiPerSgd = _sgdToWeiRate"
          Identifier weiPerSgd
             Type: uint256
             Source: "weiPerSgd"
          Identifier _sgdToWeiRate
             Type: uint256
             Source: "_sgdToWeiRate"
      ExpressionStatement
         Gas costs: 0
         Source: "SgdToWeiRateSet(_sgdToWeiRate)"
        FunctionCall
           Type: tuple()
           Source: "SgdToWeiRateSet(_sgdToWeiRate)"
          Identifier SgdToWeiRateSet
             Type: function (uint256)
             Source: "SgdToWeiRateSet"
          Identifier _sgdToWeiRate
             Type: uint256
             Source: "_sgdToWeiRate"
ContractDefinition "FeeBurner"
   Source: "contract FeeBurner is Withdrawable, FeeBurnerInterface {\r\n\r\n    mapping(address=>uint) public reserveFeesInBps;\r\n    mapping(address=>address) public reserveKNCWallet;\r\n    mapping(address=>uint) public walletFeesInBps;\r\n    mapping(address=>uint) public reserveFeeToBurn;\r\n    mapping(address=>mapping(address=>uint)) public reserveFeeToWallet;\r\n\r\n    BurnableToken public knc;\r\n    address public kyberNetwork;\r\n    uint public kncPerETHRate = 300;\r\n\r\n    function FeeBurner(address _admin, BurnableToken kncToken) public {\r\n        require(_admin != address(0));\r\n        require(kncToken != address(0));\r\n        admin = _admin;\r\n        knc = kncToken;\r\n    }\r\n\r\n    function setReserveData(address reserve, uint feesInBps, address kncWallet) public onlyAdmin {\r\n        require(feesInBps < 100); // make sure it is always < 1%\r\n        require(kncWallet != address(0));\r\n        reserveFeesInBps[reserve] = feesInBps;\r\n        reserveKNCWallet[reserve] = kncWallet;\r\n    }\r\n\r\n    function setWalletFees(address wallet, uint feesInBps) public onlyAdmin {\r\n        require(feesInBps < 10000); // under 100%\r\n        walletFeesInBps[wallet] = feesInBps;\r\n    }\r\n\r\n    function setKyberNetwork(address _kyberNetwork) public onlyAdmin {\r\n        require(_kyberNetwork != address(0));\r\n        kyberNetwork = _kyberNetwork;\r\n    }\r\n\r\n    function setKNCRate(uint rate) public onlyAdmin {\r\n        kncPerETHRate = rate;\r\n    }\r\n\r\n    event AssignFeeToWallet(address reserve, address wallet, uint walletFee);\r\n    event AssignBurnFees(address reserve, uint burnFee);\r\n\r\n    function handleFees(uint tradeWeiAmount, address reserve, address wallet) public returns(bool) {\r\n        require(msg.sender == kyberNetwork);\r\n\r\n        uint kncAmount = tradeWeiAmount * kncPerETHRate;\r\n        uint fee = kncAmount * reserveFeesInBps[reserve] / 10000;\r\n\r\n        uint walletFee = fee * walletFeesInBps[wallet] / 10000;\r\n        require(fee >= walletFee);\r\n        uint feeToBurn = fee - walletFee;\r\n\r\n        if (walletFee > 0) {\r\n            reserveFeeToWallet[reserve][wallet] += walletFee;\r\n            AssignFeeToWallet(reserve, wallet, walletFee);\r\n        }\r\n\r\n        if (feeToBurn > 0) {\r\n            AssignBurnFees(reserve, feeToBurn);\r\n            reserveFeeToBurn[reserve] += feeToBurn;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // this function is callable by anyone\r\n    event BurnAssignedFees(address indexed reserve, address sender);\r\n\r\n    function burnReserveFees(address reserve) public {\r\n        uint burnAmount = reserveFeeToBurn[reserve];\r\n        require(burnAmount > 1);\r\n        reserveFeeToBurn[reserve] = 1; // leave 1 twei to avoid spikes in gas fee\r\n        require(knc.burnFrom(reserveKNCWallet[reserve], burnAmount - 1));\r\n\r\n        BurnAssignedFees(reserve, msg.sender);\r\n    }\r\n\r\n    event SendWalletFees(address indexed wallet, address reserve, address sender);\r\n\r\n    // this function is callable by anyone\r\n    function sendFeeToWallet(address wallet, address reserve) public {\r\n        uint feeAmount = reserveFeeToWallet[reserve][wallet];\r\n        require(feeAmount > 1);\r\n        reserveFeeToWallet[reserve][wallet] = 1; // leave 1 twei to avoid spikes in gas fee\r\n        require(knc.transferFrom(reserveKNCWallet[reserve], wallet, feeAmount - 1));\r\n\r\n        SendWalletFees(wallet, reserve, msg.sender);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Withdrawable"
    UserDefinedTypeName "Withdrawable"
       Source: "Withdrawable"
  InheritanceSpecifier
     Gas costs: 0
     Source: "FeeBurnerInterface"
    UserDefinedTypeName "FeeBurnerInterface"
       Source: "FeeBurnerInterface"
  VariableDeclaration "reserveFeesInBps"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address=>uint) public reserveFeesInBps"
    Mapping
       Source: "mapping(address=>uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "reserveKNCWallet"
     Type: mapping(address => address)
     Gas costs: 0
     Source: "mapping(address=>address) public reserveKNCWallet"
    Mapping
       Source: "mapping(address=>address)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "walletFeesInBps"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address=>uint) public walletFeesInBps"
    Mapping
       Source: "mapping(address=>uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "reserveFeeToBurn"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address=>uint) public reserveFeeToBurn"
    Mapping
       Source: "mapping(address=>uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "reserveFeeToWallet"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping(address=>mapping(address=>uint)) public reserveFeeToWallet"
    Mapping
       Source: "mapping(address=>mapping(address=>uint))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping(address=>uint)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "knc"
     Type: contract BurnableToken
     Gas costs: 0
     Source: "BurnableToken public knc"
    UserDefinedTypeName "BurnableToken"
       Source: "BurnableToken"
  VariableDeclaration "kyberNetwork"
     Type: address
     Gas costs: 0
     Source: "address public kyberNetwork"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "kncPerETHRate"
     Type: uint256
     Gas costs: 0
     Source: "uint public kncPerETHRate = 300"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 300
       Type: int_const 300
       Source: "300"
  FunctionDefinition "FeeBurner" - public
     Source: "function FeeBurner(address _admin, BurnableToken kncToken) public {\r\n        require(_admin != address(0));\r\n        require(kncToken != address(0));\r\n        admin = _admin;\r\n        knc = kncToken;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _admin, BurnableToken kncToken)"
      VariableDeclaration "_admin"
         Type: address
         Source: "address _admin"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "kncToken"
         Type: contract BurnableToken
         Source: "BurnableToken kncToken"
        UserDefinedTypeName "BurnableToken"
           Source: "BurnableToken"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(_admin != address(0));\r\n        require(kncToken != address(0));\r\n        admin = _admin;\r\n        knc = kncToken;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_admin != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_admin != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_admin != address(0)"
            Identifier _admin
               Type: address
               Source: "_admin"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(kncToken != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(kncToken != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "kncToken != address(0)"
            Identifier kncToken
               Type: contract BurnableToken
               Source: "kncToken"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "admin = _admin"
        Assignment using operator =
           Type: address
           Source: "admin = _admin"
          Identifier admin
             Type: address
             Source: "admin"
          Identifier _admin
             Type: address
             Source: "_admin"
      ExpressionStatement
         Gas costs: 0
         Source: "knc = kncToken"
        Assignment using operator =
           Type: contract BurnableToken
           Source: "knc = kncToken"
          Identifier knc
             Type: contract BurnableToken
             Source: "knc"
          Identifier kncToken
             Type: contract BurnableToken
             Source: "kncToken"
  FunctionDefinition "setReserveData" - public
     Source: "function setReserveData(address reserve, uint feesInBps, address kncWallet) public onlyAdmin {\r\n        require(feesInBps < 100); // make sure it is always < 1%\r\n        require(kncWallet != address(0));\r\n        reserveFeesInBps[reserve] = feesInBps;\r\n        reserveKNCWallet[reserve] = kncWallet;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address reserve, uint feesInBps, address kncWallet)"
      VariableDeclaration "reserve"
         Type: address
         Source: "address reserve"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "feesInBps"
         Type: uint256
         Source: "uint feesInBps"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "kncWallet"
         Type: address
         Source: "address kncWallet"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        require(feesInBps < 100); // make sure it is always < 1%\r\n        require(kncWallet != address(0));\r\n        reserveFeesInBps[reserve] = feesInBps;\r\n        reserveKNCWallet[reserve] = kncWallet;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(feesInBps < 100)"
        FunctionCall
           Type: tuple()
           Source: "require(feesInBps < 100)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "feesInBps < 100"
            Identifier feesInBps
               Type: uint256
               Source: "feesInBps"
            Literal, token: [no token] value: 100
               Type: int_const 100
               Source: "100"
      ExpressionStatement
         Gas costs: 0
         Source: "require(kncWallet != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(kncWallet != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "kncWallet != address(0)"
            Identifier kncWallet
               Type: address
               Source: "kncWallet"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "reserveFeesInBps[reserve] = feesInBps"
        Assignment using operator =
           Type: uint256
           Source: "reserveFeesInBps[reserve] = feesInBps"
          IndexAccess
             Type: uint256
             Source: "reserveFeesInBps[reserve]"
            Identifier reserveFeesInBps
               Type: mapping(address => uint256)
               Source: "reserveFeesInBps"
            Identifier reserve
               Type: address
               Source: "reserve"
          Identifier feesInBps
             Type: uint256
             Source: "feesInBps"
      ExpressionStatement
         Gas costs: 0
         Source: "reserveKNCWallet[reserve] = kncWallet"
        Assignment using operator =
           Type: address
           Source: "reserveKNCWallet[reserve] = kncWallet"
          IndexAccess
             Type: address
             Source: "reserveKNCWallet[reserve]"
            Identifier reserveKNCWallet
               Type: mapping(address => address)
               Source: "reserveKNCWallet"
            Identifier reserve
               Type: address
               Source: "reserve"
          Identifier kncWallet
             Type: address
             Source: "kncWallet"
  FunctionDefinition "setWalletFees" - public
     Source: "function setWalletFees(address wallet, uint feesInBps) public onlyAdmin {\r\n        require(feesInBps < 10000); // under 100%\r\n        walletFeesInBps[wallet] = feesInBps;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address wallet, uint feesInBps)"
      VariableDeclaration "wallet"
         Type: address
         Source: "address wallet"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "feesInBps"
         Type: uint256
         Source: "uint feesInBps"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        require(feesInBps < 10000); // under 100%\r\n        walletFeesInBps[wallet] = feesInBps;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(feesInBps < 10000)"
        FunctionCall
           Type: tuple()
           Source: "require(feesInBps < 10000)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "feesInBps < 10000"
            Identifier feesInBps
               Type: uint256
               Source: "feesInBps"
            Literal, token: [no token] value: 10000
               Type: int_const 10000
               Source: "10000"
      ExpressionStatement
         Gas costs: 0
         Source: "walletFeesInBps[wallet] = feesInBps"
        Assignment using operator =
           Type: uint256
           Source: "walletFeesInBps[wallet] = feesInBps"
          IndexAccess
             Type: uint256
             Source: "walletFeesInBps[wallet]"
            Identifier walletFeesInBps
               Type: mapping(address => uint256)
               Source: "walletFeesInBps"
            Identifier wallet
               Type: address
               Source: "wallet"
          Identifier feesInBps
             Type: uint256
             Source: "feesInBps"
  FunctionDefinition "setKyberNetwork" - public
     Source: "function setKyberNetwork(address _kyberNetwork) public onlyAdmin {\r\n        require(_kyberNetwork != address(0));\r\n        kyberNetwork = _kyberNetwork;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _kyberNetwork)"
      VariableDeclaration "_kyberNetwork"
         Type: address
         Source: "address _kyberNetwork"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        require(_kyberNetwork != address(0));\r\n        kyberNetwork = _kyberNetwork;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_kyberNetwork != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_kyberNetwork != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_kyberNetwork != address(0)"
            Identifier _kyberNetwork
               Type: address
               Source: "_kyberNetwork"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "kyberNetwork = _kyberNetwork"
        Assignment using operator =
           Type: address
           Source: "kyberNetwork = _kyberNetwork"
          Identifier kyberNetwork
             Type: address
             Source: "kyberNetwork"
          Identifier _kyberNetwork
             Type: address
             Source: "_kyberNetwork"
  FunctionDefinition "setKNCRate" - public
     Source: "function setKNCRate(uint rate) public onlyAdmin {\r\n        kncPerETHRate = rate;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint rate)"
      VariableDeclaration "rate"
         Type: uint256
         Source: "uint rate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        kncPerETHRate = rate;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "kncPerETHRate = rate"
        Assignment using operator =
           Type: uint256
           Source: "kncPerETHRate = rate"
          Identifier kncPerETHRate
             Type: uint256
             Source: "kncPerETHRate"
          Identifier rate
             Type: uint256
             Source: "rate"
  EventDefinition "AssignFeeToWallet"
     Gas costs: 0
     Source: "event AssignFeeToWallet(address reserve, address wallet, uint walletFee);"
    ParameterList
       Source: "(address reserve, address wallet, uint walletFee)"
      VariableDeclaration "reserve"
         Type: address
         Source: "address reserve"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "wallet"
         Type: address
         Source: "address wallet"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "walletFee"
         Type: uint256
         Source: "uint walletFee"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "AssignBurnFees"
     Gas costs: 0
     Source: "event AssignBurnFees(address reserve, uint burnFee);"
    ParameterList
       Source: "(address reserve, uint burnFee)"
      VariableDeclaration "reserve"
         Type: address
         Source: "address reserve"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "burnFee"
         Type: uint256
         Source: "uint burnFee"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "handleFees" - public
     Source: "function handleFees(uint tradeWeiAmount, address reserve, address wallet) public returns(bool) {\r\n        require(msg.sender == kyberNetwork);\r\n\r\n        uint kncAmount = tradeWeiAmount * kncPerETHRate;\r\n        uint fee = kncAmount * reserveFeesInBps[reserve] / 10000;\r\n\r\n        uint walletFee = fee * walletFeesInBps[wallet] / 10000;\r\n        require(fee >= walletFee);\r\n        uint feeToBurn = fee - walletFee;\r\n\r\n        if (walletFee > 0) {\r\n            reserveFeeToWallet[reserve][wallet] += walletFee;\r\n            AssignFeeToWallet(reserve, wallet, walletFee);\r\n        }\r\n\r\n        if (feeToBurn > 0) {\r\n            AssignBurnFees(reserve, feeToBurn);\r\n            reserveFeeToBurn[reserve] += feeToBurn;\r\n        }\r\n\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint tradeWeiAmount, address reserve, address wallet)"
      VariableDeclaration "tradeWeiAmount"
         Type: uint256
         Source: "uint tradeWeiAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "reserve"
         Type: address
         Source: "address reserve"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "wallet"
         Type: address
         Source: "address wallet"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require(msg.sender == kyberNetwork);\r\n\r\n        uint kncAmount = tradeWeiAmount * kncPerETHRate;\r\n        uint fee = kncAmount * reserveFeesInBps[reserve] / 10000;\r\n\r\n        uint walletFee = fee * walletFeesInBps[wallet] / 10000;\r\n        require(fee >= walletFee);\r\n        uint feeToBurn = fee - walletFee;\r\n\r\n        if (walletFee > 0) {\r\n            reserveFeeToWallet[reserve][wallet] += walletFee;\r\n            AssignFeeToWallet(reserve, wallet, walletFee);\r\n        }\r\n\r\n        if (feeToBurn > 0) {\r\n            AssignBurnFees(reserve, feeToBurn);\r\n            reserveFeeToBurn[reserve] += feeToBurn;\r\n        }\r\n\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.sender == kyberNetwork)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == kyberNetwork)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == kyberNetwork"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier kyberNetwork
               Type: address
               Source: "kyberNetwork"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint kncAmount = tradeWeiAmount * kncPerETHRate"
        VariableDeclaration "kncAmount"
           Type: uint256
           Source: "uint kncAmount"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "tradeWeiAmount * kncPerETHRate"
          Identifier tradeWeiAmount
             Type: uint256
             Source: "tradeWeiAmount"
          Identifier kncPerETHRate
             Type: uint256
             Source: "kncPerETHRate"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint fee = kncAmount * reserveFeesInBps[reserve] / 10000"
        VariableDeclaration "fee"
           Type: uint256
           Source: "uint fee"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "kncAmount * reserveFeesInBps[reserve] / 10000"
          BinaryOperation using operator *
             Type: uint256
             Source: "kncAmount * reserveFeesInBps[reserve]"
            Identifier kncAmount
               Type: uint256
               Source: "kncAmount"
            IndexAccess
               Type: uint256
               Source: "reserveFeesInBps[reserve]"
              Identifier reserveFeesInBps
                 Type: mapping(address => uint256)
                 Source: "reserveFeesInBps"
              Identifier reserve
                 Type: address
                 Source: "reserve"
          Literal, token: [no token] value: 10000
             Type: int_const 10000
             Source: "10000"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint walletFee = fee * walletFeesInBps[wallet] / 10000"
        VariableDeclaration "walletFee"
           Type: uint256
           Source: "uint walletFee"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "fee * walletFeesInBps[wallet] / 10000"
          BinaryOperation using operator *
             Type: uint256
             Source: "fee * walletFeesInBps[wallet]"
            Identifier fee
               Type: uint256
               Source: "fee"
            IndexAccess
               Type: uint256
               Source: "walletFeesInBps[wallet]"
              Identifier walletFeesInBps
                 Type: mapping(address => uint256)
                 Source: "walletFeesInBps"
              Identifier wallet
                 Type: address
                 Source: "wallet"
          Literal, token: [no token] value: 10000
             Type: int_const 10000
             Source: "10000"
      ExpressionStatement
         Gas costs: 0
         Source: "require(fee >= walletFee)"
        FunctionCall
           Type: tuple()
           Source: "require(fee >= walletFee)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "fee >= walletFee"
            Identifier fee
               Type: uint256
               Source: "fee"
            Identifier walletFee
               Type: uint256
               Source: "walletFee"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint feeToBurn = fee - walletFee"
        VariableDeclaration "feeToBurn"
           Type: uint256
           Source: "uint feeToBurn"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator -
           Type: uint256
           Source: "fee - walletFee"
          Identifier fee
             Type: uint256
             Source: "fee"
          Identifier walletFee
             Type: uint256
             Source: "walletFee"
      IfStatement
         Source: "if (walletFee > 0) {\r\n            reserveFeeToWallet[reserve][wallet] += walletFee;\r\n            AssignFeeToWallet(reserve, wallet, walletFee);\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "walletFee > 0"
          Identifier walletFee
             Type: uint256
             Source: "walletFee"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            reserveFeeToWallet[reserve][wallet] += walletFee;\r\n            AssignFeeToWallet(reserve, wallet, walletFee);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "reserveFeeToWallet[reserve][wallet] += walletFee"
            Assignment using operator +=
               Type: uint256
               Source: "reserveFeeToWallet[reserve][wallet] += walletFee"
              IndexAccess
                 Type: uint256
                 Source: "reserveFeeToWallet[reserve][wallet]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "reserveFeeToWallet[reserve]"
                  Identifier reserveFeeToWallet
                     Type: mapping(address => mapping(address => uint256))
                     Source: "reserveFeeToWallet"
                  Identifier reserve
                     Type: address
                     Source: "reserve"
                Identifier wallet
                   Type: address
                   Source: "wallet"
              Identifier walletFee
                 Type: uint256
                 Source: "walletFee"
          ExpressionStatement
             Gas costs: 0
             Source: "AssignFeeToWallet(reserve, wallet, walletFee)"
            FunctionCall
               Type: tuple()
               Source: "AssignFeeToWallet(reserve, wallet, walletFee)"
              Identifier AssignFeeToWallet
                 Type: function (address,address,uint256)
                 Source: "AssignFeeToWallet"
              Identifier reserve
                 Type: address
                 Source: "reserve"
              Identifier wallet
                 Type: address
                 Source: "wallet"
              Identifier walletFee
                 Type: uint256
                 Source: "walletFee"
      IfStatement
         Source: "if (feeToBurn > 0) {\r\n            AssignBurnFees(reserve, feeToBurn);\r\n            reserveFeeToBurn[reserve] += feeToBurn;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "feeToBurn > 0"
          Identifier feeToBurn
             Type: uint256
             Source: "feeToBurn"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            AssignBurnFees(reserve, feeToBurn);\r\n            reserveFeeToBurn[reserve] += feeToBurn;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "AssignBurnFees(reserve, feeToBurn)"
            FunctionCall
               Type: tuple()
               Source: "AssignBurnFees(reserve, feeToBurn)"
              Identifier AssignBurnFees
                 Type: function (address,uint256)
                 Source: "AssignBurnFees"
              Identifier reserve
                 Type: address
                 Source: "reserve"
              Identifier feeToBurn
                 Type: uint256
                 Source: "feeToBurn"
          ExpressionStatement
             Gas costs: 0
             Source: "reserveFeeToBurn[reserve] += feeToBurn"
            Assignment using operator +=
               Type: uint256
               Source: "reserveFeeToBurn[reserve] += feeToBurn"
              IndexAccess
                 Type: uint256
                 Source: "reserveFeeToBurn[reserve]"
                Identifier reserveFeeToBurn
                   Type: mapping(address => uint256)
                   Source: "reserveFeeToBurn"
                Identifier reserve
                   Type: address
                   Source: "reserve"
              Identifier feeToBurn
                 Type: uint256
                 Source: "feeToBurn"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  EventDefinition "BurnAssignedFees"
     Gas costs: 0
     Source: "event BurnAssignedFees(address indexed reserve, address sender);"
    ParameterList
       Source: "(address indexed reserve, address sender)"
      VariableDeclaration "reserve"
         Type: address
         Source: "address indexed reserve"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "burnReserveFees" - public
     Source: "function burnReserveFees(address reserve) public {\r\n        uint burnAmount = reserveFeeToBurn[reserve];\r\n        require(burnAmount > 1);\r\n        reserveFeeToBurn[reserve] = 1; // leave 1 twei to avoid spikes in gas fee\r\n        require(knc.burnFrom(reserveKNCWallet[reserve], burnAmount - 1));\r\n\r\n        BurnAssignedFees(reserve, msg.sender);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address reserve)"
      VariableDeclaration "reserve"
         Type: address
         Source: "address reserve"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint burnAmount = reserveFeeToBurn[reserve];\r\n        require(burnAmount > 1);\r\n        reserveFeeToBurn[reserve] = 1; // leave 1 twei to avoid spikes in gas fee\r\n        require(knc.burnFrom(reserveKNCWallet[reserve], burnAmount - 1));\r\n\r\n        BurnAssignedFees(reserve, msg.sender);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint burnAmount = reserveFeeToBurn[reserve]"
        VariableDeclaration "burnAmount"
           Type: uint256
           Source: "uint burnAmount"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "reserveFeeToBurn[reserve]"
          Identifier reserveFeeToBurn
             Type: mapping(address => uint256)
             Source: "reserveFeeToBurn"
          Identifier reserve
             Type: address
             Source: "reserve"
      ExpressionStatement
         Gas costs: 0
         Source: "require(burnAmount > 1)"
        FunctionCall
           Type: tuple()
           Source: "require(burnAmount > 1)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "burnAmount > 1"
            Identifier burnAmount
               Type: uint256
               Source: "burnAmount"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "reserveFeeToBurn[reserve] = 1"
        Assignment using operator =
           Type: uint256
           Source: "reserveFeeToBurn[reserve] = 1"
          IndexAccess
             Type: uint256
             Source: "reserveFeeToBurn[reserve]"
            Identifier reserveFeeToBurn
               Type: mapping(address => uint256)
               Source: "reserveFeeToBurn"
            Identifier reserve
               Type: address
               Source: "reserve"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "require(knc.burnFrom(reserveKNCWallet[reserve], burnAmount - 1))"
        FunctionCall
           Type: tuple()
           Source: "require(knc.burnFrom(reserveKNCWallet[reserve], burnAmount - 1))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "knc.burnFrom(reserveKNCWallet[reserve], burnAmount - 1)"
            MemberAccess to member burnFrom
               Type: function (address,uint256) external returns (bool)
               Source: "knc.burnFrom"
              Identifier knc
                 Type: contract BurnableToken
                 Source: "knc"
            IndexAccess
               Type: address
               Source: "reserveKNCWallet[reserve]"
              Identifier reserveKNCWallet
                 Type: mapping(address => address)
                 Source: "reserveKNCWallet"
              Identifier reserve
                 Type: address
                 Source: "reserve"
            BinaryOperation using operator -
               Type: uint256
               Source: "burnAmount - 1"
              Identifier burnAmount
                 Type: uint256
                 Source: "burnAmount"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "BurnAssignedFees(reserve, msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "BurnAssignedFees(reserve, msg.sender)"
          Identifier BurnAssignedFees
             Type: function (address,address)
             Source: "BurnAssignedFees"
          Identifier reserve
             Type: address
             Source: "reserve"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  EventDefinition "SendWalletFees"
     Gas costs: 0
     Source: "event SendWalletFees(address indexed wallet, address reserve, address sender);"
    ParameterList
       Source: "(address indexed wallet, address reserve, address sender)"
      VariableDeclaration "wallet"
         Type: address
         Source: "address indexed wallet"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "reserve"
         Type: address
         Source: "address reserve"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "sendFeeToWallet" - public
     Source: "function sendFeeToWallet(address wallet, address reserve) public {\r\n        uint feeAmount = reserveFeeToWallet[reserve][wallet];\r\n        require(feeAmount > 1);\r\n        reserveFeeToWallet[reserve][wallet] = 1; // leave 1 twei to avoid spikes in gas fee\r\n        require(knc.transferFrom(reserveKNCWallet[reserve], wallet, feeAmount - 1));\r\n\r\n        SendWalletFees(wallet, reserve, msg.sender);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address wallet, address reserve)"
      VariableDeclaration "wallet"
         Type: address
         Source: "address wallet"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "reserve"
         Type: address
         Source: "address reserve"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint feeAmount = reserveFeeToWallet[reserve][wallet];\r\n        require(feeAmount > 1);\r\n        reserveFeeToWallet[reserve][wallet] = 1; // leave 1 twei to avoid spikes in gas fee\r\n        require(knc.transferFrom(reserveKNCWallet[reserve], wallet, feeAmount - 1));\r\n\r\n        SendWalletFees(wallet, reserve, msg.sender);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint feeAmount = reserveFeeToWallet[reserve][wallet]"
        VariableDeclaration "feeAmount"
           Type: uint256
           Source: "uint feeAmount"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "reserveFeeToWallet[reserve][wallet]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "reserveFeeToWallet[reserve]"
            Identifier reserveFeeToWallet
               Type: mapping(address => mapping(address => uint256))
               Source: "reserveFeeToWallet"
            Identifier reserve
               Type: address
               Source: "reserve"
          Identifier wallet
             Type: address
             Source: "wallet"
      ExpressionStatement
         Gas costs: 0
         Source: "require(feeAmount > 1)"
        FunctionCall
           Type: tuple()
           Source: "require(feeAmount > 1)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "feeAmount > 1"
            Identifier feeAmount
               Type: uint256
               Source: "feeAmount"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "reserveFeeToWallet[reserve][wallet] = 1"
        Assignment using operator =
           Type: uint256
           Source: "reserveFeeToWallet[reserve][wallet] = 1"
          IndexAccess
             Type: uint256
             Source: "reserveFeeToWallet[reserve][wallet]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "reserveFeeToWallet[reserve]"
              Identifier reserveFeeToWallet
                 Type: mapping(address => mapping(address => uint256))
                 Source: "reserveFeeToWallet"
              Identifier reserve
                 Type: address
                 Source: "reserve"
            Identifier wallet
               Type: address
               Source: "wallet"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "require(knc.transferFrom(reserveKNCWallet[reserve], wallet, feeAmount - 1))"
        FunctionCall
           Type: tuple()
           Source: "require(knc.transferFrom(reserveKNCWallet[reserve], wallet, feeAmount - 1))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "knc.transferFrom(reserveKNCWallet[reserve], wallet, feeAmount - 1)"
            MemberAccess to member transferFrom
               Type: function (address,address,uint256) external returns (bool)
               Source: "knc.transferFrom"
              Identifier knc
                 Type: contract BurnableToken
                 Source: "knc"
            IndexAccess
               Type: address
               Source: "reserveKNCWallet[reserve]"
              Identifier reserveKNCWallet
                 Type: mapping(address => address)
                 Source: "reserveKNCWallet"
              Identifier reserve
                 Type: address
                 Source: "reserve"
            Identifier wallet
               Type: address
               Source: "wallet"
            BinaryOperation using operator -
               Type: uint256
               Source: "feeAmount - 1"
              Identifier feeAmount
                 Type: uint256
                 Source: "feeAmount"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "SendWalletFees(wallet, reserve, msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "SendWalletFees(wallet, reserve, msg.sender)"
          Identifier SendWalletFees
             Type: function (address,address,address)
             Source: "SendWalletFees"
          Identifier wallet
             Type: address
             Source: "wallet"
          Identifier reserve
             Type: address
             Source: "reserve"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
ContractDefinition "SanityRates"
   Source: "contract SanityRates is SanityRatesInterface, Withdrawable, Utils {\r\n    mapping(address=>uint) public tokenRate;\r\n    mapping(address=>uint) public reasonableDiffInBps;\r\n\r\n    function SanityRates(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }\r\n\r\n    function setReasonableDiff(ERC20[] srcs, uint[] diff) public onlyAdmin {\r\n        require(srcs.length == diff.length);\r\n        for (uint i = 0; i < srcs.length; i++) {\r\n            reasonableDiffInBps[srcs[i]] = diff[i];\r\n        }\r\n    }\r\n\r\n    function setSanityRates(ERC20[] srcs, uint[] rates) public onlyOperator {\r\n        require(srcs.length == rates.length);\r\n\r\n        for (uint i = 0; i < srcs.length; i++) {\r\n            tokenRate[srcs[i]] = rates[i];\r\n        }\r\n    }\r\n\r\n    function getSanityRate(ERC20 src, ERC20 dest) public view returns(uint) {\r\n        if (src != ETH_TOKEN_ADDRESS && dest != ETH_TOKEN_ADDRESS) return 0;\r\n\r\n        uint rate;\r\n        address token;\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            rate = (PRECISION*PRECISION)/tokenRate[dest];\r\n            token = dest;\r\n        } else {\r\n            rate = tokenRate[src];\r\n            token = src;\r\n        }\r\n\r\n        return rate * (10000 + reasonableDiffInBps[token])/10000;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SanityRatesInterface"
    UserDefinedTypeName "SanityRatesInterface"
       Source: "SanityRatesInterface"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Withdrawable"
    UserDefinedTypeName "Withdrawable"
       Source: "Withdrawable"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Utils"
    UserDefinedTypeName "Utils"
       Source: "Utils"
  VariableDeclaration "tokenRate"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address=>uint) public tokenRate"
    Mapping
       Source: "mapping(address=>uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "reasonableDiffInBps"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address=>uint) public reasonableDiffInBps"
    Mapping
       Source: "mapping(address=>uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  FunctionDefinition "SanityRates" - public
     Source: "function SanityRates(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _admin)"
      VariableDeclaration "_admin"
         Type: address
         Source: "address _admin"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_admin != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_admin != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_admin != address(0)"
            Identifier _admin
               Type: address
               Source: "_admin"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "admin = _admin"
        Assignment using operator =
           Type: address
           Source: "admin = _admin"
          Identifier admin
             Type: address
             Source: "admin"
          Identifier _admin
             Type: address
             Source: "_admin"
  FunctionDefinition "setReasonableDiff" - public
     Source: "function setReasonableDiff(ERC20[] srcs, uint[] diff) public onlyAdmin {\r\n        require(srcs.length == diff.length);\r\n        for (uint i = 0; i < srcs.length; i++) {\r\n            reasonableDiffInBps[srcs[i]] = diff[i];\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20[] srcs, uint[] diff)"
      VariableDeclaration "srcs"
         Type: contract ERC20[] memory
         Source: "ERC20[] srcs"
        ArrayTypeName
           Source: "ERC20[]"
          UserDefinedTypeName "ERC20"
             Source: "ERC20"
      VariableDeclaration "diff"
         Type: uint256[] memory
         Source: "uint[] diff"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAdmin"
       Gas costs: 0
       Source: "onlyAdmin"
      Identifier onlyAdmin
         Type: modifier ()
         Source: "onlyAdmin"
    Block
       Source: "{\r\n        require(srcs.length == diff.length);\r\n        for (uint i = 0; i < srcs.length; i++) {\r\n            reasonableDiffInBps[srcs[i]] = diff[i];\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(srcs.length == diff.length)"
        FunctionCall
           Type: tuple()
           Source: "require(srcs.length == diff.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "srcs.length == diff.length"
            MemberAccess to member length
               Type: uint256
               Source: "srcs.length"
              Identifier srcs
                 Type: contract ERC20[] memory
                 Source: "srcs"
            MemberAccess to member length
               Type: uint256
               Source: "diff.length"
              Identifier diff
                 Type: uint256[] memory
                 Source: "diff"
      ForStatement
         Source: "for (uint i = 0; i < srcs.length; i++) {\r\n            reasonableDiffInBps[srcs[i]] = diff[i];\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < srcs.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "srcs.length"
            Identifier srcs
               Type: contract ERC20[] memory
               Source: "srcs"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            reasonableDiffInBps[srcs[i]] = diff[i];\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "reasonableDiffInBps[srcs[i]] = diff[i]"
            Assignment using operator =
               Type: uint256
               Source: "reasonableDiffInBps[srcs[i]] = diff[i]"
              IndexAccess
                 Type: uint256
                 Source: "reasonableDiffInBps[srcs[i]]"
                Identifier reasonableDiffInBps
                   Type: mapping(address => uint256)
                   Source: "reasonableDiffInBps"
                IndexAccess
                   Type: contract ERC20
                   Source: "srcs[i]"
                  Identifier srcs
                     Type: contract ERC20[] memory
                     Source: "srcs"
                  Identifier i
                     Type: uint256
                     Source: "i"
              IndexAccess
                 Type: uint256
                 Source: "diff[i]"
                Identifier diff
                   Type: uint256[] memory
                   Source: "diff"
                Identifier i
                   Type: uint256
                   Source: "i"
  FunctionDefinition "setSanityRates" - public
     Source: "function setSanityRates(ERC20[] srcs, uint[] rates) public onlyOperator {\r\n        require(srcs.length == rates.length);\r\n\r\n        for (uint i = 0; i < srcs.length; i++) {\r\n            tokenRate[srcs[i]] = rates[i];\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20[] srcs, uint[] rates)"
      VariableDeclaration "srcs"
         Type: contract ERC20[] memory
         Source: "ERC20[] srcs"
        ArrayTypeName
           Source: "ERC20[]"
          UserDefinedTypeName "ERC20"
             Source: "ERC20"
      VariableDeclaration "rates"
         Type: uint256[] memory
         Source: "uint[] rates"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOperator"
       Gas costs: 0
       Source: "onlyOperator"
      Identifier onlyOperator
         Type: modifier ()
         Source: "onlyOperator"
    Block
       Source: "{\r\n        require(srcs.length == rates.length);\r\n\r\n        for (uint i = 0; i < srcs.length; i++) {\r\n            tokenRate[srcs[i]] = rates[i];\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(srcs.length == rates.length)"
        FunctionCall
           Type: tuple()
           Source: "require(srcs.length == rates.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "srcs.length == rates.length"
            MemberAccess to member length
               Type: uint256
               Source: "srcs.length"
              Identifier srcs
                 Type: contract ERC20[] memory
                 Source: "srcs"
            MemberAccess to member length
               Type: uint256
               Source: "rates.length"
              Identifier rates
                 Type: uint256[] memory
                 Source: "rates"
      ForStatement
         Source: "for (uint i = 0; i < srcs.length; i++) {\r\n            tokenRate[srcs[i]] = rates[i];\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < srcs.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "srcs.length"
            Identifier srcs
               Type: contract ERC20[] memory
               Source: "srcs"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            tokenRate[srcs[i]] = rates[i];\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "tokenRate[srcs[i]] = rates[i]"
            Assignment using operator =
               Type: uint256
               Source: "tokenRate[srcs[i]] = rates[i]"
              IndexAccess
                 Type: uint256
                 Source: "tokenRate[srcs[i]]"
                Identifier tokenRate
                   Type: mapping(address => uint256)
                   Source: "tokenRate"
                IndexAccess
                   Type: contract ERC20
                   Source: "srcs[i]"
                  Identifier srcs
                     Type: contract ERC20[] memory
                     Source: "srcs"
                  Identifier i
                     Type: uint256
                     Source: "i"
              IndexAccess
                 Type: uint256
                 Source: "rates[i]"
                Identifier rates
                   Type: uint256[] memory
                   Source: "rates"
                Identifier i
                   Type: uint256
                   Source: "i"
  FunctionDefinition "getSanityRate" - public - const
     Source: "function getSanityRate(ERC20 src, ERC20 dest) public view returns(uint) {\r\n        if (src != ETH_TOKEN_ADDRESS && dest != ETH_TOKEN_ADDRESS) return 0;\r\n\r\n        uint rate;\r\n        address token;\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            rate = (PRECISION*PRECISION)/tokenRate[dest];\r\n            token = dest;\r\n        } else {\r\n            rate = tokenRate[src];\r\n            token = src;\r\n        }\r\n\r\n        return rate * (10000 + reasonableDiffInBps[token])/10000;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ERC20 src, ERC20 dest)"
      VariableDeclaration "src"
         Type: contract ERC20
         Source: "ERC20 src"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
      VariableDeclaration "dest"
         Type: contract ERC20
         Source: "ERC20 dest"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (src != ETH_TOKEN_ADDRESS && dest != ETH_TOKEN_ADDRESS) return 0;\r\n\r\n        uint rate;\r\n        address token;\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            rate = (PRECISION*PRECISION)/tokenRate[dest];\r\n            token = dest;\r\n        } else {\r\n            rate = tokenRate[src];\r\n            token = src;\r\n        }\r\n\r\n        return rate * (10000 + reasonableDiffInBps[token])/10000;\r\n    }"
      IfStatement
         Source: "if (src != ETH_TOKEN_ADDRESS && dest != ETH_TOKEN_ADDRESS) return 0"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "src != ETH_TOKEN_ADDRESS && dest != ETH_TOKEN_ADDRESS"
          BinaryOperation using operator !=
             Type: bool
             Source: "src != ETH_TOKEN_ADDRESS"
            Identifier src
               Type: contract ERC20
               Source: "src"
            Identifier ETH_TOKEN_ADDRESS
               Type: contract ERC20
               Source: "ETH_TOKEN_ADDRESS"
          BinaryOperation using operator !=
             Type: bool
             Source: "dest != ETH_TOKEN_ADDRESS"
            Identifier dest
               Type: contract ERC20
               Source: "dest"
            Identifier ETH_TOKEN_ADDRESS
               Type: contract ERC20
               Source: "ETH_TOKEN_ADDRESS"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint rate"
        VariableDeclaration "rate"
           Type: uint256
           Source: "uint rate"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "address token"
        VariableDeclaration "token"
           Type: address
           Source: "address token"
          ElementaryTypeName address
             Source: "address"
      IfStatement
         Source: "if (src == ETH_TOKEN_ADDRESS) {\r\n            rate = (PRECISION*PRECISION)/tokenRate[dest];\r\n            token = dest;\r\n        } else {\r\n            rate = tokenRate[src];\r\n            token = src;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "src == ETH_TOKEN_ADDRESS"
          Identifier src
             Type: contract ERC20
             Source: "src"
          Identifier ETH_TOKEN_ADDRESS
             Type: contract ERC20
             Source: "ETH_TOKEN_ADDRESS"
        Block
           Source: "{\r\n            rate = (PRECISION*PRECISION)/tokenRate[dest];\r\n            token = dest;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "rate = (PRECISION*PRECISION)/tokenRate[dest]"
            Assignment using operator =
               Type: uint256
               Source: "rate = (PRECISION*PRECISION)/tokenRate[dest]"
              Identifier rate
                 Type: uint256
                 Source: "rate"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "(PRECISION*PRECISION)/tokenRate[dest]"
                TupleExpression
                   Type: uint256
                   Source: "(PRECISION*PRECISION)"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "PRECISION*PRECISION"
                    Identifier PRECISION
                       Type: uint256
                       Source: "PRECISION"
                    Identifier PRECISION
                       Type: uint256
                       Source: "PRECISION"
                IndexAccess
                   Type: uint256
                   Source: "tokenRate[dest]"
                  Identifier tokenRate
                     Type: mapping(address => uint256)
                     Source: "tokenRate"
                  Identifier dest
                     Type: contract ERC20
                     Source: "dest"
          ExpressionStatement
             Gas costs: 0
             Source: "token = dest"
            Assignment using operator =
               Type: address
               Source: "token = dest"
              Identifier token
                 Type: address
                 Source: "token"
              Identifier dest
                 Type: contract ERC20
                 Source: "dest"
        Block
           Source: "{\r\n            rate = tokenRate[src];\r\n            token = src;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "rate = tokenRate[src]"
            Assignment using operator =
               Type: uint256
               Source: "rate = tokenRate[src]"
              Identifier rate
                 Type: uint256
                 Source: "rate"
              IndexAccess
                 Type: uint256
                 Source: "tokenRate[src]"
                Identifier tokenRate
                   Type: mapping(address => uint256)
                   Source: "tokenRate"
                Identifier src
                   Type: contract ERC20
                   Source: "src"
          ExpressionStatement
             Gas costs: 0
             Source: "token = src"
            Assignment using operator =
               Type: address
               Source: "token = src"
              Identifier token
                 Type: address
                 Source: "token"
              Identifier src
                 Type: contract ERC20
                 Source: "src"
      Return
         Gas costs: 0
         Source: "return rate * (10000 + reasonableDiffInBps[token])/10000"
        BinaryOperation using operator /
           Type: uint256
           Source: "rate * (10000 + reasonableDiffInBps[token])/10000"
          BinaryOperation using operator *
             Type: uint256
             Source: "rate * (10000 + reasonableDiffInBps[token])"
            Identifier rate
               Type: uint256
               Source: "rate"
            TupleExpression
               Type: uint256
               Source: "(10000 + reasonableDiffInBps[token])"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "10000 + reasonableDiffInBps[token]"
                Literal, token: [no token] value: 10000
                   Type: int_const 10000
                   Source: "10000"
                IndexAccess
                   Type: uint256
                   Source: "reasonableDiffInBps[token]"
                  Identifier reasonableDiffInBps
                     Type: mapping(address => uint256)
                     Source: "reasonableDiffInBps"
                  Identifier token
                     Type: address
                     Source: "token"
          Literal, token: [no token] value: 10000
             Type: int_const 10000
             Source: "10000"
ContractDefinition "Wrapper"
   Source: "contract Wrapper is Utils {\r\n\r\n    function getBalances(address reserve, ERC20[] tokens) public view returns(uint[]) {\r\n        uint[] memory result = new uint[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            uint balance = 0;\r\n            if (tokens[i] == ETH_TOKEN_ADDRESS) {\r\n                balance = reserve.balance;\r\n            } else {\r\n                balance = tokens[i].balanceOf(reserve);\r\n            }\r\n\r\n            result[i] = balance;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function getByteFromBytes14(bytes14 x, uint byteInd) public pure returns(byte) {\r\n        require(byteInd <= 13);\r\n        return x[byteInd];\r\n    }\r\n\r\n    function getInt8FromByte(bytes14 x, uint byteInd) public pure returns(int8) {\r\n        require(byteInd <= 13);\r\n        return int8(x[byteInd]);\r\n    }\r\n\r\n//    struct TokenRatesCompactData {\r\n//        bytes14 buy;  // change buy rate of token from baseBuyRate in 10 bps\r\n//        bytes14 sell; // change sell rate of token from baseSellRate in 10 bps\r\n//\r\n//        uint32 blockNumber;\r\n//    }\r\n//\r\n//    function getDataFromCompact(TokenRatesCompactData compact, uint byteInd) public pure\r\n//        returns(int8 buyByte, int8 sellByte, uint blockNumber)\r\n//    {\r\n//        blockNumber = uint(compact.blockNumber);\r\n////        return (compact.buy[byteInd], compact.sell[byteInd], uint(compact.blockNumber));\r\n//    }\r\n\r\n    function getCompactData(ConversionRates ratesContract, ERC20 token) internal view returns(int8,int8,uint) {\r\n        uint bulkIndex; uint index; byte buy; byte sell; uint updateBlock;\r\n        (bulkIndex, index, buy, sell) = ratesContract.getCompactData(token);\r\n        updateBlock = ratesContract.getRateUpdateBlock(token);\r\n\r\n        return (int8(buy), int8(sell), updateBlock);\r\n    }\r\n\r\n    function getTokenRates(ConversionRates ratesContract, ERC20[] tokenList)\r\n        public view\r\n        returns(uint[], uint[], int8[], int8[], uint[])\r\n    {\r\n        uint[] memory buyBases = new uint[](tokenList.length);\r\n        uint[] memory sellBases = new uint[](tokenList.length);\r\n        int8[] memory compactBuy = new int8[](tokenList.length);\r\n        int8[] memory compactSell = new int8[](tokenList.length);\r\n        uint[] memory updateBlock = new uint[](tokenList.length);\r\n\r\n        for (uint i = 0;  i < tokenList.length; i++) {\r\n            buyBases[i] = ratesContract.getBasicRate(tokenList[i], true);\r\n            sellBases[i] = ratesContract.getBasicRate(tokenList[i], false);\r\n\r\n            (compactBuy[i], compactSell[i], updateBlock[i]) = getCompactData(ratesContract, tokenList[i]);\r\n        }\r\n\r\n        return (buyBases, sellBases, compactBuy, compactSell, updateBlock);\r\n    }\r\n\r\n    function getTokenIndicies(ConversionRates ratesContract, ERC20[] tokenList) public view returns(uint[], uint[]) {\r\n        uint[] memory bulkIndices = new uint[](tokenList.length);\r\n        uint[] memory tokenIndexInBulk = new uint[](tokenList.length);\r\n\r\n        for (uint i = 0; i < tokenList.length; i++) {\r\n            uint bulkIndex; uint index; byte buy; byte sell;\r\n            (bulkIndex, index, buy, sell) = ratesContract.getCompactData(tokenList[i]);\r\n\r\n            bulkIndices[i] = bulkIndex;\r\n            tokenIndexInBulk[i] = index;\r\n        }\r\n\r\n        return (bulkIndices,tokenIndexInBulk);\r\n    }\r\n\r\n\r\n    function getExpectedRates( KyberNetwork network, ERC20[] srcs, ERC20[] dests, uint[] qty )\r\n        public view returns(uint[], uint[])\r\n    {\r\n        require( srcs.length == dests.length );\r\n        require( srcs.length == qty.length );\r\n\r\n        uint[] memory rates = new uint[](srcs.length);\r\n        uint[] memory slippage = new uint[](srcs.length);\r\n        for ( uint i = 0; i < srcs.length; i++ ) {\r\n            (rates[i],slippage[i]) = network.getExpectedRate(srcs[i],dests[i],qty[i]);\r\n        }\r\n\r\n        return (rates, slippage);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Utils"
    UserDefinedTypeName "Utils"
       Source: "Utils"
  FunctionDefinition "getBalances" - public - const
     Source: "function getBalances(address reserve, ERC20[] tokens) public view returns(uint[]) {\r\n        uint[] memory result = new uint[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            uint balance = 0;\r\n            if (tokens[i] == ETH_TOKEN_ADDRESS) {\r\n                balance = reserve.balance;\r\n            } else {\r\n                balance = tokens[i].balanceOf(reserve);\r\n            }\r\n\r\n            result[i] = balance;\r\n        }\r\n\r\n        return result;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address reserve, ERC20[] tokens)"
      VariableDeclaration "reserve"
         Type: address
         Source: "address reserve"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "tokens"
         Type: contract ERC20[] memory
         Source: "ERC20[] tokens"
        ArrayTypeName
           Source: "ERC20[]"
          UserDefinedTypeName "ERC20"
             Source: "ERC20"
    ParameterList
       Gas costs: 3
       Source: "(uint[])"
      VariableDeclaration ""
         Type: uint256[] memory
         Source: "uint[]"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    Block
       Source: "{\r\n        uint[] memory result = new uint[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            uint balance = 0;\r\n            if (tokens[i] == ETH_TOKEN_ADDRESS) {\r\n                balance = reserve.balance;\r\n            } else {\r\n                balance = tokens[i].balanceOf(reserve);\r\n            }\r\n\r\n            result[i] = balance;\r\n        }\r\n\r\n        return result;\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint[] memory result = new uint[](tokens.length)"
        VariableDeclaration "result"
           Type: uint256[] memory
           Source: "uint[] memory result"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](tokens.length)"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          MemberAccess to member length
             Type: uint256
             Source: "tokens.length"
            Identifier tokens
               Type: contract ERC20[] memory
               Source: "tokens"
      ForStatement
         Source: "for (uint i = 0; i < tokens.length; i++) {\r\n            uint balance = 0;\r\n            if (tokens[i] == ETH_TOKEN_ADDRESS) {\r\n                balance = reserve.balance;\r\n            } else {\r\n                balance = tokens[i].balanceOf(reserve);\r\n            }\r\n\r\n            result[i] = balance;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 27
           Source: "i < tokens.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "tokens.length"
            Identifier tokens
               Type: contract ERC20[] memory
               Source: "tokens"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            uint balance = 0;\r\n            if (tokens[i] == ETH_TOKEN_ADDRESS) {\r\n                balance = reserve.balance;\r\n            } else {\r\n                balance = tokens[i].balanceOf(reserve);\r\n            }\r\n\r\n            result[i] = balance;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 11
             Source: "uint balance = 0"
            VariableDeclaration "balance"
               Type: uint256
               Source: "uint balance"
              ElementaryTypeName uint
                 Source: "uint"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IfStatement
             Source: "if (tokens[i] == ETH_TOKEN_ADDRESS) {\r\n                balance = reserve.balance;\r\n            } else {\r\n                balance = tokens[i].balanceOf(reserve);\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: [???]
               Source: "tokens[i] == ETH_TOKEN_ADDRESS"
              IndexAccess
                 Type: contract ERC20
                 Source: "tokens[i]"
                Identifier tokens
                   Type: contract ERC20[] memory
                   Source: "tokens"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier ETH_TOKEN_ADDRESS
                 Type: contract ERC20
                 Source: "ETH_TOKEN_ADDRESS"
            Block
               Source: "{\r\n                balance = reserve.balance;\r\n            }"
              ExpressionStatement
                 Gas costs: 414
                 Source: "balance = reserve.balance"
                Assignment using operator =
                   Type: uint256
                   Source: "balance = reserve.balance"
                  Identifier balance
                     Type: uint256
                     Source: "balance"
                  MemberAccess to member balance
                     Type: uint256
                     Source: "reserve.balance"
                    Identifier reserve
                       Type: address
                       Source: "reserve"
            Block
               Source: "{\r\n                balance = tokens[i].balanceOf(reserve);\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "balance = tokens[i].balanceOf(reserve)"
                Assignment using operator =
                   Type: uint256
                   Source: "balance = tokens[i].balanceOf(reserve)"
                  Identifier balance
                     Type: uint256
                     Source: "balance"
                  FunctionCall
                     Type: uint256
                     Source: "tokens[i].balanceOf(reserve)"
                    MemberAccess to member balanceOf
                       Type: function (address) view external returns (uint256)
                       Source: "tokens[i].balanceOf"
                      IndexAccess
                         Type: contract ERC20
                         Source: "tokens[i]"
                        Identifier tokens
                           Type: contract ERC20[] memory
                           Source: "tokens"
                        Identifier i
                           Type: uint256
                           Source: "i"
                    Identifier reserve
                       Type: address
                       Source: "reserve"
          ExpressionStatement
             Gas costs: [???]
             Source: "result[i] = balance"
            Assignment using operator =
               Type: uint256
               Source: "result[i] = balance"
              IndexAccess
                 Type: uint256
                 Source: "result[i]"
                Identifier result
                   Type: uint256[] memory
                   Source: "result"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier balance
                 Type: uint256
                 Source: "balance"
      Return
         Gas costs: 8
         Source: "return result"
        Identifier result
           Type: uint256[] memory
           Source: "result"
  FunctionDefinition "getByteFromBytes14" - public
     Source: "function getByteFromBytes14(bytes14 x, uint byteInd) public pure returns(byte) {\r\n        require(byteInd <= 13);\r\n        return x[byteInd];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes14 x, uint byteInd)"
      VariableDeclaration "x"
         Type: bytes14
         Source: "bytes14 x"
        ElementaryTypeName bytes14
           Source: "bytes14"
      VariableDeclaration "byteInd"
         Type: uint256
         Source: "uint byteInd"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(byte)"
      VariableDeclaration ""
         Type: bytes1
         Source: "byte"
        ElementaryTypeName byte
           Source: "byte"
    Block
       Source: "{\r\n        require(byteInd <= 13);\r\n        return x[byteInd];\r\n    }"
      ExpressionStatement
         Gas costs: 38
         Source: "require(byteInd <= 13)"
        FunctionCall
           Type: tuple()
           Source: "require(byteInd <= 13)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "byteInd <= 13"
            Identifier byteInd
               Type: uint256
               Source: "byteInd"
            Literal, token: [no token] value: 13
               Type: int_const 13
               Source: "13"
      Return
         Gas costs: 51
         Source: "return x[byteInd]"
        IndexAccess
           Type: bytes1
           Source: "x[byteInd]"
          Identifier x
             Type: bytes14
             Source: "x"
          Identifier byteInd
             Type: uint256
             Source: "byteInd"
  FunctionDefinition "getInt8FromByte" - public
     Source: "function getInt8FromByte(bytes14 x, uint byteInd) public pure returns(int8) {\r\n        require(byteInd <= 13);\r\n        return int8(x[byteInd]);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes14 x, uint byteInd)"
      VariableDeclaration "x"
         Type: bytes14
         Source: "bytes14 x"
        ElementaryTypeName bytes14
           Source: "bytes14"
      VariableDeclaration "byteInd"
         Type: uint256
         Source: "uint byteInd"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(int8)"
      VariableDeclaration ""
         Type: int8
         Source: "int8"
        ElementaryTypeName int8
           Source: "int8"
    Block
       Source: "{\r\n        require(byteInd <= 13);\r\n        return int8(x[byteInd]);\r\n    }"
      ExpressionStatement
         Gas costs: 38
         Source: "require(byteInd <= 13)"
        FunctionCall
           Type: tuple()
           Source: "require(byteInd <= 13)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "byteInd <= 13"
            Identifier byteInd
               Type: uint256
               Source: "byteInd"
            Literal, token: [no token] value: 13
               Type: int_const 13
               Source: "13"
      Return
         Gas costs: 62
         Source: "return int8(x[byteInd])"
        FunctionCall
           Type: int8
           Source: "int8(x[byteInd])"
          ElementaryTypeNameExpression int8
             Type: type(int8)
             Source: "int8"
          IndexAccess
             Type: bytes1
             Source: "x[byteInd]"
            Identifier x
               Type: bytes14
               Source: "x"
            Identifier byteInd
               Type: uint256
               Source: "byteInd"
  FunctionDefinition "getCompactData" - const
     Source: "function getCompactData(ConversionRates ratesContract, ERC20 token) internal view returns(int8,int8,uint) {\r\n        uint bulkIndex; uint index; byte buy; byte sell; uint updateBlock;\r\n        (bulkIndex, index, buy, sell) = ratesContract.getCompactData(token);\r\n        updateBlock = ratesContract.getRateUpdateBlock(token);\r\n\r\n        return (int8(buy), int8(sell), updateBlock);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ConversionRates ratesContract, ERC20 token)"
      VariableDeclaration "ratesContract"
         Type: contract ConversionRates
         Source: "ConversionRates ratesContract"
        UserDefinedTypeName "ConversionRates"
           Source: "ConversionRates"
      VariableDeclaration "token"
         Type: contract ERC20
         Source: "ERC20 token"
        UserDefinedTypeName "ERC20"
           Source: "ERC20"
    ParameterList
       Gas costs: 9
       Source: "(int8,int8,uint)"
      VariableDeclaration ""
         Type: int8
         Source: "int8"
        ElementaryTypeName int8
           Source: "int8"
      VariableDeclaration ""
         Type: int8
         Source: "int8"
        ElementaryTypeName int8
           Source: "int8"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint bulkIndex; uint index; byte buy; byte sell; uint updateBlock;\r\n        (bulkIndex, index, buy, sell) = ratesContract.getCompactData(token);\r\n        updateBlock = ratesContract.getRateUpdateBlock(token);\r\n\r\n        return (int8(buy), int8(sell), updateBlock);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint bulkIndex"
        VariableDeclaration "bulkIndex"
           Type: uint256
           Source: "uint bulkIndex"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint index"
        VariableDeclaration "index"
           Type: uint256
           Source: "uint index"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "byte buy"
        VariableDeclaration "buy"
           Type: bytes1
           Source: "byte buy"
          ElementaryTypeName byte
             Source: "byte"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "byte sell"
        VariableDeclaration "sell"
           Type: bytes1
           Source: "byte sell"
          ElementaryTypeName byte
             Source: "byte"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint updateBlock"
        VariableDeclaration "updateBlock"
           Type: uint256
           Source: "uint updateBlock"
          ElementaryTypeName uint
             Source: "uint"
      ExpressionStatement
         Gas costs: [???]
         Source: "(bulkIndex, index, buy, sell) = ratesContract.getCompactData(token)"
        Assignment using operator =
           Type: tuple()
           Source: "(bulkIndex, index, buy, sell) = ratesContract.getCompactData(token)"
          TupleExpression
             Type: tuple(uint256,uint256,bytes1,bytes1)
             Source: "(bulkIndex, index, buy, sell)"
            Identifier bulkIndex
               Type: uint256
               Source: "bulkIndex"
            Identifier index
               Type: uint256
               Source: "index"
            Identifier buy
               Type: bytes1
               Source: "buy"
            Identifier sell
               Type: bytes1
               Source: "sell"
          FunctionCall
             Type: tuple(uint256,uint256,bytes1,bytes1)
             Source: "ratesContract.getCompactData(token)"
            MemberAccess to member getCompactData
               Type: function (contract ERC20) view external returns (uint256,uint256,bytes1,bytes1)
               Source: "ratesContract.getCompactData"
              Identifier ratesContract
                 Type: contract ConversionRates
                 Source: "ratesContract"
            Identifier token
               Type: contract ERC20
               Source: "token"
      ExpressionStatement
         Gas costs: [???]
         Source: "updateBlock = ratesContract.getRateUpdateBlock(token)"
        Assignment using operator =
           Type: uint256
           Source: "updateBlock = ratesContract.getRateUpdateBlock(token)"
          Identifier updateBlock
             Type: uint256
             Source: "updateBlock"
          FunctionCall
             Type: uint256
             Source: "ratesContract.getRateUpdateBlock(token)"
            MemberAccess to member getRateUpdateBlock
               Type: function (contract ERC20) view external returns (uint256)
               Source: "ratesContract.getRateUpdateBlock"
              Identifier ratesContract
                 Type: contract ConversionRates
                 Source: "ratesContract"
            Identifier token
               Type: contract ERC20
               Source: "token"
      Return
         Gas costs: 46
         Source: "return (int8(buy), int8(sell), updateBlock)"
        TupleExpression
           Type: tuple(int8,int8,uint256)
           Source: "(int8(buy), int8(sell), updateBlock)"
          FunctionCall
             Type: int8
             Source: "int8(buy)"
            ElementaryTypeNameExpression int8
               Type: type(int8)
               Source: "int8"
            Identifier buy
               Type: bytes1
               Source: "buy"
          FunctionCall
             Type: int8
             Source: "int8(sell)"
            ElementaryTypeNameExpression int8
               Type: type(int8)
               Source: "int8"
            Identifier sell
               Type: bytes1
               Source: "sell"
          Identifier updateBlock
             Type: uint256
             Source: "updateBlock"
  FunctionDefinition "getTokenRates" - public - const
     Source: "function getTokenRates(ConversionRates ratesContract, ERC20[] tokenList)\r\n        public view\r\n        returns(uint[], uint[], int8[], int8[], uint[])\r\n    {\r\n        uint[] memory buyBases = new uint[](tokenList.length);\r\n        uint[] memory sellBases = new uint[](tokenList.length);\r\n        int8[] memory compactBuy = new int8[](tokenList.length);\r\n        int8[] memory compactSell = new int8[](tokenList.length);\r\n        uint[] memory updateBlock = new uint[](tokenList.length);\r\n\r\n        for (uint i = 0;  i < tokenList.length; i++) {\r\n            buyBases[i] = ratesContract.getBasicRate(tokenList[i], true);\r\n            sellBases[i] = ratesContract.getBasicRate(tokenList[i], false);\r\n\r\n            (compactBuy[i], compactSell[i], updateBlock[i]) = getCompactData(ratesContract, tokenList[i]);\r\n        }\r\n\r\n        return (buyBases, sellBases, compactBuy, compactSell, updateBlock);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ConversionRates ratesContract, ERC20[] tokenList)"
      VariableDeclaration "ratesContract"
         Type: contract ConversionRates
         Source: "ConversionRates ratesContract"
        UserDefinedTypeName "ConversionRates"
           Source: "ConversionRates"
      VariableDeclaration "tokenList"
         Type: contract ERC20[] memory
         Source: "ERC20[] tokenList"
        ArrayTypeName
           Source: "ERC20[]"
          UserDefinedTypeName "ERC20"
             Source: "ERC20"
    ParameterList
       Gas costs: 15
       Source: "(uint[], uint[], int8[], int8[], uint[])"
      VariableDeclaration ""
         Type: uint256[] memory
         Source: "uint[]"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclaration ""
         Type: uint256[] memory
         Source: "uint[]"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclaration ""
         Type: int8[] memory
         Source: "int8[]"
        ArrayTypeName
           Source: "int8[]"
          ElementaryTypeName int8
             Source: "int8"
      VariableDeclaration ""
         Type: int8[] memory
         Source: "int8[]"
        ArrayTypeName
           Source: "int8[]"
          ElementaryTypeName int8
             Source: "int8"
      VariableDeclaration ""
         Type: uint256[] memory
         Source: "uint[]"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    Block
       Source: "{\r\n        uint[] memory buyBases = new uint[](tokenList.length);\r\n        uint[] memory sellBases = new uint[](tokenList.length);\r\n        int8[] memory compactBuy = new int8[](tokenList.length);\r\n        int8[] memory compactSell = new int8[](tokenList.length);\r\n        uint[] memory updateBlock = new uint[](tokenList.length);\r\n\r\n        for (uint i = 0;  i < tokenList.length; i++) {\r\n            buyBases[i] = ratesContract.getBasicRate(tokenList[i], true);\r\n            sellBases[i] = ratesContract.getBasicRate(tokenList[i], false);\r\n\r\n            (compactBuy[i], compactSell[i], updateBlock[i]) = getCompactData(ratesContract, tokenList[i]);\r\n        }\r\n\r\n        return (buyBases, sellBases, compactBuy, compactSell, updateBlock);\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint[] memory buyBases = new uint[](tokenList.length)"
        VariableDeclaration "buyBases"
           Type: uint256[] memory
           Source: "uint[] memory buyBases"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](tokenList.length)"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          MemberAccess to member length
             Type: uint256
             Source: "tokenList.length"
            Identifier tokenList
               Type: contract ERC20[] memory
               Source: "tokenList"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint[] memory sellBases = new uint[](tokenList.length)"
        VariableDeclaration "sellBases"
           Type: uint256[] memory
           Source: "uint[] memory sellBases"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](tokenList.length)"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          MemberAccess to member length
             Type: uint256
             Source: "tokenList.length"
            Identifier tokenList
               Type: contract ERC20[] memory
               Source: "tokenList"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "int8[] memory compactBuy = new int8[](tokenList.length)"
        VariableDeclaration "compactBuy"
           Type: int8[] memory
           Source: "int8[] memory compactBuy"
          ArrayTypeName
             Source: "int8[]"
            ElementaryTypeName int8
               Source: "int8"
        FunctionCall
           Type: int8[] memory
           Source: "new int8[](tokenList.length)"
          NewExpression
             Type: function (uint256) pure returns (int8[] memory)
             Source: "new int8[]"
            ArrayTypeName
               Source: "int8[]"
              ElementaryTypeName int8
                 Source: "int8"
          MemberAccess to member length
             Type: uint256
             Source: "tokenList.length"
            Identifier tokenList
               Type: contract ERC20[] memory
               Source: "tokenList"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "int8[] memory compactSell = new int8[](tokenList.length)"
        VariableDeclaration "compactSell"
           Type: int8[] memory
           Source: "int8[] memory compactSell"
          ArrayTypeName
             Source: "int8[]"
            ElementaryTypeName int8
               Source: "int8"
        FunctionCall
           Type: int8[] memory
           Source: "new int8[](tokenList.length)"
          NewExpression
             Type: function (uint256) pure returns (int8[] memory)
             Source: "new int8[]"
            ArrayTypeName
               Source: "int8[]"
              ElementaryTypeName int8
                 Source: "int8"
          MemberAccess to member length
             Type: uint256
             Source: "tokenList.length"
            Identifier tokenList
               Type: contract ERC20[] memory
               Source: "tokenList"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint[] memory updateBlock = new uint[](tokenList.length)"
        VariableDeclaration "updateBlock"
           Type: uint256[] memory
           Source: "uint[] memory updateBlock"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](tokenList.length)"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          MemberAccess to member length
             Type: uint256
             Source: "tokenList.length"
            Identifier tokenList
               Type: contract ERC20[] memory
               Source: "tokenList"
      ForStatement
         Source: "for (uint i = 0;  i < tokenList.length; i++) {\r\n            buyBases[i] = ratesContract.getBasicRate(tokenList[i], true);\r\n            sellBases[i] = ratesContract.getBasicRate(tokenList[i], false);\r\n\r\n            (compactBuy[i], compactSell[i], updateBlock[i]) = getCompactData(ratesContract, tokenList[i]);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 27
           Source: "i < tokenList.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "tokenList.length"
            Identifier tokenList
               Type: contract ERC20[] memory
               Source: "tokenList"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            buyBases[i] = ratesContract.getBasicRate(tokenList[i], true);\r\n            sellBases[i] = ratesContract.getBasicRate(tokenList[i], false);\r\n\r\n            (compactBuy[i], compactSell[i], updateBlock[i]) = getCompactData(ratesContract, tokenList[i]);\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "buyBases[i] = ratesContract.getBasicRate(tokenList[i], true)"
            Assignment using operator =
               Type: uint256
               Source: "buyBases[i] = ratesContract.getBasicRate(tokenList[i], true)"
              IndexAccess
                 Type: uint256
                 Source: "buyBases[i]"
                Identifier buyBases
                   Type: uint256[] memory
                   Source: "buyBases"
                Identifier i
                   Type: uint256
                   Source: "i"
              FunctionCall
                 Type: uint256
                 Source: "ratesContract.getBasicRate(tokenList[i], true)"
                MemberAccess to member getBasicRate
                   Type: function (contract ERC20,bool) view external returns (uint256)
                   Source: "ratesContract.getBasicRate"
                  Identifier ratesContract
                     Type: contract ConversionRates
                     Source: "ratesContract"
                IndexAccess
                   Type: contract ERC20
                   Source: "tokenList[i]"
                  Identifier tokenList
                     Type: contract ERC20[] memory
                     Source: "tokenList"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: true value: true
                   Type: bool
                   Source: "true"
          ExpressionStatement
             Gas costs: [???]
             Source: "sellBases[i] = ratesContract.getBasicRate(tokenList[i], false)"
            Assignment using operator =
               Type: uint256
               Source: "sellBases[i] = ratesContract.getBasicRate(tokenList[i], false)"
              IndexAccess
                 Type: uint256
                 Source: "sellBases[i]"
                Identifier sellBases
                   Type: uint256[] memory
                   Source: "sellBases"
                Identifier i
                   Type: uint256
                   Source: "i"
              FunctionCall
                 Type: uint256
                 Source: "ratesContract.getBasicRate(tokenList[i], false)"
                MemberAccess to member getBasicRate
                   Type: function (contract ERC20,bool) view external returns (uint256)
                   Source: "ratesContract.getBasicRate"
                  Identifier ratesContract
                     Type: contract ConversionRates
                     Source: "ratesContract"
                IndexAccess
                   Type: contract ERC20
                   Source: "tokenList[i]"
                  Identifier tokenList
                     Type: contract ERC20[] memory
                     Source: "tokenList"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: false value: false
                   Type: bool
                   Source: "false"
          ExpressionStatement
             Gas costs: [???]
             Source: "(compactBuy[i], compactSell[i], updateBlock[i]) = getCompactData(ratesContract, tokenList[i])"
            Assignment using operator =
               Type: tuple()
               Source: "(compactBuy[i], compactSell[i], updateBlock[i]) = getCompactData(ratesContract, tokenList[i])"
              TupleExpression
                 Type: tuple(int8,int8,uint256)
                 Source: "(compactBuy[i], compactSell[i], updateBlock[i])"
                IndexAccess
                   Type: int8
                   Source: "compactBuy[i]"
                  Identifier compactBuy
                     Type: int8[] memory
                     Source: "compactBuy"
                  Identifier i
                     Type: uint256
                     Source: "i"
                IndexAccess
                   Type: int8
                   Source: "compactSell[i]"
                  Identifier compactSell
                     Type: int8[] memory
                     Source: "compactSell"
                  Identifier i
                     Type: uint256
                     Source: "i"
                IndexAccess
                   Type: uint256
                   Source: "updateBlock[i]"
                  Identifier updateBlock
                     Type: uint256[] memory
                     Source: "updateBlock"
                  Identifier i
                     Type: uint256
                     Source: "i"
              FunctionCall
                 Type: tuple(int8,int8,uint256)
                 Source: "getCompactData(ratesContract, tokenList[i])"
                Identifier getCompactData
                   Type: function (contract ConversionRates,contract ERC20) view returns (int8,int8,uint256)
                   Source: "getCompactData"
                Identifier ratesContract
                   Type: contract ConversionRates
                   Source: "ratesContract"
                IndexAccess
                   Type: contract ERC20
                   Source: "tokenList[i]"
                  Identifier tokenList
                     Type: contract ERC20[] memory
                     Source: "tokenList"
                  Identifier i
                     Type: uint256
                     Source: "i"
      Return
         Gas costs: 40
         Source: "return (buyBases, sellBases, compactBuy, compactSell, updateBlock)"
        TupleExpression
           Type: tuple(uint256[] memory,uint256[] memory,int8[] memory,int8[] memory,uint256[] memory)
           Source: "(buyBases, sellBases, compactBuy, compactSell, updateBlock)"
          Identifier buyBases
             Type: uint256[] memory
             Source: "buyBases"
          Identifier sellBases
             Type: uint256[] memory
             Source: "sellBases"
          Identifier compactBuy
             Type: int8[] memory
             Source: "compactBuy"
          Identifier compactSell
             Type: int8[] memory
             Source: "compactSell"
          Identifier updateBlock
             Type: uint256[] memory
             Source: "updateBlock"
  FunctionDefinition "getTokenIndicies" - public - const
     Source: "function getTokenIndicies(ConversionRates ratesContract, ERC20[] tokenList) public view returns(uint[], uint[]) {\r\n        uint[] memory bulkIndices = new uint[](tokenList.length);\r\n        uint[] memory tokenIndexInBulk = new uint[](tokenList.length);\r\n\r\n        for (uint i = 0; i < tokenList.length; i++) {\r\n            uint bulkIndex; uint index; byte buy; byte sell;\r\n            (bulkIndex, index, buy, sell) = ratesContract.getCompactData(tokenList[i]);\r\n\r\n            bulkIndices[i] = bulkIndex;\r\n            tokenIndexInBulk[i] = index;\r\n        }\r\n\r\n        return (bulkIndices,tokenIndexInBulk);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(ConversionRates ratesContract, ERC20[] tokenList)"
      VariableDeclaration "ratesContract"
         Type: contract ConversionRates
         Source: "ConversionRates ratesContract"
        UserDefinedTypeName "ConversionRates"
           Source: "ConversionRates"
      VariableDeclaration "tokenList"
         Type: contract ERC20[] memory
         Source: "ERC20[] tokenList"
        ArrayTypeName
           Source: "ERC20[]"
          UserDefinedTypeName "ERC20"
             Source: "ERC20"
    ParameterList
       Gas costs: 6
       Source: "(uint[], uint[])"
      VariableDeclaration ""
         Type: uint256[] memory
         Source: "uint[]"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclaration ""
         Type: uint256[] memory
         Source: "uint[]"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    Block
       Source: "{\r\n        uint[] memory bulkIndices = new uint[](tokenList.length);\r\n        uint[] memory tokenIndexInBulk = new uint[](tokenList.length);\r\n\r\n        for (uint i = 0; i < tokenList.length; i++) {\r\n            uint bulkIndex; uint index; byte buy; byte sell;\r\n            (bulkIndex, index, buy, sell) = ratesContract.getCompactData(tokenList[i]);\r\n\r\n            bulkIndices[i] = bulkIndex;\r\n            tokenIndexInBulk[i] = index;\r\n        }\r\n\r\n        return (bulkIndices,tokenIndexInBulk);\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint[] memory bulkIndices = new uint[](tokenList.length)"
        VariableDeclaration "bulkIndices"
           Type: uint256[] memory
           Source: "uint[] memory bulkIndices"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](tokenList.length)"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          MemberAccess to member length
             Type: uint256
             Source: "tokenList.length"
            Identifier tokenList
               Type: contract ERC20[] memory
               Source: "tokenList"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint[] memory tokenIndexInBulk = new uint[](tokenList.length)"
        VariableDeclaration "tokenIndexInBulk"
           Type: uint256[] memory
           Source: "uint[] memory tokenIndexInBulk"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](tokenList.length)"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          MemberAccess to member length
             Type: uint256
             Source: "tokenList.length"
            Identifier tokenList
               Type: contract ERC20[] memory
               Source: "tokenList"
      ForStatement
         Source: "for (uint i = 0; i < tokenList.length; i++) {\r\n            uint bulkIndex; uint index; byte buy; byte sell;\r\n            (bulkIndex, index, buy, sell) = ratesContract.getCompactData(tokenList[i]);\r\n\r\n            bulkIndices[i] = bulkIndex;\r\n            tokenIndexInBulk[i] = index;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 27
           Source: "i < tokenList.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "tokenList.length"
            Identifier tokenList
               Type: contract ERC20[] memory
               Source: "tokenList"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            uint bulkIndex; uint index; byte buy; byte sell;\r\n            (bulkIndex, index, buy, sell) = ratesContract.getCompactData(tokenList[i]);\r\n\r\n            bulkIndices[i] = bulkIndex;\r\n            tokenIndexInBulk[i] = index;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 3
             Source: "uint bulkIndex"
            VariableDeclaration "bulkIndex"
               Type: uint256
               Source: "uint bulkIndex"
              ElementaryTypeName uint
                 Source: "uint"
          VariableDeclarationStatement
             Gas costs: 3
             Source: "uint index"
            VariableDeclaration "index"
               Type: uint256
               Source: "uint index"
              ElementaryTypeName uint
                 Source: "uint"
          VariableDeclarationStatement
             Gas costs: 3
             Source: "byte buy"
            VariableDeclaration "buy"
               Type: bytes1
               Source: "byte buy"
              ElementaryTypeName byte
                 Source: "byte"
          VariableDeclarationStatement
             Gas costs: 3
             Source: "byte sell"
            VariableDeclaration "sell"
               Type: bytes1
               Source: "byte sell"
              ElementaryTypeName byte
                 Source: "byte"
          ExpressionStatement
             Gas costs: [???]
             Source: "(bulkIndex, index, buy, sell) = ratesContract.getCompactData(tokenList[i])"
            Assignment using operator =
               Type: tuple()
               Source: "(bulkIndex, index, buy, sell) = ratesContract.getCompactData(tokenList[i])"
              TupleExpression
                 Type: tuple(uint256,uint256,bytes1,bytes1)
                 Source: "(bulkIndex, index, buy, sell)"
                Identifier bulkIndex
                   Type: uint256
                   Source: "bulkIndex"
                Identifier index
                   Type: uint256
                   Source: "index"
                Identifier buy
                   Type: bytes1
                   Source: "buy"
                Identifier sell
                   Type: bytes1
                   Source: "sell"
              FunctionCall
                 Type: tuple(uint256,uint256,bytes1,bytes1)
                 Source: "ratesContract.getCompactData(tokenList[i])"
                MemberAccess to member getCompactData
                   Type: function (contract ERC20) view external returns (uint256,uint256,bytes1,bytes1)
                   Source: "ratesContract.getCompactData"
                  Identifier ratesContract
                     Type: contract ConversionRates
                     Source: "ratesContract"
                IndexAccess
                   Type: contract ERC20
                   Source: "tokenList[i]"
                  Identifier tokenList
                     Type: contract ERC20[] memory
                     Source: "tokenList"
                  Identifier i
                     Type: uint256
                     Source: "i"
          ExpressionStatement
             Gas costs: [???]
             Source: "bulkIndices[i] = bulkIndex"
            Assignment using operator =
               Type: uint256
               Source: "bulkIndices[i] = bulkIndex"
              IndexAccess
                 Type: uint256
                 Source: "bulkIndices[i]"
                Identifier bulkIndices
                   Type: uint256[] memory
                   Source: "bulkIndices"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier bulkIndex
                 Type: uint256
                 Source: "bulkIndex"
          ExpressionStatement
             Gas costs: [???]
             Source: "tokenIndexInBulk[i] = index"
            Assignment using operator =
               Type: uint256
               Source: "tokenIndexInBulk[i] = index"
              IndexAccess
                 Type: uint256
                 Source: "tokenIndexInBulk[i]"
                Identifier tokenIndexInBulk
                   Type: uint256[] memory
                   Source: "tokenIndexInBulk"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier index
                 Type: uint256
                 Source: "index"
      Return
         Gas costs: 16
         Source: "return (bulkIndices,tokenIndexInBulk)"
        TupleExpression
           Type: tuple(uint256[] memory,uint256[] memory)
           Source: "(bulkIndices,tokenIndexInBulk)"
          Identifier bulkIndices
             Type: uint256[] memory
             Source: "bulkIndices"
          Identifier tokenIndexInBulk
             Type: uint256[] memory
             Source: "tokenIndexInBulk"
  FunctionDefinition "getExpectedRates" - public - const
     Source: "function getExpectedRates( KyberNetwork network, ERC20[] srcs, ERC20[] dests, uint[] qty )\r\n        public view returns(uint[], uint[])\r\n    {\r\n        require( srcs.length == dests.length );\r\n        require( srcs.length == qty.length );\r\n\r\n        uint[] memory rates = new uint[](srcs.length);\r\n        uint[] memory slippage = new uint[](srcs.length);\r\n        for ( uint i = 0; i < srcs.length; i++ ) {\r\n            (rates[i],slippage[i]) = network.getExpectedRate(srcs[i],dests[i],qty[i]);\r\n        }\r\n\r\n        return (rates, slippage);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "( KyberNetwork network, ERC20[] srcs, ERC20[] dests, uint[] qty )"
      VariableDeclaration "network"
         Type: contract KyberNetwork
         Source: "KyberNetwork network"
        UserDefinedTypeName "KyberNetwork"
           Source: "KyberNetwork"
      VariableDeclaration "srcs"
         Type: contract ERC20[] memory
         Source: "ERC20[] srcs"
        ArrayTypeName
           Source: "ERC20[]"
          UserDefinedTypeName "ERC20"
             Source: "ERC20"
      VariableDeclaration "dests"
         Type: contract ERC20[] memory
         Source: "ERC20[] dests"
        ArrayTypeName
           Source: "ERC20[]"
          UserDefinedTypeName "ERC20"
             Source: "ERC20"
      VariableDeclaration "qty"
         Type: uint256[] memory
         Source: "uint[] qty"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    ParameterList
       Gas costs: 6
       Source: "(uint[], uint[])"
      VariableDeclaration ""
         Type: uint256[] memory
         Source: "uint[]"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclaration ""
         Type: uint256[] memory
         Source: "uint[]"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    Block
       Source: "{\r\n        require( srcs.length == dests.length );\r\n        require( srcs.length == qty.length );\r\n\r\n        uint[] memory rates = new uint[](srcs.length);\r\n        uint[] memory slippage = new uint[](srcs.length);\r\n        for ( uint i = 0; i < srcs.length; i++ ) {\r\n            (rates[i],slippage[i]) = network.getExpectedRate(srcs[i],dests[i],qty[i]);\r\n        }\r\n\r\n        return (rates, slippage);\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "require( srcs.length == dests.length )"
        FunctionCall
           Type: tuple()
           Source: "require( srcs.length == dests.length )"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "srcs.length == dests.length"
            MemberAccess to member length
               Type: uint256
               Source: "srcs.length"
              Identifier srcs
                 Type: contract ERC20[] memory
                 Source: "srcs"
            MemberAccess to member length
               Type: uint256
               Source: "dests.length"
              Identifier dests
                 Type: contract ERC20[] memory
                 Source: "dests"
      ExpressionStatement
         Gas costs: [???]
         Source: "require( srcs.length == qty.length )"
        FunctionCall
           Type: tuple()
           Source: "require( srcs.length == qty.length )"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "srcs.length == qty.length"
            MemberAccess to member length
               Type: uint256
               Source: "srcs.length"
              Identifier srcs
                 Type: contract ERC20[] memory
                 Source: "srcs"
            MemberAccess to member length
               Type: uint256
               Source: "qty.length"
              Identifier qty
                 Type: uint256[] memory
                 Source: "qty"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint[] memory rates = new uint[](srcs.length)"
        VariableDeclaration "rates"
           Type: uint256[] memory
           Source: "uint[] memory rates"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](srcs.length)"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          MemberAccess to member length
             Type: uint256
             Source: "srcs.length"
            Identifier srcs
               Type: contract ERC20[] memory
               Source: "srcs"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint[] memory slippage = new uint[](srcs.length)"
        VariableDeclaration "slippage"
           Type: uint256[] memory
           Source: "uint[] memory slippage"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](srcs.length)"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          MemberAccess to member length
             Type: uint256
             Source: "srcs.length"
            Identifier srcs
               Type: contract ERC20[] memory
               Source: "srcs"
      ForStatement
         Source: "for ( uint i = 0; i < srcs.length; i++ ) {\r\n            (rates[i],slippage[i]) = network.getExpectedRate(srcs[i],dests[i],qty[i]);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 27
           Source: "i < srcs.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "srcs.length"
            Identifier srcs
               Type: contract ERC20[] memory
               Source: "srcs"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            (rates[i],slippage[i]) = network.getExpectedRate(srcs[i],dests[i],qty[i]);\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "(rates[i],slippage[i]) = network.getExpectedRate(srcs[i],dests[i],qty[i])"
            Assignment using operator =
               Type: tuple()
               Source: "(rates[i],slippage[i]) = network.getExpectedRate(srcs[i],dests[i],qty[i])"
              TupleExpression
                 Type: tuple(uint256,uint256)
                 Source: "(rates[i],slippage[i])"
                IndexAccess
                   Type: uint256
                   Source: "rates[i]"
                  Identifier rates
                     Type: uint256[] memory
                     Source: "rates"
                  Identifier i
                     Type: uint256
                     Source: "i"
                IndexAccess
                   Type: uint256
                   Source: "slippage[i]"
                  Identifier slippage
                     Type: uint256[] memory
                     Source: "slippage"
                  Identifier i
                     Type: uint256
                     Source: "i"
              FunctionCall
                 Type: tuple(uint256,uint256)
                 Source: "network.getExpectedRate(srcs[i],dests[i],qty[i])"
                MemberAccess to member getExpectedRate
                   Type: function (contract ERC20,contract ERC20,uint256) view external returns (uint256,uint256)
                   Source: "network.getExpectedRate"
                  Identifier network
                     Type: contract KyberNetwork
                     Source: "network"
                IndexAccess
                   Type: contract ERC20
                   Source: "srcs[i]"
                  Identifier srcs
                     Type: contract ERC20[] memory
                     Source: "srcs"
                  Identifier i
                     Type: uint256
                     Source: "i"
                IndexAccess
                   Type: contract ERC20
                   Source: "dests[i]"
                  Identifier dests
                     Type: contract ERC20[] memory
                     Source: "dests"
                  Identifier i
                     Type: uint256
                     Source: "i"
                IndexAccess
                   Type: uint256
                   Source: "qty[i]"
                  Identifier qty
                     Type: uint256[] memory
                     Source: "qty"
                  Identifier i
                     Type: uint256
                     Source: "i"
      Return
         Gas costs: 16
         Source: "return (rates, slippage)"
        TupleExpression
           Type: tuple(uint256[] memory,uint256[] memory)
           Source: "(rates, slippage)"
          Identifier rates
             Type: uint256[] memory
             Source: "rates"
          Identifier slippage
             Type: uint256[] memory
             Source: "slippage"
