Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x3f500a7e3783fbd228ddb894de2db110eed83a5b.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^ 0.4.13;"
ContractDefinition "MigrationAgent"
   Gas costs: 0
   Source: "contract MigrationAgent {\r\n    function migrateFrom(address _from, uint256 _value);\r\n}"
  FunctionDefinition "migrateFrom" - public
     Source: "function migrateFrom(address _from, uint256 _value);"
    ParameterList
       Source: "(address _from, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
ContractDefinition "PreArtexToken"
   Gas costs: 0
   Source: "contract PreArtexToken {\r\n    function balanceOf(address _owner) constant returns(uint256 balance);\r\n    mapping(address => uint) public deposits;\r\n    uint public tokenPriceUSDWEI;\r\n}"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns(uint256 balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "deposits"
     Type: mapping(address => uint256)
     Source: "mapping(address => uint) public deposits"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "tokenPriceUSDWEI"
     Type: uint256
     Source: "uint public tokenPriceUSDWEI"
    ElementaryTypeName uint
       Source: "uint"
ContractDefinition "Owned"
   Source: "contract Owned {\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n    address public oracle;\r\n    address public btcOracle;\r\n\r\n    function Owned() payable {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrOracle {\r\n        require(owner == msg.sender || oracle == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrBtcOracle {\r\n        require(owner == msg.sender || btcOracle == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _owner) onlyOwner external {\r\n        require(_owner != 0);\r\n        newOwner = _owner;\r\n    }\r\n\r\n    function confirmOwner() external {\r\n        require(newOwner == msg.sender);\r\n        owner = newOwner;\r\n        delete newOwner;\r\n    }\r\n\r\n    function changeOracle(address _oracle) onlyOwner external {\r\n        require(_oracle != 0);\r\n        oracle = _oracle;\r\n    }\r\n\r\n    function changeBtcOracle(address _btcOracle) onlyOwner external {\r\n        require(_btcOracle != 0);\r\n        btcOracle = _btcOracle;\r\n    }\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "newOwner"
     Type: address
     Gas costs: [???]
     Source: "address public newOwner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "oracle"
     Type: address
     Gas costs: [???]
     Source: "address public oracle"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "btcOracle"
     Type: address
     Gas costs: [???]
     Source: "address public btcOracle"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "Owned" - public
     Source: "function Owned() payable {\r\n        owner = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(owner == msg.sender);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 4230
         Source: "require(owner == msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "require(owner == msg.sender)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "owner == msg.sender"
            Identifier owner
               Type: address
               Source: "owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      PlaceholderStatement
         Gas costs: 1
         Source: "_"
  ModifierDefinition "onlyOwnerOrOracle"
     Source: "modifier onlyOwnerOrOracle {\r\n        require(owner == msg.sender || oracle == msg.sender);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(owner == msg.sender || oracle == msg.sender);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 557
         Source: "require(owner == msg.sender || oracle == msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "require(owner == msg.sender || oracle == msg.sender)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "owner == msg.sender || oracle == msg.sender"
            BinaryOperation using operator ==
               Type: bool
               Source: "owner == msg.sender"
              Identifier owner
                 Type: address
                 Source: "owner"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            BinaryOperation using operator ==
               Type: bool
               Source: "oracle == msg.sender"
              Identifier oracle
                 Type: address
                 Source: "oracle"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyOwnerOrBtcOracle"
     Source: "modifier onlyOwnerOrBtcOracle {\r\n        require(owner == msg.sender || btcOracle == msg.sender);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(owner == msg.sender || btcOracle == msg.sender);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 557
         Source: "require(owner == msg.sender || btcOracle == msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "require(owner == msg.sender || btcOracle == msg.sender)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "owner == msg.sender || btcOracle == msg.sender"
            BinaryOperation using operator ==
               Type: bool
               Source: "owner == msg.sender"
              Identifier owner
                 Type: address
                 Source: "owner"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            BinaryOperation using operator ==
               Type: bool
               Source: "btcOracle == msg.sender"
              Identifier btcOracle
                 Type: address
                 Source: "btcOracle"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "changeOwner" - public
     Source: "function changeOwner(address _owner) onlyOwner external {\r\n        require(_owner != 0);\r\n        newOwner = _owner;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_owner != 0);\r\n        newOwner = _owner;\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "require(_owner != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_owner != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_owner != 0"
            Identifier _owner
               Type: address
               Source: "_owner"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "newOwner = _owner"
        Assignment using operator =
           Type: address
           Source: "newOwner = _owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "confirmOwner" - public
     Source: "function confirmOwner() external {\r\n        require(newOwner == msg.sender);\r\n        owner = newOwner;\r\n        delete newOwner;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(newOwner == msg.sender);\r\n        owner = newOwner;\r\n        delete newOwner;\r\n    }"
      ExpressionStatement
         Gas costs: 282
         Source: "require(newOwner == msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "require(newOwner == msg.sender)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "newOwner == msg.sender"
            Identifier newOwner
               Type: address
               Source: "newOwner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 20503
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
      ExpressionStatement
         Gas costs: 20242
         Source: "delete newOwner"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete newOwner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
  FunctionDefinition "changeOracle" - public
     Source: "function changeOracle(address _oracle) onlyOwner external {\r\n        require(_oracle != 0);\r\n        oracle = _oracle;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _oracle)"
      VariableDeclaration "_oracle"
         Type: address
         Source: "address _oracle"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_oracle != 0);\r\n        oracle = _oracle;\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "require(_oracle != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_oracle != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_oracle != 0"
            Identifier _oracle
               Type: address
               Source: "_oracle"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "oracle = _oracle"
        Assignment using operator =
           Type: address
           Source: "oracle = _oracle"
          Identifier oracle
             Type: address
             Source: "oracle"
          Identifier _oracle
             Type: address
             Source: "_oracle"
  FunctionDefinition "changeBtcOracle" - public
     Source: "function changeBtcOracle(address _btcOracle) onlyOwner external {\r\n        require(_btcOracle != 0);\r\n        btcOracle = _btcOracle;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _btcOracle)"
      VariableDeclaration "_btcOracle"
         Type: address
         Source: "address _btcOracle"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_btcOracle != 0);\r\n        btcOracle = _btcOracle;\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "require(_btcOracle != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_btcOracle != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_btcOracle != 0"
            Identifier _btcOracle
               Type: address
               Source: "_btcOracle"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "btcOracle = _btcOracle"
        Assignment using operator =
           Type: address
           Source: "btcOracle = _btcOracle"
          Identifier btcOracle
             Type: address
             Source: "btcOracle"
          Identifier _btcOracle
             Type: address
             Source: "_btcOracle"
ContractDefinition "KnownContract"
   Gas costs: 0
   Source: "contract KnownContract {\r\n    function transfered(address _sender, uint256 _value, bytes32[] _data) external;\r\n}"
  FunctionDefinition "transfered" - public
     Source: "function transfered(address _sender, uint256 _value, bytes32[] _data) external;"
    ParameterList
       Source: "(address _sender, uint256 _value, bytes32[] _data)"
      VariableDeclaration "_sender"
         Type: address
         Source: "address _sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_data"
         Type: bytes32[] calldata
         Source: "bytes32[] _data"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
    ParameterList
       Source: ""
ContractDefinition "ERC20"
   Gas costs: [???]
   Source: "contract ERC20 {\r\n    uint public totalSupply;\r\n\r\n    function balanceOf(address who) constant returns(uint);\r\n\r\n    function transfer(address to, uint value);\r\n\r\n    function allowance(address owner, address spender) constant returns(uint);\r\n\r\n    function transferFrom(address from, address to, uint value);\r\n\r\n    function approve(address spender, uint value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint public totalSupply"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) constant returns(uint);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint value);"
    ParameterList
       Source: "(address to, uint value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) constant returns(uint);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint value);"
    ParameterList
       Source: "(address from, address to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint value);"
    ParameterList
       Source: "(address spender, uint value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "Stateful"
   Source: "contract Stateful {\r\n    enum State {\r\n        Initial,\r\n        PreSale,\r\n        WaitingForSale,\r\n        Sale,\r\n        CrowdsaleCompleted,\r\n        SaleFailed\r\n    }\r\n\r\n    State public state = State.Initial;\r\n\r\n    event StateChanged(State oldState, State newState);\r\n\r\n    function setState(State newState) internal {\r\n        State oldState = state;\r\n        state = newState;\r\n        StateChanged(oldState, newState);\r\n    }\r\n}"
  EnumDefinition "State"
    EnumValue "Initial"
    EnumValue "PreSale"
    EnumValue "WaitingForSale"
    EnumValue "Sale"
    EnumValue "CrowdsaleCompleted"
    EnumValue "SaleFailed"
  VariableDeclaration "state"
     Type: enum Stateful.State
     Gas costs: [???]
     Source: "State public state = State.Initial"
    UserDefinedTypeName "State"
       Source: "State"
    MemberAccess to member Initial
       Type: enum Stateful.State
       Source: "State.Initial"
      Identifier State
         Type: type(enum Stateful.State)
         Source: "State"
  EventDefinition "StateChanged"
     Gas costs: 0
     Source: "event StateChanged(State oldState, State newState);"
    ParameterList
       Source: "(State oldState, State newState)"
      VariableDeclaration "oldState"
         Type: enum Stateful.State
         Source: "State oldState"
        UserDefinedTypeName "State"
           Source: "State"
      VariableDeclaration "newState"
         Type: enum Stateful.State
         Source: "State newState"
        UserDefinedTypeName "State"
           Source: "State"
  FunctionDefinition "setState"
     Source: "function setState(State newState) internal {\r\n        State oldState = state;\r\n        state = newState;\r\n        StateChanged(oldState, newState);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(State newState)"
      VariableDeclaration "newState"
         Type: enum Stateful.State
         Source: "State newState"
        UserDefinedTypeName "State"
           Source: "State"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        State oldState = state;\r\n        state = newState;\r\n        StateChanged(oldState, newState);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 297
         Source: "State oldState = state"
        VariableDeclaration "oldState"
           Type: enum Stateful.State
           Source: "State oldState"
          UserDefinedTypeName "State"
             Source: "State"
        Identifier state
           Type: enum Stateful.State
           Source: "state"
      ExpressionStatement
         Gas costs: 20337
         Source: "state = newState"
        Assignment using operator =
           Type: enum Stateful.State
           Source: "state = newState"
          Identifier state
             Type: enum Stateful.State
             Source: "state"
          Identifier newState
             Type: enum Stateful.State
             Source: "newState"
      ExpressionStatement
         Gas costs: [???]
         Source: "StateChanged(oldState, newState)"
        FunctionCall
           Type: tuple()
           Source: "StateChanged(oldState, newState)"
          Identifier StateChanged
             Type: function (enum Stateful.State,enum Stateful.State)
             Source: "StateChanged"
          Identifier oldState
             Type: enum Stateful.State
             Source: "oldState"
          Identifier newState
             Type: enum Stateful.State
             Source: "newState"
ContractDefinition "Crowdsale"
   Source: "contract Crowdsale is Owned, Stateful {\r\n\r\n    uint public etherPriceUSDWEI;\r\n    address public beneficiary;\r\n    uint public totalLimitUSDWEI;\r\n    uint public minimalSuccessUSDWEI;\r\n    uint public collectedUSDWEI;\r\n\r\n    uint public crowdsaleStartTime;\r\n    uint public crowdsaleFinishTime;\r\n\r\n    struct Investor {\r\n        uint amountTokens;\r\n        uint amountWei;\r\n    }\r\n\r\n    struct BtcDeposit {\r\n        uint amountBTCWEI;\r\n        uint btcPriceUSDWEI;\r\n        address investor;\r\n    }\r\n\r\n    mapping(bytes32 => BtcDeposit) public btcDeposits;\r\n\r\n    mapping(address => Investor) public investors;\r\n    mapping(uint => address) public investorsIter;\r\n    uint public numberOfInvestors;\r\n\r\n    mapping(uint => address) public investorsToWithdrawIter;\r\n    uint public numberOfInvestorsToWithdraw;\r\n\r\n    function Crowdsale() payable Owned() {}\r\n\r\n    //abstract methods\r\n    function emitTokens(address _investor, uint _tokenPriceUSDWEI, uint _usdwei) internal returns(uint tokensToEmit);\r\n\r\n    function emitAdditionalTokens() internal;\r\n\r\n    function burnTokens(address _address, uint _amount) internal;\r\n\r\n    function() payable crowdsaleState limitNotExceeded crowdsaleNotFinished {\r\n        uint valueWEI = msg.value;\r\n        uint valueUSDWEI = valueWEI * etherPriceUSDWEI / 1 ether;\r\n        uint tokenPriceUSDWEI = getTokenPriceUSDWEI();\r\n        if (collectedUSDWEI + valueUSDWEI > totalLimitUSDWEI) { // don't need so much ether\r\n            valueUSDWEI = totalLimitUSDWEI - collectedUSDWEI;\r\n            valueWEI = valueUSDWEI * 1 ether / etherPriceUSDWEI;\r\n            uint weiToReturn = msg.value - valueWEI;\r\n            bool isSent = msg.sender.call.gas(3000000).value(weiToReturn)();\r\n            require(isSent);\r\n            collectedUSDWEI = totalLimitUSDWEI; // to be sure!                                              \r\n        } else {\r\n            collectedUSDWEI += valueUSDWEI;\r\n        }\r\n        emitTokensFor(msg.sender, tokenPriceUSDWEI, valueUSDWEI, valueWEI);\r\n    }\r\n\r\n    function depositUSD(address _to, uint _amountUSDWEI) external onlyOwner crowdsaleState limitNotExceeded crowdsaleNotFinished {\r\n        uint tokenPriceUSDWEI = getTokenPriceUSDWEI();\r\n        collectedUSDWEI += _amountUSDWEI;\r\n        emitTokensFor(_to, tokenPriceUSDWEI, _amountUSDWEI, 0);\r\n    }\r\n\r\n    function depositBTC(address _to, uint _amountBTCWEI, uint _btcPriceUSDWEI, bytes32 _btcTxId) external onlyOwnerOrBtcOracle crowdsaleState limitNotExceeded crowdsaleNotFinished {\r\n        uint valueUSDWEI = _amountBTCWEI * _btcPriceUSDWEI / 1 ether;\r\n        uint tokenPriceUSDWEI = getTokenPriceUSDWEI();\r\n        BtcDeposit storage btcDep = btcDeposits[_btcTxId];\r\n        require(btcDep.amountBTCWEI == 0);\r\n        btcDep.amountBTCWEI = _amountBTCWEI;\r\n        btcDep.btcPriceUSDWEI = _btcPriceUSDWEI;\r\n        btcDep.investor = _to;\r\n        collectedUSDWEI += valueUSDWEI;\r\n        emitTokensFor(_to, tokenPriceUSDWEI, valueUSDWEI, 0);\r\n    }\r\n\r\n    function emitTokensFor(address _investor, uint _tokenPriceUSDWEI, uint _valueUSDWEI, uint _valueWEI) internal {\r\n        var emittedTokens = emitTokens(_investor, _tokenPriceUSDWEI, _valueUSDWEI);\r\n        Investor storage inv = investors[_investor];\r\n        if (inv.amountTokens == 0) { // new investor\r\n            investorsIter[numberOfInvestors++] = _investor;\r\n        }\r\n        inv.amountTokens += emittedTokens;\r\n        if (state == State.Sale) {\r\n            inv.amountWei += _valueWEI;\r\n        }\r\n    }\r\n\r\n    function getTokenPriceUSDWEI() internal returns(uint tokenPriceUSDWEI) {\r\n        tokenPriceUSDWEI = 0;\r\n        if (state == State.PreSale) {\r\n            tokenPriceUSDWEI = 76923076923076900;\r\n        }\r\n        if (state == State.Sale) {\r\n            if (now < crowdsaleStartTime + 1 days) {\r\n                tokenPriceUSDWEI = 86956521730000000;\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokenPriceUSDWEI = 90909090900000000;\r\n            } else if (now < crowdsaleStartTime + 2 weeks) {\r\n                tokenPriceUSDWEI = 95238095230000000;\r\n            } else {\r\n                tokenPriceUSDWEI = 100000000000000000;\r\n            }\r\n        }\r\n    }\r\n\r\n    function startPreSale(\r\n        address _beneficiary,\r\n        uint _etherPriceUSDWEI,\r\n        uint _totalLimitUSDWEI,\r\n        uint _crowdsaleDurationDays) external onlyOwner {\r\n        require(state == State.Initial);\r\n        crowdsaleStartTime = now;\r\n        beneficiary = _beneficiary;\r\n        etherPriceUSDWEI = _etherPriceUSDWEI;\r\n        totalLimitUSDWEI = _totalLimitUSDWEI;\r\n        crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days;\r\n        collectedUSDWEI = 0;\r\n        setState(State.PreSale);\r\n    }\r\n\r\n    function finishPreSale() public onlyOwner {\r\n        require(state == State.PreSale);\r\n        bool isSent = beneficiary.call.gas(3000000).value(this.balance)();\r\n        require(isSent);\r\n        setState(State.WaitingForSale);\r\n    }\r\n\r\n    function startSale(\r\n        address _beneficiary,\r\n        uint _etherPriceUSDWEI,\r\n        uint _totalLimitUSDWEI,\r\n        uint _crowdsaleDurationDays,\r\n        uint _minimalSuccessUSDWEI) external onlyOwner {\r\n\r\n        require(state == State.WaitingForSale);\r\n        crowdsaleStartTime = now;\r\n        beneficiary = _beneficiary;\r\n        etherPriceUSDWEI = _etherPriceUSDWEI;\r\n        totalLimitUSDWEI = _totalLimitUSDWEI;\r\n        crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days;\r\n        minimalSuccessUSDWEI = _minimalSuccessUSDWEI;\r\n        collectedUSDWEI = 0;\r\n        setState(State.Sale);\r\n    }\r\n\r\n    function failSale(uint _investorsToProcess) public {\r\n        require(state == State.Sale);\r\n        require(now >= crowdsaleFinishTime && collectedUSDWEI < minimalSuccessUSDWEI);\r\n        while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n            address addr = investorsIter[--numberOfInvestors];\r\n            Investor memory inv = investors[addr];\r\n            burnTokens(addr, inv.amountTokens);\r\n            --_investorsToProcess;\r\n            delete investorsIter[numberOfInvestors];\r\n\r\n            investorsToWithdrawIter[numberOfInvestorsToWithdraw] = addr;\r\n            numberOfInvestorsToWithdraw++;\r\n        }\r\n        if (numberOfInvestors > 0) {\r\n            return;\r\n        }\r\n        setState(State.SaleFailed);\r\n    }\r\n\r\n    function completeSale(uint _investorsToProcess) public onlyOwner {\r\n        require(state == State.Sale);\r\n        require(collectedUSDWEI >= minimalSuccessUSDWEI);\r\n\r\n        while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n            --numberOfInvestors;\r\n            --_investorsToProcess;\r\n            delete investors[investorsIter[numberOfInvestors]];\r\n            delete investorsIter[numberOfInvestors];\r\n        }\r\n\r\n        if (numberOfInvestors > 0) {\r\n            return;\r\n        }\r\n\r\n        emitAdditionalTokens();\r\n\r\n        bool isSent = beneficiary.call.gas(3000000).value(this.balance)();\r\n        require(isSent);\r\n        setState(State.CrowdsaleCompleted);\r\n    }\r\n\r\n    function setEtherPriceUSDWEI(uint _etherPriceUSDWEI) external onlyOwnerOrOracle {\r\n        etherPriceUSDWEI = _etherPriceUSDWEI;\r\n    }\r\n\r\n    function setBeneficiary(address _beneficiary) external onlyOwner() {\r\n        require(_beneficiary != 0);\r\n        beneficiary = _beneficiary;\r\n    }\r\n\r\n    // This function must be called by token holder in case of crowdsale failed\r\n    function withdrawBack() external saleFailedState {\r\n        returnInvestmentsToInternal(msg.sender);\r\n    }\r\n\r\n    function returnInvestments(uint _investorsToProcess) public saleFailedState {\r\n        while (_investorsToProcess > 0 && numberOfInvestorsToWithdraw > 0) {\r\n            address addr = investorsToWithdrawIter[--numberOfInvestorsToWithdraw];\r\n            delete investorsToWithdrawIter[numberOfInvestorsToWithdraw];\r\n            --_investorsToProcess;\r\n            returnInvestmentsToInternal(addr);\r\n        }\r\n    }\r\n\r\n    function returnInvestmentsTo(address _to) public saleFailedState {\r\n        returnInvestmentsToInternal(_to);\r\n    }\r\n\r\n    function returnInvestmentsToInternal(address _to) internal {\r\n        Investor memory inv = investors[_to];\r\n        uint value = inv.amountWei;\r\n        if (value > 0) {\r\n            delete investors[_to];\r\n            require(_to.call.gas(3000000).value(value)());\r\n        }\r\n    }\r\n\r\n    function withdrawFunds(uint _value) public onlyOwner {\r\n        require(state == State.PreSale || (state == State.Sale && collectedUSDWEI > minimalSuccessUSDWEI));\r\n        if (_value == 0) {\r\n            _value = this.balance;\r\n        }\r\n        bool isSent = beneficiary.call.gas(3000000).value(_value)();\r\n        require(isSent);\r\n    }\r\n\r\n    modifier crowdsaleNotFinished {\r\n        require(now < crowdsaleFinishTime);\r\n        _;\r\n    }\r\n\r\n    modifier limitNotExceeded {\r\n        require(collectedUSDWEI < totalLimitUSDWEI);\r\n        _;\r\n    }\r\n\r\n    modifier crowdsaleState {\r\n        require(state == State.PreSale || state == State.Sale);\r\n        _;\r\n    }\r\n\r\n    modifier saleFailedState {\r\n        require(state == State.SaleFailed);\r\n        _;\r\n    }\r\n\r\n    modifier completedSaleState {\r\n        require(state == State.CrowdsaleCompleted);\r\n        _;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Owned"
    UserDefinedTypeName "Owned"
       Source: "Owned"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Stateful"
    UserDefinedTypeName "Stateful"
       Source: "Stateful"
  VariableDeclaration "etherPriceUSDWEI"
     Type: uint256
     Gas costs: [???]
     Source: "uint public etherPriceUSDWEI"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "beneficiary"
     Type: address
     Gas costs: [???]
     Source: "address public beneficiary"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "totalLimitUSDWEI"
     Type: uint256
     Gas costs: [???]
     Source: "uint public totalLimitUSDWEI"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "minimalSuccessUSDWEI"
     Type: uint256
     Gas costs: [???]
     Source: "uint public minimalSuccessUSDWEI"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "collectedUSDWEI"
     Type: uint256
     Gas costs: [???]
     Source: "uint public collectedUSDWEI"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "crowdsaleStartTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint public crowdsaleStartTime"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "crowdsaleFinishTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint public crowdsaleFinishTime"
    ElementaryTypeName uint
       Source: "uint"
  StructDefinition "Investor"
     Gas costs: 0
     Source: "struct Investor {\r\n        uint amountTokens;\r\n        uint amountWei;\r\n    }"
    VariableDeclaration "amountTokens"
       Type: uint256
       Source: "uint amountTokens"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "amountWei"
       Type: uint256
       Source: "uint amountWei"
      ElementaryTypeName uint
         Source: "uint"
  StructDefinition "BtcDeposit"
     Gas costs: 0
     Source: "struct BtcDeposit {\r\n        uint amountBTCWEI;\r\n        uint btcPriceUSDWEI;\r\n        address investor;\r\n    }"
    VariableDeclaration "amountBTCWEI"
       Type: uint256
       Source: "uint amountBTCWEI"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "btcPriceUSDWEI"
       Type: uint256
       Source: "uint btcPriceUSDWEI"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "investor"
       Type: address
       Source: "address investor"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "btcDeposits"
     Type: mapping(bytes32 => struct Crowdsale.BtcDeposit storage ref)
     Gas costs: [???]
     Source: "mapping(bytes32 => BtcDeposit) public btcDeposits"
    Mapping
       Source: "mapping(bytes32 => BtcDeposit)"
      ElementaryTypeName bytes32
         Source: "bytes32"
      UserDefinedTypeName "BtcDeposit"
         Source: "BtcDeposit"
  VariableDeclaration "investors"
     Type: mapping(address => struct Crowdsale.Investor storage ref)
     Gas costs: [???]
     Source: "mapping(address => Investor) public investors"
    Mapping
       Source: "mapping(address => Investor)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "Investor"
         Source: "Investor"
  VariableDeclaration "investorsIter"
     Type: mapping(uint256 => address)
     Gas costs: [???]
     Source: "mapping(uint => address) public investorsIter"
    Mapping
       Source: "mapping(uint => address)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "numberOfInvestors"
     Type: uint256
     Gas costs: [???]
     Source: "uint public numberOfInvestors"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "investorsToWithdrawIter"
     Type: mapping(uint256 => address)
     Gas costs: [???]
     Source: "mapping(uint => address) public investorsToWithdrawIter"
    Mapping
       Source: "mapping(uint => address)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "numberOfInvestorsToWithdraw"
     Type: uint256
     Gas costs: [???]
     Source: "uint public numberOfInvestorsToWithdraw"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "Crowdsale" - public
     Source: "function Crowdsale() payable Owned() {}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "Owned"
       Gas costs: 0
       Source: "Owned()"
      Identifier Owned
         Type: type(contract Owned)
         Source: "Owned"
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "emitTokens"
     Gas costs: 0
     Source: "function emitTokens(address _investor, uint _tokenPriceUSDWEI, uint _usdwei) internal returns(uint tokensToEmit);"
    ParameterList
       Source: "(address _investor, uint _tokenPriceUSDWEI, uint _usdwei)"
      VariableDeclaration "_investor"
         Type: address
         Source: "address _investor"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokenPriceUSDWEI"
         Type: uint256
         Source: "uint _tokenPriceUSDWEI"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_usdwei"
         Type: uint256
         Source: "uint _usdwei"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint tokensToEmit)"
      VariableDeclaration "tokensToEmit"
         Type: uint256
         Source: "uint tokensToEmit"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "emitAdditionalTokens"
     Gas costs: 0
     Source: "function emitAdditionalTokens() internal;"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
  FunctionDefinition "burnTokens"
     Gas costs: 0
     Source: "function burnTokens(address _address, uint _amount) internal;"
    ParameterList
       Source: "(address _address, uint _amount)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  FunctionDefinition "" - public
     Source: "function() payable crowdsaleState limitNotExceeded crowdsaleNotFinished {\r\n        uint valueWEI = msg.value;\r\n        uint valueUSDWEI = valueWEI * etherPriceUSDWEI / 1 ether;\r\n        uint tokenPriceUSDWEI = getTokenPriceUSDWEI();\r\n        if (collectedUSDWEI + valueUSDWEI > totalLimitUSDWEI) { // don't need so much ether\r\n            valueUSDWEI = totalLimitUSDWEI - collectedUSDWEI;\r\n            valueWEI = valueUSDWEI * 1 ether / etherPriceUSDWEI;\r\n            uint weiToReturn = msg.value - valueWEI;\r\n            bool isSent = msg.sender.call.gas(3000000).value(weiToReturn)();\r\n            require(isSent);\r\n            collectedUSDWEI = totalLimitUSDWEI; // to be sure!                                              \r\n        } else {\r\n            collectedUSDWEI += valueUSDWEI;\r\n        }\r\n        emitTokensFor(msg.sender, tokenPriceUSDWEI, valueUSDWEI, valueWEI);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "crowdsaleState"
       Gas costs: 0
       Source: "crowdsaleState"
      Identifier crowdsaleState
         Type: modifier ()
         Source: "crowdsaleState"
    ModifierInvocation "limitNotExceeded"
       Gas costs: 0
       Source: "limitNotExceeded"
      Identifier limitNotExceeded
         Type: modifier ()
         Source: "limitNotExceeded"
    ModifierInvocation "crowdsaleNotFinished"
       Gas costs: 0
       Source: "crowdsaleNotFinished"
      Identifier crowdsaleNotFinished
         Type: modifier ()
         Source: "crowdsaleNotFinished"
    Block
       Source: "{\r\n        uint valueWEI = msg.value;\r\n        uint valueUSDWEI = valueWEI * etherPriceUSDWEI / 1 ether;\r\n        uint tokenPriceUSDWEI = getTokenPriceUSDWEI();\r\n        if (collectedUSDWEI + valueUSDWEI > totalLimitUSDWEI) { // don't need so much ether\r\n            valueUSDWEI = totalLimitUSDWEI - collectedUSDWEI;\r\n            valueWEI = valueUSDWEI * 1 ether / etherPriceUSDWEI;\r\n            uint weiToReturn = msg.value - valueWEI;\r\n            bool isSent = msg.sender.call.gas(3000000).value(weiToReturn)();\r\n            require(isSent);\r\n            collectedUSDWEI = totalLimitUSDWEI; // to be sure!                                              \r\n        } else {\r\n            collectedUSDWEI += valueUSDWEI;\r\n        }\r\n        emitTokensFor(msg.sender, tokenPriceUSDWEI, valueUSDWEI, valueWEI);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint valueWEI = msg.value"
        VariableDeclaration "valueWEI"
           Type: uint256
           Source: "uint valueWEI"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member value
           Type: uint256
           Source: "msg.value"
          Identifier msg
             Type: msg
             Source: "msg"
      VariableDeclarationStatement
         Gas costs: 250
         Source: "uint valueUSDWEI = valueWEI * etherPriceUSDWEI / 1 ether"
        VariableDeclaration "valueUSDWEI"
           Type: uint256
           Source: "uint valueUSDWEI"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "valueWEI * etherPriceUSDWEI / 1 ether"
          BinaryOperation using operator *
             Type: uint256
             Source: "valueWEI * etherPriceUSDWEI"
            Identifier valueWEI
               Type: uint256
               Source: "valueWEI"
            Identifier etherPriceUSDWEI
               Type: uint256
               Source: "etherPriceUSDWEI"
          Literal, token: [no token] value: 1
             Type: int_const 1000000000000000000
             Source: "1 ether"
      VariableDeclarationStatement
         Gas costs: 12
         Source: "uint tokenPriceUSDWEI = getTokenPriceUSDWEI()"
        VariableDeclaration "tokenPriceUSDWEI"
           Type: uint256
           Source: "uint tokenPriceUSDWEI"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getTokenPriceUSDWEI()"
          Identifier getTokenPriceUSDWEI
             Type: function () returns (uint256)
             Source: "getTokenPriceUSDWEI"
      IfStatement
         Source: "if (collectedUSDWEI + valueUSDWEI > totalLimitUSDWEI) { // don't need so much ether\r\n            valueUSDWEI = totalLimitUSDWEI - collectedUSDWEI;\r\n            valueWEI = valueUSDWEI * 1 ether / etherPriceUSDWEI;\r\n            uint weiToReturn = msg.value - valueWEI;\r\n            bool isSent = msg.sender.call.gas(3000000).value(weiToReturn)();\r\n            require(isSent);\r\n            collectedUSDWEI = totalLimitUSDWEI; // to be sure!                                              \r\n        } else {\r\n            collectedUSDWEI += valueUSDWEI;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 415
           Source: "collectedUSDWEI + valueUSDWEI > totalLimitUSDWEI"
          BinaryOperation using operator +
             Type: uint256
             Source: "collectedUSDWEI + valueUSDWEI"
            Identifier collectedUSDWEI
               Type: uint256
               Source: "collectedUSDWEI"
            Identifier valueUSDWEI
               Type: uint256
               Source: "valueUSDWEI"
          Identifier totalLimitUSDWEI
             Type: uint256
             Source: "totalLimitUSDWEI"
        Block
           Source: "{ // don't need so much ether\r\n            valueUSDWEI = totalLimitUSDWEI - collectedUSDWEI;\r\n            valueWEI = valueUSDWEI * 1 ether / etherPriceUSDWEI;\r\n            uint weiToReturn = msg.value - valueWEI;\r\n            bool isSent = msg.sender.call.gas(3000000).value(weiToReturn)();\r\n            require(isSent);\r\n            collectedUSDWEI = totalLimitUSDWEI; // to be sure!                                              \r\n        }"
          ExpressionStatement
             Gas costs: 414
             Source: "valueUSDWEI = totalLimitUSDWEI - collectedUSDWEI"
            Assignment using operator =
               Type: uint256
               Source: "valueUSDWEI = totalLimitUSDWEI - collectedUSDWEI"
              Identifier valueUSDWEI
                 Type: uint256
                 Source: "valueUSDWEI"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "totalLimitUSDWEI - collectedUSDWEI"
                Identifier totalLimitUSDWEI
                   Type: uint256
                   Source: "totalLimitUSDWEI"
                Identifier collectedUSDWEI
                   Type: uint256
                   Source: "collectedUSDWEI"
          ExpressionStatement
             Gas costs: 247
             Source: "valueWEI = valueUSDWEI * 1 ether / etherPriceUSDWEI"
            Assignment using operator =
               Type: uint256
               Source: "valueWEI = valueUSDWEI * 1 ether / etherPriceUSDWEI"
              Identifier valueWEI
                 Type: uint256
                 Source: "valueWEI"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "valueUSDWEI * 1 ether / etherPriceUSDWEI"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "valueUSDWEI * 1 ether"
                  Identifier valueUSDWEI
                     Type: uint256
                     Source: "valueUSDWEI"
                  Literal, token: [no token] value: 1
                     Type: int_const 1000000000000000000
                     Source: "1 ether"
                Identifier etherPriceUSDWEI
                   Type: uint256
                   Source: "etherPriceUSDWEI"
          VariableDeclarationStatement
             Gas costs: 16
             Source: "uint weiToReturn = msg.value - valueWEI"
            VariableDeclaration "weiToReturn"
               Type: uint256
               Source: "uint weiToReturn"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator -
               Type: uint256
               Source: "msg.value - valueWEI"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier valueWEI
                 Type: uint256
                 Source: "valueWEI"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "bool isSent = msg.sender.call.gas(3000000).value(weiToReturn)()"
            VariableDeclaration "isSent"
               Type: bool
               Source: "bool isSent"
              ElementaryTypeName bool
                 Source: "bool"
            FunctionCall
               Type: bool
               Source: "msg.sender.call.gas(3000000).value(weiToReturn)()"
              FunctionCall
                 Type: function () payable returns (bool)
                 Source: "msg.sender.call.gas(3000000).value(weiToReturn)"
                MemberAccess to member value
                   Type: function (uint256) returns (function () payable returns (bool))
                   Source: "msg.sender.call.gas(3000000).value"
                  FunctionCall
                     Type: function () payable returns (bool)
                     Source: "msg.sender.call.gas(3000000)"
                    MemberAccess to member gas
                       Type: function (uint256) returns (function () payable returns (bool))
                       Source: "msg.sender.call.gas"
                      MemberAccess to member call
                         Type: function () payable returns (bool)
                         Source: "msg.sender.call"
                        MemberAccess to member sender
                           Type: address
                           Source: "msg.sender"
                          Identifier msg
                             Type: msg
                             Source: "msg"
                    Literal, token: [no token] value: 3000000
                       Type: int_const 3000000
                       Source: "3000000"
                Identifier weiToReturn
                   Type: uint256
                   Source: "weiToReturn"
          ExpressionStatement
             Gas costs: 29
             Source: "require(isSent)"
            FunctionCall
               Type: tuple()
               Source: "require(isSent)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              Identifier isSent
                 Type: bool
                 Source: "isSent"
          ExpressionStatement
             Gas costs: 20214
             Source: "collectedUSDWEI = totalLimitUSDWEI"
            Assignment using operator =
               Type: uint256
               Source: "collectedUSDWEI = totalLimitUSDWEI"
              Identifier collectedUSDWEI
                 Type: uint256
                 Source: "collectedUSDWEI"
              Identifier totalLimitUSDWEI
                 Type: uint256
                 Source: "totalLimitUSDWEI"
        Block
           Source: "{\r\n            collectedUSDWEI += valueUSDWEI;\r\n        }"
          ExpressionStatement
             Gas costs: 20233
             Source: "collectedUSDWEI += valueUSDWEI"
            Assignment using operator +=
               Type: uint256
               Source: "collectedUSDWEI += valueUSDWEI"
              Identifier collectedUSDWEI
                 Type: uint256
                 Source: "collectedUSDWEI"
              Identifier valueUSDWEI
                 Type: uint256
                 Source: "valueUSDWEI"
      ExpressionStatement
         Gas costs: 15
         Source: "emitTokensFor(msg.sender, tokenPriceUSDWEI, valueUSDWEI, valueWEI)"
        FunctionCall
           Type: tuple()
           Source: "emitTokensFor(msg.sender, tokenPriceUSDWEI, valueUSDWEI, valueWEI)"
          Identifier emitTokensFor
             Type: function (address,uint256,uint256,uint256)
             Source: "emitTokensFor"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier tokenPriceUSDWEI
             Type: uint256
             Source: "tokenPriceUSDWEI"
          Identifier valueUSDWEI
             Type: uint256
             Source: "valueUSDWEI"
          Identifier valueWEI
             Type: uint256
             Source: "valueWEI"
  FunctionDefinition "depositUSD" - public
     Source: "function depositUSD(address _to, uint _amountUSDWEI) external onlyOwner crowdsaleState limitNotExceeded crowdsaleNotFinished {\r\n        uint tokenPriceUSDWEI = getTokenPriceUSDWEI();\r\n        collectedUSDWEI += _amountUSDWEI;\r\n        emitTokensFor(_to, tokenPriceUSDWEI, _amountUSDWEI, 0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _amountUSDWEI)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amountUSDWEI"
         Type: uint256
         Source: "uint _amountUSDWEI"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "crowdsaleState"
       Gas costs: 0
       Source: "crowdsaleState"
      Identifier crowdsaleState
         Type: modifier ()
         Source: "crowdsaleState"
    ModifierInvocation "limitNotExceeded"
       Gas costs: 0
       Source: "limitNotExceeded"
      Identifier limitNotExceeded
         Type: modifier ()
         Source: "limitNotExceeded"
    ModifierInvocation "crowdsaleNotFinished"
       Gas costs: 0
       Source: "crowdsaleNotFinished"
      Identifier crowdsaleNotFinished
         Type: modifier ()
         Source: "crowdsaleNotFinished"
    Block
       Source: "{\r\n        uint tokenPriceUSDWEI = getTokenPriceUSDWEI();\r\n        collectedUSDWEI += _amountUSDWEI;\r\n        emitTokensFor(_to, tokenPriceUSDWEI, _amountUSDWEI, 0);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 23
         Source: "uint tokenPriceUSDWEI = getTokenPriceUSDWEI()"
        VariableDeclaration "tokenPriceUSDWEI"
           Type: uint256
           Source: "uint tokenPriceUSDWEI"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getTokenPriceUSDWEI()"
          Identifier getTokenPriceUSDWEI
             Type: function () returns (uint256)
             Source: "getTokenPriceUSDWEI"
      ExpressionStatement
         Gas costs: 20233
         Source: "collectedUSDWEI += _amountUSDWEI"
        Assignment using operator +=
           Type: uint256
           Source: "collectedUSDWEI += _amountUSDWEI"
          Identifier collectedUSDWEI
             Type: uint256
             Source: "collectedUSDWEI"
          Identifier _amountUSDWEI
             Type: uint256
             Source: "_amountUSDWEI"
      ExpressionStatement
         Gas costs: 27
         Source: "emitTokensFor(_to, tokenPriceUSDWEI, _amountUSDWEI, 0)"
        FunctionCall
           Type: tuple()
           Source: "emitTokensFor(_to, tokenPriceUSDWEI, _amountUSDWEI, 0)"
          Identifier emitTokensFor
             Type: function (address,uint256,uint256,uint256)
             Source: "emitTokensFor"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier tokenPriceUSDWEI
             Type: uint256
             Source: "tokenPriceUSDWEI"
          Identifier _amountUSDWEI
             Type: uint256
             Source: "_amountUSDWEI"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "depositBTC" - public
     Source: "function depositBTC(address _to, uint _amountBTCWEI, uint _btcPriceUSDWEI, bytes32 _btcTxId) external onlyOwnerOrBtcOracle crowdsaleState limitNotExceeded crowdsaleNotFinished {\r\n        uint valueUSDWEI = _amountBTCWEI * _btcPriceUSDWEI / 1 ether;\r\n        uint tokenPriceUSDWEI = getTokenPriceUSDWEI();\r\n        BtcDeposit storage btcDep = btcDeposits[_btcTxId];\r\n        require(btcDep.amountBTCWEI == 0);\r\n        btcDep.amountBTCWEI = _amountBTCWEI;\r\n        btcDep.btcPriceUSDWEI = _btcPriceUSDWEI;\r\n        btcDep.investor = _to;\r\n        collectedUSDWEI += valueUSDWEI;\r\n        emitTokensFor(_to, tokenPriceUSDWEI, valueUSDWEI, 0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _amountBTCWEI, uint _btcPriceUSDWEI, bytes32 _btcTxId)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amountBTCWEI"
         Type: uint256
         Source: "uint _amountBTCWEI"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_btcPriceUSDWEI"
         Type: uint256
         Source: "uint _btcPriceUSDWEI"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_btcTxId"
         Type: bytes32
         Source: "bytes32 _btcTxId"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwnerOrBtcOracle"
       Gas costs: 0
       Source: "onlyOwnerOrBtcOracle"
      Identifier onlyOwnerOrBtcOracle
         Type: modifier ()
         Source: "onlyOwnerOrBtcOracle"
    ModifierInvocation "crowdsaleState"
       Gas costs: 0
       Source: "crowdsaleState"
      Identifier crowdsaleState
         Type: modifier ()
         Source: "crowdsaleState"
    ModifierInvocation "limitNotExceeded"
       Gas costs: 0
       Source: "limitNotExceeded"
      Identifier limitNotExceeded
         Type: modifier ()
         Source: "limitNotExceeded"
    ModifierInvocation "crowdsaleNotFinished"
       Gas costs: 0
       Source: "crowdsaleNotFinished"
      Identifier crowdsaleNotFinished
         Type: modifier ()
         Source: "crowdsaleNotFinished"
    Block
       Source: "{\r\n        uint valueUSDWEI = _amountBTCWEI * _btcPriceUSDWEI / 1 ether;\r\n        uint tokenPriceUSDWEI = getTokenPriceUSDWEI();\r\n        BtcDeposit storage btcDep = btcDeposits[_btcTxId];\r\n        require(btcDep.amountBTCWEI == 0);\r\n        btcDep.amountBTCWEI = _amountBTCWEI;\r\n        btcDep.btcPriceUSDWEI = _btcPriceUSDWEI;\r\n        btcDep.investor = _to;\r\n        collectedUSDWEI += valueUSDWEI;\r\n        emitTokensFor(_to, tokenPriceUSDWEI, valueUSDWEI, 0);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 50
         Source: "uint valueUSDWEI = _amountBTCWEI * _btcPriceUSDWEI / 1 ether"
        VariableDeclaration "valueUSDWEI"
           Type: uint256
           Source: "uint valueUSDWEI"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "_amountBTCWEI * _btcPriceUSDWEI / 1 ether"
          BinaryOperation using operator *
             Type: uint256
             Source: "_amountBTCWEI * _btcPriceUSDWEI"
            Identifier _amountBTCWEI
               Type: uint256
               Source: "_amountBTCWEI"
            Identifier _btcPriceUSDWEI
               Type: uint256
               Source: "_btcPriceUSDWEI"
          Literal, token: [no token] value: 1
             Type: int_const 1000000000000000000
             Source: "1 ether"
      VariableDeclarationStatement
         Gas costs: 23
         Source: "uint tokenPriceUSDWEI = getTokenPriceUSDWEI()"
        VariableDeclaration "tokenPriceUSDWEI"
           Type: uint256
           Source: "uint tokenPriceUSDWEI"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getTokenPriceUSDWEI()"
          Identifier getTokenPriceUSDWEI
             Type: function () returns (uint256)
             Source: "getTokenPriceUSDWEI"
      VariableDeclarationStatement
         Gas costs: 113
         Source: "BtcDeposit storage btcDep = btcDeposits[_btcTxId]"
        VariableDeclaration "btcDep"
           Type: struct Crowdsale.BtcDeposit storage pointer
           Source: "BtcDeposit storage btcDep"
          UserDefinedTypeName "BtcDeposit"
             Source: "BtcDeposit"
        IndexAccess
           Type: struct Crowdsale.BtcDeposit storage ref
           Source: "btcDeposits[_btcTxId]"
          Identifier btcDeposits
             Type: mapping(bytes32 => struct Crowdsale.BtcDeposit storage ref)
             Source: "btcDeposits"
          Identifier _btcTxId
             Type: bytes32
             Source: "_btcTxId"
      ExpressionStatement
         Gas costs: 241
         Source: "require(btcDep.amountBTCWEI == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(btcDep.amountBTCWEI == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "btcDep.amountBTCWEI == 0"
            MemberAccess to member amountBTCWEI
               Type: uint256
               Source: "btcDep.amountBTCWEI"
              Identifier btcDep
                 Type: struct Crowdsale.BtcDeposit storage pointer
                 Source: "btcDep"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20020
         Source: "btcDep.amountBTCWEI = _amountBTCWEI"
        Assignment using operator =
           Type: uint256
           Source: "btcDep.amountBTCWEI = _amountBTCWEI"
          MemberAccess to member amountBTCWEI
             Type: uint256
             Source: "btcDep.amountBTCWEI"
            Identifier btcDep
               Type: struct Crowdsale.BtcDeposit storage pointer
               Source: "btcDep"
          Identifier _amountBTCWEI
             Type: uint256
             Source: "_amountBTCWEI"
      ExpressionStatement
         Gas costs: 20020
         Source: "btcDep.btcPriceUSDWEI = _btcPriceUSDWEI"
        Assignment using operator =
           Type: uint256
           Source: "btcDep.btcPriceUSDWEI = _btcPriceUSDWEI"
          MemberAccess to member btcPriceUSDWEI
             Type: uint256
             Source: "btcDep.btcPriceUSDWEI"
            Identifier btcDep
               Type: struct Crowdsale.BtcDeposit storage pointer
               Source: "btcDep"
          Identifier _btcPriceUSDWEI
             Type: uint256
             Source: "_btcPriceUSDWEI"
      ExpressionStatement
         Gas costs: 20273
         Source: "btcDep.investor = _to"
        Assignment using operator =
           Type: address
           Source: "btcDep.investor = _to"
          MemberAccess to member investor
             Type: address
             Source: "btcDep.investor"
            Identifier btcDep
               Type: struct Crowdsale.BtcDeposit storage pointer
               Source: "btcDep"
          Identifier _to
             Type: address
             Source: "_to"
      ExpressionStatement
         Gas costs: 20233
         Source: "collectedUSDWEI += valueUSDWEI"
        Assignment using operator +=
           Type: uint256
           Source: "collectedUSDWEI += valueUSDWEI"
          Identifier collectedUSDWEI
             Type: uint256
             Source: "collectedUSDWEI"
          Identifier valueUSDWEI
             Type: uint256
             Source: "valueUSDWEI"
      ExpressionStatement
         Gas costs: 27
         Source: "emitTokensFor(_to, tokenPriceUSDWEI, valueUSDWEI, 0)"
        FunctionCall
           Type: tuple()
           Source: "emitTokensFor(_to, tokenPriceUSDWEI, valueUSDWEI, 0)"
          Identifier emitTokensFor
             Type: function (address,uint256,uint256,uint256)
             Source: "emitTokensFor"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier tokenPriceUSDWEI
             Type: uint256
             Source: "tokenPriceUSDWEI"
          Identifier valueUSDWEI
             Type: uint256
             Source: "valueUSDWEI"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "emitTokensFor"
     Source: "function emitTokensFor(address _investor, uint _tokenPriceUSDWEI, uint _valueUSDWEI, uint _valueWEI) internal {\r\n        var emittedTokens = emitTokens(_investor, _tokenPriceUSDWEI, _valueUSDWEI);\r\n        Investor storage inv = investors[_investor];\r\n        if (inv.amountTokens == 0) { // new investor\r\n            investorsIter[numberOfInvestors++] = _investor;\r\n        }\r\n        inv.amountTokens += emittedTokens;\r\n        if (state == State.Sale) {\r\n            inv.amountWei += _valueWEI;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _investor, uint _tokenPriceUSDWEI, uint _valueUSDWEI, uint _valueWEI)"
      VariableDeclaration "_investor"
         Type: address
         Source: "address _investor"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokenPriceUSDWEI"
         Type: uint256
         Source: "uint _tokenPriceUSDWEI"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_valueUSDWEI"
         Type: uint256
         Source: "uint _valueUSDWEI"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_valueWEI"
         Type: uint256
         Source: "uint _valueWEI"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        var emittedTokens = emitTokens(_investor, _tokenPriceUSDWEI, _valueUSDWEI);\r\n        Investor storage inv = investors[_investor];\r\n        if (inv.amountTokens == 0) { // new investor\r\n            investorsIter[numberOfInvestors++] = _investor;\r\n        }\r\n        inv.amountTokens += emittedTokens;\r\n        if (state == State.Sale) {\r\n            inv.amountWei += _valueWEI;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 21
         Source: "var emittedTokens = emitTokens(_investor, _tokenPriceUSDWEI, _valueUSDWEI)"
        VariableDeclaration "emittedTokens"
           Type: uint256
           Source: "var emittedTokens"
        FunctionCall
           Type: uint256
           Source: "emitTokens(_investor, _tokenPriceUSDWEI, _valueUSDWEI)"
          Identifier emitTokens
             Type: function (address,uint256,uint256) returns (uint256)
             Source: "emitTokens"
          Identifier _investor
             Type: address
             Source: "_investor"
          Identifier _tokenPriceUSDWEI
             Type: uint256
             Source: "_tokenPriceUSDWEI"
          Identifier _valueUSDWEI
             Type: uint256
             Source: "_valueUSDWEI"
      VariableDeclarationStatement
         Gas costs: 107
         Source: "Investor storage inv = investors[_investor]"
        VariableDeclaration "inv"
           Type: struct Crowdsale.Investor storage pointer
           Source: "Investor storage inv"
          UserDefinedTypeName "Investor"
             Source: "Investor"
        IndexAccess
           Type: struct Crowdsale.Investor storage ref
           Source: "investors[_investor]"
          Identifier investors
             Type: mapping(address => struct Crowdsale.Investor storage ref)
             Source: "investors"
          Identifier _investor
             Type: address
             Source: "_investor"
      IfStatement
         Source: "if (inv.amountTokens == 0) { // new investor\r\n            investorsIter[numberOfInvestors++] = _investor;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 215
           Source: "inv.amountTokens == 0"
          MemberAccess to member amountTokens
             Type: uint256
             Source: "inv.amountTokens"
            Identifier inv
               Type: struct Crowdsale.Investor storage pointer
               Source: "inv"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{ // new investor\r\n            investorsIter[numberOfInvestors++] = _investor;\r\n        }"
          ExpressionStatement
             Gas costs: 40583
             Source: "investorsIter[numberOfInvestors++] = _investor"
            Assignment using operator =
               Type: address
               Source: "investorsIter[numberOfInvestors++] = _investor"
              IndexAccess
                 Type: address
                 Source: "investorsIter[numberOfInvestors++]"
                Identifier investorsIter
                   Type: mapping(uint256 => address)
                   Source: "investorsIter"
                UnaryOperation (postfix) ++
                   Type: uint256
                   Source: "numberOfInvestors++"
                  Identifier numberOfInvestors
                     Type: uint256
                     Source: "numberOfInvestors"
              Identifier _investor
                 Type: address
                 Source: "_investor"
      ExpressionStatement
         Gas costs: 20239
         Source: "inv.amountTokens += emittedTokens"
        Assignment using operator +=
           Type: uint256
           Source: "inv.amountTokens += emittedTokens"
          MemberAccess to member amountTokens
             Type: uint256
             Source: "inv.amountTokens"
            Identifier inv
               Type: struct Crowdsale.Investor storage pointer
               Source: "inv"
          Identifier emittedTokens
             Type: uint256
             Source: "emittedTokens"
      IfStatement
         Source: "if (state == State.Sale) {\r\n            inv.amountWei += _valueWEI;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 347
           Source: "state == State.Sale"
          Identifier state
             Type: enum Stateful.State
             Source: "state"
          MemberAccess to member Sale
             Type: enum Stateful.State
             Source: "State.Sale"
            Identifier State
               Type: type(enum Stateful.State)
               Source: "State"
        Block
           Source: "{\r\n            inv.amountWei += _valueWEI;\r\n        }"
          ExpressionStatement
             Gas costs: 20239
             Source: "inv.amountWei += _valueWEI"
            Assignment using operator +=
               Type: uint256
               Source: "inv.amountWei += _valueWEI"
              MemberAccess to member amountWei
                 Type: uint256
                 Source: "inv.amountWei"
                Identifier inv
                   Type: struct Crowdsale.Investor storage pointer
                   Source: "inv"
              Identifier _valueWEI
                 Type: uint256
                 Source: "_valueWEI"
  FunctionDefinition "getTokenPriceUSDWEI"
     Source: "function getTokenPriceUSDWEI() internal returns(uint tokenPriceUSDWEI) {\r\n        tokenPriceUSDWEI = 0;\r\n        if (state == State.PreSale) {\r\n            tokenPriceUSDWEI = 76923076923076900;\r\n        }\r\n        if (state == State.Sale) {\r\n            if (now < crowdsaleStartTime + 1 days) {\r\n                tokenPriceUSDWEI = 86956521730000000;\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokenPriceUSDWEI = 90909090900000000;\r\n            } else if (now < crowdsaleStartTime + 2 weeks) {\r\n                tokenPriceUSDWEI = 95238095230000000;\r\n            } else {\r\n                tokenPriceUSDWEI = 100000000000000000;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint tokenPriceUSDWEI)"
      VariableDeclaration "tokenPriceUSDWEI"
         Type: uint256
         Source: "uint tokenPriceUSDWEI"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        tokenPriceUSDWEI = 0;\r\n        if (state == State.PreSale) {\r\n            tokenPriceUSDWEI = 76923076923076900;\r\n        }\r\n        if (state == State.Sale) {\r\n            if (now < crowdsaleStartTime + 1 days) {\r\n                tokenPriceUSDWEI = 86956521730000000;\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokenPriceUSDWEI = 90909090900000000;\r\n            } else if (now < crowdsaleStartTime + 2 weeks) {\r\n                tokenPriceUSDWEI = 95238095230000000;\r\n            } else {\r\n                tokenPriceUSDWEI = 100000000000000000;\r\n            }\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 8
         Source: "tokenPriceUSDWEI = 0"
        Assignment using operator =
           Type: uint256
           Source: "tokenPriceUSDWEI = 0"
          Identifier tokenPriceUSDWEI
             Type: uint256
             Source: "tokenPriceUSDWEI"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      IfStatement
         Source: "if (state == State.PreSale) {\r\n            tokenPriceUSDWEI = 76923076923076900;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 347
           Source: "state == State.PreSale"
          Identifier state
             Type: enum Stateful.State
             Source: "state"
          MemberAccess to member PreSale
             Type: enum Stateful.State
             Source: "State.PreSale"
            Identifier State
               Type: type(enum Stateful.State)
               Source: "State"
        Block
           Source: "{\r\n            tokenPriceUSDWEI = 76923076923076900;\r\n        }"
          ExpressionStatement
             Gas costs: 8
             Source: "tokenPriceUSDWEI = 76923076923076900"
            Assignment using operator =
               Type: uint256
               Source: "tokenPriceUSDWEI = 76923076923076900"
              Identifier tokenPriceUSDWEI
                 Type: uint256
                 Source: "tokenPriceUSDWEI"
              Literal, token: [no token] value: 76923076923076900
                 Type: int_const 76923076923076900
                 Source: "76923076923076900"
      IfStatement
         Source: "if (state == State.Sale) {\r\n            if (now < crowdsaleStartTime + 1 days) {\r\n                tokenPriceUSDWEI = 86956521730000000;\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokenPriceUSDWEI = 90909090900000000;\r\n            } else if (now < crowdsaleStartTime + 2 weeks) {\r\n                tokenPriceUSDWEI = 95238095230000000;\r\n            } else {\r\n                tokenPriceUSDWEI = 100000000000000000;\r\n            }\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 347
           Source: "state == State.Sale"
          Identifier state
             Type: enum Stateful.State
             Source: "state"
          MemberAccess to member Sale
             Type: enum Stateful.State
             Source: "State.Sale"
            Identifier State
               Type: type(enum Stateful.State)
               Source: "State"
        Block
           Source: "{\r\n            if (now < crowdsaleStartTime + 1 days) {\r\n                tokenPriceUSDWEI = 86956521730000000;\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokenPriceUSDWEI = 90909090900000000;\r\n            } else if (now < crowdsaleStartTime + 2 weeks) {\r\n                tokenPriceUSDWEI = 95238095230000000;\r\n            } else {\r\n                tokenPriceUSDWEI = 100000000000000000;\r\n            }\r\n        }"
          IfStatement
             Source: "if (now < crowdsaleStartTime + 1 days) {\r\n                tokenPriceUSDWEI = 86956521730000000;\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokenPriceUSDWEI = 90909090900000000;\r\n            } else if (now < crowdsaleStartTime + 2 weeks) {\r\n                tokenPriceUSDWEI = 95238095230000000;\r\n            } else {\r\n                tokenPriceUSDWEI = 100000000000000000;\r\n            }"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 214
               Source: "now < crowdsaleStartTime + 1 days"
              Identifier now
                 Type: uint256
                 Source: "now"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "crowdsaleStartTime + 1 days"
                Identifier crowdsaleStartTime
                   Type: uint256
                   Source: "crowdsaleStartTime"
                Literal, token: [no token] value: 1
                   Type: int_const 86400
                   Source: "1 days"
            Block
               Source: "{\r\n                tokenPriceUSDWEI = 86956521730000000;\r\n            }"
              ExpressionStatement
                 Gas costs: 8
                 Source: "tokenPriceUSDWEI = 86956521730000000"
                Assignment using operator =
                   Type: uint256
                   Source: "tokenPriceUSDWEI = 86956521730000000"
                  Identifier tokenPriceUSDWEI
                     Type: uint256
                     Source: "tokenPriceUSDWEI"
                  Literal, token: [no token] value: 86956521730000000
                     Type: int_const 86956521730000000
                     Source: "86956521730000000"
            IfStatement
               Source: "if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokenPriceUSDWEI = 90909090900000000;\r\n            } else if (now < crowdsaleStartTime + 2 weeks) {\r\n                tokenPriceUSDWEI = 95238095230000000;\r\n            } else {\r\n                tokenPriceUSDWEI = 100000000000000000;\r\n            }"
              BinaryOperation using operator <
                 Type: bool
                 Gas costs: 214
                 Source: "now < crowdsaleStartTime + 1 weeks"
                Identifier now
                   Type: uint256
                   Source: "now"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "crowdsaleStartTime + 1 weeks"
                  Identifier crowdsaleStartTime
                     Type: uint256
                     Source: "crowdsaleStartTime"
                  Literal, token: [no token] value: 1
                     Type: int_const 604800
                     Source: "1 weeks"
              Block
                 Source: "{\r\n                tokenPriceUSDWEI = 90909090900000000;\r\n            }"
                ExpressionStatement
                   Gas costs: 8
                   Source: "tokenPriceUSDWEI = 90909090900000000"
                  Assignment using operator =
                     Type: uint256
                     Source: "tokenPriceUSDWEI = 90909090900000000"
                    Identifier tokenPriceUSDWEI
                       Type: uint256
                       Source: "tokenPriceUSDWEI"
                    Literal, token: [no token] value: 90909090900000000
                       Type: int_const 90909090900000000
                       Source: "90909090900000000"
              IfStatement
                 Source: "if (now < crowdsaleStartTime + 2 weeks) {\r\n                tokenPriceUSDWEI = 95238095230000000;\r\n            } else {\r\n                tokenPriceUSDWEI = 100000000000000000;\r\n            }"
                BinaryOperation using operator <
                   Type: bool
                   Gas costs: 214
                   Source: "now < crowdsaleStartTime + 2 weeks"
                  Identifier now
                     Type: uint256
                     Source: "now"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "crowdsaleStartTime + 2 weeks"
                    Identifier crowdsaleStartTime
                       Type: uint256
                       Source: "crowdsaleStartTime"
                    Literal, token: [no token] value: 2
                       Type: int_const 1209600
                       Source: "2 weeks"
                Block
                   Source: "{\r\n                tokenPriceUSDWEI = 95238095230000000;\r\n            }"
                  ExpressionStatement
                     Gas costs: 8
                     Source: "tokenPriceUSDWEI = 95238095230000000"
                    Assignment using operator =
                       Type: uint256
                       Source: "tokenPriceUSDWEI = 95238095230000000"
                      Identifier tokenPriceUSDWEI
                         Type: uint256
                         Source: "tokenPriceUSDWEI"
                      Literal, token: [no token] value: 95238095230000000
                         Type: int_const 95238095230000000
                         Source: "95238095230000000"
                Block
                   Source: "{\r\n                tokenPriceUSDWEI = 100000000000000000;\r\n            }"
                  ExpressionStatement
                     Gas costs: 8
                     Source: "tokenPriceUSDWEI = 100000000000000000"
                    Assignment using operator =
                       Type: uint256
                       Source: "tokenPriceUSDWEI = 100000000000000000"
                      Identifier tokenPriceUSDWEI
                         Type: uint256
                         Source: "tokenPriceUSDWEI"
                      Literal, token: [no token] value: 100000000000000000
                         Type: int_const 100000000000000000
                         Source: "100000000000000000"
  FunctionDefinition "startPreSale" - public
     Source: "function startPreSale(\r\n        address _beneficiary,\r\n        uint _etherPriceUSDWEI,\r\n        uint _totalLimitUSDWEI,\r\n        uint _crowdsaleDurationDays) external onlyOwner {\r\n        require(state == State.Initial);\r\n        crowdsaleStartTime = now;\r\n        beneficiary = _beneficiary;\r\n        etherPriceUSDWEI = _etherPriceUSDWEI;\r\n        totalLimitUSDWEI = _totalLimitUSDWEI;\r\n        crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days;\r\n        collectedUSDWEI = 0;\r\n        setState(State.PreSale);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _beneficiary,\r\n        uint _etherPriceUSDWEI,\r\n        uint _totalLimitUSDWEI,\r\n        uint _crowdsaleDurationDays)"
      VariableDeclaration "_beneficiary"
         Type: address
         Source: "address _beneficiary"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_etherPriceUSDWEI"
         Type: uint256
         Source: "uint _etherPriceUSDWEI"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_totalLimitUSDWEI"
         Type: uint256
         Source: "uint _totalLimitUSDWEI"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_crowdsaleDurationDays"
         Type: uint256
         Source: "uint _crowdsaleDurationDays"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(state == State.Initial);\r\n        crowdsaleStartTime = now;\r\n        beneficiary = _beneficiary;\r\n        etherPriceUSDWEI = _etherPriceUSDWEI;\r\n        totalLimitUSDWEI = _totalLimitUSDWEI;\r\n        crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days;\r\n        collectedUSDWEI = 0;\r\n        setState(State.PreSale);\r\n    }"
      ExpressionStatement
         Gas costs: 373
         Source: "require(state == State.Initial)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.Initial)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "state == State.Initial"
            Identifier state
               Type: enum Stateful.State
               Source: "state"
            MemberAccess to member Initial
               Type: enum Stateful.State
               Source: "State.Initial"
              Identifier State
                 Type: type(enum Stateful.State)
                 Source: "State"
      ExpressionStatement
         Gas costs: 20013
         Source: "crowdsaleStartTime = now"
        Assignment using operator =
           Type: uint256
           Source: "crowdsaleStartTime = now"
          Identifier crowdsaleStartTime
             Type: uint256
             Source: "crowdsaleStartTime"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 20267
         Source: "beneficiary = _beneficiary"
        Assignment using operator =
           Type: address
           Source: "beneficiary = _beneficiary"
          Identifier beneficiary
             Type: address
             Source: "beneficiary"
          Identifier _beneficiary
             Type: address
             Source: "_beneficiary"
      ExpressionStatement
         Gas costs: 20014
         Source: "etherPriceUSDWEI = _etherPriceUSDWEI"
        Assignment using operator =
           Type: uint256
           Source: "etherPriceUSDWEI = _etherPriceUSDWEI"
          Identifier etherPriceUSDWEI
             Type: uint256
             Source: "etherPriceUSDWEI"
          Identifier _etherPriceUSDWEI
             Type: uint256
             Source: "_etherPriceUSDWEI"
      ExpressionStatement
         Gas costs: 20014
         Source: "totalLimitUSDWEI = _totalLimitUSDWEI"
        Assignment using operator =
           Type: uint256
           Source: "totalLimitUSDWEI = _totalLimitUSDWEI"
          Identifier totalLimitUSDWEI
             Type: uint256
             Source: "totalLimitUSDWEI"
          Identifier _totalLimitUSDWEI
             Type: uint256
             Source: "_totalLimitUSDWEI"
      ExpressionStatement
         Gas costs: 20027
         Source: "crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days"
        Assignment using operator =
           Type: uint256
           Source: "crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days"
          Identifier crowdsaleFinishTime
             Type: uint256
             Source: "crowdsaleFinishTime"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + _crowdsaleDurationDays * 1 days"
            Identifier now
               Type: uint256
               Source: "now"
            BinaryOperation using operator *
               Type: uint256
               Source: "_crowdsaleDurationDays * 1 days"
              Identifier _crowdsaleDurationDays
                 Type: uint256
                 Source: "_crowdsaleDurationDays"
              Literal, token: [no token] value: 1
                 Type: int_const 86400
                 Source: "1 days"
      ExpressionStatement
         Gas costs: 5014
         Source: "collectedUSDWEI = 0"
        Assignment using operator =
           Type: uint256
           Source: "collectedUSDWEI = 0"
          Identifier collectedUSDWEI
             Type: uint256
             Source: "collectedUSDWEI"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 18
         Source: "setState(State.PreSale)"
        FunctionCall
           Type: tuple()
           Source: "setState(State.PreSale)"
          Identifier setState
             Type: function (enum Stateful.State)
             Source: "setState"
          MemberAccess to member PreSale
             Type: enum Stateful.State
             Source: "State.PreSale"
            Identifier State
               Type: type(enum Stateful.State)
               Source: "State"
  FunctionDefinition "finishPreSale" - public
     Source: "function finishPreSale() public onlyOwner {\r\n        require(state == State.PreSale);\r\n        bool isSent = beneficiary.call.gas(3000000).value(this.balance)();\r\n        require(isSent);\r\n        setState(State.WaitingForSale);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(state == State.PreSale);\r\n        bool isSent = beneficiary.call.gas(3000000).value(this.balance)();\r\n        require(isSent);\r\n        setState(State.WaitingForSale);\r\n    }"
      ExpressionStatement
         Gas costs: 373
         Source: "require(state == State.PreSale)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.PreSale)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "state == State.PreSale"
            Identifier state
               Type: enum Stateful.State
               Source: "state"
            MemberAccess to member PreSale
               Type: enum Stateful.State
               Source: "State.PreSale"
              Identifier State
                 Type: type(enum Stateful.State)
                 Source: "State"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "bool isSent = beneficiary.call.gas(3000000).value(this.balance)()"
        VariableDeclaration "isSent"
           Type: bool
           Source: "bool isSent"
          ElementaryTypeName bool
             Source: "bool"
        FunctionCall
           Type: bool
           Source: "beneficiary.call.gas(3000000).value(this.balance)()"
          FunctionCall
             Type: function () payable returns (bool)
             Source: "beneficiary.call.gas(3000000).value(this.balance)"
            MemberAccess to member value
               Type: function (uint256) returns (function () payable returns (bool))
               Source: "beneficiary.call.gas(3000000).value"
              FunctionCall
                 Type: function () payable returns (bool)
                 Source: "beneficiary.call.gas(3000000)"
                MemberAccess to member gas
                   Type: function (uint256) returns (function () payable returns (bool))
                   Source: "beneficiary.call.gas"
                  MemberAccess to member call
                     Type: function () payable returns (bool)
                     Source: "beneficiary.call"
                    Identifier beneficiary
                       Type: address
                       Source: "beneficiary"
                Literal, token: [no token] value: 3000000
                   Type: int_const 3000000
                   Source: "3000000"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract Crowdsale
                 Source: "this"
      ExpressionStatement
         Gas costs: 29
         Source: "require(isSent)"
        FunctionCall
           Type: tuple()
           Source: "require(isSent)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier isSent
             Type: bool
             Source: "isSent"
      ExpressionStatement
         Gas costs: 18
         Source: "setState(State.WaitingForSale)"
        FunctionCall
           Type: tuple()
           Source: "setState(State.WaitingForSale)"
          Identifier setState
             Type: function (enum Stateful.State)
             Source: "setState"
          MemberAccess to member WaitingForSale
             Type: enum Stateful.State
             Source: "State.WaitingForSale"
            Identifier State
               Type: type(enum Stateful.State)
               Source: "State"
  FunctionDefinition "startSale" - public
     Source: "function startSale(\r\n        address _beneficiary,\r\n        uint _etherPriceUSDWEI,\r\n        uint _totalLimitUSDWEI,\r\n        uint _crowdsaleDurationDays,\r\n        uint _minimalSuccessUSDWEI) external onlyOwner {\r\n\r\n        require(state == State.WaitingForSale);\r\n        crowdsaleStartTime = now;\r\n        beneficiary = _beneficiary;\r\n        etherPriceUSDWEI = _etherPriceUSDWEI;\r\n        totalLimitUSDWEI = _totalLimitUSDWEI;\r\n        crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days;\r\n        minimalSuccessUSDWEI = _minimalSuccessUSDWEI;\r\n        collectedUSDWEI = 0;\r\n        setState(State.Sale);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _beneficiary,\r\n        uint _etherPriceUSDWEI,\r\n        uint _totalLimitUSDWEI,\r\n        uint _crowdsaleDurationDays,\r\n        uint _minimalSuccessUSDWEI)"
      VariableDeclaration "_beneficiary"
         Type: address
         Source: "address _beneficiary"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_etherPriceUSDWEI"
         Type: uint256
         Source: "uint _etherPriceUSDWEI"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_totalLimitUSDWEI"
         Type: uint256
         Source: "uint _totalLimitUSDWEI"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_crowdsaleDurationDays"
         Type: uint256
         Source: "uint _crowdsaleDurationDays"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_minimalSuccessUSDWEI"
         Type: uint256
         Source: "uint _minimalSuccessUSDWEI"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n\r\n        require(state == State.WaitingForSale);\r\n        crowdsaleStartTime = now;\r\n        beneficiary = _beneficiary;\r\n        etherPriceUSDWEI = _etherPriceUSDWEI;\r\n        totalLimitUSDWEI = _totalLimitUSDWEI;\r\n        crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days;\r\n        minimalSuccessUSDWEI = _minimalSuccessUSDWEI;\r\n        collectedUSDWEI = 0;\r\n        setState(State.Sale);\r\n    }"
      ExpressionStatement
         Gas costs: 373
         Source: "require(state == State.WaitingForSale)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.WaitingForSale)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "state == State.WaitingForSale"
            Identifier state
               Type: enum Stateful.State
               Source: "state"
            MemberAccess to member WaitingForSale
               Type: enum Stateful.State
               Source: "State.WaitingForSale"
              Identifier State
                 Type: type(enum Stateful.State)
                 Source: "State"
      ExpressionStatement
         Gas costs: 20013
         Source: "crowdsaleStartTime = now"
        Assignment using operator =
           Type: uint256
           Source: "crowdsaleStartTime = now"
          Identifier crowdsaleStartTime
             Type: uint256
             Source: "crowdsaleStartTime"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 20267
         Source: "beneficiary = _beneficiary"
        Assignment using operator =
           Type: address
           Source: "beneficiary = _beneficiary"
          Identifier beneficiary
             Type: address
             Source: "beneficiary"
          Identifier _beneficiary
             Type: address
             Source: "_beneficiary"
      ExpressionStatement
         Gas costs: 20014
         Source: "etherPriceUSDWEI = _etherPriceUSDWEI"
        Assignment using operator =
           Type: uint256
           Source: "etherPriceUSDWEI = _etherPriceUSDWEI"
          Identifier etherPriceUSDWEI
             Type: uint256
             Source: "etherPriceUSDWEI"
          Identifier _etherPriceUSDWEI
             Type: uint256
             Source: "_etherPriceUSDWEI"
      ExpressionStatement
         Gas costs: 20014
         Source: "totalLimitUSDWEI = _totalLimitUSDWEI"
        Assignment using operator =
           Type: uint256
           Source: "totalLimitUSDWEI = _totalLimitUSDWEI"
          Identifier totalLimitUSDWEI
             Type: uint256
             Source: "totalLimitUSDWEI"
          Identifier _totalLimitUSDWEI
             Type: uint256
             Source: "_totalLimitUSDWEI"
      ExpressionStatement
         Gas costs: 20027
         Source: "crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days"
        Assignment using operator =
           Type: uint256
           Source: "crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days"
          Identifier crowdsaleFinishTime
             Type: uint256
             Source: "crowdsaleFinishTime"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + _crowdsaleDurationDays * 1 days"
            Identifier now
               Type: uint256
               Source: "now"
            BinaryOperation using operator *
               Type: uint256
               Source: "_crowdsaleDurationDays * 1 days"
              Identifier _crowdsaleDurationDays
                 Type: uint256
                 Source: "_crowdsaleDurationDays"
              Literal, token: [no token] value: 1
                 Type: int_const 86400
                 Source: "1 days"
      ExpressionStatement
         Gas costs: 20014
         Source: "minimalSuccessUSDWEI = _minimalSuccessUSDWEI"
        Assignment using operator =
           Type: uint256
           Source: "minimalSuccessUSDWEI = _minimalSuccessUSDWEI"
          Identifier minimalSuccessUSDWEI
             Type: uint256
             Source: "minimalSuccessUSDWEI"
          Identifier _minimalSuccessUSDWEI
             Type: uint256
             Source: "_minimalSuccessUSDWEI"
      ExpressionStatement
         Gas costs: 5014
         Source: "collectedUSDWEI = 0"
        Assignment using operator =
           Type: uint256
           Source: "collectedUSDWEI = 0"
          Identifier collectedUSDWEI
             Type: uint256
             Source: "collectedUSDWEI"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 7
         Source: "setState(State.Sale)"
        FunctionCall
           Type: tuple()
           Source: "setState(State.Sale)"
          Identifier setState
             Type: function (enum Stateful.State)
             Source: "setState"
          MemberAccess to member Sale
             Type: enum Stateful.State
             Source: "State.Sale"
            Identifier State
               Type: type(enum Stateful.State)
               Source: "State"
  FunctionDefinition "failSale" - public
     Source: "function failSale(uint _investorsToProcess) public {\r\n        require(state == State.Sale);\r\n        require(now >= crowdsaleFinishTime && collectedUSDWEI < minimalSuccessUSDWEI);\r\n        while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n            address addr = investorsIter[--numberOfInvestors];\r\n            Investor memory inv = investors[addr];\r\n            burnTokens(addr, inv.amountTokens);\r\n            --_investorsToProcess;\r\n            delete investorsIter[numberOfInvestors];\r\n\r\n            investorsToWithdrawIter[numberOfInvestorsToWithdraw] = addr;\r\n            numberOfInvestorsToWithdraw++;\r\n        }\r\n        if (numberOfInvestors > 0) {\r\n            return;\r\n        }\r\n        setState(State.SaleFailed);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _investorsToProcess)"
      VariableDeclaration "_investorsToProcess"
         Type: uint256
         Source: "uint _investorsToProcess"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(state == State.Sale);\r\n        require(now >= crowdsaleFinishTime && collectedUSDWEI < minimalSuccessUSDWEI);\r\n        while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n            address addr = investorsIter[--numberOfInvestors];\r\n            Investor memory inv = investors[addr];\r\n            burnTokens(addr, inv.amountTokens);\r\n            --_investorsToProcess;\r\n            delete investorsIter[numberOfInvestors];\r\n\r\n            investorsToWithdrawIter[numberOfInvestorsToWithdraw] = addr;\r\n            numberOfInvestorsToWithdraw++;\r\n        }\r\n        if (numberOfInvestors > 0) {\r\n            return;\r\n        }\r\n        setState(State.SaleFailed);\r\n    }"
      ExpressionStatement
         Gas costs: 373
         Source: "require(state == State.Sale)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.Sale)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "state == State.Sale"
            Identifier state
               Type: enum Stateful.State
               Source: "state"
            MemberAccess to member Sale
               Type: enum Stateful.State
               Source: "State.Sale"
              Identifier State
                 Type: type(enum Stateful.State)
                 Source: "State"
      ExpressionStatement
         Gas costs: 668
         Source: "require(now >= crowdsaleFinishTime && collectedUSDWEI < minimalSuccessUSDWEI)"
        FunctionCall
           Type: tuple()
           Source: "require(now >= crowdsaleFinishTime && collectedUSDWEI < minimalSuccessUSDWEI)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "now >= crowdsaleFinishTime && collectedUSDWEI < minimalSuccessUSDWEI"
            BinaryOperation using operator >=
               Type: bool
               Source: "now >= crowdsaleFinishTime"
              Identifier now
                 Type: uint256
                 Source: "now"
              Identifier crowdsaleFinishTime
                 Type: uint256
                 Source: "crowdsaleFinishTime"
            BinaryOperation using operator <
               Type: bool
               Source: "collectedUSDWEI < minimalSuccessUSDWEI"
              Identifier collectedUSDWEI
                 Type: uint256
                 Source: "collectedUSDWEI"
              Identifier minimalSuccessUSDWEI
                 Type: uint256
                 Source: "minimalSuccessUSDWEI"
      WhileStatement
         Source: "while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n            address addr = investorsIter[--numberOfInvestors];\r\n            Investor memory inv = investors[addr];\r\n            burnTokens(addr, inv.amountTokens);\r\n            --_investorsToProcess;\r\n            delete investorsIter[numberOfInvestors];\r\n\r\n            investorsToWithdrawIter[numberOfInvestorsToWithdraw] = addr;\r\n            numberOfInvestorsToWithdraw++;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 240
           Source: "_investorsToProcess > 0 && numberOfInvestors > 0"
          BinaryOperation using operator >
             Type: bool
             Source: "_investorsToProcess > 0"
            Identifier _investorsToProcess
               Type: uint256
               Source: "_investorsToProcess"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator >
             Type: bool
             Source: "numberOfInvestors > 0"
            Identifier numberOfInvestors
               Type: uint256
               Source: "numberOfInvestors"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            address addr = investorsIter[--numberOfInvestors];\r\n            Investor memory inv = investors[addr];\r\n            burnTokens(addr, inv.amountTokens);\r\n            --_investorsToProcess;\r\n            delete investorsIter[numberOfInvestors];\r\n\r\n            investorsToWithdrawIter[numberOfInvestorsToWithdraw] = addr;\r\n            numberOfInvestorsToWithdraw++;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 20560
             Source: "address addr = investorsIter[--numberOfInvestors]"
            VariableDeclaration "addr"
               Type: address
               Source: "address addr"
              ElementaryTypeName address
                 Source: "address"
            IndexAccess
               Type: address
               Source: "investorsIter[--numberOfInvestors]"
              Identifier investorsIter
                 Type: mapping(uint256 => address)
                 Source: "investorsIter"
              UnaryOperation (prefix) --
                 Type: uint256
                 Source: "--numberOfInvestors"
                Identifier numberOfInvestors
                   Type: uint256
                   Source: "numberOfInvestors"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "Investor memory inv = investors[addr]"
            VariableDeclaration "inv"
               Type: struct Crowdsale.Investor memory
               Source: "Investor memory inv"
              UserDefinedTypeName "Investor"
                 Source: "Investor"
            IndexAccess
               Type: struct Crowdsale.Investor storage ref
               Source: "investors[addr]"
              Identifier investors
                 Type: mapping(address => struct Crowdsale.Investor storage ref)
                 Source: "investors"
              Identifier addr
                 Type: address
                 Source: "addr"
          ExpressionStatement
             Gas costs: [???]
             Source: "burnTokens(addr, inv.amountTokens)"
            FunctionCall
               Type: tuple()
               Source: "burnTokens(addr, inv.amountTokens)"
              Identifier burnTokens
                 Type: function (address,uint256)
                 Source: "burnTokens"
              Identifier addr
                 Type: address
                 Source: "addr"
              MemberAccess to member amountTokens
                 Type: uint256
                 Source: "inv.amountTokens"
                Identifier inv
                   Type: struct Crowdsale.Investor memory
                   Source: "inv"
          ExpressionStatement
             Gas costs: 17
             Source: "--_investorsToProcess"
            UnaryOperation (prefix) --
               Type: uint256
               Source: "--_investorsToProcess"
              Identifier _investorsToProcess
                 Type: uint256
                 Source: "_investorsToProcess"
          ExpressionStatement
             Gas costs: 20526
             Source: "delete investorsIter[numberOfInvestors]"
            UnaryOperation (prefix) delete
               Type: tuple()
               Source: "delete investorsIter[numberOfInvestors]"
              IndexAccess
                 Type: address
                 Source: "investorsIter[numberOfInvestors]"
                Identifier investorsIter
                   Type: mapping(uint256 => address)
                   Source: "investorsIter"
                Identifier numberOfInvestors
                   Type: uint256
                   Source: "numberOfInvestors"
          ExpressionStatement
             Gas costs: 20545
             Source: "investorsToWithdrawIter[numberOfInvestorsToWithdraw] = addr"
            Assignment using operator =
               Type: address
               Source: "investorsToWithdrawIter[numberOfInvestorsToWithdraw] = addr"
              IndexAccess
                 Type: address
                 Source: "investorsToWithdrawIter[numberOfInvestorsToWithdraw]"
                Identifier investorsToWithdrawIter
                   Type: mapping(uint256 => address)
                   Source: "investorsToWithdrawIter"
                Identifier numberOfInvestorsToWithdraw
                   Type: uint256
                   Source: "numberOfInvestorsToWithdraw"
              Identifier addr
                 Type: address
                 Source: "addr"
          ExpressionStatement
             Gas costs: 20237
             Source: "numberOfInvestorsToWithdraw++"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "numberOfInvestorsToWithdraw++"
              Identifier numberOfInvestorsToWithdraw
                 Type: uint256
                 Source: "numberOfInvestorsToWithdraw"
      IfStatement
         Source: "if (numberOfInvestors > 0) {\r\n            return;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "numberOfInvestors > 0"
          Identifier numberOfInvestors
             Type: uint256
             Source: "numberOfInvestors"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            return;\r\n        }"
          Return
             Gas costs: 11
             Source: "return;"
      ExpressionStatement
         Gas costs: 18
         Source: "setState(State.SaleFailed)"
        FunctionCall
           Type: tuple()
           Source: "setState(State.SaleFailed)"
          Identifier setState
             Type: function (enum Stateful.State)
             Source: "setState"
          MemberAccess to member SaleFailed
             Type: enum Stateful.State
             Source: "State.SaleFailed"
            Identifier State
               Type: type(enum Stateful.State)
               Source: "State"
  FunctionDefinition "completeSale" - public
     Source: "function completeSale(uint _investorsToProcess) public onlyOwner {\r\n        require(state == State.Sale);\r\n        require(collectedUSDWEI >= minimalSuccessUSDWEI);\r\n\r\n        while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n            --numberOfInvestors;\r\n            --_investorsToProcess;\r\n            delete investors[investorsIter[numberOfInvestors]];\r\n            delete investorsIter[numberOfInvestors];\r\n        }\r\n\r\n        if (numberOfInvestors > 0) {\r\n            return;\r\n        }\r\n\r\n        emitAdditionalTokens();\r\n\r\n        bool isSent = beneficiary.call.gas(3000000).value(this.balance)();\r\n        require(isSent);\r\n        setState(State.CrowdsaleCompleted);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _investorsToProcess)"
      VariableDeclaration "_investorsToProcess"
         Type: uint256
         Source: "uint _investorsToProcess"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(state == State.Sale);\r\n        require(collectedUSDWEI >= minimalSuccessUSDWEI);\r\n\r\n        while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n            --numberOfInvestors;\r\n            --_investorsToProcess;\r\n            delete investors[investorsIter[numberOfInvestors]];\r\n            delete investorsIter[numberOfInvestors];\r\n        }\r\n\r\n        if (numberOfInvestors > 0) {\r\n            return;\r\n        }\r\n\r\n        emitAdditionalTokens();\r\n\r\n        bool isSent = beneficiary.call.gas(3000000).value(this.balance)();\r\n        require(isSent);\r\n        setState(State.CrowdsaleCompleted);\r\n    }"
      ExpressionStatement
         Gas costs: 373
         Source: "require(state == State.Sale)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.Sale)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "state == State.Sale"
            Identifier state
               Type: enum Stateful.State
               Source: "state"
            MemberAccess to member Sale
               Type: enum Stateful.State
               Source: "State.Sale"
              Identifier State
                 Type: type(enum Stateful.State)
                 Source: "State"
      ExpressionStatement
         Gas costs: 438
         Source: "require(collectedUSDWEI >= minimalSuccessUSDWEI)"
        FunctionCall
           Type: tuple()
           Source: "require(collectedUSDWEI >= minimalSuccessUSDWEI)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "collectedUSDWEI >= minimalSuccessUSDWEI"
            Identifier collectedUSDWEI
               Type: uint256
               Source: "collectedUSDWEI"
            Identifier minimalSuccessUSDWEI
               Type: uint256
               Source: "minimalSuccessUSDWEI"
      WhileStatement
         Source: "while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n            --numberOfInvestors;\r\n            --_investorsToProcess;\r\n            delete investors[investorsIter[numberOfInvestors]];\r\n            delete investorsIter[numberOfInvestors];\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 240
           Source: "_investorsToProcess > 0 && numberOfInvestors > 0"
          BinaryOperation using operator >
             Type: bool
             Source: "_investorsToProcess > 0"
            Identifier _investorsToProcess
               Type: uint256
               Source: "_investorsToProcess"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator >
             Type: bool
             Source: "numberOfInvestors > 0"
            Identifier numberOfInvestors
               Type: uint256
               Source: "numberOfInvestors"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            --numberOfInvestors;\r\n            --_investorsToProcess;\r\n            delete investors[investorsIter[numberOfInvestors]];\r\n            delete investorsIter[numberOfInvestors];\r\n        }"
          ExpressionStatement
             Gas costs: 20234
             Source: "--numberOfInvestors"
            UnaryOperation (prefix) --
               Type: uint256
               Source: "--numberOfInvestors"
              Identifier numberOfInvestors
                 Type: uint256
                 Source: "numberOfInvestors"
          ExpressionStatement
             Gas costs: 17
             Source: "--_investorsToProcess"
            UnaryOperation (prefix) --
               Type: uint256
               Source: "--_investorsToProcess"
              Identifier _investorsToProcess
                 Type: uint256
                 Source: "_investorsToProcess"
          ExpressionStatement
             Gas costs: 10650
             Source: "delete investors[investorsIter[numberOfInvestors]]"
            UnaryOperation (prefix) delete
               Type: tuple()
               Source: "delete investors[investorsIter[numberOfInvestors]]"
              IndexAccess
                 Type: struct Crowdsale.Investor storage ref
                 Source: "investors[investorsIter[numberOfInvestors]]"
                Identifier investors
                   Type: mapping(address => struct Crowdsale.Investor storage ref)
                   Source: "investors"
                IndexAccess
                   Type: address
                   Source: "investorsIter[numberOfInvestors]"
                  Identifier investorsIter
                     Type: mapping(uint256 => address)
                     Source: "investorsIter"
                  Identifier numberOfInvestors
                     Type: uint256
                     Source: "numberOfInvestors"
          ExpressionStatement
             Gas costs: 20520
             Source: "delete investorsIter[numberOfInvestors]"
            UnaryOperation (prefix) delete
               Type: tuple()
               Source: "delete investorsIter[numberOfInvestors]"
              IndexAccess
                 Type: address
                 Source: "investorsIter[numberOfInvestors]"
                Identifier investorsIter
                   Type: mapping(uint256 => address)
                   Source: "investorsIter"
                Identifier numberOfInvestors
                   Type: uint256
                   Source: "numberOfInvestors"
      IfStatement
         Source: "if (numberOfInvestors > 0) {\r\n            return;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "numberOfInvestors > 0"
          Identifier numberOfInvestors
             Type: uint256
             Source: "numberOfInvestors"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            return;\r\n        }"
          Return
             Gas costs: 11
             Source: "return;"
      ExpressionStatement
         Gas costs: 4
         Source: "emitAdditionalTokens()"
        FunctionCall
           Type: tuple()
           Source: "emitAdditionalTokens()"
          Identifier emitAdditionalTokens
             Type: function ()
             Source: "emitAdditionalTokens"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "bool isSent = beneficiary.call.gas(3000000).value(this.balance)()"
        VariableDeclaration "isSent"
           Type: bool
           Source: "bool isSent"
          ElementaryTypeName bool
             Source: "bool"
        FunctionCall
           Type: bool
           Source: "beneficiary.call.gas(3000000).value(this.balance)()"
          FunctionCall
             Type: function () payable returns (bool)
             Source: "beneficiary.call.gas(3000000).value(this.balance)"
            MemberAccess to member value
               Type: function (uint256) returns (function () payable returns (bool))
               Source: "beneficiary.call.gas(3000000).value"
              FunctionCall
                 Type: function () payable returns (bool)
                 Source: "beneficiary.call.gas(3000000)"
                MemberAccess to member gas
                   Type: function (uint256) returns (function () payable returns (bool))
                   Source: "beneficiary.call.gas"
                  MemberAccess to member call
                     Type: function () payable returns (bool)
                     Source: "beneficiary.call"
                    Identifier beneficiary
                       Type: address
                       Source: "beneficiary"
                Literal, token: [no token] value: 3000000
                   Type: int_const 3000000
                   Source: "3000000"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract Crowdsale
                 Source: "this"
      ExpressionStatement
         Gas costs: 29
         Source: "require(isSent)"
        FunctionCall
           Type: tuple()
           Source: "require(isSent)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier isSent
             Type: bool
             Source: "isSent"
      ExpressionStatement
         Gas costs: 18
         Source: "setState(State.CrowdsaleCompleted)"
        FunctionCall
           Type: tuple()
           Source: "setState(State.CrowdsaleCompleted)"
          Identifier setState
             Type: function (enum Stateful.State)
             Source: "setState"
          MemberAccess to member CrowdsaleCompleted
             Type: enum Stateful.State
             Source: "State.CrowdsaleCompleted"
            Identifier State
               Type: type(enum Stateful.State)
               Source: "State"
  FunctionDefinition "setEtherPriceUSDWEI" - public
     Source: "function setEtherPriceUSDWEI(uint _etherPriceUSDWEI) external onlyOwnerOrOracle {\r\n        etherPriceUSDWEI = _etherPriceUSDWEI;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _etherPriceUSDWEI)"
      VariableDeclaration "_etherPriceUSDWEI"
         Type: uint256
         Source: "uint _etherPriceUSDWEI"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwnerOrOracle"
       Gas costs: 0
       Source: "onlyOwnerOrOracle"
      Identifier onlyOwnerOrOracle
         Type: modifier ()
         Source: "onlyOwnerOrOracle"
    Block
       Source: "{\r\n        etherPriceUSDWEI = _etherPriceUSDWEI;\r\n    }"
      ExpressionStatement
         Gas costs: 20014
         Source: "etherPriceUSDWEI = _etherPriceUSDWEI"
        Assignment using operator =
           Type: uint256
           Source: "etherPriceUSDWEI = _etherPriceUSDWEI"
          Identifier etherPriceUSDWEI
             Type: uint256
             Source: "etherPriceUSDWEI"
          Identifier _etherPriceUSDWEI
             Type: uint256
             Source: "_etherPriceUSDWEI"
  FunctionDefinition "setBeneficiary" - public
     Source: "function setBeneficiary(address _beneficiary) external onlyOwner() {\r\n        require(_beneficiary != 0);\r\n        beneficiary = _beneficiary;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _beneficiary)"
      VariableDeclaration "_beneficiary"
         Type: address
         Source: "address _beneficiary"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner()"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_beneficiary != 0);\r\n        beneficiary = _beneficiary;\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "require(_beneficiary != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_beneficiary != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_beneficiary != 0"
            Identifier _beneficiary
               Type: address
               Source: "_beneficiary"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "beneficiary = _beneficiary"
        Assignment using operator =
           Type: address
           Source: "beneficiary = _beneficiary"
          Identifier beneficiary
             Type: address
             Source: "beneficiary"
          Identifier _beneficiary
             Type: address
             Source: "_beneficiary"
  FunctionDefinition "withdrawBack" - public
     Source: "function withdrawBack() external saleFailedState {\r\n        returnInvestmentsToInternal(msg.sender);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "saleFailedState"
       Gas costs: 0
       Source: "saleFailedState"
      Identifier saleFailedState
         Type: modifier ()
         Source: "saleFailedState"
    Block
       Source: "{\r\n        returnInvestmentsToInternal(msg.sender);\r\n    }"
      ExpressionStatement
         Gas costs: 6
         Source: "returnInvestmentsToInternal(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "returnInvestmentsToInternal(msg.sender)"
          Identifier returnInvestmentsToInternal
             Type: function (address)
             Source: "returnInvestmentsToInternal"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "returnInvestments" - public
     Source: "function returnInvestments(uint _investorsToProcess) public saleFailedState {\r\n        while (_investorsToProcess > 0 && numberOfInvestorsToWithdraw > 0) {\r\n            address addr = investorsToWithdrawIter[--numberOfInvestorsToWithdraw];\r\n            delete investorsToWithdrawIter[numberOfInvestorsToWithdraw];\r\n            --_investorsToProcess;\r\n            returnInvestmentsToInternal(addr);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _investorsToProcess)"
      VariableDeclaration "_investorsToProcess"
         Type: uint256
         Source: "uint _investorsToProcess"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "saleFailedState"
       Gas costs: 0
       Source: "saleFailedState"
      Identifier saleFailedState
         Type: modifier ()
         Source: "saleFailedState"
    Block
       Source: "{\r\n        while (_investorsToProcess > 0 && numberOfInvestorsToWithdraw > 0) {\r\n            address addr = investorsToWithdrawIter[--numberOfInvestorsToWithdraw];\r\n            delete investorsToWithdrawIter[numberOfInvestorsToWithdraw];\r\n            --_investorsToProcess;\r\n            returnInvestmentsToInternal(addr);\r\n        }\r\n    }"
      WhileStatement
         Source: "while (_investorsToProcess > 0 && numberOfInvestorsToWithdraw > 0) {\r\n            address addr = investorsToWithdrawIter[--numberOfInvestorsToWithdraw];\r\n            delete investorsToWithdrawIter[numberOfInvestorsToWithdraw];\r\n            --_investorsToProcess;\r\n            returnInvestmentsToInternal(addr);\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 240
           Source: "_investorsToProcess > 0 && numberOfInvestorsToWithdraw > 0"
          BinaryOperation using operator >
             Type: bool
             Source: "_investorsToProcess > 0"
            Identifier _investorsToProcess
               Type: uint256
               Source: "_investorsToProcess"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator >
             Type: bool
             Source: "numberOfInvestorsToWithdraw > 0"
            Identifier numberOfInvestorsToWithdraw
               Type: uint256
               Source: "numberOfInvestorsToWithdraw"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            address addr = investorsToWithdrawIter[--numberOfInvestorsToWithdraw];\r\n            delete investorsToWithdrawIter[numberOfInvestorsToWithdraw];\r\n            --_investorsToProcess;\r\n            returnInvestmentsToInternal(addr);\r\n        }"
          VariableDeclarationStatement
             Gas costs: 20560
             Source: "address addr = investorsToWithdrawIter[--numberOfInvestorsToWithdraw]"
            VariableDeclaration "addr"
               Type: address
               Source: "address addr"
              ElementaryTypeName address
                 Source: "address"
            IndexAccess
               Type: address
               Source: "investorsToWithdrawIter[--numberOfInvestorsToWithdraw]"
              Identifier investorsToWithdrawIter
                 Type: mapping(uint256 => address)
                 Source: "investorsToWithdrawIter"
              UnaryOperation (prefix) --
                 Type: uint256
                 Source: "--numberOfInvestorsToWithdraw"
                Identifier numberOfInvestorsToWithdraw
                   Type: uint256
                   Source: "numberOfInvestorsToWithdraw"
          ExpressionStatement
             Gas costs: 20520
             Source: "delete investorsToWithdrawIter[numberOfInvestorsToWithdraw]"
            UnaryOperation (prefix) delete
               Type: tuple()
               Source: "delete investorsToWithdrawIter[numberOfInvestorsToWithdraw]"
              IndexAccess
                 Type: address
                 Source: "investorsToWithdrawIter[numberOfInvestorsToWithdraw]"
                Identifier investorsToWithdrawIter
                   Type: mapping(uint256 => address)
                   Source: "investorsToWithdrawIter"
                Identifier numberOfInvestorsToWithdraw
                   Type: uint256
                   Source: "numberOfInvestorsToWithdraw"
          ExpressionStatement
             Gas costs: 17
             Source: "--_investorsToProcess"
            UnaryOperation (prefix) --
               Type: uint256
               Source: "--_investorsToProcess"
              Identifier _investorsToProcess
                 Type: uint256
                 Source: "_investorsToProcess"
          ExpressionStatement
             Gas costs: 18
             Source: "returnInvestmentsToInternal(addr)"
            FunctionCall
               Type: tuple()
               Source: "returnInvestmentsToInternal(addr)"
              Identifier returnInvestmentsToInternal
                 Type: function (address)
                 Source: "returnInvestmentsToInternal"
              Identifier addr
                 Type: address
                 Source: "addr"
  FunctionDefinition "returnInvestmentsTo" - public
     Source: "function returnInvestmentsTo(address _to) public saleFailedState {\r\n        returnInvestmentsToInternal(_to);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "saleFailedState"
       Gas costs: 0
       Source: "saleFailedState"
      Identifier saleFailedState
         Type: modifier ()
         Source: "saleFailedState"
    Block
       Source: "{\r\n        returnInvestmentsToInternal(_to);\r\n    }"
      ExpressionStatement
         Gas costs: 18
         Source: "returnInvestmentsToInternal(_to)"
        FunctionCall
           Type: tuple()
           Source: "returnInvestmentsToInternal(_to)"
          Identifier returnInvestmentsToInternal
             Type: function (address)
             Source: "returnInvestmentsToInternal"
          Identifier _to
             Type: address
             Source: "_to"
  FunctionDefinition "returnInvestmentsToInternal"
     Source: "function returnInvestmentsToInternal(address _to) internal {\r\n        Investor memory inv = investors[_to];\r\n        uint value = inv.amountWei;\r\n        if (value > 0) {\r\n            delete investors[_to];\r\n            require(_to.call.gas(3000000).value(value)());\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        Investor memory inv = investors[_to];\r\n        uint value = inv.amountWei;\r\n        if (value > 0) {\r\n            delete investors[_to];\r\n            require(_to.call.gas(3000000).value(value)());\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "Investor memory inv = investors[_to]"
        VariableDeclaration "inv"
           Type: struct Crowdsale.Investor memory
           Source: "Investor memory inv"
          UserDefinedTypeName "Investor"
             Source: "Investor"
        IndexAccess
           Type: struct Crowdsale.Investor storage ref
           Source: "investors[_to]"
          Identifier investors
             Type: mapping(address => struct Crowdsale.Investor storage ref)
             Source: "investors"
          Identifier _to
             Type: address
             Source: "_to"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint value = inv.amountWei"
        VariableDeclaration "value"
           Type: uint256
           Source: "uint value"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member amountWei
           Type: uint256
           Source: "inv.amountWei"
          Identifier inv
             Type: struct Crowdsale.Investor memory
             Source: "inv"
      IfStatement
         Source: "if (value > 0) {\r\n            delete investors[_to];\r\n            require(_to.call.gas(3000000).value(value)());\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "value > 0"
          Identifier value
             Type: uint256
             Source: "value"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            delete investors[_to];\r\n            require(_to.call.gas(3000000).value(value)());\r\n        }"
          ExpressionStatement
             Gas costs: 10136
             Source: "delete investors[_to]"
            UnaryOperation (prefix) delete
               Type: tuple()
               Source: "delete investors[_to]"
              IndexAccess
                 Type: struct Crowdsale.Investor storage ref
                 Source: "investors[_to]"
                Identifier investors
                   Type: mapping(address => struct Crowdsale.Investor storage ref)
                   Source: "investors"
                Identifier _to
                   Type: address
                   Source: "_to"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(_to.call.gas(3000000).value(value)())"
            FunctionCall
               Type: tuple()
               Source: "require(_to.call.gas(3000000).value(value)())"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "_to.call.gas(3000000).value(value)()"
                FunctionCall
                   Type: function () payable returns (bool)
                   Source: "_to.call.gas(3000000).value(value)"
                  MemberAccess to member value
                     Type: function (uint256) returns (function () payable returns (bool))
                     Source: "_to.call.gas(3000000).value"
                    FunctionCall
                       Type: function () payable returns (bool)
                       Source: "_to.call.gas(3000000)"
                      MemberAccess to member gas
                         Type: function (uint256) returns (function () payable returns (bool))
                         Source: "_to.call.gas"
                        MemberAccess to member call
                           Type: function () payable returns (bool)
                           Source: "_to.call"
                          Identifier _to
                             Type: address
                             Source: "_to"
                      Literal, token: [no token] value: 3000000
                         Type: int_const 3000000
                         Source: "3000000"
                  Identifier value
                     Type: uint256
                     Source: "value"
  FunctionDefinition "withdrawFunds" - public
     Source: "function withdrawFunds(uint _value) public onlyOwner {\r\n        require(state == State.PreSale || (state == State.Sale && collectedUSDWEI > minimalSuccessUSDWEI));\r\n        if (_value == 0) {\r\n            _value = this.balance;\r\n        }\r\n        bool isSent = beneficiary.call.gas(3000000).value(_value)();\r\n        require(isSent);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _value)"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(state == State.PreSale || (state == State.Sale && collectedUSDWEI > minimalSuccessUSDWEI));\r\n        if (_value == 0) {\r\n            _value = this.balance;\r\n        }\r\n        bool isSent = beneficiary.call.gas(3000000).value(_value)();\r\n        require(isSent);\r\n    }"
      ExpressionStatement
         Gas costs: 1170
         Source: "require(state == State.PreSale || (state == State.Sale && collectedUSDWEI > minimalSuccessUSDWEI))"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.PreSale || (state == State.Sale && collectedUSDWEI > minimalSuccessUSDWEI))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "state == State.PreSale || (state == State.Sale && collectedUSDWEI > minimalSuccessUSDWEI)"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.PreSale"
              Identifier state
                 Type: enum Stateful.State
                 Source: "state"
              MemberAccess to member PreSale
                 Type: enum Stateful.State
                 Source: "State.PreSale"
                Identifier State
                   Type: type(enum Stateful.State)
                   Source: "State"
            TupleExpression
               Type: bool
               Source: "(state == State.Sale && collectedUSDWEI > minimalSuccessUSDWEI)"
              BinaryOperation using operator &&
                 Type: bool
                 Source: "state == State.Sale && collectedUSDWEI > minimalSuccessUSDWEI"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "state == State.Sale"
                  Identifier state
                     Type: enum Stateful.State
                     Source: "state"
                  MemberAccess to member Sale
                     Type: enum Stateful.State
                     Source: "State.Sale"
                    Identifier State
                       Type: type(enum Stateful.State)
                       Source: "State"
                BinaryOperation using operator >
                   Type: bool
                   Source: "collectedUSDWEI > minimalSuccessUSDWEI"
                  Identifier collectedUSDWEI
                     Type: uint256
                     Source: "collectedUSDWEI"
                  Identifier minimalSuccessUSDWEI
                     Type: uint256
                     Source: "minimalSuccessUSDWEI"
      IfStatement
         Source: "if (_value == 0) {\r\n            _value = this.balance;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "_value == 0"
          Identifier _value
             Type: uint256
             Source: "_value"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            _value = this.balance;\r\n        }"
          ExpressionStatement
             Gas costs: 413
             Source: "_value = this.balance"
            Assignment using operator =
               Type: uint256
               Source: "_value = this.balance"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              MemberAccess to member balance
                 Type: uint256
                 Source: "this.balance"
                Identifier this
                   Type: contract Crowdsale
                   Source: "this"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "bool isSent = beneficiary.call.gas(3000000).value(_value)()"
        VariableDeclaration "isSent"
           Type: bool
           Source: "bool isSent"
          ElementaryTypeName bool
             Source: "bool"
        FunctionCall
           Type: bool
           Source: "beneficiary.call.gas(3000000).value(_value)()"
          FunctionCall
             Type: function () payable returns (bool)
             Source: "beneficiary.call.gas(3000000).value(_value)"
            MemberAccess to member value
               Type: function (uint256) returns (function () payable returns (bool))
               Source: "beneficiary.call.gas(3000000).value"
              FunctionCall
                 Type: function () payable returns (bool)
                 Source: "beneficiary.call.gas(3000000)"
                MemberAccess to member gas
                   Type: function (uint256) returns (function () payable returns (bool))
                   Source: "beneficiary.call.gas"
                  MemberAccess to member call
                     Type: function () payable returns (bool)
                     Source: "beneficiary.call"
                    Identifier beneficiary
                       Type: address
                       Source: "beneficiary"
                Literal, token: [no token] value: 3000000
                   Type: int_const 3000000
                   Source: "3000000"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 29
         Source: "require(isSent)"
        FunctionCall
           Type: tuple()
           Source: "require(isSent)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier isSent
             Type: bool
             Source: "isSent"
  ModifierDefinition "crowdsaleNotFinished"
     Source: "modifier crowdsaleNotFinished {\r\n        require(now < crowdsaleFinishTime);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(now < crowdsaleFinishTime);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 702
         Source: "require(now < crowdsaleFinishTime)"
        FunctionCall
           Type: tuple()
           Source: "require(now < crowdsaleFinishTime)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "now < crowdsaleFinishTime"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier crowdsaleFinishTime
               Type: uint256
               Source: "crowdsaleFinishTime"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "limitNotExceeded"
     Source: "modifier limitNotExceeded {\r\n        require(collectedUSDWEI < totalLimitUSDWEI);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(collectedUSDWEI < totalLimitUSDWEI);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 1305
         Source: "require(collectedUSDWEI < totalLimitUSDWEI)"
        FunctionCall
           Type: tuple()
           Source: "require(collectedUSDWEI < totalLimitUSDWEI)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "collectedUSDWEI < totalLimitUSDWEI"
            Identifier collectedUSDWEI
               Type: uint256
               Source: "collectedUSDWEI"
            Identifier totalLimitUSDWEI
               Type: uint256
               Source: "totalLimitUSDWEI"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "crowdsaleState"
     Source: "modifier crowdsaleState {\r\n        require(state == State.PreSale || state == State.Sale);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(state == State.PreSale || state == State.Sale);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 2217
         Source: "require(state == State.PreSale || state == State.Sale)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.PreSale || state == State.Sale)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "state == State.PreSale || state == State.Sale"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.PreSale"
              Identifier state
                 Type: enum Stateful.State
                 Source: "state"
              MemberAccess to member PreSale
                 Type: enum Stateful.State
                 Source: "State.PreSale"
                Identifier State
                   Type: type(enum Stateful.State)
                   Source: "State"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.Sale"
              Identifier state
                 Type: enum Stateful.State
                 Source: "state"
              MemberAccess to member Sale
                 Type: enum Stateful.State
                 Source: "State.Sale"
                Identifier State
                   Type: type(enum Stateful.State)
                   Source: "State"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "saleFailedState"
     Source: "modifier saleFailedState {\r\n        require(state == State.SaleFailed);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(state == State.SaleFailed);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 1119
         Source: "require(state == State.SaleFailed)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.SaleFailed)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "state == State.SaleFailed"
            Identifier state
               Type: enum Stateful.State
               Source: "state"
            MemberAccess to member SaleFailed
               Type: enum Stateful.State
               Source: "State.SaleFailed"
              Identifier State
                 Type: type(enum Stateful.State)
                 Source: "State"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "completedSaleState"
     Source: "modifier completedSaleState {\r\n        require(state == State.CrowdsaleCompleted);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(state == State.CrowdsaleCompleted);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 1492
         Source: "require(state == State.CrowdsaleCompleted)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.CrowdsaleCompleted)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "state == State.CrowdsaleCompleted"
            Identifier state
               Type: enum Stateful.State
               Source: "state"
            MemberAccess to member CrowdsaleCompleted
               Type: enum Stateful.State
               Source: "State.CrowdsaleCompleted"
              Identifier State
                 Type: type(enum Stateful.State)
                 Source: "State"
      PlaceholderStatement
         Gas costs: 4
         Source: "_"
ContractDefinition "Token"
   Source: "contract Token is Crowdsale, ERC20 {\r\n\r\n    mapping(address => uint) internal balances;\r\n    mapping(address => mapping(address => uint)) public allowed;\r\n    uint8 public constant decimals = 8;\r\n\r\n\r\n    function Token() payable Crowdsale() {}\r\n\r\n    function balanceOf(address who) constant returns(uint) {\r\n        return balances[who];\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public completedSaleState onlyPayloadSize(2 * 32) {\r\n        require(balances[msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public completedSaleState onlyPayloadSize(3 * 32) {\r\n        require(balances[_from] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        balances[_from] -= _value;\r\n        balances[_to] += _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public completedSaleState {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant completedSaleState returns(uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Crowdsale"
    UserDefinedTypeName "Crowdsale"
       Source: "Crowdsale"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint) internal balances"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: [???]
     Source: "mapping(address => mapping(address => uint)) public allowed"
    Mapping
       Source: "mapping(address => mapping(address => uint))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping(address => uint)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: [???]
     Source: "uint8 public constant decimals = 8"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 8
       Type: int_const 8
       Source: "8"
  FunctionDefinition "Token" - public
     Source: "function Token() payable Crowdsale() {}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "Crowdsale"
       Gas costs: 0
       Source: "Crowdsale()"
      Identifier Crowdsale
         Type: type(contract Crowdsale)
         Source: "Crowdsale"
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) constant returns(uint) {\r\n        return balances[who];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return balances[who];\r\n    }"
      Return
         Gas costs: 304
         Source: "return balances[who]"
        IndexAccess
           Type: uint256
           Source: "balances[who]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier who
             Type: address
             Source: "who"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value) public completedSaleState onlyPayloadSize(2 * 32) {\r\n        require(balances[msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "completedSaleState"
       Gas costs: 0
       Source: "completedSaleState"
      Identifier completedSaleState
         Type: modifier ()
         Source: "completedSaleState"
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 3
       Source: "onlyPayloadSize(2 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 64
         Source: "2 * 32"
        Literal, token: [no token] value: 2
           Type: int_const 2
           Source: "2"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n        require(balances[msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 333
         Source: "require(balances[msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 630
         Source: "require(balances[_to] + _value >= balances[_to])"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_to] + _value >= balances[_to])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[_to] + _value >= balances[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balances[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
      ExpressionStatement
         Gas costs: 20328
         Source: "balances[msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value) public completedSaleState onlyPayloadSize(3 * 32) {\r\n        require(balances[_from] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        balances[_from] -= _value;\r\n        balances[_to] += _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "completedSaleState"
       Gas costs: 0
       Source: "completedSaleState"
      Identifier completedSaleState
         Type: modifier ()
         Source: "completedSaleState"
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 3
       Source: "onlyPayloadSize(3 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 96
         Source: "3 * 32"
        Literal, token: [no token] value: 3
           Type: int_const 3
           Source: "3"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n        require(balances[_from] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        balances[_from] -= _value;\r\n        balances[_to] += _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 334
         Source: "require(balances[_from] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_from] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[_from] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[_from]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 630
         Source: "require(balances[_to] + _value >= balances[_to])"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_to] + _value >= balances[_to])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[_to] + _value >= balances[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balances[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
      ExpressionStatement
         Gas costs: 423
         Source: "require(allowed[_from][msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(allowed[_from][msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "allowed[_from][msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "allowed[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[_from]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20412
         Source: "allowed[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowed[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint _value) public completedSaleState {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "completedSaleState"
       Gas costs: 0
       Source: "completedSaleState"
      Identifier completedSaleState
         Type: modifier ()
         Source: "completedSaleState"
    Block
       Source: "{\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public constant completedSaleState returns(uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint remaining"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "completedSaleState"
       Gas costs: 0
       Source: "completedSaleState"
      Identifier completedSaleState
         Type: modifier ()
         Source: "completedSaleState"
    Block
       Source: "{\r\n        return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  ModifierDefinition "onlyPayloadSize"
     Source: "modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint size)"
      VariableDeclaration "size"
         Type: uint256
         Source: "uint size"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 102
         Source: "require(msg.data.length >= size + 4)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.data.length >= size + 4)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.data.length >= size + 4"
            MemberAccess to member length
               Type: uint256
               Source: "msg.data.length"
              MemberAccess to member data
                 Type: bytes calldata
                 Source: "msg.data"
                Identifier msg
                   Type: msg
                   Source: "msg"
            BinaryOperation using operator +
               Type: uint256
               Source: "size + 4"
              Identifier size
                 Type: uint256
                 Source: "size"
              Literal, token: [no token] value: 4
                 Type: int_const 4
                 Source: "4"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
ContractDefinition "MigratableToken"
   Source: "contract MigratableToken is Token {\r\n\r\n    function MigratableToken() payable Token() {}\r\n\r\n    address public migrationAgent;\r\n    uint public totalMigrated;\r\n    address public migrationHost;\r\n    mapping(address => bool) migratedInvestors;\r\n\r\n    event Migrated(address indexed from, address indexed to, uint value);\r\n\r\n    function setMigrationHost(address _address) external onlyOwner {\r\n        require(_address != 0);\r\n        migrationHost = _address;\r\n    }\r\n\r\n    //manual migration by owner\r\n    function migrateInvestorFromHost(address _address) external onlyOwner {\r\n        require(migrationHost != 0 &&\r\n            state != State.SaleFailed &&\r\n            etherPriceUSDWEI != 0 &&\r\n            migratedInvestors[_address] == false);\r\n\r\n        PreArtexToken preArtex = PreArtexToken(migrationHost);\r\n        uint tokensDecimals = preArtex.balanceOf(_address);\r\n        require(tokensDecimals > 0);\r\n        uint depositWEI = preArtex.deposits(_address);\r\n        uint preArtexTokenPriceUSDWEI = preArtex.tokenPriceUSDWEI();\r\n        uint tokensToTransfer = 0;\r\n\r\n        if (tokensDecimals != 0 && depositWEI == 0) {\r\n            tokensToTransfer = tokensDecimals * 140 / 130;\r\n        } else {\r\n            var preArtexEtherPriceUSDWEI = ((tokensDecimals * preArtexTokenPriceUSDWEI * 1 ether) / (depositWEI * (10 ** uint(decimals))));\r\n            if (etherPriceUSDWEI > preArtexEtherPriceUSDWEI) {\r\n                tokensToTransfer = (tokensDecimals * etherPriceUSDWEI * 140) / (preArtexEtherPriceUSDWEI * 130);\r\n            } else {\r\n                tokensToTransfer = tokensDecimals * 140 / 130;\r\n            }\r\n        }\r\n\r\n        balances[_address] = tokensToTransfer;\r\n        totalSupply += tokensToTransfer;\r\n        migratedInvestors[_address] = true;\r\n\r\n        if (state != State.CrowdsaleCompleted) {\r\n            Investor storage inv = investors[_address];\r\n            investorsIter[numberOfInvestors++] = _address;\r\n            inv.amountTokens += tokensToTransfer;\r\n        }\r\n\r\n        Transfer(this, _address, tokensToTransfer);\r\n    }\r\n\r\n    //migration by investor\r\n    function migrate() external {\r\n        require(migrationAgent != 0);\r\n        uint value = balances[msg.sender];\r\n        balances[msg.sender] -= value;\r\n        Transfer(msg.sender, this, value);\r\n        totalSupply -= value;\r\n        totalMigrated += value;\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);\r\n        Migrated(msg.sender, migrationAgent, value);\r\n    }\r\n\r\n    function setMigrationAgent(address _agent) external onlyOwner {\r\n        require(migrationAgent == 0);\r\n        migrationAgent = _agent;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Token"
    UserDefinedTypeName "Token"
       Source: "Token"
  FunctionDefinition "MigratableToken" - public
     Source: "function MigratableToken() payable Token() {}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "Token"
       Gas costs: 0
       Source: "Token()"
      Identifier Token
         Type: type(contract Token)
         Source: "Token"
    Block
       Gas costs: 0
       Source: "{}"
  VariableDeclaration "migrationAgent"
     Type: address
     Gas costs: [???]
     Source: "address public migrationAgent"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "totalMigrated"
     Type: uint256
     Gas costs: [???]
     Source: "uint public totalMigrated"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "migrationHost"
     Type: address
     Gas costs: [???]
     Source: "address public migrationHost"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "migratedInvestors"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping(address => bool) migratedInvestors"
    Mapping
       Source: "mapping(address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  EventDefinition "Migrated"
     Gas costs: 0
     Source: "event Migrated(address indexed from, address indexed to, uint value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "setMigrationHost" - public
     Source: "function setMigrationHost(address _address) external onlyOwner {\r\n        require(_address != 0);\r\n        migrationHost = _address;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_address != 0);\r\n        migrationHost = _address;\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "require(_address != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_address != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_address != 0"
            Identifier _address
               Type: address
               Source: "_address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "migrationHost = _address"
        Assignment using operator =
           Type: address
           Source: "migrationHost = _address"
          Identifier migrationHost
             Type: address
             Source: "migrationHost"
          Identifier _address
             Type: address
             Source: "_address"
  FunctionDefinition "migrateInvestorFromHost" - public
     Source: "function migrateInvestorFromHost(address _address) external onlyOwner {\r\n        require(migrationHost != 0 &&\r\n            state != State.SaleFailed &&\r\n            etherPriceUSDWEI != 0 &&\r\n            migratedInvestors[_address] == false);\r\n\r\n        PreArtexToken preArtex = PreArtexToken(migrationHost);\r\n        uint tokensDecimals = preArtex.balanceOf(_address);\r\n        require(tokensDecimals > 0);\r\n        uint depositWEI = preArtex.deposits(_address);\r\n        uint preArtexTokenPriceUSDWEI = preArtex.tokenPriceUSDWEI();\r\n        uint tokensToTransfer = 0;\r\n\r\n        if (tokensDecimals != 0 && depositWEI == 0) {\r\n            tokensToTransfer = tokensDecimals * 140 / 130;\r\n        } else {\r\n            var preArtexEtherPriceUSDWEI = ((tokensDecimals * preArtexTokenPriceUSDWEI * 1 ether) / (depositWEI * (10 ** uint(decimals))));\r\n            if (etherPriceUSDWEI > preArtexEtherPriceUSDWEI) {\r\n                tokensToTransfer = (tokensDecimals * etherPriceUSDWEI * 140) / (preArtexEtherPriceUSDWEI * 130);\r\n            } else {\r\n                tokensToTransfer = tokensDecimals * 140 / 130;\r\n            }\r\n        }\r\n\r\n        balances[_address] = tokensToTransfer;\r\n        totalSupply += tokensToTransfer;\r\n        migratedInvestors[_address] = true;\r\n\r\n        if (state != State.CrowdsaleCompleted) {\r\n            Investor storage inv = investors[_address];\r\n            investorsIter[numberOfInvestors++] = _address;\r\n            inv.amountTokens += tokensToTransfer;\r\n        }\r\n\r\n        Transfer(this, _address, tokensToTransfer);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(migrationHost != 0 &&\r\n            state != State.SaleFailed &&\r\n            etherPriceUSDWEI != 0 &&\r\n            migratedInvestors[_address] == false);\r\n\r\n        PreArtexToken preArtex = PreArtexToken(migrationHost);\r\n        uint tokensDecimals = preArtex.balanceOf(_address);\r\n        require(tokensDecimals > 0);\r\n        uint depositWEI = preArtex.deposits(_address);\r\n        uint preArtexTokenPriceUSDWEI = preArtex.tokenPriceUSDWEI();\r\n        uint tokensToTransfer = 0;\r\n\r\n        if (tokensDecimals != 0 && depositWEI == 0) {\r\n            tokensToTransfer = tokensDecimals * 140 / 130;\r\n        } else {\r\n            var preArtexEtherPriceUSDWEI = ((tokensDecimals * preArtexTokenPriceUSDWEI * 1 ether) / (depositWEI * (10 ** uint(decimals))));\r\n            if (etherPriceUSDWEI > preArtexEtherPriceUSDWEI) {\r\n                tokensToTransfer = (tokensDecimals * etherPriceUSDWEI * 140) / (preArtexEtherPriceUSDWEI * 130);\r\n            } else {\r\n                tokensToTransfer = tokensDecimals * 140 / 130;\r\n            }\r\n        }\r\n\r\n        balances[_address] = tokensToTransfer;\r\n        totalSupply += tokensToTransfer;\r\n        migratedInvestors[_address] = true;\r\n\r\n        if (state != State.CrowdsaleCompleted) {\r\n            Investor storage inv = investors[_address];\r\n            investorsIter[numberOfInvestors++] = _address;\r\n            inv.amountTokens += tokensToTransfer;\r\n        }\r\n\r\n        Transfer(this, _address, tokensToTransfer);\r\n    }"
      ExpressionStatement
         Gas costs: 1261
         Source: "require(migrationHost != 0 &&\r\n            state != State.SaleFailed &&\r\n            etherPriceUSDWEI != 0 &&\r\n            migratedInvestors[_address] == false)"
        FunctionCall
           Type: tuple()
           Source: "require(migrationHost != 0 &&\r\n            state != State.SaleFailed &&\r\n            etherPriceUSDWEI != 0 &&\r\n            migratedInvestors[_address] == false)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "migrationHost != 0 &&\r\n            state != State.SaleFailed &&\r\n            etherPriceUSDWEI != 0 &&\r\n            migratedInvestors[_address] == false"
            BinaryOperation using operator &&
               Type: bool
               Source: "migrationHost != 0 &&\r\n            state != State.SaleFailed &&\r\n            etherPriceUSDWEI != 0"
              BinaryOperation using operator &&
                 Type: bool
                 Source: "migrationHost != 0 &&\r\n            state != State.SaleFailed"
                BinaryOperation using operator !=
                   Type: bool
                   Source: "migrationHost != 0"
                  Identifier migrationHost
                     Type: address
                     Source: "migrationHost"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                BinaryOperation using operator !=
                   Type: bool
                   Source: "state != State.SaleFailed"
                  Identifier state
                     Type: enum Stateful.State
                     Source: "state"
                  MemberAccess to member SaleFailed
                     Type: enum Stateful.State
                     Source: "State.SaleFailed"
                    Identifier State
                       Type: type(enum Stateful.State)
                       Source: "State"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "etherPriceUSDWEI != 0"
                Identifier etherPriceUSDWEI
                   Type: uint256
                   Source: "etherPriceUSDWEI"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "migratedInvestors[_address] == false"
              IndexAccess
                 Type: bool
                 Source: "migratedInvestors[_address]"
                Identifier migratedInvestors
                   Type: mapping(address => bool)
                   Source: "migratedInvestors"
                Identifier _address
                   Type: address
                   Source: "_address"
              Literal, token: false value: false
                 Type: bool
                 Source: "false"
      VariableDeclarationStatement
         Gas costs: 247
         Source: "PreArtexToken preArtex = PreArtexToken(migrationHost)"
        VariableDeclaration "preArtex"
           Type: contract PreArtexToken
           Source: "PreArtexToken preArtex"
          UserDefinedTypeName "PreArtexToken"
             Source: "PreArtexToken"
        FunctionCall
           Type: contract PreArtexToken
           Source: "PreArtexToken(migrationHost)"
          Identifier PreArtexToken
             Type: type(contract PreArtexToken)
             Source: "PreArtexToken"
          Identifier migrationHost
             Type: address
             Source: "migrationHost"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint tokensDecimals = preArtex.balanceOf(_address)"
        VariableDeclaration "tokensDecimals"
           Type: uint256
           Source: "uint tokensDecimals"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "preArtex.balanceOf(_address)"
          MemberAccess to member balanceOf
             Type: function (address) view external returns (uint256)
             Source: "preArtex.balanceOf"
            Identifier preArtex
               Type: contract PreArtexToken
               Source: "preArtex"
          Identifier _address
             Type: address
             Source: "_address"
      ExpressionStatement
         Gas costs: 35
         Source: "require(tokensDecimals > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(tokensDecimals > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "tokensDecimals > 0"
            Identifier tokensDecimals
               Type: uint256
               Source: "tokensDecimals"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint depositWEI = preArtex.deposits(_address)"
        VariableDeclaration "depositWEI"
           Type: uint256
           Source: "uint depositWEI"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "preArtex.deposits(_address)"
          MemberAccess to member deposits
             Type: function (address) view external returns (uint256)
             Source: "preArtex.deposits"
            Identifier preArtex
               Type: contract PreArtexToken
               Source: "preArtex"
          Identifier _address
             Type: address
             Source: "_address"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint preArtexTokenPriceUSDWEI = preArtex.tokenPriceUSDWEI()"
        VariableDeclaration "preArtexTokenPriceUSDWEI"
           Type: uint256
           Source: "uint preArtexTokenPriceUSDWEI"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "preArtex.tokenPriceUSDWEI()"
          MemberAccess to member tokenPriceUSDWEI
             Type: function () view external returns (uint256)
             Source: "preArtex.tokenPriceUSDWEI"
            Identifier preArtex
               Type: contract PreArtexToken
               Source: "preArtex"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint tokensToTransfer = 0"
        VariableDeclaration "tokensToTransfer"
           Type: uint256
           Source: "uint tokensToTransfer"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      IfStatement
         Source: "if (tokensDecimals != 0 && depositWEI == 0) {\r\n            tokensToTransfer = tokensDecimals * 140 / 130;\r\n        } else {\r\n            var preArtexEtherPriceUSDWEI = ((tokensDecimals * preArtexTokenPriceUSDWEI * 1 ether) / (depositWEI * (10 ** uint(decimals))));\r\n            if (etherPriceUSDWEI > preArtexEtherPriceUSDWEI) {\r\n                tokensToTransfer = (tokensDecimals * etherPriceUSDWEI * 140) / (preArtexEtherPriceUSDWEI * 130);\r\n            } else {\r\n                tokensToTransfer = tokensDecimals * 140 / 130;\r\n            }\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 43
           Source: "tokensDecimals != 0 && depositWEI == 0"
          BinaryOperation using operator !=
             Type: bool
             Source: "tokensDecimals != 0"
            Identifier tokensDecimals
               Type: uint256
               Source: "tokensDecimals"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator ==
             Type: bool
             Source: "depositWEI == 0"
            Identifier depositWEI
               Type: uint256
               Source: "depositWEI"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            tokensToTransfer = tokensDecimals * 140 / 130;\r\n        }"
          ExpressionStatement
             Gas costs: 47
             Source: "tokensToTransfer = tokensDecimals * 140 / 130"
            Assignment using operator =
               Type: uint256
               Source: "tokensToTransfer = tokensDecimals * 140 / 130"
              Identifier tokensToTransfer
                 Type: uint256
                 Source: "tokensToTransfer"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "tokensDecimals * 140 / 130"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "tokensDecimals * 140"
                  Identifier tokensDecimals
                     Type: uint256
                     Source: "tokensDecimals"
                  Literal, token: [no token] value: 140
                     Type: int_const 140
                     Source: "140"
                Literal, token: [no token] value: 130
                   Type: int_const 130
                   Source: "130"
        Block
           Source: "{\r\n            var preArtexEtherPriceUSDWEI = ((tokensDecimals * preArtexTokenPriceUSDWEI * 1 ether) / (depositWEI * (10 ** uint(decimals))));\r\n            if (etherPriceUSDWEI > preArtexEtherPriceUSDWEI) {\r\n                tokensToTransfer = (tokensDecimals * etherPriceUSDWEI * 140) / (preArtexEtherPriceUSDWEI * 130);\r\n            } else {\r\n                tokensToTransfer = tokensDecimals * 140 / 130;\r\n            }\r\n        }"
          VariableDeclarationStatement
             Gas costs: 132
             Source: "var preArtexEtherPriceUSDWEI = ((tokensDecimals * preArtexTokenPriceUSDWEI * 1 ether) / (depositWEI * (10 ** uint(decimals))))"
            VariableDeclaration "preArtexEtherPriceUSDWEI"
               Type: uint256
               Source: "var preArtexEtherPriceUSDWEI"
            TupleExpression
               Type: uint256
               Source: "((tokensDecimals * preArtexTokenPriceUSDWEI * 1 ether) / (depositWEI * (10 ** uint(decimals))))"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "(tokensDecimals * preArtexTokenPriceUSDWEI * 1 ether) / (depositWEI * (10 ** uint(decimals)))"
                TupleExpression
                   Type: uint256
                   Source: "(tokensDecimals * preArtexTokenPriceUSDWEI * 1 ether)"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "tokensDecimals * preArtexTokenPriceUSDWEI * 1 ether"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "tokensDecimals * preArtexTokenPriceUSDWEI"
                      Identifier tokensDecimals
                         Type: uint256
                         Source: "tokensDecimals"
                      Identifier preArtexTokenPriceUSDWEI
                         Type: uint256
                         Source: "preArtexTokenPriceUSDWEI"
                    Literal, token: [no token] value: 1
                       Type: int_const 1000000000000000000
                       Source: "1 ether"
                TupleExpression
                   Type: uint256
                   Source: "(depositWEI * (10 ** uint(decimals)))"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "depositWEI * (10 ** uint(decimals))"
                    Identifier depositWEI
                       Type: uint256
                       Source: "depositWEI"
                    TupleExpression
                       Type: uint256
                       Source: "(10 ** uint(decimals))"
                      BinaryOperation using operator **
                         Type: uint256
                         Source: "10 ** uint(decimals)"
                        Literal, token: [no token] value: 10
                           Type: int_const 10
                           Source: "10"
                        FunctionCall
                           Type: uint256
                           Source: "uint(decimals)"
                          ElementaryTypeNameExpression uint
                             Type: type(uint256)
                             Source: "uint"
                          Identifier decimals
                             Type: uint8
                             Source: "decimals"
          IfStatement
             Source: "if (etherPriceUSDWEI > preArtexEtherPriceUSDWEI) {\r\n                tokensToTransfer = (tokensDecimals * etherPriceUSDWEI * 140) / (preArtexEtherPriceUSDWEI * 130);\r\n            } else {\r\n                tokensToTransfer = tokensDecimals * 140 / 130;\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 209
               Source: "etherPriceUSDWEI > preArtexEtherPriceUSDWEI"
              Identifier etherPriceUSDWEI
                 Type: uint256
                 Source: "etherPriceUSDWEI"
              Identifier preArtexEtherPriceUSDWEI
                 Type: uint256
                 Source: "preArtexEtherPriceUSDWEI"
            Block
               Source: "{\r\n                tokensToTransfer = (tokensDecimals * etherPriceUSDWEI * 140) / (preArtexEtherPriceUSDWEI * 130);\r\n            }"
              ExpressionStatement
                 Gas costs: 263
                 Source: "tokensToTransfer = (tokensDecimals * etherPriceUSDWEI * 140) / (preArtexEtherPriceUSDWEI * 130)"
                Assignment using operator =
                   Type: uint256
                   Source: "tokensToTransfer = (tokensDecimals * etherPriceUSDWEI * 140) / (preArtexEtherPriceUSDWEI * 130)"
                  Identifier tokensToTransfer
                     Type: uint256
                     Source: "tokensToTransfer"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "(tokensDecimals * etherPriceUSDWEI * 140) / (preArtexEtherPriceUSDWEI * 130)"
                    TupleExpression
                       Type: uint256
                       Source: "(tokensDecimals * etherPriceUSDWEI * 140)"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "tokensDecimals * etherPriceUSDWEI * 140"
                        BinaryOperation using operator *
                           Type: uint256
                           Source: "tokensDecimals * etherPriceUSDWEI"
                          Identifier tokensDecimals
                             Type: uint256
                             Source: "tokensDecimals"
                          Identifier etherPriceUSDWEI
                             Type: uint256
                             Source: "etherPriceUSDWEI"
                        Literal, token: [no token] value: 140
                           Type: int_const 140
                           Source: "140"
                    TupleExpression
                       Type: uint256
                       Source: "(preArtexEtherPriceUSDWEI * 130)"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "preArtexEtherPriceUSDWEI * 130"
                        Identifier preArtexEtherPriceUSDWEI
                           Type: uint256
                           Source: "preArtexEtherPriceUSDWEI"
                        Literal, token: [no token] value: 130
                           Type: int_const 130
                           Source: "130"
            Block
               Source: "{\r\n                tokensToTransfer = tokensDecimals * 140 / 130;\r\n            }"
              ExpressionStatement
                 Gas costs: 47
                 Source: "tokensToTransfer = tokensDecimals * 140 / 130"
                Assignment using operator =
                   Type: uint256
                   Source: "tokensToTransfer = tokensDecimals * 140 / 130"
                  Identifier tokensToTransfer
                     Type: uint256
                     Source: "tokensToTransfer"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "tokensDecimals * 140 / 130"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "tokensDecimals * 140"
                      Identifier tokensDecimals
                         Type: uint256
                         Source: "tokensDecimals"
                      Literal, token: [no token] value: 140
                         Type: int_const 140
                         Source: "140"
                    Literal, token: [no token] value: 130
                       Type: int_const 130
                       Source: "130"
      ExpressionStatement
         Gas costs: 20110
         Source: "balances[_address] = tokensToTransfer"
        Assignment using operator =
           Type: uint256
           Source: "balances[_address] = tokensToTransfer"
          IndexAccess
             Type: uint256
             Source: "balances[_address]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _address
               Type: address
               Source: "_address"
          Identifier tokensToTransfer
             Type: uint256
             Source: "tokensToTransfer"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply += tokensToTransfer"
        Assignment using operator +=
           Type: uint256
           Source: "totalSupply += tokensToTransfer"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier tokensToTransfer
             Type: uint256
             Source: "tokensToTransfer"
      ExpressionStatement
         Gas costs: 20357
         Source: "migratedInvestors[_address] = true"
        Assignment using operator =
           Type: bool
           Source: "migratedInvestors[_address] = true"
          IndexAccess
             Type: bool
             Source: "migratedInvestors[_address]"
            Identifier migratedInvestors
               Type: mapping(address => bool)
               Source: "migratedInvestors"
            Identifier _address
               Type: address
               Source: "_address"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      IfStatement
         Source: "if (state != State.CrowdsaleCompleted) {\r\n            Investor storage inv = investors[_address];\r\n            investorsIter[numberOfInvestors++] = _address;\r\n            inv.amountTokens += tokensToTransfer;\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 350
           Source: "state != State.CrowdsaleCompleted"
          Identifier state
             Type: enum Stateful.State
             Source: "state"
          MemberAccess to member CrowdsaleCompleted
             Type: enum Stateful.State
             Source: "State.CrowdsaleCompleted"
            Identifier State
               Type: type(enum Stateful.State)
               Source: "State"
        Block
           Source: "{\r\n            Investor storage inv = investors[_address];\r\n            investorsIter[numberOfInvestors++] = _address;\r\n            inv.amountTokens += tokensToTransfer;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 107
             Source: "Investor storage inv = investors[_address]"
            VariableDeclaration "inv"
               Type: struct Crowdsale.Investor storage pointer
               Source: "Investor storage inv"
              UserDefinedTypeName "Investor"
                 Source: "Investor"
            IndexAccess
               Type: struct Crowdsale.Investor storage ref
               Source: "investors[_address]"
              Identifier investors
                 Type: mapping(address => struct Crowdsale.Investor storage ref)
                 Source: "investors"
              Identifier _address
                 Type: address
                 Source: "_address"
          ExpressionStatement
             Gas costs: 40577
             Source: "investorsIter[numberOfInvestors++] = _address"
            Assignment using operator =
               Type: address
               Source: "investorsIter[numberOfInvestors++] = _address"
              IndexAccess
                 Type: address
                 Source: "investorsIter[numberOfInvestors++]"
                Identifier investorsIter
                   Type: mapping(uint256 => address)
                   Source: "investorsIter"
                UnaryOperation (postfix) ++
                   Type: uint256
                   Source: "numberOfInvestors++"
                  Identifier numberOfInvestors
                     Type: uint256
                     Source: "numberOfInvestors"
              Identifier _address
                 Type: address
                 Source: "_address"
          ExpressionStatement
             Gas costs: 20239
             Source: "inv.amountTokens += tokensToTransfer"
            Assignment using operator +=
               Type: uint256
               Source: "inv.amountTokens += tokensToTransfer"
              MemberAccess to member amountTokens
                 Type: uint256
                 Source: "inv.amountTokens"
                Identifier inv
                   Type: struct Crowdsale.Investor storage pointer
                   Source: "inv"
              Identifier tokensToTransfer
                 Type: uint256
                 Source: "tokensToTransfer"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(this, _address, tokensToTransfer)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(this, _address, tokensToTransfer)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier this
             Type: contract MigratableToken
             Source: "this"
          Identifier _address
             Type: address
             Source: "_address"
          Identifier tokensToTransfer
             Type: uint256
             Source: "tokensToTransfer"
  FunctionDefinition "migrate" - public
     Source: "function migrate() external {\r\n        require(migrationAgent != 0);\r\n        uint value = balances[msg.sender];\r\n        balances[msg.sender] -= value;\r\n        Transfer(msg.sender, this, value);\r\n        totalSupply -= value;\r\n        totalMigrated += value;\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);\r\n        Migrated(msg.sender, migrationAgent, value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(migrationAgent != 0);\r\n        uint value = balances[msg.sender];\r\n        balances[msg.sender] -= value;\r\n        Transfer(msg.sender, this, value);\r\n        totalSupply -= value;\r\n        totalMigrated += value;\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);\r\n        Migrated(msg.sender, migrationAgent, value);\r\n    }"
      ExpressionStatement
         Gas costs: 280
         Source: "require(migrationAgent != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(migrationAgent != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "migrationAgent != 0"
            Identifier migrationAgent
               Type: address
               Source: "migrationAgent"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 306
         Source: "uint value = balances[msg.sender]"
        VariableDeclaration "value"
           Type: uint256
           Source: "uint value"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "balances[msg.sender]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 5322
         Source: "balances[msg.sender] -= value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[msg.sender] -= value"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier value
             Type: uint256
             Source: "value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, this, value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, this, value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier this
             Type: contract MigratableToken
             Source: "this"
          Identifier value
             Type: uint256
             Source: "value"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply -= value"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= value"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier value
             Type: uint256
             Source: "value"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalMigrated += value"
        Assignment using operator +=
           Type: uint256
           Source: "totalMigrated += value"
          Identifier totalMigrated
             Type: uint256
             Source: "totalMigrated"
          Identifier value
             Type: uint256
             Source: "value"
      ExpressionStatement
         Gas costs: [???]
         Source: "MigrationAgent(migrationAgent).migrateFrom(msg.sender, value)"
        FunctionCall
           Type: tuple()
           Source: "MigrationAgent(migrationAgent).migrateFrom(msg.sender, value)"
          MemberAccess to member migrateFrom
             Type: function (address,uint256) external
             Source: "MigrationAgent(migrationAgent).migrateFrom"
            FunctionCall
               Type: contract MigrationAgent
               Source: "MigrationAgent(migrationAgent)"
              Identifier MigrationAgent
                 Type: type(contract MigrationAgent)
                 Source: "MigrationAgent"
              Identifier migrationAgent
                 Type: address
                 Source: "migrationAgent"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier value
             Type: uint256
             Source: "value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Migrated(msg.sender, migrationAgent, value)"
        FunctionCall
           Type: tuple()
           Source: "Migrated(msg.sender, migrationAgent, value)"
          Identifier Migrated
             Type: function (address,address,uint256)
             Source: "Migrated"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier migrationAgent
             Type: address
             Source: "migrationAgent"
          Identifier value
             Type: uint256
             Source: "value"
  FunctionDefinition "setMigrationAgent" - public
     Source: "function setMigrationAgent(address _agent) external onlyOwner {\r\n        require(migrationAgent == 0);\r\n        migrationAgent = _agent;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _agent)"
      VariableDeclaration "_agent"
         Type: address
         Source: "address _agent"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(migrationAgent == 0);\r\n        migrationAgent = _agent;\r\n    }"
      ExpressionStatement
         Gas costs: 277
         Source: "require(migrationAgent == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(migrationAgent == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "migrationAgent == 0"
            Identifier migrationAgent
               Type: address
               Source: "migrationAgent"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "migrationAgent = _agent"
        Assignment using operator =
           Type: address
           Source: "migrationAgent = _agent"
          Identifier migrationAgent
             Type: address
             Source: "migrationAgent"
          Identifier _agent
             Type: address
             Source: "_agent"
ContractDefinition "ArtexToken"
   Source: "contract ArtexToken is MigratableToken {\r\n\r\n    string public constant symbol = \"ART\";\r\n\r\n    string public constant name = \"Artex Token\";\r\n\r\n    mapping(address => bool) public allowedContracts;\r\n\r\n    function ArtexToken() payable MigratableToken() {}\r\n\r\n    function emitTokens(address _investor, uint _tokenPriceUSDWEI, uint _valueUSDWEI) internal returns(uint tokensToEmit) {\r\n        tokensToEmit = (_valueUSDWEI * (10 ** uint(decimals))) / _tokenPriceUSDWEI;\r\n        require(balances[_investor] + tokensToEmit > balances[_investor]); // overflow\r\n        require(tokensToEmit > 0);\r\n        balances[_investor] += tokensToEmit;\r\n        totalSupply += tokensToEmit;\r\n        Transfer(this, _investor, tokensToEmit);\r\n    }\r\n\r\n    function emitAdditionalTokens() internal {\r\n        uint tokensToEmit = totalSupply * 100 / 74 - totalSupply;\r\n        require(balances[beneficiary] + tokensToEmit > balances[beneficiary]); // overflow\r\n        require(tokensToEmit > 0);\r\n        balances[beneficiary] += tokensToEmit;\r\n        totalSupply += tokensToEmit;\r\n        Transfer(this, beneficiary, tokensToEmit);\r\n    }\r\n\r\n    function burnTokens(address _address, uint _amount) internal {\r\n        balances[_address] -= _amount;\r\n        totalSupply -= _amount;\r\n        Transfer(_address, this, _amount);\r\n    }\r\n\r\n    function addAllowedContract(address _address) external onlyOwner {\r\n        require(_address != 0);\r\n        allowedContracts[_address] = true;\r\n    }\r\n\r\n    function removeAllowedContract(address _address) external onlyOwner {\r\n        require(_address != 0);\r\n        delete allowedContracts[_address];\r\n    }\r\n\r\n    function transferToKnownContract(address _to, uint256 _value, bytes32[] _data) external onlyAllowedContracts(_to) {\r\n        var knownContract = KnownContract(_to);\r\n        transfer(_to, _value);\r\n        knownContract.transfered(msg.sender, _value, _data);\r\n    }\r\n\r\n    modifier onlyAllowedContracts(address _address) {\r\n        require(allowedContracts[_address] == true);\r\n        _;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "MigratableToken"
    UserDefinedTypeName "MigratableToken"
       Source: "MigratableToken"
  VariableDeclaration "symbol"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant symbol = \"ART\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: ART
       Type: literal_string "ART"
       Source: "\"ART\""
  VariableDeclaration "name"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant name = \"Artex Token\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Artex Token
       Type: literal_string "Artex Token"
       Source: "\"Artex Token\""
  VariableDeclaration "allowedContracts"
     Type: mapping(address => bool)
     Gas costs: [???]
     Source: "mapping(address => bool) public allowedContracts"
    Mapping
       Source: "mapping(address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  FunctionDefinition "ArtexToken" - public
     Source: "function ArtexToken() payable MigratableToken() {}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "MigratableToken"
       Gas costs: 0
       Source: "MigratableToken()"
      Identifier MigratableToken
         Type: type(contract MigratableToken)
         Source: "MigratableToken"
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "emitTokens"
     Source: "function emitTokens(address _investor, uint _tokenPriceUSDWEI, uint _valueUSDWEI) internal returns(uint tokensToEmit) {\r\n        tokensToEmit = (_valueUSDWEI * (10 ** uint(decimals))) / _tokenPriceUSDWEI;\r\n        require(balances[_investor] + tokensToEmit > balances[_investor]); // overflow\r\n        require(tokensToEmit > 0);\r\n        balances[_investor] += tokensToEmit;\r\n        totalSupply += tokensToEmit;\r\n        Transfer(this, _investor, tokensToEmit);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _investor, uint _tokenPriceUSDWEI, uint _valueUSDWEI)"
      VariableDeclaration "_investor"
         Type: address
         Source: "address _investor"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokenPriceUSDWEI"
         Type: uint256
         Source: "uint _tokenPriceUSDWEI"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_valueUSDWEI"
         Type: uint256
         Source: "uint _valueUSDWEI"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint tokensToEmit)"
      VariableDeclaration "tokensToEmit"
         Type: uint256
         Source: "uint tokensToEmit"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        tokensToEmit = (_valueUSDWEI * (10 ** uint(decimals))) / _tokenPriceUSDWEI;\r\n        require(balances[_investor] + tokensToEmit > balances[_investor]); // overflow\r\n        require(tokensToEmit > 0);\r\n        balances[_investor] += tokensToEmit;\r\n        totalSupply += tokensToEmit;\r\n        Transfer(this, _investor, tokensToEmit);\r\n    }"
      ExpressionStatement
         Gas costs: 113
         Source: "tokensToEmit = (_valueUSDWEI * (10 ** uint(decimals))) / _tokenPriceUSDWEI"
        Assignment using operator =
           Type: uint256
           Source: "tokensToEmit = (_valueUSDWEI * (10 ** uint(decimals))) / _tokenPriceUSDWEI"
          Identifier tokensToEmit
             Type: uint256
             Source: "tokensToEmit"
          BinaryOperation using operator /
             Type: uint256
             Source: "(_valueUSDWEI * (10 ** uint(decimals))) / _tokenPriceUSDWEI"
            TupleExpression
               Type: uint256
               Source: "(_valueUSDWEI * (10 ** uint(decimals)))"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "_valueUSDWEI * (10 ** uint(decimals))"
                Identifier _valueUSDWEI
                   Type: uint256
                   Source: "_valueUSDWEI"
                TupleExpression
                   Type: uint256
                   Source: "(10 ** uint(decimals))"
                  BinaryOperation using operator **
                     Type: uint256
                     Source: "10 ** uint(decimals)"
                    Literal, token: [no token] value: 10
                       Type: int_const 10
                       Source: "10"
                    FunctionCall
                       Type: uint256
                       Source: "uint(decimals)"
                      ElementaryTypeNameExpression uint
                         Type: type(uint256)
                         Source: "uint"
                      Identifier decimals
                         Type: uint8
                         Source: "decimals"
            Identifier _tokenPriceUSDWEI
               Type: uint256
               Source: "_tokenPriceUSDWEI"
      ExpressionStatement
         Gas costs: 627
         Source: "require(balances[_investor] + tokensToEmit > balances[_investor])"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_investor] + tokensToEmit > balances[_investor])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balances[_investor] + tokensToEmit > balances[_investor]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balances[_investor] + tokensToEmit"
              IndexAccess
                 Type: uint256
                 Source: "balances[_investor]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _investor
                   Type: address
                   Source: "_investor"
              Identifier tokensToEmit
                 Type: uint256
                 Source: "tokensToEmit"
            IndexAccess
               Type: uint256
               Source: "balances[_investor]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _investor
                 Type: address
                 Source: "_investor"
      ExpressionStatement
         Gas costs: 35
         Source: "require(tokensToEmit > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(tokensToEmit > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "tokensToEmit > 0"
            Identifier tokensToEmit
               Type: uint256
               Source: "tokensToEmit"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[_investor] += tokensToEmit"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_investor] += tokensToEmit"
          IndexAccess
             Type: uint256
             Source: "balances[_investor]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _investor
               Type: address
               Source: "_investor"
          Identifier tokensToEmit
             Type: uint256
             Source: "tokensToEmit"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply += tokensToEmit"
        Assignment using operator +=
           Type: uint256
           Source: "totalSupply += tokensToEmit"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier tokensToEmit
             Type: uint256
             Source: "tokensToEmit"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(this, _investor, tokensToEmit)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(this, _investor, tokensToEmit)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier this
             Type: contract ArtexToken
             Source: "this"
          Identifier _investor
             Type: address
             Source: "_investor"
          Identifier tokensToEmit
             Type: uint256
             Source: "tokensToEmit"
  FunctionDefinition "emitAdditionalTokens"
     Source: "function emitAdditionalTokens() internal {\r\n        uint tokensToEmit = totalSupply * 100 / 74 - totalSupply;\r\n        require(balances[beneficiary] + tokensToEmit > balances[beneficiary]); // overflow\r\n        require(tokensToEmit > 0);\r\n        balances[beneficiary] += tokensToEmit;\r\n        totalSupply += tokensToEmit;\r\n        Transfer(this, beneficiary, tokensToEmit);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint tokensToEmit = totalSupply * 100 / 74 - totalSupply;\r\n        require(balances[beneficiary] + tokensToEmit > balances[beneficiary]); // overflow\r\n        require(tokensToEmit > 0);\r\n        balances[beneficiary] += tokensToEmit;\r\n        totalSupply += tokensToEmit;\r\n        Transfer(this, beneficiary, tokensToEmit);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 456
         Source: "uint tokensToEmit = totalSupply * 100 / 74 - totalSupply"
        VariableDeclaration "tokensToEmit"
           Type: uint256
           Source: "uint tokensToEmit"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator -
           Type: uint256
           Source: "totalSupply * 100 / 74 - totalSupply"
          BinaryOperation using operator /
             Type: uint256
             Source: "totalSupply * 100 / 74"
            BinaryOperation using operator *
               Type: uint256
               Source: "totalSupply * 100"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
              Literal, token: [no token] value: 100
                 Type: int_const 100
                 Source: "100"
            Literal, token: [no token] value: 74
               Type: int_const 74
               Source: "74"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
      ExpressionStatement
         Gas costs: 1099
         Source: "require(balances[beneficiary] + tokensToEmit > balances[beneficiary])"
        FunctionCall
           Type: tuple()
           Source: "require(balances[beneficiary] + tokensToEmit > balances[beneficiary])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balances[beneficiary] + tokensToEmit > balances[beneficiary]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balances[beneficiary] + tokensToEmit"
              IndexAccess
                 Type: uint256
                 Source: "balances[beneficiary]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier beneficiary
                   Type: address
                   Source: "beneficiary"
              Identifier tokensToEmit
                 Type: uint256
                 Source: "tokensToEmit"
            IndexAccess
               Type: uint256
               Source: "balances[beneficiary]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier beneficiary
                 Type: address
                 Source: "beneficiary"
      ExpressionStatement
         Gas costs: 35
         Source: "require(tokensToEmit > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(tokensToEmit > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "tokensToEmit > 0"
            Identifier tokensToEmit
               Type: uint256
               Source: "tokensToEmit"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20565
         Source: "balances[beneficiary] += tokensToEmit"
        Assignment using operator +=
           Type: uint256
           Source: "balances[beneficiary] += tokensToEmit"
          IndexAccess
             Type: uint256
             Source: "balances[beneficiary]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier beneficiary
               Type: address
               Source: "beneficiary"
          Identifier tokensToEmit
             Type: uint256
             Source: "tokensToEmit"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply += tokensToEmit"
        Assignment using operator +=
           Type: uint256
           Source: "totalSupply += tokensToEmit"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier tokensToEmit
             Type: uint256
             Source: "tokensToEmit"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(this, beneficiary, tokensToEmit)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(this, beneficiary, tokensToEmit)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier this
             Type: contract ArtexToken
             Source: "this"
          Identifier beneficiary
             Type: address
             Source: "beneficiary"
          Identifier tokensToEmit
             Type: uint256
             Source: "tokensToEmit"
  FunctionDefinition "burnTokens"
     Source: "function burnTokens(address _address, uint _amount) internal {\r\n        balances[_address] -= _amount;\r\n        totalSupply -= _amount;\r\n        Transfer(_address, this, _amount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address, uint _amount)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        balances[_address] -= _amount;\r\n        totalSupply -= _amount;\r\n        Transfer(_address, this, _amount);\r\n    }"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[_address] -= _amount"
        Assignment using operator -=
           Type: uint256
           Source: "balances[_address] -= _amount"
          IndexAccess
             Type: uint256
             Source: "balances[_address]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _address
               Type: address
               Source: "_address"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply -= _amount"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= _amount"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_address, this, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_address, this, _amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _address
             Type: address
             Source: "_address"
          Identifier this
             Type: contract ArtexToken
             Source: "this"
          Identifier _amount
             Type: uint256
             Source: "_amount"
  FunctionDefinition "addAllowedContract" - public
     Source: "function addAllowedContract(address _address) external onlyOwner {\r\n        require(_address != 0);\r\n        allowedContracts[_address] = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_address != 0);\r\n        allowedContracts[_address] = true;\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "require(_address != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_address != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_address != 0"
            Identifier _address
               Type: address
               Source: "_address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20363
         Source: "allowedContracts[_address] = true"
        Assignment using operator =
           Type: bool
           Source: "allowedContracts[_address] = true"
          IndexAccess
             Type: bool
             Source: "allowedContracts[_address]"
            Identifier allowedContracts
               Type: mapping(address => bool)
               Source: "allowedContracts"
            Identifier _address
               Type: address
               Source: "_address"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "removeAllowedContract" - public
     Source: "function removeAllowedContract(address _address) external onlyOwner {\r\n        require(_address != 0);\r\n        delete allowedContracts[_address];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_address != 0);\r\n        delete allowedContracts[_address];\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "require(_address != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_address != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_address != 0"
            Identifier _address
               Type: address
               Source: "_address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20338
         Source: "delete allowedContracts[_address]"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete allowedContracts[_address]"
          IndexAccess
             Type: bool
             Source: "allowedContracts[_address]"
            Identifier allowedContracts
               Type: mapping(address => bool)
               Source: "allowedContracts"
            Identifier _address
               Type: address
               Source: "_address"
  FunctionDefinition "transferToKnownContract" - public
     Source: "function transferToKnownContract(address _to, uint256 _value, bytes32[] _data) external onlyAllowedContracts(_to) {\r\n        var knownContract = KnownContract(_to);\r\n        transfer(_to, _value);\r\n        knownContract.transfered(msg.sender, _value, _data);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value, bytes32[] _data)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_data"
         Type: bytes32[] calldata
         Source: "bytes32[] _data"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAllowedContracts"
       Gas costs: 3
       Source: "onlyAllowedContracts(_to)"
      Identifier onlyAllowedContracts
         Type: modifier (address)
         Source: "onlyAllowedContracts"
      Identifier _to
         Type: address
         Source: "_to"
    Block
       Source: "{\r\n        var knownContract = KnownContract(_to);\r\n        transfer(_to, _value);\r\n        knownContract.transfered(msg.sender, _value, _data);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "var knownContract = KnownContract(_to)"
        VariableDeclaration "knownContract"
           Type: contract KnownContract
           Source: "var knownContract"
        FunctionCall
           Type: contract KnownContract
           Source: "KnownContract(_to)"
          Identifier KnownContract
             Type: type(contract KnownContract)
             Source: "KnownContract"
          Identifier _to
             Type: address
             Source: "_to"
      ExpressionStatement
         Gas costs: 21
         Source: "transfer(_to, _value)"
        FunctionCall
           Type: tuple()
           Source: "transfer(_to, _value)"
          Identifier transfer
             Type: function (address,uint256)
             Source: "transfer"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "knownContract.transfered(msg.sender, _value, _data)"
        FunctionCall
           Type: tuple()
           Source: "knownContract.transfered(msg.sender, _value, _data)"
          MemberAccess to member transfered
             Type: function (address,uint256,bytes32[] memory) external
             Source: "knownContract.transfered"
            Identifier knownContract
               Type: contract KnownContract
               Source: "knownContract"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier _data
             Type: bytes32[] calldata
             Source: "_data"
  ModifierDefinition "onlyAllowedContracts"
     Source: "modifier onlyAllowedContracts(address _address) {\r\n        require(allowedContracts[_address] == true);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        require(allowedContracts[_address] == true);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 379
         Source: "require(allowedContracts[_address] == true)"
        FunctionCall
           Type: tuple()
           Source: "require(allowedContracts[_address] == true)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "allowedContracts[_address] == true"
            IndexAccess
               Type: bool
               Source: "allowedContracts[_address]"
              Identifier allowedContracts
                 Type: mapping(address => bool)
                 Source: "allowedContracts"
              Identifier _address
                 Type: address
                 Source: "_address"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
