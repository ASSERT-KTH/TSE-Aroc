Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x4f8144764a115b868cb14d71576ccf961f943452.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.15;"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "mul" - const
     Source: "function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 88
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div" - const
     Source: "function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub" - const
     Source: "function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add" - const
     Source: "function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "ERC20Basic"
   Gas costs: [???]
   Source: "contract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) public constant returns (uint256);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address to, uint256 value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "ERC20"
   Gas costs: 0
   Source: "contract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
  InheritanceSpecifier
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) public constant returns (uint256);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address from, address to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address spender, uint256 value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint256 value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint256 value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "BasicToken"
   Source: "contract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) balances"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(_to != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_to != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != address(0)"
            Identifier _to
               Type: address
               Source: "_to"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 20437
         Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "balances[msg.sender].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20433
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return balances[_owner];\r\n  }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue)\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue)\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  InheritanceSpecifier
     Gas costs: 0
     Source: "BasicToken"
    UserDefinedTypeName "BasicToken"
       Source: "BasicToken"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(_to != address(0));\r\n\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(_to != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_to != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != address(0)"
            Identifier _to
               Type: address
               Source: "_to"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      VariableDeclarationStatement
         Gas costs: 396
         Source: "uint256 _allowance = allowed[_from][msg.sender]"
        VariableDeclaration "_allowance"
           Type: uint256
           Source: "uint256 _allowance"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "allowed[_from][msg.sender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_from]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _from
               Type: address
               Source: "_from"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20433
         Source: "balances[_from] = balances[_from].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_from] = balances[_from].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "balances[_from].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[_from].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20433
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20232
         Source: "allowed[_from][msg.sender] = _allowance.sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[_from][msg.sender] = _allowance.sub(_value)"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "_allowance.sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "_allowance.sub"
              Identifier _allowance
                 Type: uint256
                 Source: "_allowance"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return allowed[_owner][_spender];\r\n  }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  FunctionDefinition "increaseApproval" - public
     Source: "function increaseApproval (address _spender, uint _addedValue)\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _addedValue)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_addedValue"
         Type: uint256
         Source: "uint _addedValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 20617
         Source: "allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          FunctionCall
             Type: uint256
             Source: "allowed[msg.sender][_spender].add(_addedValue)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "allowed[msg.sender][_spender].add"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
            Identifier _addedValue
               Type: uint256
               Source: "_addedValue"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "decreaseApproval" - public
     Source: "function decreaseApproval (address _spender, uint _subtractedValue)\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _subtractedValue)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_subtractedValue"
         Type: uint256
         Source: "uint _subtractedValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 396
         Source: "uint oldValue = allowed[msg.sender][_spender]"
        VariableDeclaration "oldValue"
           Type: uint256
           Source: "uint oldValue"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "allowed[msg.sender][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[msg.sender]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
      IfStatement
         Source: "if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "_subtractedValue > oldValue"
          Identifier _subtractedValue
             Type: uint256
             Source: "_subtractedValue"
          Identifier oldValue
             Type: uint256
             Source: "oldValue"
        Block
           Source: "{\r\n      allowed[msg.sender][_spender] = 0;\r\n    }"
          ExpressionStatement
             Gas costs: 5199
             Source: "allowed[msg.sender][_spender] = 0"
            Assignment using operator =
               Type: uint256
               Source: "allowed[msg.sender][_spender] = 0"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }"
          ExpressionStatement
             Gas costs: 20232
             Source: "allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)"
            Assignment using operator =
               Type: uint256
               Source: "allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
              FunctionCall
                 Type: uint256
                 Source: "oldValue.sub(_subtractedValue)"
                MemberAccess to member sub
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "oldValue.sub"
                  Identifier oldValue
                     Type: uint256
                     Source: "oldValue"
                Identifier _subtractedValue
                   Type: uint256
                   Source: "_subtractedValue"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
ContractDefinition "Ownable"
   Source: "contract Ownable {\r\n\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));\r\n    owner = newOwner;\r\n  }\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "Ownable" - public
     Source: "function Ownable() {\r\n    owner = msg.sender;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    owner = msg.sender;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 846
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 1
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));\r\n    owner = newOwner;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(newOwner != address(0));\r\n    owner = newOwner;\r\n  }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(newOwner != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(newOwner != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "newOwner != address(0)"
            Identifier newOwner
               Type: address
               Source: "newOwner"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
ContractDefinition "CrowdsaleToken"
   Source: "contract CrowdsaleToken is StandardToken, Ownable {\r\n    \r\n  string public standard = \"AfterSchool Token v1.0\";\r\n  string public name = \"AfterSchool Token\";\r\n  string public symbol = \"AST\";\r\n  uint public decimals = 18;\r\n  address public multisig = 0x8Dab59292A76114776B4933aD6F1246Bf647aB90;\r\n  \r\n  // 1 ETH = 5800 AST tokens (1 AST = 0.05 USD)\r\n  uint PRICE = 5800;\r\n  \r\n  struct ContributorData {\r\n    uint contributionAmount;\r\n    uint tokensIssued;\r\n  }\r\n\r\n  mapping(address => ContributorData) public contributorList;\r\n  uint nextContributorIndex;\r\n  mapping(uint => address) contributorIndexes;\r\n  \r\n  state public crowdsaleState = state.pendingStart;\r\n  enum state { pendingStart, crowdsale, crowdsaleEnded }\r\n  \r\n  event CrowdsaleStarted(uint blockNumber);\r\n  event CrowdsaleEnded(uint blockNumber);\r\n  event ErrorSendingETH(address to, uint amount);\r\n  event MinCapReached(uint blockNumber);\r\n  event MaxCapReached(uint blockNumber);\r\n  \r\n  uint public constant BEGIN_TIME = 1506420000;\r\n  \r\n  uint public constant END_TIME = 1509012000;\r\n\r\n  uint public minCap = 3500 ether;\r\n  uint public maxCap = 50000 ether;\r\n  uint public ethRaised = 0;\r\n  uint public tokenTotalSupply = 800000000 * 10**decimals;\r\n  \r\n  uint crowdsaleTokenCap =            480000000 * 10**decimals; // 60%\r\n  uint foundersAndTeamTokens =        120000000 * 10**decimals; // 15%\r\n  uint advisorAndAmbassadorTokens =    56000000 * 10**decimals; // 7%\r\n  uint investorTokens =                8000000 * 10**decimals; // 10%\r\n  uint afterschoolContributorTokens = 56000000 * 10**decimals; // 7%\r\n  uint futurePartnerTokens =          64000000 * 10**decimals; // 8%\r\n  \r\n  bool foundersAndTeamTokensClaimed = false;\r\n  bool advisorAndAmbassadorTokensClaimed = false;\r\n  bool investorTokensClaimed = false;\r\n  bool afterschoolContributorTokensClaimed = false;\r\n  bool futurePartnerTokensClaimed = false;\r\n  uint nextContributorToClaim;\r\n  mapping(address => bool) hasClaimedEthWhenFail;\r\n\r\n  function() payable {\r\n  require(msg.value != 0);\r\n  require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\r\n  \r\n  bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\r\n  \r\n  if(crowdsaleState == state.crowdsale) {\r\n      createTokens(msg.sender);             // Process transaction and issue tokens\r\n    } else {\r\n      refundTransaction(stateChanged);              // Set state and return funds or throw\r\n    }\r\n  }\r\n  \r\n  //\r\n  // Check crowdsale state and calibrate it\r\n  //\r\n  function checkCrowdsaleState() internal returns (bool) {\r\n    if (ethRaised >= maxCap && crowdsaleState != state.crowdsaleEnded) { // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number); // Raise event\r\n      return true;\r\n    }\r\n    \r\n    if(now >= END_TIME) {   \r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number); // Raise event\r\n      return true;\r\n    }\r\n\r\n    if(now >= BEGIN_TIME && now < END_TIME) {        // Check if we are in crowdsale state\r\n      if (crowdsaleState != state.crowdsale) {                                                   // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n  \r\n  //\r\n  // Decide if throw or only return ether\r\n  //\r\n  function refundTransaction(bool _stateChanged) internal {\r\n    if (_stateChanged) {\r\n      msg.sender.transfer(msg.value);\r\n    } else {\r\n      revert();\r\n    }\r\n  }\r\n  \r\n  function createTokens(address _contributor) payable {\r\n  \r\n    uint _amount = msg.value;\r\n  \r\n    uint contributionAmount = _amount;\r\n    uint returnAmount = 0;\r\n    \r\n    if (_amount > (maxCap - ethRaised)) {                                          // Check if max contribution is lower than _amount sent\r\n      contributionAmount = maxCap - ethRaised;                                     // Set that user contibutes his maximum alowed contribution\r\n      returnAmount = _amount - contributionAmount;                                 // Calculate how much he must get back\r\n    }\r\n\r\n    if (ethRaised + contributionAmount > minCap && minCap > ethRaised) {\r\n      MinCapReached(block.number);\r\n    }\r\n\r\n    if (ethRaised + contributionAmount == maxCap && ethRaised < maxCap) {\r\n      MaxCapReached(block.number);\r\n    }\r\n\r\n    if (contributorList[_contributor].contributionAmount == 0){\r\n        contributorIndexes[nextContributorIndex] = _contributor;\r\n        nextContributorIndex += 1;\r\n    }\r\n  \r\n    contributorList[_contributor].contributionAmount += contributionAmount;\r\n    ethRaised += contributionAmount;                                              // Add to eth raised\r\n\r\n    uint tokenAmount = calculateEthToAfterschool(contributionAmount);      // Calculate how much tokens must contributor get\r\n    if (tokenAmount > 0) {\r\n      totalSupply = totalSupply.add(tokenAmount);\r\n      balances[_contributor] = balances[_contributor].add(tokenAmount);\r\n      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\r\n    }\r\n\r\n    if (!multisig.send(msg.value)) {\r\n        revert();\r\n    }\r\n  }\r\n  \r\n  function calculateEthToAfterschool(uint _eth) constant returns(uint) {\r\n  \r\n    uint tokens = _eth.mul(getPrice());\r\n    uint percentage = 0;\r\n    \r\n    if (ethRaised > 0)\r\n    {\r\n        percentage = ethRaised * 100 / maxCap;\r\n    }\r\n    \r\n    return tokens + getStageBonus(percentage, tokens) + getAmountBonus(_eth, tokens);\r\n  }\r\n\r\n  function getStageBonus(uint percentage, uint tokens) constant returns (uint) {\r\n    uint stageBonus = 0;\r\n      \r\n    if (percentage <= 10) stageBonus = tokens * 60 / 100; // Stage 1\r\n    else if (percentage <= 50) stageBonus = tokens * 30 / 100;\r\n    else if (percentage <= 70) stageBonus = tokens * 20 / 100;\r\n    else if (percentage <= 90) stageBonus = tokens * 15 / 100;\r\n    else if (percentage <= 100) stageBonus = tokens * 10 / 100;\r\n\r\n    return stageBonus;\r\n  }\r\n\r\n  function getAmountBonus(uint _eth, uint tokens) constant returns (uint) {\r\n    uint amountBonus = 0;  \r\n      \r\n    if (_eth >= 3000 ether) amountBonus = tokens * 13 / 100;\r\n    else if (_eth >= 2000 ether) amountBonus = tokens * 12 / 100;\r\n    else if (_eth >= 1500 ether) amountBonus = tokens * 11 / 100;\r\n    else if (_eth >= 1000 ether) amountBonus = tokens * 10 / 100;\r\n    else if (_eth >= 750 ether) amountBonus = tokens * 9 / 100;\r\n    else if (_eth >= 500 ether) amountBonus = tokens * 8 / 100;\r\n    else if (_eth >= 300 ether) amountBonus = tokens * 75 / 1000;\r\n    else if (_eth >= 200 ether) amountBonus = tokens * 7 / 100;\r\n    else if (_eth >= 150 ether) amountBonus = tokens * 6 / 100;\r\n    else if (_eth >= 100 ether) amountBonus = tokens * 55 / 1000;\r\n    else if (_eth >= 75 ether) amountBonus = tokens * 5 / 100;\r\n    else if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000;\r\n    \r\n    return amountBonus;\r\n  }\r\n  \r\n  // replace this with any other price function\r\n  function getPrice() constant returns (uint result) {\r\n    return PRICE;\r\n  }\r\n  \r\n  //\r\n  // Owner can batch return contributors contributions(eth)\r\n  //\r\n  function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner {\r\n    require(crowdsaleState != state.crowdsaleEnded);                // Check if crowdsale has ended\r\n    require(ethRaised < minCap);                // Check if crowdsale has failed\r\n    address currentParticipantAddress;\r\n    uint contribution;\r\n    for (uint cnt = 0; cnt < _numberOfReturns; cnt++){\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\r\n      if (currentParticipantAddress == 0x0) return;                                   // Check if all the participants were compensated\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)){                           // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                                    // Repeat\r\n    }\r\n  }\r\n  \r\n    //\r\n  // Owner can set multisig address for crowdsale\r\n  //\r\n  function setMultisigAddress(address _newAddress) onlyOwner {\r\n    multisig = _newAddress;\r\n  }\r\n  \r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  VariableDeclaration "standard"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public standard = \"AfterSchool Token v1.0\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: AfterSchool Token v1.0
       Type: literal_string "AfterSchool Token v1.0"
       Source: "\"AfterSchool Token v1.0\""
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public name = \"AfterSchool Token\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: AfterSchool Token
       Type: literal_string "AfterSchool Token"
       Source: "\"AfterSchool Token\""
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public symbol = \"AST\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: AST
       Type: literal_string "AST"
       Source: "\"AST\""
  VariableDeclaration "decimals"
     Type: uint256
     Gas costs: [???]
     Source: "uint public decimals = 18"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "multisig"
     Type: address
     Gas costs: [???]
     Source: "address public multisig = 0x8Dab59292A76114776B4933aD6F1246Bf647aB90"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x8Dab59292A76114776B4933aD6F1246Bf647aB90
       Type: address
       Source: "0x8Dab59292A76114776B4933aD6F1246Bf647aB90"
  VariableDeclaration "PRICE"
     Type: uint256
     Gas costs: 0
     Source: "uint PRICE = 5800"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 5800
       Type: int_const 5800
       Source: "5800"
  StructDefinition "ContributorData"
     Gas costs: 0
     Source: "struct ContributorData {\r\n    uint contributionAmount;\r\n    uint tokensIssued;\r\n  }"
    VariableDeclaration "contributionAmount"
       Type: uint256
       Source: "uint contributionAmount"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "tokensIssued"
       Type: uint256
       Source: "uint tokensIssued"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "contributorList"
     Type: mapping(address => struct CrowdsaleToken.ContributorData storage ref)
     Gas costs: [???]
     Source: "mapping(address => ContributorData) public contributorList"
    Mapping
       Source: "mapping(address => ContributorData)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "ContributorData"
         Source: "ContributorData"
  VariableDeclaration "nextContributorIndex"
     Type: uint256
     Gas costs: 0
     Source: "uint nextContributorIndex"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "contributorIndexes"
     Type: mapping(uint256 => address)
     Gas costs: 0
     Source: "mapping(uint => address) contributorIndexes"
    Mapping
       Source: "mapping(uint => address)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "crowdsaleState"
     Type: enum CrowdsaleToken.state
     Gas costs: [???]
     Source: "state public crowdsaleState = state.pendingStart"
    UserDefinedTypeName "state"
       Source: "state"
    MemberAccess to member pendingStart
       Type: enum CrowdsaleToken.state
       Source: "state.pendingStart"
      Identifier state
         Type: type(enum CrowdsaleToken.state)
         Source: "state"
  EnumDefinition "state"
    EnumValue "pendingStart"
    EnumValue "crowdsale"
    EnumValue "crowdsaleEnded"
  EventDefinition "CrowdsaleStarted"
     Gas costs: 0
     Source: "event CrowdsaleStarted(uint blockNumber);"
    ParameterList
       Source: "(uint blockNumber)"
      VariableDeclaration "blockNumber"
         Type: uint256
         Source: "uint blockNumber"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "CrowdsaleEnded"
     Gas costs: 0
     Source: "event CrowdsaleEnded(uint blockNumber);"
    ParameterList
       Source: "(uint blockNumber)"
      VariableDeclaration "blockNumber"
         Type: uint256
         Source: "uint blockNumber"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "ErrorSendingETH"
     Gas costs: 0
     Source: "event ErrorSendingETH(address to, uint amount);"
    ParameterList
       Source: "(address to, uint amount)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "MinCapReached"
     Gas costs: 0
     Source: "event MinCapReached(uint blockNumber);"
    ParameterList
       Source: "(uint blockNumber)"
      VariableDeclaration "blockNumber"
         Type: uint256
         Source: "uint blockNumber"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "MaxCapReached"
     Gas costs: 0
     Source: "event MaxCapReached(uint blockNumber);"
    ParameterList
       Source: "(uint blockNumber)"
      VariableDeclaration "blockNumber"
         Type: uint256
         Source: "uint blockNumber"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "BEGIN_TIME"
     Type: uint256
     Gas costs: [???]
     Source: "uint public constant BEGIN_TIME = 1506420000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1506420000
       Type: int_const 1506420000
       Source: "1506420000"
  VariableDeclaration "END_TIME"
     Type: uint256
     Gas costs: [???]
     Source: "uint public constant END_TIME = 1509012000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1509012000
       Type: int_const 1509012000
       Source: "1509012000"
  VariableDeclaration "minCap"
     Type: uint256
     Gas costs: [???]
     Source: "uint public minCap = 3500 ether"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 3500
       Type: int_const 3500000000000000000000
       Source: "3500 ether"
  VariableDeclaration "maxCap"
     Type: uint256
     Gas costs: [???]
     Source: "uint public maxCap = 50000 ether"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 50000
       Type: int_const 50000000000000000000000
       Source: "50000 ether"
  VariableDeclaration "ethRaised"
     Type: uint256
     Gas costs: [???]
     Source: "uint public ethRaised = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "tokenTotalSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint public tokenTotalSupply = 800000000 * 10**decimals"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: uint256
       Source: "800000000 * 10**decimals"
      Literal, token: [no token] value: 800000000
         Type: int_const 800000000
         Source: "800000000"
      BinaryOperation using operator **
         Type: uint256
         Source: "10**decimals"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Identifier decimals
           Type: uint256
           Source: "decimals"
  VariableDeclaration "crowdsaleTokenCap"
     Type: uint256
     Gas costs: 0
     Source: "uint crowdsaleTokenCap =            480000000 * 10**decimals"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: uint256
       Source: "480000000 * 10**decimals"
      Literal, token: [no token] value: 480000000
         Type: int_const 480000000
         Source: "480000000"
      BinaryOperation using operator **
         Type: uint256
         Source: "10**decimals"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Identifier decimals
           Type: uint256
           Source: "decimals"
  VariableDeclaration "foundersAndTeamTokens"
     Type: uint256
     Gas costs: 0
     Source: "uint foundersAndTeamTokens =        120000000 * 10**decimals"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: uint256
       Source: "120000000 * 10**decimals"
      Literal, token: [no token] value: 120000000
         Type: int_const 120000000
         Source: "120000000"
      BinaryOperation using operator **
         Type: uint256
         Source: "10**decimals"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Identifier decimals
           Type: uint256
           Source: "decimals"
  VariableDeclaration "advisorAndAmbassadorTokens"
     Type: uint256
     Gas costs: 0
     Source: "uint advisorAndAmbassadorTokens =    56000000 * 10**decimals"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: uint256
       Source: "56000000 * 10**decimals"
      Literal, token: [no token] value: 56000000
         Type: int_const 56000000
         Source: "56000000"
      BinaryOperation using operator **
         Type: uint256
         Source: "10**decimals"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Identifier decimals
           Type: uint256
           Source: "decimals"
  VariableDeclaration "investorTokens"
     Type: uint256
     Gas costs: 0
     Source: "uint investorTokens =                8000000 * 10**decimals"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: uint256
       Source: "8000000 * 10**decimals"
      Literal, token: [no token] value: 8000000
         Type: int_const 8000000
         Source: "8000000"
      BinaryOperation using operator **
         Type: uint256
         Source: "10**decimals"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Identifier decimals
           Type: uint256
           Source: "decimals"
  VariableDeclaration "afterschoolContributorTokens"
     Type: uint256
     Gas costs: 0
     Source: "uint afterschoolContributorTokens = 56000000 * 10**decimals"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: uint256
       Source: "56000000 * 10**decimals"
      Literal, token: [no token] value: 56000000
         Type: int_const 56000000
         Source: "56000000"
      BinaryOperation using operator **
         Type: uint256
         Source: "10**decimals"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Identifier decimals
           Type: uint256
           Source: "decimals"
  VariableDeclaration "futurePartnerTokens"
     Type: uint256
     Gas costs: 0
     Source: "uint futurePartnerTokens =          64000000 * 10**decimals"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: uint256
       Source: "64000000 * 10**decimals"
      Literal, token: [no token] value: 64000000
         Type: int_const 64000000
         Source: "64000000"
      BinaryOperation using operator **
         Type: uint256
         Source: "10**decimals"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Identifier decimals
           Type: uint256
           Source: "decimals"
  VariableDeclaration "foundersAndTeamTokensClaimed"
     Type: bool
     Gas costs: 0
     Source: "bool foundersAndTeamTokensClaimed = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "advisorAndAmbassadorTokensClaimed"
     Type: bool
     Gas costs: 0
     Source: "bool advisorAndAmbassadorTokensClaimed = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "investorTokensClaimed"
     Type: bool
     Gas costs: 0
     Source: "bool investorTokensClaimed = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "afterschoolContributorTokensClaimed"
     Type: bool
     Gas costs: 0
     Source: "bool afterschoolContributorTokensClaimed = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "futurePartnerTokensClaimed"
     Type: bool
     Gas costs: 0
     Source: "bool futurePartnerTokensClaimed = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "nextContributorToClaim"
     Type: uint256
     Gas costs: 0
     Source: "uint nextContributorToClaim"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "hasClaimedEthWhenFail"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping(address => bool) hasClaimedEthWhenFail"
    Mapping
       Source: "mapping(address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  FunctionDefinition "" - public
     Source: "function() payable {\r\n  require(msg.value != 0);\r\n  require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\r\n  \r\n  bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\r\n  \r\n  if(crowdsaleState == state.crowdsale) {\r\n      createTokens(msg.sender);             // Process transaction and issue tokens\r\n    } else {\r\n      refundTransaction(stateChanged);              // Set state and return funds or throw\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n  require(msg.value != 0);\r\n  require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\r\n  \r\n  bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\r\n  \r\n  if(crowdsaleState == state.crowdsale) {\r\n      createTokens(msg.sender);             // Process transaction and issue tokens\r\n    } else {\r\n      refundTransaction(stateChanged);              // Set state and return funds or throw\r\n    }\r\n  }"
      ExpressionStatement
         Gas costs: 37
         Source: "require(msg.value != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "msg.value != 0"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 326
         Source: "require(crowdsaleState != state.crowdsaleEnded)"
        FunctionCall
           Type: tuple()
           Source: "require(crowdsaleState != state.crowdsaleEnded)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "crowdsaleState != state.crowdsaleEnded"
            Identifier crowdsaleState
               Type: enum CrowdsaleToken.state
               Source: "crowdsaleState"
            MemberAccess to member crowdsaleEnded
               Type: enum CrowdsaleToken.state
               Source: "state.crowdsaleEnded"
              Identifier state
                 Type: type(enum CrowdsaleToken.state)
                 Source: "state"
      VariableDeclarationStatement
         Gas costs: 12
         Source: "bool stateChanged = checkCrowdsaleState()"
        VariableDeclaration "stateChanged"
           Type: bool
           Source: "bool stateChanged"
          ElementaryTypeName bool
             Source: "bool"
        FunctionCall
           Type: bool
           Source: "checkCrowdsaleState()"
          Identifier checkCrowdsaleState
             Type: function () returns (bool)
             Source: "checkCrowdsaleState"
      IfStatement
         Source: "if(crowdsaleState == state.crowdsale) {\r\n      createTokens(msg.sender);             // Process transaction and issue tokens\r\n    } else {\r\n      refundTransaction(stateChanged);              // Set state and return funds or throw\r\n    }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 297
           Source: "crowdsaleState == state.crowdsale"
          Identifier crowdsaleState
             Type: enum CrowdsaleToken.state
             Source: "crowdsaleState"
          MemberAccess to member crowdsale
             Type: enum CrowdsaleToken.state
             Source: "state.crowdsale"
            Identifier state
               Type: type(enum CrowdsaleToken.state)
               Source: "state"
        Block
           Source: "{\r\n      createTokens(msg.sender);             // Process transaction and issue tokens\r\n    }"
          ExpressionStatement
             Gas costs: 17
             Source: "createTokens(msg.sender)"
            FunctionCall
               Type: tuple()
               Source: "createTokens(msg.sender)"
              Identifier createTokens
                 Type: function (address)
                 Source: "createTokens"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
        Block
           Source: "{\r\n      refundTransaction(stateChanged);              // Set state and return funds or throw\r\n    }"
          ExpressionStatement
             Gas costs: 7
             Source: "refundTransaction(stateChanged)"
            FunctionCall
               Type: tuple()
               Source: "refundTransaction(stateChanged)"
              Identifier refundTransaction
                 Type: function (bool)
                 Source: "refundTransaction"
              Identifier stateChanged
                 Type: bool
                 Source: "stateChanged"
  FunctionDefinition "checkCrowdsaleState"
     Source: "function checkCrowdsaleState() internal returns (bool) {\r\n    if (ethRaised >= maxCap && crowdsaleState != state.crowdsaleEnded) { // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number); // Raise event\r\n      return true;\r\n    }\r\n    \r\n    if(now >= END_TIME) {   \r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number); // Raise event\r\n      return true;\r\n    }\r\n\r\n    if(now >= BEGIN_TIME && now < END_TIME) {        // Check if we are in crowdsale state\r\n      if (crowdsaleState != state.crowdsale) {                                                   // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    if (ethRaised >= maxCap && crowdsaleState != state.crowdsaleEnded) { // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number); // Raise event\r\n      return true;\r\n    }\r\n    \r\n    if(now >= END_TIME) {   \r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number); // Raise event\r\n      return true;\r\n    }\r\n\r\n    if(now >= BEGIN_TIME && now < END_TIME) {        // Check if we are in crowdsale state\r\n      if (crowdsaleState != state.crowdsale) {                                                   // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }"
      IfStatement
         Source: "if (ethRaised >= maxCap && crowdsaleState != state.crowdsaleEnded) { // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number); // Raise event\r\n      return true;\r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 734
           Source: "ethRaised >= maxCap && crowdsaleState != state.crowdsaleEnded"
          BinaryOperation using operator >=
             Type: bool
             Source: "ethRaised >= maxCap"
            Identifier ethRaised
               Type: uint256
               Source: "ethRaised"
            Identifier maxCap
               Type: uint256
               Source: "maxCap"
          BinaryOperation using operator !=
             Type: bool
             Source: "crowdsaleState != state.crowdsaleEnded"
            Identifier crowdsaleState
               Type: enum CrowdsaleToken.state
               Source: "crowdsaleState"
            MemberAccess to member crowdsaleEnded
               Type: enum CrowdsaleToken.state
               Source: "state.crowdsaleEnded"
              Identifier state
                 Type: type(enum CrowdsaleToken.state)
                 Source: "state"
        Block
           Source: "{ // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number); // Raise event\r\n      return true;\r\n    }"
          ExpressionStatement
             Gas costs: 20287
             Source: "crowdsaleState = state.crowdsaleEnded"
            Assignment using operator =
               Type: enum CrowdsaleToken.state
               Source: "crowdsaleState = state.crowdsaleEnded"
              Identifier crowdsaleState
                 Type: enum CrowdsaleToken.state
                 Source: "crowdsaleState"
              MemberAccess to member crowdsaleEnded
                 Type: enum CrowdsaleToken.state
                 Source: "state.crowdsaleEnded"
                Identifier state
                   Type: type(enum CrowdsaleToken.state)
                   Source: "state"
          ExpressionStatement
             Gas costs: [???]
             Source: "CrowdsaleEnded(block.number)"
            FunctionCall
               Type: tuple()
               Source: "CrowdsaleEnded(block.number)"
              Identifier CrowdsaleEnded
                 Type: function (uint256)
                 Source: "CrowdsaleEnded"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      IfStatement
         Source: "if(now >= END_TIME) {   \r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number); // Raise event\r\n      return true;\r\n    }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 8
           Source: "now >= END_TIME"
          Identifier now
             Type: uint256
             Source: "now"
          Identifier END_TIME
             Type: uint256
             Source: "END_TIME"
        Block
           Source: "{   \r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number); // Raise event\r\n      return true;\r\n    }"
          ExpressionStatement
             Gas costs: 20287
             Source: "crowdsaleState = state.crowdsaleEnded"
            Assignment using operator =
               Type: enum CrowdsaleToken.state
               Source: "crowdsaleState = state.crowdsaleEnded"
              Identifier crowdsaleState
                 Type: enum CrowdsaleToken.state
                 Source: "crowdsaleState"
              MemberAccess to member crowdsaleEnded
                 Type: enum CrowdsaleToken.state
                 Source: "state.crowdsaleEnded"
                Identifier state
                   Type: type(enum CrowdsaleToken.state)
                   Source: "state"
          ExpressionStatement
             Gas costs: [???]
             Source: "CrowdsaleEnded(block.number)"
            FunctionCall
               Type: tuple()
               Source: "CrowdsaleEnded(block.number)"
              Identifier CrowdsaleEnded
                 Type: function (uint256)
                 Source: "CrowdsaleEnded"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      IfStatement
         Source: "if(now >= BEGIN_TIME && now < END_TIME) {        // Check if we are in crowdsale state\r\n      if (crowdsaleState != state.crowdsale) {                                                   // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }\r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 35
           Source: "now >= BEGIN_TIME && now < END_TIME"
          BinaryOperation using operator >=
             Type: bool
             Source: "now >= BEGIN_TIME"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier BEGIN_TIME
               Type: uint256
               Source: "BEGIN_TIME"
          BinaryOperation using operator <
             Type: bool
             Source: "now < END_TIME"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier END_TIME
               Type: uint256
               Source: "END_TIME"
        Block
           Source: "{        // Check if we are in crowdsale state\r\n      if (crowdsaleState != state.crowdsale) {                                                   // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }\r\n    }"
          IfStatement
             Source: "if (crowdsaleState != state.crowdsale) {                                                   // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }"
            BinaryOperation using operator !=
               Type: bool
               Gas costs: 300
               Source: "crowdsaleState != state.crowdsale"
              Identifier crowdsaleState
                 Type: enum CrowdsaleToken.state
                 Source: "crowdsaleState"
              MemberAccess to member crowdsale
                 Type: enum CrowdsaleToken.state
                 Source: "state.crowdsale"
                Identifier state
                   Type: type(enum CrowdsaleToken.state)
                   Source: "state"
            Block
               Source: "{                                                   // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }"
              ExpressionStatement
                 Gas costs: 20287
                 Source: "crowdsaleState = state.crowdsale"
                Assignment using operator =
                   Type: enum CrowdsaleToken.state
                   Source: "crowdsaleState = state.crowdsale"
                  Identifier crowdsaleState
                     Type: enum CrowdsaleToken.state
                     Source: "crowdsaleState"
                  MemberAccess to member crowdsale
                     Type: enum CrowdsaleToken.state
                     Source: "state.crowdsale"
                    Identifier state
                       Type: type(enum CrowdsaleToken.state)
                       Source: "state"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "CrowdsaleStarted(block.number)"
                FunctionCall
                   Type: tuple()
                   Source: "CrowdsaleStarted(block.number)"
                  Identifier CrowdsaleStarted
                     Type: function (uint256)
                     Source: "CrowdsaleStarted"
                  MemberAccess to member number
                     Type: uint256
                     Source: "block.number"
                    Identifier block
                       Type: block
                       Source: "block"
              Return
                 Gas costs: 19
                 Source: "return true"
                Literal, token: true value: true
                   Type: bool
                   Source: "true"
      Return
         Gas costs: 8
         Source: "return false"
        Literal, token: false value: false
           Type: bool
           Source: "false"
  FunctionDefinition "refundTransaction"
     Source: "function refundTransaction(bool _stateChanged) internal {\r\n    if (_stateChanged) {\r\n      msg.sender.transfer(msg.value);\r\n    } else {\r\n      revert();\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bool _stateChanged)"
      VariableDeclaration "_stateChanged"
         Type: bool
         Source: "bool _stateChanged"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    if (_stateChanged) {\r\n      msg.sender.transfer(msg.value);\r\n    } else {\r\n      revert();\r\n    }\r\n  }"
      IfStatement
         Source: "if (_stateChanged) {\r\n      msg.sender.transfer(msg.value);\r\n    } else {\r\n      revert();\r\n    }"
        Identifier _stateChanged
           Type: bool
           Gas costs: 3
           Source: "_stateChanged"
        Block
           Source: "{\r\n      msg.sender.transfer(msg.value);\r\n    }"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.transfer(msg.value)"
            FunctionCall
               Type: tuple()
               Source: "msg.sender.transfer(msg.value)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "msg.sender.transfer"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
        Block
           Source: "{\r\n      revert();\r\n    }"
          ExpressionStatement
             Gas costs: 6
             Source: "revert()"
            FunctionCall
               Type: tuple()
               Source: "revert()"
              Identifier revert
                 Type: function () pure
                 Source: "revert"
  FunctionDefinition "createTokens" - public
     Source: "function createTokens(address _contributor) payable {\r\n  \r\n    uint _amount = msg.value;\r\n  \r\n    uint contributionAmount = _amount;\r\n    uint returnAmount = 0;\r\n    \r\n    if (_amount > (maxCap - ethRaised)) {                                          // Check if max contribution is lower than _amount sent\r\n      contributionAmount = maxCap - ethRaised;                                     // Set that user contibutes his maximum alowed contribution\r\n      returnAmount = _amount - contributionAmount;                                 // Calculate how much he must get back\r\n    }\r\n\r\n    if (ethRaised + contributionAmount > minCap && minCap > ethRaised) {\r\n      MinCapReached(block.number);\r\n    }\r\n\r\n    if (ethRaised + contributionAmount == maxCap && ethRaised < maxCap) {\r\n      MaxCapReached(block.number);\r\n    }\r\n\r\n    if (contributorList[_contributor].contributionAmount == 0){\r\n        contributorIndexes[nextContributorIndex] = _contributor;\r\n        nextContributorIndex += 1;\r\n    }\r\n  \r\n    contributorList[_contributor].contributionAmount += contributionAmount;\r\n    ethRaised += contributionAmount;                                              // Add to eth raised\r\n\r\n    uint tokenAmount = calculateEthToAfterschool(contributionAmount);      // Calculate how much tokens must contributor get\r\n    if (tokenAmount > 0) {\r\n      totalSupply = totalSupply.add(tokenAmount);\r\n      balances[_contributor] = balances[_contributor].add(tokenAmount);\r\n      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\r\n    }\r\n\r\n    if (!multisig.send(msg.value)) {\r\n        revert();\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _contributor)"
      VariableDeclaration "_contributor"
         Type: address
         Source: "address _contributor"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n  \r\n    uint _amount = msg.value;\r\n  \r\n    uint contributionAmount = _amount;\r\n    uint returnAmount = 0;\r\n    \r\n    if (_amount > (maxCap - ethRaised)) {                                          // Check if max contribution is lower than _amount sent\r\n      contributionAmount = maxCap - ethRaised;                                     // Set that user contibutes his maximum alowed contribution\r\n      returnAmount = _amount - contributionAmount;                                 // Calculate how much he must get back\r\n    }\r\n\r\n    if (ethRaised + contributionAmount > minCap && minCap > ethRaised) {\r\n      MinCapReached(block.number);\r\n    }\r\n\r\n    if (ethRaised + contributionAmount == maxCap && ethRaised < maxCap) {\r\n      MaxCapReached(block.number);\r\n    }\r\n\r\n    if (contributorList[_contributor].contributionAmount == 0){\r\n        contributorIndexes[nextContributorIndex] = _contributor;\r\n        nextContributorIndex += 1;\r\n    }\r\n  \r\n    contributorList[_contributor].contributionAmount += contributionAmount;\r\n    ethRaised += contributionAmount;                                              // Add to eth raised\r\n\r\n    uint tokenAmount = calculateEthToAfterschool(contributionAmount);      // Calculate how much tokens must contributor get\r\n    if (tokenAmount > 0) {\r\n      totalSupply = totalSupply.add(tokenAmount);\r\n      balances[_contributor] = balances[_contributor].add(tokenAmount);\r\n      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\r\n    }\r\n\r\n    if (!multisig.send(msg.value)) {\r\n        revert();\r\n    }\r\n  }"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint _amount = msg.value"
        VariableDeclaration "_amount"
           Type: uint256
           Source: "uint _amount"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member value
           Type: uint256
           Source: "msg.value"
          Identifier msg
             Type: msg
             Source: "msg"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint contributionAmount = _amount"
        VariableDeclaration "contributionAmount"
           Type: uint256
           Source: "uint contributionAmount"
          ElementaryTypeName uint
             Source: "uint"
        Identifier _amount
           Type: uint256
           Source: "_amount"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint returnAmount = 0"
        VariableDeclaration "returnAmount"
           Type: uint256
           Source: "uint returnAmount"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      IfStatement
         Source: "if (_amount > (maxCap - ethRaised)) {                                          // Check if max contribution is lower than _amount sent\r\n      contributionAmount = maxCap - ethRaised;                                     // Set that user contibutes his maximum alowed contribution\r\n      returnAmount = _amount - contributionAmount;                                 // Calculate how much he must get back\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 415
           Source: "_amount > (maxCap - ethRaised)"
          Identifier _amount
             Type: uint256
             Source: "_amount"
          TupleExpression
             Type: uint256
             Source: "(maxCap - ethRaised)"
            BinaryOperation using operator -
               Type: uint256
               Source: "maxCap - ethRaised"
              Identifier maxCap
                 Type: uint256
                 Source: "maxCap"
              Identifier ethRaised
                 Type: uint256
                 Source: "ethRaised"
        Block
           Source: "{                                          // Check if max contribution is lower than _amount sent\r\n      contributionAmount = maxCap - ethRaised;                                     // Set that user contibutes his maximum alowed contribution\r\n      returnAmount = _amount - contributionAmount;                                 // Calculate how much he must get back\r\n    }"
          ExpressionStatement
             Gas costs: 414
             Source: "contributionAmount = maxCap - ethRaised"
            Assignment using operator =
               Type: uint256
               Source: "contributionAmount = maxCap - ethRaised"
              Identifier contributionAmount
                 Type: uint256
                 Source: "contributionAmount"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "maxCap - ethRaised"
                Identifier maxCap
                   Type: uint256
                   Source: "maxCap"
                Identifier ethRaised
                   Type: uint256
                   Source: "ethRaised"
          ExpressionStatement
             Gas costs: 14
             Source: "returnAmount = _amount - contributionAmount"
            Assignment using operator =
               Type: uint256
               Source: "returnAmount = _amount - contributionAmount"
              Identifier returnAmount
                 Type: uint256
                 Source: "returnAmount"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "_amount - contributionAmount"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
                Identifier contributionAmount
                   Type: uint256
                   Source: "contributionAmount"
      IfStatement
         Source: "if (ethRaised + contributionAmount > minCap && minCap > ethRaised) {\r\n      MinCapReached(block.number);\r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 846
           Source: "ethRaised + contributionAmount > minCap && minCap > ethRaised"
          BinaryOperation using operator >
             Type: bool
             Source: "ethRaised + contributionAmount > minCap"
            BinaryOperation using operator +
               Type: uint256
               Source: "ethRaised + contributionAmount"
              Identifier ethRaised
                 Type: uint256
                 Source: "ethRaised"
              Identifier contributionAmount
                 Type: uint256
                 Source: "contributionAmount"
            Identifier minCap
               Type: uint256
               Source: "minCap"
          BinaryOperation using operator >
             Type: bool
             Source: "minCap > ethRaised"
            Identifier minCap
               Type: uint256
               Source: "minCap"
            Identifier ethRaised
               Type: uint256
               Source: "ethRaised"
        Block
           Source: "{\r\n      MinCapReached(block.number);\r\n    }"
          ExpressionStatement
             Gas costs: [???]
             Source: "MinCapReached(block.number)"
            FunctionCall
               Type: tuple()
               Source: "MinCapReached(block.number)"
              Identifier MinCapReached
                 Type: function (uint256)
                 Source: "MinCapReached"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
      IfStatement
         Source: "if (ethRaised + contributionAmount == maxCap && ethRaised < maxCap) {\r\n      MaxCapReached(block.number);\r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 846
           Source: "ethRaised + contributionAmount == maxCap && ethRaised < maxCap"
          BinaryOperation using operator ==
             Type: bool
             Source: "ethRaised + contributionAmount == maxCap"
            BinaryOperation using operator +
               Type: uint256
               Source: "ethRaised + contributionAmount"
              Identifier ethRaised
                 Type: uint256
                 Source: "ethRaised"
              Identifier contributionAmount
                 Type: uint256
                 Source: "contributionAmount"
            Identifier maxCap
               Type: uint256
               Source: "maxCap"
          BinaryOperation using operator <
             Type: bool
             Source: "ethRaised < maxCap"
            Identifier ethRaised
               Type: uint256
               Source: "ethRaised"
            Identifier maxCap
               Type: uint256
               Source: "maxCap"
        Block
           Source: "{\r\n      MaxCapReached(block.number);\r\n    }"
          ExpressionStatement
             Gas costs: [???]
             Source: "MaxCapReached(block.number)"
            FunctionCall
               Type: tuple()
               Source: "MaxCapReached(block.number)"
              Identifier MaxCapReached
                 Type: function (uint256)
                 Source: "MaxCapReached"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
      IfStatement
         Source: "if (contributorList[_contributor].contributionAmount == 0){\r\n        contributorIndexes[nextContributorIndex] = _contributor;\r\n        nextContributorIndex += 1;\r\n    }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 311
           Source: "contributorList[_contributor].contributionAmount == 0"
          MemberAccess to member contributionAmount
             Type: uint256
             Source: "contributorList[_contributor].contributionAmount"
            IndexAccess
               Type: struct CrowdsaleToken.ContributorData storage ref
               Source: "contributorList[_contributor]"
              Identifier contributorList
                 Type: mapping(address => struct CrowdsaleToken.ContributorData storage ref)
                 Source: "contributorList"
              Identifier _contributor
                 Type: address
                 Source: "_contributor"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n        contributorIndexes[nextContributorIndex] = _contributor;\r\n        nextContributorIndex += 1;\r\n    }"
          ExpressionStatement
             Gas costs: 20551
             Source: "contributorIndexes[nextContributorIndex] = _contributor"
            Assignment using operator =
               Type: address
               Source: "contributorIndexes[nextContributorIndex] = _contributor"
              IndexAccess
                 Type: address
                 Source: "contributorIndexes[nextContributorIndex]"
                Identifier contributorIndexes
                   Type: mapping(uint256 => address)
                   Source: "contributorIndexes"
                Identifier nextContributorIndex
                   Type: uint256
                   Source: "nextContributorIndex"
              Identifier _contributor
                 Type: address
                 Source: "_contributor"
          ExpressionStatement
             Gas costs: 20233
             Source: "nextContributorIndex += 1"
            Assignment using operator +=
               Type: uint256
               Source: "nextContributorIndex += 1"
              Identifier nextContributorIndex
                 Type: uint256
                 Source: "nextContributorIndex"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      ExpressionStatement
         Gas costs: 20335
         Source: "contributorList[_contributor].contributionAmount += contributionAmount"
        Assignment using operator +=
           Type: uint256
           Source: "contributorList[_contributor].contributionAmount += contributionAmount"
          MemberAccess to member contributionAmount
             Type: uint256
             Source: "contributorList[_contributor].contributionAmount"
            IndexAccess
               Type: struct CrowdsaleToken.ContributorData storage ref
               Source: "contributorList[_contributor]"
              Identifier contributorList
                 Type: mapping(address => struct CrowdsaleToken.ContributorData storage ref)
                 Source: "contributorList"
              Identifier _contributor
                 Type: address
                 Source: "_contributor"
          Identifier contributionAmount
             Type: uint256
             Source: "contributionAmount"
      ExpressionStatement
         Gas costs: 20233
         Source: "ethRaised += contributionAmount"
        Assignment using operator +=
           Type: uint256
           Source: "ethRaised += contributionAmount"
          Identifier ethRaised
             Type: uint256
             Source: "ethRaised"
          Identifier contributionAmount
             Type: uint256
             Source: "contributionAmount"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint tokenAmount = calculateEthToAfterschool(contributionAmount)"
        VariableDeclaration "tokenAmount"
           Type: uint256
           Source: "uint tokenAmount"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "calculateEthToAfterschool(contributionAmount)"
          Identifier calculateEthToAfterschool
             Type: function (uint256) view returns (uint256)
             Source: "calculateEthToAfterschool"
          Identifier contributionAmount
             Type: uint256
             Source: "contributionAmount"
      IfStatement
         Source: "if (tokenAmount > 0) {\r\n      totalSupply = totalSupply.add(tokenAmount);\r\n      balances[_contributor] = balances[_contributor].add(tokenAmount);\r\n      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "tokenAmount > 0"
          Identifier tokenAmount
             Type: uint256
             Source: "tokenAmount"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n      totalSupply = totalSupply.add(tokenAmount);\r\n      balances[_contributor] = balances[_contributor].add(tokenAmount);\r\n      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\r\n    }"
          ExpressionStatement
             Gas costs: 20247
             Source: "totalSupply = totalSupply.add(tokenAmount)"
            Assignment using operator =
               Type: uint256
               Source: "totalSupply = totalSupply.add(tokenAmount)"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
              FunctionCall
                 Type: uint256
                 Source: "totalSupply.add(tokenAmount)"
                MemberAccess to member add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "totalSupply.add"
                  Identifier totalSupply
                     Type: uint256
                     Source: "totalSupply"
                Identifier tokenAmount
                   Type: uint256
                   Source: "tokenAmount"
          ExpressionStatement
             Gas costs: 20439
             Source: "balances[_contributor] = balances[_contributor].add(tokenAmount)"
            Assignment using operator =
               Type: uint256
               Source: "balances[_contributor] = balances[_contributor].add(tokenAmount)"
              IndexAccess
                 Type: uint256
                 Source: "balances[_contributor]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _contributor
                   Type: address
                   Source: "_contributor"
              FunctionCall
                 Type: uint256
                 Source: "balances[_contributor].add(tokenAmount)"
                MemberAccess to member add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "balances[_contributor].add"
                  IndexAccess
                     Type: uint256
                     Source: "balances[_contributor]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    Identifier _contributor
                       Type: address
                       Source: "_contributor"
                Identifier tokenAmount
                   Type: uint256
                   Source: "tokenAmount"
          ExpressionStatement
             Gas costs: 20329
             Source: "contributorList[_contributor].tokensIssued += tokenAmount"
            Assignment using operator +=
               Type: uint256
               Source: "contributorList[_contributor].tokensIssued += tokenAmount"
              MemberAccess to member tokensIssued
                 Type: uint256
                 Source: "contributorList[_contributor].tokensIssued"
                IndexAccess
                   Type: struct CrowdsaleToken.ContributorData storage ref
                   Source: "contributorList[_contributor]"
                  Identifier contributorList
                     Type: mapping(address => struct CrowdsaleToken.ContributorData storage ref)
                     Source: "contributorList"
                  Identifier _contributor
                     Type: address
                     Source: "_contributor"
              Identifier tokenAmount
                 Type: uint256
                 Source: "tokenAmount"
      IfStatement
         Source: "if (!multisig.send(msg.value)) {\r\n        revert();\r\n    }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!multisig.send(msg.value)"
          FunctionCall
             Type: bool
             Source: "multisig.send(msg.value)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "multisig.send"
              Identifier multisig
                 Type: address
                 Source: "multisig"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
        Block
           Source: "{\r\n        revert();\r\n    }"
          ExpressionStatement
             Gas costs: 6
             Source: "revert()"
            FunctionCall
               Type: tuple()
               Source: "revert()"
              Identifier revert
                 Type: function () pure
                 Source: "revert"
  FunctionDefinition "calculateEthToAfterschool" - public - const
     Source: "function calculateEthToAfterschool(uint _eth) constant returns(uint) {\r\n  \r\n    uint tokens = _eth.mul(getPrice());\r\n    uint percentage = 0;\r\n    \r\n    if (ethRaised > 0)\r\n    {\r\n        percentage = ethRaised * 100 / maxCap;\r\n    }\r\n    \r\n    return tokens + getStageBonus(percentage, tokens) + getAmountBonus(_eth, tokens);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint _eth)"
      VariableDeclaration "_eth"
         Type: uint256
         Source: "uint _eth"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n  \r\n    uint tokens = _eth.mul(getPrice());\r\n    uint percentage = 0;\r\n    \r\n    if (ethRaised > 0)\r\n    {\r\n        percentage = ethRaised * 100 / maxCap;\r\n    }\r\n    \r\n    return tokens + getStageBonus(percentage, tokens) + getAmountBonus(_eth, tokens);\r\n  }"
      VariableDeclarationStatement
         Gas costs: 56
         Source: "uint tokens = _eth.mul(getPrice())"
        VariableDeclaration "tokens"
           Type: uint256
           Source: "uint tokens"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "_eth.mul(getPrice())"
          MemberAccess to member mul
             Type: function (uint256,uint256) view returns (uint256)
             Source: "_eth.mul"
            Identifier _eth
               Type: uint256
               Source: "_eth"
          FunctionCall
             Type: uint256
             Source: "getPrice()"
            Identifier getPrice
               Type: function () view returns (uint256)
               Source: "getPrice"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint percentage = 0"
        VariableDeclaration "percentage"
           Type: uint256
           Source: "uint percentage"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      IfStatement
         Source: "if (ethRaised > 0)\r\n    {\r\n        percentage = ethRaised * 100 / maxCap;\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "ethRaised > 0"
          Identifier ethRaised
             Type: uint256
             Source: "ethRaised"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n        percentage = ethRaised * 100 / maxCap;\r\n    }"
          ExpressionStatement
             Gas costs: 447
             Source: "percentage = ethRaised * 100 / maxCap"
            Assignment using operator =
               Type: uint256
               Source: "percentage = ethRaised * 100 / maxCap"
              Identifier percentage
                 Type: uint256
                 Source: "percentage"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "ethRaised * 100 / maxCap"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "ethRaised * 100"
                  Identifier ethRaised
                     Type: uint256
                     Source: "ethRaised"
                  Literal, token: [no token] value: 100
                     Type: int_const 100
                     Source: "100"
                Identifier maxCap
                   Type: uint256
                   Source: "maxCap"
      Return
         Gas costs: 56
         Source: "return tokens + getStageBonus(percentage, tokens) + getAmountBonus(_eth, tokens)"
        BinaryOperation using operator +
           Type: uint256
           Source: "tokens + getStageBonus(percentage, tokens) + getAmountBonus(_eth, tokens)"
          BinaryOperation using operator +
             Type: uint256
             Source: "tokens + getStageBonus(percentage, tokens)"
            Identifier tokens
               Type: uint256
               Source: "tokens"
            FunctionCall
               Type: uint256
               Source: "getStageBonus(percentage, tokens)"
              Identifier getStageBonus
                 Type: function (uint256,uint256) view returns (uint256)
                 Source: "getStageBonus"
              Identifier percentage
                 Type: uint256
                 Source: "percentage"
              Identifier tokens
                 Type: uint256
                 Source: "tokens"
          FunctionCall
             Type: uint256
             Source: "getAmountBonus(_eth, tokens)"
            Identifier getAmountBonus
               Type: function (uint256,uint256) view returns (uint256)
               Source: "getAmountBonus"
            Identifier _eth
               Type: uint256
               Source: "_eth"
            Identifier tokens
               Type: uint256
               Source: "tokens"
  FunctionDefinition "getStageBonus" - public - const
     Source: "function getStageBonus(uint percentage, uint tokens) constant returns (uint) {\r\n    uint stageBonus = 0;\r\n      \r\n    if (percentage <= 10) stageBonus = tokens * 60 / 100; // Stage 1\r\n    else if (percentage <= 50) stageBonus = tokens * 30 / 100;\r\n    else if (percentage <= 70) stageBonus = tokens * 20 / 100;\r\n    else if (percentage <= 90) stageBonus = tokens * 15 / 100;\r\n    else if (percentage <= 100) stageBonus = tokens * 10 / 100;\r\n\r\n    return stageBonus;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint percentage, uint tokens)"
      VariableDeclaration "percentage"
         Type: uint256
         Source: "uint percentage"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "tokens"
         Type: uint256
         Source: "uint tokens"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    uint stageBonus = 0;\r\n      \r\n    if (percentage <= 10) stageBonus = tokens * 60 / 100; // Stage 1\r\n    else if (percentage <= 50) stageBonus = tokens * 30 / 100;\r\n    else if (percentage <= 70) stageBonus = tokens * 20 / 100;\r\n    else if (percentage <= 90) stageBonus = tokens * 15 / 100;\r\n    else if (percentage <= 100) stageBonus = tokens * 10 / 100;\r\n\r\n    return stageBonus;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint stageBonus = 0"
        VariableDeclaration "stageBonus"
           Type: uint256
           Source: "uint stageBonus"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      IfStatement
         Source: "if (percentage <= 10) stageBonus = tokens * 60 / 100; // Stage 1\r\n    else if (percentage <= 50) stageBonus = tokens * 30 / 100;\r\n    else if (percentage <= 70) stageBonus = tokens * 20 / 100;\r\n    else if (percentage <= 90) stageBonus = tokens * 15 / 100;\r\n    else if (percentage <= 100) stageBonus = tokens * 10 / 100"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 12
           Source: "percentage <= 10"
          Identifier percentage
             Type: uint256
             Source: "percentage"
          Literal, token: [no token] value: 10
             Type: int_const 10
             Source: "10"
        ExpressionStatement
           Gas costs: 47
           Source: "stageBonus = tokens * 60 / 100"
          Assignment using operator =
             Type: uint256
             Source: "stageBonus = tokens * 60 / 100"
            Identifier stageBonus
               Type: uint256
               Source: "stageBonus"
            BinaryOperation using operator /
               Type: uint256
               Source: "tokens * 60 / 100"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "tokens * 60"
                Identifier tokens
                   Type: uint256
                   Source: "tokens"
                Literal, token: [no token] value: 60
                   Type: int_const 60
                   Source: "60"
              Literal, token: [no token] value: 100
                 Type: int_const 100
                 Source: "100"
        IfStatement
           Source: "if (percentage <= 50) stageBonus = tokens * 30 / 100;\r\n    else if (percentage <= 70) stageBonus = tokens * 20 / 100;\r\n    else if (percentage <= 90) stageBonus = tokens * 15 / 100;\r\n    else if (percentage <= 100) stageBonus = tokens * 10 / 100"
          BinaryOperation using operator <=
             Type: bool
             Gas costs: 12
             Source: "percentage <= 50"
            Identifier percentage
               Type: uint256
               Source: "percentage"
            Literal, token: [no token] value: 50
               Type: int_const 50
               Source: "50"
          ExpressionStatement
             Gas costs: 47
             Source: "stageBonus = tokens * 30 / 100"
            Assignment using operator =
               Type: uint256
               Source: "stageBonus = tokens * 30 / 100"
              Identifier stageBonus
                 Type: uint256
                 Source: "stageBonus"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "tokens * 30 / 100"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "tokens * 30"
                  Identifier tokens
                     Type: uint256
                     Source: "tokens"
                  Literal, token: [no token] value: 30
                     Type: int_const 30
                     Source: "30"
                Literal, token: [no token] value: 100
                   Type: int_const 100
                   Source: "100"
          IfStatement
             Source: "if (percentage <= 70) stageBonus = tokens * 20 / 100;\r\n    else if (percentage <= 90) stageBonus = tokens * 15 / 100;\r\n    else if (percentage <= 100) stageBonus = tokens * 10 / 100"
            BinaryOperation using operator <=
               Type: bool
               Gas costs: 12
               Source: "percentage <= 70"
              Identifier percentage
                 Type: uint256
                 Source: "percentage"
              Literal, token: [no token] value: 70
                 Type: int_const 70
                 Source: "70"
            ExpressionStatement
               Gas costs: 47
               Source: "stageBonus = tokens * 20 / 100"
              Assignment using operator =
                 Type: uint256
                 Source: "stageBonus = tokens * 20 / 100"
                Identifier stageBonus
                   Type: uint256
                   Source: "stageBonus"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "tokens * 20 / 100"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "tokens * 20"
                    Identifier tokens
                       Type: uint256
                       Source: "tokens"
                    Literal, token: [no token] value: 20
                       Type: int_const 20
                       Source: "20"
                  Literal, token: [no token] value: 100
                     Type: int_const 100
                     Source: "100"
            IfStatement
               Source: "if (percentage <= 90) stageBonus = tokens * 15 / 100;\r\n    else if (percentage <= 100) stageBonus = tokens * 10 / 100"
              BinaryOperation using operator <=
                 Type: bool
                 Gas costs: 12
                 Source: "percentage <= 90"
                Identifier percentage
                   Type: uint256
                   Source: "percentage"
                Literal, token: [no token] value: 90
                   Type: int_const 90
                   Source: "90"
              ExpressionStatement
                 Gas costs: 47
                 Source: "stageBonus = tokens * 15 / 100"
                Assignment using operator =
                   Type: uint256
                   Source: "stageBonus = tokens * 15 / 100"
                  Identifier stageBonus
                     Type: uint256
                     Source: "stageBonus"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "tokens * 15 / 100"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "tokens * 15"
                      Identifier tokens
                         Type: uint256
                         Source: "tokens"
                      Literal, token: [no token] value: 15
                         Type: int_const 15
                         Source: "15"
                    Literal, token: [no token] value: 100
                       Type: int_const 100
                       Source: "100"
              IfStatement
                 Source: "if (percentage <= 100) stageBonus = tokens * 10 / 100"
                BinaryOperation using operator <=
                   Type: bool
                   Gas costs: 12
                   Source: "percentage <= 100"
                  Identifier percentage
                     Type: uint256
                     Source: "percentage"
                  Literal, token: [no token] value: 100
                     Type: int_const 100
                     Source: "100"
                ExpressionStatement
                   Gas costs: 47
                   Source: "stageBonus = tokens * 10 / 100"
                  Assignment using operator =
                     Type: uint256
                     Source: "stageBonus = tokens * 10 / 100"
                    Identifier stageBonus
                       Type: uint256
                       Source: "stageBonus"
                    BinaryOperation using operator /
                       Type: uint256
                       Source: "tokens * 10 / 100"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "tokens * 10"
                        Identifier tokens
                           Type: uint256
                           Source: "tokens"
                        Literal, token: [no token] value: 10
                           Type: int_const 10
                           Source: "10"
                      Literal, token: [no token] value: 100
                         Type: int_const 100
                         Source: "100"
      Return
         Gas costs: 8
         Source: "return stageBonus"
        Identifier stageBonus
           Type: uint256
           Source: "stageBonus"
  FunctionDefinition "getAmountBonus" - public - const
     Source: "function getAmountBonus(uint _eth, uint tokens) constant returns (uint) {\r\n    uint amountBonus = 0;  \r\n      \r\n    if (_eth >= 3000 ether) amountBonus = tokens * 13 / 100;\r\n    else if (_eth >= 2000 ether) amountBonus = tokens * 12 / 100;\r\n    else if (_eth >= 1500 ether) amountBonus = tokens * 11 / 100;\r\n    else if (_eth >= 1000 ether) amountBonus = tokens * 10 / 100;\r\n    else if (_eth >= 750 ether) amountBonus = tokens * 9 / 100;\r\n    else if (_eth >= 500 ether) amountBonus = tokens * 8 / 100;\r\n    else if (_eth >= 300 ether) amountBonus = tokens * 75 / 1000;\r\n    else if (_eth >= 200 ether) amountBonus = tokens * 7 / 100;\r\n    else if (_eth >= 150 ether) amountBonus = tokens * 6 / 100;\r\n    else if (_eth >= 100 ether) amountBonus = tokens * 55 / 1000;\r\n    else if (_eth >= 75 ether) amountBonus = tokens * 5 / 100;\r\n    else if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000;\r\n    \r\n    return amountBonus;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint _eth, uint tokens)"
      VariableDeclaration "_eth"
         Type: uint256
         Source: "uint _eth"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "tokens"
         Type: uint256
         Source: "uint tokens"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    uint amountBonus = 0;  \r\n      \r\n    if (_eth >= 3000 ether) amountBonus = tokens * 13 / 100;\r\n    else if (_eth >= 2000 ether) amountBonus = tokens * 12 / 100;\r\n    else if (_eth >= 1500 ether) amountBonus = tokens * 11 / 100;\r\n    else if (_eth >= 1000 ether) amountBonus = tokens * 10 / 100;\r\n    else if (_eth >= 750 ether) amountBonus = tokens * 9 / 100;\r\n    else if (_eth >= 500 ether) amountBonus = tokens * 8 / 100;\r\n    else if (_eth >= 300 ether) amountBonus = tokens * 75 / 1000;\r\n    else if (_eth >= 200 ether) amountBonus = tokens * 7 / 100;\r\n    else if (_eth >= 150 ether) amountBonus = tokens * 6 / 100;\r\n    else if (_eth >= 100 ether) amountBonus = tokens * 55 / 1000;\r\n    else if (_eth >= 75 ether) amountBonus = tokens * 5 / 100;\r\n    else if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000;\r\n    \r\n    return amountBonus;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint amountBonus = 0"
        VariableDeclaration "amountBonus"
           Type: uint256
           Source: "uint amountBonus"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      IfStatement
         Source: "if (_eth >= 3000 ether) amountBonus = tokens * 13 / 100;\r\n    else if (_eth >= 2000 ether) amountBonus = tokens * 12 / 100;\r\n    else if (_eth >= 1500 ether) amountBonus = tokens * 11 / 100;\r\n    else if (_eth >= 1000 ether) amountBonus = tokens * 10 / 100;\r\n    else if (_eth >= 750 ether) amountBonus = tokens * 9 / 100;\r\n    else if (_eth >= 500 ether) amountBonus = tokens * 8 / 100;\r\n    else if (_eth >= 300 ether) amountBonus = tokens * 75 / 1000;\r\n    else if (_eth >= 200 ether) amountBonus = tokens * 7 / 100;\r\n    else if (_eth >= 150 ether) amountBonus = tokens * 6 / 100;\r\n    else if (_eth >= 100 ether) amountBonus = tokens * 55 / 1000;\r\n    else if (_eth >= 75 ether) amountBonus = tokens * 5 / 100;\r\n    else if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 12
           Source: "_eth >= 3000 ether"
          Identifier _eth
             Type: uint256
             Source: "_eth"
          Literal, token: [no token] value: 3000
             Type: int_const 3000000000000000000000
             Source: "3000 ether"
        ExpressionStatement
           Gas costs: 47
           Source: "amountBonus = tokens * 13 / 100"
          Assignment using operator =
             Type: uint256
             Source: "amountBonus = tokens * 13 / 100"
            Identifier amountBonus
               Type: uint256
               Source: "amountBonus"
            BinaryOperation using operator /
               Type: uint256
               Source: "tokens * 13 / 100"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "tokens * 13"
                Identifier tokens
                   Type: uint256
                   Source: "tokens"
                Literal, token: [no token] value: 13
                   Type: int_const 13
                   Source: "13"
              Literal, token: [no token] value: 100
                 Type: int_const 100
                 Source: "100"
        IfStatement
           Source: "if (_eth >= 2000 ether) amountBonus = tokens * 12 / 100;\r\n    else if (_eth >= 1500 ether) amountBonus = tokens * 11 / 100;\r\n    else if (_eth >= 1000 ether) amountBonus = tokens * 10 / 100;\r\n    else if (_eth >= 750 ether) amountBonus = tokens * 9 / 100;\r\n    else if (_eth >= 500 ether) amountBonus = tokens * 8 / 100;\r\n    else if (_eth >= 300 ether) amountBonus = tokens * 75 / 1000;\r\n    else if (_eth >= 200 ether) amountBonus = tokens * 7 / 100;\r\n    else if (_eth >= 150 ether) amountBonus = tokens * 6 / 100;\r\n    else if (_eth >= 100 ether) amountBonus = tokens * 55 / 1000;\r\n    else if (_eth >= 75 ether) amountBonus = tokens * 5 / 100;\r\n    else if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
          BinaryOperation using operator >=
             Type: bool
             Gas costs: 12
             Source: "_eth >= 2000 ether"
            Identifier _eth
               Type: uint256
               Source: "_eth"
            Literal, token: [no token] value: 2000
               Type: int_const 2000000000000000000000
               Source: "2000 ether"
          ExpressionStatement
             Gas costs: 47
             Source: "amountBonus = tokens * 12 / 100"
            Assignment using operator =
               Type: uint256
               Source: "amountBonus = tokens * 12 / 100"
              Identifier amountBonus
                 Type: uint256
                 Source: "amountBonus"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "tokens * 12 / 100"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "tokens * 12"
                  Identifier tokens
                     Type: uint256
                     Source: "tokens"
                  Literal, token: [no token] value: 12
                     Type: int_const 12
                     Source: "12"
                Literal, token: [no token] value: 100
                   Type: int_const 100
                   Source: "100"
          IfStatement
             Source: "if (_eth >= 1500 ether) amountBonus = tokens * 11 / 100;\r\n    else if (_eth >= 1000 ether) amountBonus = tokens * 10 / 100;\r\n    else if (_eth >= 750 ether) amountBonus = tokens * 9 / 100;\r\n    else if (_eth >= 500 ether) amountBonus = tokens * 8 / 100;\r\n    else if (_eth >= 300 ether) amountBonus = tokens * 75 / 1000;\r\n    else if (_eth >= 200 ether) amountBonus = tokens * 7 / 100;\r\n    else if (_eth >= 150 ether) amountBonus = tokens * 6 / 100;\r\n    else if (_eth >= 100 ether) amountBonus = tokens * 55 / 1000;\r\n    else if (_eth >= 75 ether) amountBonus = tokens * 5 / 100;\r\n    else if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
            BinaryOperation using operator >=
               Type: bool
               Gas costs: 12
               Source: "_eth >= 1500 ether"
              Identifier _eth
                 Type: uint256
                 Source: "_eth"
              Literal, token: [no token] value: 1500
                 Type: int_const 1500000000000000000000
                 Source: "1500 ether"
            ExpressionStatement
               Gas costs: 47
               Source: "amountBonus = tokens * 11 / 100"
              Assignment using operator =
                 Type: uint256
                 Source: "amountBonus = tokens * 11 / 100"
                Identifier amountBonus
                   Type: uint256
                   Source: "amountBonus"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "tokens * 11 / 100"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "tokens * 11"
                    Identifier tokens
                       Type: uint256
                       Source: "tokens"
                    Literal, token: [no token] value: 11
                       Type: int_const 11
                       Source: "11"
                  Literal, token: [no token] value: 100
                     Type: int_const 100
                     Source: "100"
            IfStatement
               Source: "if (_eth >= 1000 ether) amountBonus = tokens * 10 / 100;\r\n    else if (_eth >= 750 ether) amountBonus = tokens * 9 / 100;\r\n    else if (_eth >= 500 ether) amountBonus = tokens * 8 / 100;\r\n    else if (_eth >= 300 ether) amountBonus = tokens * 75 / 1000;\r\n    else if (_eth >= 200 ether) amountBonus = tokens * 7 / 100;\r\n    else if (_eth >= 150 ether) amountBonus = tokens * 6 / 100;\r\n    else if (_eth >= 100 ether) amountBonus = tokens * 55 / 1000;\r\n    else if (_eth >= 75 ether) amountBonus = tokens * 5 / 100;\r\n    else if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
              BinaryOperation using operator >=
                 Type: bool
                 Gas costs: 12
                 Source: "_eth >= 1000 ether"
                Identifier _eth
                   Type: uint256
                   Source: "_eth"
                Literal, token: [no token] value: 1000
                   Type: int_const 1000000000000000000000
                   Source: "1000 ether"
              ExpressionStatement
                 Gas costs: 47
                 Source: "amountBonus = tokens * 10 / 100"
                Assignment using operator =
                   Type: uint256
                   Source: "amountBonus = tokens * 10 / 100"
                  Identifier amountBonus
                     Type: uint256
                     Source: "amountBonus"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "tokens * 10 / 100"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "tokens * 10"
                      Identifier tokens
                         Type: uint256
                         Source: "tokens"
                      Literal, token: [no token] value: 10
                         Type: int_const 10
                         Source: "10"
                    Literal, token: [no token] value: 100
                       Type: int_const 100
                       Source: "100"
              IfStatement
                 Source: "if (_eth >= 750 ether) amountBonus = tokens * 9 / 100;\r\n    else if (_eth >= 500 ether) amountBonus = tokens * 8 / 100;\r\n    else if (_eth >= 300 ether) amountBonus = tokens * 75 / 1000;\r\n    else if (_eth >= 200 ether) amountBonus = tokens * 7 / 100;\r\n    else if (_eth >= 150 ether) amountBonus = tokens * 6 / 100;\r\n    else if (_eth >= 100 ether) amountBonus = tokens * 55 / 1000;\r\n    else if (_eth >= 75 ether) amountBonus = tokens * 5 / 100;\r\n    else if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                BinaryOperation using operator >=
                   Type: bool
                   Gas costs: 12
                   Source: "_eth >= 750 ether"
                  Identifier _eth
                     Type: uint256
                     Source: "_eth"
                  Literal, token: [no token] value: 750
                     Type: int_const 750000000000000000000
                     Source: "750 ether"
                ExpressionStatement
                   Gas costs: 47
                   Source: "amountBonus = tokens * 9 / 100"
                  Assignment using operator =
                     Type: uint256
                     Source: "amountBonus = tokens * 9 / 100"
                    Identifier amountBonus
                       Type: uint256
                       Source: "amountBonus"
                    BinaryOperation using operator /
                       Type: uint256
                       Source: "tokens * 9 / 100"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "tokens * 9"
                        Identifier tokens
                           Type: uint256
                           Source: "tokens"
                        Literal, token: [no token] value: 9
                           Type: int_const 9
                           Source: "9"
                      Literal, token: [no token] value: 100
                         Type: int_const 100
                         Source: "100"
                IfStatement
                   Source: "if (_eth >= 500 ether) amountBonus = tokens * 8 / 100;\r\n    else if (_eth >= 300 ether) amountBonus = tokens * 75 / 1000;\r\n    else if (_eth >= 200 ether) amountBonus = tokens * 7 / 100;\r\n    else if (_eth >= 150 ether) amountBonus = tokens * 6 / 100;\r\n    else if (_eth >= 100 ether) amountBonus = tokens * 55 / 1000;\r\n    else if (_eth >= 75 ether) amountBonus = tokens * 5 / 100;\r\n    else if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                  BinaryOperation using operator >=
                     Type: bool
                     Gas costs: 12
                     Source: "_eth >= 500 ether"
                    Identifier _eth
                       Type: uint256
                       Source: "_eth"
                    Literal, token: [no token] value: 500
                       Type: int_const 500000000000000000000
                       Source: "500 ether"
                  ExpressionStatement
                     Gas costs: 47
                     Source: "amountBonus = tokens * 8 / 100"
                    Assignment using operator =
                       Type: uint256
                       Source: "amountBonus = tokens * 8 / 100"
                      Identifier amountBonus
                         Type: uint256
                         Source: "amountBonus"
                      BinaryOperation using operator /
                         Type: uint256
                         Source: "tokens * 8 / 100"
                        BinaryOperation using operator *
                           Type: uint256
                           Source: "tokens * 8"
                          Identifier tokens
                             Type: uint256
                             Source: "tokens"
                          Literal, token: [no token] value: 8
                             Type: int_const 8
                             Source: "8"
                        Literal, token: [no token] value: 100
                           Type: int_const 100
                           Source: "100"
                  IfStatement
                     Source: "if (_eth >= 300 ether) amountBonus = tokens * 75 / 1000;\r\n    else if (_eth >= 200 ether) amountBonus = tokens * 7 / 100;\r\n    else if (_eth >= 150 ether) amountBonus = tokens * 6 / 100;\r\n    else if (_eth >= 100 ether) amountBonus = tokens * 55 / 1000;\r\n    else if (_eth >= 75 ether) amountBonus = tokens * 5 / 100;\r\n    else if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                    BinaryOperation using operator >=
                       Type: bool
                       Gas costs: 12
                       Source: "_eth >= 300 ether"
                      Identifier _eth
                         Type: uint256
                         Source: "_eth"
                      Literal, token: [no token] value: 300
                         Type: int_const 300000000000000000000
                         Source: "300 ether"
                    ExpressionStatement
                       Gas costs: 47
                       Source: "amountBonus = tokens * 75 / 1000"
                      Assignment using operator =
                         Type: uint256
                         Source: "amountBonus = tokens * 75 / 1000"
                        Identifier amountBonus
                           Type: uint256
                           Source: "amountBonus"
                        BinaryOperation using operator /
                           Type: uint256
                           Source: "tokens * 75 / 1000"
                          BinaryOperation using operator *
                             Type: uint256
                             Source: "tokens * 75"
                            Identifier tokens
                               Type: uint256
                               Source: "tokens"
                            Literal, token: [no token] value: 75
                               Type: int_const 75
                               Source: "75"
                          Literal, token: [no token] value: 1000
                             Type: int_const 1000
                             Source: "1000"
                    IfStatement
                       Source: "if (_eth >= 200 ether) amountBonus = tokens * 7 / 100;\r\n    else if (_eth >= 150 ether) amountBonus = tokens * 6 / 100;\r\n    else if (_eth >= 100 ether) amountBonus = tokens * 55 / 1000;\r\n    else if (_eth >= 75 ether) amountBonus = tokens * 5 / 100;\r\n    else if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                      BinaryOperation using operator >=
                         Type: bool
                         Gas costs: 12
                         Source: "_eth >= 200 ether"
                        Identifier _eth
                           Type: uint256
                           Source: "_eth"
                        Literal, token: [no token] value: 200
                           Type: int_const 200000000000000000000
                           Source: "200 ether"
                      ExpressionStatement
                         Gas costs: 47
                         Source: "amountBonus = tokens * 7 / 100"
                        Assignment using operator =
                           Type: uint256
                           Source: "amountBonus = tokens * 7 / 100"
                          Identifier amountBonus
                             Type: uint256
                             Source: "amountBonus"
                          BinaryOperation using operator /
                             Type: uint256
                             Source: "tokens * 7 / 100"
                            BinaryOperation using operator *
                               Type: uint256
                               Source: "tokens * 7"
                              Identifier tokens
                                 Type: uint256
                                 Source: "tokens"
                              Literal, token: [no token] value: 7
                                 Type: int_const 7
                                 Source: "7"
                            Literal, token: [no token] value: 100
                               Type: int_const 100
                               Source: "100"
                      IfStatement
                         Source: "if (_eth >= 150 ether) amountBonus = tokens * 6 / 100;\r\n    else if (_eth >= 100 ether) amountBonus = tokens * 55 / 1000;\r\n    else if (_eth >= 75 ether) amountBonus = tokens * 5 / 100;\r\n    else if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                        BinaryOperation using operator >=
                           Type: bool
                           Gas costs: 12
                           Source: "_eth >= 150 ether"
                          Identifier _eth
                             Type: uint256
                             Source: "_eth"
                          Literal, token: [no token] value: 150
                             Type: int_const 150000000000000000000
                             Source: "150 ether"
                        ExpressionStatement
                           Gas costs: 47
                           Source: "amountBonus = tokens * 6 / 100"
                          Assignment using operator =
                             Type: uint256
                             Source: "amountBonus = tokens * 6 / 100"
                            Identifier amountBonus
                               Type: uint256
                               Source: "amountBonus"
                            BinaryOperation using operator /
                               Type: uint256
                               Source: "tokens * 6 / 100"
                              BinaryOperation using operator *
                                 Type: uint256
                                 Source: "tokens * 6"
                                Identifier tokens
                                   Type: uint256
                                   Source: "tokens"
                                Literal, token: [no token] value: 6
                                   Type: int_const 6
                                   Source: "6"
                              Literal, token: [no token] value: 100
                                 Type: int_const 100
                                 Source: "100"
                        IfStatement
                           Source: "if (_eth >= 100 ether) amountBonus = tokens * 55 / 1000;\r\n    else if (_eth >= 75 ether) amountBonus = tokens * 5 / 100;\r\n    else if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                          BinaryOperation using operator >=
                             Type: bool
                             Gas costs: 12
                             Source: "_eth >= 100 ether"
                            Identifier _eth
                               Type: uint256
                               Source: "_eth"
                            Literal, token: [no token] value: 100
                               Type: int_const 100000000000000000000
                               Source: "100 ether"
                          ExpressionStatement
                             Gas costs: 47
                             Source: "amountBonus = tokens * 55 / 1000"
                            Assignment using operator =
                               Type: uint256
                               Source: "amountBonus = tokens * 55 / 1000"
                              Identifier amountBonus
                                 Type: uint256
                                 Source: "amountBonus"
                              BinaryOperation using operator /
                                 Type: uint256
                                 Source: "tokens * 55 / 1000"
                                BinaryOperation using operator *
                                   Type: uint256
                                   Source: "tokens * 55"
                                  Identifier tokens
                                     Type: uint256
                                     Source: "tokens"
                                  Literal, token: [no token] value: 55
                                     Type: int_const 55
                                     Source: "55"
                                Literal, token: [no token] value: 1000
                                   Type: int_const 1000
                                   Source: "1000"
                          IfStatement
                             Source: "if (_eth >= 75 ether) amountBonus = tokens * 5 / 100;\r\n    else if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                            BinaryOperation using operator >=
                               Type: bool
                               Gas costs: 12
                               Source: "_eth >= 75 ether"
                              Identifier _eth
                                 Type: uint256
                                 Source: "_eth"
                              Literal, token: [no token] value: 75
                                 Type: int_const 75000000000000000000
                                 Source: "75 ether"
                            ExpressionStatement
                               Gas costs: 47
                               Source: "amountBonus = tokens * 5 / 100"
                              Assignment using operator =
                                 Type: uint256
                                 Source: "amountBonus = tokens * 5 / 100"
                                Identifier amountBonus
                                   Type: uint256
                                   Source: "amountBonus"
                                BinaryOperation using operator /
                                   Type: uint256
                                   Source: "tokens * 5 / 100"
                                  BinaryOperation using operator *
                                     Type: uint256
                                     Source: "tokens * 5"
                                    Identifier tokens
                                       Type: uint256
                                       Source: "tokens"
                                    Literal, token: [no token] value: 5
                                       Type: int_const 5
                                       Source: "5"
                                  Literal, token: [no token] value: 100
                                     Type: int_const 100
                                     Source: "100"
                            IfStatement
                               Source: "if (_eth >= 50 ether) amountBonus = tokens * 45 / 1000;\r\n    else if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                              BinaryOperation using operator >=
                                 Type: bool
                                 Gas costs: 12
                                 Source: "_eth >= 50 ether"
                                Identifier _eth
                                   Type: uint256
                                   Source: "_eth"
                                Literal, token: [no token] value: 50
                                   Type: int_const 50000000000000000000
                                   Source: "50 ether"
                              ExpressionStatement
                                 Gas costs: 47
                                 Source: "amountBonus = tokens * 45 / 1000"
                                Assignment using operator =
                                   Type: uint256
                                   Source: "amountBonus = tokens * 45 / 1000"
                                  Identifier amountBonus
                                     Type: uint256
                                     Source: "amountBonus"
                                  BinaryOperation using operator /
                                     Type: uint256
                                     Source: "tokens * 45 / 1000"
                                    BinaryOperation using operator *
                                       Type: uint256
                                       Source: "tokens * 45"
                                      Identifier tokens
                                         Type: uint256
                                         Source: "tokens"
                                      Literal, token: [no token] value: 45
                                         Type: int_const 45
                                         Source: "45"
                                    Literal, token: [no token] value: 1000
                                       Type: int_const 1000
                                       Source: "1000"
                              IfStatement
                                 Source: "if (_eth >= 30 ether) amountBonus = tokens * 4 / 100;\r\n    else if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                                BinaryOperation using operator >=
                                   Type: bool
                                   Gas costs: 12
                                   Source: "_eth >= 30 ether"
                                  Identifier _eth
                                     Type: uint256
                                     Source: "_eth"
                                  Literal, token: [no token] value: 30
                                     Type: int_const 30000000000000000000
                                     Source: "30 ether"
                                ExpressionStatement
                                   Gas costs: 47
                                   Source: "amountBonus = tokens * 4 / 100"
                                  Assignment using operator =
                                     Type: uint256
                                     Source: "amountBonus = tokens * 4 / 100"
                                    Identifier amountBonus
                                       Type: uint256
                                       Source: "amountBonus"
                                    BinaryOperation using operator /
                                       Type: uint256
                                       Source: "tokens * 4 / 100"
                                      BinaryOperation using operator *
                                         Type: uint256
                                         Source: "tokens * 4"
                                        Identifier tokens
                                           Type: uint256
                                           Source: "tokens"
                                        Literal, token: [no token] value: 4
                                           Type: int_const 4
                                           Source: "4"
                                      Literal, token: [no token] value: 100
                                         Type: int_const 100
                                         Source: "100"
                                IfStatement
                                   Source: "if (_eth >= 20 ether) amountBonus = tokens * 35 / 1000;\r\n    else if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                                  BinaryOperation using operator >=
                                     Type: bool
                                     Gas costs: 12
                                     Source: "_eth >= 20 ether"
                                    Identifier _eth
                                       Type: uint256
                                       Source: "_eth"
                                    Literal, token: [no token] value: 20
                                       Type: int_const 20000000000000000000
                                       Source: "20 ether"
                                  ExpressionStatement
                                     Gas costs: 47
                                     Source: "amountBonus = tokens * 35 / 1000"
                                    Assignment using operator =
                                       Type: uint256
                                       Source: "amountBonus = tokens * 35 / 1000"
                                      Identifier amountBonus
                                         Type: uint256
                                         Source: "amountBonus"
                                      BinaryOperation using operator /
                                         Type: uint256
                                         Source: "tokens * 35 / 1000"
                                        BinaryOperation using operator *
                                           Type: uint256
                                           Source: "tokens * 35"
                                          Identifier tokens
                                             Type: uint256
                                             Source: "tokens"
                                          Literal, token: [no token] value: 35
                                             Type: int_const 35
                                             Source: "35"
                                        Literal, token: [no token] value: 1000
                                           Type: int_const 1000
                                           Source: "1000"
                                  IfStatement
                                     Source: "if (_eth >= 15 ether) amountBonus = tokens * 3 / 100;\r\n    else if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                                    BinaryOperation using operator >=
                                       Type: bool
                                       Gas costs: 12
                                       Source: "_eth >= 15 ether"
                                      Identifier _eth
                                         Type: uint256
                                         Source: "_eth"
                                      Literal, token: [no token] value: 15
                                         Type: int_const 15000000000000000000
                                         Source: "15 ether"
                                    ExpressionStatement
                                       Gas costs: 47
                                       Source: "amountBonus = tokens * 3 / 100"
                                      Assignment using operator =
                                         Type: uint256
                                         Source: "amountBonus = tokens * 3 / 100"
                                        Identifier amountBonus
                                           Type: uint256
                                           Source: "amountBonus"
                                        BinaryOperation using operator /
                                           Type: uint256
                                           Source: "tokens * 3 / 100"
                                          BinaryOperation using operator *
                                             Type: uint256
                                             Source: "tokens * 3"
                                            Identifier tokens
                                               Type: uint256
                                               Source: "tokens"
                                            Literal, token: [no token] value: 3
                                               Type: int_const 3
                                               Source: "3"
                                          Literal, token: [no token] value: 100
                                             Type: int_const 100
                                             Source: "100"
                                    IfStatement
                                       Source: "if (_eth >= 10 ether) amountBonus = tokens * 25 / 1000;\r\n    else if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                                      BinaryOperation using operator >=
                                         Type: bool
                                         Gas costs: 12
                                         Source: "_eth >= 10 ether"
                                        Identifier _eth
                                           Type: uint256
                                           Source: "_eth"
                                        Literal, token: [no token] value: 10
                                           Type: int_const 10000000000000000000
                                           Source: "10 ether"
                                      ExpressionStatement
                                         Gas costs: 47
                                         Source: "amountBonus = tokens * 25 / 1000"
                                        Assignment using operator =
                                           Type: uint256
                                           Source: "amountBonus = tokens * 25 / 1000"
                                          Identifier amountBonus
                                             Type: uint256
                                             Source: "amountBonus"
                                          BinaryOperation using operator /
                                             Type: uint256
                                             Source: "tokens * 25 / 1000"
                                            BinaryOperation using operator *
                                               Type: uint256
                                               Source: "tokens * 25"
                                              Identifier tokens
                                                 Type: uint256
                                                 Source: "tokens"
                                              Literal, token: [no token] value: 25
                                                 Type: int_const 25
                                                 Source: "25"
                                            Literal, token: [no token] value: 1000
                                               Type: int_const 1000
                                               Source: "1000"
                                      IfStatement
                                         Source: "if (_eth >= 7 ether) amountBonus = tokens * 2 / 100;\r\n    else if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                                        BinaryOperation using operator >=
                                           Type: bool
                                           Gas costs: 12
                                           Source: "_eth >= 7 ether"
                                          Identifier _eth
                                             Type: uint256
                                             Source: "_eth"
                                          Literal, token: [no token] value: 7
                                             Type: int_const 7000000000000000000
                                             Source: "7 ether"
                                        ExpressionStatement
                                           Gas costs: 47
                                           Source: "amountBonus = tokens * 2 / 100"
                                          Assignment using operator =
                                             Type: uint256
                                             Source: "amountBonus = tokens * 2 / 100"
                                            Identifier amountBonus
                                               Type: uint256
                                               Source: "amountBonus"
                                            BinaryOperation using operator /
                                               Type: uint256
                                               Source: "tokens * 2 / 100"
                                              BinaryOperation using operator *
                                                 Type: uint256
                                                 Source: "tokens * 2"
                                                Identifier tokens
                                                   Type: uint256
                                                   Source: "tokens"
                                                Literal, token: [no token] value: 2
                                                   Type: int_const 2
                                                   Source: "2"
                                              Literal, token: [no token] value: 100
                                                 Type: int_const 100
                                                 Source: "100"
                                        IfStatement
                                           Source: "if (_eth >= 5 ether) amountBonus = tokens * 15 / 1000;\r\n    else if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                                          BinaryOperation using operator >=
                                             Type: bool
                                             Gas costs: 12
                                             Source: "_eth >= 5 ether"
                                            Identifier _eth
                                               Type: uint256
                                               Source: "_eth"
                                            Literal, token: [no token] value: 5
                                               Type: int_const 5000000000000000000
                                               Source: "5 ether"
                                          ExpressionStatement
                                             Gas costs: 47
                                             Source: "amountBonus = tokens * 15 / 1000"
                                            Assignment using operator =
                                               Type: uint256
                                               Source: "amountBonus = tokens * 15 / 1000"
                                              Identifier amountBonus
                                                 Type: uint256
                                                 Source: "amountBonus"
                                              BinaryOperation using operator /
                                                 Type: uint256
                                                 Source: "tokens * 15 / 1000"
                                                BinaryOperation using operator *
                                                   Type: uint256
                                                   Source: "tokens * 15"
                                                  Identifier tokens
                                                     Type: uint256
                                                     Source: "tokens"
                                                  Literal, token: [no token] value: 15
                                                     Type: int_const 15
                                                     Source: "15"
                                                Literal, token: [no token] value: 1000
                                                   Type: int_const 1000
                                                   Source: "1000"
                                          IfStatement
                                             Source: "if (_eth >= 3 ether) amountBonus = tokens * 1 / 100;\r\n    else if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                                            BinaryOperation using operator >=
                                               Type: bool
                                               Gas costs: 12
                                               Source: "_eth >= 3 ether"
                                              Identifier _eth
                                                 Type: uint256
                                                 Source: "_eth"
                                              Literal, token: [no token] value: 3
                                                 Type: int_const 3000000000000000000
                                                 Source: "3 ether"
                                            ExpressionStatement
                                               Gas costs: 47
                                               Source: "amountBonus = tokens * 1 / 100"
                                              Assignment using operator =
                                                 Type: uint256
                                                 Source: "amountBonus = tokens * 1 / 100"
                                                Identifier amountBonus
                                                   Type: uint256
                                                   Source: "amountBonus"
                                                BinaryOperation using operator /
                                                   Type: uint256
                                                   Source: "tokens * 1 / 100"
                                                  BinaryOperation using operator *
                                                     Type: uint256
                                                     Source: "tokens * 1"
                                                    Identifier tokens
                                                       Type: uint256
                                                       Source: "tokens"
                                                    Literal, token: [no token] value: 1
                                                       Type: int_const 1
                                                       Source: "1"
                                                  Literal, token: [no token] value: 100
                                                     Type: int_const 100
                                                     Source: "100"
                                            IfStatement
                                               Source: "if (_eth >= 2 ether) amountBonus = tokens * 5 / 1000"
                                              BinaryOperation using operator >=
                                                 Type: bool
                                                 Gas costs: 12
                                                 Source: "_eth >= 2 ether"
                                                Identifier _eth
                                                   Type: uint256
                                                   Source: "_eth"
                                                Literal, token: [no token] value: 2
                                                   Type: int_const 2000000000000000000
                                                   Source: "2 ether"
                                              ExpressionStatement
                                                 Gas costs: 47
                                                 Source: "amountBonus = tokens * 5 / 1000"
                                                Assignment using operator =
                                                   Type: uint256
                                                   Source: "amountBonus = tokens * 5 / 1000"
                                                  Identifier amountBonus
                                                     Type: uint256
                                                     Source: "amountBonus"
                                                  BinaryOperation using operator /
                                                     Type: uint256
                                                     Source: "tokens * 5 / 1000"
                                                    BinaryOperation using operator *
                                                       Type: uint256
                                                       Source: "tokens * 5"
                                                      Identifier tokens
                                                         Type: uint256
                                                         Source: "tokens"
                                                      Literal, token: [no token] value: 5
                                                         Type: int_const 5
                                                         Source: "5"
                                                    Literal, token: [no token] value: 1000
                                                       Type: int_const 1000
                                                       Source: "1000"
      Return
         Gas costs: 8
         Source: "return amountBonus"
        Identifier amountBonus
           Type: uint256
           Source: "amountBonus"
  FunctionDefinition "getPrice" - public - const
     Source: "function getPrice() constant returns (uint result) {\r\n    return PRICE;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return PRICE;\r\n  }"
      Return
         Gas costs: 208
         Source: "return PRICE"
        Identifier PRICE
           Type: uint256
           Source: "PRICE"
  FunctionDefinition "batchReturnEthIfFailed" - public
     Source: "function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner {\r\n    require(crowdsaleState != state.crowdsaleEnded);                // Check if crowdsale has ended\r\n    require(ethRaised < minCap);                // Check if crowdsale has failed\r\n    address currentParticipantAddress;\r\n    uint contribution;\r\n    for (uint cnt = 0; cnt < _numberOfReturns; cnt++){\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\r\n      if (currentParticipantAddress == 0x0) return;                                   // Check if all the participants were compensated\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)){                           // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                                    // Repeat\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint _numberOfReturns)"
      VariableDeclaration "_numberOfReturns"
         Type: uint256
         Source: "uint _numberOfReturns"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(crowdsaleState != state.crowdsaleEnded);                // Check if crowdsale has ended\r\n    require(ethRaised < minCap);                // Check if crowdsale has failed\r\n    address currentParticipantAddress;\r\n    uint contribution;\r\n    for (uint cnt = 0; cnt < _numberOfReturns; cnt++){\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\r\n      if (currentParticipantAddress == 0x0) return;                                   // Check if all the participants were compensated\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)){                           // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                                    // Repeat\r\n    }\r\n  }"
      ExpressionStatement
         Gas costs: 326
         Source: "require(crowdsaleState != state.crowdsaleEnded)"
        FunctionCall
           Type: tuple()
           Source: "require(crowdsaleState != state.crowdsaleEnded)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "crowdsaleState != state.crowdsaleEnded"
            Identifier crowdsaleState
               Type: enum CrowdsaleToken.state
               Source: "crowdsaleState"
            MemberAccess to member crowdsaleEnded
               Type: enum CrowdsaleToken.state
               Source: "state.crowdsaleEnded"
              Identifier state
                 Type: type(enum CrowdsaleToken.state)
                 Source: "state"
      ExpressionStatement
         Gas costs: 435
         Source: "require(ethRaised < minCap)"
        FunctionCall
           Type: tuple()
           Source: "require(ethRaised < minCap)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "ethRaised < minCap"
            Identifier ethRaised
               Type: uint256
               Source: "ethRaised"
            Identifier minCap
               Type: uint256
               Source: "minCap"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "address currentParticipantAddress"
        VariableDeclaration "currentParticipantAddress"
           Type: address
           Source: "address currentParticipantAddress"
          ElementaryTypeName address
             Source: "address"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint contribution"
        VariableDeclaration "contribution"
           Type: uint256
           Source: "uint contribution"
          ElementaryTypeName uint
             Source: "uint"
      ForStatement
         Source: "for (uint cnt = 0; cnt < _numberOfReturns; cnt++){\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\r\n      if (currentParticipantAddress == 0x0) return;                                   // Check if all the participants were compensated\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)){                           // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                                    // Repeat\r\n    }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint cnt = 0"
          VariableDeclaration "cnt"
             Type: uint256
             Source: "uint cnt"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "cnt < _numberOfReturns"
          Identifier cnt
             Type: uint256
             Source: "cnt"
          Identifier _numberOfReturns
             Type: uint256
             Source: "_numberOfReturns"
        ExpressionStatement
           Gas costs: 19
           Source: "cnt++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "cnt++"
            Identifier cnt
               Type: uint256
               Source: "cnt"
        Block
           Source: "{\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\r\n      if (currentParticipantAddress == 0x0) return;                                   // Check if all the participants were compensated\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)){                           // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                                    // Repeat\r\n    }"
          ExpressionStatement
             Gas costs: 528
             Source: "currentParticipantAddress = contributorIndexes[nextContributorToClaim]"
            Assignment using operator =
               Type: address
               Source: "currentParticipantAddress = contributorIndexes[nextContributorToClaim]"
              Identifier currentParticipantAddress
                 Type: address
                 Source: "currentParticipantAddress"
              IndexAccess
                 Type: address
                 Source: "contributorIndexes[nextContributorToClaim]"
                Identifier contributorIndexes
                   Type: mapping(uint256 => address)
                   Source: "contributorIndexes"
                Identifier nextContributorToClaim
                   Type: uint256
                   Source: "nextContributorToClaim"
          IfStatement
             Source: "if (currentParticipantAddress == 0x0) return;"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 15
               Source: "currentParticipantAddress == 0x0"
              Identifier currentParticipantAddress
                 Type: address
                 Source: "currentParticipantAddress"
              Literal, token: [no token] value: 0x0
                 Type: int_const 0
                 Source: "0x0"
            Return
               Gas costs: 11
               Source: "return;"
          IfStatement
             Source: "if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)){                           // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: 338
               Source: "!hasClaimedEthWhenFail[currentParticipantAddress]"
              IndexAccess
                 Type: bool
                 Source: "hasClaimedEthWhenFail[currentParticipantAddress]"
                Identifier hasClaimedEthWhenFail
                   Type: mapping(address => bool)
                   Source: "hasClaimedEthWhenFail"
                Identifier currentParticipantAddress
                   Type: address
                   Source: "currentParticipantAddress"
            Block
               Source: "{                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)){                           // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }"
              ExpressionStatement
                 Gas costs: 310
                 Source: "contribution = contributorList[currentParticipantAddress].contributionAmount"
                Assignment using operator =
                   Type: uint256
                   Source: "contribution = contributorList[currentParticipantAddress].contributionAmount"
                  Identifier contribution
                     Type: uint256
                     Source: "contribution"
                  MemberAccess to member contributionAmount
                     Type: uint256
                     Source: "contributorList[currentParticipantAddress].contributionAmount"
                    IndexAccess
                       Type: struct CrowdsaleToken.ContributorData storage ref
                       Source: "contributorList[currentParticipantAddress]"
                      Identifier contributorList
                         Type: mapping(address => struct CrowdsaleToken.ContributorData storage ref)
                         Source: "contributorList"
                      Identifier currentParticipantAddress
                         Type: address
                         Source: "currentParticipantAddress"
              ExpressionStatement
                 Gas costs: 20357
                 Source: "hasClaimedEthWhenFail[currentParticipantAddress] = true"
                Assignment using operator =
                   Type: bool
                   Source: "hasClaimedEthWhenFail[currentParticipantAddress] = true"
                  IndexAccess
                     Type: bool
                     Source: "hasClaimedEthWhenFail[currentParticipantAddress]"
                    Identifier hasClaimedEthWhenFail
                       Type: mapping(address => bool)
                       Source: "hasClaimedEthWhenFail"
                    Identifier currentParticipantAddress
                       Type: address
                       Source: "currentParticipantAddress"
                  Literal, token: true value: true
                     Type: bool
                     Source: "true"
              IfStatement
                 Source: "if (!currentParticipantAddress.send(contribution)){                           // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }"
                UnaryOperation (prefix) !
                   Type: bool
                   Gas costs: [???]
                   Source: "!currentParticipantAddress.send(contribution)"
                  FunctionCall
                     Type: bool
                     Source: "currentParticipantAddress.send(contribution)"
                    MemberAccess to member send
                       Type: function (uint256) returns (bool)
                       Source: "currentParticipantAddress.send"
                      Identifier currentParticipantAddress
                         Type: address
                         Source: "currentParticipantAddress"
                    Identifier contribution
                       Type: uint256
                       Source: "contribution"
                Block
                   Source: "{                           // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "ErrorSendingETH(currentParticipantAddress, contribution)"
                    FunctionCall
                       Type: tuple()
                       Source: "ErrorSendingETH(currentParticipantAddress, contribution)"
                      Identifier ErrorSendingETH
                         Type: function (address,uint256)
                         Source: "ErrorSendingETH"
                      Identifier currentParticipantAddress
                         Type: address
                         Source: "currentParticipantAddress"
                      Identifier contribution
                         Type: uint256
                         Source: "contribution"
          ExpressionStatement
             Gas costs: 20233
             Source: "nextContributorToClaim += 1"
            Assignment using operator +=
               Type: uint256
               Source: "nextContributorToClaim += 1"
              Identifier nextContributorToClaim
                 Type: uint256
                 Source: "nextContributorToClaim"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
  FunctionDefinition "setMultisigAddress" - public
     Source: "function setMultisigAddress(address _newAddress) onlyOwner {\r\n    multisig = _newAddress;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _newAddress)"
      VariableDeclaration "_newAddress"
         Type: address
         Source: "address _newAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    multisig = _newAddress;\r\n  }"
      ExpressionStatement
         Gas costs: 20267
         Source: "multisig = _newAddress"
        Assignment using operator =
           Type: address
           Source: "multisig = _newAddress"
          Identifier multisig
             Type: address
             Source: "multisig"
          Identifier _newAddress
             Type: address
             Source: "_newAddress"
