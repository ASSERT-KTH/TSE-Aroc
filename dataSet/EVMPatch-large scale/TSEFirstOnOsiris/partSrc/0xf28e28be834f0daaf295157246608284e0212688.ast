Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xf28e28be834f0daaf295157246608284e0212688.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "Token"
   Gas costs: 0
   Source: "interface Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() constant returns (uint256 supply);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256 supply)"
      VariableDeclaration "supply"
         Type: uint256
         Source: "uint256 supply"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "Utils"
   Source: "contract Utils {\r\n    string constant public contract_version = \"0.1._\";\r\n    /// @notice Check if a contract exists\r\n    /// @param channel The address to check whether a contract is deployed or not\r\n    /// @return True if a contract exists, false otherwise\r\n    function contractExists(address channel) constant returns (bool) {\r\n        uint size;\r\n\r\n        assembly {\r\n            size := extcodesize(channel)\r\n        }\r\n\r\n        return size > 0;\r\n    }\r\n}"
  VariableDeclaration "contract_version"
     Type: string memory
     Gas costs: 0
     Source: "string constant public contract_version = \"0.1._\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: 0.1._
       Type: literal_string "0.1._"
       Source: "\"0.1._\""
  FunctionDefinition "contractExists" - public - const
     Source: "function contractExists(address channel) constant returns (bool) {\r\n        uint size;\r\n\r\n        assembly {\r\n            size := extcodesize(channel)\r\n        }\r\n\r\n        return size > 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address channel)"
      VariableDeclaration "channel"
         Type: address
         Source: "address channel"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        uint size;\r\n\r\n        assembly {\r\n            size := extcodesize(channel)\r\n        }\r\n\r\n        return size > 0;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint size"
        VariableDeclaration "size"
           Type: uint256
           Source: "uint size"
          ElementaryTypeName uint
             Source: "uint"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {\r\n            size := extcodesize(channel)\r\n        }\r\n\r\n        return"
      Return
         Gas costs: 0
         Source: "return size > 0"
        BinaryOperation using operator >
           Type: bool
           Source: "size > 0"
          Identifier size
             Type: uint256
             Source: "size"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
ContractDefinition "NettingChannelLibrary"
   Source: "library NettingChannelLibrary {\r\n    string constant public contract_version = \"0.1._\";\r\n\r\n    struct Participant\r\n    {\r\n        address node_address;\r\n\r\n        // Total amount of token transferred to this smart contract through the\r\n        // `deposit` function, note that direct token transfer cannot be\r\n        // tracked and will be burned.\r\n        uint256 balance;\r\n\r\n        // The latest known merkle root of the pending hash-time locks, used to\r\n        // validate the withdrawn proofs.\r\n        bytes32 locksroot;\r\n\r\n        // The latest known transferred_amount from this node to the other\r\n        // participant, used to compute the net balance on settlement.\r\n        uint256 transferred_amount;\r\n\r\n        // Value used to order transfers and only accept the latest on calls to\r\n        // update, this will only be relevant after either #182 or #293 is\r\n        // implemented.\r\n        uint64 nonce;\r\n\r\n        // A mapping to keep track of locks that have been withdrawn.\r\n        mapping(bytes32 => bool) withdrawn_locks;\r\n    }\r\n\r\n    struct Data {\r\n        uint settle_timeout;\r\n        uint opened;\r\n        uint closed;\r\n        uint settled;\r\n        address closing_address;\r\n        Token token;\r\n        Participant[2] participants;\r\n        mapping(address => uint8) participant_index;\r\n        bool updated;\r\n    }\r\n\r\n\r\n    modifier notSettledButClosed(Data storage self) {\r\n        require(self.settled <= 0 && self.closed > 0);\r\n        _;\r\n    }\r\n\r\n    modifier stillTimeout(Data storage self) {\r\n        require(self.closed + self.settle_timeout >= block.number);\r\n        _;\r\n    }\r\n\r\n    modifier timeoutOver(Data storage self) {\r\n        require(self.closed + self.settle_timeout <= block.number);\r\n        _;\r\n    }\r\n\r\n    modifier channelSettled(Data storage self) {\r\n        require(self.settled != 0);\r\n        _;\r\n    }\r\n\r\n    /// @notice Deposit amount to channel.\r\n    /// @dev Deposit an amount to the channel. At least one of the participants\r\n    /// must deposit before the channel is opened.\r\n    /// @param amount The amount to be deposited to the address\r\n    /// @return Success if the transfer was successful\r\n    /// @return The new balance of the invoker\r\n    function deposit(Data storage self, uint256 amount)\r\n        returns (bool success, uint256 balance)\r\n    {\r\n        uint8 index;\r\n\r\n        require(self.opened > 0);\r\n        require(self.closed == 0);\r\n        require(self.token.balanceOf(msg.sender) >= amount);\r\n\r\n        index = index_or_throw(self, msg.sender);\r\n        Participant storage participant = self.participants[index];\r\n\r\n        success = self.token.transferFrom(msg.sender, this, amount);\r\n        if (success == true) {\r\n            balance = participant.balance;\r\n            balance += amount;\r\n            participant.balance = balance;\r\n\r\n            return (true, balance);\r\n        }\r\n\r\n        return (false, 0);\r\n    }\r\n\r\n    /// @notice Close a channel between two parties that was used bidirectionally\r\n    function close(\r\n        Data storage self,\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    ) {\r\n        address transfer_address;\r\n        uint closer_index;\r\n        uint counterparty_index;\r\n\r\n        // close can be called only once\r\n        require(self.closed == 0);\r\n        self.closed = block.number;\r\n\r\n        // Only a participant can call close\r\n        closer_index = index_or_throw(self, msg.sender);\r\n        self.closing_address = msg.sender;\r\n\r\n        // Only the closing party can provide a transfer from the counterparty,\r\n        // and only when this function is called, i.e. this value can not be\r\n        // updated afterwards.\r\n\r\n        // An empty value means that the closer never received a transfer, or\r\n        // he is intentionally not providing the latest transfer, in which case\r\n        // the closing party is going to lose the tokens that were transferred\r\n        // to him.\r\n        if (signature.length == 65) {\r\n            transfer_address = recoverAddressFromSignature(\r\n                nonce,\r\n                transferred_amount,\r\n                locksroot,\r\n                extra_hash,\r\n                signature \r\n            );\r\n\r\n            counterparty_index = index_or_throw(self, transfer_address);\r\n            require(closer_index != counterparty_index);\r\n\r\n            // update the structure of the counterparty with its data provided\r\n            // by the closing node\r\n            Participant storage counterparty = self.participants[counterparty_index];\r\n            counterparty.nonce = uint64(nonce);\r\n            counterparty.locksroot = locksroot;\r\n            counterparty.transferred_amount = transferred_amount;\r\n        }\r\n    }\r\n\r\n    /// @notice Updates counter party transfer after closing.\r\n    function updateTransfer(\r\n        Data storage self,\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    )\r\n        notSettledButClosed(self)\r\n        stillTimeout(self)\r\n    {\r\n        address transfer_address;\r\n        uint8 caller_index;\r\n        uint8 closer_index;\r\n\r\n        // updateTransfer can be called by the counter party only once\r\n        require(!self.updated);\r\n        self.updated = true;\r\n\r\n        // Only a participant can call updateTransfer (#293 for third parties)\r\n        caller_index = index_or_throw(self, msg.sender);\r\n\r\n        // The closer is not allowed to call updateTransfer\r\n        require(self.closing_address != msg.sender);\r\n\r\n        // Counter party can only update the closer transfer\r\n        transfer_address = recoverAddressFromSignature(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature \r\n        );\r\n        require(transfer_address == self.closing_address);\r\n\r\n        // Update the structure of the closer with its data provided by the\r\n        // counterparty\r\n        closer_index = 1 - caller_index;\r\n\r\n        self.participants[closer_index].nonce = nonce;\r\n        self.participants[closer_index].locksroot = locksroot;\r\n        self.participants[closer_index].transferred_amount = transferred_amount;\r\n    }\r\n\r\n    function recoverAddressFromSignature(\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    )\r\n        constant internal returns (address)\r\n    {\r\n        bytes32 signed_hash;\r\n\r\n        require(signature.length == 65);\r\n\r\n        signed_hash = sha3(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            this,\r\n            extra_hash\r\n        );\r\n\r\n        var (r, s, v) = signatureSplit(signature);\r\n        return ecrecover(signed_hash, v, r, s);\r\n    }\r\n\r\n    /// @notice Unlock a locked transfer\r\n    /// @dev Unlock a locked transfer\r\n    /// @param locked_encoded The lock\r\n    /// @param merkle_proof The merkle proof\r\n    /// @param secret The secret\r\n    function withdraw(Data storage self, bytes locked_encoded, bytes merkle_proof, bytes32 secret)\r\n        notSettledButClosed(self)\r\n    {\r\n        uint amount;\r\n        uint8 index;\r\n        uint64 expiration;\r\n        bytes32 h;\r\n        bytes32 hashlock;\r\n\r\n        // Check if msg.sender is a participant and select the partner (for\r\n        // third party unlock see #541)\r\n        index = 1 - index_or_throw(self, msg.sender);\r\n        Participant storage counterparty = self.participants[index];\r\n\r\n        // An empty locksroot means there are no pending locks\r\n        require(counterparty.locksroot != 0);\r\n\r\n        (expiration, amount, hashlock) = decodeLock(locked_encoded);\r\n\r\n        // A lock can be withdrawn only once per participant\r\n        require(!counterparty.withdrawn_locks[hashlock]);\r\n\r\n        counterparty.withdrawn_locks[hashlock] = true;\r\n\r\n        // The lock must not have expired, it does not matter how far in the\r\n        // future it would have expired\r\n        require(expiration >= block.number);\r\n        require(hashlock == sha3(secret));\r\n\r\n        h = computeMerkleRoot(locked_encoded, merkle_proof);\r\n\r\n        require(counterparty.locksroot == h);\r\n\r\n        // This implementation allows for each transfer to be set only once, so\r\n        // it's safe to update the transferred_amount in place.\r\n        //\r\n        // Once third parties are allowed to update the counter party transfer\r\n        // (#293, #182) the locksroot may change, if the locksroot change the\r\n        // transferred_amount must be reset and locks must be re-withdrawn, so\r\n        // this is also safe.\r\n        //\r\n        // This may be problematic if an update changes the transferred_amount\r\n        // but not the locksroot, since the locks don't need to be\r\n        // re-withdrawn, the difference in the transferred_amount must be\r\n        // accounted for.\r\n        counterparty.transferred_amount += amount;\r\n    }\r\n\r\n    function computeMerkleRoot(bytes lock, bytes merkle_proof)\r\n        internal\r\n        constant\r\n        returns (bytes32)\r\n    {\r\n        require(merkle_proof.length % 32 == 0);\r\n\r\n        uint i;\r\n        bytes32 h;\r\n        bytes32 el;\r\n\r\n        h = sha3(lock);\r\n        for (i = 32; i <= merkle_proof.length; i += 32) {\r\n            assembly {\r\n                el := mload(add(merkle_proof, i))\r\n            }\r\n\r\n            if (h < el) {\r\n                h = sha3(h, el);\r\n            } else {\r\n                h = sha3(el, h);\r\n            }\r\n        }\r\n\r\n        return h;\r\n    }\r\n\r\n    /// @notice Settles the balance between the two parties\r\n    /// @dev Settles the balances of the two parties fo the channel\r\n    /// @return The participants with netted balances\r\n    function settle(Data storage self)\r\n        notSettledButClosed(self)\r\n        timeoutOver(self)\r\n    {\r\n        uint8 closing_index;\r\n        uint8 counter_index;\r\n        uint256 total_deposit;\r\n        uint256 counter_net;\r\n        uint256 closer_amount;\r\n        uint256 counter_amount;\r\n\r\n        self.settled = block.number;\r\n\r\n        closing_index = index_or_throw(self, self.closing_address);\r\n        counter_index = 1 - closing_index;\r\n\r\n        Participant storage closing_party = self.participants[closing_index];\r\n        Participant storage counter_party = self.participants[counter_index];\r\n\r\n        counter_net = (\r\n            counter_party.balance\r\n            + closing_party.transferred_amount\r\n            - counter_party.transferred_amount\r\n        );\r\n\r\n        // Direct token transfers done through the token `transfer` function\r\n        // cannot be accounted for, these superfluous tokens will be burned,\r\n        // this is because there is no way to tell which participant (if any)\r\n        // had ownership over the token.\r\n        total_deposit = closing_party.balance + counter_party.balance;\r\n\r\n        // When the closing party does not provide the counter party transfer,\r\n        // the `counter_net` may be larger than the `total_deposit`, without\r\n        // the min the token transfer fail and the token is locked.\r\n        counter_amount = min(counter_net, total_deposit);\r\n\r\n        // When the counter party does not provide the closing party transfer,\r\n        // then `counter_amount` may be negative and the transfer fails, force\r\n        // the value to 0.\r\n        counter_amount = max(counter_amount, 0);\r\n\r\n        // At this point `counter_amount` is between [0,total_deposit], so this\r\n        // is safe.\r\n        closer_amount = total_deposit - counter_amount;\r\n\r\n        if (counter_amount > 0) {\r\n            require(self.token.transfer(counter_party.node_address, counter_amount));\r\n        }\r\n\r\n        if (closer_amount > 0) {\r\n            require(self.token.transfer(closing_party.node_address, closer_amount));\r\n        }\r\n\r\n        kill(self);\r\n    }\r\n\r\n    // NOTES:\r\n    //\r\n    // - The EVM is a big-endian, byte addressing machine, with 32bytes/256bits\r\n    //   words.\r\n    // - The Ethereum Contract ABI specifies that variable length types have a\r\n    //   32bytes prefix to define the variable size.\r\n    // - Solidity has additional data types that are narrower than 32bytes\r\n    //   (e.g. uint128 uses a half word).\r\n    // - Solidity uses the *least-significant* bits of the word to store the\r\n    //   values of a narrower type.\r\n    //\r\n    // GENERAL APPROACH:\r\n    //\r\n    // Add to the message pointer the number of bytes required to move the\r\n    // address so that the target data is at the end of the 32bytes word.\r\n    //\r\n    // EXAMPLE:\r\n    //\r\n    // To decode the cmdid, consider this initial state:\r\n    //\r\n    //\r\n    //     v- pointer word start\r\n    //     [ 32 bytes length prefix ][ cmdid ] ----\r\n    //                              ^- pointer word end\r\n    //\r\n    //\r\n    // Because the cmdid has 1 byte length the type uint8 is used, the decoder\r\n    // needs to move the pointer so the cmdid is at the end of the pointer\r\n    // word.\r\n    //\r\n    //\r\n    //             v- pointer word start [moved 1byte ahead]\r\n    //     [ 32 bytes length prefix ][ cmdid ] ----\r\n    //                                       ^- pointer word end\r\n    //\r\n    //\r\n    // Now the data of the cmdid can be loaded to the uint8 variable.\r\n    //\r\n    // REFERENCES:\r\n    // - https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\r\n    // - http://solidity.readthedocs.io/en/develop/assembly.html\r\n\r\n    function decodeLock(bytes lock) internal returns (uint64 expiration, uint amount, bytes32 hashlock) {\r\n        require(lock.length == 72);\r\n\r\n        // Lock format:\r\n        // [0:8] expiration\r\n        // [8:40] amount\r\n        // [40:72] hashlock\r\n        assembly {\r\n            expiration := mload(add(lock, 8))\r\n            amount := mload(add(lock, 40))\r\n            hashlock := mload(add(lock, 72))\r\n        }\r\n    }\r\n\r\n    function signatureSplit(bytes signature) internal returns (bytes32 r, bytes32 s, uint8 v) {\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            // Here we are loading the last 32 bytes, including 31 bytes\r\n            // of 's'. There is no 'mload8' to do this.\r\n            //\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            v := and(mload(add(signature, 65)), 0xff)\r\n        }\r\n\r\n        require(v == 27 || v == 28);\r\n    }\r\n\r\n    function index_or_throw(Data storage self, address participant_address) private returns (uint8) {\r\n        uint8 n;\r\n        // Return index of participant, or throw\r\n        n = self.participant_index[participant_address];\r\n        assert(n != 0);\r\n        return n - 1;\r\n    }\r\n\r\n    function min(uint a, uint b) constant internal returns (uint) {\r\n        return a > b ? b : a;\r\n    }\r\n\r\n    function max(uint a, uint b) constant internal returns (uint) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    function kill(Data storage self) channelSettled(self) {\r\n        selfdestruct(0x00000000000000000000);\r\n    }\r\n}"
  VariableDeclaration "contract_version"
     Type: string memory
     Gas costs: 0
     Source: "string constant public contract_version = \"0.1._\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: 0.1._
       Type: literal_string "0.1._"
       Source: "\"0.1._\""
  StructDefinition "Participant"
     Gas costs: 0
     Source: "struct Participant\r\n    {\r\n        address node_address;\r\n\r\n        // Total amount of token transferred to this smart contract through the\r\n        // `deposit` function, note that direct token transfer cannot be\r\n        // tracked and will be burned.\r\n        uint256 balance;\r\n\r\n        // The latest known merkle root of the pending hash-time locks, used to\r\n        // validate the withdrawn proofs.\r\n        bytes32 locksroot;\r\n\r\n        // The latest known transferred_amount from this node to the other\r\n        // participant, used to compute the net balance on settlement.\r\n        uint256 transferred_amount;\r\n\r\n        // Value used to order transfers and only accept the latest on calls to\r\n        // update, this will only be relevant after either #182 or #293 is\r\n        // implemented.\r\n        uint64 nonce;\r\n\r\n        // A mapping to keep track of locks that have been withdrawn.\r\n        mapping(bytes32 => bool) withdrawn_locks;\r\n    }"
    VariableDeclaration "node_address"
       Type: address
       Source: "address node_address"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "balance"
       Type: uint256
       Source: "uint256 balance"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "locksroot"
       Type: bytes32
       Source: "bytes32 locksroot"
      ElementaryTypeName bytes32
         Source: "bytes32"
    VariableDeclaration "transferred_amount"
       Type: uint256
       Source: "uint256 transferred_amount"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "nonce"
       Type: uint64
       Source: "uint64 nonce"
      ElementaryTypeName uint64
         Source: "uint64"
    VariableDeclaration "withdrawn_locks"
       Type: mapping(bytes32 => bool)
       Source: "mapping(bytes32 => bool) withdrawn_locks"
      Mapping
         Source: "mapping(bytes32 => bool)"
        ElementaryTypeName bytes32
           Source: "bytes32"
        ElementaryTypeName bool
           Source: "bool"
  StructDefinition "Data"
     Gas costs: 0
     Source: "struct Data {\r\n        uint settle_timeout;\r\n        uint opened;\r\n        uint closed;\r\n        uint settled;\r\n        address closing_address;\r\n        Token token;\r\n        Participant[2] participants;\r\n        mapping(address => uint8) participant_index;\r\n        bool updated;\r\n    }"
    VariableDeclaration "settle_timeout"
       Type: uint256
       Source: "uint settle_timeout"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "opened"
       Type: uint256
       Source: "uint opened"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "closed"
       Type: uint256
       Source: "uint closed"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "settled"
       Type: uint256
       Source: "uint settled"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "closing_address"
       Type: address
       Source: "address closing_address"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "token"
       Type: contract Token
       Source: "Token token"
      UserDefinedTypeName "Token"
         Source: "Token"
    VariableDeclaration "participants"
       Type: struct NettingChannelLibrary.Participant storage ref[2] storage pointer
       Source: "Participant[2] participants"
      ArrayTypeName
         Source: "Participant[2]"
        UserDefinedTypeName "Participant"
           Source: "Participant"
        Literal, token: [no token] value: 2
           Type unknown.
           Source: "2"
    VariableDeclaration "participant_index"
       Type: mapping(address => uint8)
       Source: "mapping(address => uint8) participant_index"
      Mapping
         Source: "mapping(address => uint8)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint8
           Source: "uint8"
    VariableDeclaration "updated"
       Type: bool
       Source: "bool updated"
      ElementaryTypeName bool
         Source: "bool"
  ModifierDefinition "notSettledButClosed"
     Source: "modifier notSettledButClosed(Data storage self) {\r\n        require(self.settled <= 0 && self.closed > 0);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Data storage self)"
      VariableDeclaration "self"
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "Data storage self"
        UserDefinedTypeName "Data"
           Source: "Data"
    Block
       Source: "{\r\n        require(self.settled <= 0 && self.closed > 0);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(self.settled <= 0 && self.closed > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(self.settled <= 0 && self.closed > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "self.settled <= 0 && self.closed > 0"
            BinaryOperation using operator <=
               Type: bool
               Source: "self.settled <= 0"
              MemberAccess to member settled
                 Type: uint256
                 Source: "self.settled"
                Identifier self
                   Type: struct NettingChannelLibrary.Data storage pointer
                   Source: "self"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator >
               Type: bool
               Source: "self.closed > 0"
              MemberAccess to member closed
                 Type: uint256
                 Source: "self.closed"
                Identifier self
                   Type: struct NettingChannelLibrary.Data storage pointer
                   Source: "self"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "stillTimeout"
     Source: "modifier stillTimeout(Data storage self) {\r\n        require(self.closed + self.settle_timeout >= block.number);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Data storage self)"
      VariableDeclaration "self"
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "Data storage self"
        UserDefinedTypeName "Data"
           Source: "Data"
    Block
       Source: "{\r\n        require(self.closed + self.settle_timeout >= block.number);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(self.closed + self.settle_timeout >= block.number)"
        FunctionCall
           Type: tuple()
           Source: "require(self.closed + self.settle_timeout >= block.number)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "self.closed + self.settle_timeout >= block.number"
            BinaryOperation using operator +
               Type: uint256
               Source: "self.closed + self.settle_timeout"
              MemberAccess to member closed
                 Type: uint256
                 Source: "self.closed"
                Identifier self
                   Type: struct NettingChannelLibrary.Data storage pointer
                   Source: "self"
              MemberAccess to member settle_timeout
                 Type: uint256
                 Source: "self.settle_timeout"
                Identifier self
                   Type: struct NettingChannelLibrary.Data storage pointer
                   Source: "self"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "timeoutOver"
     Source: "modifier timeoutOver(Data storage self) {\r\n        require(self.closed + self.settle_timeout <= block.number);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Data storage self)"
      VariableDeclaration "self"
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "Data storage self"
        UserDefinedTypeName "Data"
           Source: "Data"
    Block
       Source: "{\r\n        require(self.closed + self.settle_timeout <= block.number);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(self.closed + self.settle_timeout <= block.number)"
        FunctionCall
           Type: tuple()
           Source: "require(self.closed + self.settle_timeout <= block.number)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "self.closed + self.settle_timeout <= block.number"
            BinaryOperation using operator +
               Type: uint256
               Source: "self.closed + self.settle_timeout"
              MemberAccess to member closed
                 Type: uint256
                 Source: "self.closed"
                Identifier self
                   Type: struct NettingChannelLibrary.Data storage pointer
                   Source: "self"
              MemberAccess to member settle_timeout
                 Type: uint256
                 Source: "self.settle_timeout"
                Identifier self
                   Type: struct NettingChannelLibrary.Data storage pointer
                   Source: "self"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "channelSettled"
     Source: "modifier channelSettled(Data storage self) {\r\n        require(self.settled != 0);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Data storage self)"
      VariableDeclaration "self"
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "Data storage self"
        UserDefinedTypeName "Data"
           Source: "Data"
    Block
       Source: "{\r\n        require(self.settled != 0);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(self.settled != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(self.settled != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "self.settled != 0"
            MemberAccess to member settled
               Type: uint256
               Source: "self.settled"
              Identifier self
                 Type: struct NettingChannelLibrary.Data storage pointer
                 Source: "self"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "deposit" - public
     Source: "function deposit(Data storage self, uint256 amount)\r\n        returns (bool success, uint256 balance)\r\n    {\r\n        uint8 index;\r\n\r\n        require(self.opened > 0);\r\n        require(self.closed == 0);\r\n        require(self.token.balanceOf(msg.sender) >= amount);\r\n\r\n        index = index_or_throw(self, msg.sender);\r\n        Participant storage participant = self.participants[index];\r\n\r\n        success = self.token.transferFrom(msg.sender, this, amount);\r\n        if (success == true) {\r\n            balance = participant.balance;\r\n            balance += amount;\r\n            participant.balance = balance;\r\n\r\n            return (true, balance);\r\n        }\r\n\r\n        return (false, 0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Data storage self, uint256 amount)"
      VariableDeclaration "self"
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "Data storage self"
        UserDefinedTypeName "Data"
           Source: "Data"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success, uint256 balance)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        uint8 index;\r\n\r\n        require(self.opened > 0);\r\n        require(self.closed == 0);\r\n        require(self.token.balanceOf(msg.sender) >= amount);\r\n\r\n        index = index_or_throw(self, msg.sender);\r\n        Participant storage participant = self.participants[index];\r\n\r\n        success = self.token.transferFrom(msg.sender, this, amount);\r\n        if (success == true) {\r\n            balance = participant.balance;\r\n            balance += amount;\r\n            participant.balance = balance;\r\n\r\n            return (true, balance);\r\n        }\r\n\r\n        return (false, 0);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint8 index"
        VariableDeclaration "index"
           Type: uint8
           Source: "uint8 index"
          ElementaryTypeName uint8
             Source: "uint8"
      ExpressionStatement
         Gas costs: 0
         Source: "require(self.opened > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(self.opened > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "self.opened > 0"
            MemberAccess to member opened
               Type: uint256
               Source: "self.opened"
              Identifier self
                 Type: struct NettingChannelLibrary.Data storage pointer
                 Source: "self"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(self.closed == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(self.closed == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "self.closed == 0"
            MemberAccess to member closed
               Type: uint256
               Source: "self.closed"
              Identifier self
                 Type: struct NettingChannelLibrary.Data storage pointer
                 Source: "self"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(self.token.balanceOf(msg.sender) >= amount)"
        FunctionCall
           Type: tuple()
           Source: "require(self.token.balanceOf(msg.sender) >= amount)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "self.token.balanceOf(msg.sender) >= amount"
            FunctionCall
               Type: uint256
               Source: "self.token.balanceOf(msg.sender)"
              MemberAccess to member balanceOf
                 Type: function (address) view external returns (uint256)
                 Source: "self.token.balanceOf"
                MemberAccess to member token
                   Type: contract Token
                   Source: "self.token"
                  Identifier self
                     Type: struct NettingChannelLibrary.Data storage pointer
                     Source: "self"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier amount
               Type: uint256
               Source: "amount"
      ExpressionStatement
         Gas costs: 0
         Source: "index = index_or_throw(self, msg.sender)"
        Assignment using operator =
           Type: uint8
           Source: "index = index_or_throw(self, msg.sender)"
          Identifier index
             Type: uint8
             Source: "index"
          FunctionCall
             Type: uint8
             Source: "index_or_throw(self, msg.sender)"
            Identifier index_or_throw
               Type: function (struct NettingChannelLibrary.Data storage pointer,address) returns (uint8)
               Source: "index_or_throw"
            Identifier self
               Type: struct NettingChannelLibrary.Data storage pointer
               Source: "self"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "Participant storage participant = self.participants[index]"
        VariableDeclaration "participant"
           Type: struct NettingChannelLibrary.Participant storage pointer
           Source: "Participant storage participant"
          UserDefinedTypeName "Participant"
             Source: "Participant"
        IndexAccess
           Type: struct NettingChannelLibrary.Participant storage ref
           Source: "self.participants[index]"
          MemberAccess to member participants
             Type: struct NettingChannelLibrary.Participant storage ref[2] storage ref
             Source: "self.participants"
            Identifier self
               Type: struct NettingChannelLibrary.Data storage pointer
               Source: "self"
          Identifier index
             Type: uint8
             Source: "index"
      ExpressionStatement
         Gas costs: 0
         Source: "success = self.token.transferFrom(msg.sender, this, amount)"
        Assignment using operator =
           Type: bool
           Source: "success = self.token.transferFrom(msg.sender, this, amount)"
          Identifier success
             Type: bool
             Source: "success"
          FunctionCall
             Type: bool
             Source: "self.token.transferFrom(msg.sender, this, amount)"
            MemberAccess to member transferFrom
               Type: function (address,address,uint256) external returns (bool)
               Source: "self.token.transferFrom"
              MemberAccess to member token
                 Type: contract Token
                 Source: "self.token"
                Identifier self
                   Type: struct NettingChannelLibrary.Data storage pointer
                   Source: "self"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier this
               Type: library NettingChannelLibrary
               Source: "this"
            Identifier amount
               Type: uint256
               Source: "amount"
      IfStatement
         Source: "if (success == true) {\r\n            balance = participant.balance;\r\n            balance += amount;\r\n            participant.balance = balance;\r\n\r\n            return (true, balance);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "success == true"
          Identifier success
             Type: bool
             Source: "success"
          Literal, token: true value: true
             Type: bool
             Source: "true"
        Block
           Source: "{\r\n            balance = participant.balance;\r\n            balance += amount;\r\n            participant.balance = balance;\r\n\r\n            return (true, balance);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "balance = participant.balance"
            Assignment using operator =
               Type: uint256
               Source: "balance = participant.balance"
              Identifier balance
                 Type: uint256
                 Source: "balance"
              MemberAccess to member balance
                 Type: uint256
                 Source: "participant.balance"
                Identifier participant
                   Type: struct NettingChannelLibrary.Participant storage pointer
                   Source: "participant"
          ExpressionStatement
             Gas costs: 0
             Source: "balance += amount"
            Assignment using operator +=
               Type: uint256
               Source: "balance += amount"
              Identifier balance
                 Type: uint256
                 Source: "balance"
              Identifier amount
                 Type: uint256
                 Source: "amount"
          ExpressionStatement
             Gas costs: 0
             Source: "participant.balance = balance"
            Assignment using operator =
               Type: uint256
               Source: "participant.balance = balance"
              MemberAccess to member balance
                 Type: uint256
                 Source: "participant.balance"
                Identifier participant
                   Type: struct NettingChannelLibrary.Participant storage pointer
                   Source: "participant"
              Identifier balance
                 Type: uint256
                 Source: "balance"
          Return
             Gas costs: 0
             Source: "return (true, balance)"
            TupleExpression
               Type: tuple(bool,uint256)
               Source: "(true, balance)"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
              Identifier balance
                 Type: uint256
                 Source: "balance"
      Return
         Gas costs: 0
         Source: "return (false, 0)"
        TupleExpression
           Type: tuple(bool,int_const 0)
           Source: "(false, 0)"
          Literal, token: false value: false
             Type: bool
             Source: "false"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "close" - public
     Source: "function close(\r\n        Data storage self,\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    ) {\r\n        address transfer_address;\r\n        uint closer_index;\r\n        uint counterparty_index;\r\n\r\n        // close can be called only once\r\n        require(self.closed == 0);\r\n        self.closed = block.number;\r\n\r\n        // Only a participant can call close\r\n        closer_index = index_or_throw(self, msg.sender);\r\n        self.closing_address = msg.sender;\r\n\r\n        // Only the closing party can provide a transfer from the counterparty,\r\n        // and only when this function is called, i.e. this value can not be\r\n        // updated afterwards.\r\n\r\n        // An empty value means that the closer never received a transfer, or\r\n        // he is intentionally not providing the latest transfer, in which case\r\n        // the closing party is going to lose the tokens that were transferred\r\n        // to him.\r\n        if (signature.length == 65) {\r\n            transfer_address = recoverAddressFromSignature(\r\n                nonce,\r\n                transferred_amount,\r\n                locksroot,\r\n                extra_hash,\r\n                signature \r\n            );\r\n\r\n            counterparty_index = index_or_throw(self, transfer_address);\r\n            require(closer_index != counterparty_index);\r\n\r\n            // update the structure of the counterparty with its data provided\r\n            // by the closing node\r\n            Participant storage counterparty = self.participants[counterparty_index];\r\n            counterparty.nonce = uint64(nonce);\r\n            counterparty.locksroot = locksroot;\r\n            counterparty.transferred_amount = transferred_amount;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        Data storage self,\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    )"
      VariableDeclaration "self"
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "Data storage self"
        UserDefinedTypeName "Data"
           Source: "Data"
      VariableDeclaration "nonce"
         Type: uint64
         Source: "uint64 nonce"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "transferred_amount"
         Type: uint256
         Source: "uint256 transferred_amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "locksroot"
         Type: bytes32
         Source: "bytes32 locksroot"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "extra_hash"
         Type: bytes32
         Source: "bytes32 extra_hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "signature"
         Type: bytes memory
         Source: "bytes signature"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        address transfer_address;\r\n        uint closer_index;\r\n        uint counterparty_index;\r\n\r\n        // close can be called only once\r\n        require(self.closed == 0);\r\n        self.closed = block.number;\r\n\r\n        // Only a participant can call close\r\n        closer_index = index_or_throw(self, msg.sender);\r\n        self.closing_address = msg.sender;\r\n\r\n        // Only the closing party can provide a transfer from the counterparty,\r\n        // and only when this function is called, i.e. this value can not be\r\n        // updated afterwards.\r\n\r\n        // An empty value means that the closer never received a transfer, or\r\n        // he is intentionally not providing the latest transfer, in which case\r\n        // the closing party is going to lose the tokens that were transferred\r\n        // to him.\r\n        if (signature.length == 65) {\r\n            transfer_address = recoverAddressFromSignature(\r\n                nonce,\r\n                transferred_amount,\r\n                locksroot,\r\n                extra_hash,\r\n                signature \r\n            );\r\n\r\n            counterparty_index = index_or_throw(self, transfer_address);\r\n            require(closer_index != counterparty_index);\r\n\r\n            // update the structure of the counterparty with its data provided\r\n            // by the closing node\r\n            Participant storage counterparty = self.participants[counterparty_index];\r\n            counterparty.nonce = uint64(nonce);\r\n            counterparty.locksroot = locksroot;\r\n            counterparty.transferred_amount = transferred_amount;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "address transfer_address"
        VariableDeclaration "transfer_address"
           Type: address
           Source: "address transfer_address"
          ElementaryTypeName address
             Source: "address"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint closer_index"
        VariableDeclaration "closer_index"
           Type: uint256
           Source: "uint closer_index"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint counterparty_index"
        VariableDeclaration "counterparty_index"
           Type: uint256
           Source: "uint counterparty_index"
          ElementaryTypeName uint
             Source: "uint"
      ExpressionStatement
         Gas costs: 0
         Source: "require(self.closed == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(self.closed == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "self.closed == 0"
            MemberAccess to member closed
               Type: uint256
               Source: "self.closed"
              Identifier self
                 Type: struct NettingChannelLibrary.Data storage pointer
                 Source: "self"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "self.closed = block.number"
        Assignment using operator =
           Type: uint256
           Source: "self.closed = block.number"
          MemberAccess to member closed
             Type: uint256
             Source: "self.closed"
            Identifier self
               Type: struct NettingChannelLibrary.Data storage pointer
               Source: "self"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
      ExpressionStatement
         Gas costs: 0
         Source: "closer_index = index_or_throw(self, msg.sender)"
        Assignment using operator =
           Type: uint256
           Source: "closer_index = index_or_throw(self, msg.sender)"
          Identifier closer_index
             Type: uint256
             Source: "closer_index"
          FunctionCall
             Type: uint8
             Source: "index_or_throw(self, msg.sender)"
            Identifier index_or_throw
               Type: function (struct NettingChannelLibrary.Data storage pointer,address) returns (uint8)
               Source: "index_or_throw"
            Identifier self
               Type: struct NettingChannelLibrary.Data storage pointer
               Source: "self"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "self.closing_address = msg.sender"
        Assignment using operator =
           Type: address
           Source: "self.closing_address = msg.sender"
          MemberAccess to member closing_address
             Type: address
             Source: "self.closing_address"
            Identifier self
               Type: struct NettingChannelLibrary.Data storage pointer
               Source: "self"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (signature.length == 65) {\r\n            transfer_address = recoverAddressFromSignature(\r\n                nonce,\r\n                transferred_amount,\r\n                locksroot,\r\n                extra_hash,\r\n                signature \r\n            );\r\n\r\n            counterparty_index = index_or_throw(self, transfer_address);\r\n            require(closer_index != counterparty_index);\r\n\r\n            // update the structure of the counterparty with its data provided\r\n            // by the closing node\r\n            Participant storage counterparty = self.participants[counterparty_index];\r\n            counterparty.nonce = uint64(nonce);\r\n            counterparty.locksroot = locksroot;\r\n            counterparty.transferred_amount = transferred_amount;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "signature.length == 65"
          MemberAccess to member length
             Type: uint256
             Source: "signature.length"
            Identifier signature
               Type: bytes memory
               Source: "signature"
          Literal, token: [no token] value: 65
             Type: int_const 65
             Source: "65"
        Block
           Source: "{\r\n            transfer_address = recoverAddressFromSignature(\r\n                nonce,\r\n                transferred_amount,\r\n                locksroot,\r\n                extra_hash,\r\n                signature \r\n            );\r\n\r\n            counterparty_index = index_or_throw(self, transfer_address);\r\n            require(closer_index != counterparty_index);\r\n\r\n            // update the structure of the counterparty with its data provided\r\n            // by the closing node\r\n            Participant storage counterparty = self.participants[counterparty_index];\r\n            counterparty.nonce = uint64(nonce);\r\n            counterparty.locksroot = locksroot;\r\n            counterparty.transferred_amount = transferred_amount;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "transfer_address = recoverAddressFromSignature(\r\n                nonce,\r\n                transferred_amount,\r\n                locksroot,\r\n                extra_hash,\r\n                signature \r\n            )"
            Assignment using operator =
               Type: address
               Source: "transfer_address = recoverAddressFromSignature(\r\n                nonce,\r\n                transferred_amount,\r\n                locksroot,\r\n                extra_hash,\r\n                signature \r\n            )"
              Identifier transfer_address
                 Type: address
                 Source: "transfer_address"
              FunctionCall
                 Type: address
                 Source: "recoverAddressFromSignature(\r\n                nonce,\r\n                transferred_amount,\r\n                locksroot,\r\n                extra_hash,\r\n                signature \r\n            )"
                Identifier recoverAddressFromSignature
                   Type: function (uint64,uint256,bytes32,bytes32,bytes memory) view returns (address)
                   Source: "recoverAddressFromSignature"
                Identifier nonce
                   Type: uint64
                   Source: "nonce"
                Identifier transferred_amount
                   Type: uint256
                   Source: "transferred_amount"
                Identifier locksroot
                   Type: bytes32
                   Source: "locksroot"
                Identifier extra_hash
                   Type: bytes32
                   Source: "extra_hash"
                Identifier signature
                   Type: bytes memory
                   Source: "signature"
          ExpressionStatement
             Gas costs: 0
             Source: "counterparty_index = index_or_throw(self, transfer_address)"
            Assignment using operator =
               Type: uint256
               Source: "counterparty_index = index_or_throw(self, transfer_address)"
              Identifier counterparty_index
                 Type: uint256
                 Source: "counterparty_index"
              FunctionCall
                 Type: uint8
                 Source: "index_or_throw(self, transfer_address)"
                Identifier index_or_throw
                   Type: function (struct NettingChannelLibrary.Data storage pointer,address) returns (uint8)
                   Source: "index_or_throw"
                Identifier self
                   Type: struct NettingChannelLibrary.Data storage pointer
                   Source: "self"
                Identifier transfer_address
                   Type: address
                   Source: "transfer_address"
          ExpressionStatement
             Gas costs: 0
             Source: "require(closer_index != counterparty_index)"
            FunctionCall
               Type: tuple()
               Source: "require(closer_index != counterparty_index)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "closer_index != counterparty_index"
                Identifier closer_index
                   Type: uint256
                   Source: "closer_index"
                Identifier counterparty_index
                   Type: uint256
                   Source: "counterparty_index"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "Participant storage counterparty = self.participants[counterparty_index]"
            VariableDeclaration "counterparty"
               Type: struct NettingChannelLibrary.Participant storage pointer
               Source: "Participant storage counterparty"
              UserDefinedTypeName "Participant"
                 Source: "Participant"
            IndexAccess
               Type: struct NettingChannelLibrary.Participant storage ref
               Source: "self.participants[counterparty_index]"
              MemberAccess to member participants
                 Type: struct NettingChannelLibrary.Participant storage ref[2] storage ref
                 Source: "self.participants"
                Identifier self
                   Type: struct NettingChannelLibrary.Data storage pointer
                   Source: "self"
              Identifier counterparty_index
                 Type: uint256
                 Source: "counterparty_index"
          ExpressionStatement
             Gas costs: 0
             Source: "counterparty.nonce = uint64(nonce)"
            Assignment using operator =
               Type: uint64
               Source: "counterparty.nonce = uint64(nonce)"
              MemberAccess to member nonce
                 Type: uint64
                 Source: "counterparty.nonce"
                Identifier counterparty
                   Type: struct NettingChannelLibrary.Participant storage pointer
                   Source: "counterparty"
              FunctionCall
                 Type: uint64
                 Source: "uint64(nonce)"
                ElementaryTypeNameExpression uint64
                   Type: type(uint64)
                   Source: "uint64"
                Identifier nonce
                   Type: uint64
                   Source: "nonce"
          ExpressionStatement
             Gas costs: 0
             Source: "counterparty.locksroot = locksroot"
            Assignment using operator =
               Type: bytes32
               Source: "counterparty.locksroot = locksroot"
              MemberAccess to member locksroot
                 Type: bytes32
                 Source: "counterparty.locksroot"
                Identifier counterparty
                   Type: struct NettingChannelLibrary.Participant storage pointer
                   Source: "counterparty"
              Identifier locksroot
                 Type: bytes32
                 Source: "locksroot"
          ExpressionStatement
             Gas costs: 0
             Source: "counterparty.transferred_amount = transferred_amount"
            Assignment using operator =
               Type: uint256
               Source: "counterparty.transferred_amount = transferred_amount"
              MemberAccess to member transferred_amount
                 Type: uint256
                 Source: "counterparty.transferred_amount"
                Identifier counterparty
                   Type: struct NettingChannelLibrary.Participant storage pointer
                   Source: "counterparty"
              Identifier transferred_amount
                 Type: uint256
                 Source: "transferred_amount"
  FunctionDefinition "updateTransfer" - public
     Source: "function updateTransfer(\r\n        Data storage self,\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    )\r\n        notSettledButClosed(self)\r\n        stillTimeout(self)\r\n    {\r\n        address transfer_address;\r\n        uint8 caller_index;\r\n        uint8 closer_index;\r\n\r\n        // updateTransfer can be called by the counter party only once\r\n        require(!self.updated);\r\n        self.updated = true;\r\n\r\n        // Only a participant can call updateTransfer (#293 for third parties)\r\n        caller_index = index_or_throw(self, msg.sender);\r\n\r\n        // The closer is not allowed to call updateTransfer\r\n        require(self.closing_address != msg.sender);\r\n\r\n        // Counter party can only update the closer transfer\r\n        transfer_address = recoverAddressFromSignature(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature \r\n        );\r\n        require(transfer_address == self.closing_address);\r\n\r\n        // Update the structure of the closer with its data provided by the\r\n        // counterparty\r\n        closer_index = 1 - caller_index;\r\n\r\n        self.participants[closer_index].nonce = nonce;\r\n        self.participants[closer_index].locksroot = locksroot;\r\n        self.participants[closer_index].transferred_amount = transferred_amount;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        Data storage self,\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    )"
      VariableDeclaration "self"
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "Data storage self"
        UserDefinedTypeName "Data"
           Source: "Data"
      VariableDeclaration "nonce"
         Type: uint64
         Source: "uint64 nonce"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "transferred_amount"
         Type: uint256
         Source: "uint256 transferred_amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "locksroot"
         Type: bytes32
         Source: "bytes32 locksroot"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "extra_hash"
         Type: bytes32
         Source: "bytes32 extra_hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "signature"
         Type: bytes memory
         Source: "bytes signature"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "notSettledButClosed"
       Gas costs: 0
       Source: "notSettledButClosed(self)"
      Identifier notSettledButClosed
         Type: modifier (struct NettingChannelLibrary.Data storage pointer)
         Source: "notSettledButClosed"
      Identifier self
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "self"
    ModifierInvocation "stillTimeout"
       Gas costs: 0
       Source: "stillTimeout(self)"
      Identifier stillTimeout
         Type: modifier (struct NettingChannelLibrary.Data storage pointer)
         Source: "stillTimeout"
      Identifier self
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "self"
    Block
       Source: "{\r\n        address transfer_address;\r\n        uint8 caller_index;\r\n        uint8 closer_index;\r\n\r\n        // updateTransfer can be called by the counter party only once\r\n        require(!self.updated);\r\n        self.updated = true;\r\n\r\n        // Only a participant can call updateTransfer (#293 for third parties)\r\n        caller_index = index_or_throw(self, msg.sender);\r\n\r\n        // The closer is not allowed to call updateTransfer\r\n        require(self.closing_address != msg.sender);\r\n\r\n        // Counter party can only update the closer transfer\r\n        transfer_address = recoverAddressFromSignature(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature \r\n        );\r\n        require(transfer_address == self.closing_address);\r\n\r\n        // Update the structure of the closer with its data provided by the\r\n        // counterparty\r\n        closer_index = 1 - caller_index;\r\n\r\n        self.participants[closer_index].nonce = nonce;\r\n        self.participants[closer_index].locksroot = locksroot;\r\n        self.participants[closer_index].transferred_amount = transferred_amount;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "address transfer_address"
        VariableDeclaration "transfer_address"
           Type: address
           Source: "address transfer_address"
          ElementaryTypeName address
             Source: "address"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint8 caller_index"
        VariableDeclaration "caller_index"
           Type: uint8
           Source: "uint8 caller_index"
          ElementaryTypeName uint8
             Source: "uint8"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint8 closer_index"
        VariableDeclaration "closer_index"
           Type: uint8
           Source: "uint8 closer_index"
          ElementaryTypeName uint8
             Source: "uint8"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!self.updated)"
        FunctionCall
           Type: tuple()
           Source: "require(!self.updated)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!self.updated"
            MemberAccess to member updated
               Type: bool
               Source: "self.updated"
              Identifier self
                 Type: struct NettingChannelLibrary.Data storage pointer
                 Source: "self"
      ExpressionStatement
         Gas costs: 0
         Source: "self.updated = true"
        Assignment using operator =
           Type: bool
           Source: "self.updated = true"
          MemberAccess to member updated
             Type: bool
             Source: "self.updated"
            Identifier self
               Type: struct NettingChannelLibrary.Data storage pointer
               Source: "self"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "caller_index = index_or_throw(self, msg.sender)"
        Assignment using operator =
           Type: uint8
           Source: "caller_index = index_or_throw(self, msg.sender)"
          Identifier caller_index
             Type: uint8
             Source: "caller_index"
          FunctionCall
             Type: uint8
             Source: "index_or_throw(self, msg.sender)"
            Identifier index_or_throw
               Type: function (struct NettingChannelLibrary.Data storage pointer,address) returns (uint8)
               Source: "index_or_throw"
            Identifier self
               Type: struct NettingChannelLibrary.Data storage pointer
               Source: "self"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "require(self.closing_address != msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "require(self.closing_address != msg.sender)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "self.closing_address != msg.sender"
            MemberAccess to member closing_address
               Type: address
               Source: "self.closing_address"
              Identifier self
                 Type: struct NettingChannelLibrary.Data storage pointer
                 Source: "self"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "transfer_address = recoverAddressFromSignature(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature \r\n        )"
        Assignment using operator =
           Type: address
           Source: "transfer_address = recoverAddressFromSignature(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature \r\n        )"
          Identifier transfer_address
             Type: address
             Source: "transfer_address"
          FunctionCall
             Type: address
             Source: "recoverAddressFromSignature(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature \r\n        )"
            Identifier recoverAddressFromSignature
               Type: function (uint64,uint256,bytes32,bytes32,bytes memory) view returns (address)
               Source: "recoverAddressFromSignature"
            Identifier nonce
               Type: uint64
               Source: "nonce"
            Identifier transferred_amount
               Type: uint256
               Source: "transferred_amount"
            Identifier locksroot
               Type: bytes32
               Source: "locksroot"
            Identifier extra_hash
               Type: bytes32
               Source: "extra_hash"
            Identifier signature
               Type: bytes memory
               Source: "signature"
      ExpressionStatement
         Gas costs: 0
         Source: "require(transfer_address == self.closing_address)"
        FunctionCall
           Type: tuple()
           Source: "require(transfer_address == self.closing_address)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "transfer_address == self.closing_address"
            Identifier transfer_address
               Type: address
               Source: "transfer_address"
            MemberAccess to member closing_address
               Type: address
               Source: "self.closing_address"
              Identifier self
                 Type: struct NettingChannelLibrary.Data storage pointer
                 Source: "self"
      ExpressionStatement
         Gas costs: 0
         Source: "closer_index = 1 - caller_index"
        Assignment using operator =
           Type: uint8
           Source: "closer_index = 1 - caller_index"
          Identifier closer_index
             Type: uint8
             Source: "closer_index"
          BinaryOperation using operator -
             Type: uint8
             Source: "1 - caller_index"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
            Identifier caller_index
               Type: uint8
               Source: "caller_index"
      ExpressionStatement
         Gas costs: 0
         Source: "self.participants[closer_index].nonce = nonce"
        Assignment using operator =
           Type: uint64
           Source: "self.participants[closer_index].nonce = nonce"
          MemberAccess to member nonce
             Type: uint64
             Source: "self.participants[closer_index].nonce"
            IndexAccess
               Type: struct NettingChannelLibrary.Participant storage ref
               Source: "self.participants[closer_index]"
              MemberAccess to member participants
                 Type: struct NettingChannelLibrary.Participant storage ref[2] storage ref
                 Source: "self.participants"
                Identifier self
                   Type: struct NettingChannelLibrary.Data storage pointer
                   Source: "self"
              Identifier closer_index
                 Type: uint8
                 Source: "closer_index"
          Identifier nonce
             Type: uint64
             Source: "nonce"
      ExpressionStatement
         Gas costs: 0
         Source: "self.participants[closer_index].locksroot = locksroot"
        Assignment using operator =
           Type: bytes32
           Source: "self.participants[closer_index].locksroot = locksroot"
          MemberAccess to member locksroot
             Type: bytes32
             Source: "self.participants[closer_index].locksroot"
            IndexAccess
               Type: struct NettingChannelLibrary.Participant storage ref
               Source: "self.participants[closer_index]"
              MemberAccess to member participants
                 Type: struct NettingChannelLibrary.Participant storage ref[2] storage ref
                 Source: "self.participants"
                Identifier self
                   Type: struct NettingChannelLibrary.Data storage pointer
                   Source: "self"
              Identifier closer_index
                 Type: uint8
                 Source: "closer_index"
          Identifier locksroot
             Type: bytes32
             Source: "locksroot"
      ExpressionStatement
         Gas costs: 0
         Source: "self.participants[closer_index].transferred_amount = transferred_amount"
        Assignment using operator =
           Type: uint256
           Source: "self.participants[closer_index].transferred_amount = transferred_amount"
          MemberAccess to member transferred_amount
             Type: uint256
             Source: "self.participants[closer_index].transferred_amount"
            IndexAccess
               Type: struct NettingChannelLibrary.Participant storage ref
               Source: "self.participants[closer_index]"
              MemberAccess to member participants
                 Type: struct NettingChannelLibrary.Participant storage ref[2] storage ref
                 Source: "self.participants"
                Identifier self
                   Type: struct NettingChannelLibrary.Data storage pointer
                   Source: "self"
              Identifier closer_index
                 Type: uint8
                 Source: "closer_index"
          Identifier transferred_amount
             Type: uint256
             Source: "transferred_amount"
  FunctionDefinition "recoverAddressFromSignature" - const
     Source: "function recoverAddressFromSignature(\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    )\r\n        constant internal returns (address)\r\n    {\r\n        bytes32 signed_hash;\r\n\r\n        require(signature.length == 65);\r\n\r\n        signed_hash = sha3(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            this,\r\n            extra_hash\r\n        );\r\n\r\n        var (r, s, v) = signatureSplit(signature);\r\n        return ecrecover(signed_hash, v, r, s);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    )"
      VariableDeclaration "nonce"
         Type: uint64
         Source: "uint64 nonce"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "transferred_amount"
         Type: uint256
         Source: "uint256 transferred_amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "locksroot"
         Type: bytes32
         Source: "bytes32 locksroot"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "extra_hash"
         Type: bytes32
         Source: "bytes32 extra_hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "signature"
         Type: bytes memory
         Source: "bytes signature"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        bytes32 signed_hash;\r\n\r\n        require(signature.length == 65);\r\n\r\n        signed_hash = sha3(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            this,\r\n            extra_hash\r\n        );\r\n\r\n        var (r, s, v) = signatureSplit(signature);\r\n        return ecrecover(signed_hash, v, r, s);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 signed_hash"
        VariableDeclaration "signed_hash"
           Type: bytes32
           Source: "bytes32 signed_hash"
          ElementaryTypeName bytes32
             Source: "bytes32"
      ExpressionStatement
         Gas costs: 0
         Source: "require(signature.length == 65)"
        FunctionCall
           Type: tuple()
           Source: "require(signature.length == 65)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "signature.length == 65"
            MemberAccess to member length
               Type: uint256
               Source: "signature.length"
              Identifier signature
                 Type: bytes memory
                 Source: "signature"
            Literal, token: [no token] value: 65
               Type: int_const 65
               Source: "65"
      ExpressionStatement
         Gas costs: 0
         Source: "signed_hash = sha3(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            this,\r\n            extra_hash\r\n        )"
        Assignment using operator =
           Type: bytes32
           Source: "signed_hash = sha3(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            this,\r\n            extra_hash\r\n        )"
          Identifier signed_hash
             Type: bytes32
             Source: "signed_hash"
          FunctionCall
             Type: bytes32
             Source: "sha3(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            this,\r\n            extra_hash\r\n        )"
            Identifier sha3
               Type: function () pure returns (bytes32)
               Source: "sha3"
            Identifier nonce
               Type: uint64
               Source: "nonce"
            Identifier transferred_amount
               Type: uint256
               Source: "transferred_amount"
            Identifier locksroot
               Type: bytes32
               Source: "locksroot"
            Identifier this
               Type: library NettingChannelLibrary
               Source: "this"
            Identifier extra_hash
               Type: bytes32
               Source: "extra_hash"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "var (r, s, v) = signatureSplit(signature)"
        VariableDeclaration "r"
           Type: bytes32
           Source: "r"
        VariableDeclaration "s"
           Type: bytes32
           Source: "s"
        VariableDeclaration "v"
           Type: uint8
           Source: "v"
        FunctionCall
           Type: tuple(bytes32,bytes32,uint8)
           Source: "signatureSplit(signature)"
          Identifier signatureSplit
             Type: function (bytes memory) returns (bytes32,bytes32,uint8)
             Source: "signatureSplit"
          Identifier signature
             Type: bytes memory
             Source: "signature"
      Return
         Gas costs: 0
         Source: "return ecrecover(signed_hash, v, r, s)"
        FunctionCall
           Type: address
           Source: "ecrecover(signed_hash, v, r, s)"
          Identifier ecrecover
             Type: function (bytes32,uint8,bytes32,bytes32) pure returns (address)
             Source: "ecrecover"
          Identifier signed_hash
             Type: bytes32
             Source: "signed_hash"
          Identifier v
             Type: uint8
             Source: "v"
          Identifier r
             Type: bytes32
             Source: "r"
          Identifier s
             Type: bytes32
             Source: "s"
  FunctionDefinition "withdraw" - public
     Source: "function withdraw(Data storage self, bytes locked_encoded, bytes merkle_proof, bytes32 secret)\r\n        notSettledButClosed(self)\r\n    {\r\n        uint amount;\r\n        uint8 index;\r\n        uint64 expiration;\r\n        bytes32 h;\r\n        bytes32 hashlock;\r\n\r\n        // Check if msg.sender is a participant and select the partner (for\r\n        // third party unlock see #541)\r\n        index = 1 - index_or_throw(self, msg.sender);\r\n        Participant storage counterparty = self.participants[index];\r\n\r\n        // An empty locksroot means there are no pending locks\r\n        require(counterparty.locksroot != 0);\r\n\r\n        (expiration, amount, hashlock) = decodeLock(locked_encoded);\r\n\r\n        // A lock can be withdrawn only once per participant\r\n        require(!counterparty.withdrawn_locks[hashlock]);\r\n\r\n        counterparty.withdrawn_locks[hashlock] = true;\r\n\r\n        // The lock must not have expired, it does not matter how far in the\r\n        // future it would have expired\r\n        require(expiration >= block.number);\r\n        require(hashlock == sha3(secret));\r\n\r\n        h = computeMerkleRoot(locked_encoded, merkle_proof);\r\n\r\n        require(counterparty.locksroot == h);\r\n\r\n        // This implementation allows for each transfer to be set only once, so\r\n        // it's safe to update the transferred_amount in place.\r\n        //\r\n        // Once third parties are allowed to update the counter party transfer\r\n        // (#293, #182) the locksroot may change, if the locksroot change the\r\n        // transferred_amount must be reset and locks must be re-withdrawn, so\r\n        // this is also safe.\r\n        //\r\n        // This may be problematic if an update changes the transferred_amount\r\n        // but not the locksroot, since the locks don't need to be\r\n        // re-withdrawn, the difference in the transferred_amount must be\r\n        // accounted for.\r\n        counterparty.transferred_amount += amount;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Data storage self, bytes locked_encoded, bytes merkle_proof, bytes32 secret)"
      VariableDeclaration "self"
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "Data storage self"
        UserDefinedTypeName "Data"
           Source: "Data"
      VariableDeclaration "locked_encoded"
         Type: bytes memory
         Source: "bytes locked_encoded"
        ElementaryTypeName bytes
           Source: "bytes"
      VariableDeclaration "merkle_proof"
         Type: bytes memory
         Source: "bytes merkle_proof"
        ElementaryTypeName bytes
           Source: "bytes"
      VariableDeclaration "secret"
         Type: bytes32
         Source: "bytes32 secret"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "notSettledButClosed"
       Gas costs: 0
       Source: "notSettledButClosed(self)"
      Identifier notSettledButClosed
         Type: modifier (struct NettingChannelLibrary.Data storage pointer)
         Source: "notSettledButClosed"
      Identifier self
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "self"
    Block
       Source: "{\r\n        uint amount;\r\n        uint8 index;\r\n        uint64 expiration;\r\n        bytes32 h;\r\n        bytes32 hashlock;\r\n\r\n        // Check if msg.sender is a participant and select the partner (for\r\n        // third party unlock see #541)\r\n        index = 1 - index_or_throw(self, msg.sender);\r\n        Participant storage counterparty = self.participants[index];\r\n\r\n        // An empty locksroot means there are no pending locks\r\n        require(counterparty.locksroot != 0);\r\n\r\n        (expiration, amount, hashlock) = decodeLock(locked_encoded);\r\n\r\n        // A lock can be withdrawn only once per participant\r\n        require(!counterparty.withdrawn_locks[hashlock]);\r\n\r\n        counterparty.withdrawn_locks[hashlock] = true;\r\n\r\n        // The lock must not have expired, it does not matter how far in the\r\n        // future it would have expired\r\n        require(expiration >= block.number);\r\n        require(hashlock == sha3(secret));\r\n\r\n        h = computeMerkleRoot(locked_encoded, merkle_proof);\r\n\r\n        require(counterparty.locksroot == h);\r\n\r\n        // This implementation allows for each transfer to be set only once, so\r\n        // it's safe to update the transferred_amount in place.\r\n        //\r\n        // Once third parties are allowed to update the counter party transfer\r\n        // (#293, #182) the locksroot may change, if the locksroot change the\r\n        // transferred_amount must be reset and locks must be re-withdrawn, so\r\n        // this is also safe.\r\n        //\r\n        // This may be problematic if an update changes the transferred_amount\r\n        // but not the locksroot, since the locks don't need to be\r\n        // re-withdrawn, the difference in the transferred_amount must be\r\n        // accounted for.\r\n        counterparty.transferred_amount += amount;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint amount"
        VariableDeclaration "amount"
           Type: uint256
           Source: "uint amount"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint8 index"
        VariableDeclaration "index"
           Type: uint8
           Source: "uint8 index"
          ElementaryTypeName uint8
             Source: "uint8"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint64 expiration"
        VariableDeclaration "expiration"
           Type: uint64
           Source: "uint64 expiration"
          ElementaryTypeName uint64
             Source: "uint64"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 h"
        VariableDeclaration "h"
           Type: bytes32
           Source: "bytes32 h"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 hashlock"
        VariableDeclaration "hashlock"
           Type: bytes32
           Source: "bytes32 hashlock"
          ElementaryTypeName bytes32
             Source: "bytes32"
      ExpressionStatement
         Gas costs: 0
         Source: "index = 1 - index_or_throw(self, msg.sender)"
        Assignment using operator =
           Type: uint8
           Source: "index = 1 - index_or_throw(self, msg.sender)"
          Identifier index
             Type: uint8
             Source: "index"
          BinaryOperation using operator -
             Type: uint8
             Source: "1 - index_or_throw(self, msg.sender)"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
            FunctionCall
               Type: uint8
               Source: "index_or_throw(self, msg.sender)"
              Identifier index_or_throw
                 Type: function (struct NettingChannelLibrary.Data storage pointer,address) returns (uint8)
                 Source: "index_or_throw"
              Identifier self
                 Type: struct NettingChannelLibrary.Data storage pointer
                 Source: "self"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "Participant storage counterparty = self.participants[index]"
        VariableDeclaration "counterparty"
           Type: struct NettingChannelLibrary.Participant storage pointer
           Source: "Participant storage counterparty"
          UserDefinedTypeName "Participant"
             Source: "Participant"
        IndexAccess
           Type: struct NettingChannelLibrary.Participant storage ref
           Source: "self.participants[index]"
          MemberAccess to member participants
             Type: struct NettingChannelLibrary.Participant storage ref[2] storage ref
             Source: "self.participants"
            Identifier self
               Type: struct NettingChannelLibrary.Data storage pointer
               Source: "self"
          Identifier index
             Type: uint8
             Source: "index"
      ExpressionStatement
         Gas costs: 0
         Source: "require(counterparty.locksroot != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(counterparty.locksroot != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "counterparty.locksroot != 0"
            MemberAccess to member locksroot
               Type: bytes32
               Source: "counterparty.locksroot"
              Identifier counterparty
                 Type: struct NettingChannelLibrary.Participant storage pointer
                 Source: "counterparty"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "(expiration, amount, hashlock) = decodeLock(locked_encoded)"
        Assignment using operator =
           Type: tuple()
           Source: "(expiration, amount, hashlock) = decodeLock(locked_encoded)"
          TupleExpression
             Type: tuple(uint64,uint256,bytes32)
             Source: "(expiration, amount, hashlock)"
            Identifier expiration
               Type: uint64
               Source: "expiration"
            Identifier amount
               Type: uint256
               Source: "amount"
            Identifier hashlock
               Type: bytes32
               Source: "hashlock"
          FunctionCall
             Type: tuple(uint64,uint256,bytes32)
             Source: "decodeLock(locked_encoded)"
            Identifier decodeLock
               Type: function (bytes memory) returns (uint64,uint256,bytes32)
               Source: "decodeLock"
            Identifier locked_encoded
               Type: bytes memory
               Source: "locked_encoded"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!counterparty.withdrawn_locks[hashlock])"
        FunctionCall
           Type: tuple()
           Source: "require(!counterparty.withdrawn_locks[hashlock])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!counterparty.withdrawn_locks[hashlock]"
            IndexAccess
               Type: bool
               Source: "counterparty.withdrawn_locks[hashlock]"
              MemberAccess to member withdrawn_locks
                 Type: mapping(bytes32 => bool)
                 Source: "counterparty.withdrawn_locks"
                Identifier counterparty
                   Type: struct NettingChannelLibrary.Participant storage pointer
                   Source: "counterparty"
              Identifier hashlock
                 Type: bytes32
                 Source: "hashlock"
      ExpressionStatement
         Gas costs: 0
         Source: "counterparty.withdrawn_locks[hashlock] = true"
        Assignment using operator =
           Type: bool
           Source: "counterparty.withdrawn_locks[hashlock] = true"
          IndexAccess
             Type: bool
             Source: "counterparty.withdrawn_locks[hashlock]"
            MemberAccess to member withdrawn_locks
               Type: mapping(bytes32 => bool)
               Source: "counterparty.withdrawn_locks"
              Identifier counterparty
                 Type: struct NettingChannelLibrary.Participant storage pointer
                 Source: "counterparty"
            Identifier hashlock
               Type: bytes32
               Source: "hashlock"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "require(expiration >= block.number)"
        FunctionCall
           Type: tuple()
           Source: "require(expiration >= block.number)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "expiration >= block.number"
            Identifier expiration
               Type: uint64
               Source: "expiration"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
      ExpressionStatement
         Gas costs: 0
         Source: "require(hashlock == sha3(secret))"
        FunctionCall
           Type: tuple()
           Source: "require(hashlock == sha3(secret))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "hashlock == sha3(secret)"
            Identifier hashlock
               Type: bytes32
               Source: "hashlock"
            FunctionCall
               Type: bytes32
               Source: "sha3(secret)"
              Identifier sha3
                 Type: function () pure returns (bytes32)
                 Source: "sha3"
              Identifier secret
                 Type: bytes32
                 Source: "secret"
      ExpressionStatement
         Gas costs: 0
         Source: "h = computeMerkleRoot(locked_encoded, merkle_proof)"
        Assignment using operator =
           Type: bytes32
           Source: "h = computeMerkleRoot(locked_encoded, merkle_proof)"
          Identifier h
             Type: bytes32
             Source: "h"
          FunctionCall
             Type: bytes32
             Source: "computeMerkleRoot(locked_encoded, merkle_proof)"
            Identifier computeMerkleRoot
               Type: function (bytes memory,bytes memory) view returns (bytes32)
               Source: "computeMerkleRoot"
            Identifier locked_encoded
               Type: bytes memory
               Source: "locked_encoded"
            Identifier merkle_proof
               Type: bytes memory
               Source: "merkle_proof"
      ExpressionStatement
         Gas costs: 0
         Source: "require(counterparty.locksroot == h)"
        FunctionCall
           Type: tuple()
           Source: "require(counterparty.locksroot == h)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "counterparty.locksroot == h"
            MemberAccess to member locksroot
               Type: bytes32
               Source: "counterparty.locksroot"
              Identifier counterparty
                 Type: struct NettingChannelLibrary.Participant storage pointer
                 Source: "counterparty"
            Identifier h
               Type: bytes32
               Source: "h"
      ExpressionStatement
         Gas costs: 0
         Source: "counterparty.transferred_amount += amount"
        Assignment using operator +=
           Type: uint256
           Source: "counterparty.transferred_amount += amount"
          MemberAccess to member transferred_amount
             Type: uint256
             Source: "counterparty.transferred_amount"
            Identifier counterparty
               Type: struct NettingChannelLibrary.Participant storage pointer
               Source: "counterparty"
          Identifier amount
             Type: uint256
             Source: "amount"
  FunctionDefinition "computeMerkleRoot" - const
     Source: "function computeMerkleRoot(bytes lock, bytes merkle_proof)\r\n        internal\r\n        constant\r\n        returns (bytes32)\r\n    {\r\n        require(merkle_proof.length % 32 == 0);\r\n\r\n        uint i;\r\n        bytes32 h;\r\n        bytes32 el;\r\n\r\n        h = sha3(lock);\r\n        for (i = 32; i <= merkle_proof.length; i += 32) {\r\n            assembly {\r\n                el := mload(add(merkle_proof, i))\r\n            }\r\n\r\n            if (h < el) {\r\n                h = sha3(h, el);\r\n            } else {\r\n                h = sha3(el, h);\r\n            }\r\n        }\r\n\r\n        return h;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes lock, bytes merkle_proof)"
      VariableDeclaration "lock"
         Type: bytes memory
         Source: "bytes lock"
        ElementaryTypeName bytes
           Source: "bytes"
      VariableDeclaration "merkle_proof"
         Type: bytes memory
         Source: "bytes merkle_proof"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: "(bytes32)"
      VariableDeclaration ""
         Type: bytes32
         Source: "bytes32"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        require(merkle_proof.length % 32 == 0);\r\n\r\n        uint i;\r\n        bytes32 h;\r\n        bytes32 el;\r\n\r\n        h = sha3(lock);\r\n        for (i = 32; i <= merkle_proof.length; i += 32) {\r\n            assembly {\r\n                el := mload(add(merkle_proof, i))\r\n            }\r\n\r\n            if (h < el) {\r\n                h = sha3(h, el);\r\n            } else {\r\n                h = sha3(el, h);\r\n            }\r\n        }\r\n\r\n        return h;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(merkle_proof.length % 32 == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(merkle_proof.length % 32 == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "merkle_proof.length % 32 == 0"
            BinaryOperation using operator %
               Type: uint256
               Source: "merkle_proof.length % 32"
              MemberAccess to member length
                 Type: uint256
                 Source: "merkle_proof.length"
                Identifier merkle_proof
                   Type: bytes memory
                   Source: "merkle_proof"
              Literal, token: [no token] value: 32
                 Type: int_const 32
                 Source: "32"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint i"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint i"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 h"
        VariableDeclaration "h"
           Type: bytes32
           Source: "bytes32 h"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 el"
        VariableDeclaration "el"
           Type: bytes32
           Source: "bytes32 el"
          ElementaryTypeName bytes32
             Source: "bytes32"
      ExpressionStatement
         Gas costs: 0
         Source: "h = sha3(lock)"
        Assignment using operator =
           Type: bytes32
           Source: "h = sha3(lock)"
          Identifier h
             Type: bytes32
             Source: "h"
          FunctionCall
             Type: bytes32
             Source: "sha3(lock)"
            Identifier sha3
               Type: function () pure returns (bytes32)
               Source: "sha3"
            Identifier lock
               Type: bytes memory
               Source: "lock"
      ForStatement
         Source: "for (i = 32; i <= merkle_proof.length; i += 32) {\r\n            assembly {\r\n                el := mload(add(merkle_proof, i))\r\n            }\r\n\r\n            if (h < el) {\r\n                h = sha3(h, el);\r\n            } else {\r\n                h = sha3(el, h);\r\n            }\r\n        }"
        ExpressionStatement
           Gas costs: 0
           Source: "i = 32"
          Assignment using operator =
             Type: uint256
             Source: "i = 32"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 32
               Type: int_const 32
               Source: "32"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 0
           Source: "i <= merkle_proof.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "merkle_proof.length"
            Identifier merkle_proof
               Type: bytes memory
               Source: "merkle_proof"
        ExpressionStatement
           Gas costs: 0
           Source: "i += 32"
          Assignment using operator +=
             Type: uint256
             Source: "i += 32"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 32
               Type: int_const 32
               Source: "32"
        Block
           Source: "{\r\n            assembly {\r\n                el := mload(add(merkle_proof, i))\r\n            }\r\n\r\n            if (h < el) {\r\n                h = sha3(h, el);\r\n            } else {\r\n                h = sha3(el, h);\r\n            }\r\n        }"
          InlineAssembly
             Gas costs: 0
             Source: "assembly {\r\n                el := mload(add(merkle_proof, i))\r\n            }\r\n\r\n            if"
          IfStatement
             Source: "if (h < el) {\r\n                h = sha3(h, el);\r\n            } else {\r\n                h = sha3(el, h);\r\n            }"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 0
               Source: "h < el"
              Identifier h
                 Type: bytes32
                 Source: "h"
              Identifier el
                 Type: bytes32
                 Source: "el"
            Block
               Source: "{\r\n                h = sha3(h, el);\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "h = sha3(h, el)"
                Assignment using operator =
                   Type: bytes32
                   Source: "h = sha3(h, el)"
                  Identifier h
                     Type: bytes32
                     Source: "h"
                  FunctionCall
                     Type: bytes32
                     Source: "sha3(h, el)"
                    Identifier sha3
                       Type: function () pure returns (bytes32)
                       Source: "sha3"
                    Identifier h
                       Type: bytes32
                       Source: "h"
                    Identifier el
                       Type: bytes32
                       Source: "el"
            Block
               Source: "{\r\n                h = sha3(el, h);\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "h = sha3(el, h)"
                Assignment using operator =
                   Type: bytes32
                   Source: "h = sha3(el, h)"
                  Identifier h
                     Type: bytes32
                     Source: "h"
                  FunctionCall
                     Type: bytes32
                     Source: "sha3(el, h)"
                    Identifier sha3
                       Type: function () pure returns (bytes32)
                       Source: "sha3"
                    Identifier el
                       Type: bytes32
                       Source: "el"
                    Identifier h
                       Type: bytes32
                       Source: "h"
      Return
         Gas costs: 0
         Source: "return h"
        Identifier h
           Type: bytes32
           Source: "h"
  FunctionDefinition "settle" - public
     Source: "function settle(Data storage self)\r\n        notSettledButClosed(self)\r\n        timeoutOver(self)\r\n    {\r\n        uint8 closing_index;\r\n        uint8 counter_index;\r\n        uint256 total_deposit;\r\n        uint256 counter_net;\r\n        uint256 closer_amount;\r\n        uint256 counter_amount;\r\n\r\n        self.settled = block.number;\r\n\r\n        closing_index = index_or_throw(self, self.closing_address);\r\n        counter_index = 1 - closing_index;\r\n\r\n        Participant storage closing_party = self.participants[closing_index];\r\n        Participant storage counter_party = self.participants[counter_index];\r\n\r\n        counter_net = (\r\n            counter_party.balance\r\n            + closing_party.transferred_amount\r\n            - counter_party.transferred_amount\r\n        );\r\n\r\n        // Direct token transfers done through the token `transfer` function\r\n        // cannot be accounted for, these superfluous tokens will be burned,\r\n        // this is because there is no way to tell which participant (if any)\r\n        // had ownership over the token.\r\n        total_deposit = closing_party.balance + counter_party.balance;\r\n\r\n        // When the closing party does not provide the counter party transfer,\r\n        // the `counter_net` may be larger than the `total_deposit`, without\r\n        // the min the token transfer fail and the token is locked.\r\n        counter_amount = min(counter_net, total_deposit);\r\n\r\n        // When the counter party does not provide the closing party transfer,\r\n        // then `counter_amount` may be negative and the transfer fails, force\r\n        // the value to 0.\r\n        counter_amount = max(counter_amount, 0);\r\n\r\n        // At this point `counter_amount` is between [0,total_deposit], so this\r\n        // is safe.\r\n        closer_amount = total_deposit - counter_amount;\r\n\r\n        if (counter_amount > 0) {\r\n            require(self.token.transfer(counter_party.node_address, counter_amount));\r\n        }\r\n\r\n        if (closer_amount > 0) {\r\n            require(self.token.transfer(closing_party.node_address, closer_amount));\r\n        }\r\n\r\n        kill(self);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Data storage self)"
      VariableDeclaration "self"
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "Data storage self"
        UserDefinedTypeName "Data"
           Source: "Data"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "notSettledButClosed"
       Gas costs: 0
       Source: "notSettledButClosed(self)"
      Identifier notSettledButClosed
         Type: modifier (struct NettingChannelLibrary.Data storage pointer)
         Source: "notSettledButClosed"
      Identifier self
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "self"
    ModifierInvocation "timeoutOver"
       Gas costs: 0
       Source: "timeoutOver(self)"
      Identifier timeoutOver
         Type: modifier (struct NettingChannelLibrary.Data storage pointer)
         Source: "timeoutOver"
      Identifier self
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "self"
    Block
       Source: "{\r\n        uint8 closing_index;\r\n        uint8 counter_index;\r\n        uint256 total_deposit;\r\n        uint256 counter_net;\r\n        uint256 closer_amount;\r\n        uint256 counter_amount;\r\n\r\n        self.settled = block.number;\r\n\r\n        closing_index = index_or_throw(self, self.closing_address);\r\n        counter_index = 1 - closing_index;\r\n\r\n        Participant storage closing_party = self.participants[closing_index];\r\n        Participant storage counter_party = self.participants[counter_index];\r\n\r\n        counter_net = (\r\n            counter_party.balance\r\n            + closing_party.transferred_amount\r\n            - counter_party.transferred_amount\r\n        );\r\n\r\n        // Direct token transfers done through the token `transfer` function\r\n        // cannot be accounted for, these superfluous tokens will be burned,\r\n        // this is because there is no way to tell which participant (if any)\r\n        // had ownership over the token.\r\n        total_deposit = closing_party.balance + counter_party.balance;\r\n\r\n        // When the closing party does not provide the counter party transfer,\r\n        // the `counter_net` may be larger than the `total_deposit`, without\r\n        // the min the token transfer fail and the token is locked.\r\n        counter_amount = min(counter_net, total_deposit);\r\n\r\n        // When the counter party does not provide the closing party transfer,\r\n        // then `counter_amount` may be negative and the transfer fails, force\r\n        // the value to 0.\r\n        counter_amount = max(counter_amount, 0);\r\n\r\n        // At this point `counter_amount` is between [0,total_deposit], so this\r\n        // is safe.\r\n        closer_amount = total_deposit - counter_amount;\r\n\r\n        if (counter_amount > 0) {\r\n            require(self.token.transfer(counter_party.node_address, counter_amount));\r\n        }\r\n\r\n        if (closer_amount > 0) {\r\n            require(self.token.transfer(closing_party.node_address, closer_amount));\r\n        }\r\n\r\n        kill(self);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint8 closing_index"
        VariableDeclaration "closing_index"
           Type: uint8
           Source: "uint8 closing_index"
          ElementaryTypeName uint8
             Source: "uint8"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint8 counter_index"
        VariableDeclaration "counter_index"
           Type: uint8
           Source: "uint8 counter_index"
          ElementaryTypeName uint8
             Source: "uint8"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 total_deposit"
        VariableDeclaration "total_deposit"
           Type: uint256
           Source: "uint256 total_deposit"
          ElementaryTypeName uint256
             Source: "uint256"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 counter_net"
        VariableDeclaration "counter_net"
           Type: uint256
           Source: "uint256 counter_net"
          ElementaryTypeName uint256
             Source: "uint256"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 closer_amount"
        VariableDeclaration "closer_amount"
           Type: uint256
           Source: "uint256 closer_amount"
          ElementaryTypeName uint256
             Source: "uint256"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 counter_amount"
        VariableDeclaration "counter_amount"
           Type: uint256
           Source: "uint256 counter_amount"
          ElementaryTypeName uint256
             Source: "uint256"
      ExpressionStatement
         Gas costs: 0
         Source: "self.settled = block.number"
        Assignment using operator =
           Type: uint256
           Source: "self.settled = block.number"
          MemberAccess to member settled
             Type: uint256
             Source: "self.settled"
            Identifier self
               Type: struct NettingChannelLibrary.Data storage pointer
               Source: "self"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
      ExpressionStatement
         Gas costs: 0
         Source: "closing_index = index_or_throw(self, self.closing_address)"
        Assignment using operator =
           Type: uint8
           Source: "closing_index = index_or_throw(self, self.closing_address)"
          Identifier closing_index
             Type: uint8
             Source: "closing_index"
          FunctionCall
             Type: uint8
             Source: "index_or_throw(self, self.closing_address)"
            Identifier index_or_throw
               Type: function (struct NettingChannelLibrary.Data storage pointer,address) returns (uint8)
               Source: "index_or_throw"
            Identifier self
               Type: struct NettingChannelLibrary.Data storage pointer
               Source: "self"
            MemberAccess to member closing_address
               Type: address
               Source: "self.closing_address"
              Identifier self
                 Type: struct NettingChannelLibrary.Data storage pointer
                 Source: "self"
      ExpressionStatement
         Gas costs: 0
         Source: "counter_index = 1 - closing_index"
        Assignment using operator =
           Type: uint8
           Source: "counter_index = 1 - closing_index"
          Identifier counter_index
             Type: uint8
             Source: "counter_index"
          BinaryOperation using operator -
             Type: uint8
             Source: "1 - closing_index"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
            Identifier closing_index
               Type: uint8
               Source: "closing_index"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "Participant storage closing_party = self.participants[closing_index]"
        VariableDeclaration "closing_party"
           Type: struct NettingChannelLibrary.Participant storage pointer
           Source: "Participant storage closing_party"
          UserDefinedTypeName "Participant"
             Source: "Participant"
        IndexAccess
           Type: struct NettingChannelLibrary.Participant storage ref
           Source: "self.participants[closing_index]"
          MemberAccess to member participants
             Type: struct NettingChannelLibrary.Participant storage ref[2] storage ref
             Source: "self.participants"
            Identifier self
               Type: struct NettingChannelLibrary.Data storage pointer
               Source: "self"
          Identifier closing_index
             Type: uint8
             Source: "closing_index"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "Participant storage counter_party = self.participants[counter_index]"
        VariableDeclaration "counter_party"
           Type: struct NettingChannelLibrary.Participant storage pointer
           Source: "Participant storage counter_party"
          UserDefinedTypeName "Participant"
             Source: "Participant"
        IndexAccess
           Type: struct NettingChannelLibrary.Participant storage ref
           Source: "self.participants[counter_index]"
          MemberAccess to member participants
             Type: struct NettingChannelLibrary.Participant storage ref[2] storage ref
             Source: "self.participants"
            Identifier self
               Type: struct NettingChannelLibrary.Data storage pointer
               Source: "self"
          Identifier counter_index
             Type: uint8
             Source: "counter_index"
      ExpressionStatement
         Gas costs: 0
         Source: "counter_net = (\r\n            counter_party.balance\r\n            + closing_party.transferred_amount\r\n            - counter_party.transferred_amount\r\n        )"
        Assignment using operator =
           Type: uint256
           Source: "counter_net = (\r\n            counter_party.balance\r\n            + closing_party.transferred_amount\r\n            - counter_party.transferred_amount\r\n        )"
          Identifier counter_net
             Type: uint256
             Source: "counter_net"
          TupleExpression
             Type: uint256
             Source: "(\r\n            counter_party.balance\r\n            + closing_party.transferred_amount\r\n            - counter_party.transferred_amount\r\n        )"
            BinaryOperation using operator -
               Type: uint256
               Source: "counter_party.balance\r\n            + closing_party.transferred_amount\r\n            - counter_party.transferred_amount"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "counter_party.balance\r\n            + closing_party.transferred_amount"
                MemberAccess to member balance
                   Type: uint256
                   Source: "counter_party.balance"
                  Identifier counter_party
                     Type: struct NettingChannelLibrary.Participant storage pointer
                     Source: "counter_party"
                MemberAccess to member transferred_amount
                   Type: uint256
                   Source: "closing_party.transferred_amount"
                  Identifier closing_party
                     Type: struct NettingChannelLibrary.Participant storage pointer
                     Source: "closing_party"
              MemberAccess to member transferred_amount
                 Type: uint256
                 Source: "counter_party.transferred_amount"
                Identifier counter_party
                   Type: struct NettingChannelLibrary.Participant storage pointer
                   Source: "counter_party"
      ExpressionStatement
         Gas costs: 0
         Source: "total_deposit = closing_party.balance + counter_party.balance"
        Assignment using operator =
           Type: uint256
           Source: "total_deposit = closing_party.balance + counter_party.balance"
          Identifier total_deposit
             Type: uint256
             Source: "total_deposit"
          BinaryOperation using operator +
             Type: uint256
             Source: "closing_party.balance + counter_party.balance"
            MemberAccess to member balance
               Type: uint256
               Source: "closing_party.balance"
              Identifier closing_party
                 Type: struct NettingChannelLibrary.Participant storage pointer
                 Source: "closing_party"
            MemberAccess to member balance
               Type: uint256
               Source: "counter_party.balance"
              Identifier counter_party
                 Type: struct NettingChannelLibrary.Participant storage pointer
                 Source: "counter_party"
      ExpressionStatement
         Gas costs: 0
         Source: "counter_amount = min(counter_net, total_deposit)"
        Assignment using operator =
           Type: uint256
           Source: "counter_amount = min(counter_net, total_deposit)"
          Identifier counter_amount
             Type: uint256
             Source: "counter_amount"
          FunctionCall
             Type: uint256
             Source: "min(counter_net, total_deposit)"
            Identifier min
               Type: function (uint256,uint256) view returns (uint256)
               Source: "min"
            Identifier counter_net
               Type: uint256
               Source: "counter_net"
            Identifier total_deposit
               Type: uint256
               Source: "total_deposit"
      ExpressionStatement
         Gas costs: 0
         Source: "counter_amount = max(counter_amount, 0)"
        Assignment using operator =
           Type: uint256
           Source: "counter_amount = max(counter_amount, 0)"
          Identifier counter_amount
             Type: uint256
             Source: "counter_amount"
          FunctionCall
             Type: uint256
             Source: "max(counter_amount, 0)"
            Identifier max
               Type: function (uint256,uint256) view returns (uint256)
               Source: "max"
            Identifier counter_amount
               Type: uint256
               Source: "counter_amount"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "closer_amount = total_deposit - counter_amount"
        Assignment using operator =
           Type: uint256
           Source: "closer_amount = total_deposit - counter_amount"
          Identifier closer_amount
             Type: uint256
             Source: "closer_amount"
          BinaryOperation using operator -
             Type: uint256
             Source: "total_deposit - counter_amount"
            Identifier total_deposit
               Type: uint256
               Source: "total_deposit"
            Identifier counter_amount
               Type: uint256
               Source: "counter_amount"
      IfStatement
         Source: "if (counter_amount > 0) {\r\n            require(self.token.transfer(counter_party.node_address, counter_amount));\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "counter_amount > 0"
          Identifier counter_amount
             Type: uint256
             Source: "counter_amount"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            require(self.token.transfer(counter_party.node_address, counter_amount));\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require(self.token.transfer(counter_party.node_address, counter_amount))"
            FunctionCall
               Type: tuple()
               Source: "require(self.token.transfer(counter_party.node_address, counter_amount))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "self.token.transfer(counter_party.node_address, counter_amount)"
                MemberAccess to member transfer
                   Type: function (address,uint256) external returns (bool)
                   Source: "self.token.transfer"
                  MemberAccess to member token
                     Type: contract Token
                     Source: "self.token"
                    Identifier self
                       Type: struct NettingChannelLibrary.Data storage pointer
                       Source: "self"
                MemberAccess to member node_address
                   Type: address
                   Source: "counter_party.node_address"
                  Identifier counter_party
                     Type: struct NettingChannelLibrary.Participant storage pointer
                     Source: "counter_party"
                Identifier counter_amount
                   Type: uint256
                   Source: "counter_amount"
      IfStatement
         Source: "if (closer_amount > 0) {\r\n            require(self.token.transfer(closing_party.node_address, closer_amount));\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "closer_amount > 0"
          Identifier closer_amount
             Type: uint256
             Source: "closer_amount"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            require(self.token.transfer(closing_party.node_address, closer_amount));\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require(self.token.transfer(closing_party.node_address, closer_amount))"
            FunctionCall
               Type: tuple()
               Source: "require(self.token.transfer(closing_party.node_address, closer_amount))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "self.token.transfer(closing_party.node_address, closer_amount)"
                MemberAccess to member transfer
                   Type: function (address,uint256) external returns (bool)
                   Source: "self.token.transfer"
                  MemberAccess to member token
                     Type: contract Token
                     Source: "self.token"
                    Identifier self
                       Type: struct NettingChannelLibrary.Data storage pointer
                       Source: "self"
                MemberAccess to member node_address
                   Type: address
                   Source: "closing_party.node_address"
                  Identifier closing_party
                     Type: struct NettingChannelLibrary.Participant storage pointer
                     Source: "closing_party"
                Identifier closer_amount
                   Type: uint256
                   Source: "closer_amount"
      ExpressionStatement
         Gas costs: 0
         Source: "kill(self)"
        FunctionCall
           Type: tuple()
           Source: "kill(self)"
          Identifier kill
             Type: function (struct NettingChannelLibrary.Data storage pointer)
             Source: "kill"
          Identifier self
             Type: struct NettingChannelLibrary.Data storage pointer
             Source: "self"
  FunctionDefinition "decodeLock"
     Source: "function decodeLock(bytes lock) internal returns (uint64 expiration, uint amount, bytes32 hashlock) {\r\n        require(lock.length == 72);\r\n\r\n        // Lock format:\r\n        // [0:8] expiration\r\n        // [8:40] amount\r\n        // [40:72] hashlock\r\n        assembly {\r\n            expiration := mload(add(lock, 8))\r\n            amount := mload(add(lock, 40))\r\n            hashlock := mload(add(lock, 72))\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes lock)"
      VariableDeclaration "lock"
         Type: bytes memory
         Source: "bytes lock"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: "(uint64 expiration, uint amount, bytes32 hashlock)"
      VariableDeclaration "expiration"
         Type: uint64
         Source: "uint64 expiration"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "hashlock"
         Type: bytes32
         Source: "bytes32 hashlock"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        require(lock.length == 72);\r\n\r\n        // Lock format:\r\n        // [0:8] expiration\r\n        // [8:40] amount\r\n        // [40:72] hashlock\r\n        assembly {\r\n            expiration := mload(add(lock, 8))\r\n            amount := mload(add(lock, 40))\r\n            hashlock := mload(add(lock, 72))\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(lock.length == 72)"
        FunctionCall
           Type: tuple()
           Source: "require(lock.length == 72)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "lock.length == 72"
            MemberAccess to member length
               Type: uint256
               Source: "lock.length"
              Identifier lock
                 Type: bytes memory
                 Source: "lock"
            Literal, token: [no token] value: 72
               Type: int_const 72
               Source: "72"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {\r\n            expiration := mload(add(lock, 8))\r\n            amount := mload(add(lock, 40))\r\n            hashlock := mload(add(lock, 72))\r\n        }\r\n    }"
  FunctionDefinition "signatureSplit"
     Source: "function signatureSplit(bytes signature) internal returns (bytes32 r, bytes32 s, uint8 v) {\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            // Here we are loading the last 32 bytes, including 31 bytes\r\n            // of 's'. There is no 'mload8' to do this.\r\n            //\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            v := and(mload(add(signature, 65)), 0xff)\r\n        }\r\n\r\n        require(v == 27 || v == 28);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes signature)"
      VariableDeclaration "signature"
         Type: bytes memory
         Source: "bytes signature"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 r, bytes32 s, uint8 v)"
      VariableDeclaration "r"
         Type: bytes32
         Source: "bytes32 r"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "s"
         Type: bytes32
         Source: "bytes32 s"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "v"
         Type: uint8
         Source: "uint8 v"
        ElementaryTypeName uint8
           Source: "uint8"
    Block
       Source: "{\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            // Here we are loading the last 32 bytes, including 31 bytes\r\n            // of 's'. There is no 'mload8' to do this.\r\n            //\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            v := and(mload(add(signature, 65)), 0xff)\r\n        }\r\n\r\n        require(v == 27 || v == 28);\r\n    }"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            // Here we are loading the last 32 bytes, including 31 bytes\r\n            // of 's'. There is no 'mload8' to do this.\r\n            //\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            v := and(mload(add(signature, 65)), 0xff)\r\n        }\r\n\r\n        require"
      ExpressionStatement
         Gas costs: 0
         Source: "require(v == 27 || v == 28)"
        FunctionCall
           Type: tuple()
           Source: "require(v == 27 || v == 28)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "v == 27 || v == 28"
            BinaryOperation using operator ==
               Type: bool
               Source: "v == 27"
              Identifier v
                 Type: uint8
                 Source: "v"
              Literal, token: [no token] value: 27
                 Type: int_const 27
                 Source: "27"
            BinaryOperation using operator ==
               Type: bool
               Source: "v == 28"
              Identifier v
                 Type: uint8
                 Source: "v"
              Literal, token: [no token] value: 28
                 Type: int_const 28
                 Source: "28"
  FunctionDefinition "index_or_throw"
     Source: "function index_or_throw(Data storage self, address participant_address) private returns (uint8) {\r\n        uint8 n;\r\n        // Return index of participant, or throw\r\n        n = self.participant_index[participant_address];\r\n        assert(n != 0);\r\n        return n - 1;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Data storage self, address participant_address)"
      VariableDeclaration "self"
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "Data storage self"
        UserDefinedTypeName "Data"
           Source: "Data"
      VariableDeclaration "participant_address"
         Type: address
         Source: "address participant_address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint8)"
      VariableDeclaration ""
         Type: uint8
         Source: "uint8"
        ElementaryTypeName uint8
           Source: "uint8"
    Block
       Source: "{\r\n        uint8 n;\r\n        // Return index of participant, or throw\r\n        n = self.participant_index[participant_address];\r\n        assert(n != 0);\r\n        return n - 1;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint8 n"
        VariableDeclaration "n"
           Type: uint8
           Source: "uint8 n"
          ElementaryTypeName uint8
             Source: "uint8"
      ExpressionStatement
         Gas costs: 0
         Source: "n = self.participant_index[participant_address]"
        Assignment using operator =
           Type: uint8
           Source: "n = self.participant_index[participant_address]"
          Identifier n
             Type: uint8
             Source: "n"
          IndexAccess
             Type: uint8
             Source: "self.participant_index[participant_address]"
            MemberAccess to member participant_index
               Type: mapping(address => uint8)
               Source: "self.participant_index"
              Identifier self
                 Type: struct NettingChannelLibrary.Data storage pointer
                 Source: "self"
            Identifier participant_address
               Type: address
               Source: "participant_address"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(n != 0)"
        FunctionCall
           Type: tuple()
           Source: "assert(n != 0)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator !=
             Type: bool
             Source: "n != 0"
            Identifier n
               Type: uint8
               Source: "n"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      Return
         Gas costs: 0
         Source: "return n - 1"
        BinaryOperation using operator -
           Type: uint8
           Source: "n - 1"
          Identifier n
             Type: uint8
             Source: "n"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
  FunctionDefinition "min" - const
     Source: "function min(uint a, uint b) constant internal returns (uint) {\r\n        return a > b ? b : a;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return a > b ? b : a;\r\n    }"
      Return
         Gas costs: 0
         Source: "return a > b ? b : a"
        Conditional
           Type: uint256
           Source: "a > b ? b : a"
          BinaryOperation using operator >
             Type: bool
             Source: "a > b"
            Identifier a
               Type: uint256
               Source: "a"
            Identifier b
               Type: uint256
               Source: "b"
          Identifier b
             Type: uint256
             Source: "b"
          Identifier a
             Type: uint256
             Source: "a"
  FunctionDefinition "max" - const
     Source: "function max(uint a, uint b) constant internal returns (uint) {\r\n        return a > b ? a : b;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return a > b ? a : b;\r\n    }"
      Return
         Gas costs: 0
         Source: "return a > b ? a : b"
        Conditional
           Type: uint256
           Source: "a > b ? a : b"
          BinaryOperation using operator >
             Type: bool
             Source: "a > b"
            Identifier a
               Type: uint256
               Source: "a"
            Identifier b
               Type: uint256
               Source: "b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "kill" - public
     Source: "function kill(Data storage self) channelSettled(self) {\r\n        selfdestruct(0x00000000000000000000);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Data storage self)"
      VariableDeclaration "self"
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "Data storage self"
        UserDefinedTypeName "Data"
           Source: "Data"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "channelSettled"
       Gas costs: 0
       Source: "channelSettled(self)"
      Identifier channelSettled
         Type: modifier (struct NettingChannelLibrary.Data storage pointer)
         Source: "channelSettled"
      Identifier self
         Type: struct NettingChannelLibrary.Data storage pointer
         Source: "self"
    Block
       Source: "{\r\n        selfdestruct(0x00000000000000000000);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "selfdestruct(0x00000000000000000000)"
        FunctionCall
           Type: tuple()
           Source: "selfdestruct(0x00000000000000000000)"
          Identifier selfdestruct
             Type: function (address)
             Source: "selfdestruct"
          Literal, token: [no token] value: 0x00000000000000000000
             Type: int_const 0
             Source: "0x00000000000000000000"
ContractDefinition "NettingChannelContract"
   Source: "contract NettingChannelContract {\r\n    string constant public contract_version = \"0.1._\";\r\n\r\n    using NettingChannelLibrary for NettingChannelLibrary.Data;\r\n    NettingChannelLibrary.Data public data;\r\n\r\n    event ChannelNewBalance(address token_address, address participant, uint balance, uint block_number);\r\n    event ChannelClosed(address closing_address, uint block_number);\r\n    event TransferUpdated(address node_address, uint block_number);\r\n    event ChannelSettled(uint block_number);\r\n    event ChannelSecretRevealed(bytes32 secret, address receiver_address);\r\n\r\n    modifier settleTimeoutNotTooLow(uint t) {\r\n        assert(t >= 6);\r\n        _;\r\n    }\r\n\r\n    function NettingChannelContract(\r\n        address token_address,\r\n        address participant1,\r\n        address participant2,\r\n        uint timeout)\r\n        settleTimeoutNotTooLow(timeout)\r\n    {\r\n        require(participant1 != participant2);\r\n\r\n        data.participants[0].node_address = participant1;\r\n        data.participants[1].node_address = participant2;\r\n        data.participant_index[participant1] = 1;\r\n        data.participant_index[participant2] = 2;\r\n\r\n        data.token = Token(token_address);\r\n        data.settle_timeout = timeout;\r\n        data.opened = block.number;\r\n    }\r\n\r\n    /// @notice Caller makes a deposit into their channel balance.\r\n    /// @param amount The amount caller wants to deposit.\r\n    /// @return True if deposit is successful.\r\n    function deposit(uint256 amount) returns (bool) {\r\n        bool success;\r\n        uint256 balance;\r\n\r\n        (success, balance) = data.deposit(amount);\r\n\r\n        if (success == true) {\r\n            ChannelNewBalance(data.token, msg.sender, balance, block.number);\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    /// @notice Get the address and balance of both partners in a channel.\r\n    /// @return The address and balance pairs.\r\n    function addressAndBalance()\r\n        constant\r\n        returns (\r\n        address participant1,\r\n        uint balance1,\r\n        address participant2,\r\n        uint balance2)\r\n    {\r\n        NettingChannelLibrary.Participant storage node1 = data.participants[0];\r\n        NettingChannelLibrary.Participant storage node2 = data.participants[1];\r\n\r\n        participant1 = node1.node_address;\r\n        balance1 = node1.balance;\r\n        participant2 = node2.node_address;\r\n        balance2 = node2.balance;\r\n    }\r\n\r\n    /// @notice Close the channel. Can only be called by a participant in the channel.\r\n    function close(\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    ) {\r\n        data.close(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature\r\n        );\r\n        ChannelClosed(msg.sender, data.closed);\r\n    }\r\n\r\n    /// @notice Dispute the state after closing, called by the counterparty (the\r\n    ///         participant who did not close the channel).\r\n    function updateTransfer(\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    ) {\r\n        data.updateTransfer(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature\r\n        );\r\n        TransferUpdated(msg.sender, block.number);\r\n    }\r\n\r\n    /// @notice Unlock a locked transfer.\r\n    /// @param locked_encoded The locked transfer to be unlocked.\r\n    /// @param merkle_proof The merke_proof for the locked transfer.\r\n    /// @param secret The secret to unlock the locked transfer.\r\n    function withdraw(bytes locked_encoded, bytes merkle_proof, bytes32 secret) {\r\n        // throws if sender is not a participant\r\n        data.withdraw(locked_encoded, merkle_proof, secret);\r\n        ChannelSecretRevealed(secret, msg.sender);\r\n    }\r\n\r\n    /// @notice Settle the transfers and balances of the channel and pay out to\r\n    ///         each participant. Can only be called after the channel is closed\r\n    ///         and only after the number of blocks in the settlement timeout\r\n    ///         have passed.\r\n    function settle() {\r\n        data.settle();\r\n        ChannelSettled(data.settled);\r\n    }\r\n\r\n    /// @notice Returns the number of blocks until the settlement timeout.\r\n    /// @return The number of blocks until the settlement timeout.\r\n    function settleTimeout() constant returns (uint) {\r\n        return data.settle_timeout;\r\n    }\r\n\r\n    /// @notice Returns the address of the token.\r\n    /// @return The address of the token.\r\n    function tokenAddress() constant returns (address) {\r\n        return data.token;\r\n    }\r\n\r\n    /// @notice Returns the block number for when the channel was opened.\r\n    /// @return The block number for when the channel was opened.\r\n    function opened() constant returns (uint) {\r\n        return data.opened;\r\n    }\r\n\r\n    /// @notice Returns the block number for when the channel was closed.\r\n    /// @return The block number for when the channel was closed.\r\n    function closed() constant returns (uint) {\r\n        return data.closed;\r\n    }\r\n\r\n    /// @notice Returns the block number for when the channel was settled.\r\n    /// @return The block number for when the channel was settled.\r\n    function settled() constant returns (uint) {\r\n        return data.settled;\r\n    }\r\n\r\n    /// @notice Returns the address of the closing participant.\r\n    /// @return The address of the closing participant.\r\n    function closingAddress() constant returns (address) {\r\n        return data.closing_address;\r\n    }\r\n\r\n    function () { revert(); }\r\n}"
  VariableDeclaration "contract_version"
     Type: string memory
     Gas costs: 0
     Source: "string constant public contract_version = \"0.1._\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: 0.1._
       Type: literal_string "0.1._"
       Source: "\"0.1._\""
  UsingForDirective
     Gas costs: 0
     Source: "using NettingChannelLibrary for NettingChannelLibrary.Data;"
    UserDefinedTypeName "NettingChannelLibrary"
       Source: "NettingChannelLibrary"
    UserDefinedTypeName "NettingChannelLibrary.Data"
       Source: "NettingChannelLibrary.Data"
  VariableDeclaration "data"
     Type: struct NettingChannelLibrary.Data storage ref
     Gas costs: 0
     Source: "NettingChannelLibrary.Data public data"
    UserDefinedTypeName "NettingChannelLibrary.Data"
       Source: "NettingChannelLibrary.Data"
  EventDefinition "ChannelNewBalance"
     Gas costs: 0
     Source: "event ChannelNewBalance(address token_address, address participant, uint balance, uint block_number);"
    ParameterList
       Source: "(address token_address, address participant, uint balance, uint block_number)"
      VariableDeclaration "token_address"
         Type: address
         Source: "address token_address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "participant"
         Type: address
         Source: "address participant"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint balance"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "block_number"
         Type: uint256
         Source: "uint block_number"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "ChannelClosed"
     Gas costs: 0
     Source: "event ChannelClosed(address closing_address, uint block_number);"
    ParameterList
       Source: "(address closing_address, uint block_number)"
      VariableDeclaration "closing_address"
         Type: address
         Source: "address closing_address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "block_number"
         Type: uint256
         Source: "uint block_number"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "TransferUpdated"
     Gas costs: 0
     Source: "event TransferUpdated(address node_address, uint block_number);"
    ParameterList
       Source: "(address node_address, uint block_number)"
      VariableDeclaration "node_address"
         Type: address
         Source: "address node_address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "block_number"
         Type: uint256
         Source: "uint block_number"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "ChannelSettled"
     Gas costs: 0
     Source: "event ChannelSettled(uint block_number);"
    ParameterList
       Source: "(uint block_number)"
      VariableDeclaration "block_number"
         Type: uint256
         Source: "uint block_number"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "ChannelSecretRevealed"
     Gas costs: 0
     Source: "event ChannelSecretRevealed(bytes32 secret, address receiver_address);"
    ParameterList
       Source: "(bytes32 secret, address receiver_address)"
      VariableDeclaration "secret"
         Type: bytes32
         Source: "bytes32 secret"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "receiver_address"
         Type: address
         Source: "address receiver_address"
        ElementaryTypeName address
           Source: "address"
  ModifierDefinition "settleTimeoutNotTooLow"
     Source: "modifier settleTimeoutNotTooLow(uint t) {\r\n        assert(t >= 6);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint t)"
      VariableDeclaration "t"
         Type: uint256
         Source: "uint t"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        assert(t >= 6);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(t >= 6)"
        FunctionCall
           Type: tuple()
           Source: "assert(t >= 6)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "t >= 6"
            Identifier t
               Type: uint256
               Source: "t"
            Literal, token: [no token] value: 6
               Type: int_const 6
               Source: "6"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "NettingChannelContract" - public
     Source: "function NettingChannelContract(\r\n        address token_address,\r\n        address participant1,\r\n        address participant2,\r\n        uint timeout)\r\n        settleTimeoutNotTooLow(timeout)\r\n    {\r\n        require(participant1 != participant2);\r\n\r\n        data.participants[0].node_address = participant1;\r\n        data.participants[1].node_address = participant2;\r\n        data.participant_index[participant1] = 1;\r\n        data.participant_index[participant2] = 2;\r\n\r\n        data.token = Token(token_address);\r\n        data.settle_timeout = timeout;\r\n        data.opened = block.number;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address token_address,\r\n        address participant1,\r\n        address participant2,\r\n        uint timeout)"
      VariableDeclaration "token_address"
         Type: address
         Source: "address token_address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "participant1"
         Type: address
         Source: "address participant1"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "participant2"
         Type: address
         Source: "address participant2"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "timeout"
         Type: uint256
         Source: "uint timeout"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "settleTimeoutNotTooLow"
       Gas costs: 0
       Source: "settleTimeoutNotTooLow(timeout)"
      Identifier settleTimeoutNotTooLow
         Type: modifier (uint256)
         Source: "settleTimeoutNotTooLow"
      Identifier timeout
         Type: uint256
         Source: "timeout"
    Block
       Source: "{\r\n        require(participant1 != participant2);\r\n\r\n        data.participants[0].node_address = participant1;\r\n        data.participants[1].node_address = participant2;\r\n        data.participant_index[participant1] = 1;\r\n        data.participant_index[participant2] = 2;\r\n\r\n        data.token = Token(token_address);\r\n        data.settle_timeout = timeout;\r\n        data.opened = block.number;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(participant1 != participant2)"
        FunctionCall
           Type: tuple()
           Source: "require(participant1 != participant2)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "participant1 != participant2"
            Identifier participant1
               Type: address
               Source: "participant1"
            Identifier participant2
               Type: address
               Source: "participant2"
      ExpressionStatement
         Gas costs: 0
         Source: "data.participants[0].node_address = participant1"
        Assignment using operator =
           Type: address
           Source: "data.participants[0].node_address = participant1"
          MemberAccess to member node_address
             Type: address
             Source: "data.participants[0].node_address"
            IndexAccess
               Type: struct NettingChannelLibrary.Participant storage ref
               Source: "data.participants[0]"
              MemberAccess to member participants
                 Type: struct NettingChannelLibrary.Participant storage ref[2] storage ref
                 Source: "data.participants"
                Identifier data
                   Type: struct NettingChannelLibrary.Data storage ref
                   Source: "data"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Identifier participant1
             Type: address
             Source: "participant1"
      ExpressionStatement
         Gas costs: 0
         Source: "data.participants[1].node_address = participant2"
        Assignment using operator =
           Type: address
           Source: "data.participants[1].node_address = participant2"
          MemberAccess to member node_address
             Type: address
             Source: "data.participants[1].node_address"
            IndexAccess
               Type: struct NettingChannelLibrary.Participant storage ref
               Source: "data.participants[1]"
              MemberAccess to member participants
                 Type: struct NettingChannelLibrary.Participant storage ref[2] storage ref
                 Source: "data.participants"
                Identifier data
                   Type: struct NettingChannelLibrary.Data storage ref
                   Source: "data"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          Identifier participant2
             Type: address
             Source: "participant2"
      ExpressionStatement
         Gas costs: 0
         Source: "data.participant_index[participant1] = 1"
        Assignment using operator =
           Type: uint8
           Source: "data.participant_index[participant1] = 1"
          IndexAccess
             Type: uint8
             Source: "data.participant_index[participant1]"
            MemberAccess to member participant_index
               Type: mapping(address => uint8)
               Source: "data.participant_index"
              Identifier data
                 Type: struct NettingChannelLibrary.Data storage ref
                 Source: "data"
            Identifier participant1
               Type: address
               Source: "participant1"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "data.participant_index[participant2] = 2"
        Assignment using operator =
           Type: uint8
           Source: "data.participant_index[participant2] = 2"
          IndexAccess
             Type: uint8
             Source: "data.participant_index[participant2]"
            MemberAccess to member participant_index
               Type: mapping(address => uint8)
               Source: "data.participant_index"
              Identifier data
                 Type: struct NettingChannelLibrary.Data storage ref
                 Source: "data"
            Identifier participant2
               Type: address
               Source: "participant2"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
      ExpressionStatement
         Gas costs: 0
         Source: "data.token = Token(token_address)"
        Assignment using operator =
           Type: contract Token
           Source: "data.token = Token(token_address)"
          MemberAccess to member token
             Type: contract Token
             Source: "data.token"
            Identifier data
               Type: struct NettingChannelLibrary.Data storage ref
               Source: "data"
          FunctionCall
             Type: contract Token
             Source: "Token(token_address)"
            Identifier Token
               Type: type(contract Token)
               Source: "Token"
            Identifier token_address
               Type: address
               Source: "token_address"
      ExpressionStatement
         Gas costs: 0
         Source: "data.settle_timeout = timeout"
        Assignment using operator =
           Type: uint256
           Source: "data.settle_timeout = timeout"
          MemberAccess to member settle_timeout
             Type: uint256
             Source: "data.settle_timeout"
            Identifier data
               Type: struct NettingChannelLibrary.Data storage ref
               Source: "data"
          Identifier timeout
             Type: uint256
             Source: "timeout"
      ExpressionStatement
         Gas costs: 0
         Source: "data.opened = block.number"
        Assignment using operator =
           Type: uint256
           Source: "data.opened = block.number"
          MemberAccess to member opened
             Type: uint256
             Source: "data.opened"
            Identifier data
               Type: struct NettingChannelLibrary.Data storage ref
               Source: "data"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
  FunctionDefinition "deposit" - public
     Source: "function deposit(uint256 amount) returns (bool) {\r\n        bool success;\r\n        uint256 balance;\r\n\r\n        (success, balance) = data.deposit(amount);\r\n\r\n        if (success == true) {\r\n            ChannelNewBalance(data.token, msg.sender, balance, block.number);\r\n        }\r\n\r\n        return success;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        bool success;\r\n        uint256 balance;\r\n\r\n        (success, balance) = data.deposit(amount);\r\n\r\n        if (success == true) {\r\n            ChannelNewBalance(data.token, msg.sender, balance, block.number);\r\n        }\r\n\r\n        return success;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bool success"
        VariableDeclaration "success"
           Type: bool
           Source: "bool success"
          ElementaryTypeName bool
             Source: "bool"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 balance"
        VariableDeclaration "balance"
           Type: uint256
           Source: "uint256 balance"
          ElementaryTypeName uint256
             Source: "uint256"
      ExpressionStatement
         Gas costs: 0
         Source: "(success, balance) = data.deposit(amount)"
        Assignment using operator =
           Type: tuple()
           Source: "(success, balance) = data.deposit(amount)"
          TupleExpression
             Type: tuple(bool,uint256)
             Source: "(success, balance)"
            Identifier success
               Type: bool
               Source: "success"
            Identifier balance
               Type: uint256
               Source: "balance"
          FunctionCall
             Type: tuple(bool,uint256)
             Source: "data.deposit(amount)"
            MemberAccess to member deposit
               Type: function (struct NettingChannelLibrary.Data storage pointer,uint256) returns (bool,uint256)
               Source: "data.deposit"
              Identifier data
                 Type: struct NettingChannelLibrary.Data storage ref
                 Source: "data"
            Identifier amount
               Type: uint256
               Source: "amount"
      IfStatement
         Source: "if (success == true) {\r\n            ChannelNewBalance(data.token, msg.sender, balance, block.number);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "success == true"
          Identifier success
             Type: bool
             Source: "success"
          Literal, token: true value: true
             Type: bool
             Source: "true"
        Block
           Source: "{\r\n            ChannelNewBalance(data.token, msg.sender, balance, block.number);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "ChannelNewBalance(data.token, msg.sender, balance, block.number)"
            FunctionCall
               Type: tuple()
               Source: "ChannelNewBalance(data.token, msg.sender, balance, block.number)"
              Identifier ChannelNewBalance
                 Type: function (address,address,uint256,uint256)
                 Source: "ChannelNewBalance"
              MemberAccess to member token
                 Type: contract Token
                 Source: "data.token"
                Identifier data
                   Type: struct NettingChannelLibrary.Data storage ref
                   Source: "data"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier balance
                 Type: uint256
                 Source: "balance"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
      Return
         Gas costs: 0
         Source: "return success"
        Identifier success
           Type: bool
           Source: "success"
  FunctionDefinition "addressAndBalance" - public - const
     Source: "function addressAndBalance()\r\n        constant\r\n        returns (\r\n        address participant1,\r\n        uint balance1,\r\n        address participant2,\r\n        uint balance2)\r\n    {\r\n        NettingChannelLibrary.Participant storage node1 = data.participants[0];\r\n        NettingChannelLibrary.Participant storage node2 = data.participants[1];\r\n\r\n        participant1 = node1.node_address;\r\n        balance1 = node1.balance;\r\n        participant2 = node2.node_address;\r\n        balance2 = node2.balance;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address participant1,\r\n        uint balance1,\r\n        address participant2,\r\n        uint balance2)"
      VariableDeclaration "participant1"
         Type: address
         Source: "address participant1"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "balance1"
         Type: uint256
         Source: "uint balance1"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "participant2"
         Type: address
         Source: "address participant2"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "balance2"
         Type: uint256
         Source: "uint balance2"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        NettingChannelLibrary.Participant storage node1 = data.participants[0];\r\n        NettingChannelLibrary.Participant storage node2 = data.participants[1];\r\n\r\n        participant1 = node1.node_address;\r\n        balance1 = node1.balance;\r\n        participant2 = node2.node_address;\r\n        balance2 = node2.balance;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "NettingChannelLibrary.Participant storage node1 = data.participants[0]"
        VariableDeclaration "node1"
           Type: struct NettingChannelLibrary.Participant storage pointer
           Source: "NettingChannelLibrary.Participant storage node1"
          UserDefinedTypeName "NettingChannelLibrary.Participant"
             Source: "NettingChannelLibrary.Participant"
        IndexAccess
           Type: struct NettingChannelLibrary.Participant storage ref
           Source: "data.participants[0]"
          MemberAccess to member participants
             Type: struct NettingChannelLibrary.Participant storage ref[2] storage ref
             Source: "data.participants"
            Identifier data
               Type: struct NettingChannelLibrary.Data storage ref
               Source: "data"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "NettingChannelLibrary.Participant storage node2 = data.participants[1]"
        VariableDeclaration "node2"
           Type: struct NettingChannelLibrary.Participant storage pointer
           Source: "NettingChannelLibrary.Participant storage node2"
          UserDefinedTypeName "NettingChannelLibrary.Participant"
             Source: "NettingChannelLibrary.Participant"
        IndexAccess
           Type: struct NettingChannelLibrary.Participant storage ref
           Source: "data.participants[1]"
          MemberAccess to member participants
             Type: struct NettingChannelLibrary.Participant storage ref[2] storage ref
             Source: "data.participants"
            Identifier data
               Type: struct NettingChannelLibrary.Data storage ref
               Source: "data"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "participant1 = node1.node_address"
        Assignment using operator =
           Type: address
           Source: "participant1 = node1.node_address"
          Identifier participant1
             Type: address
             Source: "participant1"
          MemberAccess to member node_address
             Type: address
             Source: "node1.node_address"
            Identifier node1
               Type: struct NettingChannelLibrary.Participant storage pointer
               Source: "node1"
      ExpressionStatement
         Gas costs: 0
         Source: "balance1 = node1.balance"
        Assignment using operator =
           Type: uint256
           Source: "balance1 = node1.balance"
          Identifier balance1
             Type: uint256
             Source: "balance1"
          MemberAccess to member balance
             Type: uint256
             Source: "node1.balance"
            Identifier node1
               Type: struct NettingChannelLibrary.Participant storage pointer
               Source: "node1"
      ExpressionStatement
         Gas costs: 0
         Source: "participant2 = node2.node_address"
        Assignment using operator =
           Type: address
           Source: "participant2 = node2.node_address"
          Identifier participant2
             Type: address
             Source: "participant2"
          MemberAccess to member node_address
             Type: address
             Source: "node2.node_address"
            Identifier node2
               Type: struct NettingChannelLibrary.Participant storage pointer
               Source: "node2"
      ExpressionStatement
         Gas costs: 0
         Source: "balance2 = node2.balance"
        Assignment using operator =
           Type: uint256
           Source: "balance2 = node2.balance"
          Identifier balance2
             Type: uint256
             Source: "balance2"
          MemberAccess to member balance
             Type: uint256
             Source: "node2.balance"
            Identifier node2
               Type: struct NettingChannelLibrary.Participant storage pointer
               Source: "node2"
  FunctionDefinition "close" - public
     Source: "function close(\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    ) {\r\n        data.close(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature\r\n        );\r\n        ChannelClosed(msg.sender, data.closed);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    )"
      VariableDeclaration "nonce"
         Type: uint64
         Source: "uint64 nonce"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "transferred_amount"
         Type: uint256
         Source: "uint256 transferred_amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "locksroot"
         Type: bytes32
         Source: "bytes32 locksroot"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "extra_hash"
         Type: bytes32
         Source: "bytes32 extra_hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "signature"
         Type: bytes memory
         Source: "bytes signature"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        data.close(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature\r\n        );\r\n        ChannelClosed(msg.sender, data.closed);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "data.close(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "data.close(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature\r\n        )"
          MemberAccess to member close
             Type: function (struct NettingChannelLibrary.Data storage pointer,uint64,uint256,bytes32,bytes32,bytes memory)
             Source: "data.close"
            Identifier data
               Type: struct NettingChannelLibrary.Data storage ref
               Source: "data"
          Identifier nonce
             Type: uint64
             Source: "nonce"
          Identifier transferred_amount
             Type: uint256
             Source: "transferred_amount"
          Identifier locksroot
             Type: bytes32
             Source: "locksroot"
          Identifier extra_hash
             Type: bytes32
             Source: "extra_hash"
          Identifier signature
             Type: bytes memory
             Source: "signature"
      ExpressionStatement
         Gas costs: 0
         Source: "ChannelClosed(msg.sender, data.closed)"
        FunctionCall
           Type: tuple()
           Source: "ChannelClosed(msg.sender, data.closed)"
          Identifier ChannelClosed
             Type: function (address,uint256)
             Source: "ChannelClosed"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          MemberAccess to member closed
             Type: uint256
             Source: "data.closed"
            Identifier data
               Type: struct NettingChannelLibrary.Data storage ref
               Source: "data"
  FunctionDefinition "updateTransfer" - public
     Source: "function updateTransfer(\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    ) {\r\n        data.updateTransfer(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature\r\n        );\r\n        TransferUpdated(msg.sender, block.number);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    )"
      VariableDeclaration "nonce"
         Type: uint64
         Source: "uint64 nonce"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "transferred_amount"
         Type: uint256
         Source: "uint256 transferred_amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "locksroot"
         Type: bytes32
         Source: "bytes32 locksroot"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "extra_hash"
         Type: bytes32
         Source: "bytes32 extra_hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "signature"
         Type: bytes memory
         Source: "bytes signature"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        data.updateTransfer(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature\r\n        );\r\n        TransferUpdated(msg.sender, block.number);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "data.updateTransfer(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "data.updateTransfer(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature\r\n        )"
          MemberAccess to member updateTransfer
             Type: function (struct NettingChannelLibrary.Data storage pointer,uint64,uint256,bytes32,bytes32,bytes memory)
             Source: "data.updateTransfer"
            Identifier data
               Type: struct NettingChannelLibrary.Data storage ref
               Source: "data"
          Identifier nonce
             Type: uint64
             Source: "nonce"
          Identifier transferred_amount
             Type: uint256
             Source: "transferred_amount"
          Identifier locksroot
             Type: bytes32
             Source: "locksroot"
          Identifier extra_hash
             Type: bytes32
             Source: "extra_hash"
          Identifier signature
             Type: bytes memory
             Source: "signature"
      ExpressionStatement
         Gas costs: 0
         Source: "TransferUpdated(msg.sender, block.number)"
        FunctionCall
           Type: tuple()
           Source: "TransferUpdated(msg.sender, block.number)"
          Identifier TransferUpdated
             Type: function (address,uint256)
             Source: "TransferUpdated"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
  FunctionDefinition "withdraw" - public
     Source: "function withdraw(bytes locked_encoded, bytes merkle_proof, bytes32 secret) {\r\n        // throws if sender is not a participant\r\n        data.withdraw(locked_encoded, merkle_proof, secret);\r\n        ChannelSecretRevealed(secret, msg.sender);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes locked_encoded, bytes merkle_proof, bytes32 secret)"
      VariableDeclaration "locked_encoded"
         Type: bytes memory
         Source: "bytes locked_encoded"
        ElementaryTypeName bytes
           Source: "bytes"
      VariableDeclaration "merkle_proof"
         Type: bytes memory
         Source: "bytes merkle_proof"
        ElementaryTypeName bytes
           Source: "bytes"
      VariableDeclaration "secret"
         Type: bytes32
         Source: "bytes32 secret"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        // throws if sender is not a participant\r\n        data.withdraw(locked_encoded, merkle_proof, secret);\r\n        ChannelSecretRevealed(secret, msg.sender);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "data.withdraw(locked_encoded, merkle_proof, secret)"
        FunctionCall
           Type: tuple()
           Source: "data.withdraw(locked_encoded, merkle_proof, secret)"
          MemberAccess to member withdraw
             Type: function (struct NettingChannelLibrary.Data storage pointer,bytes memory,bytes memory,bytes32)
             Source: "data.withdraw"
            Identifier data
               Type: struct NettingChannelLibrary.Data storage ref
               Source: "data"
          Identifier locked_encoded
             Type: bytes memory
             Source: "locked_encoded"
          Identifier merkle_proof
             Type: bytes memory
             Source: "merkle_proof"
          Identifier secret
             Type: bytes32
             Source: "secret"
      ExpressionStatement
         Gas costs: 0
         Source: "ChannelSecretRevealed(secret, msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "ChannelSecretRevealed(secret, msg.sender)"
          Identifier ChannelSecretRevealed
             Type: function (bytes32,address)
             Source: "ChannelSecretRevealed"
          Identifier secret
             Type: bytes32
             Source: "secret"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "settle" - public
     Source: "function settle() {\r\n        data.settle();\r\n        ChannelSettled(data.settled);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        data.settle();\r\n        ChannelSettled(data.settled);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "data.settle()"
        FunctionCall
           Type: tuple()
           Source: "data.settle()"
          MemberAccess to member settle
             Type: function (struct NettingChannelLibrary.Data storage pointer)
             Source: "data.settle"
            Identifier data
               Type: struct NettingChannelLibrary.Data storage ref
               Source: "data"
      ExpressionStatement
         Gas costs: 0
         Source: "ChannelSettled(data.settled)"
        FunctionCall
           Type: tuple()
           Source: "ChannelSettled(data.settled)"
          Identifier ChannelSettled
             Type: function (uint256)
             Source: "ChannelSettled"
          MemberAccess to member settled
             Type: uint256
             Source: "data.settled"
            Identifier data
               Type: struct NettingChannelLibrary.Data storage ref
               Source: "data"
  FunctionDefinition "settleTimeout" - public - const
     Source: "function settleTimeout() constant returns (uint) {\r\n        return data.settle_timeout;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return data.settle_timeout;\r\n    }"
      Return
         Gas costs: 0
         Source: "return data.settle_timeout"
        MemberAccess to member settle_timeout
           Type: uint256
           Source: "data.settle_timeout"
          Identifier data
             Type: struct NettingChannelLibrary.Data storage ref
             Source: "data"
  FunctionDefinition "tokenAddress" - public - const
     Source: "function tokenAddress() constant returns (address) {\r\n        return data.token;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return data.token;\r\n    }"
      Return
         Gas costs: 0
         Source: "return data.token"
        MemberAccess to member token
           Type: contract Token
           Source: "data.token"
          Identifier data
             Type: struct NettingChannelLibrary.Data storage ref
             Source: "data"
  FunctionDefinition "opened" - public - const
     Source: "function opened() constant returns (uint) {\r\n        return data.opened;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return data.opened;\r\n    }"
      Return
         Gas costs: 0
         Source: "return data.opened"
        MemberAccess to member opened
           Type: uint256
           Source: "data.opened"
          Identifier data
             Type: struct NettingChannelLibrary.Data storage ref
             Source: "data"
  FunctionDefinition "closed" - public - const
     Source: "function closed() constant returns (uint) {\r\n        return data.closed;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return data.closed;\r\n    }"
      Return
         Gas costs: 0
         Source: "return data.closed"
        MemberAccess to member closed
           Type: uint256
           Source: "data.closed"
          Identifier data
             Type: struct NettingChannelLibrary.Data storage ref
             Source: "data"
  FunctionDefinition "settled" - public - const
     Source: "function settled() constant returns (uint) {\r\n        return data.settled;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return data.settled;\r\n    }"
      Return
         Gas costs: 0
         Source: "return data.settled"
        MemberAccess to member settled
           Type: uint256
           Source: "data.settled"
          Identifier data
             Type: struct NettingChannelLibrary.Data storage ref
             Source: "data"
  FunctionDefinition "closingAddress" - public - const
     Source: "function closingAddress() constant returns (address) {\r\n        return data.closing_address;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return data.closing_address;\r\n    }"
      Return
         Gas costs: 0
         Source: "return data.closing_address"
        MemberAccess to member closing_address
           Type: address
           Source: "data.closing_address"
          Identifier data
             Type: struct NettingChannelLibrary.Data storage ref
             Source: "data"
  FunctionDefinition "" - public
     Source: "function () { revert(); }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ revert(); }"
      ExpressionStatement
         Gas costs: 0
         Source: "revert()"
        FunctionCall
           Type: tuple()
           Source: "revert()"
          Identifier revert
             Type: function () pure
             Source: "revert"
ContractDefinition "ChannelManagerLibrary"
   Source: "library ChannelManagerLibrary {\r\n    string constant public contract_version = \"0.1._\";\r\n\r\n    struct Data {\r\n        Token token;\r\n\r\n        address[] all_channels;\r\n        mapping(bytes32 => uint) partyhash_to_channelpos;\r\n\r\n        mapping(address => address[]) nodeaddress_to_channeladdresses;\r\n        mapping(address => mapping(address => uint)) node_index;\r\n    }\r\n\r\n    /// @notice Get the address of channel with a partner\r\n    /// @param partner The address of the partner\r\n    /// @return The address of the channel\r\n    function getChannelWith(Data storage self, address partner) constant returns (address) {\r\n        bytes32 party_hash = partyHash(msg.sender, partner);\r\n        uint channel_pos = self.partyhash_to_channelpos[party_hash];\r\n\r\n        if (channel_pos != 0) {\r\n            return self.all_channels[channel_pos - 1];\r\n        }\r\n    }\r\n\r\n    /// @notice Create a new payment channel between two parties\r\n    /// @param partner The address of the partner\r\n    /// @param settle_timeout The settle timeout in blocks\r\n    /// @return The address of the newly created NettingChannelContract.\r\n    function newChannel(Data storage self, address partner, uint settle_timeout)\r\n        returns (address)\r\n    {\r\n        address[] storage caller_channels = self.nodeaddress_to_channeladdresses[msg.sender];\r\n        address[] storage partner_channels = self.nodeaddress_to_channeladdresses[partner];\r\n\r\n        bytes32 party_hash = partyHash(msg.sender, partner);\r\n        uint channel_pos = self.partyhash_to_channelpos[party_hash];\r\n\r\n        address new_channel_address = new NettingChannelContract(\r\n            self.token,\r\n            msg.sender,\r\n            partner,\r\n            settle_timeout\r\n        );\r\n\r\n        if (channel_pos != 0) {\r\n            // Check if the channel was settled. Once a channel is settled it\r\n            // kills itself, so address must not have code.\r\n            address settled_channel = self.all_channels[channel_pos - 1];\r\n            require(!contractExists(settled_channel));\r\n\r\n            uint caller_pos = self.node_index[msg.sender][partner];\r\n            uint partner_pos = self.node_index[partner][msg.sender];\r\n\r\n            // replace the channel address in-place\r\n            self.all_channels[channel_pos - 1] = new_channel_address;\r\n            caller_channels[caller_pos - 1] = new_channel_address;\r\n            partner_channels[partner_pos - 1] = new_channel_address;\r\n\r\n        } else {\r\n            self.all_channels.push(new_channel_address);\r\n            caller_channels.push(new_channel_address);\r\n            partner_channels.push(new_channel_address);\r\n\r\n            // using the 1-index, 0 is used for the absence of a value\r\n            self.partyhash_to_channelpos[party_hash] = self.all_channels.length;\r\n            self.node_index[msg.sender][partner] = caller_channels.length;\r\n            self.node_index[partner][msg.sender] = partner_channels.length;\r\n        }\r\n\r\n        return new_channel_address;\r\n    }\r\n\r\n    /// @notice Get the hash of the two addresses\r\n    /// @param address_one address of one party\r\n    /// @param address_two of the other party\r\n    /// @return The sha3 hash of both parties sorted by size of address\r\n    function partyHash(address address_one, address address_two) internal constant returns (bytes32) {\r\n        if (address_one < address_two) {\r\n            return sha3(address_one, address_two);\r\n        } else {\r\n            // The two participants can't be the same here due to this check in\r\n            // the netting channel constructor:\r\n            // https://github.com/raiden-network/raiden/blob/e17d96db375d31b134ae7b4e2ad2c1f905b47857/raiden/smart_contracts/NettingChannelContract.sol#L27\r\n            return sha3(address_two, address_one);\r\n        }\r\n    }\r\n\r\n    /// TODO: Find a way to remove this function duplication from Utils.sol here\r\n    ///       At the moment libraries can't inherit so we need to add this here\r\n    ///       explicitly.\r\n    /// @notice Check if a contract exists\r\n    /// @param channel The address to check whether a contract is deployed or not\r\n    /// @return True if a contract exists, false otherwise\r\n    function contractExists(address channel) private constant returns (bool) {\r\n        uint size;\r\n\r\n        assembly {\r\n            size := extcodesize(channel)\r\n        }\r\n\r\n        return size > 0;\r\n    }\r\n}"
  VariableDeclaration "contract_version"
     Type: string memory
     Gas costs: 0
     Source: "string constant public contract_version = \"0.1._\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: 0.1._
       Type: literal_string "0.1._"
       Source: "\"0.1._\""
  StructDefinition "Data"
     Gas costs: 0
     Source: "struct Data {\r\n        Token token;\r\n\r\n        address[] all_channels;\r\n        mapping(bytes32 => uint) partyhash_to_channelpos;\r\n\r\n        mapping(address => address[]) nodeaddress_to_channeladdresses;\r\n        mapping(address => mapping(address => uint)) node_index;\r\n    }"
    VariableDeclaration "token"
       Type: contract Token
       Source: "Token token"
      UserDefinedTypeName "Token"
         Source: "Token"
    VariableDeclaration "all_channels"
       Type: address[] storage pointer
       Source: "address[] all_channels"
      ArrayTypeName
         Source: "address[]"
        ElementaryTypeName address
           Source: "address"
    VariableDeclaration "partyhash_to_channelpos"
       Type: mapping(bytes32 => uint256)
       Source: "mapping(bytes32 => uint) partyhash_to_channelpos"
      Mapping
         Source: "mapping(bytes32 => uint)"
        ElementaryTypeName bytes32
           Source: "bytes32"
        ElementaryTypeName uint
           Source: "uint"
    VariableDeclaration "nodeaddress_to_channeladdresses"
       Type: mapping(address => address[] storage ref)
       Source: "mapping(address => address[]) nodeaddress_to_channeladdresses"
      Mapping
         Source: "mapping(address => address[])"
        ElementaryTypeName address
           Source: "address"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    VariableDeclaration "node_index"
       Type: mapping(address => mapping(address => uint256))
       Source: "mapping(address => mapping(address => uint)) node_index"
      Mapping
         Source: "mapping(address => mapping(address => uint))"
        ElementaryTypeName address
           Source: "address"
        Mapping
           Source: "mapping(address => uint)"
          ElementaryTypeName address
             Source: "address"
          ElementaryTypeName uint
             Source: "uint"
  FunctionDefinition "getChannelWith" - public - const
     Source: "function getChannelWith(Data storage self, address partner) constant returns (address) {\r\n        bytes32 party_hash = partyHash(msg.sender, partner);\r\n        uint channel_pos = self.partyhash_to_channelpos[party_hash];\r\n\r\n        if (channel_pos != 0) {\r\n            return self.all_channels[channel_pos - 1];\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Data storage self, address partner)"
      VariableDeclaration "self"
         Type: struct ChannelManagerLibrary.Data storage pointer
         Source: "Data storage self"
        UserDefinedTypeName "Data"
           Source: "Data"
      VariableDeclaration "partner"
         Type: address
         Source: "address partner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        bytes32 party_hash = partyHash(msg.sender, partner);\r\n        uint channel_pos = self.partyhash_to_channelpos[party_hash];\r\n\r\n        if (channel_pos != 0) {\r\n            return self.all_channels[channel_pos - 1];\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 party_hash = partyHash(msg.sender, partner)"
        VariableDeclaration "party_hash"
           Type: bytes32
           Source: "bytes32 party_hash"
          ElementaryTypeName bytes32
             Source: "bytes32"
        FunctionCall
           Type: bytes32
           Source: "partyHash(msg.sender, partner)"
          Identifier partyHash
             Type: function (address,address) view returns (bytes32)
             Source: "partyHash"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier partner
             Type: address
             Source: "partner"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint channel_pos = self.partyhash_to_channelpos[party_hash]"
        VariableDeclaration "channel_pos"
           Type: uint256
           Source: "uint channel_pos"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "self.partyhash_to_channelpos[party_hash]"
          MemberAccess to member partyhash_to_channelpos
             Type: mapping(bytes32 => uint256)
             Source: "self.partyhash_to_channelpos"
            Identifier self
               Type: struct ChannelManagerLibrary.Data storage pointer
               Source: "self"
          Identifier party_hash
             Type: bytes32
             Source: "party_hash"
      IfStatement
         Source: "if (channel_pos != 0) {\r\n            return self.all_channels[channel_pos - 1];\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "channel_pos != 0"
          Identifier channel_pos
             Type: uint256
             Source: "channel_pos"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            return self.all_channels[channel_pos - 1];\r\n        }"
          Return
             Gas costs: 0
             Source: "return self.all_channels[channel_pos - 1]"
            IndexAccess
               Type: address
               Source: "self.all_channels[channel_pos - 1]"
              MemberAccess to member all_channels
                 Type: address[] storage ref
                 Source: "self.all_channels"
                Identifier self
                   Type: struct ChannelManagerLibrary.Data storage pointer
                   Source: "self"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "channel_pos - 1"
                Identifier channel_pos
                   Type: uint256
                   Source: "channel_pos"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
  FunctionDefinition "newChannel" - public
     Source: "function newChannel(Data storage self, address partner, uint settle_timeout)\r\n        returns (address)\r\n    {\r\n        address[] storage caller_channels = self.nodeaddress_to_channeladdresses[msg.sender];\r\n        address[] storage partner_channels = self.nodeaddress_to_channeladdresses[partner];\r\n\r\n        bytes32 party_hash = partyHash(msg.sender, partner);\r\n        uint channel_pos = self.partyhash_to_channelpos[party_hash];\r\n\r\n        address new_channel_address = new NettingChannelContract(\r\n            self.token,\r\n            msg.sender,\r\n            partner,\r\n            settle_timeout\r\n        );\r\n\r\n        if (channel_pos != 0) {\r\n            // Check if the channel was settled. Once a channel is settled it\r\n            // kills itself, so address must not have code.\r\n            address settled_channel = self.all_channels[channel_pos - 1];\r\n            require(!contractExists(settled_channel));\r\n\r\n            uint caller_pos = self.node_index[msg.sender][partner];\r\n            uint partner_pos = self.node_index[partner][msg.sender];\r\n\r\n            // replace the channel address in-place\r\n            self.all_channels[channel_pos - 1] = new_channel_address;\r\n            caller_channels[caller_pos - 1] = new_channel_address;\r\n            partner_channels[partner_pos - 1] = new_channel_address;\r\n\r\n        } else {\r\n            self.all_channels.push(new_channel_address);\r\n            caller_channels.push(new_channel_address);\r\n            partner_channels.push(new_channel_address);\r\n\r\n            // using the 1-index, 0 is used for the absence of a value\r\n            self.partyhash_to_channelpos[party_hash] = self.all_channels.length;\r\n            self.node_index[msg.sender][partner] = caller_channels.length;\r\n            self.node_index[partner][msg.sender] = partner_channels.length;\r\n        }\r\n\r\n        return new_channel_address;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Data storage self, address partner, uint settle_timeout)"
      VariableDeclaration "self"
         Type: struct ChannelManagerLibrary.Data storage pointer
         Source: "Data storage self"
        UserDefinedTypeName "Data"
           Source: "Data"
      VariableDeclaration "partner"
         Type: address
         Source: "address partner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "settle_timeout"
         Type: uint256
         Source: "uint settle_timeout"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        address[] storage caller_channels = self.nodeaddress_to_channeladdresses[msg.sender];\r\n        address[] storage partner_channels = self.nodeaddress_to_channeladdresses[partner];\r\n\r\n        bytes32 party_hash = partyHash(msg.sender, partner);\r\n        uint channel_pos = self.partyhash_to_channelpos[party_hash];\r\n\r\n        address new_channel_address = new NettingChannelContract(\r\n            self.token,\r\n            msg.sender,\r\n            partner,\r\n            settle_timeout\r\n        );\r\n\r\n        if (channel_pos != 0) {\r\n            // Check if the channel was settled. Once a channel is settled it\r\n            // kills itself, so address must not have code.\r\n            address settled_channel = self.all_channels[channel_pos - 1];\r\n            require(!contractExists(settled_channel));\r\n\r\n            uint caller_pos = self.node_index[msg.sender][partner];\r\n            uint partner_pos = self.node_index[partner][msg.sender];\r\n\r\n            // replace the channel address in-place\r\n            self.all_channels[channel_pos - 1] = new_channel_address;\r\n            caller_channels[caller_pos - 1] = new_channel_address;\r\n            partner_channels[partner_pos - 1] = new_channel_address;\r\n\r\n        } else {\r\n            self.all_channels.push(new_channel_address);\r\n            caller_channels.push(new_channel_address);\r\n            partner_channels.push(new_channel_address);\r\n\r\n            // using the 1-index, 0 is used for the absence of a value\r\n            self.partyhash_to_channelpos[party_hash] = self.all_channels.length;\r\n            self.node_index[msg.sender][partner] = caller_channels.length;\r\n            self.node_index[partner][msg.sender] = partner_channels.length;\r\n        }\r\n\r\n        return new_channel_address;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "address[] storage caller_channels = self.nodeaddress_to_channeladdresses[msg.sender]"
        VariableDeclaration "caller_channels"
           Type: address[] storage pointer
           Source: "address[] storage caller_channels"
          ArrayTypeName
             Source: "address[]"
            ElementaryTypeName address
               Source: "address"
        IndexAccess
           Type: address[] storage ref
           Source: "self.nodeaddress_to_channeladdresses[msg.sender]"
          MemberAccess to member nodeaddress_to_channeladdresses
             Type: mapping(address => address[] storage ref)
             Source: "self.nodeaddress_to_channeladdresses"
            Identifier self
               Type: struct ChannelManagerLibrary.Data storage pointer
               Source: "self"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "address[] storage partner_channels = self.nodeaddress_to_channeladdresses[partner]"
        VariableDeclaration "partner_channels"
           Type: address[] storage pointer
           Source: "address[] storage partner_channels"
          ArrayTypeName
             Source: "address[]"
            ElementaryTypeName address
               Source: "address"
        IndexAccess
           Type: address[] storage ref
           Source: "self.nodeaddress_to_channeladdresses[partner]"
          MemberAccess to member nodeaddress_to_channeladdresses
             Type: mapping(address => address[] storage ref)
             Source: "self.nodeaddress_to_channeladdresses"
            Identifier self
               Type: struct ChannelManagerLibrary.Data storage pointer
               Source: "self"
          Identifier partner
             Type: address
             Source: "partner"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 party_hash = partyHash(msg.sender, partner)"
        VariableDeclaration "party_hash"
           Type: bytes32
           Source: "bytes32 party_hash"
          ElementaryTypeName bytes32
             Source: "bytes32"
        FunctionCall
           Type: bytes32
           Source: "partyHash(msg.sender, partner)"
          Identifier partyHash
             Type: function (address,address) view returns (bytes32)
             Source: "partyHash"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier partner
             Type: address
             Source: "partner"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint channel_pos = self.partyhash_to_channelpos[party_hash]"
        VariableDeclaration "channel_pos"
           Type: uint256
           Source: "uint channel_pos"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "self.partyhash_to_channelpos[party_hash]"
          MemberAccess to member partyhash_to_channelpos
             Type: mapping(bytes32 => uint256)
             Source: "self.partyhash_to_channelpos"
            Identifier self
               Type: struct ChannelManagerLibrary.Data storage pointer
               Source: "self"
          Identifier party_hash
             Type: bytes32
             Source: "party_hash"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "address new_channel_address = new NettingChannelContract(\r\n            self.token,\r\n            msg.sender,\r\n            partner,\r\n            settle_timeout\r\n        )"
        VariableDeclaration "new_channel_address"
           Type: address
           Source: "address new_channel_address"
          ElementaryTypeName address
             Source: "address"
        FunctionCall
           Type: contract NettingChannelContract
           Source: "new NettingChannelContract(\r\n            self.token,\r\n            msg.sender,\r\n            partner,\r\n            settle_timeout\r\n        )"
          NewExpression
             Type: function (address,address,address,uint256) returns (contract NettingChannelContract)
             Source: "new NettingChannelContract"
            UserDefinedTypeName "NettingChannelContract"
               Source: "NettingChannelContract"
          MemberAccess to member token
             Type: contract Token
             Source: "self.token"
            Identifier self
               Type: struct ChannelManagerLibrary.Data storage pointer
               Source: "self"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier partner
             Type: address
             Source: "partner"
          Identifier settle_timeout
             Type: uint256
             Source: "settle_timeout"
      IfStatement
         Source: "if (channel_pos != 0) {\r\n            // Check if the channel was settled. Once a channel is settled it\r\n            // kills itself, so address must not have code.\r\n            address settled_channel = self.all_channels[channel_pos - 1];\r\n            require(!contractExists(settled_channel));\r\n\r\n            uint caller_pos = self.node_index[msg.sender][partner];\r\n            uint partner_pos = self.node_index[partner][msg.sender];\r\n\r\n            // replace the channel address in-place\r\n            self.all_channels[channel_pos - 1] = new_channel_address;\r\n            caller_channels[caller_pos - 1] = new_channel_address;\r\n            partner_channels[partner_pos - 1] = new_channel_address;\r\n\r\n        } else {\r\n            self.all_channels.push(new_channel_address);\r\n            caller_channels.push(new_channel_address);\r\n            partner_channels.push(new_channel_address);\r\n\r\n            // using the 1-index, 0 is used for the absence of a value\r\n            self.partyhash_to_channelpos[party_hash] = self.all_channels.length;\r\n            self.node_index[msg.sender][partner] = caller_channels.length;\r\n            self.node_index[partner][msg.sender] = partner_channels.length;\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "channel_pos != 0"
          Identifier channel_pos
             Type: uint256
             Source: "channel_pos"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            // Check if the channel was settled. Once a channel is settled it\r\n            // kills itself, so address must not have code.\r\n            address settled_channel = self.all_channels[channel_pos - 1];\r\n            require(!contractExists(settled_channel));\r\n\r\n            uint caller_pos = self.node_index[msg.sender][partner];\r\n            uint partner_pos = self.node_index[partner][msg.sender];\r\n\r\n            // replace the channel address in-place\r\n            self.all_channels[channel_pos - 1] = new_channel_address;\r\n            caller_channels[caller_pos - 1] = new_channel_address;\r\n            partner_channels[partner_pos - 1] = new_channel_address;\r\n\r\n        }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "address settled_channel = self.all_channels[channel_pos - 1]"
            VariableDeclaration "settled_channel"
               Type: address
               Source: "address settled_channel"
              ElementaryTypeName address
                 Source: "address"
            IndexAccess
               Type: address
               Source: "self.all_channels[channel_pos - 1]"
              MemberAccess to member all_channels
                 Type: address[] storage ref
                 Source: "self.all_channels"
                Identifier self
                   Type: struct ChannelManagerLibrary.Data storage pointer
                   Source: "self"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "channel_pos - 1"
                Identifier channel_pos
                   Type: uint256
                   Source: "channel_pos"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
          ExpressionStatement
             Gas costs: 0
             Source: "require(!contractExists(settled_channel))"
            FunctionCall
               Type: tuple()
               Source: "require(!contractExists(settled_channel))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              UnaryOperation (prefix) !
                 Type: bool
                 Source: "!contractExists(settled_channel)"
                FunctionCall
                   Type: bool
                   Source: "contractExists(settled_channel)"
                  Identifier contractExists
                     Type: function (address) view returns (bool)
                     Source: "contractExists"
                  Identifier settled_channel
                     Type: address
                     Source: "settled_channel"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "uint caller_pos = self.node_index[msg.sender][partner]"
            VariableDeclaration "caller_pos"
               Type: uint256
               Source: "uint caller_pos"
              ElementaryTypeName uint
                 Source: "uint"
            IndexAccess
               Type: uint256
               Source: "self.node_index[msg.sender][partner]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "self.node_index[msg.sender]"
                MemberAccess to member node_index
                   Type: mapping(address => mapping(address => uint256))
                   Source: "self.node_index"
                  Identifier self
                     Type: struct ChannelManagerLibrary.Data storage pointer
                     Source: "self"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier partner
                 Type: address
                 Source: "partner"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "uint partner_pos = self.node_index[partner][msg.sender]"
            VariableDeclaration "partner_pos"
               Type: uint256
               Source: "uint partner_pos"
              ElementaryTypeName uint
                 Source: "uint"
            IndexAccess
               Type: uint256
               Source: "self.node_index[partner][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "self.node_index[partner]"
                MemberAccess to member node_index
                   Type: mapping(address => mapping(address => uint256))
                   Source: "self.node_index"
                  Identifier self
                     Type: struct ChannelManagerLibrary.Data storage pointer
                     Source: "self"
                Identifier partner
                   Type: address
                   Source: "partner"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          ExpressionStatement
             Gas costs: 0
             Source: "self.all_channels[channel_pos - 1] = new_channel_address"
            Assignment using operator =
               Type: address
               Source: "self.all_channels[channel_pos - 1] = new_channel_address"
              IndexAccess
                 Type: address
                 Source: "self.all_channels[channel_pos - 1]"
                MemberAccess to member all_channels
                   Type: address[] storage ref
                   Source: "self.all_channels"
                  Identifier self
                     Type: struct ChannelManagerLibrary.Data storage pointer
                     Source: "self"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "channel_pos - 1"
                  Identifier channel_pos
                     Type: uint256
                     Source: "channel_pos"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              Identifier new_channel_address
                 Type: address
                 Source: "new_channel_address"
          ExpressionStatement
             Gas costs: 0
             Source: "caller_channels[caller_pos - 1] = new_channel_address"
            Assignment using operator =
               Type: address
               Source: "caller_channels[caller_pos - 1] = new_channel_address"
              IndexAccess
                 Type: address
                 Source: "caller_channels[caller_pos - 1]"
                Identifier caller_channels
                   Type: address[] storage pointer
                   Source: "caller_channels"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "caller_pos - 1"
                  Identifier caller_pos
                     Type: uint256
                     Source: "caller_pos"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              Identifier new_channel_address
                 Type: address
                 Source: "new_channel_address"
          ExpressionStatement
             Gas costs: 0
             Source: "partner_channels[partner_pos - 1] = new_channel_address"
            Assignment using operator =
               Type: address
               Source: "partner_channels[partner_pos - 1] = new_channel_address"
              IndexAccess
                 Type: address
                 Source: "partner_channels[partner_pos - 1]"
                Identifier partner_channels
                   Type: address[] storage pointer
                   Source: "partner_channels"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "partner_pos - 1"
                  Identifier partner_pos
                     Type: uint256
                     Source: "partner_pos"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              Identifier new_channel_address
                 Type: address
                 Source: "new_channel_address"
        Block
           Source: "{\r\n            self.all_channels.push(new_channel_address);\r\n            caller_channels.push(new_channel_address);\r\n            partner_channels.push(new_channel_address);\r\n\r\n            // using the 1-index, 0 is used for the absence of a value\r\n            self.partyhash_to_channelpos[party_hash] = self.all_channels.length;\r\n            self.node_index[msg.sender][partner] = caller_channels.length;\r\n            self.node_index[partner][msg.sender] = partner_channels.length;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "self.all_channels.push(new_channel_address)"
            FunctionCall
               Type: uint256
               Source: "self.all_channels.push(new_channel_address)"
              MemberAccess to member push
                 Type: function (address) returns (uint256)
                 Source: "self.all_channels.push"
                MemberAccess to member all_channels
                   Type: address[] storage ref
                   Source: "self.all_channels"
                  Identifier self
                     Type: struct ChannelManagerLibrary.Data storage pointer
                     Source: "self"
              Identifier new_channel_address
                 Type: address
                 Source: "new_channel_address"
          ExpressionStatement
             Gas costs: 0
             Source: "caller_channels.push(new_channel_address)"
            FunctionCall
               Type: uint256
               Source: "caller_channels.push(new_channel_address)"
              MemberAccess to member push
                 Type: function (address) returns (uint256)
                 Source: "caller_channels.push"
                Identifier caller_channels
                   Type: address[] storage pointer
                   Source: "caller_channels"
              Identifier new_channel_address
                 Type: address
                 Source: "new_channel_address"
          ExpressionStatement
             Gas costs: 0
             Source: "partner_channels.push(new_channel_address)"
            FunctionCall
               Type: uint256
               Source: "partner_channels.push(new_channel_address)"
              MemberAccess to member push
                 Type: function (address) returns (uint256)
                 Source: "partner_channels.push"
                Identifier partner_channels
                   Type: address[] storage pointer
                   Source: "partner_channels"
              Identifier new_channel_address
                 Type: address
                 Source: "new_channel_address"
          ExpressionStatement
             Gas costs: 0
             Source: "self.partyhash_to_channelpos[party_hash] = self.all_channels.length"
            Assignment using operator =
               Type: uint256
               Source: "self.partyhash_to_channelpos[party_hash] = self.all_channels.length"
              IndexAccess
                 Type: uint256
                 Source: "self.partyhash_to_channelpos[party_hash]"
                MemberAccess to member partyhash_to_channelpos
                   Type: mapping(bytes32 => uint256)
                   Source: "self.partyhash_to_channelpos"
                  Identifier self
                     Type: struct ChannelManagerLibrary.Data storage pointer
                     Source: "self"
                Identifier party_hash
                   Type: bytes32
                   Source: "party_hash"
              MemberAccess to member length
                 Type: uint256
                 Source: "self.all_channels.length"
                MemberAccess to member all_channels
                   Type: address[] storage ref
                   Source: "self.all_channels"
                  Identifier self
                     Type: struct ChannelManagerLibrary.Data storage pointer
                     Source: "self"
          ExpressionStatement
             Gas costs: 0
             Source: "self.node_index[msg.sender][partner] = caller_channels.length"
            Assignment using operator =
               Type: uint256
               Source: "self.node_index[msg.sender][partner] = caller_channels.length"
              IndexAccess
                 Type: uint256
                 Source: "self.node_index[msg.sender][partner]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "self.node_index[msg.sender]"
                  MemberAccess to member node_index
                     Type: mapping(address => mapping(address => uint256))
                     Source: "self.node_index"
                    Identifier self
                       Type: struct ChannelManagerLibrary.Data storage pointer
                       Source: "self"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier partner
                   Type: address
                   Source: "partner"
              MemberAccess to member length
                 Type: uint256
                 Source: "caller_channels.length"
                Identifier caller_channels
                   Type: address[] storage pointer
                   Source: "caller_channels"
          ExpressionStatement
             Gas costs: 0
             Source: "self.node_index[partner][msg.sender] = partner_channels.length"
            Assignment using operator =
               Type: uint256
               Source: "self.node_index[partner][msg.sender] = partner_channels.length"
              IndexAccess
                 Type: uint256
                 Source: "self.node_index[partner][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "self.node_index[partner]"
                  MemberAccess to member node_index
                     Type: mapping(address => mapping(address => uint256))
                     Source: "self.node_index"
                    Identifier self
                       Type: struct ChannelManagerLibrary.Data storage pointer
                       Source: "self"
                  Identifier partner
                     Type: address
                     Source: "partner"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              MemberAccess to member length
                 Type: uint256
                 Source: "partner_channels.length"
                Identifier partner_channels
                   Type: address[] storage pointer
                   Source: "partner_channels"
      Return
         Gas costs: 0
         Source: "return new_channel_address"
        Identifier new_channel_address
           Type: address
           Source: "new_channel_address"
  FunctionDefinition "partyHash" - const
     Source: "function partyHash(address address_one, address address_two) internal constant returns (bytes32) {\r\n        if (address_one < address_two) {\r\n            return sha3(address_one, address_two);\r\n        } else {\r\n            // The two participants can't be the same here due to this check in\r\n            // the netting channel constructor:\r\n            // https://github.com/raiden-network/raiden/blob/e17d96db375d31b134ae7b4e2ad2c1f905b47857/raiden/smart_contracts/NettingChannelContract.sol#L27\r\n            return sha3(address_two, address_one);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address address_one, address address_two)"
      VariableDeclaration "address_one"
         Type: address
         Source: "address address_one"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "address_two"
         Type: address
         Source: "address address_two"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(bytes32)"
      VariableDeclaration ""
         Type: bytes32
         Source: "bytes32"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        if (address_one < address_two) {\r\n            return sha3(address_one, address_two);\r\n        } else {\r\n            // The two participants can't be the same here due to this check in\r\n            // the netting channel constructor:\r\n            // https://github.com/raiden-network/raiden/blob/e17d96db375d31b134ae7b4e2ad2c1f905b47857/raiden/smart_contracts/NettingChannelContract.sol#L27\r\n            return sha3(address_two, address_one);\r\n        }\r\n    }"
      IfStatement
         Source: "if (address_one < address_two) {\r\n            return sha3(address_one, address_two);\r\n        } else {\r\n            // The two participants can't be the same here due to this check in\r\n            // the netting channel constructor:\r\n            // https://github.com/raiden-network/raiden/blob/e17d96db375d31b134ae7b4e2ad2c1f905b47857/raiden/smart_contracts/NettingChannelContract.sol#L27\r\n            return sha3(address_two, address_one);\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "address_one < address_two"
          Identifier address_one
             Type: address
             Source: "address_one"
          Identifier address_two
             Type: address
             Source: "address_two"
        Block
           Source: "{\r\n            return sha3(address_one, address_two);\r\n        }"
          Return
             Gas costs: 0
             Source: "return sha3(address_one, address_two)"
            FunctionCall
               Type: bytes32
               Source: "sha3(address_one, address_two)"
              Identifier sha3
                 Type: function () pure returns (bytes32)
                 Source: "sha3"
              Identifier address_one
                 Type: address
                 Source: "address_one"
              Identifier address_two
                 Type: address
                 Source: "address_two"
        Block
           Source: "{\r\n            // The two participants can't be the same here due to this check in\r\n            // the netting channel constructor:\r\n            // https://github.com/raiden-network/raiden/blob/e17d96db375d31b134ae7b4e2ad2c1f905b47857/raiden/smart_contracts/NettingChannelContract.sol#L27\r\n            return sha3(address_two, address_one);\r\n        }"
          Return
             Gas costs: 0
             Source: "return sha3(address_two, address_one)"
            FunctionCall
               Type: bytes32
               Source: "sha3(address_two, address_one)"
              Identifier sha3
                 Type: function () pure returns (bytes32)
                 Source: "sha3"
              Identifier address_two
                 Type: address
                 Source: "address_two"
              Identifier address_one
                 Type: address
                 Source: "address_one"
  FunctionDefinition "contractExists" - const
     Source: "function contractExists(address channel) private constant returns (bool) {\r\n        uint size;\r\n\r\n        assembly {\r\n            size := extcodesize(channel)\r\n        }\r\n\r\n        return size > 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address channel)"
      VariableDeclaration "channel"
         Type: address
         Source: "address channel"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        uint size;\r\n\r\n        assembly {\r\n            size := extcodesize(channel)\r\n        }\r\n\r\n        return size > 0;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint size"
        VariableDeclaration "size"
           Type: uint256
           Source: "uint size"
          ElementaryTypeName uint
             Source: "uint"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {\r\n            size := extcodesize(channel)\r\n        }\r\n\r\n        return"
      Return
         Gas costs: 0
         Source: "return size > 0"
        BinaryOperation using operator >
           Type: bool
           Source: "size > 0"
          Identifier size
             Type: uint256
             Source: "size"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
ContractDefinition "ChannelManagerContract"
   Source: "contract ChannelManagerContract is Utils {\r\n    string constant public contract_version = \"0.1._\";\r\n\r\n    using ChannelManagerLibrary for ChannelManagerLibrary.Data;\r\n    ChannelManagerLibrary.Data data;\r\n\r\n    event ChannelNew(\r\n        address netting_channel,\r\n        address participant1,\r\n        address participant2,\r\n        uint settle_timeout\r\n    );\r\n\r\n    event ChannelDeleted(\r\n        address caller_address,\r\n        address partner\r\n    );\r\n\r\n    function ChannelManagerContract(address token_address) {\r\n        data.token = Token(token_address);\r\n    }\r\n\r\n    /// @notice Get all channels\r\n    /// @return All the open channels\r\n    function getChannelsAddresses() constant returns (address[]) {\r\n        return data.all_channels;\r\n    }\r\n\r\n    /// @notice Get all participants of all channels\r\n    /// @return All participants in all channels\r\n    function getChannelsParticipants() constant returns (address[]) {\r\n        uint i;\r\n        uint pos;\r\n        address[] memory result;\r\n        NettingChannelContract channel;\r\n\r\n        uint open_channels_num = 0;\r\n        for (i = 0; i < data.all_channels.length; i++) {\r\n            if (contractExists(data.all_channels[i])) {\r\n                open_channels_num += 1;\r\n            }\r\n        }\r\n        result = new address[](open_channels_num * 2);\r\n\r\n        pos = 0;\r\n        for (i = 0; i < data.all_channels.length; i++) {\r\n            if (!contractExists(data.all_channels[i])) {\r\n                continue;\r\n            }\r\n            channel = NettingChannelContract(data.all_channels[i]);\r\n\r\n            var (address1, , address2, ) = channel.addressAndBalance();\r\n\r\n            result[pos] = address1;\r\n            pos += 1;\r\n            result[pos] = address2;\r\n            pos += 1;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /// @notice Get all channels that an address participates in.\r\n    /// @param node_address The address of the node\r\n    /// @return The channel's addresses that node_address participates in.\r\n    function nettingContractsByAddress(address node_address) constant returns (address[]) {\r\n        return data.nodeaddress_to_channeladdresses[node_address];\r\n    }\r\n\r\n    /// @notice Get the address of the channel token\r\n    /// @return The token\r\n    function tokenAddress() constant returns (address) {\r\n        return data.token;\r\n    }\r\n\r\n    /// @notice Get the address of channel with a partner\r\n    /// @param partner The address of the partner\r\n    /// @return The address of the channel\r\n    function getChannelWith(address partner) constant returns (address) {\r\n        return data.getChannelWith(partner);\r\n    }\r\n\r\n    /// @notice Create a new payment channel between two parties\r\n    /// @param partner The address of the partner\r\n    /// @param settle_timeout The settle timeout in blocks\r\n    /// @return The address of the newly created NettingChannelContract.\r\n    function newChannel(address partner, uint settle_timeout) returns (address) {\r\n        address old_channel = getChannelWith(partner);\r\n        if (old_channel != 0) {\r\n            ChannelDeleted(msg.sender, partner);\r\n        }\r\n\r\n        address new_channel = data.newChannel(partner, settle_timeout);\r\n        ChannelNew(new_channel, msg.sender, partner, settle_timeout);\r\n        return new_channel;\r\n    }\r\n\r\n    function () { revert(); }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Utils"
    UserDefinedTypeName "Utils"
       Source: "Utils"
  VariableDeclaration "contract_version"
     Type: string memory
     Gas costs: 0
     Source: "string constant public contract_version = \"0.1._\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: 0.1._
       Type: literal_string "0.1._"
       Source: "\"0.1._\""
  UsingForDirective
     Gas costs: 0
     Source: "using ChannelManagerLibrary for ChannelManagerLibrary.Data;"
    UserDefinedTypeName "ChannelManagerLibrary"
       Source: "ChannelManagerLibrary"
    UserDefinedTypeName "ChannelManagerLibrary.Data"
       Source: "ChannelManagerLibrary.Data"
  VariableDeclaration "data"
     Type: struct ChannelManagerLibrary.Data storage ref
     Gas costs: 0
     Source: "ChannelManagerLibrary.Data data"
    UserDefinedTypeName "ChannelManagerLibrary.Data"
       Source: "ChannelManagerLibrary.Data"
  EventDefinition "ChannelNew"
     Gas costs: 0
     Source: "event ChannelNew(\r\n        address netting_channel,\r\n        address participant1,\r\n        address participant2,\r\n        uint settle_timeout\r\n    );"
    ParameterList
       Source: "(\r\n        address netting_channel,\r\n        address participant1,\r\n        address participant2,\r\n        uint settle_timeout\r\n    )"
      VariableDeclaration "netting_channel"
         Type: address
         Source: "address netting_channel"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "participant1"
         Type: address
         Source: "address participant1"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "participant2"
         Type: address
         Source: "address participant2"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "settle_timeout"
         Type: uint256
         Source: "uint settle_timeout"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "ChannelDeleted"
     Gas costs: 0
     Source: "event ChannelDeleted(\r\n        address caller_address,\r\n        address partner\r\n    );"
    ParameterList
       Source: "(\r\n        address caller_address,\r\n        address partner\r\n    )"
      VariableDeclaration "caller_address"
         Type: address
         Source: "address caller_address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "partner"
         Type: address
         Source: "address partner"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "ChannelManagerContract" - public
     Source: "function ChannelManagerContract(address token_address) {\r\n        data.token = Token(token_address);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address token_address)"
      VariableDeclaration "token_address"
         Type: address
         Source: "address token_address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        data.token = Token(token_address);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "data.token = Token(token_address)"
        Assignment using operator =
           Type: contract Token
           Source: "data.token = Token(token_address)"
          MemberAccess to member token
             Type: contract Token
             Source: "data.token"
            Identifier data
               Type: struct ChannelManagerLibrary.Data storage ref
               Source: "data"
          FunctionCall
             Type: contract Token
             Source: "Token(token_address)"
            Identifier Token
               Type: type(contract Token)
               Source: "Token"
            Identifier token_address
               Type: address
               Source: "token_address"
  FunctionDefinition "getChannelsAddresses" - public - const
     Source: "function getChannelsAddresses() constant returns (address[]) {\r\n        return data.all_channels;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address[])"
      VariableDeclaration ""
         Type: address[] memory
         Source: "address[]"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\r\n        return data.all_channels;\r\n    }"
      Return
         Gas costs: 0
         Source: "return data.all_channels"
        MemberAccess to member all_channels
           Type: address[] storage ref
           Source: "data.all_channels"
          Identifier data
             Type: struct ChannelManagerLibrary.Data storage ref
             Source: "data"
  FunctionDefinition "getChannelsParticipants" - public - const
     Source: "function getChannelsParticipants() constant returns (address[]) {\r\n        uint i;\r\n        uint pos;\r\n        address[] memory result;\r\n        NettingChannelContract channel;\r\n\r\n        uint open_channels_num = 0;\r\n        for (i = 0; i < data.all_channels.length; i++) {\r\n            if (contractExists(data.all_channels[i])) {\r\n                open_channels_num += 1;\r\n            }\r\n        }\r\n        result = new address[](open_channels_num * 2);\r\n\r\n        pos = 0;\r\n        for (i = 0; i < data.all_channels.length; i++) {\r\n            if (!contractExists(data.all_channels[i])) {\r\n                continue;\r\n            }\r\n            channel = NettingChannelContract(data.all_channels[i]);\r\n\r\n            var (address1, , address2, ) = channel.addressAndBalance();\r\n\r\n            result[pos] = address1;\r\n            pos += 1;\r\n            result[pos] = address2;\r\n            pos += 1;\r\n        }\r\n\r\n        return result;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address[])"
      VariableDeclaration ""
         Type: address[] memory
         Source: "address[]"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\r\n        uint i;\r\n        uint pos;\r\n        address[] memory result;\r\n        NettingChannelContract channel;\r\n\r\n        uint open_channels_num = 0;\r\n        for (i = 0; i < data.all_channels.length; i++) {\r\n            if (contractExists(data.all_channels[i])) {\r\n                open_channels_num += 1;\r\n            }\r\n        }\r\n        result = new address[](open_channels_num * 2);\r\n\r\n        pos = 0;\r\n        for (i = 0; i < data.all_channels.length; i++) {\r\n            if (!contractExists(data.all_channels[i])) {\r\n                continue;\r\n            }\r\n            channel = NettingChannelContract(data.all_channels[i]);\r\n\r\n            var (address1, , address2, ) = channel.addressAndBalance();\r\n\r\n            result[pos] = address1;\r\n            pos += 1;\r\n            result[pos] = address2;\r\n            pos += 1;\r\n        }\r\n\r\n        return result;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint i"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint i"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint pos"
        VariableDeclaration "pos"
           Type: uint256
           Source: "uint pos"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "address[] memory result"
        VariableDeclaration "result"
           Type: address[] memory
           Source: "address[] memory result"
          ArrayTypeName
             Source: "address[]"
            ElementaryTypeName address
               Source: "address"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "NettingChannelContract channel"
        VariableDeclaration "channel"
           Type: contract NettingChannelContract
           Source: "NettingChannelContract channel"
          UserDefinedTypeName "NettingChannelContract"
             Source: "NettingChannelContract"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint open_channels_num = 0"
        VariableDeclaration "open_channels_num"
           Type: uint256
           Source: "uint open_channels_num"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for (i = 0; i < data.all_channels.length; i++) {\r\n            if (contractExists(data.all_channels[i])) {\r\n                open_channels_num += 1;\r\n            }\r\n        }"
        ExpressionStatement
           Gas costs: 0
           Source: "i = 0"
          Assignment using operator =
             Type: uint256
             Source: "i = 0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < data.all_channels.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "data.all_channels.length"
            MemberAccess to member all_channels
               Type: address[] storage ref
               Source: "data.all_channels"
              Identifier data
                 Type: struct ChannelManagerLibrary.Data storage ref
                 Source: "data"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (contractExists(data.all_channels[i])) {\r\n                open_channels_num += 1;\r\n            }\r\n        }"
          IfStatement
             Source: "if (contractExists(data.all_channels[i])) {\r\n                open_channels_num += 1;\r\n            }"
            FunctionCall
               Type: bool
               Gas costs: 0
               Source: "contractExists(data.all_channels[i])"
              Identifier contractExists
                 Type: function (address) view returns (bool)
                 Source: "contractExists"
              IndexAccess
                 Type: address
                 Source: "data.all_channels[i]"
                MemberAccess to member all_channels
                   Type: address[] storage ref
                   Source: "data.all_channels"
                  Identifier data
                     Type: struct ChannelManagerLibrary.Data storage ref
                     Source: "data"
                Identifier i
                   Type: uint256
                   Source: "i"
            Block
               Source: "{\r\n                open_channels_num += 1;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "open_channels_num += 1"
                Assignment using operator +=
                   Type: uint256
                   Source: "open_channels_num += 1"
                  Identifier open_channels_num
                     Type: uint256
                     Source: "open_channels_num"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "result = new address[](open_channels_num * 2)"
        Assignment using operator =
           Type: address[] memory
           Source: "result = new address[](open_channels_num * 2)"
          Identifier result
             Type: address[] memory
             Source: "result"
          FunctionCall
             Type: address[] memory
             Source: "new address[](open_channels_num * 2)"
            NewExpression
               Type: function (uint256) pure returns (address[] memory)
               Source: "new address[]"
              ArrayTypeName
                 Source: "address[]"
                ElementaryTypeName address
                   Source: "address"
            BinaryOperation using operator *
               Type: uint256
               Source: "open_channels_num * 2"
              Identifier open_channels_num
                 Type: uint256
                 Source: "open_channels_num"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
      ExpressionStatement
         Gas costs: 0
         Source: "pos = 0"
        Assignment using operator =
           Type: uint256
           Source: "pos = 0"
          Identifier pos
             Type: uint256
             Source: "pos"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ForStatement
         Source: "for (i = 0; i < data.all_channels.length; i++) {\r\n            if (!contractExists(data.all_channels[i])) {\r\n                continue;\r\n            }\r\n            channel = NettingChannelContract(data.all_channels[i]);\r\n\r\n            var (address1, , address2, ) = channel.addressAndBalance();\r\n\r\n            result[pos] = address1;\r\n            pos += 1;\r\n            result[pos] = address2;\r\n            pos += 1;\r\n        }"
        ExpressionStatement
           Gas costs: 0
           Source: "i = 0"
          Assignment using operator =
             Type: uint256
             Source: "i = 0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < data.all_channels.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "data.all_channels.length"
            MemberAccess to member all_channels
               Type: address[] storage ref
               Source: "data.all_channels"
              Identifier data
                 Type: struct ChannelManagerLibrary.Data storage ref
                 Source: "data"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (!contractExists(data.all_channels[i])) {\r\n                continue;\r\n            }\r\n            channel = NettingChannelContract(data.all_channels[i]);\r\n\r\n            var (address1, , address2, ) = channel.addressAndBalance();\r\n\r\n            result[pos] = address1;\r\n            pos += 1;\r\n            result[pos] = address2;\r\n            pos += 1;\r\n        }"
          IfStatement
             Source: "if (!contractExists(data.all_channels[i])) {\r\n                continue;\r\n            }"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: 0
               Source: "!contractExists(data.all_channels[i])"
              FunctionCall
                 Type: bool
                 Source: "contractExists(data.all_channels[i])"
                Identifier contractExists
                   Type: function (address) view returns (bool)
                   Source: "contractExists"
                IndexAccess
                   Type: address
                   Source: "data.all_channels[i]"
                  MemberAccess to member all_channels
                     Type: address[] storage ref
                     Source: "data.all_channels"
                    Identifier data
                       Type: struct ChannelManagerLibrary.Data storage ref
                       Source: "data"
                  Identifier i
                     Type: uint256
                     Source: "i"
            Block
               Source: "{\r\n                continue;\r\n            }"
              Continue
                 Gas costs: 0
                 Source: "continue"
          ExpressionStatement
             Gas costs: 0
             Source: "channel = NettingChannelContract(data.all_channels[i])"
            Assignment using operator =
               Type: contract NettingChannelContract
               Source: "channel = NettingChannelContract(data.all_channels[i])"
              Identifier channel
                 Type: contract NettingChannelContract
                 Source: "channel"
              FunctionCall
                 Type: contract NettingChannelContract
                 Source: "NettingChannelContract(data.all_channels[i])"
                Identifier NettingChannelContract
                   Type: type(contract NettingChannelContract)
                   Source: "NettingChannelContract"
                IndexAccess
                   Type: address
                   Source: "data.all_channels[i]"
                  MemberAccess to member all_channels
                     Type: address[] storage ref
                     Source: "data.all_channels"
                    Identifier data
                       Type: struct ChannelManagerLibrary.Data storage ref
                       Source: "data"
                  Identifier i
                     Type: uint256
                     Source: "i"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "var (address1, , address2, ) = channel.addressAndBalance()"
            VariableDeclaration "address1"
               Type: address
               Source: "address1"
            VariableDeclaration "address2"
               Type: address
               Source: "address2"
            FunctionCall
               Type: tuple(address,uint256,address,uint256)
               Source: "channel.addressAndBalance()"
              MemberAccess to member addressAndBalance
                 Type: function () view external returns (address,uint256,address,uint256)
                 Source: "channel.addressAndBalance"
                Identifier channel
                   Type: contract NettingChannelContract
                   Source: "channel"
          ExpressionStatement
             Gas costs: 0
             Source: "result[pos] = address1"
            Assignment using operator =
               Type: address
               Source: "result[pos] = address1"
              IndexAccess
                 Type: address
                 Source: "result[pos]"
                Identifier result
                   Type: address[] memory
                   Source: "result"
                Identifier pos
                   Type: uint256
                   Source: "pos"
              Identifier address1
                 Type: address
                 Source: "address1"
          ExpressionStatement
             Gas costs: 0
             Source: "pos += 1"
            Assignment using operator +=
               Type: uint256
               Source: "pos += 1"
              Identifier pos
                 Type: uint256
                 Source: "pos"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          ExpressionStatement
             Gas costs: 0
             Source: "result[pos] = address2"
            Assignment using operator =
               Type: address
               Source: "result[pos] = address2"
              IndexAccess
                 Type: address
                 Source: "result[pos]"
                Identifier result
                   Type: address[] memory
                   Source: "result"
                Identifier pos
                   Type: uint256
                   Source: "pos"
              Identifier address2
                 Type: address
                 Source: "address2"
          ExpressionStatement
             Gas costs: 0
             Source: "pos += 1"
            Assignment using operator +=
               Type: uint256
               Source: "pos += 1"
              Identifier pos
                 Type: uint256
                 Source: "pos"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      Return
         Gas costs: 0
         Source: "return result"
        Identifier result
           Type: address[] memory
           Source: "result"
  FunctionDefinition "nettingContractsByAddress" - public - const
     Source: "function nettingContractsByAddress(address node_address) constant returns (address[]) {\r\n        return data.nodeaddress_to_channeladdresses[node_address];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address node_address)"
      VariableDeclaration "node_address"
         Type: address
         Source: "address node_address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(address[])"
      VariableDeclaration ""
         Type: address[] memory
         Source: "address[]"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\r\n        return data.nodeaddress_to_channeladdresses[node_address];\r\n    }"
      Return
         Gas costs: 0
         Source: "return data.nodeaddress_to_channeladdresses[node_address]"
        IndexAccess
           Type: address[] storage ref
           Source: "data.nodeaddress_to_channeladdresses[node_address]"
          MemberAccess to member nodeaddress_to_channeladdresses
             Type: mapping(address => address[] storage ref)
             Source: "data.nodeaddress_to_channeladdresses"
            Identifier data
               Type: struct ChannelManagerLibrary.Data storage ref
               Source: "data"
          Identifier node_address
             Type: address
             Source: "node_address"
  FunctionDefinition "tokenAddress" - public - const
     Source: "function tokenAddress() constant returns (address) {\r\n        return data.token;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return data.token;\r\n    }"
      Return
         Gas costs: 0
         Source: "return data.token"
        MemberAccess to member token
           Type: contract Token
           Source: "data.token"
          Identifier data
             Type: struct ChannelManagerLibrary.Data storage ref
             Source: "data"
  FunctionDefinition "getChannelWith" - public - const
     Source: "function getChannelWith(address partner) constant returns (address) {\r\n        return data.getChannelWith(partner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address partner)"
      VariableDeclaration "partner"
         Type: address
         Source: "address partner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return data.getChannelWith(partner);\r\n    }"
      Return
         Gas costs: 0
         Source: "return data.getChannelWith(partner)"
        FunctionCall
           Type: address
           Source: "data.getChannelWith(partner)"
          MemberAccess to member getChannelWith
             Type: function (struct ChannelManagerLibrary.Data storage pointer,address) view returns (address)
             Source: "data.getChannelWith"
            Identifier data
               Type: struct ChannelManagerLibrary.Data storage ref
               Source: "data"
          Identifier partner
             Type: address
             Source: "partner"
  FunctionDefinition "newChannel" - public
     Source: "function newChannel(address partner, uint settle_timeout) returns (address) {\r\n        address old_channel = getChannelWith(partner);\r\n        if (old_channel != 0) {\r\n            ChannelDeleted(msg.sender, partner);\r\n        }\r\n\r\n        address new_channel = data.newChannel(partner, settle_timeout);\r\n        ChannelNew(new_channel, msg.sender, partner, settle_timeout);\r\n        return new_channel;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address partner, uint settle_timeout)"
      VariableDeclaration "partner"
         Type: address
         Source: "address partner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "settle_timeout"
         Type: uint256
         Source: "uint settle_timeout"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        address old_channel = getChannelWith(partner);\r\n        if (old_channel != 0) {\r\n            ChannelDeleted(msg.sender, partner);\r\n        }\r\n\r\n        address new_channel = data.newChannel(partner, settle_timeout);\r\n        ChannelNew(new_channel, msg.sender, partner, settle_timeout);\r\n        return new_channel;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "address old_channel = getChannelWith(partner)"
        VariableDeclaration "old_channel"
           Type: address
           Source: "address old_channel"
          ElementaryTypeName address
             Source: "address"
        FunctionCall
           Type: address
           Source: "getChannelWith(partner)"
          Identifier getChannelWith
             Type: function (address) view returns (address)
             Source: "getChannelWith"
          Identifier partner
             Type: address
             Source: "partner"
      IfStatement
         Source: "if (old_channel != 0) {\r\n            ChannelDeleted(msg.sender, partner);\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "old_channel != 0"
          Identifier old_channel
             Type: address
             Source: "old_channel"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            ChannelDeleted(msg.sender, partner);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "ChannelDeleted(msg.sender, partner)"
            FunctionCall
               Type: tuple()
               Source: "ChannelDeleted(msg.sender, partner)"
              Identifier ChannelDeleted
                 Type: function (address,address)
                 Source: "ChannelDeleted"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier partner
                 Type: address
                 Source: "partner"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "address new_channel = data.newChannel(partner, settle_timeout)"
        VariableDeclaration "new_channel"
           Type: address
           Source: "address new_channel"
          ElementaryTypeName address
             Source: "address"
        FunctionCall
           Type: address
           Source: "data.newChannel(partner, settle_timeout)"
          MemberAccess to member newChannel
             Type: function (struct ChannelManagerLibrary.Data storage pointer,address,uint256) returns (address)
             Source: "data.newChannel"
            Identifier data
               Type: struct ChannelManagerLibrary.Data storage ref
               Source: "data"
          Identifier partner
             Type: address
             Source: "partner"
          Identifier settle_timeout
             Type: uint256
             Source: "settle_timeout"
      ExpressionStatement
         Gas costs: 0
         Source: "ChannelNew(new_channel, msg.sender, partner, settle_timeout)"
        FunctionCall
           Type: tuple()
           Source: "ChannelNew(new_channel, msg.sender, partner, settle_timeout)"
          Identifier ChannelNew
             Type: function (address,address,address,uint256)
             Source: "ChannelNew"
          Identifier new_channel
             Type: address
             Source: "new_channel"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier partner
             Type: address
             Source: "partner"
          Identifier settle_timeout
             Type: uint256
             Source: "settle_timeout"
      Return
         Gas costs: 0
         Source: "return new_channel"
        Identifier new_channel
           Type: address
           Source: "new_channel"
  FunctionDefinition "" - public
     Source: "function () { revert(); }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ revert(); }"
      ExpressionStatement
         Gas costs: 0
         Source: "revert()"
        FunctionCall
           Type: tuple()
           Source: "revert()"
          Identifier revert
             Type: function () pure
             Source: "revert"
ContractDefinition "Registry"
   Source: "contract Registry {\r\n    string constant public contract_version = \"0.1._\";\r\n\r\n    mapping(address => address) public registry;\r\n    address[] public tokens;\r\n\r\n    event TokenAdded(address token_address, address channel_manager_address);\r\n\r\n    modifier addressExists(address _address) {\r\n        require(registry[_address] != 0x0);\r\n        _;\r\n    }\r\n\r\n    modifier doesNotExist(address _address) {\r\n        // Check if it's already registered or token contract is invalid.\r\n        // We assume if it has a valid totalSupply() function it's a valid Token contract\r\n        require(registry[_address] == 0x0);\r\n        Token token = Token(_address);\r\n        token.totalSupply();\r\n        _;\r\n    }\r\n\r\n    /// @notice Register a new ERC20 token\r\n    /// @param token_address Address of the token\r\n    /// @return The address of the channel manager\r\n    function addToken(address token_address)\r\n        doesNotExist(token_address)\r\n        returns (address)\r\n    {\r\n        address manager_address;\r\n\r\n        manager_address = new ChannelManagerContract(token_address);\r\n\r\n        registry[token_address] = manager_address;\r\n        tokens.push(token_address);\r\n\r\n        TokenAdded(token_address, manager_address);\r\n\r\n        return manager_address;\r\n    }\r\n\r\n    /// @notice Get the ChannelManager address for a specific token\r\n    /// @param token_address The address of the given token\r\n    /// @return Address of channel manager\r\n    function channelManagerByToken(address token_address)\r\n        addressExists(token_address)\r\n        constant\r\n        returns (address)\r\n    {\r\n        return registry[token_address];\r\n    }\r\n\r\n    /// @notice Get all registered tokens\r\n    /// @return addresses of all registered tokens\r\n    function tokenAddresses()\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return tokens;\r\n    }\r\n\r\n    /// @notice Get the addresses of all channel managers for all registered tokens\r\n    /// @return addresses of all channel managers\r\n    function channelManagerAddresses()\r\n        constant\r\n        returns (address[])\r\n    {\r\n        uint i;\r\n        address token_address;\r\n        address[] memory result;\r\n\r\n        result = new address[](tokens.length);\r\n\r\n        for (i = 0; i < tokens.length; i++) {\r\n            token_address = tokens[i];\r\n            result[i] = registry[token_address];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function () { revert(); }\r\n}"
  VariableDeclaration "contract_version"
     Type: string memory
     Gas costs: [???]
     Source: "string constant public contract_version = \"0.1._\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: 0.1._
       Type: literal_string "0.1._"
       Source: "\"0.1._\""
  VariableDeclaration "registry"
     Type: mapping(address => address)
     Gas costs: 468
     Source: "mapping(address => address) public registry"
    Mapping
       Source: "mapping(address => address)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "tokens"
     Type: address[] storage ref
     Gas costs: 682
     Source: "address[] public tokens"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  EventDefinition "TokenAdded"
     Gas costs: 0
     Source: "event TokenAdded(address token_address, address channel_manager_address);"
    ParameterList
       Source: "(address token_address, address channel_manager_address)"
      VariableDeclaration "token_address"
         Type: address
         Source: "address token_address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "channel_manager_address"
         Type: address
         Source: "address channel_manager_address"
        ElementaryTypeName address
           Source: "address"
  ModifierDefinition "addressExists"
     Source: "modifier addressExists(address _address) {\r\n        require(registry[_address] != 0x0);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        require(registry[_address] != 0x0);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 376
         Source: "require(registry[_address] != 0x0)"
        FunctionCall
           Type: tuple()
           Source: "require(registry[_address] != 0x0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "registry[_address] != 0x0"
            IndexAccess
               Type: address
               Source: "registry[_address]"
              Identifier registry
                 Type: mapping(address => address)
                 Source: "registry"
              Identifier _address
                 Type: address
                 Source: "_address"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "doesNotExist"
     Source: "modifier doesNotExist(address _address) {\r\n        // Check if it's already registered or token contract is invalid.\r\n        // We assume if it has a valid totalSupply() function it's a valid Token contract\r\n        require(registry[_address] == 0x0);\r\n        Token token = Token(_address);\r\n        token.totalSupply();\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        // Check if it's already registered or token contract is invalid.\r\n        // We assume if it has a valid totalSupply() function it's a valid Token contract\r\n        require(registry[_address] == 0x0);\r\n        Token token = Token(_address);\r\n        token.totalSupply();\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 373
         Source: "require(registry[_address] == 0x0)"
        FunctionCall
           Type: tuple()
           Source: "require(registry[_address] == 0x0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "registry[_address] == 0x0"
            IndexAccess
               Type: address
               Source: "registry[_address]"
              Identifier registry
                 Type: mapping(address => address)
                 Source: "registry"
              Identifier _address
                 Type: address
                 Source: "_address"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "Token token = Token(_address)"
        VariableDeclaration "token"
           Type: contract Token
           Source: "Token token"
          UserDefinedTypeName "Token"
             Source: "Token"
        FunctionCall
           Type: contract Token
           Source: "Token(_address)"
          Identifier Token
             Type: type(contract Token)
             Source: "Token"
          Identifier _address
             Type: address
             Source: "_address"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.totalSupply()"
        FunctionCall
           Type: uint256
           Source: "token.totalSupply()"
          MemberAccess to member totalSupply
             Type: function () view external returns (uint256)
             Source: "token.totalSupply"
            Identifier token
               Type: contract Token
               Source: "token"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "addToken" - public
     Source: "function addToken(address token_address)\r\n        doesNotExist(token_address)\r\n        returns (address)\r\n    {\r\n        address manager_address;\r\n\r\n        manager_address = new ChannelManagerContract(token_address);\r\n\r\n        registry[token_address] = manager_address;\r\n        tokens.push(token_address);\r\n\r\n        TokenAdded(token_address, manager_address);\r\n\r\n        return manager_address;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address token_address)"
      VariableDeclaration "token_address"
         Type: address
         Source: "address token_address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    ModifierInvocation "doesNotExist"
       Gas costs: 3
       Source: "doesNotExist(token_address)"
      Identifier doesNotExist
         Type: modifier (address)
         Source: "doesNotExist"
      Identifier token_address
         Type: address
         Source: "token_address"
    Block
       Source: "{\r\n        address manager_address;\r\n\r\n        manager_address = new ChannelManagerContract(token_address);\r\n\r\n        registry[token_address] = manager_address;\r\n        tokens.push(token_address);\r\n\r\n        TokenAdded(token_address, manager_address);\r\n\r\n        return manager_address;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "address manager_address"
        VariableDeclaration "manager_address"
           Type: address
           Source: "address manager_address"
          ElementaryTypeName address
             Source: "address"
      ExpressionStatement
         Gas costs: [???]
         Source: "manager_address = new ChannelManagerContract(token_address)"
        Assignment using operator =
           Type: address
           Source: "manager_address = new ChannelManagerContract(token_address)"
          Identifier manager_address
             Type: address
             Source: "manager_address"
          FunctionCall
             Type: contract ChannelManagerContract
             Source: "new ChannelManagerContract(token_address)"
            NewExpression
               Type: function (address) returns (contract ChannelManagerContract)
               Source: "new ChannelManagerContract"
              UserDefinedTypeName "ChannelManagerContract"
                 Source: "ChannelManagerContract"
            Identifier token_address
               Type: address
               Source: "token_address"
      ExpressionStatement
         Gas costs: 20363
         Source: "registry[token_address] = manager_address"
        Assignment using operator =
           Type: address
           Source: "registry[token_address] = manager_address"
          IndexAccess
             Type: address
             Source: "registry[token_address]"
            Identifier registry
               Type: mapping(address => address)
               Source: "registry"
            Identifier token_address
               Type: address
               Source: "token_address"
          Identifier manager_address
             Type: address
             Source: "manager_address"
      ExpressionStatement
         Gas costs: 20362
         Source: "tokens.push(token_address)"
        FunctionCall
           Type: uint256
           Source: "tokens.push(token_address)"
          MemberAccess to member push
             Type: function (address) returns (uint256)
             Source: "tokens.push"
            Identifier tokens
               Type: address[] storage ref
               Source: "tokens"
          Identifier token_address
             Type: address
             Source: "token_address"
      ExpressionStatement
         Gas costs: [???]
         Source: "TokenAdded(token_address, manager_address)"
        FunctionCall
           Type: tuple()
           Source: "TokenAdded(token_address, manager_address)"
          Identifier TokenAdded
             Type: function (address,address)
             Source: "TokenAdded"
          Identifier token_address
             Type: address
             Source: "token_address"
          Identifier manager_address
             Type: address
             Source: "manager_address"
      Return
         Gas costs: 8
         Source: "return manager_address"
        Identifier manager_address
           Type: address
           Source: "manager_address"
  FunctionDefinition "channelManagerByToken" - public - const
     Source: "function channelManagerByToken(address token_address)\r\n        addressExists(token_address)\r\n        constant\r\n        returns (address)\r\n    {\r\n        return registry[token_address];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address token_address)"
      VariableDeclaration "token_address"
         Type: address
         Source: "address token_address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    ModifierInvocation "addressExists"
       Gas costs: 3
       Source: "addressExists(token_address)"
      Identifier addressExists
         Type: modifier (address)
         Source: "addressExists"
      Identifier token_address
         Type: address
         Source: "token_address"
    Block
       Source: "{\r\n        return registry[token_address];\r\n    }"
      Return
         Gas costs: 340
         Source: "return registry[token_address]"
        IndexAccess
           Type: address
           Source: "registry[token_address]"
          Identifier registry
             Type: mapping(address => address)
             Source: "registry"
          Identifier token_address
             Type: address
             Source: "token_address"
  FunctionDefinition "tokenAddresses" - public - const
     Source: "function tokenAddresses()\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return tokens;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(address[])"
      VariableDeclaration ""
         Type: address[] memory
         Source: "address[]"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\r\n        return tokens;\r\n    }"
      Return
         Gas costs: [???]
         Source: "return tokens"
        Identifier tokens
           Type: address[] storage ref
           Source: "tokens"
  FunctionDefinition "channelManagerAddresses" - public - const
     Source: "function channelManagerAddresses()\r\n        constant\r\n        returns (address[])\r\n    {\r\n        uint i;\r\n        address token_address;\r\n        address[] memory result;\r\n\r\n        result = new address[](tokens.length);\r\n\r\n        for (i = 0; i < tokens.length; i++) {\r\n            token_address = tokens[i];\r\n            result[i] = registry[token_address];\r\n        }\r\n\r\n        return result;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(address[])"
      VariableDeclaration ""
         Type: address[] memory
         Source: "address[]"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\r\n        uint i;\r\n        address token_address;\r\n        address[] memory result;\r\n\r\n        result = new address[](tokens.length);\r\n\r\n        for (i = 0; i < tokens.length; i++) {\r\n            token_address = tokens[i];\r\n            result[i] = registry[token_address];\r\n        }\r\n\r\n        return result;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint i"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint i"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "address token_address"
        VariableDeclaration "token_address"
           Type: address
           Source: "address token_address"
          ElementaryTypeName address
             Source: "address"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "address[] memory result"
        VariableDeclaration "result"
           Type: address[] memory
           Source: "address[] memory result"
          ArrayTypeName
             Source: "address[]"
            ElementaryTypeName address
               Source: "address"
      ExpressionStatement
         Gas costs: 314
         Source: "result = new address[](tokens.length)"
        Assignment using operator =
           Type: address[] memory
           Source: "result = new address[](tokens.length)"
          Identifier result
             Type: address[] memory
             Source: "result"
          FunctionCall
             Type: address[] memory
             Source: "new address[](tokens.length)"
            NewExpression
               Type: function (uint256) pure returns (address[] memory)
               Source: "new address[]"
              ArrayTypeName
                 Source: "address[]"
                ElementaryTypeName address
                   Source: "address"
            MemberAccess to member length
               Type: uint256
               Source: "tokens.length"
              Identifier tokens
                 Type: address[] storage ref
                 Source: "tokens"
      ForStatement
         Source: "for (i = 0; i < tokens.length; i++) {\r\n            token_address = tokens[i];\r\n            result[i] = registry[token_address];\r\n        }"
        ExpressionStatement
           Gas costs: 8
           Source: "i = 0"
          Assignment using operator =
             Type: uint256
             Source: "i = 0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 217
           Source: "i < tokens.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "tokens.length"
            Identifier tokens
               Type: address[] storage ref
               Source: "tokens"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            token_address = tokens[i];\r\n            result[i] = registry[token_address];\r\n        }"
          ExpressionStatement
             Gas costs: 533
             Source: "token_address = tokens[i]"
            Assignment using operator =
               Type: address
               Source: "token_address = tokens[i]"
              Identifier token_address
                 Type: address
                 Source: "token_address"
              IndexAccess
                 Type: address
                 Source: "tokens[i]"
                Identifier tokens
                   Type: address[] storage ref
                   Source: "tokens"
                Identifier i
                   Type: uint256
                   Source: "i"
          ExpressionStatement
             Gas costs: [???]
             Source: "result[i] = registry[token_address]"
            Assignment using operator =
               Type: address
               Source: "result[i] = registry[token_address]"
              IndexAccess
                 Type: address
                 Source: "result[i]"
                Identifier result
                   Type: address[] memory
                   Source: "result"
                Identifier i
                   Type: uint256
                   Source: "i"
              IndexAccess
                 Type: address
                 Source: "registry[token_address]"
                Identifier registry
                   Type: mapping(address => address)
                   Source: "registry"
                Identifier token_address
                   Type: address
                   Source: "token_address"
      Return
         Gas costs: 8
         Source: "return result"
        Identifier result
           Type: address[] memory
           Source: "result"
  FunctionDefinition "" - public
     Source: "function () { revert(); }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ revert(); }"
      ExpressionStatement
         Gas costs: 6
         Source: "revert()"
        FunctionCall
           Type: tuple()
           Source: "revert()"
          Identifier revert
             Type: function () pure
             Source: "revert"
