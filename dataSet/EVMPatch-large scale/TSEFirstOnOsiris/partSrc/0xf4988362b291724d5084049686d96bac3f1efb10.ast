Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xf4988362b291724d5084049686d96bac3f1efb10.sol =======
ContractDefinition "ERC20Basic"
   Gas costs: [???]
   Source: "contract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) public constant returns (uint256);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address to, uint256 value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "ERC20Interface"
   Source: "contract ERC20Interface {\r\n    function totalSupply() constant returns (uint supply) {}\r\n    function balanceOf(address _owner) constant returns (uint balance) {}\r\n    function transfer(address _to, uint _value) returns (bool success) {}\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\r\n    function approve(address _spender, uint _value) returns (bool success) {}\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() constant returns (uint supply) {}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint supply)"
      VariableDeclaration "supply"
         Type: uint256
         Source: "uint supply"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint balance) {}"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint balance"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value) returns (bool success) {}"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value) returns (bool success) {}"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint _value) returns (bool success) {}"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint remaining) {}"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint remaining"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Gas costs: 0
       Source: "{}"
  EventDefinition "Transfer"
     Gas costs: 0
     Source: "event Transfer(address indexed _from, address indexed _to, uint _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Approval"
     Gas costs: 0
     Source: "event Approval(address indexed _owner, address indexed _spender, uint _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "mul" - const
     Source: "function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div" - const
     Source: "function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub" - const
     Source: "function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add" - const
     Source: "function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "BasicToken"
   Source: "contract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) balances"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(_to != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_to != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != address(0)"
            Identifier _to
               Type: address
               Source: "_to"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 333
         Source: "require(_value <= balances[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= balances[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= balances[msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 20437
         Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "balances[msg.sender].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20433
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return balances[_owner];\r\n  }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
ContractDefinition "WrapperLock"
   Source: "contract WrapperLock is BasicToken {\r\n\r\n  address ZEROEX_PROXY = 0x8da0d80f5007ef1e431dd2127178d224e32c2ef4;\r\n  address ETHFINEX;\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint public decimals;\r\n  address public originalToken;\r\n\r\n  mapping (address => uint) public depositLock;\r\n\r\n  function WrapperLock(address _originalToken, string _name, string _symbol, uint _decimals) {\r\n    originalToken = _originalToken;\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n    ETHFINEX = 0x5A2143B894C9E8d8DFe2A0e8B80d7DB2689fC382;\r\n  }\r\n\r\n  function deposit(uint _value, uint _forTime) returns (bool success) {\r\n    require (_forTime >= 1);\r\n    require (now + _forTime * 1 hours >= depositLock[msg.sender]);\r\n    success = ERC20Interface(originalToken).transferFrom(msg.sender, this, _value);\r\n    if(success) {\r\n      balances[msg.sender] = balances[msg.sender].add(_value);\r\n      depositLock[msg.sender] = now + _forTime * 1 hours;\r\n    }\r\n  }\r\n\r\n  function withdraw(uint8 v, bytes32 r, bytes32 s, uint _value, uint signatureValidUntilBlock) returns (bool success) {\r\n    require(balanceOf(msg.sender) >= _value);\r\n    if (now > depositLock[msg.sender]){\r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      success = ERC20Interface(originalToken).transfer(msg.sender, _value);\r\n    }\r\n    else {\r\n      require(block.number < signatureValidUntilBlock);\r\n      require(isValidSignature(ETHFINEX, keccak256(msg.sender, _value, signatureValidUntilBlock), v, r, s));\r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      success = ERC20Interface(originalToken).transfer(msg.sender, _value);\r\n    }\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) {\r\n    assert(msg.sender == ZEROEX_PROXY);\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function allowance(address owner, address spender) returns (uint) {\r\n    if(spender == ZEROEX_PROXY) {\r\n      return 2**256 - 1;\r\n    }\r\n  }\r\n\r\n  function isValidSignature(\r\n        address signer,\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return signer == ecrecover(\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "BasicToken"
    UserDefinedTypeName "BasicToken"
       Source: "BasicToken"
  VariableDeclaration "ZEROEX_PROXY"
     Type: address
     Gas costs: 0
     Source: "address ZEROEX_PROXY = 0x8da0d80f5007ef1e431dd2127178d224e32c2ef4"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x8da0d80f5007ef1e431dd2127178d224e32c2ef4
       Type: int_const 8085...(40 digits omitted)...9812
       Source: "0x8da0d80f5007ef1e431dd2127178d224e32c2ef4"
  VariableDeclaration "ETHFINEX"
     Type: address
     Gas costs: 0
     Source: "address ETHFINEX"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public name"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public symbol"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "decimals"
     Type: uint256
     Gas costs: [???]
     Source: "uint public decimals"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "originalToken"
     Type: address
     Gas costs: [???]
     Source: "address public originalToken"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "depositLock"
     Type: mapping(address => uint256)
     Gas costs: [???]
     Source: "mapping (address => uint) public depositLock"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  FunctionDefinition "WrapperLock" - public
     Source: "function WrapperLock(address _originalToken, string _name, string _symbol, uint _decimals) {\r\n    originalToken = _originalToken;\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n    ETHFINEX = 0x5A2143B894C9E8d8DFe2A0e8B80d7DB2689fC382;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _originalToken, string _name, string _symbol, uint _decimals)"
      VariableDeclaration "_originalToken"
         Type: address
         Source: "address _originalToken"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_name"
         Type: string memory
         Source: "string _name"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_symbol"
         Type: string memory
         Source: "string _symbol"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_decimals"
         Type: uint256
         Source: "uint _decimals"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    originalToken = _originalToken;\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n    ETHFINEX = 0x5A2143B894C9E8d8DFe2A0e8B80d7DB2689fC382;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "originalToken = _originalToken"
        Assignment using operator =
           Type: address
           Source: "originalToken = _originalToken"
          Identifier originalToken
             Type: address
             Source: "originalToken"
          Identifier _originalToken
             Type: address
             Source: "_originalToken"
      ExpressionStatement
         Gas costs: 0
         Source: "name = _name"
        Assignment using operator =
           Type: string storage ref
           Source: "name = _name"
          Identifier name
             Type: string storage ref
             Source: "name"
          Identifier _name
             Type: string memory
             Source: "_name"
      ExpressionStatement
         Gas costs: 0
         Source: "symbol = _symbol"
        Assignment using operator =
           Type: string storage ref
           Source: "symbol = _symbol"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
          Identifier _symbol
             Type: string memory
             Source: "_symbol"
      ExpressionStatement
         Gas costs: 0
         Source: "decimals = _decimals"
        Assignment using operator =
           Type: uint256
           Source: "decimals = _decimals"
          Identifier decimals
             Type: uint256
             Source: "decimals"
          Identifier _decimals
             Type: uint256
             Source: "_decimals"
      ExpressionStatement
         Gas costs: 0
         Source: "ETHFINEX = 0x5A2143B894C9E8d8DFe2A0e8B80d7DB2689fC382"
        Assignment using operator =
           Type: address
           Source: "ETHFINEX = 0x5A2143B894C9E8d8DFe2A0e8B80d7DB2689fC382"
          Identifier ETHFINEX
             Type: address
             Source: "ETHFINEX"
          Literal, token: [no token] value: 0x5A2143B894C9E8d8DFe2A0e8B80d7DB2689fC382
             Type: address
             Source: "0x5A2143B894C9E8d8DFe2A0e8B80d7DB2689fC382"
  FunctionDefinition "deposit" - public
     Source: "function deposit(uint _value, uint _forTime) returns (bool success) {\r\n    require (_forTime >= 1);\r\n    require (now + _forTime * 1 hours >= depositLock[msg.sender]);\r\n    success = ERC20Interface(originalToken).transferFrom(msg.sender, this, _value);\r\n    if(success) {\r\n      balances[msg.sender] = balances[msg.sender].add(_value);\r\n      depositLock[msg.sender] = now + _forTime * 1 hours;\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint _value, uint _forTime)"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_forTime"
         Type: uint256
         Source: "uint _forTime"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require (_forTime >= 1);\r\n    require (now + _forTime * 1 hours >= depositLock[msg.sender]);\r\n    success = ERC20Interface(originalToken).transferFrom(msg.sender, this, _value);\r\n    if(success) {\r\n      balances[msg.sender] = balances[msg.sender].add(_value);\r\n      depositLock[msg.sender] = now + _forTime * 1 hours;\r\n    }\r\n  }"
      ExpressionStatement
         Gas costs: 38
         Source: "require (_forTime >= 1)"
        FunctionCall
           Type: tuple()
           Source: "require (_forTime >= 1)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "_forTime >= 1"
            Identifier _forTime
               Type: uint256
               Source: "_forTime"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: 346
         Source: "require (now + _forTime * 1 hours >= depositLock[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require (now + _forTime * 1 hours >= depositLock[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "now + _forTime * 1 hours >= depositLock[msg.sender]"
            BinaryOperation using operator +
               Type: uint256
               Source: "now + _forTime * 1 hours"
              Identifier now
                 Type: uint256
                 Source: "now"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "_forTime * 1 hours"
                Identifier _forTime
                   Type: uint256
                   Source: "_forTime"
                Literal, token: [no token] value: 1
                   Type: int_const 3600
                   Source: "1 hours"
            IndexAccess
               Type: uint256
               Source: "depositLock[msg.sender]"
              Identifier depositLock
                 Type: mapping(address => uint256)
                 Source: "depositLock"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: [???]
         Source: "success = ERC20Interface(originalToken).transferFrom(msg.sender, this, _value)"
        Assignment using operator =
           Type: bool
           Source: "success = ERC20Interface(originalToken).transferFrom(msg.sender, this, _value)"
          Identifier success
             Type: bool
             Source: "success"
          FunctionCall
             Type: bool
             Source: "ERC20Interface(originalToken).transferFrom(msg.sender, this, _value)"
            MemberAccess to member transferFrom
               Type: function (address,address,uint256) external returns (bool)
               Source: "ERC20Interface(originalToken).transferFrom"
              FunctionCall
                 Type: contract ERC20Interface
                 Source: "ERC20Interface(originalToken)"
                Identifier ERC20Interface
                   Type: type(contract ERC20Interface)
                   Source: "ERC20Interface"
                Identifier originalToken
                   Type: address
                   Source: "originalToken"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier this
               Type: contract WrapperLock
               Source: "this"
            Identifier _value
               Type: uint256
               Source: "_value"
      IfStatement
         Source: "if(success) {\r\n      balances[msg.sender] = balances[msg.sender].add(_value);\r\n      depositLock[msg.sender] = now + _forTime * 1 hours;\r\n    }"
        Identifier success
           Type: bool
           Gas costs: 3
           Source: "success"
        Block
           Source: "{\r\n      balances[msg.sender] = balances[msg.sender].add(_value);\r\n      depositLock[msg.sender] = now + _forTime * 1 hours;\r\n    }"
          ExpressionStatement
             Gas costs: 20437
             Source: "balances[msg.sender] = balances[msg.sender].add(_value)"
            Assignment using operator =
               Type: uint256
               Source: "balances[msg.sender] = balances[msg.sender].add(_value)"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              FunctionCall
                 Type: uint256
                 Source: "balances[msg.sender].add(_value)"
                MemberAccess to member add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "balances[msg.sender].add"
                  IndexAccess
                     Type: uint256
                     Source: "balances[msg.sender]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                Identifier _value
                   Type: uint256
                   Source: "_value"
          ExpressionStatement
             Gas costs: 20116
             Source: "depositLock[msg.sender] = now + _forTime * 1 hours"
            Assignment using operator =
               Type: uint256
               Source: "depositLock[msg.sender] = now + _forTime * 1 hours"
              IndexAccess
                 Type: uint256
                 Source: "depositLock[msg.sender]"
                Identifier depositLock
                   Type: mapping(address => uint256)
                   Source: "depositLock"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "now + _forTime * 1 hours"
                Identifier now
                   Type: uint256
                   Source: "now"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "_forTime * 1 hours"
                  Identifier _forTime
                     Type: uint256
                     Source: "_forTime"
                  Literal, token: [no token] value: 1
                     Type: int_const 3600
                     Source: "1 hours"
  FunctionDefinition "withdraw" - public
     Source: "function withdraw(uint8 v, bytes32 r, bytes32 s, uint _value, uint signatureValidUntilBlock) returns (bool success) {\r\n    require(balanceOf(msg.sender) >= _value);\r\n    if (now > depositLock[msg.sender]){\r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      success = ERC20Interface(originalToken).transfer(msg.sender, _value);\r\n    }\r\n    else {\r\n      require(block.number < signatureValidUntilBlock);\r\n      require(isValidSignature(ETHFINEX, keccak256(msg.sender, _value, signatureValidUntilBlock), v, r, s));\r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      success = ERC20Interface(originalToken).transfer(msg.sender, _value);\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint8 v, bytes32 r, bytes32 s, uint _value, uint signatureValidUntilBlock)"
      VariableDeclaration "v"
         Type: uint8
         Source: "uint8 v"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "r"
         Type: bytes32
         Source: "bytes32 r"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "s"
         Type: bytes32
         Source: "bytes32 s"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "signatureValidUntilBlock"
         Type: uint256
         Source: "uint signatureValidUntilBlock"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(balanceOf(msg.sender) >= _value);\r\n    if (now > depositLock[msg.sender]){\r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      success = ERC20Interface(originalToken).transfer(msg.sender, _value);\r\n    }\r\n    else {\r\n      require(block.number < signatureValidUntilBlock);\r\n      require(isValidSignature(ETHFINEX, keccak256(msg.sender, _value, signatureValidUntilBlock), v, r, s));\r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      success = ERC20Interface(originalToken).transfer(msg.sender, _value);\r\n    }\r\n  }"
      ExpressionStatement
         Gas costs: 52
         Source: "require(balanceOf(msg.sender) >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balanceOf(msg.sender) >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balanceOf(msg.sender) >= _value"
            FunctionCall
               Type: uint256
               Source: "balanceOf(msg.sender)"
              Identifier balanceOf
                 Type: function (address) view returns (uint256)
                 Source: "balanceOf"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      IfStatement
         Source: "if (now > depositLock[msg.sender]){\r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      success = ERC20Interface(originalToken).transfer(msg.sender, _value);\r\n    }\r\n    else {\r\n      require(block.number < signatureValidUntilBlock);\r\n      require(isValidSignature(ETHFINEX, keccak256(msg.sender, _value, signatureValidUntilBlock), v, r, s));\r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      success = ERC20Interface(originalToken).transfer(msg.sender, _value);\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 303
           Source: "now > depositLock[msg.sender]"
          Identifier now
             Type: uint256
             Source: "now"
          IndexAccess
             Type: uint256
             Source: "depositLock[msg.sender]"
            Identifier depositLock
               Type: mapping(address => uint256)
               Source: "depositLock"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
        Block
           Source: "{\r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      success = ERC20Interface(originalToken).transfer(msg.sender, _value);\r\n    }"
          ExpressionStatement
             Gas costs: 20437
             Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
            Assignment using operator =
               Type: uint256
               Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              FunctionCall
                 Type: uint256
                 Source: "balances[msg.sender].sub(_value)"
                MemberAccess to member sub
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "balances[msg.sender].sub"
                  IndexAccess
                     Type: uint256
                     Source: "balances[msg.sender]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                Identifier _value
                   Type: uint256
                   Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "success = ERC20Interface(originalToken).transfer(msg.sender, _value)"
            Assignment using operator =
               Type: bool
               Source: "success = ERC20Interface(originalToken).transfer(msg.sender, _value)"
              Identifier success
                 Type: bool
                 Source: "success"
              FunctionCall
                 Type: bool
                 Source: "ERC20Interface(originalToken).transfer(msg.sender, _value)"
                MemberAccess to member transfer
                   Type: function (address,uint256) external returns (bool)
                   Source: "ERC20Interface(originalToken).transfer"
                  FunctionCall
                     Type: contract ERC20Interface
                     Source: "ERC20Interface(originalToken)"
                    Identifier ERC20Interface
                       Type: type(contract ERC20Interface)
                       Source: "ERC20Interface"
                    Identifier originalToken
                       Type: address
                       Source: "originalToken"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Identifier _value
                   Type: uint256
                   Source: "_value"
        Block
           Source: "{\r\n      require(block.number < signatureValidUntilBlock);\r\n      require(isValidSignature(ETHFINEX, keccak256(msg.sender, _value, signatureValidUntilBlock), v, r, s));\r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      success = ERC20Interface(originalToken).transfer(msg.sender, _value);\r\n    }"
          ExpressionStatement
             Gas costs: 34
             Source: "require(block.number < signatureValidUntilBlock)"
            FunctionCall
               Type: tuple()
               Source: "require(block.number < signatureValidUntilBlock)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator <
                 Type: bool
                 Source: "block.number < signatureValidUntilBlock"
                MemberAccess to member number
                   Type: uint256
                   Source: "block.number"
                  Identifier block
                     Type: block
                     Source: "block"
                Identifier signatureValidUntilBlock
                   Type: uint256
                   Source: "signatureValidUntilBlock"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(isValidSignature(ETHFINEX, keccak256(msg.sender, _value, signatureValidUntilBlock), v, r, s))"
            FunctionCall
               Type: tuple()
               Source: "require(isValidSignature(ETHFINEX, keccak256(msg.sender, _value, signatureValidUntilBlock), v, r, s))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "isValidSignature(ETHFINEX, keccak256(msg.sender, _value, signatureValidUntilBlock), v, r, s)"
                Identifier isValidSignature
                   Type: function (address,bytes32,uint8,bytes32,bytes32) view returns (bool)
                   Source: "isValidSignature"
                Identifier ETHFINEX
                   Type: address
                   Source: "ETHFINEX"
                FunctionCall
                   Type: bytes32
                   Source: "keccak256(msg.sender, _value, signatureValidUntilBlock)"
                  Identifier keccak256
                     Type: function () pure returns (bytes32)
                     Source: "keccak256"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier _value
                     Type: uint256
                     Source: "_value"
                  Identifier signatureValidUntilBlock
                     Type: uint256
                     Source: "signatureValidUntilBlock"
                Identifier v
                   Type: uint8
                   Source: "v"
                Identifier r
                   Type: bytes32
                   Source: "r"
                Identifier s
                   Type: bytes32
                   Source: "s"
          ExpressionStatement
             Gas costs: 20437
             Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
            Assignment using operator =
               Type: uint256
               Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              FunctionCall
                 Type: uint256
                 Source: "balances[msg.sender].sub(_value)"
                MemberAccess to member sub
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "balances[msg.sender].sub"
                  IndexAccess
                     Type: uint256
                     Source: "balances[msg.sender]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                Identifier _value
                   Type: uint256
                   Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "success = ERC20Interface(originalToken).transfer(msg.sender, _value)"
            Assignment using operator =
               Type: bool
               Source: "success = ERC20Interface(originalToken).transfer(msg.sender, _value)"
              Identifier success
                 Type: bool
                 Source: "success"
              FunctionCall
                 Type: bool
                 Source: "ERC20Interface(originalToken).transfer(msg.sender, _value)"
                MemberAccess to member transfer
                   Type: function (address,uint256) external returns (bool)
                   Source: "ERC20Interface(originalToken).transfer"
                  FunctionCall
                     Type: contract ERC20Interface
                     Source: "ERC20Interface(originalToken)"
                    Identifier ERC20Interface
                       Type: type(contract ERC20Interface)
                       Source: "ERC20Interface"
                    Identifier originalToken
                       Type: address
                       Source: "originalToken"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Identifier _value
                   Type: uint256
                   Source: "_value"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value) {\r\n    assert(msg.sender == ZEROEX_PROXY);\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    assert(msg.sender == ZEROEX_PROXY);\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }"
      ExpressionStatement
         Gas costs: 276
         Source: "assert(msg.sender == ZEROEX_PROXY)"
        FunctionCall
           Type: tuple()
           Source: "assert(msg.sender == ZEROEX_PROXY)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == ZEROEX_PROXY"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier ZEROEX_PROXY
               Type: address
               Source: "ZEROEX_PROXY"
      ExpressionStatement
         Gas costs: 20439
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20433
         Source: "balances[_from] = balances[_from].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_from] = balances[_from].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "balances[_from].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[_from].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "allowance" - public
     Source: "function allowance(address owner, address spender) returns (uint) {\r\n    if(spender == ZEROEX_PROXY) {\r\n      return 2**256 - 1;\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    if(spender == ZEROEX_PROXY) {\r\n      return 2**256 - 1;\r\n    }\r\n  }"
      IfStatement
         Source: "if(spender == ZEROEX_PROXY) {\r\n      return 2**256 - 1;\r\n    }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 257
           Source: "spender == ZEROEX_PROXY"
          Identifier spender
             Type: address
             Source: "spender"
          Identifier ZEROEX_PROXY
             Type: address
             Source: "ZEROEX_PROXY"
        Block
           Source: "{\r\n      return 2**256 - 1;\r\n    }"
          Return
             Gas costs: 19
             Source: "return 2**256 - 1"
            BinaryOperation using operator -
               Type: int_const 1157...(70 digits omitted)...9935
               Source: "2**256 - 1"
              BinaryOperation using operator **
                 Type: int_const 1157...(70 digits omitted)...9936
                 Source: "2**256"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
                Literal, token: [no token] value: 256
                   Type: int_const 256
                   Source: "256"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
  FunctionDefinition "isValidSignature" - public - const
     Source: "function isValidSignature(\r\n        address signer,\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return signer == ecrecover(\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address signer,\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)"
      VariableDeclaration "signer"
         Type: address
         Source: "address signer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "hash"
         Type: bytes32
         Source: "bytes32 hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "v"
         Type: uint8
         Source: "uint8 v"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "r"
         Type: bytes32
         Source: "bytes32 r"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "s"
         Type: bytes32
         Source: "bytes32 s"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        return signer == ecrecover(\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }"
      Return
         Gas costs: [???]
         Source: "return signer == ecrecover(\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\r\n            v,\r\n            r,\r\n            s\r\n        )"
        BinaryOperation using operator ==
           Type: bool
           Source: "signer == ecrecover(\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\r\n            v,\r\n            r,\r\n            s\r\n        )"
          Identifier signer
             Type: address
             Source: "signer"
          FunctionCall
             Type: address
             Source: "ecrecover(\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\r\n            v,\r\n            r,\r\n            s\r\n        )"
            Identifier ecrecover
               Type: function (bytes32,uint8,bytes32,bytes32) pure returns (address)
               Source: "ecrecover"
            FunctionCall
               Type: bytes32
               Source: "keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash)"
              Identifier keccak256
                 Type: function () pure returns (bytes32)
                 Source: "keccak256"
              Literal, token: [no token] value: Ethereum Signed Message:
32
                 Type: literal_string "Ethereum Signed Message:
32"
                 Source: "\"\\x19Ethereum Signed Message:\\n32\""
              Identifier hash
                 Type: bytes32
                 Source: "hash"
            Identifier v
               Type: uint8
               Source: "v"
            Identifier r
               Type: bytes32
               Source: "r"
            Identifier s
               Type: bytes32
               Source: "s"
