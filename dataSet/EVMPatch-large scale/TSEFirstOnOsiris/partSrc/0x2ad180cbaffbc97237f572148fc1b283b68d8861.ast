Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x2ad180cbaffbc97237f572148fc1b283b68d8861.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "ERC20"
   Gas costs: 0
   Source: "contract ERC20 {\r\n\r\n  function balanceOf(address who) constant public returns (uint);\r\n  function allowance(address owner, address spender) constant public returns (uint);\r\n\r\n  function transfer(address to, uint value) public returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n  function approve(address spender, uint value) public returns (bool ok);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n}"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) constant public returns (uint);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) constant public returns (uint);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint value) public returns (bool ok);"
    ParameterList
       Source: "(address to, uint value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint value) public returns (bool ok);"
    ParameterList
       Source: "(address from, address to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint value) public returns (bool ok);"
    ParameterList
       Source: "(address spender, uint value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "TokenController"
   Gas costs: 0
   Source: "contract TokenController {\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) payable public returns(bool);\r\n\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\r\n\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount) public\r\n        returns(bool);\r\n}"
  FunctionDefinition "proxyPayment" - public
     Source: "function proxyPayment(address _owner) payable public returns(bool);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "onTransfer" - public
     Source: "function onTransfer(address _from, address _to, uint _amount) public returns(bool);"
    ParameterList
       Source: "(address _from, address _to, uint _amount)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "onApprove" - public
     Source: "function onApprove(address _owner, address _spender, uint _amount) public\r\n        returns(bool);"
    ParameterList
       Source: "(address _owner, address _spender, uint _amount)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
ContractDefinition "Controlled"
   Source: "contract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController { require(msg.sender == controller); _; }\r\n\r\n    address public controller;\r\n\r\n    function Controlled() public { controller = msg.sender;}\r\n\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) onlyController public {\r\n        controller = _newController;\r\n    }\r\n}"
  ModifierDefinition "onlyController"
     Source: "modifier onlyController { require(msg.sender == controller); _; }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ require(msg.sender == controller); _; }"
      ExpressionStatement
         Gas costs: 1128
         Source: "require(msg.sender == controller)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == controller)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == controller"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier controller
               Type: address
               Source: "controller"
      PlaceholderStatement
         Gas costs: 1
         Source: "_"
  VariableDeclaration "controller"
     Type: address
     Gas costs: [???]
     Source: "address public controller"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "Controlled" - public
     Source: "function Controlled() public { controller = msg.sender;}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ controller = msg.sender;}"
      ExpressionStatement
         Gas costs: 0
         Source: "controller = msg.sender"
        Assignment using operator =
           Type: address
           Source: "controller = msg.sender"
          Identifier controller
             Type: address
             Source: "controller"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "changeController" - public
     Source: "function changeController(address _newController) onlyController public {\r\n        controller = _newController;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _newController)"
      VariableDeclaration "_newController"
         Type: address
         Source: "address _newController"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        controller = _newController;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "controller = _newController"
        Assignment using operator =
           Type: address
           Source: "controller = _newController"
          Identifier controller
             Type: address
             Source: "controller"
          Identifier _newController
             Type: address
             Source: "_newController"
ContractDefinition "ControlledToken"
   Source: "contract ControlledToken is ERC20, Controlled {\r\n\r\n    uint256 constant MAX_UINT256 = 2**256 - 1;\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = '1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n    uint256 public totalSupply;\r\n\r\n    function ControlledToken(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol\r\n        )  {\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n    }\r\n\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onTransfer(msg.sender, _to, _value));\r\n        }\r\n\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        // Alerts the token controller of the transfer\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onTransfer(_from, _to, _value));\r\n        }\r\n\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n\r\n        // Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onApprove(msg.sender, _spender, _value));\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    ////////////////\r\n// Generate and destroy tokens\r\n////////////////\r\n\r\n    /// @notice Generates `_amount` tokens that are assigned to `_owner`\r\n    /// @param _owner The address that will be assigned the new tokens\r\n    /// @param _amount The quantity of tokens generated\r\n    /// @return True if the tokens are generated correctly\r\n    function generateTokens(address _owner, uint _amount ) onlyController returns (bool) {\r\n        uint curTotalSupply = totalSupply;\r\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\r\n        uint previousBalanceTo = balanceOf(_owner);\r\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\r\n        totalSupply = curTotalSupply + _amount;\r\n        balances[_owner]  = previousBalanceTo + _amount;\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @notice Burns `_amount` tokens from `_owner`\r\n    /// @param _owner The address that will lose the tokens\r\n    /// @param _amount The quantity of tokens to burn\r\n    /// @return True if the tokens are burned correctly\r\n    function destroyTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = totalSupply;\r\n        require(curTotalSupply >= _amount);\r\n        uint previousBalanceFrom = balanceOf(_owner);\r\n        require(previousBalanceFrom >= _amount);\r\n        totalSupply = curTotalSupply - _amount;\r\n        balances[_owner] = previousBalanceFrom - _amount;\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice The fallback function: If the contract's controller has not been\r\n    ///  set to 0, then the `proxyPayment` method is called which relays the\r\n    ///  ether and creates tokens as described in the token controller contract\r\n    function ()  payable {\r\n        require(isContract(controller));\r\n        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\r\n    }\r\n\r\n    /// @dev Internal function to determine if an address is a contract\r\n    /// @param _addr The address being queried\r\n    /// @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) onlyController {\r\n        if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ControlledToken token = ControlledToken(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        ClaimedTokens(_token, controller, balance);\r\n    }\r\n\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Controlled"
    UserDefinedTypeName "Controlled"
       Source: "Controlled"
  VariableDeclaration "MAX_UINT256"
     Type: uint256
     Gas costs: 3
     Source: "uint256 constant MAX_UINT256 = 2**256 - 1"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator -
       Type: int_const 1157...(70 digits omitted)...9935
       Source: "2**256 - 1"
      BinaryOperation using operator **
         Type: int_const 1157...(70 digits omitted)...9936
         Source: "2**256"
        Literal, token: [no token] value: 2
           Type: int_const 2
           Source: "2"
        Literal, token: [no token] value: 256
           Type: int_const 256
           Source: "256"
      Literal, token: [no token] value: 1
         Type: int_const 1
         Source: "1"
  EventDefinition "ClaimedTokens"
     Gas costs: 0
     Source: "event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);"
    ParameterList
       Source: "(address indexed _token, address indexed _controller, uint _amount)"
      VariableDeclaration "_token"
         Type: address
         Source: "address indexed _token"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_controller"
         Type: address
         Source: "address indexed _controller"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public name"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: [???]
     Source: "uint8 public decimals"
    ElementaryTypeName uint8
       Source: "uint8"
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public symbol"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "version"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public version = '1.0'"
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: 1.0
       Type: literal_string "1.0"
       Source: "'1.0'"
  VariableDeclaration "totalSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "ControlledToken" - public
     Source: "function ControlledToken(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol\r\n        )  {\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol\r\n        )"
      VariableDeclaration "_initialAmount"
         Type: uint256
         Source: "uint256 _initialAmount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_tokenName"
         Type: string memory
         Source: "string _tokenName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_decimalUnits"
         Type: uint8
         Source: "uint8 _decimalUnits"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "_tokenSymbol"
         Type: string memory
         Source: "string _tokenSymbol"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] = _initialAmount"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = _initialAmount"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _initialAmount
             Type: uint256
             Source: "_initialAmount"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = _initialAmount"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = _initialAmount"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _initialAmount
             Type: uint256
             Source: "_initialAmount"
      ExpressionStatement
         Gas costs: 0
         Source: "name = _tokenName"
        Assignment using operator =
           Type: string storage ref
           Source: "name = _tokenName"
          Identifier name
             Type: string storage ref
             Source: "name"
          Identifier _tokenName
             Type: string memory
             Source: "_tokenName"
      ExpressionStatement
         Gas costs: 0
         Source: "decimals = _decimalUnits"
        Assignment using operator =
           Type: uint8
           Source: "decimals = _decimalUnits"
          Identifier decimals
             Type: uint8
             Source: "decimals"
          Identifier _decimalUnits
             Type: uint8
             Source: "_decimalUnits"
      ExpressionStatement
         Gas costs: 0
         Source: "symbol = _tokenSymbol"
        Assignment using operator =
           Type: string storage ref
           Source: "symbol = _tokenSymbol"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
          Identifier _tokenSymbol
             Type: string memory
             Source: "_tokenSymbol"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onTransfer(msg.sender, _to, _value));\r\n        }\r\n\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        // Alerts the token controller of the transfer\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onTransfer(msg.sender, _to, _value));\r\n        }\r\n\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        // Alerts the token controller of the transfer\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 333
         Source: "require(balances[msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      IfStatement
         Source: "if (isContract(controller)) {\r\n            require(TokenController(controller).onTransfer(msg.sender, _to, _value));\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 254
           Source: "isContract(controller)"
          Identifier isContract
             Type: function (address) view returns (bool)
             Source: "isContract"
          Identifier controller
             Type: address
             Source: "controller"
        Block
           Source: "{\r\n            require(TokenController(controller).onTransfer(msg.sender, _to, _value));\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(TokenController(controller).onTransfer(msg.sender, _to, _value))"
            FunctionCall
               Type: tuple()
               Source: "require(TokenController(controller).onTransfer(msg.sender, _to, _value))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "TokenController(controller).onTransfer(msg.sender, _to, _value)"
                MemberAccess to member onTransfer
                   Type: function (address,address,uint256) external returns (bool)
                   Source: "TokenController(controller).onTransfer"
                  FunctionCall
                     Type: contract TokenController
                     Source: "TokenController(controller)"
                    Identifier TokenController
                       Type: type(contract TokenController)
                       Source: "TokenController"
                    Identifier controller
                       Type: address
                       Source: "controller"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Identifier _to
                   Type: address
                   Source: "_to"
                Identifier _value
                   Type: uint256
                   Source: "_value"
      ExpressionStatement
         Gas costs: 20328
         Source: "balances[msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onTransfer(_from, _to, _value));\r\n        }\r\n\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onTransfer(_from, _to, _value));\r\n        }\r\n\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 396
         Source: "uint256 allowance = allowed[_from][msg.sender]"
        VariableDeclaration "allowance"
           Type: uint256
           Source: "uint256 allowance"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "allowed[_from][msg.sender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_from]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _from
               Type: address
               Source: "_from"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 362
         Source: "require(balances[_from] >= _value && allowance >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_from] >= _value && allowance >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "balances[_from] >= _value && allowance >= _value"
            BinaryOperation using operator >=
               Type: bool
               Source: "balances[_from] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            BinaryOperation using operator >=
               Type: bool
               Source: "allowance >= _value"
              Identifier allowance
                 Type: uint256
                 Source: "allowance"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      IfStatement
         Source: "if (isContract(controller)) {\r\n            require(TokenController(controller).onTransfer(_from, _to, _value));\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 254
           Source: "isContract(controller)"
          Identifier isContract
             Type: function (address) view returns (bool)
             Source: "isContract"
          Identifier controller
             Type: address
             Source: "controller"
        Block
           Source: "{\r\n            require(TokenController(controller).onTransfer(_from, _to, _value));\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(TokenController(controller).onTransfer(_from, _to, _value))"
            FunctionCall
               Type: tuple()
               Source: "require(TokenController(controller).onTransfer(_from, _to, _value))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "TokenController(controller).onTransfer(_from, _to, _value)"
                MemberAccess to member onTransfer
                   Type: function (address,address,uint256) external returns (bool)
                   Source: "TokenController(controller).onTransfer"
                  FunctionCall
                     Type: contract TokenController
                     Source: "TokenController(controller)"
                    Identifier TokenController
                       Type: type(contract TokenController)
                       Source: "TokenController"
                    Identifier controller
                       Type: address
                       Source: "controller"
                Identifier _from
                   Type: address
                   Source: "_from"
                Identifier _to
                   Type: address
                   Source: "_to"
                Identifier _value
                   Type: uint256
                   Source: "_value"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balances[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      IfStatement
         Source: "if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 6
           Source: "allowance < MAX_UINT256"
          Identifier allowance
             Type: uint256
             Source: "allowance"
          Identifier MAX_UINT256
             Type: uint256
             Source: "MAX_UINT256"
        Block
           Source: "{\r\n            allowed[_from][msg.sender] -= _value;\r\n        }"
          ExpressionStatement
             Gas costs: 20418
             Source: "allowed[_from][msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "allowed[_from][msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balances[_owner];\r\n    }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success) {\r\n\r\n        // Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onApprove(msg.sender, _spender, _value));\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n        // Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onApprove(msg.sender, _spender, _value));\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (isContract(controller)) {\r\n            require(TokenController(controller).onApprove(msg.sender, _spender, _value));\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 254
           Source: "isContract(controller)"
          Identifier isContract
             Type: function (address) view returns (bool)
             Source: "isContract"
          Identifier controller
             Type: address
             Source: "controller"
        Block
           Source: "{\r\n            require(TokenController(controller).onApprove(msg.sender, _spender, _value));\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(TokenController(controller).onApprove(msg.sender, _spender, _value))"
            FunctionCall
               Type: tuple()
               Source: "require(TokenController(controller).onApprove(msg.sender, _spender, _value))"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "TokenController(controller).onApprove(msg.sender, _spender, _value)"
                MemberAccess to member onApprove
                   Type: function (address,address,uint256) external returns (bool)
                   Source: "TokenController(controller).onApprove"
                  FunctionCall
                     Type: contract TokenController
                     Source: "TokenController(controller)"
                    Identifier TokenController
                       Type: type(contract TokenController)
                       Source: "TokenController"
                    Identifier controller
                       Type: address
                       Source: "controller"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
                Identifier _value
                   Type: uint256
                   Source: "_value"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  FunctionDefinition "generateTokens" - public
     Source: "function generateTokens(address _owner, uint _amount ) onlyController returns (bool) {\r\n        uint curTotalSupply = totalSupply;\r\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\r\n        uint previousBalanceTo = balanceOf(_owner);\r\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\r\n        totalSupply = curTotalSupply + _amount;\r\n        balances[_owner]  = previousBalanceTo + _amount;\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, uint _amount )"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        uint curTotalSupply = totalSupply;\r\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\r\n        uint previousBalanceTo = balanceOf(_owner);\r\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\r\n        totalSupply = curTotalSupply + _amount;\r\n        balances[_owner]  = previousBalanceTo + _amount;\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 211
         Source: "uint curTotalSupply = totalSupply"
        VariableDeclaration "curTotalSupply"
           Type: uint256
           Source: "uint curTotalSupply"
          ElementaryTypeName uint
             Source: "uint"
        Identifier totalSupply
           Type: uint256
           Source: "totalSupply"
      ExpressionStatement
         Gas costs: 44
         Source: "require(curTotalSupply + _amount >= curTotalSupply)"
        FunctionCall
           Type: tuple()
           Source: "require(curTotalSupply + _amount >= curTotalSupply)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "curTotalSupply + _amount >= curTotalSupply"
            BinaryOperation using operator +
               Type: uint256
               Source: "curTotalSupply + _amount"
              Identifier curTotalSupply
                 Type: uint256
                 Source: "curTotalSupply"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
            Identifier curTotalSupply
               Type: uint256
               Source: "curTotalSupply"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint previousBalanceTo = balanceOf(_owner)"
        VariableDeclaration "previousBalanceTo"
           Type: uint256
           Source: "uint previousBalanceTo"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "balanceOf(_owner)"
          Identifier balanceOf
             Type: function (address) view returns (uint256)
             Source: "balanceOf"
          Identifier _owner
             Type: address
             Source: "_owner"
      ExpressionStatement
         Gas costs: 44
         Source: "require(previousBalanceTo + _amount >= previousBalanceTo)"
        FunctionCall
           Type: tuple()
           Source: "require(previousBalanceTo + _amount >= previousBalanceTo)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "previousBalanceTo + _amount >= previousBalanceTo"
            BinaryOperation using operator +
               Type: uint256
               Source: "previousBalanceTo + _amount"
              Identifier previousBalanceTo
                 Type: uint256
                 Source: "previousBalanceTo"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
            Identifier previousBalanceTo
               Type: uint256
               Source: "previousBalanceTo"
      ExpressionStatement
         Gas costs: 20020
         Source: "totalSupply = curTotalSupply + _amount"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = curTotalSupply + _amount"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          BinaryOperation using operator +
             Type: uint256
             Source: "curTotalSupply + _amount"
            Identifier curTotalSupply
               Type: uint256
               Source: "curTotalSupply"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 20116
         Source: "balances[_owner]  = previousBalanceTo + _amount"
        Assignment using operator =
           Type: uint256
           Source: "balances[_owner]  = previousBalanceTo + _amount"
          IndexAccess
             Type: uint256
             Source: "balances[_owner]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _owner
               Type: address
               Source: "_owner"
          BinaryOperation using operator +
             Type: uint256
             Source: "previousBalanceTo + _amount"
            Identifier previousBalanceTo
               Type: uint256
               Source: "previousBalanceTo"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(0, _owner, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(0, _owner, _amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Identifier _owner
             Type: address
             Source: "_owner"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "destroyTokens" - public
     Source: "function destroyTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = totalSupply;\r\n        require(curTotalSupply >= _amount);\r\n        uint previousBalanceFrom = balanceOf(_owner);\r\n        require(previousBalanceFrom >= _amount);\r\n        totalSupply = curTotalSupply - _amount;\r\n        balances[_owner] = previousBalanceFrom - _amount;\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, uint _amount\r\n    )"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        uint curTotalSupply = totalSupply;\r\n        require(curTotalSupply >= _amount);\r\n        uint previousBalanceFrom = balanceOf(_owner);\r\n        require(previousBalanceFrom >= _amount);\r\n        totalSupply = curTotalSupply - _amount;\r\n        balances[_owner] = previousBalanceFrom - _amount;\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 211
         Source: "uint curTotalSupply = totalSupply"
        VariableDeclaration "curTotalSupply"
           Type: uint256
           Source: "uint curTotalSupply"
          ElementaryTypeName uint
             Source: "uint"
        Identifier totalSupply
           Type: uint256
           Source: "totalSupply"
      ExpressionStatement
         Gas costs: 38
         Source: "require(curTotalSupply >= _amount)"
        FunctionCall
           Type: tuple()
           Source: "require(curTotalSupply >= _amount)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "curTotalSupply >= _amount"
            Identifier curTotalSupply
               Type: uint256
               Source: "curTotalSupply"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint previousBalanceFrom = balanceOf(_owner)"
        VariableDeclaration "previousBalanceFrom"
           Type: uint256
           Source: "uint previousBalanceFrom"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "balanceOf(_owner)"
          Identifier balanceOf
             Type: function (address) view returns (uint256)
             Source: "balanceOf"
          Identifier _owner
             Type: address
             Source: "_owner"
      ExpressionStatement
         Gas costs: 38
         Source: "require(previousBalanceFrom >= _amount)"
        FunctionCall
           Type: tuple()
           Source: "require(previousBalanceFrom >= _amount)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "previousBalanceFrom >= _amount"
            Identifier previousBalanceFrom
               Type: uint256
               Source: "previousBalanceFrom"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 20020
         Source: "totalSupply = curTotalSupply - _amount"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = curTotalSupply - _amount"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          BinaryOperation using operator -
             Type: uint256
             Source: "curTotalSupply - _amount"
            Identifier curTotalSupply
               Type: uint256
               Source: "curTotalSupply"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 20116
         Source: "balances[_owner] = previousBalanceFrom - _amount"
        Assignment using operator =
           Type: uint256
           Source: "balances[_owner] = previousBalanceFrom - _amount"
          IndexAccess
             Type: uint256
             Source: "balances[_owner]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _owner
               Type: address
               Source: "_owner"
          BinaryOperation using operator -
             Type: uint256
             Source: "previousBalanceFrom - _amount"
            Identifier previousBalanceFrom
               Type: uint256
               Source: "previousBalanceFrom"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_owner, 0, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_owner, 0, _amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _owner
             Type: address
             Source: "_owner"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "" - public
     Source: "function ()  payable {\r\n        require(isContract(controller));\r\n        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(isContract(controller));\r\n        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\r\n    }"
      ExpressionStatement
         Gas costs: 269
         Source: "require(isContract(controller))"
        FunctionCall
           Type: tuple()
           Source: "require(isContract(controller))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "isContract(controller)"
            Identifier isContract
               Type: function (address) view returns (bool)
               Source: "isContract"
            Identifier controller
               Type: address
               Source: "controller"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))"
        FunctionCall
           Type: tuple()
           Source: "require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "TokenController(controller).proxyPayment.value(msg.value)(msg.sender)"
            FunctionCall
               Type: function (address) payable external returns (bool)
               Source: "TokenController(controller).proxyPayment.value(msg.value)"
              MemberAccess to member value
                 Type: function (uint256) returns (function (address) payable external returns (bool))
                 Source: "TokenController(controller).proxyPayment.value"
                MemberAccess to member proxyPayment
                   Type: function (address) payable external returns (bool)
                   Source: "TokenController(controller).proxyPayment"
                  FunctionCall
                     Type: contract TokenController
                     Source: "TokenController(controller)"
                    Identifier TokenController
                       Type: type(contract TokenController)
                       Source: "TokenController"
                    Identifier controller
                       Type: address
                       Source: "controller"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "isContract" - const
     Source: "function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _addr)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint size"
        VariableDeclaration "size"
           Type: uint256
           Source: "uint size"
          ElementaryTypeName uint
             Source: "uint"
      IfStatement
         Source: "if (_addr == 0) return false"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 15
           Source: "_addr == 0"
          Identifier _addr
             Type: address
             Source: "_addr"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return"
      Return
         Gas costs: 14
         Source: "return size>0"
        BinaryOperation using operator >
           Type: bool
           Source: "size>0"
          Identifier size
             Type: uint256
             Source: "size"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "claimTokens" - public
     Source: "function claimTokens(address _token) onlyController {\r\n        if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ControlledToken token = ControlledToken(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        ClaimedTokens(_token, controller, balance);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _token)"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ControlledToken token = ControlledToken(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        ClaimedTokens(_token, controller, balance);\r\n    }"
      IfStatement
         Source: "if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 15
           Source: "_token == 0x0"
          Identifier _token
             Type: address
             Source: "_token"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
        Block
           Source: "{\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "controller.transfer(this.balance)"
            FunctionCall
               Type: tuple()
               Source: "controller.transfer(this.balance)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "controller.transfer"
                Identifier controller
                   Type: address
                   Source: "controller"
              MemberAccess to member balance
                 Type: uint256
                 Source: "this.balance"
                Identifier this
                   Type: contract ControlledToken
                   Source: "this"
          Return
             Gas costs: 11
             Source: "return;"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "ControlledToken token = ControlledToken(_token)"
        VariableDeclaration "token"
           Type: contract ControlledToken
           Source: "ControlledToken token"
          UserDefinedTypeName "ControlledToken"
             Source: "ControlledToken"
        FunctionCall
           Type: contract ControlledToken
           Source: "ControlledToken(_token)"
          Identifier ControlledToken
             Type: type(contract ControlledToken)
             Source: "ControlledToken"
          Identifier _token
             Type: address
             Source: "_token"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint balance = token.balanceOf(this)"
        VariableDeclaration "balance"
           Type: uint256
           Source: "uint balance"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "token.balanceOf(this)"
          MemberAccess to member balanceOf
             Type: function (address) view external returns (uint256)
             Source: "token.balanceOf"
            Identifier token
               Type: contract ControlledToken
               Source: "token"
          Identifier this
             Type: contract ControlledToken
             Source: "this"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.transfer(controller, balance)"
        FunctionCall
           Type: bool
           Source: "token.transfer(controller, balance)"
          MemberAccess to member transfer
             Type: function (address,uint256) external returns (bool)
             Source: "token.transfer"
            Identifier token
               Type: contract ControlledToken
               Source: "token"
          Identifier controller
             Type: address
             Source: "controller"
          Identifier balance
             Type: uint256
             Source: "balance"
      ExpressionStatement
         Gas costs: [???]
         Source: "ClaimedTokens(_token, controller, balance)"
        FunctionCall
           Type: tuple()
           Source: "ClaimedTokens(_token, controller, balance)"
          Identifier ClaimedTokens
             Type: function (address,address,uint256)
             Source: "ClaimedTokens"
          Identifier _token
             Type: address
             Source: "_token"
          Identifier controller
             Type: address
             Source: "controller"
          Identifier balance
             Type: uint256
             Source: "balance"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balances"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "IZXToken"
   Source: "contract IZXToken is ControlledToken {\r\n\r\n   function IZXToken() ControlledToken( 1, 'IZX Token', 18, 'IZX' ) public {}\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ControlledToken"
    UserDefinedTypeName "ControlledToken"
       Source: "ControlledToken"
  FunctionDefinition "IZXToken" - public
     Source: "function IZXToken() ControlledToken( 1, 'IZX Token', 18, 'IZX' ) public {}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ControlledToken"
       Gas costs: 0
       Source: "ControlledToken( 1, 'IZX Token', 18, 'IZX' )"
      Identifier ControlledToken
         Type: type(contract ControlledToken)
         Source: "ControlledToken"
      Literal, token: [no token] value: 1
         Type: int_const 1
         Source: "1"
      Literal, token: [no token] value: IZX Token
         Type: literal_string "IZX Token"
         Source: "'IZX Token'"
      Literal, token: [no token] value: 18
         Type: int_const 18
         Source: "18"
      Literal, token: [no token] value: IZX
         Type: literal_string "IZX"
         Source: "'IZX'"
    Block
       Gas costs: 0
       Source: "{}"
