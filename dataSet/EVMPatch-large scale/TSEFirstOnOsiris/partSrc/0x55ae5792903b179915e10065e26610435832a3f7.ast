Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x55ae5792903b179915e10065e26610435832a3f7.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "owned"
   Source: "contract owned {\r\n\r\n\taddress public owner;\r\n\r\n\tfunction owned() {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner {\r\n\t\tif (msg.sender != owner) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address newOwner) onlyOwner {\r\n\t\towner = newOwner;\r\n\t}\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: 335
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "owned" - public
     Source: "function owned() {\r\n\t\towner = msg.sender;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\towner = msg.sender;\r\n\t}"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner {\r\n\t\tif (msg.sender != owner) throw;\r\n\t\t_;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tif (msg.sender != owner) throw;\r\n\t\t_;\r\n\t}"
      IfStatement
         Source: "if (msg.sender != owner) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 2590
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Throw
           Gas costs: 60
           Source: "throw"
      PlaceholderStatement
         Gas costs: 1
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) onlyOwner {\r\n\t\towner = newOwner;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n\t\towner = newOwner;\r\n\t}"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
ContractDefinition "tokenRecipient"
   Gas costs: 0
   Source: "contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }"
  FunctionDefinition "receiveApproval" - public
     Source: "function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);"
    ParameterList
       Source: "(address _from, uint256 _value, address _token, bytes _extraData)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: ""
ContractDefinition "ICofounditToken"
   Gas costs: 0
   Source: "contract ICofounditToken {\r\n\tfunction mintTokens(address _to, uint256 _amount, string _reason);\r\n\tfunction totalSupply() constant returns (uint256 totalSupply);\r\n}"
  FunctionDefinition "mintTokens" - public
     Source: "function mintTokens(address _to, uint256 _amount, string _reason);"
    ParameterList
       Source: "(address _to, uint256 _amount, string _reason)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_reason"
         Type: string memory
         Source: "string _reason"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Source: ""
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() constant returns (uint256 totalSupply);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256 totalSupply)"
      VariableDeclaration "totalSupply"
         Type: uint256
         Source: "uint256 totalSupply"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "CofounditICO"
   Source: "contract CofounditICO is owned{\r\n\r\n\tuint256 public startBlock;\r\n\tuint256 public endBlock;\r\n\tuint256 public minEthToRaise;\r\n\tuint256 public maxEthToRaise;\r\n\tuint256 public totalEthRaised;\r\n\taddress public multisigAddress;\r\n\r\n\tuint256 public icoSupply;\r\n\tuint256 public strategicReserveSupply;\r\n\tuint256 public cashilaTokenSupply;\r\n\tuint256 public iconomiTokenSupply;\r\n\tuint256 public coreTeamTokenSupply;\r\n\r\n\tICofounditToken cofounditTokenContract;\t\r\n\tmapping (address => bool) presaleContributorAllowance;\r\n\tuint256 nextFreeParticipantIndex;\r\n\tmapping (uint => address) participantIndex;\r\n\tmapping (address => uint256) participantContribution;\r\n\r\n\tuint256 usedIcoSupply;\r\n\tuint256 usedStrategicReserveSupply;\r\n\tuint256 usedCashilaTokenSupply;\r\n\tuint256 usedIconomiTokenSupply;\r\n\tuint256 usedCoreTeamTokenSupply;\r\n\r\n\tbool icoHasStarted;\r\n\tbool minTresholdReached;\r\n\tbool icoHasSucessfulyEnded;\r\n\r\n\tuint256 lastEthReturnIndex;\r\n\tmapping (address => bool) hasClaimedEthWhenFail;\r\n\tuint256 lastCfiIssuanceIndex;\r\n\r\n\tstring icoStartedMessage = \"Cofoundit is launching!\";\r\n\tstring icoMinTresholdReachedMessage = \"Firing Stage 2!\";\r\n\tstring icoEndedSuccessfulyMessage = \"Orbit achieved!\";\r\n\tstring icoEndedSuccessfulyWithCapMessage = \"Leaving Earth orbit!\";\r\n\tstring icoFailedMessage = \"Rocket crashed.\";\r\n\r\n\tevent ICOStarted(uint256 _blockNumber, string _message);\r\n\tevent ICOMinTresholdReached(uint256 _blockNumber, string _message);\r\n\tevent ICOEndedSuccessfuly(uint256 _blockNumber, uint256 _amountRaised, string _message);\r\n\tevent ICOFailed(uint256 _blockNumber, uint256 _ammountRaised, string _message);\r\n\tevent ErrorSendingETH(address _from, uint256 _amount);\r\n\r\n\tfunction CofounditICO(uint256 _startBlock, uint256 _endBlock, address _multisigAddress) {\r\n\t\tstartBlock = _startBlock;\r\n\t\tendBlock = _endBlock;\r\n\t\tminEthToRaise = 4525 * 10**18;\r\n\t\tmaxEthToRaise = 56565 * 10**18;\r\n\t\tmultisigAddress = _multisigAddress;\r\n\r\n\t\ticoSupply =\t \t\t\t\t125000000 * 10**18;\r\n\t\tstrategicReserveSupply = \t125000000 * 10**18;\r\n\t\tcashilaTokenSupply = \t\t100000000 * 10**18;\r\n\t\ticonomiTokenSupply = \t\t50000000 * 10**18;\r\n\t\tcoreTeamTokenSupply =\t\t100000000 * 10**18;\r\n\t}\r\n\r\n\t// \t\r\n\t/* User accessible methods */ \t\r\n\t// \t\r\n\r\n\t/* Users send ETH and enter the crowdsale*/ \t\r\n\tfunction () payable { \t\t\r\n\t\tif (msg.value == 0) throw;  \t\t\t\t\t\t\t\t\t\t\t\t// Check if balance is not 0 \t\t\r\n\t\tif (icoHasSucessfulyEnded || block.number > endBlock) throw;\t\t\t\t// Throw if ico has already ended \t\t\r\n\t\tif (!icoHasStarted){\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if this is the first transaction of ico \t\t\t\r\n\t\t\tif (block.number < startBlock){\t\t\t\t\t\t\t\t\t\t\t// Check if ico should start \t\t\t\t\r\n\t\t\t\tif (!presaleContributorAllowance[msg.sender]) throw;\t\t\t\t// Check if this address is part of presale contributors \t\t\t\r\n\t\t\t} \t\t\t\r\n\t\t\telse{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If ICO should start \t\t\t\t\r\n\t\t\t\ticoHasStarted = true;\t\t\t\t\t\t\t\t\t\t\t\t// Set that ico has started \t\t\t\t\r\n\t\t\t\tICOStarted(block.number, icoStartedMessage);\t\t\t\t\t\t// Raise event \t\t\t\r\n\t\t\t} \t\t\r\n\t\t} \t\t\r\n\t\tif (participantContribution[msg.sender] == 0){ \t\t\t\t\t\t\t\t// Check if sender is a new user \t\t\t\r\n\t\t\tparticipantIndex[nextFreeParticipantIndex] = msg.sender;\t\t\t\t// Add new user to participant data structure \t\t\t\r\n\t\t\tnextFreeParticipantIndex += 1; \t\t\r\n\t\t} \t\t\r\n\t\tif (maxEthToRaise > (totalEthRaised + msg.value)){\t\t\t\t\t\t\t// Check if user sent to much eth \t\t\t\r\n\t\t\tparticipantContribution[msg.sender] += msg.value;\t\t\t\t\t\t// Add accounts contribution \t\t\t\r\n\t\t\ttotalEthRaised += msg.value;\t\t\t\t\t\t\t\t\t\t\t// Add to total eth Raised \t\t\t\r\n\t\t\tif (!minTresholdReached && totalEthRaised >= minEthToRaise){\t\t\t// Check if min treshold has been reached(Do that one time) \t\t\t\t\r\n\t\t\t\tICOMinTresholdReached(block.number, icoMinTresholdReachedMessage);\t// Raise event \t\t\t\t\r\n\t\t\t\tminTresholdReached = true;\t\t\t\t\t\t\t\t\t\t\t// Set that treshold has been reached \t\t\t\r\n\t\t\t} \t\t\r\n\t\t}else{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If user sent to much eth \t\t\t\r\n\t\t\tuint maxContribution = maxEthToRaise - totalEthRaised; \t\t\t\t\t// Calculate max contribution \t\t\t\r\n\t\t\tparticipantContribution[msg.sender] += maxContribution;\t\t\t\t\t// Add max contribution to account \t\t\t\r\n\t\t\ttotalEthRaised += maxContribution;\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\tuint toReturn = msg.value - maxContribution;\t\t\t\t\t\t\t// Calculate how much user should get back \t\t\t\r\n\t\t\ticoHasSucessfulyEnded = true;\t\t\t\t\t\t\t\t\t\t\t// Set that ico has successfullyEnded \t\t\t\r\n\t\t\tICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyWithCapMessage); \t\t\t\r\n\t\t\tif(!msg.sender.send(toReturn)){\t\t\t\t\t\t\t\t\t\t\t// Refound balance that is over the cap \t\t\t\t\r\n\t\t\t\tErrorSendingETH(msg.sender, toReturn);\t\t\t\t\t\t\t\t// Raise event for manual return if transaction throws \t\t\t\r\n\t\t\t} \t\t\r\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Feel good about achiving the cap \t\r\n\t} \t\r\n\r\n\t/* Users can claim eth by themself if they want to in instance of eth faliure*/ \t\r\n\tfunction claimEthIfFailed(){ \t\t\r\n\t\tif (block.number <= endBlock || totalEthRaised >= minEthToRaise) throw;\t// Check that ico has failed :( \t\t\r\n\t\tif (participantContribution[msg.sender] == 0) throw;\t\t\t\t\t// Check if user has even been at crowdsale \t\t\r\n\t\tif (hasClaimedEthWhenFail[msg.sender]) throw;\t\t\t\t\t\t\t// Check if this account has already claimed its eth \t\t\r\n\t\tuint256 ethContributed = participantContribution[msg.sender];\t\t\t// Get participant eth Contribution \t\t\r\n\t\thasClaimedEthWhenFail[msg.sender] = true; \t\t\r\n\t\tif (!msg.sender.send(ethContributed)){ \t\t\t\r\n\t\t\tErrorSendingETH(msg.sender, ethContributed);\t\t\t\t\t\t// Raise event if send failed and resolve manually \t\t\r\n\t\t} \t\r\n\t} \t\r\n\r\n\t// \t\r\n\t/* Only owner methods */ \t\r\n\t// \t\r\n\r\n\t/* Adds addresses that are allowed to take part in presale */ \t\r\n\tfunction addPresaleContributors(address[] _presaleContributors) onlyOwner { \t\t\r\n\t\tfor (uint cnt = 0; cnt < _presaleContributors.length; cnt++){ \t\t\t\r\n\t\t\tpresaleContributorAllowance[_presaleContributors[cnt]] = true; \t\t\r\n\t\t} \t\r\n\t} \t\r\n\r\n\t/* Owner can issue new tokens in token contract */ \t\r\n\tfunction batchIssueTokens(uint256 _numberOfIssuances) onlyOwner{ \t\t\r\n\t\tif (!icoHasSucessfulyEnded) throw;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if ico has ended \t\t\r\n\t\taddress currentParticipantAddress; \t\t\r\n\t\tuint256 tokensToBeIssued; \t\t\r\n\t\tfor (uint cnt = 0; cnt < _numberOfIssuances; cnt++){ \t\t\t\r\n\t\t\tcurrentParticipantAddress = participantIndex[lastCfiIssuanceIndex];\t// Get next participant address\r\n\t\t\tif (currentParticipantAddress == 0x0) continue; \t\t\t\r\n\t\t\ttokensToBeIssued = icoSupply * participantContribution[currentParticipantAddress] / totalEthRaised;\t\t// Calculate how much tokens will address get \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(currentParticipantAddress, tokensToBeIssued, \"Ico participation mint\");\t// Mint tokens @ CofounditToken \t\t\t\r\n\t\t\tlastCfiIssuanceIndex += 1;\t\r\n\t\t} \r\n\r\n\t\tif (participantIndex[lastCfiIssuanceIndex] == 0x0 && cofounditTokenContract.totalSupply() < icoSupply){\r\n\t\t\tuint divisionDifference = icoSupply - cofounditTokenContract.totalSupply();\r\n\t\t\tcofounditTokenContract.mintTokens(multisigAddress, divisionDifference, \"Mint division error\");\t// Mint divison difference @ CofounditToken so that total supply is whole number\t\t\t\r\n\t\t}\r\n\t} \t\r\n\r\n\t/* Owner can return eth for multiple users in one call*/ \t\r\n\tfunction batchReturnEthIfFailed(uint256 _numberOfReturns) onlyOwner{ \t\t\r\n\t\tif (block.number < endBlock || totalEthRaised >= minEthToRaise) throw;\t\t// Check that ico has failed :( \t\t\r\n\t\taddress currentParticipantAddress; \t\t\r\n\t\tuint256 contribution;\r\n\t\tfor (uint cnt = 0; cnt < _numberOfReturns; cnt++){ \t\t\t\r\n\t\t\tcurrentParticipantAddress = participantIndex[lastEthReturnIndex];\t\t// Get next account \t\t\t\r\n\t\t\tif (currentParticipantAddress == 0x0) return;\t\t\t\t\t\t\t// If all the participants were reinbursed return \t\t\t\r\n\t\t\tif (!hasClaimedEthWhenFail[currentParticipantAddress]) {\t\t\t\t// Check if user has manually recovered eth \t\t\t\t\r\n\t\t\t\tcontribution = participantContribution[currentParticipantAddress];\t// Get accounts contribution \t\t\t\t\r\n\t\t\t\thasClaimedEthWhenFail[msg.sender] = true;\t\t\t\t\t\t\t// Set that user got his eth back \t\t\t\t\r\n\t\t\t\tif (!currentParticipantAddress.send(contribution)){\t\t\t\t\t// Send fund back to account \t\t\t\t\t\r\n\t\t\t\t\tErrorSendingETH(currentParticipantAddress, contribution);\t\t// Raise event if send failed and resolve manually \t\t\t\t\r\n\t\t\t\t} \t\t\t\r\n\t\t\t} \t\t\t\r\n\t\t\tlastEthReturnIndex += 1; \t\t\r\n\t\t} \t\r\n\t} \t\r\n\r\n\t/* Owner sets new address of CofounditToken */\r\n\tfunction changeMultisigAddress(address _newAddress) onlyOwner { \t\t\r\n\t\tmultisigAddress = _newAddress;\r\n\t} \t\r\n\r\n\t/* Owner can claim reserved tokens on the end of crowsale */ \t\r\n\tfunction claimReservedTokens(string _which, address _to, uint256 _amount, string _reason) onlyOwner{ \t\t\r\n\t\tif (!icoHasSucessfulyEnded) throw;                 \r\n\t\tbytes32 hashedStr = sha3(_which);\t\t\t\t\r\n\t\tif (hashedStr == sha3(\"Reserve\")){ \t\t\t\r\n\t\t\tif (_amount > strategicReserveSupply - usedStrategicReserveSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, _reason); \t\t\t\r\n\t\t\tusedStrategicReserveSupply += _amount; \t\t\r\n\t\t} \t\t\r\n\t\telse if (hashedStr == sha3(\"Cashila\")){ \t\t\t\r\n\t\t\tif (_amount > cashilaTokenSupply - usedCashilaTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cashila\"); \t\t\t\r\n\t\t\tusedCashilaTokenSupply += _amount; \t\t} \t\t\r\n\t\telse if (hashedStr == sha3(\"Iconomi\")){ \t\t\t\r\n\t\t\tif (_amount > iconomiTokenSupply - usedIconomiTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for iconomi\"); \t\t\t\r\n\t\t\tusedIconomiTokenSupply += _amount; \t\t\r\n\t\t}\r\n\t\telse if (hashedStr == sha3(\"Core\")){ \t\t\t\r\n\t\t\tif (_amount > coreTeamTokenSupply - usedCoreTeamTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cofoundit team\"); \t\t\t\r\n\t\t\tusedCoreTeamTokenSupply += _amount; \t\t\r\n\t\t} \t\t\r\n\t\telse throw; \t\r\n\t} \t\r\n\r\n\t/* Owner can remove allowance of designated presale contributor */ \t\r\n\tfunction removePresaleContributor(address _presaleContributor) onlyOwner { \t\t\r\n\t\tpresaleContributorAllowance[_presaleContributor] = false; \t\r\n\t} \t\r\n\r\n\t/* Set token contract where mints will be done (tokens will be issued)*/ \t\r\n\tfunction setTokenContract(address _cofounditContractAddress) onlyOwner { \t\t\r\n\t\tcofounditTokenContract = ICofounditToken(_cofounditContractAddress); \t\r\n\t} \t\r\n\r\n\t/* Withdraw funds from contract */ \t\r\n\tfunction withdrawEth() onlyOwner{ \t\t\r\n\t\tif (this.balance == 0) throw;\t\t\t\t// Check if there is something on the contract \t\t\r\n\t\tif (totalEthRaised < minEthToRaise) throw;\t// Check if minEth treshold is surpassed \t\t\r\n\t\tif (block.number > endBlock){\t\t\t\t// Check if ico has ended withouth reaching the maxCap \t\t\t\r\n\t\t\ticoHasSucessfulyEnded = true; \t\t\t\r\n\t\t\tICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyMessage); \t\t\r\n\t\t} \t\t\r\n\t\tif(multisigAddress.send(this.balance)){}\t\t// Send contracts whole balance to multisig address \t\r\n\t} \t\r\n\r\n\t/* Withdraw remaining balance to manually return where contracts send has failed */ \t\r\n\tfunction withdrawRemainingBalanceForManualRecovery() onlyOwner{ \t\t\r\n\t\tif (this.balance == 0) throw;\t\t\t\t\t\t\t\t\t\t\t// Check if there is something on the contract \t\t\r\n\t\tif (block.number < endBlock || totalEthRaised >= minEthToRaise) throw;\t// Check if ico has failed :( \t\t\r\n\t\tif (participantIndex[lastEthReturnIndex] != 0x0) throw;\t\t\t\t\t// Check if all the participants has been reinbursed \t\t\r\n\t\tif(multisigAddress.send(this.balance)){}\t\t\t\t\t\t\t\t// Send remainder so it can be manually processed \t\r\n\t} \t\r\n\r\n\t// \t\r\n\t/* Getters */ \t\r\n\t// \t\r\n\r\n\tfunction getCfiEstimation(address _querryAddress) constant returns (uint256 answer){ \t\t\r\n\t\treturn icoSupply * participantContribution[_querryAddress] / totalEthRaised; \t\r\n\t} \t\r\n\r\n\tfunction getCofounditTokenAddress() constant returns(address _tokenAddress){ \t\t\r\n\t\treturn address(cofounditTokenContract); \t\r\n\t} \t\r\n\r\n\tfunction icoInProgress() constant returns (bool answer){ \t\t\r\n\t\treturn icoHasStarted && !icoHasSucessfulyEnded; \t\r\n\t} \t\r\n\r\n\tfunction isAddressAllowedInPresale(address _querryAddress) constant returns (bool answer){ \t\t\r\n\t\treturn presaleContributorAllowance[_querryAddress]; \t\r\n\t} \t\r\n\r\n\tfunction participantContributionInEth(address _querryAddress) constant returns (uint256 answer){ \t\t\r\n\t\treturn participantContribution[_querryAddress]; \t\r\n\t}\r\n\r\n\t//\r\n\t/* This part is here only for testing and will not be included into final version */\r\n\t//\r\n\t//function killContract() onlyOwner{\r\n\t//\tselfdestruct(msg.sender);\r\n\t//}\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "owned"
    UserDefinedTypeName "owned"
       Source: "owned"
  VariableDeclaration "startBlock"
     Type: uint256
     Gas costs: 287
     Source: "uint256 public startBlock"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "endBlock"
     Type: uint256
     Gas costs: 287
     Source: "uint256 public endBlock"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "minEthToRaise"
     Type: uint256
     Gas costs: 287
     Source: "uint256 public minEthToRaise"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "maxEthToRaise"
     Type: uint256
     Gas costs: 287
     Source: "uint256 public maxEthToRaise"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "totalEthRaised"
     Type: uint256
     Gas costs: 287
     Source: "uint256 public totalEthRaised"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "multisigAddress"
     Type: address
     Gas costs: 335
     Source: "address public multisigAddress"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "icoSupply"
     Type: uint256
     Gas costs: 287
     Source: "uint256 public icoSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "strategicReserveSupply"
     Type: uint256
     Gas costs: 287
     Source: "uint256 public strategicReserveSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "cashilaTokenSupply"
     Type: uint256
     Gas costs: 287
     Source: "uint256 public cashilaTokenSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "iconomiTokenSupply"
     Type: uint256
     Gas costs: 287
     Source: "uint256 public iconomiTokenSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "coreTeamTokenSupply"
     Type: uint256
     Gas costs: 287
     Source: "uint256 public coreTeamTokenSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "cofounditTokenContract"
     Type: contract ICofounditToken
     Gas costs: 0
     Source: "ICofounditToken cofounditTokenContract"
    UserDefinedTypeName "ICofounditToken"
       Source: "ICofounditToken"
  VariableDeclaration "presaleContributorAllowance"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping (address => bool) presaleContributorAllowance"
    Mapping
       Source: "mapping (address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "nextFreeParticipantIndex"
     Type: uint256
     Gas costs: 0
     Source: "uint256 nextFreeParticipantIndex"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "participantIndex"
     Type: mapping(uint256 => address)
     Gas costs: 0
     Source: "mapping (uint => address) participantIndex"
    Mapping
       Source: "mapping (uint => address)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "participantContribution"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) participantContribution"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "usedIcoSupply"
     Type: uint256
     Gas costs: 0
     Source: "uint256 usedIcoSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "usedStrategicReserveSupply"
     Type: uint256
     Gas costs: 0
     Source: "uint256 usedStrategicReserveSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "usedCashilaTokenSupply"
     Type: uint256
     Gas costs: 0
     Source: "uint256 usedCashilaTokenSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "usedIconomiTokenSupply"
     Type: uint256
     Gas costs: 0
     Source: "uint256 usedIconomiTokenSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "usedCoreTeamTokenSupply"
     Type: uint256
     Gas costs: 0
     Source: "uint256 usedCoreTeamTokenSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "icoHasStarted"
     Type: bool
     Gas costs: 0
     Source: "bool icoHasStarted"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "minTresholdReached"
     Type: bool
     Gas costs: 0
     Source: "bool minTresholdReached"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "icoHasSucessfulyEnded"
     Type: bool
     Gas costs: 0
     Source: "bool icoHasSucessfulyEnded"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "lastEthReturnIndex"
     Type: uint256
     Gas costs: 0
     Source: "uint256 lastEthReturnIndex"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "hasClaimedEthWhenFail"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping (address => bool) hasClaimedEthWhenFail"
    Mapping
       Source: "mapping (address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "lastCfiIssuanceIndex"
     Type: uint256
     Gas costs: 0
     Source: "uint256 lastCfiIssuanceIndex"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "icoStartedMessage"
     Type: string storage ref
     Gas costs: 0
     Source: "string icoStartedMessage = \"Cofoundit is launching!\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Cofoundit is launching!
       Type: literal_string "Cofoundit is launching!"
       Source: "\"Cofoundit is launching!\""
  VariableDeclaration "icoMinTresholdReachedMessage"
     Type: string storage ref
     Gas costs: 0
     Source: "string icoMinTresholdReachedMessage = \"Firing Stage 2!\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Firing Stage 2!
       Type: literal_string "Firing Stage 2!"
       Source: "\"Firing Stage 2!\""
  VariableDeclaration "icoEndedSuccessfulyMessage"
     Type: string storage ref
     Gas costs: 0
     Source: "string icoEndedSuccessfulyMessage = \"Orbit achieved!\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Orbit achieved!
       Type: literal_string "Orbit achieved!"
       Source: "\"Orbit achieved!\""
  VariableDeclaration "icoEndedSuccessfulyWithCapMessage"
     Type: string storage ref
     Gas costs: 0
     Source: "string icoEndedSuccessfulyWithCapMessage = \"Leaving Earth orbit!\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Leaving Earth orbit!
       Type: literal_string "Leaving Earth orbit!"
       Source: "\"Leaving Earth orbit!\""
  VariableDeclaration "icoFailedMessage"
     Type: string storage ref
     Gas costs: 0
     Source: "string icoFailedMessage = \"Rocket crashed.\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Rocket crashed.
       Type: literal_string "Rocket crashed."
       Source: "\"Rocket crashed.\""
  EventDefinition "ICOStarted"
     Gas costs: 0
     Source: "event ICOStarted(uint256 _blockNumber, string _message);"
    ParameterList
       Source: "(uint256 _blockNumber, string _message)"
      VariableDeclaration "_blockNumber"
         Type: uint256
         Source: "uint256 _blockNumber"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_message"
         Type: string memory
         Source: "string _message"
        ElementaryTypeName string
           Source: "string"
  EventDefinition "ICOMinTresholdReached"
     Gas costs: 0
     Source: "event ICOMinTresholdReached(uint256 _blockNumber, string _message);"
    ParameterList
       Source: "(uint256 _blockNumber, string _message)"
      VariableDeclaration "_blockNumber"
         Type: uint256
         Source: "uint256 _blockNumber"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_message"
         Type: string memory
         Source: "string _message"
        ElementaryTypeName string
           Source: "string"
  EventDefinition "ICOEndedSuccessfuly"
     Gas costs: 0
     Source: "event ICOEndedSuccessfuly(uint256 _blockNumber, uint256 _amountRaised, string _message);"
    ParameterList
       Source: "(uint256 _blockNumber, uint256 _amountRaised, string _message)"
      VariableDeclaration "_blockNumber"
         Type: uint256
         Source: "uint256 _blockNumber"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_amountRaised"
         Type: uint256
         Source: "uint256 _amountRaised"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_message"
         Type: string memory
         Source: "string _message"
        ElementaryTypeName string
           Source: "string"
  EventDefinition "ICOFailed"
     Gas costs: 0
     Source: "event ICOFailed(uint256 _blockNumber, uint256 _ammountRaised, string _message);"
    ParameterList
       Source: "(uint256 _blockNumber, uint256 _ammountRaised, string _message)"
      VariableDeclaration "_blockNumber"
         Type: uint256
         Source: "uint256 _blockNumber"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_ammountRaised"
         Type: uint256
         Source: "uint256 _ammountRaised"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_message"
         Type: string memory
         Source: "string _message"
        ElementaryTypeName string
           Source: "string"
  EventDefinition "ErrorSendingETH"
     Gas costs: 0
     Source: "event ErrorSendingETH(address _from, uint256 _amount);"
    ParameterList
       Source: "(address _from, uint256 _amount)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "CofounditICO" - public
     Source: "function CofounditICO(uint256 _startBlock, uint256 _endBlock, address _multisigAddress) {\r\n\t\tstartBlock = _startBlock;\r\n\t\tendBlock = _endBlock;\r\n\t\tminEthToRaise = 4525 * 10**18;\r\n\t\tmaxEthToRaise = 56565 * 10**18;\r\n\t\tmultisigAddress = _multisigAddress;\r\n\r\n\t\ticoSupply =\t \t\t\t\t125000000 * 10**18;\r\n\t\tstrategicReserveSupply = \t125000000 * 10**18;\r\n\t\tcashilaTokenSupply = \t\t100000000 * 10**18;\r\n\t\ticonomiTokenSupply = \t\t50000000 * 10**18;\r\n\t\tcoreTeamTokenSupply =\t\t100000000 * 10**18;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _startBlock, uint256 _endBlock, address _multisigAddress)"
      VariableDeclaration "_startBlock"
         Type: uint256
         Source: "uint256 _startBlock"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_endBlock"
         Type: uint256
         Source: "uint256 _endBlock"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_multisigAddress"
         Type: address
         Source: "address _multisigAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tstartBlock = _startBlock;\r\n\t\tendBlock = _endBlock;\r\n\t\tminEthToRaise = 4525 * 10**18;\r\n\t\tmaxEthToRaise = 56565 * 10**18;\r\n\t\tmultisigAddress = _multisigAddress;\r\n\r\n\t\ticoSupply =\t \t\t\t\t125000000 * 10**18;\r\n\t\tstrategicReserveSupply = \t125000000 * 10**18;\r\n\t\tcashilaTokenSupply = \t\t100000000 * 10**18;\r\n\t\ticonomiTokenSupply = \t\t50000000 * 10**18;\r\n\t\tcoreTeamTokenSupply =\t\t100000000 * 10**18;\r\n\t}"
      ExpressionStatement
         Gas costs: 0
         Source: "startBlock = _startBlock"
        Assignment using operator =
           Type: uint256
           Source: "startBlock = _startBlock"
          Identifier startBlock
             Type: uint256
             Source: "startBlock"
          Identifier _startBlock
             Type: uint256
             Source: "_startBlock"
      ExpressionStatement
         Gas costs: 0
         Source: "endBlock = _endBlock"
        Assignment using operator =
           Type: uint256
           Source: "endBlock = _endBlock"
          Identifier endBlock
             Type: uint256
             Source: "endBlock"
          Identifier _endBlock
             Type: uint256
             Source: "_endBlock"
      ExpressionStatement
         Gas costs: 0
         Source: "minEthToRaise = 4525 * 10**18"
        Assignment using operator =
           Type: uint256
           Source: "minEthToRaise = 4525 * 10**18"
          Identifier minEthToRaise
             Type: uint256
             Source: "minEthToRaise"
          BinaryOperation using operator *
             Type: int_const 4525000000000000000000
             Source: "4525 * 10**18"
            Literal, token: [no token] value: 4525
               Type: int_const 4525
               Source: "4525"
            BinaryOperation using operator **
               Type: int_const 1000000000000000000
               Source: "10**18"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Literal, token: [no token] value: 18
                 Type: int_const 18
                 Source: "18"
      ExpressionStatement
         Gas costs: 0
         Source: "maxEthToRaise = 56565 * 10**18"
        Assignment using operator =
           Type: uint256
           Source: "maxEthToRaise = 56565 * 10**18"
          Identifier maxEthToRaise
             Type: uint256
             Source: "maxEthToRaise"
          BinaryOperation using operator *
             Type: int_const 56565000000000000000000
             Source: "56565 * 10**18"
            Literal, token: [no token] value: 56565
               Type: int_const 56565
               Source: "56565"
            BinaryOperation using operator **
               Type: int_const 1000000000000000000
               Source: "10**18"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Literal, token: [no token] value: 18
                 Type: int_const 18
                 Source: "18"
      ExpressionStatement
         Gas costs: 0
         Source: "multisigAddress = _multisigAddress"
        Assignment using operator =
           Type: address
           Source: "multisigAddress = _multisigAddress"
          Identifier multisigAddress
             Type: address
             Source: "multisigAddress"
          Identifier _multisigAddress
             Type: address
             Source: "_multisigAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "icoSupply =\t \t\t\t\t125000000 * 10**18"
        Assignment using operator =
           Type: uint256
           Source: "icoSupply =\t \t\t\t\t125000000 * 10**18"
          Identifier icoSupply
             Type: uint256
             Source: "icoSupply"
          BinaryOperation using operator *
             Type: int_const 125000000000000000000000000
             Source: "125000000 * 10**18"
            Literal, token: [no token] value: 125000000
               Type: int_const 125000000
               Source: "125000000"
            BinaryOperation using operator **
               Type: int_const 1000000000000000000
               Source: "10**18"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Literal, token: [no token] value: 18
                 Type: int_const 18
                 Source: "18"
      ExpressionStatement
         Gas costs: 0
         Source: "strategicReserveSupply = \t125000000 * 10**18"
        Assignment using operator =
           Type: uint256
           Source: "strategicReserveSupply = \t125000000 * 10**18"
          Identifier strategicReserveSupply
             Type: uint256
             Source: "strategicReserveSupply"
          BinaryOperation using operator *
             Type: int_const 125000000000000000000000000
             Source: "125000000 * 10**18"
            Literal, token: [no token] value: 125000000
               Type: int_const 125000000
               Source: "125000000"
            BinaryOperation using operator **
               Type: int_const 1000000000000000000
               Source: "10**18"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Literal, token: [no token] value: 18
                 Type: int_const 18
                 Source: "18"
      ExpressionStatement
         Gas costs: 0
         Source: "cashilaTokenSupply = \t\t100000000 * 10**18"
        Assignment using operator =
           Type: uint256
           Source: "cashilaTokenSupply = \t\t100000000 * 10**18"
          Identifier cashilaTokenSupply
             Type: uint256
             Source: "cashilaTokenSupply"
          BinaryOperation using operator *
             Type: int_const 100000000000000000000000000
             Source: "100000000 * 10**18"
            Literal, token: [no token] value: 100000000
               Type: int_const 100000000
               Source: "100000000"
            BinaryOperation using operator **
               Type: int_const 1000000000000000000
               Source: "10**18"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Literal, token: [no token] value: 18
                 Type: int_const 18
                 Source: "18"
      ExpressionStatement
         Gas costs: 0
         Source: "iconomiTokenSupply = \t\t50000000 * 10**18"
        Assignment using operator =
           Type: uint256
           Source: "iconomiTokenSupply = \t\t50000000 * 10**18"
          Identifier iconomiTokenSupply
             Type: uint256
             Source: "iconomiTokenSupply"
          BinaryOperation using operator *
             Type: int_const 50000000000000000000000000
             Source: "50000000 * 10**18"
            Literal, token: [no token] value: 50000000
               Type: int_const 50000000
               Source: "50000000"
            BinaryOperation using operator **
               Type: int_const 1000000000000000000
               Source: "10**18"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Literal, token: [no token] value: 18
                 Type: int_const 18
                 Source: "18"
      ExpressionStatement
         Gas costs: 0
         Source: "coreTeamTokenSupply =\t\t100000000 * 10**18"
        Assignment using operator =
           Type: uint256
           Source: "coreTeamTokenSupply =\t\t100000000 * 10**18"
          Identifier coreTeamTokenSupply
             Type: uint256
             Source: "coreTeamTokenSupply"
          BinaryOperation using operator *
             Type: int_const 100000000000000000000000000
             Source: "100000000 * 10**18"
            Literal, token: [no token] value: 100000000
               Type: int_const 100000000
               Source: "100000000"
            BinaryOperation using operator **
               Type: int_const 1000000000000000000
               Source: "10**18"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Literal, token: [no token] value: 18
                 Type: int_const 18
                 Source: "18"
  FunctionDefinition "" - public
     Source: "function () payable { \t\t\r\n\t\tif (msg.value == 0) throw;  \t\t\t\t\t\t\t\t\t\t\t\t// Check if balance is not 0 \t\t\r\n\t\tif (icoHasSucessfulyEnded || block.number > endBlock) throw;\t\t\t\t// Throw if ico has already ended \t\t\r\n\t\tif (!icoHasStarted){\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if this is the first transaction of ico \t\t\t\r\n\t\t\tif (block.number < startBlock){\t\t\t\t\t\t\t\t\t\t\t// Check if ico should start \t\t\t\t\r\n\t\t\t\tif (!presaleContributorAllowance[msg.sender]) throw;\t\t\t\t// Check if this address is part of presale contributors \t\t\t\r\n\t\t\t} \t\t\t\r\n\t\t\telse{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If ICO should start \t\t\t\t\r\n\t\t\t\ticoHasStarted = true;\t\t\t\t\t\t\t\t\t\t\t\t// Set that ico has started \t\t\t\t\r\n\t\t\t\tICOStarted(block.number, icoStartedMessage);\t\t\t\t\t\t// Raise event \t\t\t\r\n\t\t\t} \t\t\r\n\t\t} \t\t\r\n\t\tif (participantContribution[msg.sender] == 0){ \t\t\t\t\t\t\t\t// Check if sender is a new user \t\t\t\r\n\t\t\tparticipantIndex[nextFreeParticipantIndex] = msg.sender;\t\t\t\t// Add new user to participant data structure \t\t\t\r\n\t\t\tnextFreeParticipantIndex += 1; \t\t\r\n\t\t} \t\t\r\n\t\tif (maxEthToRaise > (totalEthRaised + msg.value)){\t\t\t\t\t\t\t// Check if user sent to much eth \t\t\t\r\n\t\t\tparticipantContribution[msg.sender] += msg.value;\t\t\t\t\t\t// Add accounts contribution \t\t\t\r\n\t\t\ttotalEthRaised += msg.value;\t\t\t\t\t\t\t\t\t\t\t// Add to total eth Raised \t\t\t\r\n\t\t\tif (!minTresholdReached && totalEthRaised >= minEthToRaise){\t\t\t// Check if min treshold has been reached(Do that one time) \t\t\t\t\r\n\t\t\t\tICOMinTresholdReached(block.number, icoMinTresholdReachedMessage);\t// Raise event \t\t\t\t\r\n\t\t\t\tminTresholdReached = true;\t\t\t\t\t\t\t\t\t\t\t// Set that treshold has been reached \t\t\t\r\n\t\t\t} \t\t\r\n\t\t}else{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If user sent to much eth \t\t\t\r\n\t\t\tuint maxContribution = maxEthToRaise - totalEthRaised; \t\t\t\t\t// Calculate max contribution \t\t\t\r\n\t\t\tparticipantContribution[msg.sender] += maxContribution;\t\t\t\t\t// Add max contribution to account \t\t\t\r\n\t\t\ttotalEthRaised += maxContribution;\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\tuint toReturn = msg.value - maxContribution;\t\t\t\t\t\t\t// Calculate how much user should get back \t\t\t\r\n\t\t\ticoHasSucessfulyEnded = true;\t\t\t\t\t\t\t\t\t\t\t// Set that ico has successfullyEnded \t\t\t\r\n\t\t\tICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyWithCapMessage); \t\t\t\r\n\t\t\tif(!msg.sender.send(toReturn)){\t\t\t\t\t\t\t\t\t\t\t// Refound balance that is over the cap \t\t\t\t\r\n\t\t\t\tErrorSendingETH(msg.sender, toReturn);\t\t\t\t\t\t\t\t// Raise event for manual return if transaction throws \t\t\t\r\n\t\t\t} \t\t\r\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Feel good about achiving the cap \t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ \t\t\r\n\t\tif (msg.value == 0) throw;  \t\t\t\t\t\t\t\t\t\t\t\t// Check if balance is not 0 \t\t\r\n\t\tif (icoHasSucessfulyEnded || block.number > endBlock) throw;\t\t\t\t// Throw if ico has already ended \t\t\r\n\t\tif (!icoHasStarted){\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if this is the first transaction of ico \t\t\t\r\n\t\t\tif (block.number < startBlock){\t\t\t\t\t\t\t\t\t\t\t// Check if ico should start \t\t\t\t\r\n\t\t\t\tif (!presaleContributorAllowance[msg.sender]) throw;\t\t\t\t// Check if this address is part of presale contributors \t\t\t\r\n\t\t\t} \t\t\t\r\n\t\t\telse{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If ICO should start \t\t\t\t\r\n\t\t\t\ticoHasStarted = true;\t\t\t\t\t\t\t\t\t\t\t\t// Set that ico has started \t\t\t\t\r\n\t\t\t\tICOStarted(block.number, icoStartedMessage);\t\t\t\t\t\t// Raise event \t\t\t\r\n\t\t\t} \t\t\r\n\t\t} \t\t\r\n\t\tif (participantContribution[msg.sender] == 0){ \t\t\t\t\t\t\t\t// Check if sender is a new user \t\t\t\r\n\t\t\tparticipantIndex[nextFreeParticipantIndex] = msg.sender;\t\t\t\t// Add new user to participant data structure \t\t\t\r\n\t\t\tnextFreeParticipantIndex += 1; \t\t\r\n\t\t} \t\t\r\n\t\tif (maxEthToRaise > (totalEthRaised + msg.value)){\t\t\t\t\t\t\t// Check if user sent to much eth \t\t\t\r\n\t\t\tparticipantContribution[msg.sender] += msg.value;\t\t\t\t\t\t// Add accounts contribution \t\t\t\r\n\t\t\ttotalEthRaised += msg.value;\t\t\t\t\t\t\t\t\t\t\t// Add to total eth Raised \t\t\t\r\n\t\t\tif (!minTresholdReached && totalEthRaised >= minEthToRaise){\t\t\t// Check if min treshold has been reached(Do that one time) \t\t\t\t\r\n\t\t\t\tICOMinTresholdReached(block.number, icoMinTresholdReachedMessage);\t// Raise event \t\t\t\t\r\n\t\t\t\tminTresholdReached = true;\t\t\t\t\t\t\t\t\t\t\t// Set that treshold has been reached \t\t\t\r\n\t\t\t} \t\t\r\n\t\t}else{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If user sent to much eth \t\t\t\r\n\t\t\tuint maxContribution = maxEthToRaise - totalEthRaised; \t\t\t\t\t// Calculate max contribution \t\t\t\r\n\t\t\tparticipantContribution[msg.sender] += maxContribution;\t\t\t\t\t// Add max contribution to account \t\t\t\r\n\t\t\ttotalEthRaised += maxContribution;\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\tuint toReturn = msg.value - maxContribution;\t\t\t\t\t\t\t// Calculate how much user should get back \t\t\t\r\n\t\t\ticoHasSucessfulyEnded = true;\t\t\t\t\t\t\t\t\t\t\t// Set that ico has successfullyEnded \t\t\t\r\n\t\t\tICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyWithCapMessage); \t\t\t\r\n\t\t\tif(!msg.sender.send(toReturn)){\t\t\t\t\t\t\t\t\t\t\t// Refound balance that is over the cap \t\t\t\t\r\n\t\t\t\tErrorSendingETH(msg.sender, toReturn);\t\t\t\t\t\t\t\t// Raise event for manual return if transaction throws \t\t\t\r\n\t\t\t} \t\t\r\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Feel good about achiving the cap \t\r\n\t}"
      IfStatement
         Source: "if (msg.value == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 8
           Source: "msg.value == 0"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (icoHasSucessfulyEnded || block.number > endBlock) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 516
           Source: "icoHasSucessfulyEnded || block.number > endBlock"
          Identifier icoHasSucessfulyEnded
             Type: bool
             Source: "icoHasSucessfulyEnded"
          BinaryOperation using operator >
             Type: bool
             Source: "block.number > endBlock"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier endBlock
               Type: uint256
               Source: "endBlock"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (!icoHasStarted){\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if this is the first transaction of ico \t\t\t\r\n\t\t\tif (block.number < startBlock){\t\t\t\t\t\t\t\t\t\t\t// Check if ico should start \t\t\t\t\r\n\t\t\t\tif (!presaleContributorAllowance[msg.sender]) throw;\t\t\t\t// Check if this address is part of presale contributors \t\t\t\r\n\t\t\t} \t\t\t\r\n\t\t\telse{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If ICO should start \t\t\t\t\r\n\t\t\t\ticoHasStarted = true;\t\t\t\t\t\t\t\t\t\t\t\t// Set that ico has started \t\t\t\t\r\n\t\t\t\tICOStarted(block.number, icoStartedMessage);\t\t\t\t\t\t// Raise event \t\t\t\r\n\t\t\t} \t\t\r\n\t\t}"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 242
           Source: "!icoHasStarted"
          Identifier icoHasStarted
             Type: bool
             Source: "icoHasStarted"
        Block
           Source: "{\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if this is the first transaction of ico \t\t\t\r\n\t\t\tif (block.number < startBlock){\t\t\t\t\t\t\t\t\t\t\t// Check if ico should start \t\t\t\t\r\n\t\t\t\tif (!presaleContributorAllowance[msg.sender]) throw;\t\t\t\t// Check if this address is part of presale contributors \t\t\t\r\n\t\t\t} \t\t\t\r\n\t\t\telse{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If ICO should start \t\t\t\t\r\n\t\t\t\ticoHasStarted = true;\t\t\t\t\t\t\t\t\t\t\t\t// Set that ico has started \t\t\t\t\r\n\t\t\t\tICOStarted(block.number, icoStartedMessage);\t\t\t\t\t\t// Raise event \t\t\t\r\n\t\t\t} \t\t\r\n\t\t}"
          IfStatement
             Source: "if (block.number < startBlock){\t\t\t\t\t\t\t\t\t\t\t// Check if ico should start \t\t\t\t\r\n\t\t\t\tif (!presaleContributorAllowance[msg.sender]) throw;\t\t\t\t// Check if this address is part of presale contributors \t\t\t\r\n\t\t\t} \t\t\t\r\n\t\t\telse{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If ICO should start \t\t\t\t\r\n\t\t\t\ticoHasStarted = true;\t\t\t\t\t\t\t\t\t\t\t\t// Set that ico has started \t\t\t\t\r\n\t\t\t\tICOStarted(block.number, icoStartedMessage);\t\t\t\t\t\t// Raise event \t\t\t\r\n\t\t\t}"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 208
               Source: "block.number < startBlock"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              Identifier startBlock
                 Type: uint256
                 Source: "startBlock"
            Block
               Source: "{\t\t\t\t\t\t\t\t\t\t\t// Check if ico should start \t\t\t\t\r\n\t\t\t\tif (!presaleContributorAllowance[msg.sender]) throw;\t\t\t\t// Check if this address is part of presale contributors \t\t\t\r\n\t\t\t}"
              IfStatement
                 Source: "if (!presaleContributorAllowance[msg.sender]) throw"
                UnaryOperation (prefix) !
                   Type: bool
                   Gas costs: 337
                   Source: "!presaleContributorAllowance[msg.sender]"
                  IndexAccess
                     Type: bool
                     Source: "presaleContributorAllowance[msg.sender]"
                    Identifier presaleContributorAllowance
                       Type: mapping(address => bool)
                       Source: "presaleContributorAllowance"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                Throw
                   Gas costs: 6
                   Source: "throw"
            Block
               Source: "{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If ICO should start \t\t\t\t\r\n\t\t\t\ticoHasStarted = true;\t\t\t\t\t\t\t\t\t\t\t\t// Set that ico has started \t\t\t\t\r\n\t\t\t\tICOStarted(block.number, icoStartedMessage);\t\t\t\t\t\t// Raise event \t\t\t\r\n\t\t\t}"
              ExpressionStatement
                 Gas costs: 20267
                 Source: "icoHasStarted = true"
                Assignment using operator =
                   Type: bool
                   Source: "icoHasStarted = true"
                  Identifier icoHasStarted
                     Type: bool
                     Source: "icoHasStarted"
                  Literal, token: true value: true
                     Type: bool
                     Source: "true"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "ICOStarted(block.number, icoStartedMessage)"
                FunctionCall
                   Type: tuple()
                   Source: "ICOStarted(block.number, icoStartedMessage)"
                  Identifier ICOStarted
                     Type: function (uint256,string memory)
                     Source: "ICOStarted"
                  MemberAccess to member number
                     Type: uint256
                     Source: "block.number"
                    Identifier block
                       Type: block
                       Source: "block"
                  Identifier icoStartedMessage
                     Type: string storage ref
                     Source: "icoStartedMessage"
      IfStatement
         Source: "if (participantContribution[msg.sender] == 0){ \t\t\t\t\t\t\t\t// Check if sender is a new user \t\t\t\r\n\t\t\tparticipantIndex[nextFreeParticipantIndex] = msg.sender;\t\t\t\t// Add new user to participant data structure \t\t\t\r\n\t\t\tnextFreeParticipantIndex += 1; \t\t\r\n\t\t}"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 304
           Source: "participantContribution[msg.sender] == 0"
          IndexAccess
             Type: uint256
             Source: "participantContribution[msg.sender]"
            Identifier participantContribution
               Type: mapping(address => uint256)
               Source: "participantContribution"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{ \t\t\t\t\t\t\t\t// Check if sender is a new user \t\t\t\r\n\t\t\tparticipantIndex[nextFreeParticipantIndex] = msg.sender;\t\t\t\t// Add new user to participant data structure \t\t\t\r\n\t\t\tnextFreeParticipantIndex += 1; \t\t\r\n\t\t}"
          ExpressionStatement
             Gas costs: 20550
             Source: "participantIndex[nextFreeParticipantIndex] = msg.sender"
            Assignment using operator =
               Type: address
               Source: "participantIndex[nextFreeParticipantIndex] = msg.sender"
              IndexAccess
                 Type: address
                 Source: "participantIndex[nextFreeParticipantIndex]"
                Identifier participantIndex
                   Type: mapping(uint256 => address)
                   Source: "participantIndex"
                Identifier nextFreeParticipantIndex
                   Type: uint256
                   Source: "nextFreeParticipantIndex"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          ExpressionStatement
             Gas costs: 20233
             Source: "nextFreeParticipantIndex += 1"
            Assignment using operator +=
               Type: uint256
               Source: "nextFreeParticipantIndex += 1"
              Identifier nextFreeParticipantIndex
                 Type: uint256
                 Source: "nextFreeParticipantIndex"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      IfStatement
         Source: "if (maxEthToRaise > (totalEthRaised + msg.value)){\t\t\t\t\t\t\t// Check if user sent to much eth \t\t\t\r\n\t\t\tparticipantContribution[msg.sender] += msg.value;\t\t\t\t\t\t// Add accounts contribution \t\t\t\r\n\t\t\ttotalEthRaised += msg.value;\t\t\t\t\t\t\t\t\t\t\t// Add to total eth Raised \t\t\t\r\n\t\t\tif (!minTresholdReached && totalEthRaised >= minEthToRaise){\t\t\t// Check if min treshold has been reached(Do that one time) \t\t\t\t\r\n\t\t\t\tICOMinTresholdReached(block.number, icoMinTresholdReachedMessage);\t// Raise event \t\t\t\t\r\n\t\t\t\tminTresholdReached = true;\t\t\t\t\t\t\t\t\t\t\t// Set that treshold has been reached \t\t\t\r\n\t\t\t} \t\t\r\n\t\t}else{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If user sent to much eth \t\t\t\r\n\t\t\tuint maxContribution = maxEthToRaise - totalEthRaised; \t\t\t\t\t// Calculate max contribution \t\t\t\r\n\t\t\tparticipantContribution[msg.sender] += maxContribution;\t\t\t\t\t// Add max contribution to account \t\t\t\r\n\t\t\ttotalEthRaised += maxContribution;\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\tuint toReturn = msg.value - maxContribution;\t\t\t\t\t\t\t// Calculate how much user should get back \t\t\t\r\n\t\t\ticoHasSucessfulyEnded = true;\t\t\t\t\t\t\t\t\t\t\t// Set that ico has successfullyEnded \t\t\t\r\n\t\t\tICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyWithCapMessage); \t\t\t\r\n\t\t\tif(!msg.sender.send(toReturn)){\t\t\t\t\t\t\t\t\t\t\t// Refound balance that is over the cap \t\t\t\t\r\n\t\t\t\tErrorSendingETH(msg.sender, toReturn);\t\t\t\t\t\t\t\t// Raise event for manual return if transaction throws \t\t\t\r\n\t\t\t} \t\t\r\n\t\t}"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 414
           Source: "maxEthToRaise > (totalEthRaised + msg.value)"
          Identifier maxEthToRaise
             Type: uint256
             Source: "maxEthToRaise"
          TupleExpression
             Type: uint256
             Source: "(totalEthRaised + msg.value)"
            BinaryOperation using operator +
               Type: uint256
               Source: "totalEthRaised + msg.value"
              Identifier totalEthRaised
                 Type: uint256
                 Source: "totalEthRaised"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
        Block
           Source: "{\t\t\t\t\t\t\t// Check if user sent to much eth \t\t\t\r\n\t\t\tparticipantContribution[msg.sender] += msg.value;\t\t\t\t\t\t// Add accounts contribution \t\t\t\r\n\t\t\ttotalEthRaised += msg.value;\t\t\t\t\t\t\t\t\t\t\t// Add to total eth Raised \t\t\t\r\n\t\t\tif (!minTresholdReached && totalEthRaised >= minEthToRaise){\t\t\t// Check if min treshold has been reached(Do that one time) \t\t\t\t\r\n\t\t\t\tICOMinTresholdReached(block.number, icoMinTresholdReachedMessage);\t// Raise event \t\t\t\t\r\n\t\t\t\tminTresholdReached = true;\t\t\t\t\t\t\t\t\t\t\t// Set that treshold has been reached \t\t\t\r\n\t\t\t} \t\t\r\n\t\t}"
          ExpressionStatement
             Gas costs: 20327
             Source: "participantContribution[msg.sender] += msg.value"
            Assignment using operator +=
               Type: uint256
               Source: "participantContribution[msg.sender] += msg.value"
              IndexAccess
                 Type: uint256
                 Source: "participantContribution[msg.sender]"
                Identifier participantContribution
                   Type: mapping(address => uint256)
                   Source: "participantContribution"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
          ExpressionStatement
             Gas costs: 20232
             Source: "totalEthRaised += msg.value"
            Assignment using operator +=
               Type: uint256
               Source: "totalEthRaised += msg.value"
              Identifier totalEthRaised
                 Type: uint256
                 Source: "totalEthRaised"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
          IfStatement
             Source: "if (!minTresholdReached && totalEthRaised >= minEthToRaise){\t\t\t// Check if min treshold has been reached(Do that one time) \t\t\t\t\r\n\t\t\t\tICOMinTresholdReached(block.number, icoMinTresholdReachedMessage);\t// Raise event \t\t\t\t\r\n\t\t\t\tminTresholdReached = true;\t\t\t\t\t\t\t\t\t\t\t// Set that treshold has been reached \t\t\t\r\n\t\t\t}"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 726
               Source: "!minTresholdReached && totalEthRaised >= minEthToRaise"
              UnaryOperation (prefix) !
                 Type: bool
                 Source: "!minTresholdReached"
                Identifier minTresholdReached
                   Type: bool
                   Source: "minTresholdReached"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "totalEthRaised >= minEthToRaise"
                Identifier totalEthRaised
                   Type: uint256
                   Source: "totalEthRaised"
                Identifier minEthToRaise
                   Type: uint256
                   Source: "minEthToRaise"
            Block
               Source: "{\t\t\t// Check if min treshold has been reached(Do that one time) \t\t\t\t\r\n\t\t\t\tICOMinTresholdReached(block.number, icoMinTresholdReachedMessage);\t// Raise event \t\t\t\t\r\n\t\t\t\tminTresholdReached = true;\t\t\t\t\t\t\t\t\t\t\t// Set that treshold has been reached \t\t\t\r\n\t\t\t}"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "ICOMinTresholdReached(block.number, icoMinTresholdReachedMessage)"
                FunctionCall
                   Type: tuple()
                   Source: "ICOMinTresholdReached(block.number, icoMinTresholdReachedMessage)"
                  Identifier ICOMinTresholdReached
                     Type: function (uint256,string memory)
                     Source: "ICOMinTresholdReached"
                  MemberAccess to member number
                     Type: uint256
                     Source: "block.number"
                    Identifier block
                       Type: block
                       Source: "block"
                  Identifier icoMinTresholdReachedMessage
                     Type: string storage ref
                     Source: "icoMinTresholdReachedMessage"
              ExpressionStatement
                 Gas costs: 20317
                 Source: "minTresholdReached = true"
                Assignment using operator =
                   Type: bool
                   Source: "minTresholdReached = true"
                  Identifier minTresholdReached
                     Type: bool
                     Source: "minTresholdReached"
                  Literal, token: true value: true
                     Type: bool
                     Source: "true"
        Block
           Source: "{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If user sent to much eth \t\t\t\r\n\t\t\tuint maxContribution = maxEthToRaise - totalEthRaised; \t\t\t\t\t// Calculate max contribution \t\t\t\r\n\t\t\tparticipantContribution[msg.sender] += maxContribution;\t\t\t\t\t// Add max contribution to account \t\t\t\r\n\t\t\ttotalEthRaised += maxContribution;\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\tuint toReturn = msg.value - maxContribution;\t\t\t\t\t\t\t// Calculate how much user should get back \t\t\t\r\n\t\t\ticoHasSucessfulyEnded = true;\t\t\t\t\t\t\t\t\t\t\t// Set that ico has successfullyEnded \t\t\t\r\n\t\t\tICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyWithCapMessage); \t\t\t\r\n\t\t\tif(!msg.sender.send(toReturn)){\t\t\t\t\t\t\t\t\t\t\t// Refound balance that is over the cap \t\t\t\t\r\n\t\t\t\tErrorSendingETH(msg.sender, toReturn);\t\t\t\t\t\t\t\t// Raise event for manual return if transaction throws \t\t\t\r\n\t\t\t} \t\t\r\n\t\t}"
          VariableDeclarationStatement
             Gas costs: 417
             Source: "uint maxContribution = maxEthToRaise - totalEthRaised"
            VariableDeclaration "maxContribution"
               Type: uint256
               Source: "uint maxContribution"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator -
               Type: uint256
               Source: "maxEthToRaise - totalEthRaised"
              Identifier maxEthToRaise
                 Type: uint256
                 Source: "maxEthToRaise"
              Identifier totalEthRaised
                 Type: uint256
                 Source: "totalEthRaised"
          ExpressionStatement
             Gas costs: 20328
             Source: "participantContribution[msg.sender] += maxContribution"
            Assignment using operator +=
               Type: uint256
               Source: "participantContribution[msg.sender] += maxContribution"
              IndexAccess
                 Type: uint256
                 Source: "participantContribution[msg.sender]"
                Identifier participantContribution
                   Type: mapping(address => uint256)
                   Source: "participantContribution"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier maxContribution
                 Type: uint256
                 Source: "maxContribution"
          ExpressionStatement
             Gas costs: 20233
             Source: "totalEthRaised += maxContribution"
            Assignment using operator +=
               Type: uint256
               Source: "totalEthRaised += maxContribution"
              Identifier totalEthRaised
                 Type: uint256
                 Source: "totalEthRaised"
              Identifier maxContribution
                 Type: uint256
                 Source: "maxContribution"
          VariableDeclarationStatement
             Gas costs: 16
             Source: "uint toReturn = msg.value - maxContribution"
            VariableDeclaration "toReturn"
               Type: uint256
               Source: "uint toReturn"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator -
               Type: uint256
               Source: "msg.value - maxContribution"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier maxContribution
                 Type: uint256
                 Source: "maxContribution"
          ExpressionStatement
             Gas costs: 20317
             Source: "icoHasSucessfulyEnded = true"
            Assignment using operator =
               Type: bool
               Source: "icoHasSucessfulyEnded = true"
              Identifier icoHasSucessfulyEnded
                 Type: bool
                 Source: "icoHasSucessfulyEnded"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
          ExpressionStatement
             Gas costs: [???]
             Source: "ICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyWithCapMessage)"
            FunctionCall
               Type: tuple()
               Source: "ICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyWithCapMessage)"
              Identifier ICOEndedSuccessfuly
                 Type: function (uint256,uint256,string memory)
                 Source: "ICOEndedSuccessfuly"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              Identifier totalEthRaised
                 Type: uint256
                 Source: "totalEthRaised"
              Identifier icoEndedSuccessfulyWithCapMessage
                 Type: string storage ref
                 Source: "icoEndedSuccessfulyWithCapMessage"
          IfStatement
             Source: "if(!msg.sender.send(toReturn)){\t\t\t\t\t\t\t\t\t\t\t// Refound balance that is over the cap \t\t\t\t\r\n\t\t\t\tErrorSendingETH(msg.sender, toReturn);\t\t\t\t\t\t\t\t// Raise event for manual return if transaction throws \t\t\t\r\n\t\t\t}"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: [???]
               Source: "!msg.sender.send(toReturn)"
              FunctionCall
                 Type: bool
                 Source: "msg.sender.send(toReturn)"
                MemberAccess to member send
                   Type: function (uint256) returns (bool)
                   Source: "msg.sender.send"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier toReturn
                   Type: uint256
                   Source: "toReturn"
            Block
               Source: "{\t\t\t\t\t\t\t\t\t\t\t// Refound balance that is over the cap \t\t\t\t\r\n\t\t\t\tErrorSendingETH(msg.sender, toReturn);\t\t\t\t\t\t\t\t// Raise event for manual return if transaction throws \t\t\t\r\n\t\t\t}"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "ErrorSendingETH(msg.sender, toReturn)"
                FunctionCall
                   Type: tuple()
                   Source: "ErrorSendingETH(msg.sender, toReturn)"
                  Identifier ErrorSendingETH
                     Type: function (address,uint256)
                     Source: "ErrorSendingETH"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier toReturn
                     Type: uint256
                     Source: "toReturn"
  FunctionDefinition "claimEthIfFailed" - public
     Source: "function claimEthIfFailed(){ \t\t\r\n\t\tif (block.number <= endBlock || totalEthRaised >= minEthToRaise) throw;\t// Check that ico has failed :( \t\t\r\n\t\tif (participantContribution[msg.sender] == 0) throw;\t\t\t\t\t// Check if user has even been at crowdsale \t\t\r\n\t\tif (hasClaimedEthWhenFail[msg.sender]) throw;\t\t\t\t\t\t\t// Check if this account has already claimed its eth \t\t\r\n\t\tuint256 ethContributed = participantContribution[msg.sender];\t\t\t// Get participant eth Contribution \t\t\r\n\t\thasClaimedEthWhenFail[msg.sender] = true; \t\t\r\n\t\tif (!msg.sender.send(ethContributed)){ \t\t\t\r\n\t\t\tErrorSendingETH(msg.sender, ethContributed);\t\t\t\t\t\t// Raise event if send failed and resolve manually \t\t\r\n\t\t} \t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ \t\t\r\n\t\tif (block.number <= endBlock || totalEthRaised >= minEthToRaise) throw;\t// Check that ico has failed :( \t\t\r\n\t\tif (participantContribution[msg.sender] == 0) throw;\t\t\t\t\t// Check if user has even been at crowdsale \t\t\r\n\t\tif (hasClaimedEthWhenFail[msg.sender]) throw;\t\t\t\t\t\t\t// Check if this account has already claimed its eth \t\t\r\n\t\tuint256 ethContributed = participantContribution[msg.sender];\t\t\t// Get participant eth Contribution \t\t\r\n\t\thasClaimedEthWhenFail[msg.sender] = true; \t\t\r\n\t\tif (!msg.sender.send(ethContributed)){ \t\t\t\r\n\t\t\tErrorSendingETH(msg.sender, ethContributed);\t\t\t\t\t\t// Raise event if send failed and resolve manually \t\t\r\n\t\t} \t\r\n\t}"
      IfStatement
         Source: "if (block.number <= endBlock || totalEthRaised >= minEthToRaise) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 642
           Source: "block.number <= endBlock || totalEthRaised >= minEthToRaise"
          BinaryOperation using operator <=
             Type: bool
             Source: "block.number <= endBlock"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier endBlock
               Type: uint256
               Source: "endBlock"
          BinaryOperation using operator >=
             Type: bool
             Source: "totalEthRaised >= minEthToRaise"
            Identifier totalEthRaised
               Type: uint256
               Source: "totalEthRaised"
            Identifier minEthToRaise
               Type: uint256
               Source: "minEthToRaise"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (participantContribution[msg.sender] == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 304
           Source: "participantContribution[msg.sender] == 0"
          IndexAccess
             Type: uint256
             Source: "participantContribution[msg.sender]"
            Identifier participantContribution
               Type: mapping(address => uint256)
               Source: "participantContribution"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (hasClaimedEthWhenFail[msg.sender]) throw"
        IndexAccess
           Type: bool
           Gas costs: 334
           Source: "hasClaimedEthWhenFail[msg.sender]"
          Identifier hasClaimedEthWhenFail
             Type: mapping(address => bool)
             Source: "hasClaimedEthWhenFail"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
        Throw
           Gas costs: 6
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 306
         Source: "uint256 ethContributed = participantContribution[msg.sender]"
        VariableDeclaration "ethContributed"
           Type: uint256
           Source: "uint256 ethContributed"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "participantContribution[msg.sender]"
          Identifier participantContribution
             Type: mapping(address => uint256)
             Source: "participantContribution"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20356
         Source: "hasClaimedEthWhenFail[msg.sender] = true"
        Assignment using operator =
           Type: bool
           Source: "hasClaimedEthWhenFail[msg.sender] = true"
          IndexAccess
             Type: bool
             Source: "hasClaimedEthWhenFail[msg.sender]"
            Identifier hasClaimedEthWhenFail
               Type: mapping(address => bool)
               Source: "hasClaimedEthWhenFail"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      IfStatement
         Source: "if (!msg.sender.send(ethContributed)){ \t\t\t\r\n\t\t\tErrorSendingETH(msg.sender, ethContributed);\t\t\t\t\t\t// Raise event if send failed and resolve manually \t\t\r\n\t\t}"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!msg.sender.send(ethContributed)"
          FunctionCall
             Type: bool
             Source: "msg.sender.send(ethContributed)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "msg.sender.send"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier ethContributed
               Type: uint256
               Source: "ethContributed"
        Block
           Source: "{ \t\t\t\r\n\t\t\tErrorSendingETH(msg.sender, ethContributed);\t\t\t\t\t\t// Raise event if send failed and resolve manually \t\t\r\n\t\t}"
          ExpressionStatement
             Gas costs: [???]
             Source: "ErrorSendingETH(msg.sender, ethContributed)"
            FunctionCall
               Type: tuple()
               Source: "ErrorSendingETH(msg.sender, ethContributed)"
              Identifier ErrorSendingETH
                 Type: function (address,uint256)
                 Source: "ErrorSendingETH"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier ethContributed
                 Type: uint256
                 Source: "ethContributed"
  FunctionDefinition "addPresaleContributors" - public
     Source: "function addPresaleContributors(address[] _presaleContributors) onlyOwner { \t\t\r\n\t\tfor (uint cnt = 0; cnt < _presaleContributors.length; cnt++){ \t\t\t\r\n\t\t\tpresaleContributorAllowance[_presaleContributors[cnt]] = true; \t\t\r\n\t\t} \t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address[] _presaleContributors)"
      VariableDeclaration "_presaleContributors"
         Type: address[] memory
         Source: "address[] _presaleContributors"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{ \t\t\r\n\t\tfor (uint cnt = 0; cnt < _presaleContributors.length; cnt++){ \t\t\t\r\n\t\t\tpresaleContributorAllowance[_presaleContributors[cnt]] = true; \t\t\r\n\t\t} \t\r\n\t}"
      ForStatement
         Source: "for (uint cnt = 0; cnt < _presaleContributors.length; cnt++){ \t\t\t\r\n\t\t\tpresaleContributorAllowance[_presaleContributors[cnt]] = true; \t\t\r\n\t\t}"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint cnt = 0"
          VariableDeclaration "cnt"
             Type: uint256
             Source: "uint cnt"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 27
           Source: "cnt < _presaleContributors.length"
          Identifier cnt
             Type: uint256
             Source: "cnt"
          MemberAccess to member length
             Type: uint256
             Source: "_presaleContributors.length"
            Identifier _presaleContributors
               Type: address[] memory
               Source: "_presaleContributors"
        ExpressionStatement
           Gas costs: 19
           Source: "cnt++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "cnt++"
            Identifier cnt
               Type: uint256
               Source: "cnt"
        Block
           Source: "{ \t\t\t\r\n\t\t\tpresaleContributorAllowance[_presaleContributors[cnt]] = true; \t\t\r\n\t\t}"
          ExpressionStatement
             Gas costs: [???]
             Source: "presaleContributorAllowance[_presaleContributors[cnt]] = true"
            Assignment using operator =
               Type: bool
               Source: "presaleContributorAllowance[_presaleContributors[cnt]] = true"
              IndexAccess
                 Type: bool
                 Source: "presaleContributorAllowance[_presaleContributors[cnt]]"
                Identifier presaleContributorAllowance
                   Type: mapping(address => bool)
                   Source: "presaleContributorAllowance"
                IndexAccess
                   Type: address
                   Source: "_presaleContributors[cnt]"
                  Identifier _presaleContributors
                     Type: address[] memory
                     Source: "_presaleContributors"
                  Identifier cnt
                     Type: uint256
                     Source: "cnt"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
  FunctionDefinition "batchIssueTokens" - public
     Source: "function batchIssueTokens(uint256 _numberOfIssuances) onlyOwner{ \t\t\r\n\t\tif (!icoHasSucessfulyEnded) throw;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if ico has ended \t\t\r\n\t\taddress currentParticipantAddress; \t\t\r\n\t\tuint256 tokensToBeIssued; \t\t\r\n\t\tfor (uint cnt = 0; cnt < _numberOfIssuances; cnt++){ \t\t\t\r\n\t\t\tcurrentParticipantAddress = participantIndex[lastCfiIssuanceIndex];\t// Get next participant address\r\n\t\t\tif (currentParticipantAddress == 0x0) continue; \t\t\t\r\n\t\t\ttokensToBeIssued = icoSupply * participantContribution[currentParticipantAddress] / totalEthRaised;\t\t// Calculate how much tokens will address get \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(currentParticipantAddress, tokensToBeIssued, \"Ico participation mint\");\t// Mint tokens @ CofounditToken \t\t\t\r\n\t\t\tlastCfiIssuanceIndex += 1;\t\r\n\t\t} \r\n\r\n\t\tif (participantIndex[lastCfiIssuanceIndex] == 0x0 && cofounditTokenContract.totalSupply() < icoSupply){\r\n\t\t\tuint divisionDifference = icoSupply - cofounditTokenContract.totalSupply();\r\n\t\t\tcofounditTokenContract.mintTokens(multisigAddress, divisionDifference, \"Mint division error\");\t// Mint divison difference @ CofounditToken so that total supply is whole number\t\t\t\r\n\t\t}\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _numberOfIssuances)"
      VariableDeclaration "_numberOfIssuances"
         Type: uint256
         Source: "uint256 _numberOfIssuances"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{ \t\t\r\n\t\tif (!icoHasSucessfulyEnded) throw;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if ico has ended \t\t\r\n\t\taddress currentParticipantAddress; \t\t\r\n\t\tuint256 tokensToBeIssued; \t\t\r\n\t\tfor (uint cnt = 0; cnt < _numberOfIssuances; cnt++){ \t\t\t\r\n\t\t\tcurrentParticipantAddress = participantIndex[lastCfiIssuanceIndex];\t// Get next participant address\r\n\t\t\tif (currentParticipantAddress == 0x0) continue; \t\t\t\r\n\t\t\ttokensToBeIssued = icoSupply * participantContribution[currentParticipantAddress] / totalEthRaised;\t\t// Calculate how much tokens will address get \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(currentParticipantAddress, tokensToBeIssued, \"Ico participation mint\");\t// Mint tokens @ CofounditToken \t\t\t\r\n\t\t\tlastCfiIssuanceIndex += 1;\t\r\n\t\t} \r\n\r\n\t\tif (participantIndex[lastCfiIssuanceIndex] == 0x0 && cofounditTokenContract.totalSupply() < icoSupply){\r\n\t\t\tuint divisionDifference = icoSupply - cofounditTokenContract.totalSupply();\r\n\t\t\tcofounditTokenContract.mintTokens(multisigAddress, divisionDifference, \"Mint division error\");\t// Mint divison difference @ CofounditToken so that total supply is whole number\t\t\t\r\n\t\t}\r\n\t}"
      IfStatement
         Source: "if (!icoHasSucessfulyEnded) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 292
           Source: "!icoHasSucessfulyEnded"
          Identifier icoHasSucessfulyEnded
             Type: bool
             Source: "icoHasSucessfulyEnded"
        Throw
           Gas costs: 6
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "address currentParticipantAddress"
        VariableDeclaration "currentParticipantAddress"
           Type: address
           Source: "address currentParticipantAddress"
          ElementaryTypeName address
             Source: "address"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint256 tokensToBeIssued"
        VariableDeclaration "tokensToBeIssued"
           Type: uint256
           Source: "uint256 tokensToBeIssued"
          ElementaryTypeName uint256
             Source: "uint256"
      ForStatement
         Source: "for (uint cnt = 0; cnt < _numberOfIssuances; cnt++){ \t\t\t\r\n\t\t\tcurrentParticipantAddress = participantIndex[lastCfiIssuanceIndex];\t// Get next participant address\r\n\t\t\tif (currentParticipantAddress == 0x0) continue; \t\t\t\r\n\t\t\ttokensToBeIssued = icoSupply * participantContribution[currentParticipantAddress] / totalEthRaised;\t\t// Calculate how much tokens will address get \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(currentParticipantAddress, tokensToBeIssued, \"Ico participation mint\");\t// Mint tokens @ CofounditToken \t\t\t\r\n\t\t\tlastCfiIssuanceIndex += 1;\t\r\n\t\t}"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint cnt = 0"
          VariableDeclaration "cnt"
             Type: uint256
             Source: "uint cnt"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "cnt < _numberOfIssuances"
          Identifier cnt
             Type: uint256
             Source: "cnt"
          Identifier _numberOfIssuances
             Type: uint256
             Source: "_numberOfIssuances"
        ExpressionStatement
           Gas costs: 19
           Source: "cnt++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "cnt++"
            Identifier cnt
               Type: uint256
               Source: "cnt"
        Block
           Source: "{ \t\t\t\r\n\t\t\tcurrentParticipantAddress = participantIndex[lastCfiIssuanceIndex];\t// Get next participant address\r\n\t\t\tif (currentParticipantAddress == 0x0) continue; \t\t\t\r\n\t\t\ttokensToBeIssued = icoSupply * participantContribution[currentParticipantAddress] / totalEthRaised;\t\t// Calculate how much tokens will address get \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(currentParticipantAddress, tokensToBeIssued, \"Ico participation mint\");\t// Mint tokens @ CofounditToken \t\t\t\r\n\t\t\tlastCfiIssuanceIndex += 1;\t\r\n\t\t}"
          ExpressionStatement
             Gas costs: 528
             Source: "currentParticipantAddress = participantIndex[lastCfiIssuanceIndex]"
            Assignment using operator =
               Type: address
               Source: "currentParticipantAddress = participantIndex[lastCfiIssuanceIndex]"
              Identifier currentParticipantAddress
                 Type: address
                 Source: "currentParticipantAddress"
              IndexAccess
                 Type: address
                 Source: "participantIndex[lastCfiIssuanceIndex]"
                Identifier participantIndex
                   Type: mapping(uint256 => address)
                   Source: "participantIndex"
                Identifier lastCfiIssuanceIndex
                   Type: uint256
                   Source: "lastCfiIssuanceIndex"
          IfStatement
             Source: "if (currentParticipantAddress == 0x0) continue"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 15
               Source: "currentParticipantAddress == 0x0"
              Identifier currentParticipantAddress
                 Type: address
                 Source: "currentParticipantAddress"
              Literal, token: [no token] value: 0x0
                 Type: int_const 0
                 Source: "0x0"
            Continue
               Gas costs: 11
               Source: "continue"
          ExpressionStatement
             Gas costs: 743
             Source: "tokensToBeIssued = icoSupply * participantContribution[currentParticipantAddress] / totalEthRaised"
            Assignment using operator =
               Type: uint256
               Source: "tokensToBeIssued = icoSupply * participantContribution[currentParticipantAddress] / totalEthRaised"
              Identifier tokensToBeIssued
                 Type: uint256
                 Source: "tokensToBeIssued"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "icoSupply * participantContribution[currentParticipantAddress] / totalEthRaised"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "icoSupply * participantContribution[currentParticipantAddress]"
                  Identifier icoSupply
                     Type: uint256
                     Source: "icoSupply"
                  IndexAccess
                     Type: uint256
                     Source: "participantContribution[currentParticipantAddress]"
                    Identifier participantContribution
                       Type: mapping(address => uint256)
                       Source: "participantContribution"
                    Identifier currentParticipantAddress
                       Type: address
                       Source: "currentParticipantAddress"
                Identifier totalEthRaised
                   Type: uint256
                   Source: "totalEthRaised"
          ExpressionStatement
             Gas costs: [???]
             Source: "cofounditTokenContract.mintTokens(currentParticipantAddress, tokensToBeIssued, \"Ico participation mint\")"
            FunctionCall
               Type: tuple()
               Source: "cofounditTokenContract.mintTokens(currentParticipantAddress, tokensToBeIssued, \"Ico participation mint\")"
              MemberAccess to member mintTokens
                 Type: function (address,uint256,string memory) external
                 Source: "cofounditTokenContract.mintTokens"
                Identifier cofounditTokenContract
                   Type: contract ICofounditToken
                   Source: "cofounditTokenContract"
              Identifier currentParticipantAddress
                 Type: address
                 Source: "currentParticipantAddress"
              Identifier tokensToBeIssued
                 Type: uint256
                 Source: "tokensToBeIssued"
              Literal, token: [no token] value: Ico participation mint
                 Type: literal_string "Ico participation mint"
                 Source: "\"Ico participation mint\""
          ExpressionStatement
             Gas costs: 20233
             Source: "lastCfiIssuanceIndex += 1"
            Assignment using operator +=
               Type: uint256
               Source: "lastCfiIssuanceIndex += 1"
              Identifier lastCfiIssuanceIndex
                 Type: uint256
                 Source: "lastCfiIssuanceIndex"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      IfStatement
         Source: "if (participantIndex[lastCfiIssuanceIndex] == 0x0 && cofounditTokenContract.totalSupply() < icoSupply){\r\n\t\t\tuint divisionDifference = icoSupply - cofounditTokenContract.totalSupply();\r\n\t\t\tcofounditTokenContract.mintTokens(multisigAddress, divisionDifference, \"Mint division error\");\t// Mint divison difference @ CofounditToken so that total supply is whole number\t\t\t\r\n\t\t}"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: [???]
           Source: "participantIndex[lastCfiIssuanceIndex] == 0x0 && cofounditTokenContract.totalSupply() < icoSupply"
          BinaryOperation using operator ==
             Type: bool
             Source: "participantIndex[lastCfiIssuanceIndex] == 0x0"
            IndexAccess
               Type: address
               Source: "participantIndex[lastCfiIssuanceIndex]"
              Identifier participantIndex
                 Type: mapping(uint256 => address)
                 Source: "participantIndex"
              Identifier lastCfiIssuanceIndex
                 Type: uint256
                 Source: "lastCfiIssuanceIndex"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
          BinaryOperation using operator <
             Type: bool
             Source: "cofounditTokenContract.totalSupply() < icoSupply"
            FunctionCall
               Type: uint256
               Source: "cofounditTokenContract.totalSupply()"
              MemberAccess to member totalSupply
                 Type: function () view external returns (uint256)
                 Source: "cofounditTokenContract.totalSupply"
                Identifier cofounditTokenContract
                   Type: contract ICofounditToken
                   Source: "cofounditTokenContract"
            Identifier icoSupply
               Type: uint256
               Source: "icoSupply"
        Block
           Source: "{\r\n\t\t\tuint divisionDifference = icoSupply - cofounditTokenContract.totalSupply();\r\n\t\t\tcofounditTokenContract.mintTokens(multisigAddress, divisionDifference, \"Mint division error\");\t// Mint divison difference @ CofounditToken so that total supply is whole number\t\t\t\r\n\t\t}"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "uint divisionDifference = icoSupply - cofounditTokenContract.totalSupply()"
            VariableDeclaration "divisionDifference"
               Type: uint256
               Source: "uint divisionDifference"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator -
               Type: uint256
               Source: "icoSupply - cofounditTokenContract.totalSupply()"
              Identifier icoSupply
                 Type: uint256
                 Source: "icoSupply"
              FunctionCall
                 Type: uint256
                 Source: "cofounditTokenContract.totalSupply()"
                MemberAccess to member totalSupply
                   Type: function () view external returns (uint256)
                   Source: "cofounditTokenContract.totalSupply"
                  Identifier cofounditTokenContract
                     Type: contract ICofounditToken
                     Source: "cofounditTokenContract"
          ExpressionStatement
             Gas costs: [???]
             Source: "cofounditTokenContract.mintTokens(multisigAddress, divisionDifference, \"Mint division error\")"
            FunctionCall
               Type: tuple()
               Source: "cofounditTokenContract.mintTokens(multisigAddress, divisionDifference, \"Mint division error\")"
              MemberAccess to member mintTokens
                 Type: function (address,uint256,string memory) external
                 Source: "cofounditTokenContract.mintTokens"
                Identifier cofounditTokenContract
                   Type: contract ICofounditToken
                   Source: "cofounditTokenContract"
              Identifier multisigAddress
                 Type: address
                 Source: "multisigAddress"
              Identifier divisionDifference
                 Type: uint256
                 Source: "divisionDifference"
              Literal, token: [no token] value: Mint division error
                 Type: literal_string "Mint division error"
                 Source: "\"Mint division error\""
  FunctionDefinition "batchReturnEthIfFailed" - public
     Source: "function batchReturnEthIfFailed(uint256 _numberOfReturns) onlyOwner{ \t\t\r\n\t\tif (block.number < endBlock || totalEthRaised >= minEthToRaise) throw;\t\t// Check that ico has failed :( \t\t\r\n\t\taddress currentParticipantAddress; \t\t\r\n\t\tuint256 contribution;\r\n\t\tfor (uint cnt = 0; cnt < _numberOfReturns; cnt++){ \t\t\t\r\n\t\t\tcurrentParticipantAddress = participantIndex[lastEthReturnIndex];\t\t// Get next account \t\t\t\r\n\t\t\tif (currentParticipantAddress == 0x0) return;\t\t\t\t\t\t\t// If all the participants were reinbursed return \t\t\t\r\n\t\t\tif (!hasClaimedEthWhenFail[currentParticipantAddress]) {\t\t\t\t// Check if user has manually recovered eth \t\t\t\t\r\n\t\t\t\tcontribution = participantContribution[currentParticipantAddress];\t// Get accounts contribution \t\t\t\t\r\n\t\t\t\thasClaimedEthWhenFail[msg.sender] = true;\t\t\t\t\t\t\t// Set that user got his eth back \t\t\t\t\r\n\t\t\t\tif (!currentParticipantAddress.send(contribution)){\t\t\t\t\t// Send fund back to account \t\t\t\t\t\r\n\t\t\t\t\tErrorSendingETH(currentParticipantAddress, contribution);\t\t// Raise event if send failed and resolve manually \t\t\t\t\r\n\t\t\t\t} \t\t\t\r\n\t\t\t} \t\t\t\r\n\t\t\tlastEthReturnIndex += 1; \t\t\r\n\t\t} \t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _numberOfReturns)"
      VariableDeclaration "_numberOfReturns"
         Type: uint256
         Source: "uint256 _numberOfReturns"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{ \t\t\r\n\t\tif (block.number < endBlock || totalEthRaised >= minEthToRaise) throw;\t\t// Check that ico has failed :( \t\t\r\n\t\taddress currentParticipantAddress; \t\t\r\n\t\tuint256 contribution;\r\n\t\tfor (uint cnt = 0; cnt < _numberOfReturns; cnt++){ \t\t\t\r\n\t\t\tcurrentParticipantAddress = participantIndex[lastEthReturnIndex];\t\t// Get next account \t\t\t\r\n\t\t\tif (currentParticipantAddress == 0x0) return;\t\t\t\t\t\t\t// If all the participants were reinbursed return \t\t\t\r\n\t\t\tif (!hasClaimedEthWhenFail[currentParticipantAddress]) {\t\t\t\t// Check if user has manually recovered eth \t\t\t\t\r\n\t\t\t\tcontribution = participantContribution[currentParticipantAddress];\t// Get accounts contribution \t\t\t\t\r\n\t\t\t\thasClaimedEthWhenFail[msg.sender] = true;\t\t\t\t\t\t\t// Set that user got his eth back \t\t\t\t\r\n\t\t\t\tif (!currentParticipantAddress.send(contribution)){\t\t\t\t\t// Send fund back to account \t\t\t\t\t\r\n\t\t\t\t\tErrorSendingETH(currentParticipantAddress, contribution);\t\t// Raise event if send failed and resolve manually \t\t\t\t\r\n\t\t\t\t} \t\t\t\r\n\t\t\t} \t\t\t\r\n\t\t\tlastEthReturnIndex += 1; \t\t\r\n\t\t} \t\r\n\t}"
      IfStatement
         Source: "if (block.number < endBlock || totalEthRaised >= minEthToRaise) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 639
           Source: "block.number < endBlock || totalEthRaised >= minEthToRaise"
          BinaryOperation using operator <
             Type: bool
             Source: "block.number < endBlock"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier endBlock
               Type: uint256
               Source: "endBlock"
          BinaryOperation using operator >=
             Type: bool
             Source: "totalEthRaised >= minEthToRaise"
            Identifier totalEthRaised
               Type: uint256
               Source: "totalEthRaised"
            Identifier minEthToRaise
               Type: uint256
               Source: "minEthToRaise"
        Throw
           Gas costs: 6
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "address currentParticipantAddress"
        VariableDeclaration "currentParticipantAddress"
           Type: address
           Source: "address currentParticipantAddress"
          ElementaryTypeName address
             Source: "address"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint256 contribution"
        VariableDeclaration "contribution"
           Type: uint256
           Source: "uint256 contribution"
          ElementaryTypeName uint256
             Source: "uint256"
      ForStatement
         Source: "for (uint cnt = 0; cnt < _numberOfReturns; cnt++){ \t\t\t\r\n\t\t\tcurrentParticipantAddress = participantIndex[lastEthReturnIndex];\t\t// Get next account \t\t\t\r\n\t\t\tif (currentParticipantAddress == 0x0) return;\t\t\t\t\t\t\t// If all the participants were reinbursed return \t\t\t\r\n\t\t\tif (!hasClaimedEthWhenFail[currentParticipantAddress]) {\t\t\t\t// Check if user has manually recovered eth \t\t\t\t\r\n\t\t\t\tcontribution = participantContribution[currentParticipantAddress];\t// Get accounts contribution \t\t\t\t\r\n\t\t\t\thasClaimedEthWhenFail[msg.sender] = true;\t\t\t\t\t\t\t// Set that user got his eth back \t\t\t\t\r\n\t\t\t\tif (!currentParticipantAddress.send(contribution)){\t\t\t\t\t// Send fund back to account \t\t\t\t\t\r\n\t\t\t\t\tErrorSendingETH(currentParticipantAddress, contribution);\t\t// Raise event if send failed and resolve manually \t\t\t\t\r\n\t\t\t\t} \t\t\t\r\n\t\t\t} \t\t\t\r\n\t\t\tlastEthReturnIndex += 1; \t\t\r\n\t\t}"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint cnt = 0"
          VariableDeclaration "cnt"
             Type: uint256
             Source: "uint cnt"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "cnt < _numberOfReturns"
          Identifier cnt
             Type: uint256
             Source: "cnt"
          Identifier _numberOfReturns
             Type: uint256
             Source: "_numberOfReturns"
        ExpressionStatement
           Gas costs: 19
           Source: "cnt++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "cnt++"
            Identifier cnt
               Type: uint256
               Source: "cnt"
        Block
           Source: "{ \t\t\t\r\n\t\t\tcurrentParticipantAddress = participantIndex[lastEthReturnIndex];\t\t// Get next account \t\t\t\r\n\t\t\tif (currentParticipantAddress == 0x0) return;\t\t\t\t\t\t\t// If all the participants were reinbursed return \t\t\t\r\n\t\t\tif (!hasClaimedEthWhenFail[currentParticipantAddress]) {\t\t\t\t// Check if user has manually recovered eth \t\t\t\t\r\n\t\t\t\tcontribution = participantContribution[currentParticipantAddress];\t// Get accounts contribution \t\t\t\t\r\n\t\t\t\thasClaimedEthWhenFail[msg.sender] = true;\t\t\t\t\t\t\t// Set that user got his eth back \t\t\t\t\r\n\t\t\t\tif (!currentParticipantAddress.send(contribution)){\t\t\t\t\t// Send fund back to account \t\t\t\t\t\r\n\t\t\t\t\tErrorSendingETH(currentParticipantAddress, contribution);\t\t// Raise event if send failed and resolve manually \t\t\t\t\r\n\t\t\t\t} \t\t\t\r\n\t\t\t} \t\t\t\r\n\t\t\tlastEthReturnIndex += 1; \t\t\r\n\t\t}"
          ExpressionStatement
             Gas costs: 528
             Source: "currentParticipantAddress = participantIndex[lastEthReturnIndex]"
            Assignment using operator =
               Type: address
               Source: "currentParticipantAddress = participantIndex[lastEthReturnIndex]"
              Identifier currentParticipantAddress
                 Type: address
                 Source: "currentParticipantAddress"
              IndexAccess
                 Type: address
                 Source: "participantIndex[lastEthReturnIndex]"
                Identifier participantIndex
                   Type: mapping(uint256 => address)
                   Source: "participantIndex"
                Identifier lastEthReturnIndex
                   Type: uint256
                   Source: "lastEthReturnIndex"
          IfStatement
             Source: "if (currentParticipantAddress == 0x0) return;"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 15
               Source: "currentParticipantAddress == 0x0"
              Identifier currentParticipantAddress
                 Type: address
                 Source: "currentParticipantAddress"
              Literal, token: [no token] value: 0x0
                 Type: int_const 0
                 Source: "0x0"
            Return
               Gas costs: 11
               Source: "return;"
          IfStatement
             Source: "if (!hasClaimedEthWhenFail[currentParticipantAddress]) {\t\t\t\t// Check if user has manually recovered eth \t\t\t\t\r\n\t\t\t\tcontribution = participantContribution[currentParticipantAddress];\t// Get accounts contribution \t\t\t\t\r\n\t\t\t\thasClaimedEthWhenFail[msg.sender] = true;\t\t\t\t\t\t\t// Set that user got his eth back \t\t\t\t\r\n\t\t\t\tif (!currentParticipantAddress.send(contribution)){\t\t\t\t\t// Send fund back to account \t\t\t\t\t\r\n\t\t\t\t\tErrorSendingETH(currentParticipantAddress, contribution);\t\t// Raise event if send failed and resolve manually \t\t\t\t\r\n\t\t\t\t} \t\t\t\r\n\t\t\t}"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: 338
               Source: "!hasClaimedEthWhenFail[currentParticipantAddress]"
              IndexAccess
                 Type: bool
                 Source: "hasClaimedEthWhenFail[currentParticipantAddress]"
                Identifier hasClaimedEthWhenFail
                   Type: mapping(address => bool)
                   Source: "hasClaimedEthWhenFail"
                Identifier currentParticipantAddress
                   Type: address
                   Source: "currentParticipantAddress"
            Block
               Source: "{\t\t\t\t// Check if user has manually recovered eth \t\t\t\t\r\n\t\t\t\tcontribution = participantContribution[currentParticipantAddress];\t// Get accounts contribution \t\t\t\t\r\n\t\t\t\thasClaimedEthWhenFail[msg.sender] = true;\t\t\t\t\t\t\t// Set that user got his eth back \t\t\t\t\r\n\t\t\t\tif (!currentParticipantAddress.send(contribution)){\t\t\t\t\t// Send fund back to account \t\t\t\t\t\r\n\t\t\t\t\tErrorSendingETH(currentParticipantAddress, contribution);\t\t// Raise event if send failed and resolve manually \t\t\t\t\r\n\t\t\t\t} \t\t\t\r\n\t\t\t}"
              ExpressionStatement
                 Gas costs: 304
                 Source: "contribution = participantContribution[currentParticipantAddress]"
                Assignment using operator =
                   Type: uint256
                   Source: "contribution = participantContribution[currentParticipantAddress]"
                  Identifier contribution
                     Type: uint256
                     Source: "contribution"
                  IndexAccess
                     Type: uint256
                     Source: "participantContribution[currentParticipantAddress]"
                    Identifier participantContribution
                       Type: mapping(address => uint256)
                       Source: "participantContribution"
                    Identifier currentParticipantAddress
                       Type: address
                       Source: "currentParticipantAddress"
              ExpressionStatement
                 Gas costs: 20356
                 Source: "hasClaimedEthWhenFail[msg.sender] = true"
                Assignment using operator =
                   Type: bool
                   Source: "hasClaimedEthWhenFail[msg.sender] = true"
                  IndexAccess
                     Type: bool
                     Source: "hasClaimedEthWhenFail[msg.sender]"
                    Identifier hasClaimedEthWhenFail
                       Type: mapping(address => bool)
                       Source: "hasClaimedEthWhenFail"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                  Literal, token: true value: true
                     Type: bool
                     Source: "true"
              IfStatement
                 Source: "if (!currentParticipantAddress.send(contribution)){\t\t\t\t\t// Send fund back to account \t\t\t\t\t\r\n\t\t\t\t\tErrorSendingETH(currentParticipantAddress, contribution);\t\t// Raise event if send failed and resolve manually \t\t\t\t\r\n\t\t\t\t}"
                UnaryOperation (prefix) !
                   Type: bool
                   Gas costs: [???]
                   Source: "!currentParticipantAddress.send(contribution)"
                  FunctionCall
                     Type: bool
                     Source: "currentParticipantAddress.send(contribution)"
                    MemberAccess to member send
                       Type: function (uint256) returns (bool)
                       Source: "currentParticipantAddress.send"
                      Identifier currentParticipantAddress
                         Type: address
                         Source: "currentParticipantAddress"
                    Identifier contribution
                       Type: uint256
                       Source: "contribution"
                Block
                   Source: "{\t\t\t\t\t// Send fund back to account \t\t\t\t\t\r\n\t\t\t\t\tErrorSendingETH(currentParticipantAddress, contribution);\t\t// Raise event if send failed and resolve manually \t\t\t\t\r\n\t\t\t\t}"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "ErrorSendingETH(currentParticipantAddress, contribution)"
                    FunctionCall
                       Type: tuple()
                       Source: "ErrorSendingETH(currentParticipantAddress, contribution)"
                      Identifier ErrorSendingETH
                         Type: function (address,uint256)
                         Source: "ErrorSendingETH"
                      Identifier currentParticipantAddress
                         Type: address
                         Source: "currentParticipantAddress"
                      Identifier contribution
                         Type: uint256
                         Source: "contribution"
          ExpressionStatement
             Gas costs: 20233
             Source: "lastEthReturnIndex += 1"
            Assignment using operator +=
               Type: uint256
               Source: "lastEthReturnIndex += 1"
              Identifier lastEthReturnIndex
                 Type: uint256
                 Source: "lastEthReturnIndex"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
  FunctionDefinition "changeMultisigAddress" - public
     Source: "function changeMultisigAddress(address _newAddress) onlyOwner { \t\t\r\n\t\tmultisigAddress = _newAddress;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address _newAddress)"
      VariableDeclaration "_newAddress"
         Type: address
         Source: "address _newAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{ \t\t\r\n\t\tmultisigAddress = _newAddress;\r\n\t}"
      ExpressionStatement
         Gas costs: 20267
         Source: "multisigAddress = _newAddress"
        Assignment using operator =
           Type: address
           Source: "multisigAddress = _newAddress"
          Identifier multisigAddress
             Type: address
             Source: "multisigAddress"
          Identifier _newAddress
             Type: address
             Source: "_newAddress"
  FunctionDefinition "claimReservedTokens" - public
     Source: "function claimReservedTokens(string _which, address _to, uint256 _amount, string _reason) onlyOwner{ \t\t\r\n\t\tif (!icoHasSucessfulyEnded) throw;                 \r\n\t\tbytes32 hashedStr = sha3(_which);\t\t\t\t\r\n\t\tif (hashedStr == sha3(\"Reserve\")){ \t\t\t\r\n\t\t\tif (_amount > strategicReserveSupply - usedStrategicReserveSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, _reason); \t\t\t\r\n\t\t\tusedStrategicReserveSupply += _amount; \t\t\r\n\t\t} \t\t\r\n\t\telse if (hashedStr == sha3(\"Cashila\")){ \t\t\t\r\n\t\t\tif (_amount > cashilaTokenSupply - usedCashilaTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cashila\"); \t\t\t\r\n\t\t\tusedCashilaTokenSupply += _amount; \t\t} \t\t\r\n\t\telse if (hashedStr == sha3(\"Iconomi\")){ \t\t\t\r\n\t\t\tif (_amount > iconomiTokenSupply - usedIconomiTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for iconomi\"); \t\t\t\r\n\t\t\tusedIconomiTokenSupply += _amount; \t\t\r\n\t\t}\r\n\t\telse if (hashedStr == sha3(\"Core\")){ \t\t\t\r\n\t\t\tif (_amount > coreTeamTokenSupply - usedCoreTeamTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cofoundit team\"); \t\t\t\r\n\t\t\tusedCoreTeamTokenSupply += _amount; \t\t\r\n\t\t} \t\t\r\n\t\telse throw; \t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(string _which, address _to, uint256 _amount, string _reason)"
      VariableDeclaration "_which"
         Type: string memory
         Source: "string _which"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_reason"
         Type: string memory
         Source: "string _reason"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{ \t\t\r\n\t\tif (!icoHasSucessfulyEnded) throw;                 \r\n\t\tbytes32 hashedStr = sha3(_which);\t\t\t\t\r\n\t\tif (hashedStr == sha3(\"Reserve\")){ \t\t\t\r\n\t\t\tif (_amount > strategicReserveSupply - usedStrategicReserveSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, _reason); \t\t\t\r\n\t\t\tusedStrategicReserveSupply += _amount; \t\t\r\n\t\t} \t\t\r\n\t\telse if (hashedStr == sha3(\"Cashila\")){ \t\t\t\r\n\t\t\tif (_amount > cashilaTokenSupply - usedCashilaTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cashila\"); \t\t\t\r\n\t\t\tusedCashilaTokenSupply += _amount; \t\t} \t\t\r\n\t\telse if (hashedStr == sha3(\"Iconomi\")){ \t\t\t\r\n\t\t\tif (_amount > iconomiTokenSupply - usedIconomiTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for iconomi\"); \t\t\t\r\n\t\t\tusedIconomiTokenSupply += _amount; \t\t\r\n\t\t}\r\n\t\telse if (hashedStr == sha3(\"Core\")){ \t\t\t\r\n\t\t\tif (_amount > coreTeamTokenSupply - usedCoreTeamTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cofoundit team\"); \t\t\t\r\n\t\t\tusedCoreTeamTokenSupply += _amount; \t\t\r\n\t\t} \t\t\r\n\t\telse throw; \t\r\n\t}"
      IfStatement
         Source: "if (!icoHasSucessfulyEnded) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 292
           Source: "!icoHasSucessfulyEnded"
          Identifier icoHasSucessfulyEnded
             Type: bool
             Source: "icoHasSucessfulyEnded"
        Throw
           Gas costs: 6
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "bytes32 hashedStr = sha3(_which)"
        VariableDeclaration "hashedStr"
           Type: bytes32
           Source: "bytes32 hashedStr"
          ElementaryTypeName bytes32
             Source: "bytes32"
        FunctionCall
           Type: bytes32
           Source: "sha3(_which)"
          Identifier sha3
             Type: function () pure returns (bytes32)
             Source: "sha3"
          Identifier _which
             Type: string memory
             Source: "_which"
      IfStatement
         Source: "if (hashedStr == sha3(\"Reserve\")){ \t\t\t\r\n\t\t\tif (_amount > strategicReserveSupply - usedStrategicReserveSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, _reason); \t\t\t\r\n\t\t\tusedStrategicReserveSupply += _amount; \t\t\r\n\t\t} \t\t\r\n\t\telse if (hashedStr == sha3(\"Cashila\")){ \t\t\t\r\n\t\t\tif (_amount > cashilaTokenSupply - usedCashilaTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cashila\"); \t\t\t\r\n\t\t\tusedCashilaTokenSupply += _amount; \t\t} \t\t\r\n\t\telse if (hashedStr == sha3(\"Iconomi\")){ \t\t\t\r\n\t\t\tif (_amount > iconomiTokenSupply - usedIconomiTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for iconomi\"); \t\t\t\r\n\t\t\tusedIconomiTokenSupply += _amount; \t\t\r\n\t\t}\r\n\t\telse if (hashedStr == sha3(\"Core\")){ \t\t\t\r\n\t\t\tif (_amount > coreTeamTokenSupply - usedCoreTeamTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cofoundit team\"); \t\t\t\r\n\t\t\tusedCoreTeamTokenSupply += _amount; \t\t\r\n\t\t} \t\t\r\n\t\telse throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: [???]
           Source: "hashedStr == sha3(\"Reserve\")"
          Identifier hashedStr
             Type: bytes32
             Source: "hashedStr"
          FunctionCall
             Type: bytes32
             Source: "sha3(\"Reserve\")"
            Identifier sha3
               Type: function () pure returns (bytes32)
               Source: "sha3"
            Literal, token: [no token] value: Reserve
               Type: literal_string "Reserve"
               Source: "\"Reserve\""
        Block
           Source: "{ \t\t\t\r\n\t\t\tif (_amount > strategicReserveSupply - usedStrategicReserveSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, _reason); \t\t\t\r\n\t\t\tusedStrategicReserveSupply += _amount; \t\t\r\n\t\t}"
          IfStatement
             Source: "if (_amount > strategicReserveSupply - usedStrategicReserveSupply) throw"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 415
               Source: "_amount > strategicReserveSupply - usedStrategicReserveSupply"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "strategicReserveSupply - usedStrategicReserveSupply"
                Identifier strategicReserveSupply
                   Type: uint256
                   Source: "strategicReserveSupply"
                Identifier usedStrategicReserveSupply
                   Type: uint256
                   Source: "usedStrategicReserveSupply"
            Throw
               Gas costs: 6
               Source: "throw"
          ExpressionStatement
             Gas costs: [???]
             Source: "cofounditTokenContract.mintTokens(_to, _amount, _reason)"
            FunctionCall
               Type: tuple()
               Source: "cofounditTokenContract.mintTokens(_to, _amount, _reason)"
              MemberAccess to member mintTokens
                 Type: function (address,uint256,string memory) external
                 Source: "cofounditTokenContract.mintTokens"
                Identifier cofounditTokenContract
                   Type: contract ICofounditToken
                   Source: "cofounditTokenContract"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
              Identifier _reason
                 Type: string memory
                 Source: "_reason"
          ExpressionStatement
             Gas costs: 20233
             Source: "usedStrategicReserveSupply += _amount"
            Assignment using operator +=
               Type: uint256
               Source: "usedStrategicReserveSupply += _amount"
              Identifier usedStrategicReserveSupply
                 Type: uint256
                 Source: "usedStrategicReserveSupply"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
        IfStatement
           Source: "if (hashedStr == sha3(\"Cashila\")){ \t\t\t\r\n\t\t\tif (_amount > cashilaTokenSupply - usedCashilaTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cashila\"); \t\t\t\r\n\t\t\tusedCashilaTokenSupply += _amount; \t\t} \t\t\r\n\t\telse if (hashedStr == sha3(\"Iconomi\")){ \t\t\t\r\n\t\t\tif (_amount > iconomiTokenSupply - usedIconomiTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for iconomi\"); \t\t\t\r\n\t\t\tusedIconomiTokenSupply += _amount; \t\t\r\n\t\t}\r\n\t\telse if (hashedStr == sha3(\"Core\")){ \t\t\t\r\n\t\t\tif (_amount > coreTeamTokenSupply - usedCoreTeamTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cofoundit team\"); \t\t\t\r\n\t\t\tusedCoreTeamTokenSupply += _amount; \t\t\r\n\t\t} \t\t\r\n\t\telse throw"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: [???]
             Source: "hashedStr == sha3(\"Cashila\")"
            Identifier hashedStr
               Type: bytes32
               Source: "hashedStr"
            FunctionCall
               Type: bytes32
               Source: "sha3(\"Cashila\")"
              Identifier sha3
                 Type: function () pure returns (bytes32)
                 Source: "sha3"
              Literal, token: [no token] value: Cashila
                 Type: literal_string "Cashila"
                 Source: "\"Cashila\""
          Block
             Source: "{ \t\t\t\r\n\t\t\tif (_amount > cashilaTokenSupply - usedCashilaTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cashila\"); \t\t\t\r\n\t\t\tusedCashilaTokenSupply += _amount; \t\t}"
            IfStatement
               Source: "if (_amount > cashilaTokenSupply - usedCashilaTokenSupply) throw"
              BinaryOperation using operator >
                 Type: bool
                 Gas costs: 415
                 Source: "_amount > cashilaTokenSupply - usedCashilaTokenSupply"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "cashilaTokenSupply - usedCashilaTokenSupply"
                  Identifier cashilaTokenSupply
                     Type: uint256
                     Source: "cashilaTokenSupply"
                  Identifier usedCashilaTokenSupply
                     Type: uint256
                     Source: "usedCashilaTokenSupply"
              Throw
                 Gas costs: 6
                 Source: "throw"
            ExpressionStatement
               Gas costs: [???]
               Source: "cofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cashila\")"
              FunctionCall
                 Type: tuple()
                 Source: "cofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cashila\")"
                MemberAccess to member mintTokens
                   Type: function (address,uint256,string memory) external
                   Source: "cofounditTokenContract.mintTokens"
                  Identifier cofounditTokenContract
                     Type: contract ICofounditToken
                     Source: "cofounditTokenContract"
                Identifier _to
                   Type: address
                   Source: "_to"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
                Literal, token: [no token] value: Reserved tokens for cashila
                   Type: literal_string "Reserved tokens for cashila"
                   Source: "\"Reserved tokens for cashila\""
            ExpressionStatement
               Gas costs: 20233
               Source: "usedCashilaTokenSupply += _amount"
              Assignment using operator +=
                 Type: uint256
                 Source: "usedCashilaTokenSupply += _amount"
                Identifier usedCashilaTokenSupply
                   Type: uint256
                   Source: "usedCashilaTokenSupply"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
          IfStatement
             Source: "if (hashedStr == sha3(\"Iconomi\")){ \t\t\t\r\n\t\t\tif (_amount > iconomiTokenSupply - usedIconomiTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for iconomi\"); \t\t\t\r\n\t\t\tusedIconomiTokenSupply += _amount; \t\t\r\n\t\t}\r\n\t\telse if (hashedStr == sha3(\"Core\")){ \t\t\t\r\n\t\t\tif (_amount > coreTeamTokenSupply - usedCoreTeamTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cofoundit team\"); \t\t\t\r\n\t\t\tusedCoreTeamTokenSupply += _amount; \t\t\r\n\t\t} \t\t\r\n\t\telse throw"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: [???]
               Source: "hashedStr == sha3(\"Iconomi\")"
              Identifier hashedStr
                 Type: bytes32
                 Source: "hashedStr"
              FunctionCall
                 Type: bytes32
                 Source: "sha3(\"Iconomi\")"
                Identifier sha3
                   Type: function () pure returns (bytes32)
                   Source: "sha3"
                Literal, token: [no token] value: Iconomi
                   Type: literal_string "Iconomi"
                   Source: "\"Iconomi\""
            Block
               Source: "{ \t\t\t\r\n\t\t\tif (_amount > iconomiTokenSupply - usedIconomiTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for iconomi\"); \t\t\t\r\n\t\t\tusedIconomiTokenSupply += _amount; \t\t\r\n\t\t}"
              IfStatement
                 Source: "if (_amount > iconomiTokenSupply - usedIconomiTokenSupply) throw"
                BinaryOperation using operator >
                   Type: bool
                   Gas costs: 415
                   Source: "_amount > iconomiTokenSupply - usedIconomiTokenSupply"
                  Identifier _amount
                     Type: uint256
                     Source: "_amount"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "iconomiTokenSupply - usedIconomiTokenSupply"
                    Identifier iconomiTokenSupply
                       Type: uint256
                       Source: "iconomiTokenSupply"
                    Identifier usedIconomiTokenSupply
                       Type: uint256
                       Source: "usedIconomiTokenSupply"
                Throw
                   Gas costs: 6
                   Source: "throw"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "cofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for iconomi\")"
                FunctionCall
                   Type: tuple()
                   Source: "cofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for iconomi\")"
                  MemberAccess to member mintTokens
                     Type: function (address,uint256,string memory) external
                     Source: "cofounditTokenContract.mintTokens"
                    Identifier cofounditTokenContract
                       Type: contract ICofounditToken
                       Source: "cofounditTokenContract"
                  Identifier _to
                     Type: address
                     Source: "_to"
                  Identifier _amount
                     Type: uint256
                     Source: "_amount"
                  Literal, token: [no token] value: Reserved tokens for iconomi
                     Type: literal_string "Reserved tokens for iconomi"
                     Source: "\"Reserved tokens for iconomi\""
              ExpressionStatement
                 Gas costs: 20233
                 Source: "usedIconomiTokenSupply += _amount"
                Assignment using operator +=
                   Type: uint256
                   Source: "usedIconomiTokenSupply += _amount"
                  Identifier usedIconomiTokenSupply
                     Type: uint256
                     Source: "usedIconomiTokenSupply"
                  Identifier _amount
                     Type: uint256
                     Source: "_amount"
            IfStatement
               Source: "if (hashedStr == sha3(\"Core\")){ \t\t\t\r\n\t\t\tif (_amount > coreTeamTokenSupply - usedCoreTeamTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cofoundit team\"); \t\t\t\r\n\t\t\tusedCoreTeamTokenSupply += _amount; \t\t\r\n\t\t} \t\t\r\n\t\telse throw"
              BinaryOperation using operator ==
                 Type: bool
                 Gas costs: [???]
                 Source: "hashedStr == sha3(\"Core\")"
                Identifier hashedStr
                   Type: bytes32
                   Source: "hashedStr"
                FunctionCall
                   Type: bytes32
                   Source: "sha3(\"Core\")"
                  Identifier sha3
                     Type: function () pure returns (bytes32)
                     Source: "sha3"
                  Literal, token: [no token] value: Core
                     Type: literal_string "Core"
                     Source: "\"Core\""
              Block
                 Source: "{ \t\t\t\r\n\t\t\tif (_amount > coreTeamTokenSupply - usedCoreTeamTokenSupply) throw; \t\t\t\r\n\t\t\tcofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cofoundit team\"); \t\t\t\r\n\t\t\tusedCoreTeamTokenSupply += _amount; \t\t\r\n\t\t}"
                IfStatement
                   Source: "if (_amount > coreTeamTokenSupply - usedCoreTeamTokenSupply) throw"
                  BinaryOperation using operator >
                     Type: bool
                     Gas costs: 415
                     Source: "_amount > coreTeamTokenSupply - usedCoreTeamTokenSupply"
                    Identifier _amount
                       Type: uint256
                       Source: "_amount"
                    BinaryOperation using operator -
                       Type: uint256
                       Source: "coreTeamTokenSupply - usedCoreTeamTokenSupply"
                      Identifier coreTeamTokenSupply
                         Type: uint256
                         Source: "coreTeamTokenSupply"
                      Identifier usedCoreTeamTokenSupply
                         Type: uint256
                         Source: "usedCoreTeamTokenSupply"
                  Throw
                     Gas costs: 6
                     Source: "throw"
                ExpressionStatement
                   Gas costs: [???]
                   Source: "cofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cofoundit team\")"
                  FunctionCall
                     Type: tuple()
                     Source: "cofounditTokenContract.mintTokens(_to, _amount, \"Reserved tokens for cofoundit team\")"
                    MemberAccess to member mintTokens
                       Type: function (address,uint256,string memory) external
                       Source: "cofounditTokenContract.mintTokens"
                      Identifier cofounditTokenContract
                         Type: contract ICofounditToken
                         Source: "cofounditTokenContract"
                    Identifier _to
                       Type: address
                       Source: "_to"
                    Identifier _amount
                       Type: uint256
                       Source: "_amount"
                    Literal, token: [no token] value: Reserved tokens for cofoundit team
                       Type: literal_string "Reserved tokens for cofoundit team"
                       Source: "\"Reserved tokens for cofoundit team\""
                ExpressionStatement
                   Gas costs: 20233
                   Source: "usedCoreTeamTokenSupply += _amount"
                  Assignment using operator +=
                     Type: uint256
                     Source: "usedCoreTeamTokenSupply += _amount"
                    Identifier usedCoreTeamTokenSupply
                       Type: uint256
                       Source: "usedCoreTeamTokenSupply"
                    Identifier _amount
                       Type: uint256
                       Source: "_amount"
              Throw
                 Gas costs: 6
                 Source: "throw"
  FunctionDefinition "removePresaleContributor" - public
     Source: "function removePresaleContributor(address _presaleContributor) onlyOwner { \t\t\r\n\t\tpresaleContributorAllowance[_presaleContributor] = false; \t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address _presaleContributor)"
      VariableDeclaration "_presaleContributor"
         Type: address
         Source: "address _presaleContributor"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{ \t\t\r\n\t\tpresaleContributorAllowance[_presaleContributor] = false; \t\r\n\t}"
      ExpressionStatement
         Gas costs: 20363
         Source: "presaleContributorAllowance[_presaleContributor] = false"
        Assignment using operator =
           Type: bool
           Source: "presaleContributorAllowance[_presaleContributor] = false"
          IndexAccess
             Type: bool
             Source: "presaleContributorAllowance[_presaleContributor]"
            Identifier presaleContributorAllowance
               Type: mapping(address => bool)
               Source: "presaleContributorAllowance"
            Identifier _presaleContributor
               Type: address
               Source: "_presaleContributor"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "setTokenContract" - public
     Source: "function setTokenContract(address _cofounditContractAddress) onlyOwner { \t\t\r\n\t\tcofounditTokenContract = ICofounditToken(_cofounditContractAddress); \t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address _cofounditContractAddress)"
      VariableDeclaration "_cofounditContractAddress"
         Type: address
         Source: "address _cofounditContractAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{ \t\t\r\n\t\tcofounditTokenContract = ICofounditToken(_cofounditContractAddress); \t\r\n\t}"
      ExpressionStatement
         Gas costs: 20267
         Source: "cofounditTokenContract = ICofounditToken(_cofounditContractAddress)"
        Assignment using operator =
           Type: contract ICofounditToken
           Source: "cofounditTokenContract = ICofounditToken(_cofounditContractAddress)"
          Identifier cofounditTokenContract
             Type: contract ICofounditToken
             Source: "cofounditTokenContract"
          FunctionCall
             Type: contract ICofounditToken
             Source: "ICofounditToken(_cofounditContractAddress)"
            Identifier ICofounditToken
               Type: type(contract ICofounditToken)
               Source: "ICofounditToken"
            Identifier _cofounditContractAddress
               Type: address
               Source: "_cofounditContractAddress"
  FunctionDefinition "withdrawEth" - public
     Source: "function withdrawEth() onlyOwner{ \t\t\r\n\t\tif (this.balance == 0) throw;\t\t\t\t// Check if there is something on the contract \t\t\r\n\t\tif (totalEthRaised < minEthToRaise) throw;\t// Check if minEth treshold is surpassed \t\t\r\n\t\tif (block.number > endBlock){\t\t\t\t// Check if ico has ended withouth reaching the maxCap \t\t\t\r\n\t\t\ticoHasSucessfulyEnded = true; \t\t\t\r\n\t\t\tICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyMessage); \t\t\r\n\t\t} \t\t\r\n\t\tif(multisigAddress.send(this.balance)){}\t\t// Send contracts whole balance to multisig address \t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{ \t\t\r\n\t\tif (this.balance == 0) throw;\t\t\t\t// Check if there is something on the contract \t\t\r\n\t\tif (totalEthRaised < minEthToRaise) throw;\t// Check if minEth treshold is surpassed \t\t\r\n\t\tif (block.number > endBlock){\t\t\t\t// Check if ico has ended withouth reaching the maxCap \t\t\t\r\n\t\t\ticoHasSucessfulyEnded = true; \t\t\t\r\n\t\t\tICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyMessage); \t\t\r\n\t\t} \t\t\r\n\t\tif(multisigAddress.send(this.balance)){}\t\t// Send contracts whole balance to multisig address \t\r\n\t}"
      IfStatement
         Source: "if (this.balance == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 414
           Source: "this.balance == 0"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract CofounditICO
               Source: "this"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (totalEthRaised < minEthToRaise) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 409
           Source: "totalEthRaised < minEthToRaise"
          Identifier totalEthRaised
             Type: uint256
             Source: "totalEthRaised"
          Identifier minEthToRaise
             Type: uint256
             Source: "minEthToRaise"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (block.number > endBlock){\t\t\t\t// Check if ico has ended withouth reaching the maxCap \t\t\t\r\n\t\t\ticoHasSucessfulyEnded = true; \t\t\t\r\n\t\t\tICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyMessage); \t\t\r\n\t\t}"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 208
           Source: "block.number > endBlock"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          Identifier endBlock
             Type: uint256
             Source: "endBlock"
        Block
           Source: "{\t\t\t\t// Check if ico has ended withouth reaching the maxCap \t\t\t\r\n\t\t\ticoHasSucessfulyEnded = true; \t\t\t\r\n\t\t\tICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyMessage); \t\t\r\n\t\t}"
          ExpressionStatement
             Gas costs: 20317
             Source: "icoHasSucessfulyEnded = true"
            Assignment using operator =
               Type: bool
               Source: "icoHasSucessfulyEnded = true"
              Identifier icoHasSucessfulyEnded
                 Type: bool
                 Source: "icoHasSucessfulyEnded"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
          ExpressionStatement
             Gas costs: [???]
             Source: "ICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyMessage)"
            FunctionCall
               Type: tuple()
               Source: "ICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyMessage)"
              Identifier ICOEndedSuccessfuly
                 Type: function (uint256,uint256,string memory)
                 Source: "ICOEndedSuccessfuly"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              Identifier totalEthRaised
                 Type: uint256
                 Source: "totalEthRaised"
              Identifier icoEndedSuccessfulyMessage
                 Type: string storage ref
                 Source: "icoEndedSuccessfulyMessage"
      IfStatement
         Source: "if(multisigAddress.send(this.balance)){}"
        FunctionCall
           Type: bool
           Gas costs: [???]
           Source: "multisigAddress.send(this.balance)"
          MemberAccess to member send
             Type: function (uint256) returns (bool)
             Source: "multisigAddress.send"
            Identifier multisigAddress
               Type: address
               Source: "multisigAddress"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract CofounditICO
               Source: "this"
        Block
           Gas costs: 0
           Source: "{}"
  FunctionDefinition "withdrawRemainingBalanceForManualRecovery" - public
     Source: "function withdrawRemainingBalanceForManualRecovery() onlyOwner{ \t\t\r\n\t\tif (this.balance == 0) throw;\t\t\t\t\t\t\t\t\t\t\t// Check if there is something on the contract \t\t\r\n\t\tif (block.number < endBlock || totalEthRaised >= minEthToRaise) throw;\t// Check if ico has failed :( \t\t\r\n\t\tif (participantIndex[lastEthReturnIndex] != 0x0) throw;\t\t\t\t\t// Check if all the participants has been reinbursed \t\t\r\n\t\tif(multisigAddress.send(this.balance)){}\t\t\t\t\t\t\t\t// Send remainder so it can be manually processed \t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{ \t\t\r\n\t\tif (this.balance == 0) throw;\t\t\t\t\t\t\t\t\t\t\t// Check if there is something on the contract \t\t\r\n\t\tif (block.number < endBlock || totalEthRaised >= minEthToRaise) throw;\t// Check if ico has failed :( \t\t\r\n\t\tif (participantIndex[lastEthReturnIndex] != 0x0) throw;\t\t\t\t\t// Check if all the participants has been reinbursed \t\t\r\n\t\tif(multisigAddress.send(this.balance)){}\t\t\t\t\t\t\t\t// Send remainder so it can be manually processed \t\r\n\t}"
      IfStatement
         Source: "if (this.balance == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 414
           Source: "this.balance == 0"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract CofounditICO
               Source: "this"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (block.number < endBlock || totalEthRaised >= minEthToRaise) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 639
           Source: "block.number < endBlock || totalEthRaised >= minEthToRaise"
          BinaryOperation using operator <
             Type: bool
             Source: "block.number < endBlock"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier endBlock
               Type: uint256
               Source: "endBlock"
          BinaryOperation using operator >=
             Type: bool
             Source: "totalEthRaised >= minEthToRaise"
            Identifier totalEthRaised
               Type: uint256
               Source: "totalEthRaised"
            Identifier minEthToRaise
               Type: uint256
               Source: "minEthToRaise"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (participantIndex[lastEthReturnIndex] != 0x0) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 538
           Source: "participantIndex[lastEthReturnIndex] != 0x0"
          IndexAccess
             Type: address
             Source: "participantIndex[lastEthReturnIndex]"
            Identifier participantIndex
               Type: mapping(uint256 => address)
               Source: "participantIndex"
            Identifier lastEthReturnIndex
               Type: uint256
               Source: "lastEthReturnIndex"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if(multisigAddress.send(this.balance)){}"
        FunctionCall
           Type: bool
           Gas costs: [???]
           Source: "multisigAddress.send(this.balance)"
          MemberAccess to member send
             Type: function (uint256) returns (bool)
             Source: "multisigAddress.send"
            Identifier multisigAddress
               Type: address
               Source: "multisigAddress"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract CofounditICO
               Source: "this"
        Block
           Gas costs: 0
           Source: "{}"
  FunctionDefinition "getCfiEstimation" - public - const
     Source: "function getCfiEstimation(address _querryAddress) constant returns (uint256 answer){ \t\t\r\n\t\treturn icoSupply * participantContribution[_querryAddress] / totalEthRaised; \t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address _querryAddress)"
      VariableDeclaration "_querryAddress"
         Type: address
         Source: "address _querryAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 answer)"
      VariableDeclaration "answer"
         Type: uint256
         Source: "uint256 answer"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{ \t\t\r\n\t\treturn icoSupply * participantContribution[_querryAddress] / totalEthRaised; \t\r\n\t}"
      Return
         Gas costs: 743
         Source: "return icoSupply * participantContribution[_querryAddress] / totalEthRaised"
        BinaryOperation using operator /
           Type: uint256
           Source: "icoSupply * participantContribution[_querryAddress] / totalEthRaised"
          BinaryOperation using operator *
             Type: uint256
             Source: "icoSupply * participantContribution[_querryAddress]"
            Identifier icoSupply
               Type: uint256
               Source: "icoSupply"
            IndexAccess
               Type: uint256
               Source: "participantContribution[_querryAddress]"
              Identifier participantContribution
                 Type: mapping(address => uint256)
                 Source: "participantContribution"
              Identifier _querryAddress
                 Type: address
                 Source: "_querryAddress"
          Identifier totalEthRaised
             Type: uint256
             Source: "totalEthRaised"
  FunctionDefinition "getCofounditTokenAddress" - public - const
     Source: "function getCofounditTokenAddress() constant returns(address _tokenAddress){ \t\t\r\n\t\treturn address(cofounditTokenContract); \t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(address _tokenAddress)"
      VariableDeclaration "_tokenAddress"
         Type: address
         Source: "address _tokenAddress"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{ \t\t\r\n\t\treturn address(cofounditTokenContract); \t\r\n\t}"
      Return
         Gas costs: 244
         Source: "return address(cofounditTokenContract)"
        FunctionCall
           Type: address
           Source: "address(cofounditTokenContract)"
          ElementaryTypeNameExpression address
             Type: type(address)
             Source: "address"
          Identifier cofounditTokenContract
             Type: contract ICofounditToken
             Source: "cofounditTokenContract"
  FunctionDefinition "icoInProgress" - public - const
     Source: "function icoInProgress() constant returns (bool answer){ \t\t\r\n\t\treturn icoHasStarted && !icoHasSucessfulyEnded; \t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool answer)"
      VariableDeclaration "answer"
         Type: bool
         Source: "bool answer"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{ \t\t\r\n\t\treturn icoHasStarted && !icoHasSucessfulyEnded; \t\r\n\t}"
      Return
         Gas costs: 558
         Source: "return icoHasStarted && !icoHasSucessfulyEnded"
        BinaryOperation using operator &&
           Type: bool
           Source: "icoHasStarted && !icoHasSucessfulyEnded"
          Identifier icoHasStarted
             Type: bool
             Source: "icoHasStarted"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!icoHasSucessfulyEnded"
            Identifier icoHasSucessfulyEnded
               Type: bool
               Source: "icoHasSucessfulyEnded"
  FunctionDefinition "isAddressAllowedInPresale" - public - const
     Source: "function isAddressAllowedInPresale(address _querryAddress) constant returns (bool answer){ \t\t\r\n\t\treturn presaleContributorAllowance[_querryAddress]; \t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address _querryAddress)"
      VariableDeclaration "_querryAddress"
         Type: address
         Source: "address _querryAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool answer)"
      VariableDeclaration "answer"
         Type: bool
         Source: "bool answer"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{ \t\t\r\n\t\treturn presaleContributorAllowance[_querryAddress]; \t\r\n\t}"
      Return
         Gas costs: 340
         Source: "return presaleContributorAllowance[_querryAddress]"
        IndexAccess
           Type: bool
           Source: "presaleContributorAllowance[_querryAddress]"
          Identifier presaleContributorAllowance
             Type: mapping(address => bool)
             Source: "presaleContributorAllowance"
          Identifier _querryAddress
             Type: address
             Source: "_querryAddress"
  FunctionDefinition "participantContributionInEth" - public - const
     Source: "function participantContributionInEth(address _querryAddress) constant returns (uint256 answer){ \t\t\r\n\t\treturn participantContribution[_querryAddress]; \t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address _querryAddress)"
      VariableDeclaration "_querryAddress"
         Type: address
         Source: "address _querryAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 answer)"
      VariableDeclaration "answer"
         Type: uint256
         Source: "uint256 answer"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{ \t\t\r\n\t\treturn participantContribution[_querryAddress]; \t\r\n\t}"
      Return
         Gas costs: 304
         Source: "return participantContribution[_querryAddress]"
        IndexAccess
           Type: uint256
           Source: "participantContribution[_querryAddress]"
          Identifier participantContribution
             Type: mapping(address => uint256)
             Source: "participantContribution"
          Identifier _querryAddress
             Type: address
             Source: "_querryAddress"
