Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x44cba3a62a15ac8f66ff75bf7abd058dcca7d7ed.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.17;"
ContractDefinition "ERC20"
   Gas costs: 0
   Source: "contract ERC20 {\r\n    uint public totalSupply;\r\n\r\n    // ERC223 and ERC20 functions and events\r\n    function balanceOf(address who) public constant returns (uint);\r\n    function totalSupply() constant public returns (uint256 _supply);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value, bytes data) public returns (bool ok);\r\n    function transfer(address to, uint value, bytes data, string customFallback) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\r\n\r\n    // ERC223 functions\r\n    function name() constant public returns (string _name);\r\n    function symbol() constant public returns (string _symbol);\r\n    function decimals() constant public returns (uint8 _decimals);\r\n\r\n    // ERC20 functions and events\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint public totalSupply"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) public constant returns (uint);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() constant public returns (uint256 _supply);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256 _supply)"
      VariableDeclaration "_supply"
         Type: uint256
         Source: "uint256 _supply"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint value) public returns (bool ok);"
    ParameterList
       Source: "(address to, uint value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint value, bytes data) public returns (bool ok);"
    ParameterList
       Source: "(address to, uint value, bytes data)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "data"
         Type: bytes memory
         Source: "bytes data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint value, bytes data, string customFallback) public returns (bool ok);"
    ParameterList
       Source: "(address to, uint value, bytes data, string customFallback)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "data"
         Type: bytes memory
         Source: "bytes data"
        ElementaryTypeName bytes
           Source: "bytes"
      VariableDeclaration "customFallback"
         Type: string memory
         Source: "string customFallback"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint value, bytes indexed data)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "data"
         Type: bytes memory
         Source: "bytes indexed data"
        ElementaryTypeName bytes
           Source: "bytes"
  FunctionDefinition "name" - public - const
     Source: "function name() constant public returns (string _name);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(string _name)"
      VariableDeclaration "_name"
         Type: string memory
         Source: "string _name"
        ElementaryTypeName string
           Source: "string"
  FunctionDefinition "symbol" - public - const
     Source: "function symbol() constant public returns (string _symbol);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(string _symbol)"
      VariableDeclaration "_symbol"
         Type: string memory
         Source: "string _symbol"
        ElementaryTypeName string
           Source: "string"
  FunctionDefinition "decimals" - public - const
     Source: "function decimals() constant public returns (uint8 _decimals);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint8 _decimals)"
      VariableDeclaration "_decimals"
         Type: uint8
         Source: "uint8 _decimals"
        ElementaryTypeName uint8
           Source: "uint8"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "SafeMath"
   Source: "contract SafeMath {\r\n    uint256 constant public MAX_UINT256 =\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (x > MAX_UINT256 - y)\r\n            revert();\r\n        return x + y;\r\n    }\r\n\r\n    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (x < y) {\r\n            revert();\r\n        }\r\n        return x - y;\r\n    }\r\n\r\n    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (y == 0) {\r\n            return 0;\r\n        }\r\n        if (x > MAX_UINT256 / y) {\r\n            revert();\r\n        }\r\n        return x * y;\r\n    }\r\n}"
  VariableDeclaration "MAX_UINT256"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 constant public MAX_UINT256 =\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
       Type: int_const 1157...(70 digits omitted)...9935
       Source: "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
  FunctionDefinition "safeAdd" - const
     Source: "function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (x > MAX_UINT256 - y)\r\n            revert();\r\n        return x + y;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 z)"
      VariableDeclaration "z"
         Type: uint256
         Source: "uint256 z"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        if (x > MAX_UINT256 - y)\r\n            revert();\r\n        return x + y;\r\n    }"
      IfStatement
         Source: "if (x > MAX_UINT256 - y)\r\n            revert()"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 12
           Source: "x > MAX_UINT256 - y"
          Identifier x
             Type: uint256
             Source: "x"
          BinaryOperation using operator -
             Type: uint256
             Source: "MAX_UINT256 - y"
            Identifier MAX_UINT256
               Type: uint256
               Source: "MAX_UINT256"
            Identifier y
               Type: uint256
               Source: "y"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      Return
         Gas costs: 14
         Source: "return x + y"
        BinaryOperation using operator +
           Type: uint256
           Source: "x + y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
  FunctionDefinition "safeSub" - const
     Source: "function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (x < y) {\r\n            revert();\r\n        }\r\n        return x - y;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 z)"
      VariableDeclaration "z"
         Type: uint256
         Source: "uint256 z"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        if (x < y) {\r\n            revert();\r\n        }\r\n        return x - y;\r\n    }"
      IfStatement
         Source: "if (x < y) {\r\n            revert();\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "x < y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
        Block
           Source: "{\r\n            revert();\r\n        }"
          ExpressionStatement
             Gas costs: 6
             Source: "revert()"
            FunctionCall
               Type: tuple()
               Source: "revert()"
              Identifier revert
                 Type: function () pure
                 Source: "revert"
      Return
         Gas costs: 14
         Source: "return x - y"
        BinaryOperation using operator -
           Type: uint256
           Source: "x - y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
  FunctionDefinition "safeMul" - const
     Source: "function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (y == 0) {\r\n            return 0;\r\n        }\r\n        if (x > MAX_UINT256 / y) {\r\n            revert();\r\n        }\r\n        return x * y;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 z)"
      VariableDeclaration "z"
         Type: uint256
         Source: "uint256 z"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        if (y == 0) {\r\n            return 0;\r\n        }\r\n        if (x > MAX_UINT256 / y) {\r\n            revert();\r\n        }\r\n        return x * y;\r\n    }"
      IfStatement
         Source: "if (y == 0) {\r\n            return 0;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "y == 0"
          Identifier y
             Type: uint256
             Source: "y"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            return 0;\r\n        }"
          Return
             Gas costs: 19
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      IfStatement
         Source: "if (x > MAX_UINT256 / y) {\r\n            revert();\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 37
           Source: "x > MAX_UINT256 / y"
          Identifier x
             Type: uint256
             Source: "x"
          BinaryOperation using operator /
             Type: uint256
             Source: "MAX_UINT256 / y"
            Identifier MAX_UINT256
               Type: uint256
               Source: "MAX_UINT256"
            Identifier y
               Type: uint256
               Source: "y"
        Block
           Source: "{\r\n            revert();\r\n        }"
          ExpressionStatement
             Gas costs: 6
             Source: "revert()"
            FunctionCall
               Type: tuple()
               Source: "revert()"
              Identifier revert
                 Type: function () pure
                 Source: "revert"
      Return
         Gas costs: 16
         Source: "return x * y"
        BinaryOperation using operator *
           Type: uint256
           Source: "x * y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
ContractDefinition "ContractReceiver"
   Source: "contract ContractReceiver {\r\n\r\n    struct TKN {\r\n        address sender;\r\n        uint value;\r\n        bytes data;\r\n        bytes4 sig;\r\n    }\r\n\r\n    function tokenFallback(address _from, uint _value, bytes _data) public {\r\n      TKN memory tkn;\r\n      tkn.sender = _from;\r\n      tkn.value = _value;\r\n      tkn.data = _data;\r\n      uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\r\n      tkn.sig = bytes4(u);\r\n\r\n      /* tkn variable is analogue of msg variable of Ether transaction\r\n      *  tkn.sender is person who initiated this token transaction   (analogue of msg.sender)\r\n      *  tkn.value the number of tokens that were sent   (analogue of msg.value)\r\n      *  tkn.data is data of token transaction   (analogue of msg.data)\r\n      *  tkn.sig is 4 bytes signature of function\r\n      *  if data of token transaction is a function execution\r\n      */\r\n    }\r\n}"
  StructDefinition "TKN"
     Gas costs: 0
     Source: "struct TKN {\r\n        address sender;\r\n        uint value;\r\n        bytes data;\r\n        bytes4 sig;\r\n    }"
    VariableDeclaration "sender"
       Type: address
       Source: "address sender"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "value"
       Type: uint256
       Source: "uint value"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "data"
       Type: bytes storage pointer
       Source: "bytes data"
      ElementaryTypeName bytes
         Source: "bytes"
    VariableDeclaration "sig"
       Type: bytes4
       Source: "bytes4 sig"
      ElementaryTypeName bytes4
         Source: "bytes4"
  FunctionDefinition "tokenFallback" - public
     Source: "function tokenFallback(address _from, uint _value, bytes _data) public {\r\n      TKN memory tkn;\r\n      tkn.sender = _from;\r\n      tkn.value = _value;\r\n      tkn.data = _data;\r\n      uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\r\n      tkn.sig = bytes4(u);\r\n\r\n      /* tkn variable is analogue of msg variable of Ether transaction\r\n      *  tkn.sender is person who initiated this token transaction   (analogue of msg.sender)\r\n      *  tkn.value the number of tokens that were sent   (analogue of msg.value)\r\n      *  tkn.data is data of token transaction   (analogue of msg.data)\r\n      *  tkn.sig is 4 bytes signature of function\r\n      *  if data of token transaction is a function execution\r\n      */\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, uint _value, bytes _data)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n      TKN memory tkn;\r\n      tkn.sender = _from;\r\n      tkn.value = _value;\r\n      tkn.data = _data;\r\n      uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\r\n      tkn.sig = bytes4(u);\r\n\r\n      /* tkn variable is analogue of msg variable of Ether transaction\r\n      *  tkn.sender is person who initiated this token transaction   (analogue of msg.sender)\r\n      *  tkn.value the number of tokens that were sent   (analogue of msg.value)\r\n      *  tkn.data is data of token transaction   (analogue of msg.data)\r\n      *  tkn.sig is 4 bytes signature of function\r\n      *  if data of token transaction is a function execution\r\n      */\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "TKN memory tkn"
        VariableDeclaration "tkn"
           Type: struct ContractReceiver.TKN memory
           Source: "TKN memory tkn"
          UserDefinedTypeName "TKN"
             Source: "TKN"
      ExpressionStatement
         Gas costs: 0
         Source: "tkn.sender = _from"
        Assignment using operator =
           Type: address
           Source: "tkn.sender = _from"
          MemberAccess to member sender
             Type: address
             Source: "tkn.sender"
            Identifier tkn
               Type: struct ContractReceiver.TKN memory
               Source: "tkn"
          Identifier _from
             Type: address
             Source: "_from"
      ExpressionStatement
         Gas costs: 0
         Source: "tkn.value = _value"
        Assignment using operator =
           Type: uint256
           Source: "tkn.value = _value"
          MemberAccess to member value
             Type: uint256
             Source: "tkn.value"
            Identifier tkn
               Type: struct ContractReceiver.TKN memory
               Source: "tkn"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "tkn.data = _data"
        Assignment using operator =
           Type: bytes memory
           Source: "tkn.data = _data"
          MemberAccess to member data
             Type: bytes memory
             Source: "tkn.data"
            Identifier tkn
               Type: struct ContractReceiver.TKN memory
               Source: "tkn"
          Identifier _data
             Type: bytes memory
             Source: "_data"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24)"
        VariableDeclaration "u"
           Type: uint32
           Source: "uint32 u"
          ElementaryTypeName uint32
             Source: "uint32"
        BinaryOperation using operator +
           Type: uint32
           Source: "uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24)"
          BinaryOperation using operator +
             Type: uint32
             Source: "uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16)"
            BinaryOperation using operator +
               Type: uint32
               Source: "uint32(_data[3]) + (uint32(_data[2]) << 8)"
              FunctionCall
                 Type: uint32
                 Source: "uint32(_data[3])"
                ElementaryTypeNameExpression uint32
                   Type: type(uint32)
                   Source: "uint32"
                IndexAccess
                   Type: bytes1
                   Source: "_data[3]"
                  Identifier _data
                     Type: bytes memory
                     Source: "_data"
                  Literal, token: [no token] value: 3
                     Type: int_const 3
                     Source: "3"
              TupleExpression
                 Type: uint32
                 Source: "(uint32(_data[2]) << 8)"
                BinaryOperation using operator <<
                   Type: uint32
                   Source: "uint32(_data[2]) << 8"
                  FunctionCall
                     Type: uint32
                     Source: "uint32(_data[2])"
                    ElementaryTypeNameExpression uint32
                       Type: type(uint32)
                       Source: "uint32"
                    IndexAccess
                       Type: bytes1
                       Source: "_data[2]"
                      Identifier _data
                         Type: bytes memory
                         Source: "_data"
                      Literal, token: [no token] value: 2
                         Type: int_const 2
                         Source: "2"
                  Literal, token: [no token] value: 8
                     Type: int_const 8
                     Source: "8"
            TupleExpression
               Type: uint32
               Source: "(uint32(_data[1]) << 16)"
              BinaryOperation using operator <<
                 Type: uint32
                 Source: "uint32(_data[1]) << 16"
                FunctionCall
                   Type: uint32
                   Source: "uint32(_data[1])"
                  ElementaryTypeNameExpression uint32
                     Type: type(uint32)
                     Source: "uint32"
                  IndexAccess
                     Type: bytes1
                     Source: "_data[1]"
                    Identifier _data
                       Type: bytes memory
                       Source: "_data"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
                Literal, token: [no token] value: 16
                   Type: int_const 16
                   Source: "16"
          TupleExpression
             Type: uint32
             Source: "(uint32(_data[0]) << 24)"
            BinaryOperation using operator <<
               Type: uint32
               Source: "uint32(_data[0]) << 24"
              FunctionCall
                 Type: uint32
                 Source: "uint32(_data[0])"
                ElementaryTypeNameExpression uint32
                   Type: type(uint32)
                   Source: "uint32"
                IndexAccess
                   Type: bytes1
                   Source: "_data[0]"
                  Identifier _data
                     Type: bytes memory
                     Source: "_data"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              Literal, token: [no token] value: 24
                 Type: int_const 24
                 Source: "24"
      ExpressionStatement
         Gas costs: 0
         Source: "tkn.sig = bytes4(u)"
        Assignment using operator =
           Type: bytes4
           Source: "tkn.sig = bytes4(u)"
          MemberAccess to member sig
             Type: bytes4
             Source: "tkn.sig"
            Identifier tkn
               Type: struct ContractReceiver.TKN memory
               Source: "tkn"
          FunctionCall
             Type: bytes4
             Source: "bytes4(u)"
            ElementaryTypeNameExpression bytes4
               Type: type(bytes4)
               Source: "bytes4"
            Identifier u
               Type: uint32
               Source: "u"
ContractDefinition "EDOGE"
   Source: "contract EDOGE is ERC20, SafeMath {\r\n\r\n    string public name = \"eDogecoin\";\r\n\r\n    string public symbol = \"EDOGE\";\r\n\r\n    uint8 public decimals = 8;\r\n\r\n    uint256 public totalSupply = 100000000000 * 10**8;\r\n\r\n    address public owner;\r\n\r\n    bool public unlocked = false;\r\n\r\n    bool public tokenCreated = false;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n\r\n    // Initialize to have owner have 100,000,000,000 EDOGE on contract creation\r\n    // Constructor is called only once and can not be called again (Ethereum Solidity specification)\r\n    function EDOGE() public {\r\n\r\n        // Security check in case EVM has future flaw or exploit to call constructor multiple times\r\n        // Ensure token gets created once only\r\n        require(tokenCreated == false);\r\n        tokenCreated = true;\r\n\r\n        owner = msg.sender;\r\n        balances[owner] = totalSupply;\r\n\r\n        // Final sanity check to ensure owner balance is greater than zero\r\n        require(balances[owner] > 0);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    // Function to distribute tokens to list of addresses by the provided amount\r\n    // Verify and require that:\r\n    // - Balance of owner cannot be negative\r\n    // - All transfers can be fulfilled with remaining owner balance\r\n    // - No new tokens can ever be minted except originally created 100,000,000,000\r\n    function distributeAirdrop(address[] addresses, uint256 amount) onlyOwner public {\r\n        // Only allow undrop while token is locked\r\n        // After token is unlocked, this method becomes permanently disabled\r\n        require(!unlocked);\r\n\r\n        // Amount is in Wei, convert to EDOGE amount in 8 decimal places\r\n        uint256 normalizedAmount = amount * 10**8;\r\n        // Only proceed if there are enough tokens to be distributed to all addresses\r\n        // Never allow balance of owner to become negative\r\n        require(balances[owner] >= safeMul(addresses.length, normalizedAmount));\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            balances[owner] = safeSub(balanceOf(owner), normalizedAmount);\r\n            balances[addresses[i]] = safeAdd(balanceOf(addresses[i]), normalizedAmount);\r\n            Transfer(owner, addresses[i], normalizedAmount);\r\n        }\r\n    }\r\n\r\n    // Function to access name of token .sha\r\n    function name() constant public returns (string _name) {\r\n        return name;\r\n    }\r\n    // Function to access symbol of token .\r\n    function symbol() constant public returns (string _symbol) {\r\n        return symbol;\r\n    }\r\n    // Function to access decimals of token .\r\n    function decimals() constant public returns (uint8 _decimals) {\r\n        return decimals;\r\n    }\r\n    // Function to access total supply of tokens .\r\n    function totalSupply() constant public returns (uint256 _totalSupply) {\r\n        return totalSupply;\r\n    }\r\n\r\n    // Function that is called when a user or another contract wants to transfer funds .\r\n    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {\r\n\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n\r\n        if (isContract(_to)) {\r\n            if (balanceOf(msg.sender) < _value) {\r\n                revert();\r\n            }\r\n            balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n            balances[_to] = safeAdd(balanceOf(_to), _value);\r\n            ContractReceiver receiver = ContractReceiver(_to);\r\n            receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);\r\n            Transfer(msg.sender, _to, _value, _data);\r\n            return true;\r\n        } else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }\r\n\r\n    // Function that is called when a user or another contract wants to transfer funds .\r\n    function transfer(address _to, uint _value, bytes _data) public  returns (bool success) {\r\n\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n\r\n        if (isContract(_to)) {\r\n            return transferToContract(_to, _value, _data);\r\n        } else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }\r\n\r\n    // Standard function transfer similar to ERC20 transfer with no _data .\r\n    // Added due to backwards compatibility reasons .\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n\r\n        //standard function transfer similar to ERC20 transfer with no _data\r\n        //added due to backwards compatibility reasons\r\n        bytes memory empty;\r\n        if (isContract(_to)) {\r\n            return transferToContract(_to, _value, empty);\r\n        } else {\r\n            return transferToAddress(_to, _value, empty);\r\n        }\r\n    }\r\n\r\n    // assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n    function isContract(address _addr) private returns (bool is_contract) {\r\n        uint length;\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return (length > 0);\r\n    }\r\n\r\n    // function that is called when transaction target is an address\r\n    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\r\n        if (balanceOf(msg.sender) < _value) {\r\n            revert();\r\n        }\r\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }\r\n\r\n    // function that is called when transaction target is a contract\r\n    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\r\n        if (balanceOf(msg.sender) < _value) {\r\n            revert();\r\n        }\r\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        ContractReceiver receiver = ContractReceiver(_to);\r\n        receiver.tokenFallback(msg.sender, _value, _data);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }\r\n\r\n    // Get balance of the address provided\r\n    function balanceOf(address _owner) constant public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n     // Creator/Owner can unlocked it once and it can never be locked again\r\n     // Use after airdrop is complete\r\n    function unlockForever() onlyOwner public {\r\n        unlocked = true;\r\n    }\r\n\r\n    // Allow transfers if the owner provided an allowance\r\n    // Prevent from any transfers if token is not yet unlocked\r\n    // Use SafeMath for the main logic\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n        // Protect against wrapping uints.\r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        balances[_from] = safeSub(balanceOf(_from), _value);\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: 0
     Source: "string public name = \"eDogecoin\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: eDogecoin
       Type: literal_string "eDogecoin"
       Source: "\"eDogecoin\""
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: 0
     Source: "string public symbol = \"EDOGE\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: EDOGE
       Type: literal_string "EDOGE"
       Source: "\"EDOGE\""
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: 0
     Source: "uint8 public decimals = 8"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 8
       Type: int_const 8
       Source: "8"
  VariableDeclaration "totalSupply"
     Type: uint256
     Gas costs: 0
     Source: "uint256 public totalSupply = 100000000000 * 10**8"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator *
       Type: int_const 10000000000000000000
       Source: "100000000000 * 10**8"
      Literal, token: [no token] value: 100000000000
         Type: int_const 100000000000
         Source: "100000000000"
      BinaryOperation using operator **
         Type: int_const 100000000
         Source: "10**8"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Literal, token: [no token] value: 8
           Type: int_const 8
           Source: "8"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "unlocked"
     Type: bool
     Gas costs: [???]
     Source: "bool public unlocked = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "tokenCreated"
     Type: bool
     Gas costs: [???]
     Source: "bool public tokenCreated = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) balances"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping(address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping(address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "EDOGE" - public
     Source: "function EDOGE() public {\r\n\r\n        // Security check in case EVM has future flaw or exploit to call constructor multiple times\r\n        // Ensure token gets created once only\r\n        require(tokenCreated == false);\r\n        tokenCreated = true;\r\n\r\n        owner = msg.sender;\r\n        balances[owner] = totalSupply;\r\n\r\n        // Final sanity check to ensure owner balance is greater than zero\r\n        require(balances[owner] > 0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\r\n        // Security check in case EVM has future flaw or exploit to call constructor multiple times\r\n        // Ensure token gets created once only\r\n        require(tokenCreated == false);\r\n        tokenCreated = true;\r\n\r\n        owner = msg.sender;\r\n        balances[owner] = totalSupply;\r\n\r\n        // Final sanity check to ensure owner balance is greater than zero\r\n        require(balances[owner] > 0);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(tokenCreated == false)"
        FunctionCall
           Type: tuple()
           Source: "require(tokenCreated == false)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "tokenCreated == false"
            Identifier tokenCreated
               Type: bool
               Source: "tokenCreated"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenCreated = true"
        Assignment using operator =
           Type: bool
           Source: "tokenCreated = true"
          Identifier tokenCreated
             Type: bool
             Source: "tokenCreated"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[owner] = totalSupply"
        Assignment using operator =
           Type: uint256
           Source: "balances[owner] = totalSupply"
          IndexAccess
             Type: uint256
             Source: "balances[owner]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier owner
               Type: address
               Source: "owner"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balances[owner] > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[owner] > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balances[owner] > 0"
            IndexAccess
               Type: uint256
               Source: "balances[owner]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier owner
                 Type: address
                 Source: "owner"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 564
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "distributeAirdrop" - public
     Source: "function distributeAirdrop(address[] addresses, uint256 amount) onlyOwner public {\r\n        // Only allow undrop while token is locked\r\n        // After token is unlocked, this method becomes permanently disabled\r\n        require(!unlocked);\r\n\r\n        // Amount is in Wei, convert to EDOGE amount in 8 decimal places\r\n        uint256 normalizedAmount = amount * 10**8;\r\n        // Only proceed if there are enough tokens to be distributed to all addresses\r\n        // Never allow balance of owner to become negative\r\n        require(balances[owner] >= safeMul(addresses.length, normalizedAmount));\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            balances[owner] = safeSub(balanceOf(owner), normalizedAmount);\r\n            balances[addresses[i]] = safeAdd(balanceOf(addresses[i]), normalizedAmount);\r\n            Transfer(owner, addresses[i], normalizedAmount);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] addresses, uint256 amount)"
      VariableDeclaration "addresses"
         Type: address[] memory
         Source: "address[] addresses"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        // Only allow undrop while token is locked\r\n        // After token is unlocked, this method becomes permanently disabled\r\n        require(!unlocked);\r\n\r\n        // Amount is in Wei, convert to EDOGE amount in 8 decimal places\r\n        uint256 normalizedAmount = amount * 10**8;\r\n        // Only proceed if there are enough tokens to be distributed to all addresses\r\n        // Never allow balance of owner to become negative\r\n        require(balances[owner] >= safeMul(addresses.length, normalizedAmount));\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            balances[owner] = safeSub(balanceOf(owner), normalizedAmount);\r\n            balances[addresses[i]] = safeAdd(balanceOf(addresses[i]), normalizedAmount);\r\n            Transfer(owner, addresses[i], normalizedAmount);\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 318
         Source: "require(!unlocked)"
        FunctionCall
           Type: tuple()
           Source: "require(!unlocked)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!unlocked"
            Identifier unlocked
               Type: bool
               Source: "unlocked"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint256 normalizedAmount = amount * 10**8"
        VariableDeclaration "normalizedAmount"
           Type: uint256
           Source: "uint256 normalizedAmount"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "amount * 10**8"
          Identifier amount
             Type: uint256
             Source: "amount"
          BinaryOperation using operator **
             Type: int_const 100000000
             Source: "10**8"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
            Literal, token: [no token] value: 8
               Type: int_const 8
               Source: "8"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(balances[owner] >= safeMul(addresses.length, normalizedAmount))"
        FunctionCall
           Type: tuple()
           Source: "require(balances[owner] >= safeMul(addresses.length, normalizedAmount))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[owner] >= safeMul(addresses.length, normalizedAmount)"
            IndexAccess
               Type: uint256
               Source: "balances[owner]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier owner
                 Type: address
                 Source: "owner"
            FunctionCall
               Type: uint256
               Source: "safeMul(addresses.length, normalizedAmount)"
              Identifier safeMul
                 Type: function (uint256,uint256) view returns (uint256)
                 Source: "safeMul"
              MemberAccess to member length
                 Type: uint256
                 Source: "addresses.length"
                Identifier addresses
                   Type: address[] memory
                   Source: "addresses"
              Identifier normalizedAmount
                 Type: uint256
                 Source: "normalizedAmount"
      ForStatement
         Source: "for (uint i = 0; i < addresses.length; i++) {\r\n            balances[owner] = safeSub(balanceOf(owner), normalizedAmount);\r\n            balances[addresses[i]] = safeAdd(balanceOf(addresses[i]), normalizedAmount);\r\n            Transfer(owner, addresses[i], normalizedAmount);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "i < addresses.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "addresses.length"
            Identifier addresses
               Type: address[] memory
               Source: "addresses"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            balances[owner] = safeSub(balanceOf(owner), normalizedAmount);\r\n            balances[addresses[i]] = safeAdd(balanceOf(addresses[i]), normalizedAmount);\r\n            Transfer(owner, addresses[i], normalizedAmount);\r\n        }"
          ExpressionStatement
             Gas costs: 20615
             Source: "balances[owner] = safeSub(balanceOf(owner), normalizedAmount)"
            Assignment using operator =
               Type: uint256
               Source: "balances[owner] = safeSub(balanceOf(owner), normalizedAmount)"
              IndexAccess
                 Type: uint256
                 Source: "balances[owner]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier owner
                   Type: address
                   Source: "owner"
              FunctionCall
                 Type: uint256
                 Source: "safeSub(balanceOf(owner), normalizedAmount)"
                Identifier safeSub
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "safeSub"
                FunctionCall
                   Type: uint256
                   Source: "balanceOf(owner)"
                  Identifier balanceOf
                     Type: function (address) view returns (uint256)
                     Source: "balanceOf"
                  Identifier owner
                     Type: address
                     Source: "owner"
                Identifier normalizedAmount
                   Type: uint256
                   Source: "normalizedAmount"
          ExpressionStatement
             Gas costs: [???]
             Source: "balances[addresses[i]] = safeAdd(balanceOf(addresses[i]), normalizedAmount)"
            Assignment using operator =
               Type: uint256
               Source: "balances[addresses[i]] = safeAdd(balanceOf(addresses[i]), normalizedAmount)"
              IndexAccess
                 Type: uint256
                 Source: "balances[addresses[i]]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                IndexAccess
                   Type: address
                   Source: "addresses[i]"
                  Identifier addresses
                     Type: address[] memory
                     Source: "addresses"
                  Identifier i
                     Type: uint256
                     Source: "i"
              FunctionCall
                 Type: uint256
                 Source: "safeAdd(balanceOf(addresses[i]), normalizedAmount)"
                Identifier safeAdd
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "safeAdd"
                FunctionCall
                   Type: uint256
                   Source: "balanceOf(addresses[i])"
                  Identifier balanceOf
                     Type: function (address) view returns (uint256)
                     Source: "balanceOf"
                  IndexAccess
                     Type: address
                     Source: "addresses[i]"
                    Identifier addresses
                       Type: address[] memory
                       Source: "addresses"
                    Identifier i
                       Type: uint256
                       Source: "i"
                Identifier normalizedAmount
                   Type: uint256
                   Source: "normalizedAmount"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(owner, addresses[i], normalizedAmount)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(owner, addresses[i], normalizedAmount)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              Identifier owner
                 Type: address
                 Source: "owner"
              IndexAccess
                 Type: address
                 Source: "addresses[i]"
                Identifier addresses
                   Type: address[] memory
                   Source: "addresses"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier normalizedAmount
                 Type: uint256
                 Source: "normalizedAmount"
  FunctionDefinition "name" - public - const
     Source: "function name() constant public returns (string _name) {\r\n        return name;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(string _name)"
      VariableDeclaration "_name"
         Type: string memory
         Source: "string _name"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n        return name;\r\n    }"
      Return
         Gas costs: [???]
         Source: "return name"
        Identifier name
           Type: string storage ref
           Source: "name"
  FunctionDefinition "symbol" - public - const
     Source: "function symbol() constant public returns (string _symbol) {\r\n        return symbol;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(string _symbol)"
      VariableDeclaration "_symbol"
         Type: string memory
         Source: "string _symbol"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n        return symbol;\r\n    }"
      Return
         Gas costs: [???]
         Source: "return symbol"
        Identifier symbol
           Type: string storage ref
           Source: "symbol"
  FunctionDefinition "decimals" - public - const
     Source: "function decimals() constant public returns (uint8 _decimals) {\r\n        return decimals;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint8 _decimals)"
      VariableDeclaration "_decimals"
         Type: uint8
         Source: "uint8 _decimals"
        ElementaryTypeName uint8
           Source: "uint8"
    Block
       Source: "{\r\n        return decimals;\r\n    }"
      Return
         Gas costs: 244
         Source: "return decimals"
        Identifier decimals
           Type: uint8
           Source: "decimals"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() constant public returns (uint256 _totalSupply) {\r\n        return totalSupply;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256 _totalSupply)"
      VariableDeclaration "_totalSupply"
         Type: uint256
         Source: "uint256 _totalSupply"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return totalSupply;\r\n    }"
      Return
         Gas costs: 208
         Source: "return totalSupply"
        Identifier totalSupply
           Type: uint256
           Source: "totalSupply"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {\r\n\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n\r\n        if (isContract(_to)) {\r\n            if (balanceOf(msg.sender) < _value) {\r\n                revert();\r\n            }\r\n            balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n            balances[_to] = safeAdd(balanceOf(_to), _value);\r\n            ContractReceiver receiver = ContractReceiver(_to);\r\n            receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);\r\n            Transfer(msg.sender, _to, _value, _data);\r\n            return true;\r\n        } else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value, bytes _data, string _custom_fallback)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
      VariableDeclaration "_custom_fallback"
         Type: string memory
         Source: "string _custom_fallback"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n\r\n        if (isContract(_to)) {\r\n            if (balanceOf(msg.sender) < _value) {\r\n                revert();\r\n            }\r\n            balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n            balances[_to] = safeAdd(balanceOf(_to), _value);\r\n            ContractReceiver receiver = ContractReceiver(_to);\r\n            receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);\r\n            Transfer(msg.sender, _to, _value, _data);\r\n            return true;\r\n        } else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 315
         Source: "require(unlocked)"
        FunctionCall
           Type: tuple()
           Source: "require(unlocked)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier unlocked
             Type: bool
             Source: "unlocked"
      IfStatement
         Source: "if (isContract(_to)) {\r\n            if (balanceOf(msg.sender) < _value) {\r\n                revert();\r\n            }\r\n            balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n            balances[_to] = safeAdd(balanceOf(_to), _value);\r\n            ContractReceiver receiver = ContractReceiver(_to);\r\n            receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);\r\n            Transfer(msg.sender, _to, _value, _data);\r\n            return true;\r\n        } else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 18
           Source: "isContract(_to)"
          Identifier isContract
             Type: function (address) returns (bool)
             Source: "isContract"
          Identifier _to
             Type: address
             Source: "_to"
        Block
           Source: "{\r\n            if (balanceOf(msg.sender) < _value) {\r\n                revert();\r\n            }\r\n            balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n            balances[_to] = safeAdd(balanceOf(_to), _value);\r\n            ContractReceiver receiver = ContractReceiver(_to);\r\n            receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);\r\n            Transfer(msg.sender, _to, _value, _data);\r\n            return true;\r\n        }"
          IfStatement
             Source: "if (balanceOf(msg.sender) < _value) {\r\n                revert();\r\n            }"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 23
               Source: "balanceOf(msg.sender) < _value"
              FunctionCall
                 Type: uint256
                 Source: "balanceOf(msg.sender)"
                Identifier balanceOf
                   Type: function (address) view returns (uint256)
                   Source: "balanceOf"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            Block
               Source: "{\r\n                revert();\r\n            }"
              ExpressionStatement
                 Gas costs: 6
                 Source: "revert()"
                FunctionCall
                   Type: tuple()
                   Source: "revert()"
                  Identifier revert
                     Type: function () pure
                     Source: "revert"
          ExpressionStatement
             Gas costs: 20141
             Source: "balances[msg.sender] = safeSub(balanceOf(msg.sender), _value)"
            Assignment using operator =
               Type: uint256
               Source: "balances[msg.sender] = safeSub(balanceOf(msg.sender), _value)"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              FunctionCall
                 Type: uint256
                 Source: "safeSub(balanceOf(msg.sender), _value)"
                Identifier safeSub
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "safeSub"
                FunctionCall
                   Type: uint256
                   Source: "balanceOf(msg.sender)"
                  Identifier balanceOf
                     Type: function (address) view returns (uint256)
                     Source: "balanceOf"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _value
                   Type: uint256
                   Source: "_value"
          ExpressionStatement
             Gas costs: 20143
             Source: "balances[_to] = safeAdd(balanceOf(_to), _value)"
            Assignment using operator =
               Type: uint256
               Source: "balances[_to] = safeAdd(balanceOf(_to), _value)"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              FunctionCall
                 Type: uint256
                 Source: "safeAdd(balanceOf(_to), _value)"
                Identifier safeAdd
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "safeAdd"
                FunctionCall
                   Type: uint256
                   Source: "balanceOf(_to)"
                  Identifier balanceOf
                     Type: function (address) view returns (uint256)
                     Source: "balanceOf"
                  Identifier _to
                     Type: address
                     Source: "_to"
                Identifier _value
                   Type: uint256
                   Source: "_value"
          VariableDeclarationStatement
             Gas costs: 11
             Source: "ContractReceiver receiver = ContractReceiver(_to)"
            VariableDeclaration "receiver"
               Type: contract ContractReceiver
               Source: "ContractReceiver receiver"
              UserDefinedTypeName "ContractReceiver"
                 Source: "ContractReceiver"
            FunctionCall
               Type: contract ContractReceiver
               Source: "ContractReceiver(_to)"
              Identifier ContractReceiver
                 Type: type(contract ContractReceiver)
                 Source: "ContractReceiver"
              Identifier _to
                 Type: address
                 Source: "_to"
          ExpressionStatement
             Gas costs: [???]
             Source: "receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data)"
            FunctionCall
               Type: bool
               Source: "receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data)"
              FunctionCall
                 Type: function () payable returns (bool)
                 Source: "receiver.call.value(0)"
                MemberAccess to member value
                   Type: function (uint256) returns (function () payable returns (bool))
                   Source: "receiver.call.value"
                  MemberAccess to member call
                     Type: function () payable returns (bool)
                     Source: "receiver.call"
                    Identifier receiver
                       Type: contract ContractReceiver
                       Source: "receiver"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              FunctionCall
                 Type: bytes4
                 Source: "bytes4(sha3(_custom_fallback))"
                ElementaryTypeNameExpression bytes4
                   Type: type(bytes4)
                   Source: "bytes4"
                FunctionCall
                   Type: bytes32
                   Source: "sha3(_custom_fallback)"
                  Identifier sha3
                     Type: function () pure returns (bytes32)
                     Source: "sha3"
                  Identifier _custom_fallback
                     Type: string memory
                     Source: "_custom_fallback"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier _data
                 Type: bytes memory
                 Source: "_data"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(msg.sender, _to, _value, _data)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(msg.sender, _to, _value, _data)"
              Identifier Transfer
                 Type: function (address,address,uint256,bytes memory)
                 Source: "Transfer"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier _data
                 Type: bytes memory
                 Source: "_data"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{\r\n            return transferToAddress(_to, _value, _data);\r\n        }"
          Return
             Gas costs: 29
             Source: "return transferToAddress(_to, _value, _data)"
            FunctionCall
               Type: bool
               Source: "transferToAddress(_to, _value, _data)"
              Identifier transferToAddress
                 Type: function (address,uint256,bytes memory) returns (bool)
                 Source: "transferToAddress"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier _data
                 Type: bytes memory
                 Source: "_data"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value, bytes _data) public  returns (bool success) {\r\n\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n\r\n        if (isContract(_to)) {\r\n            return transferToContract(_to, _value, _data);\r\n        } else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value, bytes _data)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n\r\n        if (isContract(_to)) {\r\n            return transferToContract(_to, _value, _data);\r\n        } else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 315
         Source: "require(unlocked)"
        FunctionCall
           Type: tuple()
           Source: "require(unlocked)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier unlocked
             Type: bool
             Source: "unlocked"
      IfStatement
         Source: "if (isContract(_to)) {\r\n            return transferToContract(_to, _value, _data);\r\n        } else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 18
           Source: "isContract(_to)"
          Identifier isContract
             Type: function (address) returns (bool)
             Source: "isContract"
          Identifier _to
             Type: address
             Source: "_to"
        Block
           Source: "{\r\n            return transferToContract(_to, _value, _data);\r\n        }"
          Return
             Gas costs: 40
             Source: "return transferToContract(_to, _value, _data)"
            FunctionCall
               Type: bool
               Source: "transferToContract(_to, _value, _data)"
              Identifier transferToContract
                 Type: function (address,uint256,bytes memory) returns (bool)
                 Source: "transferToContract"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier _data
                 Type: bytes memory
                 Source: "_data"
        Block
           Source: "{\r\n            return transferToAddress(_to, _value, _data);\r\n        }"
          Return
             Gas costs: 29
             Source: "return transferToAddress(_to, _value, _data)"
            FunctionCall
               Type: bool
               Source: "transferToAddress(_to, _value, _data)"
              Identifier transferToAddress
                 Type: function (address,uint256,bytes memory) returns (bool)
                 Source: "transferToAddress"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier _data
                 Type: bytes memory
                 Source: "_data"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value) public returns (bool success) {\r\n\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n\r\n        //standard function transfer similar to ERC20 transfer with no _data\r\n        //added due to backwards compatibility reasons\r\n        bytes memory empty;\r\n        if (isContract(_to)) {\r\n            return transferToContract(_to, _value, empty);\r\n        } else {\r\n            return transferToAddress(_to, _value, empty);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n\r\n        //standard function transfer similar to ERC20 transfer with no _data\r\n        //added due to backwards compatibility reasons\r\n        bytes memory empty;\r\n        if (isContract(_to)) {\r\n            return transferToContract(_to, _value, empty);\r\n        } else {\r\n            return transferToAddress(_to, _value, empty);\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 315
         Source: "require(unlocked)"
        FunctionCall
           Type: tuple()
           Source: "require(unlocked)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier unlocked
             Type: bool
             Source: "unlocked"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "bytes memory empty"
        VariableDeclaration "empty"
           Type: bytes memory
           Source: "bytes memory empty"
          ElementaryTypeName bytes
             Source: "bytes"
      IfStatement
         Source: "if (isContract(_to)) {\r\n            return transferToContract(_to, _value, empty);\r\n        } else {\r\n            return transferToAddress(_to, _value, empty);\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 7
           Source: "isContract(_to)"
          Identifier isContract
             Type: function (address) returns (bool)
             Source: "isContract"
          Identifier _to
             Type: address
             Source: "_to"
        Block
           Source: "{\r\n            return transferToContract(_to, _value, empty);\r\n        }"
          Return
             Gas costs: 29
             Source: "return transferToContract(_to, _value, empty)"
            FunctionCall
               Type: bool
               Source: "transferToContract(_to, _value, empty)"
              Identifier transferToContract
                 Type: function (address,uint256,bytes memory) returns (bool)
                 Source: "transferToContract"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier empty
                 Type: bytes memory
                 Source: "empty"
        Block
           Source: "{\r\n            return transferToAddress(_to, _value, empty);\r\n        }"
          Return
             Gas costs: 18
             Source: "return transferToAddress(_to, _value, empty)"
            FunctionCall
               Type: bool
               Source: "transferToAddress(_to, _value, empty)"
              Identifier transferToAddress
                 Type: function (address,uint256,bytes memory) returns (bool)
                 Source: "transferToAddress"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier empty
                 Type: bytes memory
                 Source: "empty"
  FunctionDefinition "isContract"
     Source: "function isContract(address _addr) private returns (bool is_contract) {\r\n        uint length;\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return (length > 0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _addr)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool is_contract)"
      VariableDeclaration "is_contract"
         Type: bool
         Source: "bool is_contract"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        uint length;\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return (length > 0);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint length"
        VariableDeclaration "length"
           Type: uint256
           Source: "uint length"
          ElementaryTypeName uint
             Source: "uint"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return"
      Return
         Gas costs: 14
         Source: "return (length > 0)"
        TupleExpression
           Type: bool
           Source: "(length > 0)"
          BinaryOperation using operator >
             Type: bool
             Source: "length > 0"
            Identifier length
               Type: uint256
               Source: "length"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "transferToAddress"
     Source: "function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\r\n        if (balanceOf(msg.sender) < _value) {\r\n            revert();\r\n        }\r\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value, bytes _data)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if (balanceOf(msg.sender) < _value) {\r\n            revert();\r\n        }\r\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (balanceOf(msg.sender) < _value) {\r\n            revert();\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 23
           Source: "balanceOf(msg.sender) < _value"
          FunctionCall
             Type: uint256
             Source: "balanceOf(msg.sender)"
            Identifier balanceOf
               Type: function (address) view returns (uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
        Block
           Source: "{\r\n            revert();\r\n        }"
          ExpressionStatement
             Gas costs: 6
             Source: "revert()"
            FunctionCall
               Type: tuple()
               Source: "revert()"
              Identifier revert
                 Type: function () pure
                 Source: "revert"
      ExpressionStatement
         Gas costs: 20141
         Source: "balances[msg.sender] = safeSub(balanceOf(msg.sender), _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = safeSub(balanceOf(msg.sender), _value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "safeSub(balanceOf(msg.sender), _value)"
            Identifier safeSub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "safeSub"
            FunctionCall
               Type: uint256
               Source: "balanceOf(msg.sender)"
              Identifier balanceOf
                 Type: function (address) view returns (uint256)
                 Source: "balanceOf"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20143
         Source: "balances[_to] = safeAdd(balanceOf(_to), _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = safeAdd(balanceOf(_to), _value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "safeAdd(balanceOf(_to), _value)"
            Identifier safeAdd
               Type: function (uint256,uint256) view returns (uint256)
               Source: "safeAdd"
            FunctionCall
               Type: uint256
               Source: "balanceOf(_to)"
              Identifier balanceOf
                 Type: function (address) view returns (uint256)
                 Source: "balanceOf"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value, _data)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value, _data)"
          Identifier Transfer
             Type: function (address,address,uint256,bytes memory)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier _data
             Type: bytes memory
             Source: "_data"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferToContract"
     Source: "function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\r\n        if (balanceOf(msg.sender) < _value) {\r\n            revert();\r\n        }\r\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        ContractReceiver receiver = ContractReceiver(_to);\r\n        receiver.tokenFallback(msg.sender, _value, _data);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value, bytes _data)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if (balanceOf(msg.sender) < _value) {\r\n            revert();\r\n        }\r\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        ContractReceiver receiver = ContractReceiver(_to);\r\n        receiver.tokenFallback(msg.sender, _value, _data);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (balanceOf(msg.sender) < _value) {\r\n            revert();\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 23
           Source: "balanceOf(msg.sender) < _value"
          FunctionCall
             Type: uint256
             Source: "balanceOf(msg.sender)"
            Identifier balanceOf
               Type: function (address) view returns (uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
        Block
           Source: "{\r\n            revert();\r\n        }"
          ExpressionStatement
             Gas costs: 6
             Source: "revert()"
            FunctionCall
               Type: tuple()
               Source: "revert()"
              Identifier revert
                 Type: function () pure
                 Source: "revert"
      ExpressionStatement
         Gas costs: 20141
         Source: "balances[msg.sender] = safeSub(balanceOf(msg.sender), _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = safeSub(balanceOf(msg.sender), _value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "safeSub(balanceOf(msg.sender), _value)"
            Identifier safeSub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "safeSub"
            FunctionCall
               Type: uint256
               Source: "balanceOf(msg.sender)"
              Identifier balanceOf
                 Type: function (address) view returns (uint256)
                 Source: "balanceOf"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20143
         Source: "balances[_to] = safeAdd(balanceOf(_to), _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = safeAdd(balanceOf(_to), _value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "safeAdd(balanceOf(_to), _value)"
            Identifier safeAdd
               Type: function (uint256,uint256) view returns (uint256)
               Source: "safeAdd"
            FunctionCall
               Type: uint256
               Source: "balanceOf(_to)"
              Identifier balanceOf
                 Type: function (address) view returns (uint256)
                 Source: "balanceOf"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "ContractReceiver receiver = ContractReceiver(_to)"
        VariableDeclaration "receiver"
           Type: contract ContractReceiver
           Source: "ContractReceiver receiver"
          UserDefinedTypeName "ContractReceiver"
             Source: "ContractReceiver"
        FunctionCall
           Type: contract ContractReceiver
           Source: "ContractReceiver(_to)"
          Identifier ContractReceiver
             Type: type(contract ContractReceiver)
             Source: "ContractReceiver"
          Identifier _to
             Type: address
             Source: "_to"
      ExpressionStatement
         Gas costs: [???]
         Source: "receiver.tokenFallback(msg.sender, _value, _data)"
        FunctionCall
           Type: tuple()
           Source: "receiver.tokenFallback(msg.sender, _value, _data)"
          MemberAccess to member tokenFallback
             Type: function (address,uint256,bytes memory) external
             Source: "receiver.tokenFallback"
            Identifier receiver
               Type: contract ContractReceiver
               Source: "receiver"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier _data
             Type: bytes memory
             Source: "_data"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value, _data)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value, _data)"
          Identifier Transfer
             Type: function (address,address,uint256,bytes memory)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier _data
             Type: bytes memory
             Source: "_data"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balances[_owner];\r\n    }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "unlockForever" - public
     Source: "function unlockForever() onlyOwner public {\r\n        unlocked = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        unlocked = true;\r\n    }"
      ExpressionStatement
         Gas costs: 20317
         Source: "unlocked = true"
        Assignment using operator =
           Type: bool
           Source: "unlocked = true"
          Identifier unlocked
             Type: bool
             Source: "unlocked"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n        // Protect against wrapping uints.\r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        balances[_from] = safeSub(balanceOf(_from), _value);\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n        // Protect against wrapping uints.\r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        balances[_from] = safeSub(balanceOf(_from), _value);\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 315
         Source: "require(unlocked)"
        FunctionCall
           Type: tuple()
           Source: "require(unlocked)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier unlocked
             Type: bool
             Source: "unlocked"
      ExpressionStatement
         Gas costs: 1376
         Source: "require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to])"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]"
            BinaryOperation using operator &&
               Type: bool
               Source: "balances[_from] >= _value && allowed[_from][msg.sender] >= _value"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "balances[_from] >= _value"
                IndexAccess
                   Type: uint256
                   Source: "balances[_from]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  Identifier _from
                     Type: address
                     Source: "_from"
                Identifier _value
                   Type: uint256
                   Source: "_value"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "allowed[_from][msg.sender] >= _value"
                IndexAccess
                   Type: uint256
                   Source: "allowed[_from][msg.sender]"
                  IndexAccess
                     Type: mapping(address => uint256)
                     Source: "allowed[_from]"
                    Identifier allowed
                       Type: mapping(address => mapping(address => uint256))
                       Source: "allowed"
                    Identifier _from
                       Type: address
                       Source: "_from"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _value
                   Type: uint256
                   Source: "_value"
            BinaryOperation using operator >
               Type: bool
               Source: "balances[_to] + _value > balances[_to]"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "balances[_to] + _value"
                IndexAccess
                   Type: uint256
                   Source: "balances[_to]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  Identifier _to
                     Type: address
                     Source: "_to"
                Identifier _value
                   Type: uint256
                   Source: "_value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
      VariableDeclarationStatement
         Gas costs: 396
         Source: "uint256 allowance = allowed[_from][msg.sender]"
        VariableDeclaration "allowance"
           Type: uint256
           Source: "uint256 allowance"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "allowed[_from][msg.sender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_from]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _from
               Type: address
               Source: "_from"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 362
         Source: "require(balances[_from] >= _value && allowance >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_from] >= _value && allowance >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "balances[_from] >= _value && allowance >= _value"
            BinaryOperation using operator >=
               Type: bool
               Source: "balances[_from] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            BinaryOperation using operator >=
               Type: bool
               Source: "allowance >= _value"
              Identifier allowance
                 Type: uint256
                 Source: "allowance"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      ExpressionStatement
         Gas costs: 20132
         Source: "balances[_to] = safeAdd(balanceOf(_to), _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = safeAdd(balanceOf(_to), _value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "safeAdd(balanceOf(_to), _value)"
            Identifier safeAdd
               Type: function (uint256,uint256) view returns (uint256)
               Source: "safeAdd"
            FunctionCall
               Type: uint256
               Source: "balanceOf(_to)"
              Identifier balanceOf
                 Type: function (address) view returns (uint256)
                 Source: "balanceOf"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20132
         Source: "balances[_from] = safeSub(balanceOf(_from), _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_from] = safeSub(balanceOf(_from), _value)"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "safeSub(balanceOf(_from), _value)"
            Identifier safeSub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "safeSub"
            FunctionCall
               Type: uint256
               Source: "balanceOf(_from)"
              Identifier balanceOf
                 Type: function (address) view returns (uint256)
                 Source: "balanceOf"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      IfStatement
         Source: "if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 6
           Source: "allowance < MAX_UINT256"
          Identifier allowance
             Type: uint256
             Source: "allowance"
          Identifier MAX_UINT256
             Type: uint256
             Source: "MAX_UINT256"
        Block
           Source: "{\r\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n        }"
          ExpressionStatement
             Gas costs: 20602
             Source: "allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value)"
            Assignment using operator =
               Type: uint256
               Source: "allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value)"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              FunctionCall
                 Type: uint256
                 Source: "safeSub(allowed[_from][msg.sender], _value)"
                Identifier safeSub
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "safeSub"
                IndexAccess
                   Type: uint256
                   Source: "allowed[_from][msg.sender]"
                  IndexAccess
                     Type: mapping(address => uint256)
                     Source: "allowed[_from]"
                    Identifier allowed
                       Type: mapping(address => mapping(address => uint256))
                       Source: "allowed"
                    Identifier _from
                       Type: address
                       Source: "_from"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _value
                   Type: uint256
                   Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        // Only allow transfer once unlocked\r\n        // Once it is unlocked, it is unlocked forever and no one can lock again\r\n        require(unlocked);\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 315
         Source: "require(unlocked)"
        FunctionCall
           Type: tuple()
           Source: "require(unlocked)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier unlocked
             Type: bool
             Source: "unlocked"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
