Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xf10fef19e61ef739a9d2d60c520723023f7bf7fb.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.15;"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "mul" - const
     Source: "function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 88
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div" - const
     Source: "function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub" - const
     Source: "function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add" - const
     Source: "function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "Math"
   Source: "library Math {\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}"
  FunctionDefinition "max64" - const
     Source: "function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint64 a, uint64 b)"
      VariableDeclaration "a"
         Type: uint64
         Source: "uint64 a"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "b"
         Type: uint64
         Source: "uint64 b"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 0
       Source: "(uint64)"
      VariableDeclaration ""
         Type: uint64
         Source: "uint64"
        ElementaryTypeName uint64
           Source: "uint64"
    Block
       Source: "{\r\n    return a >= b ? a : b;\r\n  }"
      Return
         Gas costs: 0
         Source: "return a >= b ? a : b"
        Conditional
           Type: uint64
           Source: "a >= b ? a : b"
          BinaryOperation using operator >=
             Type: bool
             Source: "a >= b"
            Identifier a
               Type: uint64
               Source: "a"
            Identifier b
               Type: uint64
               Source: "b"
          Identifier a
             Type: uint64
             Source: "a"
          Identifier b
             Type: uint64
             Source: "b"
  FunctionDefinition "min64" - const
     Source: "function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint64 a, uint64 b)"
      VariableDeclaration "a"
         Type: uint64
         Source: "uint64 a"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "b"
         Type: uint64
         Source: "uint64 b"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 0
       Source: "(uint64)"
      VariableDeclaration ""
         Type: uint64
         Source: "uint64"
        ElementaryTypeName uint64
           Source: "uint64"
    Block
       Source: "{\r\n    return a < b ? a : b;\r\n  }"
      Return
         Gas costs: 0
         Source: "return a < b ? a : b"
        Conditional
           Type: uint64
           Source: "a < b ? a : b"
          BinaryOperation using operator <
             Type: bool
             Source: "a < b"
            Identifier a
               Type: uint64
               Source: "a"
            Identifier b
               Type: uint64
               Source: "b"
          Identifier a
             Type: uint64
             Source: "a"
          Identifier b
             Type: uint64
             Source: "b"
  FunctionDefinition "max256" - const
     Source: "function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return a >= b ? a : b;\r\n  }"
      Return
         Gas costs: 0
         Source: "return a >= b ? a : b"
        Conditional
           Type: uint256
           Source: "a >= b ? a : b"
          BinaryOperation using operator >=
             Type: bool
             Source: "a >= b"
            Identifier a
               Type: uint256
               Source: "a"
            Identifier b
               Type: uint256
               Source: "b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "min256" - const
     Source: "function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return a < b ? a : b;\r\n  }"
      Return
         Gas costs: 46
         Source: "return a < b ? a : b"
        Conditional
           Type: uint256
           Source: "a < b ? a : b"
          BinaryOperation using operator <
             Type: bool
             Source: "a < b"
            Identifier a
               Type: uint256
               Source: "a"
            Identifier b
               Type: uint256
               Source: "b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
ContractDefinition "ERC20Basic"
   Gas costs: 0
   Source: "contract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) constant returns (uint256);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint256 value) returns (bool);"
    ParameterList
       Source: "(address to, uint256 value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "ERC20"
   Gas costs: 0
   Source: "contract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
  InheritanceSpecifier
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) constant returns (uint256);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint256 value) returns (bool);"
    ParameterList
       Source: "(address from, address to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint256 value) returns (bool);"
    ParameterList
       Source: "(address spender, uint256 value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint256 value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint256 value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "Ownable"
   Source: "contract Ownable {\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: 0
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "Ownable" - public
     Source: "function Ownable() {\r\n    owner = msg.sender;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    owner = msg.sender;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }"
      IfStatement
         Source: "if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "newOwner != address(0)"
          Identifier newOwner
             Type: address
             Source: "newOwner"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n      owner = newOwner;\r\n    }"
          ExpressionStatement
             Gas costs: 0
             Source: "owner = newOwner"
            Assignment using operator =
               Type: address
               Source: "owner = newOwner"
              Identifier owner
                 Type: address
                 Source: "owner"
              Identifier newOwner
                 Type: address
                 Source: "newOwner"
ContractDefinition "UintLib"
   Source: "library UintLib {\r\n    using SafeMath  for uint;\r\n\r\n    function tolerantSub(uint x, uint y) internal constant returns (uint z) {\r\n        if (x >= y)\r\n            z = x - y;\r\n        else\r\n            z = 0;\r\n    }\r\n\r\n    function next(uint i, uint size) internal constant returns (uint) {\r\n        return (i + 1) % size;\r\n    }\r\n\r\n    function prev(uint i, uint size) internal constant returns (uint) {\r\n        return (i + size - 1) % size;\r\n    }\r\n\r\n    /// @dev calculate the square of Coefficient of Variation (CV)\r\n    /// https://en.wikipedia.org/wiki/Coefficient_of_variation\r\n    function cvsquare(\r\n        uint[] arr,\r\n        uint scale)\r\n        internal\r\n        constant\r\n        returns (uint)\r\n    {\r\n        uint len = arr.length;\r\n        require(len > 1);\r\n        require(scale > 0);\r\n\r\n        uint avg = 0;\r\n        for (uint i = 0; i < len; i++) {\r\n            avg += arr[i];\r\n        }\r\n\r\n        avg = avg.div(len);\r\n\r\n        if (avg == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint cvs = 0;\r\n        for (i = 0; i < len; i++) {\r\n            uint sub = 0;\r\n            if (arr[i] > avg) {\r\n                sub = arr[i] - avg;\r\n            } else {\r\n                sub = avg - arr[i];\r\n            }\r\n            cvs += sub.mul(sub);\r\n        }\r\n\r\n        return cvs.mul(scale).div(avg).mul(scale).div(avg).div(len - 1);\r\n    }\r\n}"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath  for uint;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "tolerantSub" - const
     Source: "function tolerantSub(uint x, uint y) internal constant returns (uint z) {\r\n        if (x >= y)\r\n            z = x - y;\r\n        else\r\n            z = 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint x, uint y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint x"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint y"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint z)"
      VariableDeclaration "z"
         Type: uint256
         Source: "uint z"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (x >= y)\r\n            z = x - y;\r\n        else\r\n            z = 0;\r\n    }"
      IfStatement
         Source: "if (x >= y)\r\n            z = x - y;\r\n        else\r\n            z = 0"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 12
           Source: "x >= y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
        ExpressionStatement
           Gas costs: 14
           Source: "z = x - y"
          Assignment using operator =
             Type: uint256
             Source: "z = x - y"
            Identifier z
               Type: uint256
               Source: "z"
            BinaryOperation using operator -
               Type: uint256
               Source: "x - y"
              Identifier x
                 Type: uint256
                 Source: "x"
              Identifier y
                 Type: uint256
                 Source: "y"
        ExpressionStatement
           Gas costs: 8
           Source: "z = 0"
          Assignment using operator =
             Type: uint256
             Source: "z = 0"
            Identifier z
               Type: uint256
               Source: "z"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "next" - const
     Source: "function next(uint i, uint size) internal constant returns (uint) {\r\n        return (i + 1) % size;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint i, uint size)"
      VariableDeclaration "i"
         Type: uint256
         Source: "uint i"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "size"
         Type: uint256
         Source: "uint size"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return (i + 1) % size;\r\n    }"
      Return
         Gas costs: 45
         Source: "return (i + 1) % size"
        BinaryOperation using operator %
           Type: uint256
           Source: "(i + 1) % size"
          TupleExpression
             Type: uint256
             Source: "(i + 1)"
            BinaryOperation using operator +
               Type: uint256
               Source: "i + 1"
              Identifier i
                 Type: uint256
                 Source: "i"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          Identifier size
             Type: uint256
             Source: "size"
  FunctionDefinition "prev" - const
     Source: "function prev(uint i, uint size) internal constant returns (uint) {\r\n        return (i + size - 1) % size;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint i, uint size)"
      VariableDeclaration "i"
         Type: uint256
         Source: "uint i"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "size"
         Type: uint256
         Source: "uint size"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return (i + size - 1) % size;\r\n    }"
      Return
         Gas costs: 51
         Source: "return (i + size - 1) % size"
        BinaryOperation using operator %
           Type: uint256
           Source: "(i + size - 1) % size"
          TupleExpression
             Type: uint256
             Source: "(i + size - 1)"
            BinaryOperation using operator -
               Type: uint256
               Source: "i + size - 1"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "i + size"
                Identifier i
                   Type: uint256
                   Source: "i"
                Identifier size
                   Type: uint256
                   Source: "size"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          Identifier size
             Type: uint256
             Source: "size"
  FunctionDefinition "cvsquare" - const
     Source: "function cvsquare(\r\n        uint[] arr,\r\n        uint scale)\r\n        internal\r\n        constant\r\n        returns (uint)\r\n    {\r\n        uint len = arr.length;\r\n        require(len > 1);\r\n        require(scale > 0);\r\n\r\n        uint avg = 0;\r\n        for (uint i = 0; i < len; i++) {\r\n            avg += arr[i];\r\n        }\r\n\r\n        avg = avg.div(len);\r\n\r\n        if (avg == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint cvs = 0;\r\n        for (i = 0; i < len; i++) {\r\n            uint sub = 0;\r\n            if (arr[i] > avg) {\r\n                sub = arr[i] - avg;\r\n            } else {\r\n                sub = avg - arr[i];\r\n            }\r\n            cvs += sub.mul(sub);\r\n        }\r\n\r\n        return cvs.mul(scale).div(avg).mul(scale).div(avg).div(len - 1);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint[] arr,\r\n        uint scale)"
      VariableDeclaration "arr"
         Type: uint256[] memory
         Source: "uint[] arr"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclaration "scale"
         Type: uint256
         Source: "uint scale"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint len = arr.length;\r\n        require(len > 1);\r\n        require(scale > 0);\r\n\r\n        uint avg = 0;\r\n        for (uint i = 0; i < len; i++) {\r\n            avg += arr[i];\r\n        }\r\n\r\n        avg = avg.div(len);\r\n\r\n        if (avg == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint cvs = 0;\r\n        for (i = 0; i < len; i++) {\r\n            uint sub = 0;\r\n            if (arr[i] > avg) {\r\n                sub = arr[i] - avg;\r\n            } else {\r\n                sub = avg - arr[i];\r\n            }\r\n            cvs += sub.mul(sub);\r\n        }\r\n\r\n        return cvs.mul(scale).div(avg).mul(scale).div(avg).div(len - 1);\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint len = arr.length"
        VariableDeclaration "len"
           Type: uint256
           Source: "uint len"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "arr.length"
          Identifier arr
             Type: uint256[] memory
             Source: "arr"
      ExpressionStatement
         Gas costs: 35
         Source: "require(len > 1)"
        FunctionCall
           Type: tuple()
           Source: "require(len > 1)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "len > 1"
            Identifier len
               Type: uint256
               Source: "len"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: 35
         Source: "require(scale > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(scale > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "scale > 0"
            Identifier scale
               Type: uint256
               Source: "scale"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint avg = 0"
        VariableDeclaration "avg"
           Type: uint256
           Source: "uint avg"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for (uint i = 0; i < len; i++) {\r\n            avg += arr[i];\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < len"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier len
             Type: uint256
             Source: "len"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            avg += arr[i];\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "avg += arr[i]"
            Assignment using operator +=
               Type: uint256
               Source: "avg += arr[i]"
              Identifier avg
                 Type: uint256
                 Source: "avg"
              IndexAccess
                 Type: uint256
                 Source: "arr[i]"
                Identifier arr
                   Type: uint256[] memory
                   Source: "arr"
                Identifier i
                   Type: uint256
                   Source: "i"
      ExpressionStatement
         Gas costs: 41
         Source: "avg = avg.div(len)"
        Assignment using operator =
           Type: uint256
           Source: "avg = avg.div(len)"
          Identifier avg
             Type: uint256
             Source: "avg"
          FunctionCall
             Type: uint256
             Source: "avg.div(len)"
            MemberAccess to member div
               Type: function (uint256,uint256) view returns (uint256)
               Source: "avg.div"
              Identifier avg
                 Type: uint256
                 Source: "avg"
            Identifier len
               Type: uint256
               Source: "len"
      IfStatement
         Source: "if (avg == 0) {\r\n            return 0;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "avg == 0"
          Identifier avg
             Type: uint256
             Source: "avg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            return 0;\r\n        }"
          Return
             Gas costs: 19
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint cvs = 0"
        VariableDeclaration "cvs"
           Type: uint256
           Source: "uint cvs"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for (i = 0; i < len; i++) {\r\n            uint sub = 0;\r\n            if (arr[i] > avg) {\r\n                sub = arr[i] - avg;\r\n            } else {\r\n                sub = avg - arr[i];\r\n            }\r\n            cvs += sub.mul(sub);\r\n        }"
        ExpressionStatement
           Gas costs: 8
           Source: "i = 0"
          Assignment using operator =
             Type: uint256
             Source: "i = 0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < len"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier len
             Type: uint256
             Source: "len"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            uint sub = 0;\r\n            if (arr[i] > avg) {\r\n                sub = arr[i] - avg;\r\n            } else {\r\n                sub = avg - arr[i];\r\n            }\r\n            cvs += sub.mul(sub);\r\n        }"
          VariableDeclarationStatement
             Gas costs: 11
             Source: "uint sub = 0"
            VariableDeclaration "sub"
               Type: uint256
               Source: "uint sub"
              ElementaryTypeName uint
                 Source: "uint"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IfStatement
             Source: "if (arr[i] > avg) {\r\n                sub = arr[i] - avg;\r\n            } else {\r\n                sub = avg - arr[i];\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: [???]
               Source: "arr[i] > avg"
              IndexAccess
                 Type: uint256
                 Source: "arr[i]"
                Identifier arr
                   Type: uint256[] memory
                   Source: "arr"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier avg
                 Type: uint256
                 Source: "avg"
            Block
               Source: "{\r\n                sub = arr[i] - avg;\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "sub = arr[i] - avg"
                Assignment using operator =
                   Type: uint256
                   Source: "sub = arr[i] - avg"
                  Identifier sub
                     Type: uint256
                     Source: "sub"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "arr[i] - avg"
                    IndexAccess
                       Type: uint256
                       Source: "arr[i]"
                      Identifier arr
                         Type: uint256[] memory
                         Source: "arr"
                      Identifier i
                         Type: uint256
                         Source: "i"
                    Identifier avg
                       Type: uint256
                       Source: "avg"
            Block
               Source: "{\r\n                sub = avg - arr[i];\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "sub = avg - arr[i]"
                Assignment using operator =
                   Type: uint256
                   Source: "sub = avg - arr[i]"
                  Identifier sub
                     Type: uint256
                     Source: "sub"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "avg - arr[i]"
                    Identifier avg
                       Type: uint256
                       Source: "avg"
                    IndexAccess
                       Type: uint256
                       Source: "arr[i]"
                      Identifier arr
                         Type: uint256[] memory
                         Source: "arr"
                      Identifier i
                         Type: uint256
                         Source: "i"
          ExpressionStatement
             Gas costs: 47
             Source: "cvs += sub.mul(sub)"
            Assignment using operator +=
               Type: uint256
               Source: "cvs += sub.mul(sub)"
              Identifier cvs
                 Type: uint256
                 Source: "cvs"
              FunctionCall
                 Type: uint256
                 Source: "sub.mul(sub)"
                MemberAccess to member mul
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "sub.mul"
                  Identifier sub
                     Type: uint256
                     Source: "sub"
                Identifier sub
                   Type: uint256
                   Source: "sub"
      Return
         Gas costs: 179
         Source: "return cvs.mul(scale).div(avg).mul(scale).div(avg).div(len - 1)"
        FunctionCall
           Type: uint256
           Source: "cvs.mul(scale).div(avg).mul(scale).div(avg).div(len - 1)"
          MemberAccess to member div
             Type: function (uint256,uint256) view returns (uint256)
             Source: "cvs.mul(scale).div(avg).mul(scale).div(avg).div"
            FunctionCall
               Type: uint256
               Source: "cvs.mul(scale).div(avg).mul(scale).div(avg)"
              MemberAccess to member div
                 Type: function (uint256,uint256) view returns (uint256)
                 Source: "cvs.mul(scale).div(avg).mul(scale).div"
                FunctionCall
                   Type: uint256
                   Source: "cvs.mul(scale).div(avg).mul(scale)"
                  MemberAccess to member mul
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "cvs.mul(scale).div(avg).mul"
                    FunctionCall
                       Type: uint256
                       Source: "cvs.mul(scale).div(avg)"
                      MemberAccess to member div
                         Type: function (uint256,uint256) view returns (uint256)
                         Source: "cvs.mul(scale).div"
                        FunctionCall
                           Type: uint256
                           Source: "cvs.mul(scale)"
                          MemberAccess to member mul
                             Type: function (uint256,uint256) view returns (uint256)
                             Source: "cvs.mul"
                            Identifier cvs
                               Type: uint256
                               Source: "cvs"
                          Identifier scale
                             Type: uint256
                             Source: "scale"
                      Identifier avg
                         Type: uint256
                         Source: "avg"
                  Identifier scale
                     Type: uint256
                     Source: "scale"
              Identifier avg
                 Type: uint256
                 Source: "avg"
          BinaryOperation using operator -
             Type: uint256
             Source: "len - 1"
            Identifier len
               Type: uint256
               Source: "len"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
ContractDefinition "Uint8Lib"
   Source: "library Uint8Lib {\r\n    function xorReduce(\r\n        uint8[] arr,\r\n        uint    len\r\n        )\r\n        internal\r\n        constant\r\n        returns (uint8 res)\r\n    {\r\n        res = arr[0];\r\n        for (uint i = 1; i < len; i++) {\r\n            res ^= arr[i];\r\n        }\r\n    }\r\n}"
  FunctionDefinition "xorReduce" - const
     Source: "function xorReduce(\r\n        uint8[] arr,\r\n        uint    len\r\n        )\r\n        internal\r\n        constant\r\n        returns (uint8 res)\r\n    {\r\n        res = arr[0];\r\n        for (uint i = 1; i < len; i++) {\r\n            res ^= arr[i];\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint8[] arr,\r\n        uint    len\r\n        )"
      VariableDeclaration "arr"
         Type: uint8[] memory
         Source: "uint8[] arr"
        ArrayTypeName
           Source: "uint8[]"
          ElementaryTypeName uint8
             Source: "uint8"
      VariableDeclaration "len"
         Type: uint256
         Source: "uint    len"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint8 res)"
      VariableDeclaration "res"
         Type: uint8
         Source: "uint8 res"
        ElementaryTypeName uint8
           Source: "uint8"
    Block
       Source: "{\r\n        res = arr[0];\r\n        for (uint i = 1; i < len; i++) {\r\n            res ^= arr[i];\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "res = arr[0]"
        Assignment using operator =
           Type: uint8
           Source: "res = arr[0]"
          Identifier res
             Type: uint8
             Source: "res"
          IndexAccess
             Type: uint8
             Source: "arr[0]"
            Identifier arr
               Type: uint8[] memory
               Source: "arr"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ForStatement
         Source: "for (uint i = 1; i < len; i++) {\r\n            res ^= arr[i];\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 1"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < len"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier len
             Type: uint256
             Source: "len"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            res ^= arr[i];\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "res ^= arr[i]"
            Assignment using operator ^=
               Type: uint8
               Source: "res ^= arr[i]"
              Identifier res
                 Type: uint8
                 Source: "res"
              IndexAccess
                 Type: uint8
                 Source: "arr[i]"
                Identifier arr
                   Type: uint8[] memory
                   Source: "arr"
                Identifier i
                   Type: uint256
                   Source: "i"
ContractDefinition "ErrorLib"
   Source: "library ErrorLib {\r\n\r\n    event Error(string message);\r\n\r\n    /// @dev Check if condition hold, if not, log an exception and revert.\r\n    function check(bool condition, string message) internal constant {\r\n        if (!condition) {\r\n            error(message);\r\n        }\r\n    }\r\n\r\n    function error(string message) internal constant {\r\n        Error(message);\r\n        revert();\r\n    }\r\n}"
  EventDefinition "Error"
     Gas costs: 0
     Source: "event Error(string message);"
    ParameterList
       Source: "(string message)"
      VariableDeclaration "message"
         Type: string memory
         Source: "string message"
        ElementaryTypeName string
           Source: "string"
  FunctionDefinition "check" - const
     Source: "function check(bool condition, string message) internal constant {\r\n        if (!condition) {\r\n            error(message);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bool condition, string message)"
      VariableDeclaration "condition"
         Type: bool
         Source: "bool condition"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "message"
         Type: string memory
         Source: "string message"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (!condition) {\r\n            error(message);\r\n        }\r\n    }"
      IfStatement
         Source: "if (!condition) {\r\n            error(message);\r\n        }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 6
           Source: "!condition"
          Identifier condition
             Type: bool
             Source: "condition"
        Block
           Source: "{\r\n            error(message);\r\n        }"
          ExpressionStatement
             Gas costs: 18
             Source: "error(message)"
            FunctionCall
               Type: tuple()
               Source: "error(message)"
              Identifier error
                 Type: function (string memory) view
                 Source: "error"
              Identifier message
                 Type: string memory
                 Source: "message"
  FunctionDefinition "error" - const
     Source: "function error(string message) internal constant {\r\n        Error(message);\r\n        revert();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string message)"
      VariableDeclaration "message"
         Type: string memory
         Source: "string message"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        Error(message);\r\n        revert();\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "Error(message)"
        FunctionCall
           Type: tuple()
           Source: "Error(message)"
          Identifier Error
             Type: function (string memory)
             Source: "Error"
          Identifier message
             Type: string memory
             Source: "message"
      ExpressionStatement
         Gas costs: 6
         Source: "revert()"
        FunctionCall
           Type: tuple()
           Source: "revert()"
          Identifier revert
             Type: function () pure
             Source: "revert"
ContractDefinition "Bytes32Lib"
   Source: "library Bytes32Lib {\r\n\r\n    function xorReduce(\r\n        bytes32[]   arr,\r\n        uint        len\r\n        )\r\n        internal\r\n        constant\r\n        returns (bytes32 res)\r\n    {\r\n        res = arr[0];\r\n        for (uint i = 1; i < len; i++) {\r\n            res = xorOp(res, arr[i]);\r\n        }\r\n    }\r\n\r\n    function xorOp(\r\n        bytes32 bs1,\r\n        bytes32 bs2\r\n        )\r\n        internal\r\n        constant\r\n        returns (bytes32 res)\r\n    {\r\n        bytes memory temp = new bytes(32);\r\n        for (uint i = 0; i < 32; i++) {\r\n            temp[i] = bs1[i] ^ bs2[i];\r\n        }\r\n        string memory str = string(temp);\r\n        assembly {\r\n            res := mload(add(str, 32))\r\n        }\r\n    }\r\n}"
  FunctionDefinition "xorReduce" - const
     Source: "function xorReduce(\r\n        bytes32[]   arr,\r\n        uint        len\r\n        )\r\n        internal\r\n        constant\r\n        returns (bytes32 res)\r\n    {\r\n        res = arr[0];\r\n        for (uint i = 1; i < len; i++) {\r\n            res = xorOp(res, arr[i]);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        bytes32[]   arr,\r\n        uint        len\r\n        )"
      VariableDeclaration "arr"
         Type: bytes32[] memory
         Source: "bytes32[]   arr"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclaration "len"
         Type: uint256
         Source: "uint        len"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 res)"
      VariableDeclaration "res"
         Type: bytes32
         Source: "bytes32 res"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        res = arr[0];\r\n        for (uint i = 1; i < len; i++) {\r\n            res = xorOp(res, arr[i]);\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "res = arr[0]"
        Assignment using operator =
           Type: bytes32
           Source: "res = arr[0]"
          Identifier res
             Type: bytes32
             Source: "res"
          IndexAccess
             Type: bytes32
             Source: "arr[0]"
            Identifier arr
               Type: bytes32[] memory
               Source: "arr"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ForStatement
         Source: "for (uint i = 1; i < len; i++) {\r\n            res = xorOp(res, arr[i]);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 1"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < len"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier len
             Type: uint256
             Source: "len"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            res = xorOp(res, arr[i]);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "res = xorOp(res, arr[i])"
            Assignment using operator =
               Type: bytes32
               Source: "res = xorOp(res, arr[i])"
              Identifier res
                 Type: bytes32
                 Source: "res"
              FunctionCall
                 Type: bytes32
                 Source: "xorOp(res, arr[i])"
                Identifier xorOp
                   Type: function (bytes32,bytes32) view returns (bytes32)
                   Source: "xorOp"
                Identifier res
                   Type: bytes32
                   Source: "res"
                IndexAccess
                   Type: bytes32
                   Source: "arr[i]"
                  Identifier arr
                     Type: bytes32[] memory
                     Source: "arr"
                  Identifier i
                     Type: uint256
                     Source: "i"
  FunctionDefinition "xorOp" - const
     Source: "function xorOp(\r\n        bytes32 bs1,\r\n        bytes32 bs2\r\n        )\r\n        internal\r\n        constant\r\n        returns (bytes32 res)\r\n    {\r\n        bytes memory temp = new bytes(32);\r\n        for (uint i = 0; i < 32; i++) {\r\n            temp[i] = bs1[i] ^ bs2[i];\r\n        }\r\n        string memory str = string(temp);\r\n        assembly {\r\n            res := mload(add(str, 32))\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        bytes32 bs1,\r\n        bytes32 bs2\r\n        )"
      VariableDeclaration "bs1"
         Type: bytes32
         Source: "bytes32 bs1"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "bs2"
         Type: bytes32
         Source: "bytes32 bs2"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 res)"
      VariableDeclaration "res"
         Type: bytes32
         Source: "bytes32 res"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        bytes memory temp = new bytes(32);\r\n        for (uint i = 0; i < 32; i++) {\r\n            temp[i] = bs1[i] ^ bs2[i];\r\n        }\r\n        string memory str = string(temp);\r\n        assembly {\r\n            res := mload(add(str, 32))\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory temp = new bytes(32)"
        VariableDeclaration "temp"
           Type: bytes memory
           Source: "bytes memory temp"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "new bytes(32)"
          NewExpression
             Type: function (uint256) pure returns (bytes memory)
             Source: "new bytes"
            ElementaryTypeName bytes
               Source: "bytes"
          Literal, token: [no token] value: 32
             Type: int_const 32
             Source: "32"
      ForStatement
         Source: "for (uint i = 0; i < 32; i++) {\r\n            temp[i] = bs1[i] ^ bs2[i];\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < 32"
          Identifier i
             Type: uint256
             Source: "i"
          Literal, token: [no token] value: 32
             Type: int_const 32
             Source: "32"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            temp[i] = bs1[i] ^ bs2[i];\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "temp[i] = bs1[i] ^ bs2[i]"
            Assignment using operator =
               Type: bytes1
               Source: "temp[i] = bs1[i] ^ bs2[i]"
              IndexAccess
                 Type: bytes1
                 Source: "temp[i]"
                Identifier temp
                   Type: bytes memory
                   Source: "temp"
                Identifier i
                   Type: uint256
                   Source: "i"
              BinaryOperation using operator ^
                 Type: bytes1
                 Source: "bs1[i] ^ bs2[i]"
                IndexAccess
                   Type: bytes1
                   Source: "bs1[i]"
                  Identifier bs1
                     Type: bytes32
                     Source: "bs1"
                  Identifier i
                     Type: uint256
                     Source: "i"
                IndexAccess
                   Type: bytes1
                   Source: "bs2[i]"
                  Identifier bs2
                     Type: bytes32
                     Source: "bs2"
                  Identifier i
                     Type: uint256
                     Source: "i"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "string memory str = string(temp)"
        VariableDeclaration "str"
           Type: string memory
           Source: "string memory str"
          ElementaryTypeName string
             Source: "string"
        FunctionCall
           Type: string memory
           Source: "string(temp)"
          ElementaryTypeNameExpression string
             Type: type(string storage pointer)
             Source: "string"
          Identifier temp
             Type: bytes memory
             Source: "temp"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {\r\n            res := mload(add(str, 32))\r\n        }\r\n    }"
ContractDefinition "TokenRegistry"
   Source: "contract TokenRegistry is Ownable {\r\n\r\n    address[] public tokens;\r\n\r\n    mapping (string => address) tokenSymbolMap;\r\n\r\n    function registerToken(address _token, string _symbol)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(_token != address(0));\r\n        require(!isTokenRegisteredBySymbol(_symbol));\r\n        require(!isTokenRegistered(_token));\r\n        tokens.push(_token);\r\n        tokenSymbolMap[_symbol] = _token;\r\n    }\r\n\r\n    function unregisterToken(address _token, string _symbol)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(tokenSymbolMap[_symbol] == _token);\r\n        delete tokenSymbolMap[_symbol];\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            if (tokens[i] == _token) {\r\n                tokens[i] == tokens[tokens.length - 1];\r\n                tokens.length --;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function isTokenRegisteredBySymbol(string symbol)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return tokenSymbolMap[symbol] != address(0);\r\n    }\r\n\r\n    function isTokenRegistered(address _token)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            if (tokens[i] == _token) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getAddressBySymbol(string symbol)\r\n        public\r\n        constant\r\n        returns (address)\r\n    {\r\n        return tokenSymbolMap[symbol];\r\n    }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  VariableDeclaration "tokens"
     Type: address[] storage ref
     Gas costs: 0
     Source: "address[] public tokens"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "tokenSymbolMap"
     Type: mapping(string memory => address)
     Gas costs: 0
     Source: "mapping (string => address) tokenSymbolMap"
    Mapping
       Source: "mapping (string => address)"
      ElementaryTypeName string
         Source: "string"
      ElementaryTypeName address
         Source: "address"
  FunctionDefinition "registerToken" - public
     Source: "function registerToken(address _token, string _symbol)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(_token != address(0));\r\n        require(!isTokenRegisteredBySymbol(_symbol));\r\n        require(!isTokenRegistered(_token));\r\n        tokens.push(_token);\r\n        tokenSymbolMap[_symbol] = _token;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _token, string _symbol)"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_symbol"
         Type: string memory
         Source: "string _symbol"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_token != address(0));\r\n        require(!isTokenRegisteredBySymbol(_symbol));\r\n        require(!isTokenRegistered(_token));\r\n        tokens.push(_token);\r\n        tokenSymbolMap[_symbol] = _token;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_token != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_token != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_token != address(0)"
            Identifier _token
               Type: address
               Source: "_token"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!isTokenRegisteredBySymbol(_symbol))"
        FunctionCall
           Type: tuple()
           Source: "require(!isTokenRegisteredBySymbol(_symbol))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!isTokenRegisteredBySymbol(_symbol)"
            FunctionCall
               Type: bool
               Source: "isTokenRegisteredBySymbol(_symbol)"
              Identifier isTokenRegisteredBySymbol
                 Type: function (string memory) view returns (bool)
                 Source: "isTokenRegisteredBySymbol"
              Identifier _symbol
                 Type: string memory
                 Source: "_symbol"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!isTokenRegistered(_token))"
        FunctionCall
           Type: tuple()
           Source: "require(!isTokenRegistered(_token))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!isTokenRegistered(_token)"
            FunctionCall
               Type: bool
               Source: "isTokenRegistered(_token)"
              Identifier isTokenRegistered
                 Type: function (address) view returns (bool)
                 Source: "isTokenRegistered"
              Identifier _token
                 Type: address
                 Source: "_token"
      ExpressionStatement
         Gas costs: 0
         Source: "tokens.push(_token)"
        FunctionCall
           Type: uint256
           Source: "tokens.push(_token)"
          MemberAccess to member push
             Type: function (address) returns (uint256)
             Source: "tokens.push"
            Identifier tokens
               Type: address[] storage ref
               Source: "tokens"
          Identifier _token
             Type: address
             Source: "_token"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenSymbolMap[_symbol] = _token"
        Assignment using operator =
           Type: address
           Source: "tokenSymbolMap[_symbol] = _token"
          IndexAccess
             Type: address
             Source: "tokenSymbolMap[_symbol]"
            Identifier tokenSymbolMap
               Type: mapping(string memory => address)
               Source: "tokenSymbolMap"
            Identifier _symbol
               Type: string memory
               Source: "_symbol"
          Identifier _token
             Type: address
             Source: "_token"
  FunctionDefinition "unregisterToken" - public
     Source: "function unregisterToken(address _token, string _symbol)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(tokenSymbolMap[_symbol] == _token);\r\n        delete tokenSymbolMap[_symbol];\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            if (tokens[i] == _token) {\r\n                tokens[i] == tokens[tokens.length - 1];\r\n                tokens.length --;\r\n                break;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _token, string _symbol)"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_symbol"
         Type: string memory
         Source: "string _symbol"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(tokenSymbolMap[_symbol] == _token);\r\n        delete tokenSymbolMap[_symbol];\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            if (tokens[i] == _token) {\r\n                tokens[i] == tokens[tokens.length - 1];\r\n                tokens.length --;\r\n                break;\r\n            }\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(tokenSymbolMap[_symbol] == _token)"
        FunctionCall
           Type: tuple()
           Source: "require(tokenSymbolMap[_symbol] == _token)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "tokenSymbolMap[_symbol] == _token"
            IndexAccess
               Type: address
               Source: "tokenSymbolMap[_symbol]"
              Identifier tokenSymbolMap
                 Type: mapping(string memory => address)
                 Source: "tokenSymbolMap"
              Identifier _symbol
                 Type: string memory
                 Source: "_symbol"
            Identifier _token
               Type: address
               Source: "_token"
      ExpressionStatement
         Gas costs: 0
         Source: "delete tokenSymbolMap[_symbol]"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete tokenSymbolMap[_symbol]"
          IndexAccess
             Type: address
             Source: "tokenSymbolMap[_symbol]"
            Identifier tokenSymbolMap
               Type: mapping(string memory => address)
               Source: "tokenSymbolMap"
            Identifier _symbol
               Type: string memory
               Source: "_symbol"
      ForStatement
         Source: "for (uint i = 0; i < tokens.length; i++) {\r\n            if (tokens[i] == _token) {\r\n                tokens[i] == tokens[tokens.length - 1];\r\n                tokens.length --;\r\n                break;\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < tokens.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "tokens.length"
            Identifier tokens
               Type: address[] storage ref
               Source: "tokens"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (tokens[i] == _token) {\r\n                tokens[i] == tokens[tokens.length - 1];\r\n                tokens.length --;\r\n                break;\r\n            }\r\n        }"
          IfStatement
             Source: "if (tokens[i] == _token) {\r\n                tokens[i] == tokens[tokens.length - 1];\r\n                tokens.length --;\r\n                break;\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "tokens[i] == _token"
              IndexAccess
                 Type: address
                 Source: "tokens[i]"
                Identifier tokens
                   Type: address[] storage ref
                   Source: "tokens"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier _token
                 Type: address
                 Source: "_token"
            Block
               Source: "{\r\n                tokens[i] == tokens[tokens.length - 1];\r\n                tokens.length --;\r\n                break;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "tokens[i] == tokens[tokens.length - 1]"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "tokens[i] == tokens[tokens.length - 1]"
                  IndexAccess
                     Type: address
                     Source: "tokens[i]"
                    Identifier tokens
                       Type: address[] storage ref
                       Source: "tokens"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  IndexAccess
                     Type: address
                     Source: "tokens[tokens.length - 1]"
                    Identifier tokens
                       Type: address[] storage ref
                       Source: "tokens"
                    BinaryOperation using operator -
                       Type: uint256
                       Source: "tokens.length - 1"
                      MemberAccess to member length
                         Type: uint256
                         Source: "tokens.length"
                        Identifier tokens
                           Type: address[] storage ref
                           Source: "tokens"
                      Literal, token: [no token] value: 1
                         Type: int_const 1
                         Source: "1"
              ExpressionStatement
                 Gas costs: 0
                 Source: "tokens.length --"
                UnaryOperation (postfix) --
                   Type: uint256
                   Source: "tokens.length --"
                  MemberAccess to member length
                     Type: uint256
                     Source: "tokens.length"
                    Identifier tokens
                       Type: address[] storage ref
                       Source: "tokens"
              Break
                 Gas costs: 0
                 Source: "break"
  FunctionDefinition "isTokenRegisteredBySymbol" - public - const
     Source: "function isTokenRegisteredBySymbol(string symbol)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return tokenSymbolMap[symbol] != address(0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string symbol)"
      VariableDeclaration "symbol"
         Type: string memory
         Source: "string symbol"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        return tokenSymbolMap[symbol] != address(0);\r\n    }"
      Return
         Gas costs: 0
         Source: "return tokenSymbolMap[symbol] != address(0)"
        BinaryOperation using operator !=
           Type: bool
           Source: "tokenSymbolMap[symbol] != address(0)"
          IndexAccess
             Type: address
             Source: "tokenSymbolMap[symbol]"
            Identifier tokenSymbolMap
               Type: mapping(string memory => address)
               Source: "tokenSymbolMap"
            Identifier symbol
               Type: string memory
               Source: "symbol"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "isTokenRegistered" - public - const
     Source: "function isTokenRegistered(address _token)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            if (tokens[i] == _token) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _token)"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            if (tokens[i] == _token) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }"
      ForStatement
         Source: "for (uint i = 0; i < tokens.length; i++) {\r\n            if (tokens[i] == _token) {\r\n                return true;\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < tokens.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "tokens.length"
            Identifier tokens
               Type: address[] storage ref
               Source: "tokens"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (tokens[i] == _token) {\r\n                return true;\r\n            }\r\n        }"
          IfStatement
             Source: "if (tokens[i] == _token) {\r\n                return true;\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "tokens[i] == _token"
              IndexAccess
                 Type: address
                 Source: "tokens[i]"
                Identifier tokens
                   Type: address[] storage ref
                   Source: "tokens"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier _token
                 Type: address
                 Source: "_token"
            Block
               Source: "{\r\n                return true;\r\n            }"
              Return
                 Gas costs: 0
                 Source: "return true"
                Literal, token: true value: true
                   Type: bool
                   Source: "true"
      Return
         Gas costs: 0
         Source: "return false"
        Literal, token: false value: false
           Type: bool
           Source: "false"
  FunctionDefinition "getAddressBySymbol" - public - const
     Source: "function getAddressBySymbol(string symbol)\r\n        public\r\n        constant\r\n        returns (address)\r\n    {\r\n        return tokenSymbolMap[symbol];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string symbol)"
      VariableDeclaration "symbol"
         Type: string memory
         Source: "string symbol"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return tokenSymbolMap[symbol];\r\n    }"
      Return
         Gas costs: 0
         Source: "return tokenSymbolMap[symbol]"
        IndexAccess
           Type: address
           Source: "tokenSymbolMap[symbol]"
          Identifier tokenSymbolMap
             Type: mapping(string memory => address)
             Source: "tokenSymbolMap"
          Identifier symbol
             Type: string memory
             Source: "symbol"
ContractDefinition "TokenTransferDelegate"
   Source: "contract TokenTransferDelegate is Ownable {\r\n    using Math for uint;\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Variables                                                            ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n\r\n    uint lastVersion = 0;\r\n    address[] public versions;\r\n    mapping (address => uint) public versioned;\r\n\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Modifiers                                                            ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n\r\n    modifier isVersioned(address addr) {\r\n        if (versioned[addr] == 0) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier notVersioned(address addr) {\r\n        if (versioned[addr] > 0) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Events                                                               ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n\r\n    event VersionAdded(address indexed addr, uint version);\r\n\r\n    event VersionRemoved(address indexed addr, uint version);\r\n\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Public Functions                                                     ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n\r\n    /// @dev Add a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function addVersion(address addr)\r\n        onlyOwner\r\n        notVersioned(addr)\r\n    {\r\n        versioned[addr] = ++lastVersion;\r\n        versions.push(addr);\r\n        VersionAdded(addr, lastVersion);\r\n    }\r\n\r\n    /// @dev Remove a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function removeVersion(address addr)\r\n        onlyOwner\r\n        isVersioned(addr)\r\n    {\r\n        require(versioned[addr] > 0);\r\n        uint version = versioned[addr];\r\n        delete versioned[addr];\r\n\r\n        uint length = versions.length;\r\n        for (uint i = 0; i < length; i++) {\r\n            if (versions[i] == addr) {\r\n                versions[i] = versions[length - 1];\r\n                versions.length -= 1;\r\n                break;\r\n            }\r\n        }\r\n        VersionRemoved(addr, version);\r\n    }\r\n\r\n    /// @return Amount of ERC20 token that can be spent by this contract.\r\n    /// @param tokenAddress Address of token to transfer.\r\n    /// @param _owner Address of the token owner.\r\n    function getSpendable(\r\n        address tokenAddress,\r\n        address _owner\r\n        )\r\n        isVersioned(msg.sender)\r\n        constant\r\n        returns (uint)\r\n    {\r\n\r\n        var token = ERC20(tokenAddress);\r\n        return token.allowance(\r\n            _owner,\r\n            address(this)\r\n        ).min256(\r\n            token.balanceOf(_owner)\r\n        );\r\n    }\r\n\r\n    /// @dev Invoke ERC20 transferFrom method.\r\n    /// @param token Address of token to transfer.\r\n    /// @param from Address to transfer token from.\r\n    /// @param to Address to transfer token to.\r\n    /// @param value Amount of token to transfer.\r\n    /// @return Tansfer result.\r\n    function transferToken(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint value)\r\n        isVersioned(msg.sender)\r\n        returns (bool)\r\n    {\r\n        if (from == to) {\r\n            return false;\r\n        } else {\r\n            return ERC20(token).transferFrom(from, to, value);\r\n        }\r\n    }\r\n\r\n    /// @dev Gets all versioned addresses.\r\n    /// @return Array of versioned addresses.\r\n    function getVersions()\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return versions;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  UsingForDirective
     Gas costs: 0
     Source: "using Math for uint;"
    UserDefinedTypeName "Math"
       Source: "Math"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "lastVersion"
     Type: uint256
     Gas costs: 0
     Source: "uint lastVersion = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "versions"
     Type: address[] storage ref
     Gas costs: 0
     Source: "address[] public versions"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "versioned"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint) public versioned"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  ModifierDefinition "isVersioned"
     Source: "modifier isVersioned(address addr) {\r\n        if (versioned[addr] == 0) {\r\n            revert();\r\n        }\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address addr)"
      VariableDeclaration "addr"
         Type: address
         Source: "address addr"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        if (versioned[addr] == 0) {\r\n            revert();\r\n        }\r\n        _;\r\n    }"
      IfStatement
         Source: "if (versioned[addr] == 0) {\r\n            revert();\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "versioned[addr] == 0"
          IndexAccess
             Type: uint256
             Source: "versioned[addr]"
            Identifier versioned
               Type: mapping(address => uint256)
               Source: "versioned"
            Identifier addr
               Type: address
               Source: "addr"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            revert();\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "revert()"
            FunctionCall
               Type: tuple()
               Source: "revert()"
              Identifier revert
                 Type: function () pure
                 Source: "revert"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "notVersioned"
     Source: "modifier notVersioned(address addr) {\r\n        if (versioned[addr] > 0) {\r\n            revert();\r\n        }\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address addr)"
      VariableDeclaration "addr"
         Type: address
         Source: "address addr"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        if (versioned[addr] > 0) {\r\n            revert();\r\n        }\r\n        _;\r\n    }"
      IfStatement
         Source: "if (versioned[addr] > 0) {\r\n            revert();\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "versioned[addr] > 0"
          IndexAccess
             Type: uint256
             Source: "versioned[addr]"
            Identifier versioned
               Type: mapping(address => uint256)
               Source: "versioned"
            Identifier addr
               Type: address
               Source: "addr"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            revert();\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "revert()"
            FunctionCall
               Type: tuple()
               Source: "revert()"
              Identifier revert
                 Type: function () pure
                 Source: "revert"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  EventDefinition "VersionAdded"
     Gas costs: 0
     Source: "event VersionAdded(address indexed addr, uint version);"
    ParameterList
       Source: "(address indexed addr, uint version)"
      VariableDeclaration "addr"
         Type: address
         Source: "address indexed addr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "version"
         Type: uint256
         Source: "uint version"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "VersionRemoved"
     Gas costs: 0
     Source: "event VersionRemoved(address indexed addr, uint version);"
    ParameterList
       Source: "(address indexed addr, uint version)"
      VariableDeclaration "addr"
         Type: address
         Source: "address indexed addr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "version"
         Type: uint256
         Source: "uint version"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "addVersion" - public
     Source: "function addVersion(address addr)\r\n        onlyOwner\r\n        notVersioned(addr)\r\n    {\r\n        versioned[addr] = ++lastVersion;\r\n        versions.push(addr);\r\n        VersionAdded(addr, lastVersion);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address addr)"
      VariableDeclaration "addr"
         Type: address
         Source: "address addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "notVersioned"
       Gas costs: 0
       Source: "notVersioned(addr)"
      Identifier notVersioned
         Type: modifier (address)
         Source: "notVersioned"
      Identifier addr
         Type: address
         Source: "addr"
    Block
       Source: "{\r\n        versioned[addr] = ++lastVersion;\r\n        versions.push(addr);\r\n        VersionAdded(addr, lastVersion);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "versioned[addr] = ++lastVersion"
        Assignment using operator =
           Type: uint256
           Source: "versioned[addr] = ++lastVersion"
          IndexAccess
             Type: uint256
             Source: "versioned[addr]"
            Identifier versioned
               Type: mapping(address => uint256)
               Source: "versioned"
            Identifier addr
               Type: address
               Source: "addr"
          UnaryOperation (prefix) ++
             Type: uint256
             Source: "++lastVersion"
            Identifier lastVersion
               Type: uint256
               Source: "lastVersion"
      ExpressionStatement
         Gas costs: 0
         Source: "versions.push(addr)"
        FunctionCall
           Type: uint256
           Source: "versions.push(addr)"
          MemberAccess to member push
             Type: function (address) returns (uint256)
             Source: "versions.push"
            Identifier versions
               Type: address[] storage ref
               Source: "versions"
          Identifier addr
             Type: address
             Source: "addr"
      ExpressionStatement
         Gas costs: 0
         Source: "VersionAdded(addr, lastVersion)"
        FunctionCall
           Type: tuple()
           Source: "VersionAdded(addr, lastVersion)"
          Identifier VersionAdded
             Type: function (address,uint256)
             Source: "VersionAdded"
          Identifier addr
             Type: address
             Source: "addr"
          Identifier lastVersion
             Type: uint256
             Source: "lastVersion"
  FunctionDefinition "removeVersion" - public
     Source: "function removeVersion(address addr)\r\n        onlyOwner\r\n        isVersioned(addr)\r\n    {\r\n        require(versioned[addr] > 0);\r\n        uint version = versioned[addr];\r\n        delete versioned[addr];\r\n\r\n        uint length = versions.length;\r\n        for (uint i = 0; i < length; i++) {\r\n            if (versions[i] == addr) {\r\n                versions[i] = versions[length - 1];\r\n                versions.length -= 1;\r\n                break;\r\n            }\r\n        }\r\n        VersionRemoved(addr, version);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address addr)"
      VariableDeclaration "addr"
         Type: address
         Source: "address addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "isVersioned"
       Gas costs: 0
       Source: "isVersioned(addr)"
      Identifier isVersioned
         Type: modifier (address)
         Source: "isVersioned"
      Identifier addr
         Type: address
         Source: "addr"
    Block
       Source: "{\r\n        require(versioned[addr] > 0);\r\n        uint version = versioned[addr];\r\n        delete versioned[addr];\r\n\r\n        uint length = versions.length;\r\n        for (uint i = 0; i < length; i++) {\r\n            if (versions[i] == addr) {\r\n                versions[i] = versions[length - 1];\r\n                versions.length -= 1;\r\n                break;\r\n            }\r\n        }\r\n        VersionRemoved(addr, version);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(versioned[addr] > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(versioned[addr] > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "versioned[addr] > 0"
            IndexAccess
               Type: uint256
               Source: "versioned[addr]"
              Identifier versioned
                 Type: mapping(address => uint256)
                 Source: "versioned"
              Identifier addr
                 Type: address
                 Source: "addr"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint version = versioned[addr]"
        VariableDeclaration "version"
           Type: uint256
           Source: "uint version"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "versioned[addr]"
          Identifier versioned
             Type: mapping(address => uint256)
             Source: "versioned"
          Identifier addr
             Type: address
             Source: "addr"
      ExpressionStatement
         Gas costs: 0
         Source: "delete versioned[addr]"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete versioned[addr]"
          IndexAccess
             Type: uint256
             Source: "versioned[addr]"
            Identifier versioned
               Type: mapping(address => uint256)
               Source: "versioned"
            Identifier addr
               Type: address
               Source: "addr"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint length = versions.length"
        VariableDeclaration "length"
           Type: uint256
           Source: "uint length"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "versions.length"
          Identifier versions
             Type: address[] storage ref
             Source: "versions"
      ForStatement
         Source: "for (uint i = 0; i < length; i++) {\r\n            if (versions[i] == addr) {\r\n                versions[i] = versions[length - 1];\r\n                versions.length -= 1;\r\n                break;\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < length"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier length
             Type: uint256
             Source: "length"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (versions[i] == addr) {\r\n                versions[i] = versions[length - 1];\r\n                versions.length -= 1;\r\n                break;\r\n            }\r\n        }"
          IfStatement
             Source: "if (versions[i] == addr) {\r\n                versions[i] = versions[length - 1];\r\n                versions.length -= 1;\r\n                break;\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "versions[i] == addr"
              IndexAccess
                 Type: address
                 Source: "versions[i]"
                Identifier versions
                   Type: address[] storage ref
                   Source: "versions"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier addr
                 Type: address
                 Source: "addr"
            Block
               Source: "{\r\n                versions[i] = versions[length - 1];\r\n                versions.length -= 1;\r\n                break;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "versions[i] = versions[length - 1]"
                Assignment using operator =
                   Type: address
                   Source: "versions[i] = versions[length - 1]"
                  IndexAccess
                     Type: address
                     Source: "versions[i]"
                    Identifier versions
                       Type: address[] storage ref
                       Source: "versions"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  IndexAccess
                     Type: address
                     Source: "versions[length - 1]"
                    Identifier versions
                       Type: address[] storage ref
                       Source: "versions"
                    BinaryOperation using operator -
                       Type: uint256
                       Source: "length - 1"
                      Identifier length
                         Type: uint256
                         Source: "length"
                      Literal, token: [no token] value: 1
                         Type: int_const 1
                         Source: "1"
              ExpressionStatement
                 Gas costs: 0
                 Source: "versions.length -= 1"
                Assignment using operator -=
                   Type: uint256
                   Source: "versions.length -= 1"
                  MemberAccess to member length
                     Type: uint256
                     Source: "versions.length"
                    Identifier versions
                       Type: address[] storage ref
                       Source: "versions"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              Break
                 Gas costs: 0
                 Source: "break"
      ExpressionStatement
         Gas costs: 0
         Source: "VersionRemoved(addr, version)"
        FunctionCall
           Type: tuple()
           Source: "VersionRemoved(addr, version)"
          Identifier VersionRemoved
             Type: function (address,uint256)
             Source: "VersionRemoved"
          Identifier addr
             Type: address
             Source: "addr"
          Identifier version
             Type: uint256
             Source: "version"
  FunctionDefinition "getSpendable" - public - const
     Source: "function getSpendable(\r\n        address tokenAddress,\r\n        address _owner\r\n        )\r\n        isVersioned(msg.sender)\r\n        constant\r\n        returns (uint)\r\n    {\r\n\r\n        var token = ERC20(tokenAddress);\r\n        return token.allowance(\r\n            _owner,\r\n            address(this)\r\n        ).min256(\r\n            token.balanceOf(_owner)\r\n        );\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address tokenAddress,\r\n        address _owner\r\n        )"
      VariableDeclaration "tokenAddress"
         Type: address
         Source: "address tokenAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "isVersioned"
       Gas costs: 0
       Source: "isVersioned(msg.sender)"
      Identifier isVersioned
         Type: modifier (address)
         Source: "isVersioned"
      MemberAccess to member sender
         Type: address
         Source: "msg.sender"
        Identifier msg
           Type: msg
           Source: "msg"
    Block
       Source: "{\r\n\r\n        var token = ERC20(tokenAddress);\r\n        return token.allowance(\r\n            _owner,\r\n            address(this)\r\n        ).min256(\r\n            token.balanceOf(_owner)\r\n        );\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "var token = ERC20(tokenAddress)"
        VariableDeclaration "token"
           Type: contract ERC20
           Source: "var token"
        FunctionCall
           Type: contract ERC20
           Source: "ERC20(tokenAddress)"
          Identifier ERC20
             Type: type(contract ERC20)
             Source: "ERC20"
          Identifier tokenAddress
             Type: address
             Source: "tokenAddress"
      Return
         Gas costs: 0
         Source: "return token.allowance(\r\n            _owner,\r\n            address(this)\r\n        ).min256(\r\n            token.balanceOf(_owner)\r\n        )"
        FunctionCall
           Type: uint256
           Source: "token.allowance(\r\n            _owner,\r\n            address(this)\r\n        ).min256(\r\n            token.balanceOf(_owner)\r\n        )"
          MemberAccess to member min256
             Type: function (uint256,uint256) view returns (uint256)
             Source: "token.allowance(\r\n            _owner,\r\n            address(this)\r\n        ).min256"
            FunctionCall
               Type: uint256
               Source: "token.allowance(\r\n            _owner,\r\n            address(this)\r\n        )"
              MemberAccess to member allowance
                 Type: function (address,address) view external returns (uint256)
                 Source: "token.allowance"
                Identifier token
                   Type: contract ERC20
                   Source: "token"
              Identifier _owner
                 Type: address
                 Source: "_owner"
              FunctionCall
                 Type: address
                 Source: "address(this)"
                ElementaryTypeNameExpression address
                   Type: type(address)
                   Source: "address"
                Identifier this
                   Type: contract TokenTransferDelegate
                   Source: "this"
          FunctionCall
             Type: uint256
             Source: "token.balanceOf(_owner)"
            MemberAccess to member balanceOf
               Type: function (address) view external returns (uint256)
               Source: "token.balanceOf"
              Identifier token
                 Type: contract ERC20
                 Source: "token"
            Identifier _owner
               Type: address
               Source: "_owner"
  FunctionDefinition "transferToken" - public
     Source: "function transferToken(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint value)\r\n        isVersioned(msg.sender)\r\n        returns (bool)\r\n    {\r\n        if (from == to) {\r\n            return false;\r\n        } else {\r\n            return ERC20(token).transferFrom(from, to, value);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint value)"
      VariableDeclaration "token"
         Type: address
         Source: "address token"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "isVersioned"
       Gas costs: 0
       Source: "isVersioned(msg.sender)"
      Identifier isVersioned
         Type: modifier (address)
         Source: "isVersioned"
      MemberAccess to member sender
         Type: address
         Source: "msg.sender"
        Identifier msg
           Type: msg
           Source: "msg"
    Block
       Source: "{\r\n        if (from == to) {\r\n            return false;\r\n        } else {\r\n            return ERC20(token).transferFrom(from, to, value);\r\n        }\r\n    }"
      IfStatement
         Source: "if (from == to) {\r\n            return false;\r\n        } else {\r\n            return ERC20(token).transferFrom(from, to, value);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "from == to"
          Identifier from
             Type: address
             Source: "from"
          Identifier to
             Type: address
             Source: "to"
        Block
           Source: "{\r\n            return false;\r\n        }"
          Return
             Gas costs: 0
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
        Block
           Source: "{\r\n            return ERC20(token).transferFrom(from, to, value);\r\n        }"
          Return
             Gas costs: 0
             Source: "return ERC20(token).transferFrom(from, to, value)"
            FunctionCall
               Type: bool
               Source: "ERC20(token).transferFrom(from, to, value)"
              MemberAccess to member transferFrom
                 Type: function (address,address,uint256) external returns (bool)
                 Source: "ERC20(token).transferFrom"
                FunctionCall
                   Type: contract ERC20
                   Source: "ERC20(token)"
                  Identifier ERC20
                     Type: type(contract ERC20)
                     Source: "ERC20"
                  Identifier token
                     Type: address
                     Source: "token"
              Identifier from
                 Type: address
                 Source: "from"
              Identifier to
                 Type: address
                 Source: "to"
              Identifier value
                 Type: uint256
                 Source: "value"
  FunctionDefinition "getVersions" - public - const
     Source: "function getVersions()\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return versions;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address[])"
      VariableDeclaration ""
         Type: address[] memory
         Source: "address[]"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\r\n        return versions;\r\n    }"
      Return
         Gas costs: 0
         Source: "return versions"
        Identifier versions
           Type: address[] storage ref
           Source: "versions"
ContractDefinition "RinghashRegistry"
   Source: "contract RinghashRegistry {\r\n    using Bytes32Lib    for bytes32[];\r\n    using ErrorLib      for bool;\r\n    using Uint8Lib      for uint8[];\r\n\r\n    uint public blocksToLive;\r\n\r\n    struct Submission {\r\n        address ringminer;\r\n        uint block;\r\n    }\r\n\r\n    mapping (bytes32 => Submission) submissions;\r\n\r\n\r\n    /// Events\r\n\r\n    event RinghashSubmitted(\r\n        address indexed _ringminer,\r\n        bytes32 indexed _ringhash\r\n    );\r\n\r\n    /// Constructor\r\n\r\n    function RinghashRegistry(uint _blocksToLive)\r\n        public\r\n    {\r\n        require(_blocksToLive > 0);\r\n        blocksToLive = _blocksToLive;\r\n    }\r\n\r\n    /// Public Functions\r\n\r\n    function submitRinghash(\r\n        uint        ringSize,\r\n        address     ringminer,\r\n        uint8[]     vList,\r\n        bytes32[]   rList,\r\n        bytes32[]   sList)\r\n        public\r\n    {\r\n        bytes32 ringhash = calculateRinghash(\r\n            ringSize,\r\n            vList,\r\n            rList,\r\n            sList\r\n        );\r\n\r\n        ErrorLib.check(\r\n            canSubmit(ringhash, ringminer),\r\n            \"Ringhash submitted\"\r\n        );\r\n\r\n        submissions[ringhash] = Submission(ringminer, block.number);\r\n        RinghashSubmitted(ringminer, ringhash);\r\n    }\r\n\r\n    function canSubmit(\r\n        bytes32 ringhash,\r\n        address ringminer)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        var submission = submissions[ringhash];\r\n        return (\r\n            submission.ringminer == address(0) || (\r\n            submission.block + blocksToLive < block.number) || (\r\n            submission.ringminer == ringminer)\r\n        );\r\n    }\r\n\r\n    /// @return True if a ring's hash has ever been submitted; false otherwise.\r\n    function ringhashFound(bytes32 ringhash)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n\r\n        return submissions[ringhash].ringminer != address(0);\r\n    }\r\n\r\n    /// @dev Calculate the hash of a ring.\r\n    function calculateRinghash(\r\n        uint        ringSize,\r\n        uint8[]     vList,\r\n        bytes32[]   rList,\r\n        bytes32[]   sList)\r\n        public\r\n        constant\r\n        returns (bytes32)\r\n    {\r\n        ErrorLib.check(\r\n            ringSize == vList.length - 1 && (\r\n            ringSize == rList.length - 1) && (\r\n            ringSize == sList.length - 1),\r\n            \"invalid ring data\"\r\n        );\r\n\r\n        return keccak256(\r\n            vList.xorReduce(ringSize),\r\n            rList.xorReduce(ringSize),\r\n            sList.xorReduce(ringSize)\r\n        );\r\n    }\r\n}"
  UsingForDirective
     Gas costs: 0
     Source: "using Bytes32Lib    for bytes32[];"
    UserDefinedTypeName "Bytes32Lib"
       Source: "Bytes32Lib"
    ArrayTypeName
       Source: "bytes32[]"
      ElementaryTypeName bytes32
         Source: "bytes32"
  UsingForDirective
     Gas costs: 0
     Source: "using ErrorLib      for bool;"
    UserDefinedTypeName "ErrorLib"
       Source: "ErrorLib"
    ElementaryTypeName bool
       Source: "bool"
  UsingForDirective
     Gas costs: 0
     Source: "using Uint8Lib      for uint8[];"
    UserDefinedTypeName "Uint8Lib"
       Source: "Uint8Lib"
    ArrayTypeName
       Source: "uint8[]"
      ElementaryTypeName uint8
         Source: "uint8"
  VariableDeclaration "blocksToLive"
     Type: uint256
     Gas costs: 0
     Source: "uint public blocksToLive"
    ElementaryTypeName uint
       Source: "uint"
  StructDefinition "Submission"
     Gas costs: 0
     Source: "struct Submission {\r\n        address ringminer;\r\n        uint block;\r\n    }"
    VariableDeclaration "ringminer"
       Type: address
       Source: "address ringminer"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "block"
       Type: uint256
       Source: "uint block"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "submissions"
     Type: mapping(bytes32 => struct RinghashRegistry.Submission storage ref)
     Gas costs: 0
     Source: "mapping (bytes32 => Submission) submissions"
    Mapping
       Source: "mapping (bytes32 => Submission)"
      ElementaryTypeName bytes32
         Source: "bytes32"
      UserDefinedTypeName "Submission"
         Source: "Submission"
  EventDefinition "RinghashSubmitted"
     Gas costs: 0
     Source: "event RinghashSubmitted(\r\n        address indexed _ringminer,\r\n        bytes32 indexed _ringhash\r\n    );"
    ParameterList
       Source: "(\r\n        address indexed _ringminer,\r\n        bytes32 indexed _ringhash\r\n    )"
      VariableDeclaration "_ringminer"
         Type: address
         Source: "address indexed _ringminer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_ringhash"
         Type: bytes32
         Source: "bytes32 indexed _ringhash"
        ElementaryTypeName bytes32
           Source: "bytes32"
  FunctionDefinition "RinghashRegistry" - public
     Source: "function RinghashRegistry(uint _blocksToLive)\r\n        public\r\n    {\r\n        require(_blocksToLive > 0);\r\n        blocksToLive = _blocksToLive;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _blocksToLive)"
      VariableDeclaration "_blocksToLive"
         Type: uint256
         Source: "uint _blocksToLive"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(_blocksToLive > 0);\r\n        blocksToLive = _blocksToLive;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_blocksToLive > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_blocksToLive > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "_blocksToLive > 0"
            Identifier _blocksToLive
               Type: uint256
               Source: "_blocksToLive"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "blocksToLive = _blocksToLive"
        Assignment using operator =
           Type: uint256
           Source: "blocksToLive = _blocksToLive"
          Identifier blocksToLive
             Type: uint256
             Source: "blocksToLive"
          Identifier _blocksToLive
             Type: uint256
             Source: "_blocksToLive"
  FunctionDefinition "submitRinghash" - public
     Source: "function submitRinghash(\r\n        uint        ringSize,\r\n        address     ringminer,\r\n        uint8[]     vList,\r\n        bytes32[]   rList,\r\n        bytes32[]   sList)\r\n        public\r\n    {\r\n        bytes32 ringhash = calculateRinghash(\r\n            ringSize,\r\n            vList,\r\n            rList,\r\n            sList\r\n        );\r\n\r\n        ErrorLib.check(\r\n            canSubmit(ringhash, ringminer),\r\n            \"Ringhash submitted\"\r\n        );\r\n\r\n        submissions[ringhash] = Submission(ringminer, block.number);\r\n        RinghashSubmitted(ringminer, ringhash);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint        ringSize,\r\n        address     ringminer,\r\n        uint8[]     vList,\r\n        bytes32[]   rList,\r\n        bytes32[]   sList)"
      VariableDeclaration "ringSize"
         Type: uint256
         Source: "uint        ringSize"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "ringminer"
         Type: address
         Source: "address     ringminer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "vList"
         Type: uint8[] memory
         Source: "uint8[]     vList"
        ArrayTypeName
           Source: "uint8[]"
          ElementaryTypeName uint8
             Source: "uint8"
      VariableDeclaration "rList"
         Type: bytes32[] memory
         Source: "bytes32[]   rList"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclaration "sList"
         Type: bytes32[] memory
         Source: "bytes32[]   sList"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        bytes32 ringhash = calculateRinghash(\r\n            ringSize,\r\n            vList,\r\n            rList,\r\n            sList\r\n        );\r\n\r\n        ErrorLib.check(\r\n            canSubmit(ringhash, ringminer),\r\n            \"Ringhash submitted\"\r\n        );\r\n\r\n        submissions[ringhash] = Submission(ringminer, block.number);\r\n        RinghashSubmitted(ringminer, ringhash);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 ringhash = calculateRinghash(\r\n            ringSize,\r\n            vList,\r\n            rList,\r\n            sList\r\n        )"
        VariableDeclaration "ringhash"
           Type: bytes32
           Source: "bytes32 ringhash"
          ElementaryTypeName bytes32
             Source: "bytes32"
        FunctionCall
           Type: bytes32
           Source: "calculateRinghash(\r\n            ringSize,\r\n            vList,\r\n            rList,\r\n            sList\r\n        )"
          Identifier calculateRinghash
             Type: function (uint256,uint8[] memory,bytes32[] memory,bytes32[] memory) view returns (bytes32)
             Source: "calculateRinghash"
          Identifier ringSize
             Type: uint256
             Source: "ringSize"
          Identifier vList
             Type: uint8[] memory
             Source: "vList"
          Identifier rList
             Type: bytes32[] memory
             Source: "rList"
          Identifier sList
             Type: bytes32[] memory
             Source: "sList"
      ExpressionStatement
         Gas costs: 0
         Source: "ErrorLib.check(\r\n            canSubmit(ringhash, ringminer),\r\n            \"Ringhash submitted\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            canSubmit(ringhash, ringminer),\r\n            \"Ringhash submitted\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          FunctionCall
             Type: bool
             Source: "canSubmit(ringhash, ringminer)"
            Identifier canSubmit
               Type: function (bytes32,address) view returns (bool)
               Source: "canSubmit"
            Identifier ringhash
               Type: bytes32
               Source: "ringhash"
            Identifier ringminer
               Type: address
               Source: "ringminer"
          Literal, token: [no token] value: Ringhash submitted
             Type: literal_string "Ringhash submitted"
             Source: "\"Ringhash submitted\""
      ExpressionStatement
         Gas costs: 0
         Source: "submissions[ringhash] = Submission(ringminer, block.number)"
        Assignment using operator =
           Type: struct RinghashRegistry.Submission storage ref
           Source: "submissions[ringhash] = Submission(ringminer, block.number)"
          IndexAccess
             Type: struct RinghashRegistry.Submission storage ref
             Source: "submissions[ringhash]"
            Identifier submissions
               Type: mapping(bytes32 => struct RinghashRegistry.Submission storage ref)
               Source: "submissions"
            Identifier ringhash
               Type: bytes32
               Source: "ringhash"
          FunctionCall
             Type: struct RinghashRegistry.Submission memory
             Source: "Submission(ringminer, block.number)"
            Identifier Submission
               Type: type(struct RinghashRegistry.Submission storage pointer)
               Source: "Submission"
            Identifier ringminer
               Type: address
               Source: "ringminer"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
      ExpressionStatement
         Gas costs: 0
         Source: "RinghashSubmitted(ringminer, ringhash)"
        FunctionCall
           Type: tuple()
           Source: "RinghashSubmitted(ringminer, ringhash)"
          Identifier RinghashSubmitted
             Type: function (address,bytes32)
             Source: "RinghashSubmitted"
          Identifier ringminer
             Type: address
             Source: "ringminer"
          Identifier ringhash
             Type: bytes32
             Source: "ringhash"
  FunctionDefinition "canSubmit" - public - const
     Source: "function canSubmit(\r\n        bytes32 ringhash,\r\n        address ringminer)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        var submission = submissions[ringhash];\r\n        return (\r\n            submission.ringminer == address(0) || (\r\n            submission.block + blocksToLive < block.number) || (\r\n            submission.ringminer == ringminer)\r\n        );\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        bytes32 ringhash,\r\n        address ringminer)"
      VariableDeclaration "ringhash"
         Type: bytes32
         Source: "bytes32 ringhash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "ringminer"
         Type: address
         Source: "address ringminer"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        var submission = submissions[ringhash];\r\n        return (\r\n            submission.ringminer == address(0) || (\r\n            submission.block + blocksToLive < block.number) || (\r\n            submission.ringminer == ringminer)\r\n        );\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "var submission = submissions[ringhash]"
        VariableDeclaration "submission"
           Type: struct RinghashRegistry.Submission storage pointer
           Source: "var submission"
        IndexAccess
           Type: struct RinghashRegistry.Submission storage ref
           Source: "submissions[ringhash]"
          Identifier submissions
             Type: mapping(bytes32 => struct RinghashRegistry.Submission storage ref)
             Source: "submissions"
          Identifier ringhash
             Type: bytes32
             Source: "ringhash"
      Return
         Gas costs: 0
         Source: "return (\r\n            submission.ringminer == address(0) || (\r\n            submission.block + blocksToLive < block.number) || (\r\n            submission.ringminer == ringminer)\r\n        )"
        TupleExpression
           Type: bool
           Source: "(\r\n            submission.ringminer == address(0) || (\r\n            submission.block + blocksToLive < block.number) || (\r\n            submission.ringminer == ringminer)\r\n        )"
          BinaryOperation using operator ||
             Type: bool
             Source: "submission.ringminer == address(0) || (\r\n            submission.block + blocksToLive < block.number) || (\r\n            submission.ringminer == ringminer)"
            BinaryOperation using operator ||
               Type: bool
               Source: "submission.ringminer == address(0) || (\r\n            submission.block + blocksToLive < block.number)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "submission.ringminer == address(0)"
                MemberAccess to member ringminer
                   Type: address
                   Source: "submission.ringminer"
                  Identifier submission
                     Type: struct RinghashRegistry.Submission storage pointer
                     Source: "submission"
                FunctionCall
                   Type: address
                   Source: "address(0)"
                  ElementaryTypeNameExpression address
                     Type: type(address)
                     Source: "address"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              TupleExpression
                 Type: bool
                 Source: "(\r\n            submission.block + blocksToLive < block.number)"
                BinaryOperation using operator <
                   Type: bool
                   Source: "submission.block + blocksToLive < block.number"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "submission.block + blocksToLive"
                    MemberAccess to member block
                       Type: uint256
                       Source: "submission.block"
                      Identifier submission
                         Type: struct RinghashRegistry.Submission storage pointer
                         Source: "submission"
                    Identifier blocksToLive
                       Type: uint256
                       Source: "blocksToLive"
                  MemberAccess to member number
                     Type: uint256
                     Source: "block.number"
                    Identifier block
                       Type: block
                       Source: "block"
            TupleExpression
               Type: bool
               Source: "(\r\n            submission.ringminer == ringminer)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "submission.ringminer == ringminer"
                MemberAccess to member ringminer
                   Type: address
                   Source: "submission.ringminer"
                  Identifier submission
                     Type: struct RinghashRegistry.Submission storage pointer
                     Source: "submission"
                Identifier ringminer
                   Type: address
                   Source: "ringminer"
  FunctionDefinition "ringhashFound" - public - const
     Source: "function ringhashFound(bytes32 ringhash)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n\r\n        return submissions[ringhash].ringminer != address(0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 ringhash)"
      VariableDeclaration "ringhash"
         Type: bytes32
         Source: "bytes32 ringhash"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n        return submissions[ringhash].ringminer != address(0);\r\n    }"
      Return
         Gas costs: 0
         Source: "return submissions[ringhash].ringminer != address(0)"
        BinaryOperation using operator !=
           Type: bool
           Source: "submissions[ringhash].ringminer != address(0)"
          MemberAccess to member ringminer
             Type: address
             Source: "submissions[ringhash].ringminer"
            IndexAccess
               Type: struct RinghashRegistry.Submission storage ref
               Source: "submissions[ringhash]"
              Identifier submissions
                 Type: mapping(bytes32 => struct RinghashRegistry.Submission storage ref)
                 Source: "submissions"
              Identifier ringhash
                 Type: bytes32
                 Source: "ringhash"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "calculateRinghash" - public - const
     Source: "function calculateRinghash(\r\n        uint        ringSize,\r\n        uint8[]     vList,\r\n        bytes32[]   rList,\r\n        bytes32[]   sList)\r\n        public\r\n        constant\r\n        returns (bytes32)\r\n    {\r\n        ErrorLib.check(\r\n            ringSize == vList.length - 1 && (\r\n            ringSize == rList.length - 1) && (\r\n            ringSize == sList.length - 1),\r\n            \"invalid ring data\"\r\n        );\r\n\r\n        return keccak256(\r\n            vList.xorReduce(ringSize),\r\n            rList.xorReduce(ringSize),\r\n            sList.xorReduce(ringSize)\r\n        );\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint        ringSize,\r\n        uint8[]     vList,\r\n        bytes32[]   rList,\r\n        bytes32[]   sList)"
      VariableDeclaration "ringSize"
         Type: uint256
         Source: "uint        ringSize"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "vList"
         Type: uint8[] memory
         Source: "uint8[]     vList"
        ArrayTypeName
           Source: "uint8[]"
          ElementaryTypeName uint8
             Source: "uint8"
      VariableDeclaration "rList"
         Type: bytes32[] memory
         Source: "bytes32[]   rList"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclaration "sList"
         Type: bytes32[] memory
         Source: "bytes32[]   sList"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: "(bytes32)"
      VariableDeclaration ""
         Type: bytes32
         Source: "bytes32"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        ErrorLib.check(\r\n            ringSize == vList.length - 1 && (\r\n            ringSize == rList.length - 1) && (\r\n            ringSize == sList.length - 1),\r\n            \"invalid ring data\"\r\n        );\r\n\r\n        return keccak256(\r\n            vList.xorReduce(ringSize),\r\n            rList.xorReduce(ringSize),\r\n            sList.xorReduce(ringSize)\r\n        );\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "ErrorLib.check(\r\n            ringSize == vList.length - 1 && (\r\n            ringSize == rList.length - 1) && (\r\n            ringSize == sList.length - 1),\r\n            \"invalid ring data\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            ringSize == vList.length - 1 && (\r\n            ringSize == rList.length - 1) && (\r\n            ringSize == sList.length - 1),\r\n            \"invalid ring data\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator &&
             Type: bool
             Source: "ringSize == vList.length - 1 && (\r\n            ringSize == rList.length - 1) && (\r\n            ringSize == sList.length - 1)"
            BinaryOperation using operator &&
               Type: bool
               Source: "ringSize == vList.length - 1 && (\r\n            ringSize == rList.length - 1)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "ringSize == vList.length - 1"
                Identifier ringSize
                   Type: uint256
                   Source: "ringSize"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "vList.length - 1"
                  MemberAccess to member length
                     Type: uint256
                     Source: "vList.length"
                    Identifier vList
                       Type: uint8[] memory
                       Source: "vList"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              TupleExpression
                 Type: bool
                 Source: "(\r\n            ringSize == rList.length - 1)"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "ringSize == rList.length - 1"
                  Identifier ringSize
                     Type: uint256
                     Source: "ringSize"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "rList.length - 1"
                    MemberAccess to member length
                       Type: uint256
                       Source: "rList.length"
                      Identifier rList
                         Type: bytes32[] memory
                         Source: "rList"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
            TupleExpression
               Type: bool
               Source: "(\r\n            ringSize == sList.length - 1)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "ringSize == sList.length - 1"
                Identifier ringSize
                   Type: uint256
                   Source: "ringSize"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "sList.length - 1"
                  MemberAccess to member length
                     Type: uint256
                     Source: "sList.length"
                    Identifier sList
                       Type: bytes32[] memory
                       Source: "sList"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
          Literal, token: [no token] value: invalid ring data
             Type: literal_string "invalid ring data"
             Source: "\"invalid ring data\""
      Return
         Gas costs: 0
         Source: "return keccak256(\r\n            vList.xorReduce(ringSize),\r\n            rList.xorReduce(ringSize),\r\n            sList.xorReduce(ringSize)\r\n        )"
        FunctionCall
           Type: bytes32
           Source: "keccak256(\r\n            vList.xorReduce(ringSize),\r\n            rList.xorReduce(ringSize),\r\n            sList.xorReduce(ringSize)\r\n        )"
          Identifier keccak256
             Type: function () pure returns (bytes32)
             Source: "keccak256"
          FunctionCall
             Type: uint8
             Source: "vList.xorReduce(ringSize)"
            MemberAccess to member xorReduce
               Type: function (uint8[] memory,uint256) view returns (uint8)
               Source: "vList.xorReduce"
              Identifier vList
                 Type: uint8[] memory
                 Source: "vList"
            Identifier ringSize
               Type: uint256
               Source: "ringSize"
          FunctionCall
             Type: bytes32
             Source: "rList.xorReduce(ringSize)"
            MemberAccess to member xorReduce
               Type: function (bytes32[] memory,uint256) view returns (bytes32)
               Source: "rList.xorReduce"
              Identifier rList
                 Type: bytes32[] memory
                 Source: "rList"
            Identifier ringSize
               Type: uint256
               Source: "ringSize"
          FunctionCall
             Type: bytes32
             Source: "sList.xorReduce(ringSize)"
            MemberAccess to member xorReduce
               Type: function (bytes32[] memory,uint256) view returns (bytes32)
               Source: "sList.xorReduce"
              Identifier sList
                 Type: bytes32[] memory
                 Source: "sList"
            Identifier ringSize
               Type: uint256
               Source: "ringSize"
ContractDefinition "LoopringProtocol"
   Gas costs: [???]
   Source: "contract LoopringProtocol {\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Constants                                                            ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    uint    public constant FEE_SELECT_LRC               = 0;\r\n    uint    public constant FEE_SELECT_MARGIN_SPLIT      = 1;\r\n    uint    public constant FEE_SELECT_MAX_VALUE         = 1;\r\n\r\n    uint    public constant MARGIN_SPLIT_PERCENTAGE_BASE = 100;\r\n\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Structs                                                              ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n\r\n    /// @param tokenS       Token to sell.\r\n    /// @param tokenB       Token to buy.\r\n    /// @param amountS      Maximum amount of tokenS to sell.\r\n    /// @param amountB      Minimum amount of tokenB to buy if all amountS sold.\r\n    /// @param timestamp    Indicating whtn this order is created/signed.\r\n    /// @param ttl          Indicating after how many seconds from `timestamp`\r\n    ///                     this order will expire.\r\n    /// @param salt         A random number to make this order's hash unique.\r\n    /// @param lrcFee       Max amount of LRC to pay for miner. The real amount\r\n    ///                     to pay is proportional to fill amount.\r\n    /// @param buyNoMoreThanAmountB -\r\n    ///                     If true, this order does not accept buying more\r\n    ///                     than `amountB`.\r\n    /// @param marginSplitPercentage -\r\n    ///                     The percentage of margin paid to miner.\r\n    /// @param v            ECDSA signature parameter v.\r\n    /// @param r            ECDSA signature parameters r.\r\n    /// @param s            ECDSA signature parameters s.\r\n    struct Order {\r\n        address owner;\r\n        address tokenS;\r\n        address tokenB;\r\n        uint    amountS;\r\n        uint    amountB;\r\n        uint    timestamp;\r\n        uint    ttl;\r\n        uint    salt;\r\n        uint    lrcFee;\r\n        bool    buyNoMoreThanAmountB;\r\n        uint8   marginSplitPercentage;\r\n        uint8   v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Public Functions                                                     ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n\r\n    /// @dev Submit a order-ring for validation and settlement.\r\n    /// @param addressList  List of each order's owner and tokenS. Note that next\r\n    ///                     order's `tokenS` equals this order's `tokenB`.\r\n    /// @param uintArgsList List of uint-type arguments in this order:\r\n    ///                     amountS, AmountB, rateAmountS, timestamp, ttl, salt,\r\n    ///                     and lrcFee.\r\n    /// @param uint8ArgsList -\r\n    ///                     List of unit8-type arguments, in this order:\r\n    ///                     marginSplitPercentageList, feeSelectionList.\r\n    /// @param vList        List of v for each order. This list is 1-larger than\r\n    ///                     the previous lists, with the last element being the\r\n    ///                     v value of the ring signature.\r\n    /// @param rList        List of r for each order. This list is 1-larger than\r\n    ///                     the previous lists, with the last element being the\r\n    ///                     r value of the ring signature.\r\n    /// @param sList        List of s for each order. This list is 1-larger than\r\n    ///                     the previous lists, with the last element being the\r\n    ///                     s value of the ring signature.\r\n    /// @param ringminer    The address that signed this tx.\r\n    /// @param feeRecepient The recepient address for fee collection. If this is\r\n    ///                     '0x0', all fees will be paid to the address who had\r\n    ///                     signed this transaction, not `msg.sender`. Noted if\r\n    ///                     LRC need to be paid back to order owner as the result\r\n    ///                     of fee selection model, LRC will also be sent from\r\n    ///                     this address.\r\n    /// @param throwIfLRCIsInsuffcient -\r\n    ///                     If true, throw exception if any order's spendable\r\n    ///                     LRC amount is smaller than requried; if false, ring-\r\n    ///                     minor will give up collection the LRC fee.\r\n    function submitRing(\r\n        address[2][]    addressList,\r\n        uint[7][]       uintArgsList,\r\n        uint8[2][]      uint8ArgsList,\r\n        bool[]          buyNoMoreThanAmountBList,\r\n        uint8[]         vList,\r\n        bytes32[]       rList,\r\n        bytes32[]       sList,\r\n        address         ringminer,\r\n        address         feeRecepient,\r\n        bool            throwIfLRCIsInsuffcient\r\n        ) public;\r\n\r\n    /// @dev Cancel a order. cancel amount(amountS or amountB) can be specified\r\n    ///      in orderValues.\r\n    /// @param addresses          owner, tokenS, tokenB\r\n    /// @param orderValues        amountS, amountB, timestamp, ttl, salt, lrcFee,\r\n    ///                           cancelAmountS, and cancelAmountB.\r\n    /// @param marginSplitPercentage -\r\n    /// @param buyNoMoreThanAmountB -\r\n    /// @param v                  Order ECDSA signature parameter v.\r\n    /// @param r                  Order ECDSA signature parameters r.\r\n    /// @param s                  Order ECDSA signature parameters s.\r\n    function cancelOrder(\r\n        address[3] addresses,\r\n        uint[7]    orderValues,\r\n        bool       buyNoMoreThanAmountB,\r\n        uint8      marginSplitPercentage,\r\n        uint8      v,\r\n        bytes32    r,\r\n        bytes32    s\r\n        ) public;\r\n\r\n    /// @dev   Set a cutoff timestamp to invalidate all orders whose timestamp\r\n    ///        is smaller than or equal to the new value of the address's cutoff\r\n    ///        timestamp.\r\n    /// @param cutoff The cutoff timestamp, will default to `block.timestamp`\r\n    ///        if it is 0.\r\n    function setCutoff(uint cutoff) public;\r\n}"
  VariableDeclaration "FEE_SELECT_LRC"
     Type: uint256
     Source: "uint    public constant FEE_SELECT_LRC               = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "FEE_SELECT_MARGIN_SPLIT"
     Type: uint256
     Source: "uint    public constant FEE_SELECT_MARGIN_SPLIT      = 1"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1
       Type: int_const 1
       Source: "1"
  VariableDeclaration "FEE_SELECT_MAX_VALUE"
     Type: uint256
     Source: "uint    public constant FEE_SELECT_MAX_VALUE         = 1"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1
       Type: int_const 1
       Source: "1"
  VariableDeclaration "MARGIN_SPLIT_PERCENTAGE_BASE"
     Type: uint256
     Source: "uint    public constant MARGIN_SPLIT_PERCENTAGE_BASE = 100"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 100
       Type: int_const 100
       Source: "100"
  StructDefinition "Order"
     Source: "struct Order {\r\n        address owner;\r\n        address tokenS;\r\n        address tokenB;\r\n        uint    amountS;\r\n        uint    amountB;\r\n        uint    timestamp;\r\n        uint    ttl;\r\n        uint    salt;\r\n        uint    lrcFee;\r\n        bool    buyNoMoreThanAmountB;\r\n        uint8   marginSplitPercentage;\r\n        uint8   v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }"
    VariableDeclaration "owner"
       Type: address
       Source: "address owner"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "tokenS"
       Type: address
       Source: "address tokenS"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "tokenB"
       Type: address
       Source: "address tokenB"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "amountS"
       Type: uint256
       Source: "uint    amountS"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "amountB"
       Type: uint256
       Source: "uint    amountB"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "timestamp"
       Type: uint256
       Source: "uint    timestamp"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "ttl"
       Type: uint256
       Source: "uint    ttl"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "salt"
       Type: uint256
       Source: "uint    salt"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "lrcFee"
       Type: uint256
       Source: "uint    lrcFee"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "buyNoMoreThanAmountB"
       Type: bool
       Source: "bool    buyNoMoreThanAmountB"
      ElementaryTypeName bool
         Source: "bool"
    VariableDeclaration "marginSplitPercentage"
       Type: uint8
       Source: "uint8   marginSplitPercentage"
      ElementaryTypeName uint8
         Source: "uint8"
    VariableDeclaration "v"
       Type: uint8
       Source: "uint8   v"
      ElementaryTypeName uint8
         Source: "uint8"
    VariableDeclaration "r"
       Type: bytes32
       Source: "bytes32 r"
      ElementaryTypeName bytes32
         Source: "bytes32"
    VariableDeclaration "s"
       Type: bytes32
       Source: "bytes32 s"
      ElementaryTypeName bytes32
         Source: "bytes32"
  FunctionDefinition "submitRing" - public
     Source: "function submitRing(\r\n        address[2][]    addressList,\r\n        uint[7][]       uintArgsList,\r\n        uint8[2][]      uint8ArgsList,\r\n        bool[]          buyNoMoreThanAmountBList,\r\n        uint8[]         vList,\r\n        bytes32[]       rList,\r\n        bytes32[]       sList,\r\n        address         ringminer,\r\n        address         feeRecepient,\r\n        bool            throwIfLRCIsInsuffcient\r\n        ) public;"
    ParameterList
       Source: "(\r\n        address[2][]    addressList,\r\n        uint[7][]       uintArgsList,\r\n        uint8[2][]      uint8ArgsList,\r\n        bool[]          buyNoMoreThanAmountBList,\r\n        uint8[]         vList,\r\n        bytes32[]       rList,\r\n        bytes32[]       sList,\r\n        address         ringminer,\r\n        address         feeRecepient,\r\n        bool            throwIfLRCIsInsuffcient\r\n        )"
      VariableDeclaration "addressList"
         Type: address[2] memory[] memory
         Source: "address[2][]    addressList"
        ArrayTypeName
           Source: "address[2][]"
          ArrayTypeName
             Source: "address[2]"
            ElementaryTypeName address
               Source: "address"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
      VariableDeclaration "uintArgsList"
         Type: uint256[7] memory[] memory
         Source: "uint[7][]       uintArgsList"
        ArrayTypeName
           Source: "uint[7][]"
          ArrayTypeName
             Source: "uint[7]"
            ElementaryTypeName uint
               Source: "uint"
            Literal, token: [no token] value: 7
               Type unknown.
               Source: "7"
      VariableDeclaration "uint8ArgsList"
         Type: uint8[2] memory[] memory
         Source: "uint8[2][]      uint8ArgsList"
        ArrayTypeName
           Source: "uint8[2][]"
          ArrayTypeName
             Source: "uint8[2]"
            ElementaryTypeName uint8
               Source: "uint8"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
      VariableDeclaration "buyNoMoreThanAmountBList"
         Type: bool[] memory
         Source: "bool[]          buyNoMoreThanAmountBList"
        ArrayTypeName
           Source: "bool[]"
          ElementaryTypeName bool
             Source: "bool"
      VariableDeclaration "vList"
         Type: uint8[] memory
         Source: "uint8[]         vList"
        ArrayTypeName
           Source: "uint8[]"
          ElementaryTypeName uint8
             Source: "uint8"
      VariableDeclaration "rList"
         Type: bytes32[] memory
         Source: "bytes32[]       rList"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclaration "sList"
         Type: bytes32[] memory
         Source: "bytes32[]       sList"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclaration "ringminer"
         Type: address
         Source: "address         ringminer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "feeRecepient"
         Type: address
         Source: "address         feeRecepient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "throwIfLRCIsInsuffcient"
         Type: bool
         Source: "bool            throwIfLRCIsInsuffcient"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Source: ""
  FunctionDefinition "cancelOrder" - public
     Source: "function cancelOrder(\r\n        address[3] addresses,\r\n        uint[7]    orderValues,\r\n        bool       buyNoMoreThanAmountB,\r\n        uint8      marginSplitPercentage,\r\n        uint8      v,\r\n        bytes32    r,\r\n        bytes32    s\r\n        ) public;"
    ParameterList
       Source: "(\r\n        address[3] addresses,\r\n        uint[7]    orderValues,\r\n        bool       buyNoMoreThanAmountB,\r\n        uint8      marginSplitPercentage,\r\n        uint8      v,\r\n        bytes32    r,\r\n        bytes32    s\r\n        )"
      VariableDeclaration "addresses"
         Type: address[3] memory
         Source: "address[3] addresses"
        ArrayTypeName
           Source: "address[3]"
          ElementaryTypeName address
             Source: "address"
          Literal, token: [no token] value: 3
             Type unknown.
             Source: "3"
      VariableDeclaration "orderValues"
         Type: uint256[7] memory
         Source: "uint[7]    orderValues"
        ArrayTypeName
           Source: "uint[7]"
          ElementaryTypeName uint
             Source: "uint"
          Literal, token: [no token] value: 7
             Type unknown.
             Source: "7"
      VariableDeclaration "buyNoMoreThanAmountB"
         Type: bool
         Source: "bool       buyNoMoreThanAmountB"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "marginSplitPercentage"
         Type: uint8
         Source: "uint8      marginSplitPercentage"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "v"
         Type: uint8
         Source: "uint8      v"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "r"
         Type: bytes32
         Source: "bytes32    r"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "s"
         Type: bytes32
         Source: "bytes32    s"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Source: ""
  FunctionDefinition "setCutoff" - public
     Source: "function setCutoff(uint cutoff) public;"
    ParameterList
       Source: "(uint cutoff)"
      VariableDeclaration "cutoff"
         Type: uint256
         Source: "uint cutoff"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
ContractDefinition "LoopringProtocolImpl"
   Source: "contract LoopringProtocolImpl is LoopringProtocol {\r\n    using Math      for uint;\r\n    using SafeMath  for uint;\r\n    using UintLib   for uint;\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Variables                                                            ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n\r\n    address public  lrcTokenAddress             = address(0);\r\n    address public  tokenRegistryAddress        = address(0);\r\n    address public  ringhashRegistryAddress     = address(0);\r\n    address public  delegateAddress             = address(0);\r\n\r\n    uint    public  maxRingSize                 = 0;\r\n    uint    public  ringIndex                   = 0;\r\n    bool    private entered                     = false;\r\n\r\n    // Exchange rate (rate) is the amount to sell or sold divided by the amount\r\n    // to buy or bought.\r\n    //\r\n    // Rate ratio is the ratio between executed rate and an order's original\r\n    // rate.\r\n    //\r\n    // To require all orders' rate ratios to have coefficient ofvariation (CV)\r\n    // smaller than 2.5%, for an example , rateRatioCVSThreshold should be:\r\n    //     `(0.025 * RATE_RATIO_SCALE)^2` or 62500.\r\n    uint    public  rateRatioCVSThreshold       = 0;\r\n\r\n    uint    public constant RATE_RATIO_SCALE    = 10000;\r\n\r\n    // The following two maps are used to keep trace of order fill and\r\n    // cancellation history.\r\n    mapping (bytes32 => uint) public filled;\r\n    mapping (bytes32 => uint) public cancelled;\r\n\r\n    // A map from address to its cutoff timestamp.\r\n    mapping (address => uint) public cutoffs;\r\n\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Structs                                                              ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n\r\n    struct Rate {\r\n        uint amountS;\r\n        uint amountB;\r\n    }\r\n\r\n    /// @param order        The original order\r\n    /// @param orderHash    The order's hash\r\n    /// @param feeSelection -\r\n    ///                     A miner-supplied value indicating if LRC (value = 0)\r\n    ///                     or margin split is choosen by the miner (value = 1).\r\n    ///                     We may support more fee model in the future.\r\n    /// @param rate         Exchange rate provided by miner.\r\n    /// @param availableAmountS -\r\n    ///                     The actual spendable amountS.\r\n    /// @param fillAmountS  Amount of tokenS to sell, calculated by protocol.\r\n    /// @param lrcReward    The amount of LRC paid by miner to order owner in\r\n    ///                     exchange for margin split.\r\n    /// @param lrcFee       The amount of LR paid by order owner to miner.\r\n    /// @param splitS      TokenS paid to miner.\r\n    /// @param splitB      TokenB paid to miner.\r\n    struct OrderState {\r\n        Order   order;\r\n        bytes32 orderHash;\r\n        uint8   feeSelection;\r\n        Rate    rate;\r\n        uint    availableAmountS;\r\n        uint    fillAmountS;\r\n        uint    lrcReward;\r\n        uint    lrcFee;\r\n        uint    splitS;\r\n        uint    splitB;\r\n    }\r\n\r\n    struct Ring {\r\n        bytes32      ringhash;\r\n        OrderState[] orders;\r\n        address      miner;\r\n        address      feeRecepient;\r\n        bool         throwIfLRCIsInsuffcient;\r\n    }\r\n\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Events                                                               ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n\r\n    event RingMined(\r\n        uint                _ringIndex,\r\n        uint                _time,\r\n        uint                _blocknumber,\r\n        bytes32     indexed _ringhash,\r\n        address     indexed _miner,\r\n        address     indexed _feeRecepient,\r\n        bool                _ringhashFound);\r\n\r\n    event OrderFilled(\r\n        uint                _ringIndex,\r\n        uint                _time,\r\n        uint                _blocknumber,\r\n        bytes32     indexed _ringhash,\r\n        bytes32             _prevOrderHash,\r\n        bytes32     indexed _orderHash,\r\n        bytes32              _nextOrderHash,\r\n        uint                _amountS,\r\n        uint                _amountB,\r\n        uint                _lrcReward,\r\n        uint                _lrcFee);\r\n\r\n    event OrderCancelled(\r\n        uint                _time,\r\n        uint                _blocknumber,\r\n        bytes32     indexed _orderHash,\r\n        uint                _amountCancelled);\r\n\r\n    event CutoffTimestampChanged(\r\n        uint                _time,\r\n        uint                _blocknumber,\r\n        address     indexed _address,\r\n        uint                _cutoff);\r\n\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Constructor                                                          ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n\r\n    function LoopringProtocolImpl(\r\n        address _lrcTokenAddress,\r\n        address _tokenRegistryAddress,\r\n        address _ringhashRegistryAddress,\r\n        address _delegateAddress,\r\n        uint    _maxRingSize,\r\n        uint    _rateRatioCVSThreshold\r\n        )\r\n        public\r\n    {\r\n        require(address(0) != _lrcTokenAddress);\r\n        require(address(0) != _tokenRegistryAddress);\r\n        require(address(0) != _delegateAddress);\r\n\r\n        require(_maxRingSize > 1);\r\n        require(_rateRatioCVSThreshold > 0);\r\n\r\n        lrcTokenAddress = _lrcTokenAddress;\r\n        tokenRegistryAddress = _tokenRegistryAddress;\r\n        ringhashRegistryAddress = _ringhashRegistryAddress;\r\n        delegateAddress = _delegateAddress;\r\n        maxRingSize = _maxRingSize;\r\n        rateRatioCVSThreshold = _rateRatioCVSThreshold;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Public Functions                                                     ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n\r\n    /// @dev Disable default function.\r\n    function ()\r\n        payable\r\n    {\r\n        revert();\r\n    }\r\n\r\n    /// @dev Submit a order-ring for validation and settlement.\r\n    /// @param addressList  List of each order's tokenS. Note that next order's\r\n    ///                     `tokenS` equals this order's `tokenB`.\r\n    /// @param uintArgsList List of uint-type arguments in this order:\r\n    ///                     amountS, amountB, timestamp, ttl, salt, lrcFee,\r\n    ///                     rateAmountS.\r\n    /// @param uint8ArgsList -\r\n    ///                     List of unit8-type arguments, in this order:\r\n    ///                     marginSplitPercentageList,feeSelectionList.\r\n    /// @param vList        List of v for each order. This list is 1-larger than\r\n    ///                     the previous lists, with the last element being the\r\n    ///                     v value of the ring signature.\r\n    /// @param rList        List of r for each order. This list is 1-larger than\r\n    ///                     the previous lists, with the last element being the\r\n    ///                     r value of the ring signature.\r\n    /// @param sList        List of s for each order. This list is 1-larger than\r\n    ///                     the previous lists, with the last element being the\r\n    ///                     s value of the ring signature.\r\n    /// @param ringminer    The address that signed this tx.\r\n    /// @param feeRecepient The recepient address for fee collection. If this is\r\n    ///                     '0x0', all fees will be paid to the address who had\r\n    ///                     signed this transaction, not `msg.sender`. Noted if\r\n    ///                     LRC need to be paid back to order owner as the result\r\n    ///                     of fee selection model, LRC will also be sent from\r\n    ///                     this address.\r\n    /// @param throwIfLRCIsInsuffcient -\r\n    ///                     If true, throw exception if any order's spendable\r\n    ///                     LRC amount is smaller than requried; if false, ring-\r\n    ///                     minor will give up collection the LRC fee.\r\n    function submitRing(\r\n        address[2][]    addressList,\r\n        uint[7][]       uintArgsList,\r\n        uint8[2][]      uint8ArgsList,\r\n        bool[]          buyNoMoreThanAmountBList,\r\n        uint8[]         vList,\r\n        bytes32[]       rList,\r\n        bytes32[]       sList,\r\n        address         ringminer,\r\n        address         feeRecepient,\r\n        bool            throwIfLRCIsInsuffcient\r\n        )\r\n        public\r\n    {\r\n        ErrorLib.check(!entered, \"attempted to re-ent submitRing function\");\r\n        entered = true;\r\n\r\n        //Check ring size\r\n        uint ringSize = addressList.length;\r\n        ErrorLib.check(\r\n            ringSize > 1 && ringSize <= maxRingSize,\r\n            \"invalid ring size\"\r\n        );\r\n\r\n        verifyInputDataIntegrity(\r\n            ringSize,\r\n            addressList,\r\n            uintArgsList,\r\n            uint8ArgsList,\r\n            buyNoMoreThanAmountBList,\r\n            vList,\r\n            rList,\r\n            sList\r\n        );\r\n\r\n        verifyTokensRegistered(addressList);\r\n\r\n        var ringhashRegistry = RinghashRegistry(ringhashRegistryAddress);\r\n\r\n        bytes32 ringhash = ringhashRegistry.calculateRinghash(\r\n            ringSize,\r\n            vList,\r\n            rList,\r\n            sList\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringhashRegistry.canSubmit(ringhash, feeRecepient),\r\n            \"Ring claimed by others\"\r\n        );\r\n\r\n        verifySignature(\r\n            ringminer,\r\n            ringhash,\r\n            vList[ringSize],\r\n            rList[ringSize],\r\n            sList[ringSize]\r\n        );\r\n\r\n        //Assemble input data into a struct so we can pass it to functions.\r\n        var orders = assembleOrders(\r\n            ringSize,\r\n            addressList,\r\n            uintArgsList,\r\n            uint8ArgsList,\r\n            buyNoMoreThanAmountBList,\r\n            vList,\r\n            rList,\r\n            sList\r\n        );\r\n\r\n        if (feeRecepient == address(0)) {\r\n            feeRecepient = ringminer;\r\n        }\r\n\r\n        handleRing(\r\n            ringhash,\r\n            orders,\r\n            ringminer,\r\n            feeRecepient,\r\n            throwIfLRCIsInsuffcient\r\n        );\r\n\r\n        entered = false;\r\n    }\r\n\r\n    /// @dev Cancel a order. Amount (amountS or amountB) to cancel can be\r\n    ///                           specified using orderValues.\r\n    /// @param addresses          owner, tokenS, tokenB\r\n    /// @param orderValues        amountS, amountB, timestamp, ttl, salt,\r\n    ///                           lrcFee, and cancelAmount\r\n    /// @param buyNoMoreThanAmountB -\r\n    ///                           If true, this order does not accept buying\r\n    ///                           more than `amountB`.\r\n    /// @param marginSplitPercentage -\r\n    ///                           The percentage of margin paid to miner.\r\n    /// @param v                  Order ECDSA signature parameter v.\r\n    /// @param r                  Order ECDSA signature parameters r.\r\n    /// @param s                  Order ECDSA signature parameters s.\r\n\r\n    function cancelOrder(\r\n        address[3] addresses,\r\n        uint[7]    orderValues,\r\n        bool       buyNoMoreThanAmountB,\r\n        uint8      marginSplitPercentage,\r\n        uint8      v,\r\n        bytes32    r,\r\n        bytes32    s\r\n        )\r\n        public\r\n    {\r\n        uint cancelAmount = orderValues[6];\r\n        ErrorLib.check(cancelAmount > 0, \"amount to cancel is zero\");\r\n\r\n        var order = Order(\r\n            addresses[0],\r\n            addresses[1],\r\n            addresses[2],\r\n            orderValues[0],\r\n            orderValues[1],\r\n            orderValues[2],\r\n            orderValues[3],\r\n            orderValues[4],\r\n            orderValues[5],\r\n            buyNoMoreThanAmountB,\r\n            marginSplitPercentage,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n\r\n        ErrorLib.check(msg.sender == order.owner, \"cancelOrder not submitted by order owner\");\r\n\r\n        bytes32 orderHash = calculateOrderHash(order);\r\n\r\n        verifySignature(\r\n            order.owner,\r\n            orderHash,\r\n            order.v,\r\n            order.r,\r\n            order.s\r\n        );\r\n\r\n        cancelled[orderHash] = cancelled[orderHash].add(cancelAmount);\r\n\r\n        OrderCancelled(\r\n            block.timestamp,\r\n            block.number,\r\n            orderHash,\r\n            cancelAmount\r\n        );\r\n    }\r\n\r\n    /// @dev   Set a cutoff timestamp to invalidate all orders whose timestamp\r\n    ///        is smaller than or equal to the new value of the address's cutoff\r\n    ///        timestamp.\r\n    /// @param cutoff The cutoff timestamp, will default to `block.timestamp`\r\n    ///        if it is 0.\r\n    function setCutoff(uint cutoff)\r\n        public\r\n    {\r\n        uint t = cutoff;\r\n        if (t == 0) {\r\n            t = block.timestamp;\r\n        }\r\n\r\n        ErrorLib.check(\r\n            cutoffs[msg.sender] < t,\r\n            \"attempted to set cutoff to a smaller value\"\r\n        );\r\n\r\n        cutoffs[msg.sender] = t;\r\n\r\n        CutoffTimestampChanged(\r\n            block.timestamp,\r\n            block.number,\r\n            msg.sender,\r\n            t\r\n        );\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Internal & Private Functions                                         ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n\r\n    /// @dev Validate a ring.\r\n    function verifyRingHasNoSubRing(Ring ring)\r\n        internal\r\n        constant\r\n    {\r\n        uint ringSize = ring.orders.length;\r\n        // Check the ring has no sub-ring.\r\n        for (uint i = 0; i < ringSize - 1; i++) {\r\n            address tokenS = ring.orders[i].order.tokenS;\r\n            for (uint j = i + 1; j < ringSize; j++) {\r\n                ErrorLib.check(\r\n                    tokenS != ring.orders[j].order.tokenS,\r\n                    \"found sub-ring\"\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function verifyTokensRegistered(address[2][] addressList)\r\n        internal\r\n        constant\r\n    {\r\n        var registryContract = TokenRegistry(tokenRegistryAddress);\r\n        for (uint i = 0; i < addressList.length; i++) {\r\n            ErrorLib.check(\r\n                registryContract.isTokenRegistered(addressList[i][1]),\r\n                \"token not registered\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function handleRing(\r\n        bytes32 ringhash,\r\n        OrderState[] orders,\r\n        address miner,\r\n        address feeRecepient,\r\n        bool throwIfLRCIsInsuffcient\r\n        )\r\n        internal\r\n    {\r\n        var ring = Ring(\r\n            ringhash,\r\n            orders,\r\n            miner,\r\n            feeRecepient,\r\n            throwIfLRCIsInsuffcient\r\n        );\r\n\r\n        // Do the hard work.\r\n        verifyRingHasNoSubRing(ring);\r\n\r\n        // Exchange rates calculation are performed by ring-miners as solidity\r\n        // cannot get power-of-1/n operation, therefore we have to verify\r\n        // these rates are correct.\r\n        verifyMinerSuppliedFillRates(ring);\r\n\r\n        // Scale down each order independently by substracting amount-filled and\r\n        // amount-cancelled. Order owner's current balance and allowance are\r\n        // not taken into consideration in these operations.\r\n        scaleRingBasedOnHistoricalRecords(ring);\r\n\r\n        // Based on the already verified exchange rate provided by ring-miners,\r\n        // we can furthur scale down orders based on token balance and allowance,\r\n        // then find the smallest order of the ring, then calculate each order's\r\n        // `fillAmountS`.\r\n        calculateRingFillAmount(ring);\r\n\r\n        // Calculate each order's `lrcFee` and `lrcRewrard` and splict how much\r\n        // of `fillAmountS` shall be paid to matching order or miner as margin\r\n        // split.\r\n        calculateRingFees(ring);\r\n\r\n        /// Make payments.\r\n        settleRing(ring);\r\n\r\n        RingMined(\r\n            ringIndex++,\r\n            block.timestamp,\r\n            block.number,\r\n            ring.ringhash,\r\n            ring.miner,\r\n            ring.feeRecepient,\r\n            RinghashRegistry(ringhashRegistryAddress).ringhashFound(ring.ringhash)\r\n        );\r\n    }\r\n\r\n    function settleRing(Ring ring)\r\n        internal\r\n    {\r\n        uint ringSize = ring.orders.length;\r\n        var delegate = TokenTransferDelegate(delegateAddress);\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            var state = ring.orders[i];\r\n            var prev = ring.orders[i.prev(ringSize)];\r\n            var next = ring.orders[i.next(ringSize)];\r\n\r\n            // Pay tokenS to previous order, or to miner as previous order's\r\n            // margin split or/and this order's margin split.\r\n\r\n            delegate.transferToken(\r\n                state.order.tokenS,\r\n                state.order.owner,\r\n                prev.order.owner,\r\n                state.fillAmountS - prev.splitB\r\n            );\r\n\r\n            if (prev.splitB + state.splitS > 0) {\r\n                delegate.transferToken(\r\n                    state.order.tokenS,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    prev.splitB + state.splitS\r\n                );\r\n            }\r\n\r\n            // Pay LRC\r\n            if (state.lrcReward > 0) {\r\n                delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    ring.feeRecepient,\r\n                    state.order.owner,\r\n                    state.lrcReward\r\n                );\r\n            }\r\n\r\n            if (state.lrcFee > 0) {\r\n                delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    state.lrcFee\r\n                );\r\n            }\r\n\r\n            // Update fill records\r\n            if (state.order.buyNoMoreThanAmountB) {\r\n                filled[state.orderHash] += next.fillAmountS;\r\n            } else {\r\n                filled[state.orderHash] += state.fillAmountS;\r\n            }\r\n\r\n            OrderFilled(\r\n                ringIndex,\r\n                block.timestamp,\r\n                block.number,\r\n                ring.ringhash,\r\n                prev.orderHash,\r\n                state.orderHash,\r\n                next.orderHash,\r\n                state.fillAmountS + state.splitS,\r\n                next.fillAmountS - state.splitB,\r\n                state.lrcReward,\r\n                state.lrcFee\r\n            );\r\n        }\r\n\r\n    }\r\n\r\n    function verifyMinerSuppliedFillRates(Ring ring)\r\n        internal\r\n        constant\r\n    {\r\n        var orders = ring.orders;\r\n        uint ringSize = orders.length;\r\n        uint[] memory rateRatios = new uint[](ringSize);\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            uint s1b0 = orders[i].rate.amountS.mul(orders[i].order.amountB);\r\n            uint s0b1 = orders[i].order.amountS.mul(orders[i].rate.amountB);\r\n\r\n            ErrorLib.check(\r\n                s1b0 <= s0b1,\r\n                \"miner supplied exchange rate provides invalid discount\"\r\n            );\r\n\r\n            rateRatios[i] = RATE_RATIO_SCALE.mul(s1b0).div(s0b1);\r\n        }\r\n\r\n        uint cvs = UintLib.cvsquare(rateRatios, RATE_RATIO_SCALE);\r\n\r\n        ErrorLib.check(\r\n            cvs <= rateRatioCVSThreshold,\r\n            \"miner supplied exchange rate is not evenly discounted\"\r\n        );\r\n    }\r\n\r\n    function calculateRingFees(Ring ring)\r\n        internal\r\n        constant\r\n    {\r\n        uint minerLrcSpendable = getLRCSpendable(ring.feeRecepient);\r\n        uint ringSize = ring.orders.length;\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            var state = ring.orders[i];\r\n            var next = ring.orders[i.next(ringSize)];\r\n\r\n            if (state.feeSelection == FEE_SELECT_LRC) {\r\n\r\n                uint lrcSpendable = getLRCSpendable(state.order.owner);\r\n\r\n                if (lrcSpendable < state.lrcFee) {\r\n                    ErrorLib.check(\r\n                        !ring.throwIfLRCIsInsuffcient,\r\n                        \"order LRC balance insuffcient\"\r\n                    );\r\n\r\n                    state.lrcFee = lrcSpendable;\r\n                    minerLrcSpendable += lrcSpendable;\r\n                }\r\n\r\n            } else if (state.feeSelection == FEE_SELECT_MARGIN_SPLIT) {\r\n                if (minerLrcSpendable >= state.lrcFee) {\r\n                    if (state.order.buyNoMoreThanAmountB) {\r\n                        uint splitS = next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub(\r\n                            state.fillAmountS\r\n                        );\r\n\r\n                        state.splitS = splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    } else {\r\n                        uint splitB = next.fillAmountS.sub(state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)\r\n                        );\r\n\r\n                        state.splitB = splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    }\r\n\r\n                    // This implicits order with smaller index in the ring will\r\n                    // be paid LRC reward first, so the orders in the ring does\r\n                    // mater.\r\n                    if (state.splitS > 0 || state.splitB > 0) {\r\n                        minerLrcSpendable = minerLrcSpendable.sub(state.lrcFee);\r\n                        state.lrcReward = state.lrcFee;\r\n                    }\r\n                    state.lrcFee = 0;\r\n                }\r\n            } else {\r\n                ErrorLib.error(\"unsupported fee selection value\");\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function calculateRingFillAmount(Ring ring)\r\n        internal\r\n        constant\r\n    {\r\n        uint ringSize = ring.orders.length;\r\n        uint smallestIdx = 0;\r\n        uint i;\r\n        uint j;\r\n\r\n        for (i = 0; i < ringSize; i++) {\r\n            j = i.next(ringSize);\r\n\r\n            uint res = calculateOrderFillAmount(\r\n                ring.orders[i],\r\n                ring.orders[j]\r\n            );\r\n\r\n            if (res == 1) {\r\n                smallestIdx = i;\r\n            } else if (res == 2) {\r\n                smallestIdx = j;\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < smallestIdx; i++) {\r\n            j = i.next(ringSize);\r\n            calculateOrderFillAmount(\r\n                ring.orders[i],\r\n                ring.orders[j]\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @return 0 if neither order is the smallest one;\r\n    ///         1 if 'state' is the smallest order;\r\n    ///         2 if 'next' is the smallest order.\r\n    function calculateOrderFillAmount(\r\n        OrderState state,\r\n        OrderState next\r\n        )\r\n        internal\r\n        constant\r\n        returns (uint whichIsSmaller)\r\n    {\r\n        uint fillAmountB = state.fillAmountS.mul(\r\n            state.rate.amountB\r\n        ).div(\r\n            state.rate.amountS\r\n        );\r\n\r\n        if (state.order.buyNoMoreThanAmountB) {\r\n            if (fillAmountB > state.order.amountB) {\r\n                fillAmountB = state.order.amountB;\r\n\r\n                state.fillAmountS = fillAmountB.mul(\r\n                    state.rate.amountS\r\n                ).div(\r\n                    state.rate.amountB\r\n                );\r\n\r\n                whichIsSmaller = 1;\r\n            }\r\n        }\r\n\r\n        state.lrcFee = state.order.lrcFee.mul(\r\n            state.fillAmountS\r\n        ).div(\r\n            state.order.amountS\r\n        );\r\n\r\n        if (fillAmountB <= next.fillAmountS) {\r\n            next.fillAmountS = fillAmountB;\r\n        } else {\r\n            whichIsSmaller = 2;\r\n        }\r\n    }\r\n\r\n    /// @dev Scale down all orders based on historical fill or cancellation\r\n    ///      stats but key the order's original exchange rate.\r\n    function scaleRingBasedOnHistoricalRecords(Ring ring)\r\n        internal\r\n        constant\r\n    {\r\n        uint ringSize = ring.orders.length;\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            var state = ring.orders[i];\r\n            var order = state.order;\r\n\r\n            if (order.buyNoMoreThanAmountB) {\r\n                uint amountB = order.amountB.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                );\r\n\r\n                order.amountS = amountB.mul(order.amountS).div(order.amountB);\r\n                order.lrcFee = amountB.mul(order.lrcFee).div(order.amountB);\r\n\r\n                order.amountB = amountB;\r\n            } else {\r\n                uint amountS = order.amountS.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                );\r\n\r\n                order.amountB = amountS.mul(order.amountB).div(order.amountS);\r\n                order.lrcFee = amountS.mul(order.lrcFee).div(order.amountS);\r\n\r\n                order.amountS = amountS;\r\n            }\r\n\r\n            ErrorLib.check(order.amountS > 0, \"amountS is zero\");\r\n            ErrorLib.check(order.amountB > 0, \"amountB is zero\");\r\n\r\n            state.fillAmountS = order.amountS.min256(state.availableAmountS);\r\n        }\r\n    }\r\n\r\n    /// @return Amount of ERC20 token that can be spent by this contract.\r\n    function getSpendable(\r\n        address tokenAddress,\r\n        address tokenOwner\r\n        )\r\n        internal\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return TokenTransferDelegate(\r\n            delegateAddress\r\n        ).getSpendable(\r\n            tokenAddress,\r\n            tokenOwner\r\n        );\r\n    }\r\n\r\n    /// @return Amount of LRC token that can be spent by this contract.\r\n    function getLRCSpendable(address tokenOwner)\r\n        internal\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return getSpendable(lrcTokenAddress, tokenOwner);\r\n    }\r\n\r\n    /// @dev verify input data's basic integrity.\r\n    function verifyInputDataIntegrity(\r\n        uint ringSize,\r\n        address[2][]    addressList,\r\n        uint[7][]       uintArgsList,\r\n        uint8[2][]      uint8ArgsList,\r\n        bool[]          buyNoMoreThanAmountBList,\r\n        uint8[]         vList,\r\n        bytes32[]       rList,\r\n        bytes32[]       sList\r\n        )\r\n        internal\r\n        constant\r\n    {\r\n        ErrorLib.check(\r\n            ringSize == addressList.length,\r\n            \"ring data is inconsistent - addressList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize == uintArgsList.length,\r\n            \"ring data is inconsistent - uintArgsList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize == uint8ArgsList.length,\r\n            \"ring data is inconsistent - uint8ArgsList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize == buyNoMoreThanAmountBList.length,\r\n            \"ring data is inconsistent - buyNoMoreThanAmountBList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize + 1 == vList.length,\r\n            \"ring data is inconsistent - vList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize + 1 == rList.length,\r\n            \"ring data is inconsistent - rList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize + 1 == sList.length,\r\n            \"ring data is inconsistent - sList\"\r\n        );\r\n\r\n        // Validate ring-mining related arguments.\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            ErrorLib.check(\r\n                uintArgsList[i][6] > 0,\r\n                \"order rateAmountS is zero\"\r\n            );\r\n\r\n            ErrorLib.check(\r\n                uint8ArgsList[i][1] <= FEE_SELECT_MAX_VALUE,\r\n                \"invalid order fee selection\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev        assmble order parameters into Order struct.\r\n    /// @return     A list of orders.\r\n    function assembleOrders(\r\n        uint            ringSize,\r\n        address[2][]    addressList,\r\n        uint[7][]       uintArgsList,\r\n        uint8[2][]      uint8ArgsList,\r\n        bool[]          buyNoMoreThanAmountBList,\r\n        uint8[]         vList,\r\n        bytes32[]       rList,\r\n        bytes32[]       sList\r\n        )\r\n        internal\r\n        constant\r\n        returns (OrderState[])\r\n    {\r\n        var orders = new OrderState[](ringSize);\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            uint j = i.next(ringSize);\r\n\r\n            var order = Order(\r\n                addressList[i][0],\r\n                addressList[i][1],\r\n                addressList[j][1],\r\n                uintArgsList[i][0],\r\n                uintArgsList[i][1],\r\n                uintArgsList[i][2],\r\n                uintArgsList[i][3],\r\n                uintArgsList[i][4],\r\n                uintArgsList[i][5],\r\n                buyNoMoreThanAmountBList[i],\r\n                uint8ArgsList[i][0],\r\n                vList[i],\r\n                rList[i],\r\n                sList[i]\r\n            );\r\n\r\n            bytes32 orderHash = calculateOrderHash(order);\r\n\r\n            verifySignature(\r\n                order.owner,\r\n                orderHash,\r\n                order.v,\r\n                order.r,\r\n                order.s\r\n            );\r\n\r\n            validateOrder(order);\r\n\r\n            orders[i] = OrderState(\r\n                order,\r\n                orderHash,\r\n                uint8ArgsList[i][1],  // feeSelection\r\n                Rate(uintArgsList[i][6], order.amountB),\r\n                getSpendable(order.tokenS, order.owner),\r\n                0,   // fillAmountS\r\n                0,   // lrcReward\r\n                0,   // lrcFee\r\n                0,   // splitS\r\n                0    // splitB\r\n            );\r\n\r\n            ErrorLib.check(\r\n                orders[i].availableAmountS > 0,\r\n                \"order spendable amountS is zero\"\r\n            );\r\n        }\r\n\r\n        return orders;\r\n    }\r\n\r\n    /// @dev validate order's parameters are OK.\r\n    function validateOrder(Order order)\r\n        internal\r\n        constant\r\n    {\r\n        ErrorLib.check(\r\n            order.owner != address(0),\r\n            \"invalid order owner\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.tokenS != address(0),\r\n            \"invalid order tokenS\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.tokenB != address(0),\r\n            \"invalid order tokenB\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.amountS > 0,\r\n            \"invalid order amountS\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.amountB > 0,\r\n            \"invalid order amountB\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.timestamp <= block.timestamp,\r\n            \"order is too early to match\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.timestamp > cutoffs[order.owner],\r\n            \"order is cut off\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.ttl > 0,\r\n            \"order ttl is 0\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.timestamp + order.ttl > block.timestamp,\r\n            \"order is expired\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.salt > 0,\r\n            \"invalid order salt\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.marginSplitPercentage <= MARGIN_SPLIT_PERCENTAGE_BASE,\r\n            \"invalid order marginSplitPercentage\"\r\n        );\r\n    }\r\n\r\n    /// @dev Get the Keccak-256 hash of order with specified parameters.\r\n    function calculateOrderHash(Order order)\r\n        internal\r\n        constant\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            address(this),\r\n            order.owner,\r\n            order.tokenS,\r\n            order.tokenB,\r\n            order.amountS,\r\n            order.amountB,\r\n            order.timestamp,\r\n            order.ttl,\r\n            order.salt,\r\n            order.lrcFee,\r\n            order.buyNoMoreThanAmountB,\r\n            order.marginSplitPercentage\r\n        );\r\n    }\r\n\r\n    /// @dev Verify signer's signature.\r\n    function verifySignature(\r\n        address signer,\r\n        bytes32 hash,\r\n        uint8   v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        internal\r\n        constant\r\n    {\r\n        address addr = ecrecover(\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n\r\n        ErrorLib.check(signer == addr, \"invalid signature\");\r\n    }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "LoopringProtocol"
    UserDefinedTypeName "LoopringProtocol"
       Source: "LoopringProtocol"
  UsingForDirective
     Gas costs: 0
     Source: "using Math      for uint;"
    UserDefinedTypeName "Math"
       Source: "Math"
    ElementaryTypeName uint
       Source: "uint"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath  for uint;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint
       Source: "uint"
  UsingForDirective
     Gas costs: 0
     Source: "using UintLib   for uint;"
    UserDefinedTypeName "UintLib"
       Source: "UintLib"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "lrcTokenAddress"
     Type: address
     Gas costs: [???]
     Source: "address public  lrcTokenAddress             = address(0)"
    ElementaryTypeName address
       Source: "address"
    FunctionCall
       Type: address
       Source: "address(0)"
      ElementaryTypeNameExpression address
         Type: type(address)
         Source: "address"
      Literal, token: [no token] value: 0
         Type: int_const 0
         Source: "0"
  VariableDeclaration "tokenRegistryAddress"
     Type: address
     Gas costs: [???]
     Source: "address public  tokenRegistryAddress        = address(0)"
    ElementaryTypeName address
       Source: "address"
    FunctionCall
       Type: address
       Source: "address(0)"
      ElementaryTypeNameExpression address
         Type: type(address)
         Source: "address"
      Literal, token: [no token] value: 0
         Type: int_const 0
         Source: "0"
  VariableDeclaration "ringhashRegistryAddress"
     Type: address
     Gas costs: [???]
     Source: "address public  ringhashRegistryAddress     = address(0)"
    ElementaryTypeName address
       Source: "address"
    FunctionCall
       Type: address
       Source: "address(0)"
      ElementaryTypeNameExpression address
         Type: type(address)
         Source: "address"
      Literal, token: [no token] value: 0
         Type: int_const 0
         Source: "0"
  VariableDeclaration "delegateAddress"
     Type: address
     Gas costs: [???]
     Source: "address public  delegateAddress             = address(0)"
    ElementaryTypeName address
       Source: "address"
    FunctionCall
       Type: address
       Source: "address(0)"
      ElementaryTypeNameExpression address
         Type: type(address)
         Source: "address"
      Literal, token: [no token] value: 0
         Type: int_const 0
         Source: "0"
  VariableDeclaration "maxRingSize"
     Type: uint256
     Gas costs: [???]
     Source: "uint    public  maxRingSize                 = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "ringIndex"
     Type: uint256
     Gas costs: [???]
     Source: "uint    public  ringIndex                   = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "entered"
     Type: bool
     Gas costs: 0
     Source: "bool    private entered                     = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "rateRatioCVSThreshold"
     Type: uint256
     Gas costs: [???]
     Source: "uint    public  rateRatioCVSThreshold       = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "RATE_RATIO_SCALE"
     Type: uint256
     Gas costs: [???]
     Source: "uint    public constant RATE_RATIO_SCALE    = 10000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 10000
       Type: int_const 10000
       Source: "10000"
  VariableDeclaration "filled"
     Type: mapping(bytes32 => uint256)
     Gas costs: [???]
     Source: "mapping (bytes32 => uint) public filled"
    Mapping
       Source: "mapping (bytes32 => uint)"
      ElementaryTypeName bytes32
         Source: "bytes32"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "cancelled"
     Type: mapping(bytes32 => uint256)
     Gas costs: [???]
     Source: "mapping (bytes32 => uint) public cancelled"
    Mapping
       Source: "mapping (bytes32 => uint)"
      ElementaryTypeName bytes32
         Source: "bytes32"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "cutoffs"
     Type: mapping(address => uint256)
     Gas costs: [???]
     Source: "mapping (address => uint) public cutoffs"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  StructDefinition "Rate"
     Gas costs: 0
     Source: "struct Rate {\r\n        uint amountS;\r\n        uint amountB;\r\n    }"
    VariableDeclaration "amountS"
       Type: uint256
       Source: "uint amountS"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "amountB"
       Type: uint256
       Source: "uint amountB"
      ElementaryTypeName uint
         Source: "uint"
  StructDefinition "OrderState"
     Gas costs: 0
     Source: "struct OrderState {\r\n        Order   order;\r\n        bytes32 orderHash;\r\n        uint8   feeSelection;\r\n        Rate    rate;\r\n        uint    availableAmountS;\r\n        uint    fillAmountS;\r\n        uint    lrcReward;\r\n        uint    lrcFee;\r\n        uint    splitS;\r\n        uint    splitB;\r\n    }"
    VariableDeclaration "order"
       Type: struct LoopringProtocol.Order storage pointer
       Source: "Order   order"
      UserDefinedTypeName "Order"
         Source: "Order"
    VariableDeclaration "orderHash"
       Type: bytes32
       Source: "bytes32 orderHash"
      ElementaryTypeName bytes32
         Source: "bytes32"
    VariableDeclaration "feeSelection"
       Type: uint8
       Source: "uint8   feeSelection"
      ElementaryTypeName uint8
         Source: "uint8"
    VariableDeclaration "rate"
       Type: struct LoopringProtocolImpl.Rate storage pointer
       Source: "Rate    rate"
      UserDefinedTypeName "Rate"
         Source: "Rate"
    VariableDeclaration "availableAmountS"
       Type: uint256
       Source: "uint    availableAmountS"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "fillAmountS"
       Type: uint256
       Source: "uint    fillAmountS"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "lrcReward"
       Type: uint256
       Source: "uint    lrcReward"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "lrcFee"
       Type: uint256
       Source: "uint    lrcFee"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "splitS"
       Type: uint256
       Source: "uint    splitS"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "splitB"
       Type: uint256
       Source: "uint    splitB"
      ElementaryTypeName uint
         Source: "uint"
  StructDefinition "Ring"
     Gas costs: 0
     Source: "struct Ring {\r\n        bytes32      ringhash;\r\n        OrderState[] orders;\r\n        address      miner;\r\n        address      feeRecepient;\r\n        bool         throwIfLRCIsInsuffcient;\r\n    }"
    VariableDeclaration "ringhash"
       Type: bytes32
       Source: "bytes32      ringhash"
      ElementaryTypeName bytes32
         Source: "bytes32"
    VariableDeclaration "orders"
       Type: struct LoopringProtocolImpl.OrderState storage ref[] storage pointer
       Source: "OrderState[] orders"
      ArrayTypeName
         Source: "OrderState[]"
        UserDefinedTypeName "OrderState"
           Source: "OrderState"
    VariableDeclaration "miner"
       Type: address
       Source: "address      miner"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "feeRecepient"
       Type: address
       Source: "address      feeRecepient"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "throwIfLRCIsInsuffcient"
       Type: bool
       Source: "bool         throwIfLRCIsInsuffcient"
      ElementaryTypeName bool
         Source: "bool"
  EventDefinition "RingMined"
     Gas costs: 0
     Source: "event RingMined(\r\n        uint                _ringIndex,\r\n        uint                _time,\r\n        uint                _blocknumber,\r\n        bytes32     indexed _ringhash,\r\n        address     indexed _miner,\r\n        address     indexed _feeRecepient,\r\n        bool                _ringhashFound);"
    ParameterList
       Source: "(\r\n        uint                _ringIndex,\r\n        uint                _time,\r\n        uint                _blocknumber,\r\n        bytes32     indexed _ringhash,\r\n        address     indexed _miner,\r\n        address     indexed _feeRecepient,\r\n        bool                _ringhashFound)"
      VariableDeclaration "_ringIndex"
         Type: uint256
         Source: "uint                _ringIndex"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_time"
         Type: uint256
         Source: "uint                _time"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_blocknumber"
         Type: uint256
         Source: "uint                _blocknumber"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_ringhash"
         Type: bytes32
         Source: "bytes32     indexed _ringhash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_miner"
         Type: address
         Source: "address     indexed _miner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_feeRecepient"
         Type: address
         Source: "address     indexed _feeRecepient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_ringhashFound"
         Type: bool
         Source: "bool                _ringhashFound"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "OrderFilled"
     Gas costs: 0
     Source: "event OrderFilled(\r\n        uint                _ringIndex,\r\n        uint                _time,\r\n        uint                _blocknumber,\r\n        bytes32     indexed _ringhash,\r\n        bytes32             _prevOrderHash,\r\n        bytes32     indexed _orderHash,\r\n        bytes32              _nextOrderHash,\r\n        uint                _amountS,\r\n        uint                _amountB,\r\n        uint                _lrcReward,\r\n        uint                _lrcFee);"
    ParameterList
       Source: "(\r\n        uint                _ringIndex,\r\n        uint                _time,\r\n        uint                _blocknumber,\r\n        bytes32     indexed _ringhash,\r\n        bytes32             _prevOrderHash,\r\n        bytes32     indexed _orderHash,\r\n        bytes32              _nextOrderHash,\r\n        uint                _amountS,\r\n        uint                _amountB,\r\n        uint                _lrcReward,\r\n        uint                _lrcFee)"
      VariableDeclaration "_ringIndex"
         Type: uint256
         Source: "uint                _ringIndex"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_time"
         Type: uint256
         Source: "uint                _time"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_blocknumber"
         Type: uint256
         Source: "uint                _blocknumber"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_ringhash"
         Type: bytes32
         Source: "bytes32     indexed _ringhash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_prevOrderHash"
         Type: bytes32
         Source: "bytes32             _prevOrderHash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_orderHash"
         Type: bytes32
         Source: "bytes32     indexed _orderHash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_nextOrderHash"
         Type: bytes32
         Source: "bytes32              _nextOrderHash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_amountS"
         Type: uint256
         Source: "uint                _amountS"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_amountB"
         Type: uint256
         Source: "uint                _amountB"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_lrcReward"
         Type: uint256
         Source: "uint                _lrcReward"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_lrcFee"
         Type: uint256
         Source: "uint                _lrcFee"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "OrderCancelled"
     Gas costs: 0
     Source: "event OrderCancelled(\r\n        uint                _time,\r\n        uint                _blocknumber,\r\n        bytes32     indexed _orderHash,\r\n        uint                _amountCancelled);"
    ParameterList
       Source: "(\r\n        uint                _time,\r\n        uint                _blocknumber,\r\n        bytes32     indexed _orderHash,\r\n        uint                _amountCancelled)"
      VariableDeclaration "_time"
         Type: uint256
         Source: "uint                _time"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_blocknumber"
         Type: uint256
         Source: "uint                _blocknumber"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_orderHash"
         Type: bytes32
         Source: "bytes32     indexed _orderHash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_amountCancelled"
         Type: uint256
         Source: "uint                _amountCancelled"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "CutoffTimestampChanged"
     Gas costs: 0
     Source: "event CutoffTimestampChanged(\r\n        uint                _time,\r\n        uint                _blocknumber,\r\n        address     indexed _address,\r\n        uint                _cutoff);"
    ParameterList
       Source: "(\r\n        uint                _time,\r\n        uint                _blocknumber,\r\n        address     indexed _address,\r\n        uint                _cutoff)"
      VariableDeclaration "_time"
         Type: uint256
         Source: "uint                _time"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_blocknumber"
         Type: uint256
         Source: "uint                _blocknumber"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_address"
         Type: address
         Source: "address     indexed _address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_cutoff"
         Type: uint256
         Source: "uint                _cutoff"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "LoopringProtocolImpl" - public
     Source: "function LoopringProtocolImpl(\r\n        address _lrcTokenAddress,\r\n        address _tokenRegistryAddress,\r\n        address _ringhashRegistryAddress,\r\n        address _delegateAddress,\r\n        uint    _maxRingSize,\r\n        uint    _rateRatioCVSThreshold\r\n        )\r\n        public\r\n    {\r\n        require(address(0) != _lrcTokenAddress);\r\n        require(address(0) != _tokenRegistryAddress);\r\n        require(address(0) != _delegateAddress);\r\n\r\n        require(_maxRingSize > 1);\r\n        require(_rateRatioCVSThreshold > 0);\r\n\r\n        lrcTokenAddress = _lrcTokenAddress;\r\n        tokenRegistryAddress = _tokenRegistryAddress;\r\n        ringhashRegistryAddress = _ringhashRegistryAddress;\r\n        delegateAddress = _delegateAddress;\r\n        maxRingSize = _maxRingSize;\r\n        rateRatioCVSThreshold = _rateRatioCVSThreshold;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _lrcTokenAddress,\r\n        address _tokenRegistryAddress,\r\n        address _ringhashRegistryAddress,\r\n        address _delegateAddress,\r\n        uint    _maxRingSize,\r\n        uint    _rateRatioCVSThreshold\r\n        )"
      VariableDeclaration "_lrcTokenAddress"
         Type: address
         Source: "address _lrcTokenAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokenRegistryAddress"
         Type: address
         Source: "address _tokenRegistryAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_ringhashRegistryAddress"
         Type: address
         Source: "address _ringhashRegistryAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_delegateAddress"
         Type: address
         Source: "address _delegateAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_maxRingSize"
         Type: uint256
         Source: "uint    _maxRingSize"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_rateRatioCVSThreshold"
         Type: uint256
         Source: "uint    _rateRatioCVSThreshold"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(address(0) != _lrcTokenAddress);\r\n        require(address(0) != _tokenRegistryAddress);\r\n        require(address(0) != _delegateAddress);\r\n\r\n        require(_maxRingSize > 1);\r\n        require(_rateRatioCVSThreshold > 0);\r\n\r\n        lrcTokenAddress = _lrcTokenAddress;\r\n        tokenRegistryAddress = _tokenRegistryAddress;\r\n        ringhashRegistryAddress = _ringhashRegistryAddress;\r\n        delegateAddress = _delegateAddress;\r\n        maxRingSize = _maxRingSize;\r\n        rateRatioCVSThreshold = _rateRatioCVSThreshold;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(address(0) != _lrcTokenAddress)"
        FunctionCall
           Type: tuple()
           Source: "require(address(0) != _lrcTokenAddress)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "address(0) != _lrcTokenAddress"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Identifier _lrcTokenAddress
               Type: address
               Source: "_lrcTokenAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "require(address(0) != _tokenRegistryAddress)"
        FunctionCall
           Type: tuple()
           Source: "require(address(0) != _tokenRegistryAddress)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "address(0) != _tokenRegistryAddress"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Identifier _tokenRegistryAddress
               Type: address
               Source: "_tokenRegistryAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "require(address(0) != _delegateAddress)"
        FunctionCall
           Type: tuple()
           Source: "require(address(0) != _delegateAddress)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "address(0) != _delegateAddress"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Identifier _delegateAddress
               Type: address
               Source: "_delegateAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_maxRingSize > 1)"
        FunctionCall
           Type: tuple()
           Source: "require(_maxRingSize > 1)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "_maxRingSize > 1"
            Identifier _maxRingSize
               Type: uint256
               Source: "_maxRingSize"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_rateRatioCVSThreshold > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_rateRatioCVSThreshold > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "_rateRatioCVSThreshold > 0"
            Identifier _rateRatioCVSThreshold
               Type: uint256
               Source: "_rateRatioCVSThreshold"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "lrcTokenAddress = _lrcTokenAddress"
        Assignment using operator =
           Type: address
           Source: "lrcTokenAddress = _lrcTokenAddress"
          Identifier lrcTokenAddress
             Type: address
             Source: "lrcTokenAddress"
          Identifier _lrcTokenAddress
             Type: address
             Source: "_lrcTokenAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenRegistryAddress = _tokenRegistryAddress"
        Assignment using operator =
           Type: address
           Source: "tokenRegistryAddress = _tokenRegistryAddress"
          Identifier tokenRegistryAddress
             Type: address
             Source: "tokenRegistryAddress"
          Identifier _tokenRegistryAddress
             Type: address
             Source: "_tokenRegistryAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "ringhashRegistryAddress = _ringhashRegistryAddress"
        Assignment using operator =
           Type: address
           Source: "ringhashRegistryAddress = _ringhashRegistryAddress"
          Identifier ringhashRegistryAddress
             Type: address
             Source: "ringhashRegistryAddress"
          Identifier _ringhashRegistryAddress
             Type: address
             Source: "_ringhashRegistryAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "delegateAddress = _delegateAddress"
        Assignment using operator =
           Type: address
           Source: "delegateAddress = _delegateAddress"
          Identifier delegateAddress
             Type: address
             Source: "delegateAddress"
          Identifier _delegateAddress
             Type: address
             Source: "_delegateAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "maxRingSize = _maxRingSize"
        Assignment using operator =
           Type: uint256
           Source: "maxRingSize = _maxRingSize"
          Identifier maxRingSize
             Type: uint256
             Source: "maxRingSize"
          Identifier _maxRingSize
             Type: uint256
             Source: "_maxRingSize"
      ExpressionStatement
         Gas costs: 0
         Source: "rateRatioCVSThreshold = _rateRatioCVSThreshold"
        Assignment using operator =
           Type: uint256
           Source: "rateRatioCVSThreshold = _rateRatioCVSThreshold"
          Identifier rateRatioCVSThreshold
             Type: uint256
             Source: "rateRatioCVSThreshold"
          Identifier _rateRatioCVSThreshold
             Type: uint256
             Source: "_rateRatioCVSThreshold"
  FunctionDefinition "" - public
     Source: "function ()\r\n        payable\r\n    {\r\n        revert();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        revert();\r\n    }"
      ExpressionStatement
         Gas costs: 6
         Source: "revert()"
        FunctionCall
           Type: tuple()
           Source: "revert()"
          Identifier revert
             Type: function () pure
             Source: "revert"
  FunctionDefinition "submitRing" - public
     Source: "function submitRing(\r\n        address[2][]    addressList,\r\n        uint[7][]       uintArgsList,\r\n        uint8[2][]      uint8ArgsList,\r\n        bool[]          buyNoMoreThanAmountBList,\r\n        uint8[]         vList,\r\n        bytes32[]       rList,\r\n        bytes32[]       sList,\r\n        address         ringminer,\r\n        address         feeRecepient,\r\n        bool            throwIfLRCIsInsuffcient\r\n        )\r\n        public\r\n    {\r\n        ErrorLib.check(!entered, \"attempted to re-ent submitRing function\");\r\n        entered = true;\r\n\r\n        //Check ring size\r\n        uint ringSize = addressList.length;\r\n        ErrorLib.check(\r\n            ringSize > 1 && ringSize <= maxRingSize,\r\n            \"invalid ring size\"\r\n        );\r\n\r\n        verifyInputDataIntegrity(\r\n            ringSize,\r\n            addressList,\r\n            uintArgsList,\r\n            uint8ArgsList,\r\n            buyNoMoreThanAmountBList,\r\n            vList,\r\n            rList,\r\n            sList\r\n        );\r\n\r\n        verifyTokensRegistered(addressList);\r\n\r\n        var ringhashRegistry = RinghashRegistry(ringhashRegistryAddress);\r\n\r\n        bytes32 ringhash = ringhashRegistry.calculateRinghash(\r\n            ringSize,\r\n            vList,\r\n            rList,\r\n            sList\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringhashRegistry.canSubmit(ringhash, feeRecepient),\r\n            \"Ring claimed by others\"\r\n        );\r\n\r\n        verifySignature(\r\n            ringminer,\r\n            ringhash,\r\n            vList[ringSize],\r\n            rList[ringSize],\r\n            sList[ringSize]\r\n        );\r\n\r\n        //Assemble input data into a struct so we can pass it to functions.\r\n        var orders = assembleOrders(\r\n            ringSize,\r\n            addressList,\r\n            uintArgsList,\r\n            uint8ArgsList,\r\n            buyNoMoreThanAmountBList,\r\n            vList,\r\n            rList,\r\n            sList\r\n        );\r\n\r\n        if (feeRecepient == address(0)) {\r\n            feeRecepient = ringminer;\r\n        }\r\n\r\n        handleRing(\r\n            ringhash,\r\n            orders,\r\n            ringminer,\r\n            feeRecepient,\r\n            throwIfLRCIsInsuffcient\r\n        );\r\n\r\n        entered = false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address[2][]    addressList,\r\n        uint[7][]       uintArgsList,\r\n        uint8[2][]      uint8ArgsList,\r\n        bool[]          buyNoMoreThanAmountBList,\r\n        uint8[]         vList,\r\n        bytes32[]       rList,\r\n        bytes32[]       sList,\r\n        address         ringminer,\r\n        address         feeRecepient,\r\n        bool            throwIfLRCIsInsuffcient\r\n        )"
      VariableDeclaration "addressList"
         Type: address[2] memory[] memory
         Source: "address[2][]    addressList"
        ArrayTypeName
           Source: "address[2][]"
          ArrayTypeName
             Source: "address[2]"
            ElementaryTypeName address
               Source: "address"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
      VariableDeclaration "uintArgsList"
         Type: uint256[7] memory[] memory
         Source: "uint[7][]       uintArgsList"
        ArrayTypeName
           Source: "uint[7][]"
          ArrayTypeName
             Source: "uint[7]"
            ElementaryTypeName uint
               Source: "uint"
            Literal, token: [no token] value: 7
               Type unknown.
               Source: "7"
      VariableDeclaration "uint8ArgsList"
         Type: uint8[2] memory[] memory
         Source: "uint8[2][]      uint8ArgsList"
        ArrayTypeName
           Source: "uint8[2][]"
          ArrayTypeName
             Source: "uint8[2]"
            ElementaryTypeName uint8
               Source: "uint8"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
      VariableDeclaration "buyNoMoreThanAmountBList"
         Type: bool[] memory
         Source: "bool[]          buyNoMoreThanAmountBList"
        ArrayTypeName
           Source: "bool[]"
          ElementaryTypeName bool
             Source: "bool"
      VariableDeclaration "vList"
         Type: uint8[] memory
         Source: "uint8[]         vList"
        ArrayTypeName
           Source: "uint8[]"
          ElementaryTypeName uint8
             Source: "uint8"
      VariableDeclaration "rList"
         Type: bytes32[] memory
         Source: "bytes32[]       rList"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclaration "sList"
         Type: bytes32[] memory
         Source: "bytes32[]       sList"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclaration "ringminer"
         Type: address
         Source: "address         ringminer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "feeRecepient"
         Type: address
         Source: "address         feeRecepient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "throwIfLRCIsInsuffcient"
         Type: bool
         Source: "bool            throwIfLRCIsInsuffcient"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        ErrorLib.check(!entered, \"attempted to re-ent submitRing function\");\r\n        entered = true;\r\n\r\n        //Check ring size\r\n        uint ringSize = addressList.length;\r\n        ErrorLib.check(\r\n            ringSize > 1 && ringSize <= maxRingSize,\r\n            \"invalid ring size\"\r\n        );\r\n\r\n        verifyInputDataIntegrity(\r\n            ringSize,\r\n            addressList,\r\n            uintArgsList,\r\n            uint8ArgsList,\r\n            buyNoMoreThanAmountBList,\r\n            vList,\r\n            rList,\r\n            sList\r\n        );\r\n\r\n        verifyTokensRegistered(addressList);\r\n\r\n        var ringhashRegistry = RinghashRegistry(ringhashRegistryAddress);\r\n\r\n        bytes32 ringhash = ringhashRegistry.calculateRinghash(\r\n            ringSize,\r\n            vList,\r\n            rList,\r\n            sList\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringhashRegistry.canSubmit(ringhash, feeRecepient),\r\n            \"Ring claimed by others\"\r\n        );\r\n\r\n        verifySignature(\r\n            ringminer,\r\n            ringhash,\r\n            vList[ringSize],\r\n            rList[ringSize],\r\n            sList[ringSize]\r\n        );\r\n\r\n        //Assemble input data into a struct so we can pass it to functions.\r\n        var orders = assembleOrders(\r\n            ringSize,\r\n            addressList,\r\n            uintArgsList,\r\n            uint8ArgsList,\r\n            buyNoMoreThanAmountBList,\r\n            vList,\r\n            rList,\r\n            sList\r\n        );\r\n\r\n        if (feeRecepient == address(0)) {\r\n            feeRecepient = ringminer;\r\n        }\r\n\r\n        handleRing(\r\n            ringhash,\r\n            orders,\r\n            ringminer,\r\n            feeRecepient,\r\n            throwIfLRCIsInsuffcient\r\n        );\r\n\r\n        entered = false;\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(!entered, \"attempted to re-ent submitRing function\")"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(!entered, \"attempted to re-ent submitRing function\")"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!entered"
            Identifier entered
               Type: bool
               Source: "entered"
          Literal, token: [no token] value: attempted to re-ent submitRing function
             Type: literal_string "attempted to re-ent submitRing function"
             Source: "\"attempted to re-ent submitRing function\""
      ExpressionStatement
         Gas costs: 20267
         Source: "entered = true"
        Assignment using operator =
           Type: bool
           Source: "entered = true"
          Identifier entered
             Type: bool
             Source: "entered"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint ringSize = addressList.length"
        VariableDeclaration "ringSize"
           Type: uint256
           Source: "uint ringSize"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "addressList.length"
          Identifier addressList
             Type: address[2] memory[] memory
             Source: "addressList"
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            ringSize > 1 && ringSize <= maxRingSize,\r\n            \"invalid ring size\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            ringSize > 1 && ringSize <= maxRingSize,\r\n            \"invalid ring size\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator &&
             Type: bool
             Source: "ringSize > 1 && ringSize <= maxRingSize"
            BinaryOperation using operator >
               Type: bool
               Source: "ringSize > 1"
              Identifier ringSize
                 Type: uint256
                 Source: "ringSize"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            BinaryOperation using operator <=
               Type: bool
               Source: "ringSize <= maxRingSize"
              Identifier ringSize
                 Type: uint256
                 Source: "ringSize"
              Identifier maxRingSize
                 Type: uint256
                 Source: "maxRingSize"
          Literal, token: [no token] value: invalid ring size
             Type: literal_string "invalid ring size"
             Source: "\"invalid ring size\""
      ExpressionStatement
         Gas costs: 28
         Source: "verifyInputDataIntegrity(\r\n            ringSize,\r\n            addressList,\r\n            uintArgsList,\r\n            uint8ArgsList,\r\n            buyNoMoreThanAmountBList,\r\n            vList,\r\n            rList,\r\n            sList\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "verifyInputDataIntegrity(\r\n            ringSize,\r\n            addressList,\r\n            uintArgsList,\r\n            uint8ArgsList,\r\n            buyNoMoreThanAmountBList,\r\n            vList,\r\n            rList,\r\n            sList\r\n        )"
          Identifier verifyInputDataIntegrity
             Type: function (uint256,address[2] memory[] memory,uint256[7] memory[] memory,uint8[2] memory[] memory,bool[] memory,uint8[] memory,bytes32[] memory,bytes32[] memory) view
             Source: "verifyInputDataIntegrity"
          Identifier ringSize
             Type: uint256
             Source: "ringSize"
          Identifier addressList
             Type: address[2] memory[] memory
             Source: "addressList"
          Identifier uintArgsList
             Type: uint256[7] memory[] memory
             Source: "uintArgsList"
          Identifier uint8ArgsList
             Type: uint8[2] memory[] memory
             Source: "uint8ArgsList"
          Identifier buyNoMoreThanAmountBList
             Type: bool[] memory
             Source: "buyNoMoreThanAmountBList"
          Identifier vList
             Type: uint8[] memory
             Source: "vList"
          Identifier rList
             Type: bytes32[] memory
             Source: "rList"
          Identifier sList
             Type: bytes32[] memory
             Source: "sList"
      ExpressionStatement
         Gas costs: 7
         Source: "verifyTokensRegistered(addressList)"
        FunctionCall
           Type: tuple()
           Source: "verifyTokensRegistered(addressList)"
          Identifier verifyTokensRegistered
             Type: function (address[2] memory[] memory) view
             Source: "verifyTokensRegistered"
          Identifier addressList
             Type: address[2] memory[] memory
             Source: "addressList"
      VariableDeclarationStatement
         Gas costs: 247
         Source: "var ringhashRegistry = RinghashRegistry(ringhashRegistryAddress)"
        VariableDeclaration "ringhashRegistry"
           Type: contract RinghashRegistry
           Source: "var ringhashRegistry"
        FunctionCall
           Type: contract RinghashRegistry
           Source: "RinghashRegistry(ringhashRegistryAddress)"
          Identifier RinghashRegistry
             Type: type(contract RinghashRegistry)
             Source: "RinghashRegistry"
          Identifier ringhashRegistryAddress
             Type: address
             Source: "ringhashRegistryAddress"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "bytes32 ringhash = ringhashRegistry.calculateRinghash(\r\n            ringSize,\r\n            vList,\r\n            rList,\r\n            sList\r\n        )"
        VariableDeclaration "ringhash"
           Type: bytes32
           Source: "bytes32 ringhash"
          ElementaryTypeName bytes32
             Source: "bytes32"
        FunctionCall
           Type: bytes32
           Source: "ringhashRegistry.calculateRinghash(\r\n            ringSize,\r\n            vList,\r\n            rList,\r\n            sList\r\n        )"
          MemberAccess to member calculateRinghash
             Type: function (uint256,uint8[] memory,bytes32[] memory,bytes32[] memory) view external returns (bytes32)
             Source: "ringhashRegistry.calculateRinghash"
            Identifier ringhashRegistry
               Type: contract RinghashRegistry
               Source: "ringhashRegistry"
          Identifier ringSize
             Type: uint256
             Source: "ringSize"
          Identifier vList
             Type: uint8[] memory
             Source: "vList"
          Identifier rList
             Type: bytes32[] memory
             Source: "rList"
          Identifier sList
             Type: bytes32[] memory
             Source: "sList"
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            ringhashRegistry.canSubmit(ringhash, feeRecepient),\r\n            \"Ring claimed by others\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            ringhashRegistry.canSubmit(ringhash, feeRecepient),\r\n            \"Ring claimed by others\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          FunctionCall
             Type: bool
             Source: "ringhashRegistry.canSubmit(ringhash, feeRecepient)"
            MemberAccess to member canSubmit
               Type: function (bytes32,address) view external returns (bool)
               Source: "ringhashRegistry.canSubmit"
              Identifier ringhashRegistry
                 Type: contract RinghashRegistry
                 Source: "ringhashRegistry"
            Identifier ringhash
               Type: bytes32
               Source: "ringhash"
            Identifier feeRecepient
               Type: address
               Source: "feeRecepient"
          Literal, token: [no token] value: Ring claimed by others
             Type: literal_string "Ring claimed by others"
             Source: "\"Ring claimed by others\""
      ExpressionStatement
         Gas costs: [???]
         Source: "verifySignature(\r\n            ringminer,\r\n            ringhash,\r\n            vList[ringSize],\r\n            rList[ringSize],\r\n            sList[ringSize]\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "verifySignature(\r\n            ringminer,\r\n            ringhash,\r\n            vList[ringSize],\r\n            rList[ringSize],\r\n            sList[ringSize]\r\n        )"
          Identifier verifySignature
             Type: function (address,bytes32,uint8,bytes32,bytes32) view
             Source: "verifySignature"
          Identifier ringminer
             Type: address
             Source: "ringminer"
          Identifier ringhash
             Type: bytes32
             Source: "ringhash"
          IndexAccess
             Type: uint8
             Source: "vList[ringSize]"
            Identifier vList
               Type: uint8[] memory
               Source: "vList"
            Identifier ringSize
               Type: uint256
               Source: "ringSize"
          IndexAccess
             Type: bytes32
             Source: "rList[ringSize]"
            Identifier rList
               Type: bytes32[] memory
               Source: "rList"
            Identifier ringSize
               Type: uint256
               Source: "ringSize"
          IndexAccess
             Type: bytes32
             Source: "sList[ringSize]"
            Identifier sList
               Type: bytes32[] memory
               Source: "sList"
            Identifier ringSize
               Type: uint256
               Source: "ringSize"
      VariableDeclarationStatement
         Gas costs: 36
         Source: "var orders = assembleOrders(\r\n            ringSize,\r\n            addressList,\r\n            uintArgsList,\r\n            uint8ArgsList,\r\n            buyNoMoreThanAmountBList,\r\n            vList,\r\n            rList,\r\n            sList\r\n        )"
        VariableDeclaration "orders"
           Type: struct LoopringProtocolImpl.OrderState memory[] memory
           Source: "var orders"
        FunctionCall
           Type: struct LoopringProtocolImpl.OrderState memory[] memory
           Source: "assembleOrders(\r\n            ringSize,\r\n            addressList,\r\n            uintArgsList,\r\n            uint8ArgsList,\r\n            buyNoMoreThanAmountBList,\r\n            vList,\r\n            rList,\r\n            sList\r\n        )"
          Identifier assembleOrders
             Type: function (uint256,address[2] memory[] memory,uint256[7] memory[] memory,uint8[2] memory[] memory,bool[] memory,uint8[] memory,bytes32[] memory,bytes32[] memory) view returns (struct LoopringProtocolImpl.OrderState memory[] memory)
             Source: "assembleOrders"
          Identifier ringSize
             Type: uint256
             Source: "ringSize"
          Identifier addressList
             Type: address[2] memory[] memory
             Source: "addressList"
          Identifier uintArgsList
             Type: uint256[7] memory[] memory
             Source: "uintArgsList"
          Identifier uint8ArgsList
             Type: uint8[2] memory[] memory
             Source: "uint8ArgsList"
          Identifier buyNoMoreThanAmountBList
             Type: bool[] memory
             Source: "buyNoMoreThanAmountBList"
          Identifier vList
             Type: uint8[] memory
             Source: "vList"
          Identifier rList
             Type: bytes32[] memory
             Source: "rList"
          Identifier sList
             Type: bytes32[] memory
             Source: "sList"
      IfStatement
         Source: "if (feeRecepient == address(0)) {\r\n            feeRecepient = ringminer;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 21
           Source: "feeRecepient == address(0)"
          Identifier feeRecepient
             Type: address
             Source: "feeRecepient"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            feeRecepient = ringminer;\r\n        }"
          ExpressionStatement
             Gas costs: 8
             Source: "feeRecepient = ringminer"
            Assignment using operator =
               Type: address
               Source: "feeRecepient = ringminer"
              Identifier feeRecepient
                 Type: address
                 Source: "feeRecepient"
              Identifier ringminer
                 Type: address
                 Source: "ringminer"
      ExpressionStatement
         Gas costs: 19
         Source: "handleRing(\r\n            ringhash,\r\n            orders,\r\n            ringminer,\r\n            feeRecepient,\r\n            throwIfLRCIsInsuffcient\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "handleRing(\r\n            ringhash,\r\n            orders,\r\n            ringminer,\r\n            feeRecepient,\r\n            throwIfLRCIsInsuffcient\r\n        )"
          Identifier handleRing
             Type: function (bytes32,struct LoopringProtocolImpl.OrderState memory[] memory,address,address,bool)
             Source: "handleRing"
          Identifier ringhash
             Type: bytes32
             Source: "ringhash"
          Identifier orders
             Type: struct LoopringProtocolImpl.OrderState memory[] memory
             Source: "orders"
          Identifier ringminer
             Type: address
             Source: "ringminer"
          Identifier feeRecepient
             Type: address
             Source: "feeRecepient"
          Identifier throwIfLRCIsInsuffcient
             Type: bool
             Source: "throwIfLRCIsInsuffcient"
      ExpressionStatement
         Gas costs: 20267
         Source: "entered = false"
        Assignment using operator =
           Type: bool
           Source: "entered = false"
          Identifier entered
             Type: bool
             Source: "entered"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "cancelOrder" - public
     Source: "function cancelOrder(\r\n        address[3] addresses,\r\n        uint[7]    orderValues,\r\n        bool       buyNoMoreThanAmountB,\r\n        uint8      marginSplitPercentage,\r\n        uint8      v,\r\n        bytes32    r,\r\n        bytes32    s\r\n        )\r\n        public\r\n    {\r\n        uint cancelAmount = orderValues[6];\r\n        ErrorLib.check(cancelAmount > 0, \"amount to cancel is zero\");\r\n\r\n        var order = Order(\r\n            addresses[0],\r\n            addresses[1],\r\n            addresses[2],\r\n            orderValues[0],\r\n            orderValues[1],\r\n            orderValues[2],\r\n            orderValues[3],\r\n            orderValues[4],\r\n            orderValues[5],\r\n            buyNoMoreThanAmountB,\r\n            marginSplitPercentage,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n\r\n        ErrorLib.check(msg.sender == order.owner, \"cancelOrder not submitted by order owner\");\r\n\r\n        bytes32 orderHash = calculateOrderHash(order);\r\n\r\n        verifySignature(\r\n            order.owner,\r\n            orderHash,\r\n            order.v,\r\n            order.r,\r\n            order.s\r\n        );\r\n\r\n        cancelled[orderHash] = cancelled[orderHash].add(cancelAmount);\r\n\r\n        OrderCancelled(\r\n            block.timestamp,\r\n            block.number,\r\n            orderHash,\r\n            cancelAmount\r\n        );\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address[3] addresses,\r\n        uint[7]    orderValues,\r\n        bool       buyNoMoreThanAmountB,\r\n        uint8      marginSplitPercentage,\r\n        uint8      v,\r\n        bytes32    r,\r\n        bytes32    s\r\n        )"
      VariableDeclaration "addresses"
         Type: address[3] memory
         Source: "address[3] addresses"
        ArrayTypeName
           Source: "address[3]"
          ElementaryTypeName address
             Source: "address"
          Literal, token: [no token] value: 3
             Type unknown.
             Source: "3"
      VariableDeclaration "orderValues"
         Type: uint256[7] memory
         Source: "uint[7]    orderValues"
        ArrayTypeName
           Source: "uint[7]"
          ElementaryTypeName uint
             Source: "uint"
          Literal, token: [no token] value: 7
             Type unknown.
             Source: "7"
      VariableDeclaration "buyNoMoreThanAmountB"
         Type: bool
         Source: "bool       buyNoMoreThanAmountB"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "marginSplitPercentage"
         Type: uint8
         Source: "uint8      marginSplitPercentage"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "v"
         Type: uint8
         Source: "uint8      v"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "r"
         Type: bytes32
         Source: "bytes32    r"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "s"
         Type: bytes32
         Source: "bytes32    s"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint cancelAmount = orderValues[6];\r\n        ErrorLib.check(cancelAmount > 0, \"amount to cancel is zero\");\r\n\r\n        var order = Order(\r\n            addresses[0],\r\n            addresses[1],\r\n            addresses[2],\r\n            orderValues[0],\r\n            orderValues[1],\r\n            orderValues[2],\r\n            orderValues[3],\r\n            orderValues[4],\r\n            orderValues[5],\r\n            buyNoMoreThanAmountB,\r\n            marginSplitPercentage,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n\r\n        ErrorLib.check(msg.sender == order.owner, \"cancelOrder not submitted by order owner\");\r\n\r\n        bytes32 orderHash = calculateOrderHash(order);\r\n\r\n        verifySignature(\r\n            order.owner,\r\n            orderHash,\r\n            order.v,\r\n            order.r,\r\n            order.s\r\n        );\r\n\r\n        cancelled[orderHash] = cancelled[orderHash].add(cancelAmount);\r\n\r\n        OrderCancelled(\r\n            block.timestamp,\r\n            block.number,\r\n            orderHash,\r\n            cancelAmount\r\n        );\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint cancelAmount = orderValues[6]"
        VariableDeclaration "cancelAmount"
           Type: uint256
           Source: "uint cancelAmount"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "orderValues[6]"
          Identifier orderValues
             Type: uint256[7] memory
             Source: "orderValues"
          Literal, token: [no token] value: 6
             Type: int_const 6
             Source: "6"
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(cancelAmount > 0, \"amount to cancel is zero\")"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(cancelAmount > 0, \"amount to cancel is zero\")"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator >
             Type: bool
             Source: "cancelAmount > 0"
            Identifier cancelAmount
               Type: uint256
               Source: "cancelAmount"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: amount to cancel is zero
             Type: literal_string "amount to cancel is zero"
             Source: "\"amount to cancel is zero\""
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "var order = Order(\r\n            addresses[0],\r\n            addresses[1],\r\n            addresses[2],\r\n            orderValues[0],\r\n            orderValues[1],\r\n            orderValues[2],\r\n            orderValues[3],\r\n            orderValues[4],\r\n            orderValues[5],\r\n            buyNoMoreThanAmountB,\r\n            marginSplitPercentage,\r\n            v,\r\n            r,\r\n            s\r\n        )"
        VariableDeclaration "order"
           Type: struct LoopringProtocol.Order memory
           Source: "var order"
        FunctionCall
           Type: struct LoopringProtocol.Order memory
           Source: "Order(\r\n            addresses[0],\r\n            addresses[1],\r\n            addresses[2],\r\n            orderValues[0],\r\n            orderValues[1],\r\n            orderValues[2],\r\n            orderValues[3],\r\n            orderValues[4],\r\n            orderValues[5],\r\n            buyNoMoreThanAmountB,\r\n            marginSplitPercentage,\r\n            v,\r\n            r,\r\n            s\r\n        )"
          Identifier Order
             Type: type(struct LoopringProtocol.Order storage pointer)
             Source: "Order"
          IndexAccess
             Type: address
             Source: "addresses[0]"
            Identifier addresses
               Type: address[3] memory
               Source: "addresses"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: address
             Source: "addresses[1]"
            Identifier addresses
               Type: address[3] memory
               Source: "addresses"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          IndexAccess
             Type: address
             Source: "addresses[2]"
            Identifier addresses
               Type: address[3] memory
               Source: "addresses"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
          IndexAccess
             Type: uint256
             Source: "orderValues[0]"
            Identifier orderValues
               Type: uint256[7] memory
               Source: "orderValues"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "orderValues[1]"
            Identifier orderValues
               Type: uint256[7] memory
               Source: "orderValues"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          IndexAccess
             Type: uint256
             Source: "orderValues[2]"
            Identifier orderValues
               Type: uint256[7] memory
               Source: "orderValues"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
          IndexAccess
             Type: uint256
             Source: "orderValues[3]"
            Identifier orderValues
               Type: uint256[7] memory
               Source: "orderValues"
            Literal, token: [no token] value: 3
               Type: int_const 3
               Source: "3"
          IndexAccess
             Type: uint256
             Source: "orderValues[4]"
            Identifier orderValues
               Type: uint256[7] memory
               Source: "orderValues"
            Literal, token: [no token] value: 4
               Type: int_const 4
               Source: "4"
          IndexAccess
             Type: uint256
             Source: "orderValues[5]"
            Identifier orderValues
               Type: uint256[7] memory
               Source: "orderValues"
            Literal, token: [no token] value: 5
               Type: int_const 5
               Source: "5"
          Identifier buyNoMoreThanAmountB
             Type: bool
             Source: "buyNoMoreThanAmountB"
          Identifier marginSplitPercentage
             Type: uint8
             Source: "marginSplitPercentage"
          Identifier v
             Type: uint8
             Source: "v"
          Identifier r
             Type: bytes32
             Source: "r"
          Identifier s
             Type: bytes32
             Source: "s"
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(msg.sender == order.owner, \"cancelOrder not submitted by order owner\")"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(msg.sender == order.owner, \"cancelOrder not submitted by order owner\")"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == order.owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            MemberAccess to member owner
               Type: address
               Source: "order.owner"
              Identifier order
                 Type: struct LoopringProtocol.Order memory
                 Source: "order"
          Literal, token: [no token] value: cancelOrder not submitted by order owner
             Type: literal_string "cancelOrder not submitted by order owner"
             Source: "\"cancelOrder not submitted by order owner\""
      VariableDeclarationStatement
         Gas costs: 15
         Source: "bytes32 orderHash = calculateOrderHash(order)"
        VariableDeclaration "orderHash"
           Type: bytes32
           Source: "bytes32 orderHash"
          ElementaryTypeName bytes32
             Source: "bytes32"
        FunctionCall
           Type: bytes32
           Source: "calculateOrderHash(order)"
          Identifier calculateOrderHash
             Type: function (struct LoopringProtocol.Order memory) view returns (bytes32)
             Source: "calculateOrderHash"
          Identifier order
             Type: struct LoopringProtocol.Order memory
             Source: "order"
      ExpressionStatement
         Gas costs: [???]
         Source: "verifySignature(\r\n            order.owner,\r\n            orderHash,\r\n            order.v,\r\n            order.r,\r\n            order.s\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "verifySignature(\r\n            order.owner,\r\n            orderHash,\r\n            order.v,\r\n            order.r,\r\n            order.s\r\n        )"
          Identifier verifySignature
             Type: function (address,bytes32,uint8,bytes32,bytes32) view
             Source: "verifySignature"
          MemberAccess to member owner
             Type: address
             Source: "order.owner"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
          Identifier orderHash
             Type: bytes32
             Source: "orderHash"
          MemberAccess to member v
             Type: uint8
             Source: "order.v"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
          MemberAccess to member r
             Type: bytes32
             Source: "order.r"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
          MemberAccess to member s
             Type: bytes32
             Source: "order.s"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
      ExpressionStatement
         Gas costs: 20451
         Source: "cancelled[orderHash] = cancelled[orderHash].add(cancelAmount)"
        Assignment using operator =
           Type: uint256
           Source: "cancelled[orderHash] = cancelled[orderHash].add(cancelAmount)"
          IndexAccess
             Type: uint256
             Source: "cancelled[orderHash]"
            Identifier cancelled
               Type: mapping(bytes32 => uint256)
               Source: "cancelled"
            Identifier orderHash
               Type: bytes32
               Source: "orderHash"
          FunctionCall
             Type: uint256
             Source: "cancelled[orderHash].add(cancelAmount)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "cancelled[orderHash].add"
              IndexAccess
                 Type: uint256
                 Source: "cancelled[orderHash]"
                Identifier cancelled
                   Type: mapping(bytes32 => uint256)
                   Source: "cancelled"
                Identifier orderHash
                   Type: bytes32
                   Source: "orderHash"
            Identifier cancelAmount
               Type: uint256
               Source: "cancelAmount"
      ExpressionStatement
         Gas costs: [???]
         Source: "OrderCancelled(\r\n            block.timestamp,\r\n            block.number,\r\n            orderHash,\r\n            cancelAmount\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "OrderCancelled(\r\n            block.timestamp,\r\n            block.number,\r\n            orderHash,\r\n            cancelAmount\r\n        )"
          Identifier OrderCancelled
             Type: function (uint256,uint256,bytes32,uint256)
             Source: "OrderCancelled"
          MemberAccess to member timestamp
             Type: uint256
             Source: "block.timestamp"
            Identifier block
               Type: block
               Source: "block"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          Identifier orderHash
             Type: bytes32
             Source: "orderHash"
          Identifier cancelAmount
             Type: uint256
             Source: "cancelAmount"
  FunctionDefinition "setCutoff" - public
     Source: "function setCutoff(uint cutoff)\r\n        public\r\n    {\r\n        uint t = cutoff;\r\n        if (t == 0) {\r\n            t = block.timestamp;\r\n        }\r\n\r\n        ErrorLib.check(\r\n            cutoffs[msg.sender] < t,\r\n            \"attempted to set cutoff to a smaller value\"\r\n        );\r\n\r\n        cutoffs[msg.sender] = t;\r\n\r\n        CutoffTimestampChanged(\r\n            block.timestamp,\r\n            block.number,\r\n            msg.sender,\r\n            t\r\n        );\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint cutoff)"
      VariableDeclaration "cutoff"
         Type: uint256
         Source: "uint cutoff"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint t = cutoff;\r\n        if (t == 0) {\r\n            t = block.timestamp;\r\n        }\r\n\r\n        ErrorLib.check(\r\n            cutoffs[msg.sender] < t,\r\n            \"attempted to set cutoff to a smaller value\"\r\n        );\r\n\r\n        cutoffs[msg.sender] = t;\r\n\r\n        CutoffTimestampChanged(\r\n            block.timestamp,\r\n            block.number,\r\n            msg.sender,\r\n            t\r\n        );\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint t = cutoff"
        VariableDeclaration "t"
           Type: uint256
           Source: "uint t"
          ElementaryTypeName uint
             Source: "uint"
        Identifier cutoff
           Type: uint256
           Source: "cutoff"
      IfStatement
         Source: "if (t == 0) {\r\n            t = block.timestamp;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "t == 0"
          Identifier t
             Type: uint256
             Source: "t"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            t = block.timestamp;\r\n        }"
          ExpressionStatement
             Gas costs: 7
             Source: "t = block.timestamp"
            Assignment using operator =
               Type: uint256
               Source: "t = block.timestamp"
              Identifier t
                 Type: uint256
                 Source: "t"
              MemberAccess to member timestamp
                 Type: uint256
                 Source: "block.timestamp"
                Identifier block
                   Type: block
                   Source: "block"
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            cutoffs[msg.sender] < t,\r\n            \"attempted to set cutoff to a smaller value\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            cutoffs[msg.sender] < t,\r\n            \"attempted to set cutoff to a smaller value\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator <
             Type: bool
             Source: "cutoffs[msg.sender] < t"
            IndexAccess
               Type: uint256
               Source: "cutoffs[msg.sender]"
              Identifier cutoffs
                 Type: mapping(address => uint256)
                 Source: "cutoffs"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier t
               Type: uint256
               Source: "t"
          Literal, token: [no token] value: attempted to set cutoff to a smaller value
             Type: literal_string "attempted to set cutoff to a smaller value"
             Source: "\"attempted to set cutoff to a smaller value\""
      ExpressionStatement
         Gas costs: 20109
         Source: "cutoffs[msg.sender] = t"
        Assignment using operator =
           Type: uint256
           Source: "cutoffs[msg.sender] = t"
          IndexAccess
             Type: uint256
             Source: "cutoffs[msg.sender]"
            Identifier cutoffs
               Type: mapping(address => uint256)
               Source: "cutoffs"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier t
             Type: uint256
             Source: "t"
      ExpressionStatement
         Gas costs: [???]
         Source: "CutoffTimestampChanged(\r\n            block.timestamp,\r\n            block.number,\r\n            msg.sender,\r\n            t\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "CutoffTimestampChanged(\r\n            block.timestamp,\r\n            block.number,\r\n            msg.sender,\r\n            t\r\n        )"
          Identifier CutoffTimestampChanged
             Type: function (uint256,uint256,address,uint256)
             Source: "CutoffTimestampChanged"
          MemberAccess to member timestamp
             Type: uint256
             Source: "block.timestamp"
            Identifier block
               Type: block
               Source: "block"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier t
             Type: uint256
             Source: "t"
  FunctionDefinition "verifyRingHasNoSubRing" - const
     Source: "function verifyRingHasNoSubRing(Ring ring)\r\n        internal\r\n        constant\r\n    {\r\n        uint ringSize = ring.orders.length;\r\n        // Check the ring has no sub-ring.\r\n        for (uint i = 0; i < ringSize - 1; i++) {\r\n            address tokenS = ring.orders[i].order.tokenS;\r\n            for (uint j = i + 1; j < ringSize; j++) {\r\n                ErrorLib.check(\r\n                    tokenS != ring.orders[j].order.tokenS,\r\n                    \"found sub-ring\"\r\n                );\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Ring ring)"
      VariableDeclaration "ring"
         Type: struct LoopringProtocolImpl.Ring memory
         Source: "Ring ring"
        UserDefinedTypeName "Ring"
           Source: "Ring"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint ringSize = ring.orders.length;\r\n        // Check the ring has no sub-ring.\r\n        for (uint i = 0; i < ringSize - 1; i++) {\r\n            address tokenS = ring.orders[i].order.tokenS;\r\n            for (uint j = i + 1; j < ringSize; j++) {\r\n                ErrorLib.check(\r\n                    tokenS != ring.orders[j].order.tokenS,\r\n                    \"found sub-ring\"\r\n                );\r\n            }\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint ringSize = ring.orders.length"
        VariableDeclaration "ringSize"
           Type: uint256
           Source: "uint ringSize"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "ring.orders.length"
          MemberAccess to member orders
             Type: struct LoopringProtocolImpl.OrderState memory[] memory
             Source: "ring.orders"
            Identifier ring
               Type: struct LoopringProtocolImpl.Ring memory
               Source: "ring"
      ForStatement
         Source: "for (uint i = 0; i < ringSize - 1; i++) {\r\n            address tokenS = ring.orders[i].order.tokenS;\r\n            for (uint j = i + 1; j < ringSize; j++) {\r\n                ErrorLib.check(\r\n                    tokenS != ring.orders[j].order.tokenS,\r\n                    \"found sub-ring\"\r\n                );\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 15
           Source: "i < ringSize - 1"
          Identifier i
             Type: uint256
             Source: "i"
          BinaryOperation using operator -
             Type: uint256
             Source: "ringSize - 1"
            Identifier ringSize
               Type: uint256
               Source: "ringSize"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            address tokenS = ring.orders[i].order.tokenS;\r\n            for (uint j = i + 1; j < ringSize; j++) {\r\n                ErrorLib.check(\r\n                    tokenS != ring.orders[j].order.tokenS,\r\n                    \"found sub-ring\"\r\n                );\r\n            }\r\n        }"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "address tokenS = ring.orders[i].order.tokenS"
            VariableDeclaration "tokenS"
               Type: address
               Source: "address tokenS"
              ElementaryTypeName address
                 Source: "address"
            MemberAccess to member tokenS
               Type: address
               Source: "ring.orders[i].order.tokenS"
              MemberAccess to member order
                 Type: struct LoopringProtocol.Order memory
                 Source: "ring.orders[i].order"
                IndexAccess
                   Type: struct LoopringProtocolImpl.OrderState memory
                   Source: "ring.orders[i]"
                  MemberAccess to member orders
                     Type: struct LoopringProtocolImpl.OrderState memory[] memory
                     Source: "ring.orders"
                    Identifier ring
                       Type: struct LoopringProtocolImpl.Ring memory
                       Source: "ring"
                  Identifier i
                     Type: uint256
                     Source: "i"
          ForStatement
             Source: "for (uint j = i + 1; j < ringSize; j++) {\r\n                ErrorLib.check(\r\n                    tokenS != ring.orders[j].order.tokenS,\r\n                    \"found sub-ring\"\r\n                );\r\n            }"
            VariableDeclarationStatement
               Gas costs: 17
               Source: "uint j = i + 1"
              VariableDeclaration "j"
                 Type: uint256
                 Source: "uint j"
                ElementaryTypeName uint
                   Source: "uint"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "i + 1"
                Identifier i
                   Type: uint256
                   Source: "i"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 9
               Source: "j < ringSize"
              Identifier j
                 Type: uint256
                 Source: "j"
              Identifier ringSize
                 Type: uint256
                 Source: "ringSize"
            ExpressionStatement
               Gas costs: 19
               Source: "j++"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "j++"
                Identifier j
                   Type: uint256
                   Source: "j"
            Block
               Source: "{\r\n                ErrorLib.check(\r\n                    tokenS != ring.orders[j].order.tokenS,\r\n                    \"found sub-ring\"\r\n                );\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "ErrorLib.check(\r\n                    tokenS != ring.orders[j].order.tokenS,\r\n                    \"found sub-ring\"\r\n                )"
                FunctionCall
                   Type: tuple()
                   Source: "ErrorLib.check(\r\n                    tokenS != ring.orders[j].order.tokenS,\r\n                    \"found sub-ring\"\r\n                )"
                  MemberAccess to member check
                     Type: function (bool,string memory) view
                     Source: "ErrorLib.check"
                    Identifier ErrorLib
                       Type: type(library ErrorLib)
                       Source: "ErrorLib"
                  BinaryOperation using operator !=
                     Type: bool
                     Source: "tokenS != ring.orders[j].order.tokenS"
                    Identifier tokenS
                       Type: address
                       Source: "tokenS"
                    MemberAccess to member tokenS
                       Type: address
                       Source: "ring.orders[j].order.tokenS"
                      MemberAccess to member order
                         Type: struct LoopringProtocol.Order memory
                         Source: "ring.orders[j].order"
                        IndexAccess
                           Type: struct LoopringProtocolImpl.OrderState memory
                           Source: "ring.orders[j]"
                          MemberAccess to member orders
                             Type: struct LoopringProtocolImpl.OrderState memory[] memory
                             Source: "ring.orders"
                            Identifier ring
                               Type: struct LoopringProtocolImpl.Ring memory
                               Source: "ring"
                          Identifier j
                             Type: uint256
                             Source: "j"
                  Literal, token: [no token] value: found sub-ring
                     Type: literal_string "found sub-ring"
                     Source: "\"found sub-ring\""
  FunctionDefinition "verifyTokensRegistered" - const
     Source: "function verifyTokensRegistered(address[2][] addressList)\r\n        internal\r\n        constant\r\n    {\r\n        var registryContract = TokenRegistry(tokenRegistryAddress);\r\n        for (uint i = 0; i < addressList.length; i++) {\r\n            ErrorLib.check(\r\n                registryContract.isTokenRegistered(addressList[i][1]),\r\n                \"token not registered\"\r\n            );\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[2][] addressList)"
      VariableDeclaration "addressList"
         Type: address[2] memory[] memory
         Source: "address[2][] addressList"
        ArrayTypeName
           Source: "address[2][]"
          ArrayTypeName
             Source: "address[2]"
            ElementaryTypeName address
               Source: "address"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        var registryContract = TokenRegistry(tokenRegistryAddress);\r\n        for (uint i = 0; i < addressList.length; i++) {\r\n            ErrorLib.check(\r\n                registryContract.isTokenRegistered(addressList[i][1]),\r\n                \"token not registered\"\r\n            );\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 247
         Source: "var registryContract = TokenRegistry(tokenRegistryAddress)"
        VariableDeclaration "registryContract"
           Type: contract TokenRegistry
           Source: "var registryContract"
        FunctionCall
           Type: contract TokenRegistry
           Source: "TokenRegistry(tokenRegistryAddress)"
          Identifier TokenRegistry
             Type: type(contract TokenRegistry)
             Source: "TokenRegistry"
          Identifier tokenRegistryAddress
             Type: address
             Source: "tokenRegistryAddress"
      ForStatement
         Source: "for (uint i = 0; i < addressList.length; i++) {\r\n            ErrorLib.check(\r\n                registryContract.isTokenRegistered(addressList[i][1]),\r\n                \"token not registered\"\r\n            );\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "i < addressList.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "addressList.length"
            Identifier addressList
               Type: address[2] memory[] memory
               Source: "addressList"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            ErrorLib.check(\r\n                registryContract.isTokenRegistered(addressList[i][1]),\r\n                \"token not registered\"\r\n            );\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "ErrorLib.check(\r\n                registryContract.isTokenRegistered(addressList[i][1]),\r\n                \"token not registered\"\r\n            )"
            FunctionCall
               Type: tuple()
               Source: "ErrorLib.check(\r\n                registryContract.isTokenRegistered(addressList[i][1]),\r\n                \"token not registered\"\r\n            )"
              MemberAccess to member check
                 Type: function (bool,string memory) view
                 Source: "ErrorLib.check"
                Identifier ErrorLib
                   Type: type(library ErrorLib)
                   Source: "ErrorLib"
              FunctionCall
                 Type: bool
                 Source: "registryContract.isTokenRegistered(addressList[i][1])"
                MemberAccess to member isTokenRegistered
                   Type: function (address) view external returns (bool)
                   Source: "registryContract.isTokenRegistered"
                  Identifier registryContract
                     Type: contract TokenRegistry
                     Source: "registryContract"
                IndexAccess
                   Type: address
                   Source: "addressList[i][1]"
                  IndexAccess
                     Type: address[2] memory
                     Source: "addressList[i]"
                    Identifier addressList
                       Type: address[2] memory[] memory
                       Source: "addressList"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              Literal, token: [no token] value: token not registered
                 Type: literal_string "token not registered"
                 Source: "\"token not registered\""
  FunctionDefinition "handleRing"
     Source: "function handleRing(\r\n        bytes32 ringhash,\r\n        OrderState[] orders,\r\n        address miner,\r\n        address feeRecepient,\r\n        bool throwIfLRCIsInsuffcient\r\n        )\r\n        internal\r\n    {\r\n        var ring = Ring(\r\n            ringhash,\r\n            orders,\r\n            miner,\r\n            feeRecepient,\r\n            throwIfLRCIsInsuffcient\r\n        );\r\n\r\n        // Do the hard work.\r\n        verifyRingHasNoSubRing(ring);\r\n\r\n        // Exchange rates calculation are performed by ring-miners as solidity\r\n        // cannot get power-of-1/n operation, therefore we have to verify\r\n        // these rates are correct.\r\n        verifyMinerSuppliedFillRates(ring);\r\n\r\n        // Scale down each order independently by substracting amount-filled and\r\n        // amount-cancelled. Order owner's current balance and allowance are\r\n        // not taken into consideration in these operations.\r\n        scaleRingBasedOnHistoricalRecords(ring);\r\n\r\n        // Based on the already verified exchange rate provided by ring-miners,\r\n        // we can furthur scale down orders based on token balance and allowance,\r\n        // then find the smallest order of the ring, then calculate each order's\r\n        // `fillAmountS`.\r\n        calculateRingFillAmount(ring);\r\n\r\n        // Calculate each order's `lrcFee` and `lrcRewrard` and splict how much\r\n        // of `fillAmountS` shall be paid to matching order or miner as margin\r\n        // split.\r\n        calculateRingFees(ring);\r\n\r\n        /// Make payments.\r\n        settleRing(ring);\r\n\r\n        RingMined(\r\n            ringIndex++,\r\n            block.timestamp,\r\n            block.number,\r\n            ring.ringhash,\r\n            ring.miner,\r\n            ring.feeRecepient,\r\n            RinghashRegistry(ringhashRegistryAddress).ringhashFound(ring.ringhash)\r\n        );\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        bytes32 ringhash,\r\n        OrderState[] orders,\r\n        address miner,\r\n        address feeRecepient,\r\n        bool throwIfLRCIsInsuffcient\r\n        )"
      VariableDeclaration "ringhash"
         Type: bytes32
         Source: "bytes32 ringhash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "orders"
         Type: struct LoopringProtocolImpl.OrderState memory[] memory
         Source: "OrderState[] orders"
        ArrayTypeName
           Source: "OrderState[]"
          UserDefinedTypeName "OrderState"
             Source: "OrderState"
      VariableDeclaration "miner"
         Type: address
         Source: "address miner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "feeRecepient"
         Type: address
         Source: "address feeRecepient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "throwIfLRCIsInsuffcient"
         Type: bool
         Source: "bool throwIfLRCIsInsuffcient"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        var ring = Ring(\r\n            ringhash,\r\n            orders,\r\n            miner,\r\n            feeRecepient,\r\n            throwIfLRCIsInsuffcient\r\n        );\r\n\r\n        // Do the hard work.\r\n        verifyRingHasNoSubRing(ring);\r\n\r\n        // Exchange rates calculation are performed by ring-miners as solidity\r\n        // cannot get power-of-1/n operation, therefore we have to verify\r\n        // these rates are correct.\r\n        verifyMinerSuppliedFillRates(ring);\r\n\r\n        // Scale down each order independently by substracting amount-filled and\r\n        // amount-cancelled. Order owner's current balance and allowance are\r\n        // not taken into consideration in these operations.\r\n        scaleRingBasedOnHistoricalRecords(ring);\r\n\r\n        // Based on the already verified exchange rate provided by ring-miners,\r\n        // we can furthur scale down orders based on token balance and allowance,\r\n        // then find the smallest order of the ring, then calculate each order's\r\n        // `fillAmountS`.\r\n        calculateRingFillAmount(ring);\r\n\r\n        // Calculate each order's `lrcFee` and `lrcRewrard` and splict how much\r\n        // of `fillAmountS` shall be paid to matching order or miner as margin\r\n        // split.\r\n        calculateRingFees(ring);\r\n\r\n        /// Make payments.\r\n        settleRing(ring);\r\n\r\n        RingMined(\r\n            ringIndex++,\r\n            block.timestamp,\r\n            block.number,\r\n            ring.ringhash,\r\n            ring.miner,\r\n            ring.feeRecepient,\r\n            RinghashRegistry(ringhashRegistryAddress).ringhashFound(ring.ringhash)\r\n        );\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "var ring = Ring(\r\n            ringhash,\r\n            orders,\r\n            miner,\r\n            feeRecepient,\r\n            throwIfLRCIsInsuffcient\r\n        )"
        VariableDeclaration "ring"
           Type: struct LoopringProtocolImpl.Ring memory
           Source: "var ring"
        FunctionCall
           Type: struct LoopringProtocolImpl.Ring memory
           Source: "Ring(\r\n            ringhash,\r\n            orders,\r\n            miner,\r\n            feeRecepient,\r\n            throwIfLRCIsInsuffcient\r\n        )"
          Identifier Ring
             Type: type(struct LoopringProtocolImpl.Ring storage pointer)
             Source: "Ring"
          Identifier ringhash
             Type: bytes32
             Source: "ringhash"
          Identifier orders
             Type: struct LoopringProtocolImpl.OrderState memory[] memory
             Source: "orders"
          Identifier miner
             Type: address
             Source: "miner"
          Identifier feeRecepient
             Type: address
             Source: "feeRecepient"
          Identifier throwIfLRCIsInsuffcient
             Type: bool
             Source: "throwIfLRCIsInsuffcient"
      ExpressionStatement
         Gas costs: 7
         Source: "verifyRingHasNoSubRing(ring)"
        FunctionCall
           Type: tuple()
           Source: "verifyRingHasNoSubRing(ring)"
          Identifier verifyRingHasNoSubRing
             Type: function (struct LoopringProtocolImpl.Ring memory) view
             Source: "verifyRingHasNoSubRing"
          Identifier ring
             Type: struct LoopringProtocolImpl.Ring memory
             Source: "ring"
      ExpressionStatement
         Gas costs: 7
         Source: "verifyMinerSuppliedFillRates(ring)"
        FunctionCall
           Type: tuple()
           Source: "verifyMinerSuppliedFillRates(ring)"
          Identifier verifyMinerSuppliedFillRates
             Type: function (struct LoopringProtocolImpl.Ring memory) view
             Source: "verifyMinerSuppliedFillRates"
          Identifier ring
             Type: struct LoopringProtocolImpl.Ring memory
             Source: "ring"
      ExpressionStatement
         Gas costs: 7
         Source: "scaleRingBasedOnHistoricalRecords(ring)"
        FunctionCall
           Type: tuple()
           Source: "scaleRingBasedOnHistoricalRecords(ring)"
          Identifier scaleRingBasedOnHistoricalRecords
             Type: function (struct LoopringProtocolImpl.Ring memory) view
             Source: "scaleRingBasedOnHistoricalRecords"
          Identifier ring
             Type: struct LoopringProtocolImpl.Ring memory
             Source: "ring"
      ExpressionStatement
         Gas costs: 7
         Source: "calculateRingFillAmount(ring)"
        FunctionCall
           Type: tuple()
           Source: "calculateRingFillAmount(ring)"
          Identifier calculateRingFillAmount
             Type: function (struct LoopringProtocolImpl.Ring memory) view
             Source: "calculateRingFillAmount"
          Identifier ring
             Type: struct LoopringProtocolImpl.Ring memory
             Source: "ring"
      ExpressionStatement
         Gas costs: 7
         Source: "calculateRingFees(ring)"
        FunctionCall
           Type: tuple()
           Source: "calculateRingFees(ring)"
          Identifier calculateRingFees
             Type: function (struct LoopringProtocolImpl.Ring memory) view
             Source: "calculateRingFees"
          Identifier ring
             Type: struct LoopringProtocolImpl.Ring memory
             Source: "ring"
      ExpressionStatement
         Gas costs: 7
         Source: "settleRing(ring)"
        FunctionCall
           Type: tuple()
           Source: "settleRing(ring)"
          Identifier settleRing
             Type: function (struct LoopringProtocolImpl.Ring memory)
             Source: "settleRing"
          Identifier ring
             Type: struct LoopringProtocolImpl.Ring memory
             Source: "ring"
      ExpressionStatement
         Gas costs: [???]
         Source: "RingMined(\r\n            ringIndex++,\r\n            block.timestamp,\r\n            block.number,\r\n            ring.ringhash,\r\n            ring.miner,\r\n            ring.feeRecepient,\r\n            RinghashRegistry(ringhashRegistryAddress).ringhashFound(ring.ringhash)\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "RingMined(\r\n            ringIndex++,\r\n            block.timestamp,\r\n            block.number,\r\n            ring.ringhash,\r\n            ring.miner,\r\n            ring.feeRecepient,\r\n            RinghashRegistry(ringhashRegistryAddress).ringhashFound(ring.ringhash)\r\n        )"
          Identifier RingMined
             Type: function (uint256,uint256,uint256,bytes32,address,address,bool)
             Source: "RingMined"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "ringIndex++"
            Identifier ringIndex
               Type: uint256
               Source: "ringIndex"
          MemberAccess to member timestamp
             Type: uint256
             Source: "block.timestamp"
            Identifier block
               Type: block
               Source: "block"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          MemberAccess to member ringhash
             Type: bytes32
             Source: "ring.ringhash"
            Identifier ring
               Type: struct LoopringProtocolImpl.Ring memory
               Source: "ring"
          MemberAccess to member miner
             Type: address
             Source: "ring.miner"
            Identifier ring
               Type: struct LoopringProtocolImpl.Ring memory
               Source: "ring"
          MemberAccess to member feeRecepient
             Type: address
             Source: "ring.feeRecepient"
            Identifier ring
               Type: struct LoopringProtocolImpl.Ring memory
               Source: "ring"
          FunctionCall
             Type: bool
             Source: "RinghashRegistry(ringhashRegistryAddress).ringhashFound(ring.ringhash)"
            MemberAccess to member ringhashFound
               Type: function (bytes32) view external returns (bool)
               Source: "RinghashRegistry(ringhashRegistryAddress).ringhashFound"
              FunctionCall
                 Type: contract RinghashRegistry
                 Source: "RinghashRegistry(ringhashRegistryAddress)"
                Identifier RinghashRegistry
                   Type: type(contract RinghashRegistry)
                   Source: "RinghashRegistry"
                Identifier ringhashRegistryAddress
                   Type: address
                   Source: "ringhashRegistryAddress"
            MemberAccess to member ringhash
               Type: bytes32
               Source: "ring.ringhash"
              Identifier ring
                 Type: struct LoopringProtocolImpl.Ring memory
                 Source: "ring"
  FunctionDefinition "settleRing"
     Source: "function settleRing(Ring ring)\r\n        internal\r\n    {\r\n        uint ringSize = ring.orders.length;\r\n        var delegate = TokenTransferDelegate(delegateAddress);\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            var state = ring.orders[i];\r\n            var prev = ring.orders[i.prev(ringSize)];\r\n            var next = ring.orders[i.next(ringSize)];\r\n\r\n            // Pay tokenS to previous order, or to miner as previous order's\r\n            // margin split or/and this order's margin split.\r\n\r\n            delegate.transferToken(\r\n                state.order.tokenS,\r\n                state.order.owner,\r\n                prev.order.owner,\r\n                state.fillAmountS - prev.splitB\r\n            );\r\n\r\n            if (prev.splitB + state.splitS > 0) {\r\n                delegate.transferToken(\r\n                    state.order.tokenS,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    prev.splitB + state.splitS\r\n                );\r\n            }\r\n\r\n            // Pay LRC\r\n            if (state.lrcReward > 0) {\r\n                delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    ring.feeRecepient,\r\n                    state.order.owner,\r\n                    state.lrcReward\r\n                );\r\n            }\r\n\r\n            if (state.lrcFee > 0) {\r\n                delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    state.lrcFee\r\n                );\r\n            }\r\n\r\n            // Update fill records\r\n            if (state.order.buyNoMoreThanAmountB) {\r\n                filled[state.orderHash] += next.fillAmountS;\r\n            } else {\r\n                filled[state.orderHash] += state.fillAmountS;\r\n            }\r\n\r\n            OrderFilled(\r\n                ringIndex,\r\n                block.timestamp,\r\n                block.number,\r\n                ring.ringhash,\r\n                prev.orderHash,\r\n                state.orderHash,\r\n                next.orderHash,\r\n                state.fillAmountS + state.splitS,\r\n                next.fillAmountS - state.splitB,\r\n                state.lrcReward,\r\n                state.lrcFee\r\n            );\r\n        }\r\n\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Ring ring)"
      VariableDeclaration "ring"
         Type: struct LoopringProtocolImpl.Ring memory
         Source: "Ring ring"
        UserDefinedTypeName "Ring"
           Source: "Ring"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint ringSize = ring.orders.length;\r\n        var delegate = TokenTransferDelegate(delegateAddress);\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            var state = ring.orders[i];\r\n            var prev = ring.orders[i.prev(ringSize)];\r\n            var next = ring.orders[i.next(ringSize)];\r\n\r\n            // Pay tokenS to previous order, or to miner as previous order's\r\n            // margin split or/and this order's margin split.\r\n\r\n            delegate.transferToken(\r\n                state.order.tokenS,\r\n                state.order.owner,\r\n                prev.order.owner,\r\n                state.fillAmountS - prev.splitB\r\n            );\r\n\r\n            if (prev.splitB + state.splitS > 0) {\r\n                delegate.transferToken(\r\n                    state.order.tokenS,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    prev.splitB + state.splitS\r\n                );\r\n            }\r\n\r\n            // Pay LRC\r\n            if (state.lrcReward > 0) {\r\n                delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    ring.feeRecepient,\r\n                    state.order.owner,\r\n                    state.lrcReward\r\n                );\r\n            }\r\n\r\n            if (state.lrcFee > 0) {\r\n                delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    state.lrcFee\r\n                );\r\n            }\r\n\r\n            // Update fill records\r\n            if (state.order.buyNoMoreThanAmountB) {\r\n                filled[state.orderHash] += next.fillAmountS;\r\n            } else {\r\n                filled[state.orderHash] += state.fillAmountS;\r\n            }\r\n\r\n            OrderFilled(\r\n                ringIndex,\r\n                block.timestamp,\r\n                block.number,\r\n                ring.ringhash,\r\n                prev.orderHash,\r\n                state.orderHash,\r\n                next.orderHash,\r\n                state.fillAmountS + state.splitS,\r\n                next.fillAmountS - state.splitB,\r\n                state.lrcReward,\r\n                state.lrcFee\r\n            );\r\n        }\r\n\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint ringSize = ring.orders.length"
        VariableDeclaration "ringSize"
           Type: uint256
           Source: "uint ringSize"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "ring.orders.length"
          MemberAccess to member orders
             Type: struct LoopringProtocolImpl.OrderState memory[] memory
             Source: "ring.orders"
            Identifier ring
               Type: struct LoopringProtocolImpl.Ring memory
               Source: "ring"
      VariableDeclarationStatement
         Gas costs: 247
         Source: "var delegate = TokenTransferDelegate(delegateAddress)"
        VariableDeclaration "delegate"
           Type: contract TokenTransferDelegate
           Source: "var delegate"
        FunctionCall
           Type: contract TokenTransferDelegate
           Source: "TokenTransferDelegate(delegateAddress)"
          Identifier TokenTransferDelegate
             Type: type(contract TokenTransferDelegate)
             Source: "TokenTransferDelegate"
          Identifier delegateAddress
             Type: address
             Source: "delegateAddress"
      ForStatement
         Source: "for (uint i = 0; i < ringSize; i++) {\r\n            var state = ring.orders[i];\r\n            var prev = ring.orders[i.prev(ringSize)];\r\n            var next = ring.orders[i.next(ringSize)];\r\n\r\n            // Pay tokenS to previous order, or to miner as previous order's\r\n            // margin split or/and this order's margin split.\r\n\r\n            delegate.transferToken(\r\n                state.order.tokenS,\r\n                state.order.owner,\r\n                prev.order.owner,\r\n                state.fillAmountS - prev.splitB\r\n            );\r\n\r\n            if (prev.splitB + state.splitS > 0) {\r\n                delegate.transferToken(\r\n                    state.order.tokenS,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    prev.splitB + state.splitS\r\n                );\r\n            }\r\n\r\n            // Pay LRC\r\n            if (state.lrcReward > 0) {\r\n                delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    ring.feeRecepient,\r\n                    state.order.owner,\r\n                    state.lrcReward\r\n                );\r\n            }\r\n\r\n            if (state.lrcFee > 0) {\r\n                delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    state.lrcFee\r\n                );\r\n            }\r\n\r\n            // Update fill records\r\n            if (state.order.buyNoMoreThanAmountB) {\r\n                filled[state.orderHash] += next.fillAmountS;\r\n            } else {\r\n                filled[state.orderHash] += state.fillAmountS;\r\n            }\r\n\r\n            OrderFilled(\r\n                ringIndex,\r\n                block.timestamp,\r\n                block.number,\r\n                ring.ringhash,\r\n                prev.orderHash,\r\n                state.orderHash,\r\n                next.orderHash,\r\n                state.fillAmountS + state.splitS,\r\n                next.fillAmountS - state.splitB,\r\n                state.lrcReward,\r\n                state.lrcFee\r\n            );\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < ringSize"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier ringSize
             Type: uint256
             Source: "ringSize"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            var state = ring.orders[i];\r\n            var prev = ring.orders[i.prev(ringSize)];\r\n            var next = ring.orders[i.next(ringSize)];\r\n\r\n            // Pay tokenS to previous order, or to miner as previous order's\r\n            // margin split or/and this order's margin split.\r\n\r\n            delegate.transferToken(\r\n                state.order.tokenS,\r\n                state.order.owner,\r\n                prev.order.owner,\r\n                state.fillAmountS - prev.splitB\r\n            );\r\n\r\n            if (prev.splitB + state.splitS > 0) {\r\n                delegate.transferToken(\r\n                    state.order.tokenS,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    prev.splitB + state.splitS\r\n                );\r\n            }\r\n\r\n            // Pay LRC\r\n            if (state.lrcReward > 0) {\r\n                delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    ring.feeRecepient,\r\n                    state.order.owner,\r\n                    state.lrcReward\r\n                );\r\n            }\r\n\r\n            if (state.lrcFee > 0) {\r\n                delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    state.lrcFee\r\n                );\r\n            }\r\n\r\n            // Update fill records\r\n            if (state.order.buyNoMoreThanAmountB) {\r\n                filled[state.orderHash] += next.fillAmountS;\r\n            } else {\r\n                filled[state.orderHash] += state.fillAmountS;\r\n            }\r\n\r\n            OrderFilled(\r\n                ringIndex,\r\n                block.timestamp,\r\n                block.number,\r\n                ring.ringhash,\r\n                prev.orderHash,\r\n                state.orderHash,\r\n                next.orderHash,\r\n                state.fillAmountS + state.splitS,\r\n                next.fillAmountS - state.splitB,\r\n                state.lrcReward,\r\n                state.lrcFee\r\n            );\r\n        }"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "var state = ring.orders[i]"
            VariableDeclaration "state"
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "var state"
            IndexAccess
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "ring.orders[i]"
              MemberAccess to member orders
                 Type: struct LoopringProtocolImpl.OrderState memory[] memory
                 Source: "ring.orders"
                Identifier ring
                   Type: struct LoopringProtocolImpl.Ring memory
                   Source: "ring"
              Identifier i
                 Type: uint256
                 Source: "i"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "var prev = ring.orders[i.prev(ringSize)]"
            VariableDeclaration "prev"
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "var prev"
            IndexAccess
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "ring.orders[i.prev(ringSize)]"
              MemberAccess to member orders
                 Type: struct LoopringProtocolImpl.OrderState memory[] memory
                 Source: "ring.orders"
                Identifier ring
                   Type: struct LoopringProtocolImpl.Ring memory
                   Source: "ring"
              FunctionCall
                 Type: uint256
                 Source: "i.prev(ringSize)"
                MemberAccess to member prev
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "i.prev"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Identifier ringSize
                   Type: uint256
                   Source: "ringSize"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "var next = ring.orders[i.next(ringSize)]"
            VariableDeclaration "next"
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "var next"
            IndexAccess
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "ring.orders[i.next(ringSize)]"
              MemberAccess to member orders
                 Type: struct LoopringProtocolImpl.OrderState memory[] memory
                 Source: "ring.orders"
                Identifier ring
                   Type: struct LoopringProtocolImpl.Ring memory
                   Source: "ring"
              FunctionCall
                 Type: uint256
                 Source: "i.next(ringSize)"
                MemberAccess to member next
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "i.next"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Identifier ringSize
                   Type: uint256
                   Source: "ringSize"
          ExpressionStatement
             Gas costs: [???]
             Source: "delegate.transferToken(\r\n                state.order.tokenS,\r\n                state.order.owner,\r\n                prev.order.owner,\r\n                state.fillAmountS - prev.splitB\r\n            )"
            FunctionCall
               Type: bool
               Source: "delegate.transferToken(\r\n                state.order.tokenS,\r\n                state.order.owner,\r\n                prev.order.owner,\r\n                state.fillAmountS - prev.splitB\r\n            )"
              MemberAccess to member transferToken
                 Type: function (address,address,address,uint256) external returns (bool)
                 Source: "delegate.transferToken"
                Identifier delegate
                   Type: contract TokenTransferDelegate
                   Source: "delegate"
              MemberAccess to member tokenS
                 Type: address
                 Source: "state.order.tokenS"
                MemberAccess to member order
                   Type: struct LoopringProtocol.Order memory
                   Source: "state.order"
                  Identifier state
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "state"
              MemberAccess to member owner
                 Type: address
                 Source: "state.order.owner"
                MemberAccess to member order
                   Type: struct LoopringProtocol.Order memory
                   Source: "state.order"
                  Identifier state
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "state"
              MemberAccess to member owner
                 Type: address
                 Source: "prev.order.owner"
                MemberAccess to member order
                   Type: struct LoopringProtocol.Order memory
                   Source: "prev.order"
                  Identifier prev
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "prev"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "state.fillAmountS - prev.splitB"
                MemberAccess to member fillAmountS
                   Type: uint256
                   Source: "state.fillAmountS"
                  Identifier state
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "state"
                MemberAccess to member splitB
                   Type: uint256
                   Source: "prev.splitB"
                  Identifier prev
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "prev"
          IfStatement
             Source: "if (prev.splitB + state.splitS > 0) {\r\n                delegate.transferToken(\r\n                    state.order.tokenS,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    prev.splitB + state.splitS\r\n                );\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: [???]
               Source: "prev.splitB + state.splitS > 0"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "prev.splitB + state.splitS"
                MemberAccess to member splitB
                   Type: uint256
                   Source: "prev.splitB"
                  Identifier prev
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "prev"
                MemberAccess to member splitS
                   Type: uint256
                   Source: "state.splitS"
                  Identifier state
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "state"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{\r\n                delegate.transferToken(\r\n                    state.order.tokenS,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    prev.splitB + state.splitS\r\n                );\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "delegate.transferToken(\r\n                    state.order.tokenS,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    prev.splitB + state.splitS\r\n                )"
                FunctionCall
                   Type: bool
                   Source: "delegate.transferToken(\r\n                    state.order.tokenS,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    prev.splitB + state.splitS\r\n                )"
                  MemberAccess to member transferToken
                     Type: function (address,address,address,uint256) external returns (bool)
                     Source: "delegate.transferToken"
                    Identifier delegate
                       Type: contract TokenTransferDelegate
                       Source: "delegate"
                  MemberAccess to member tokenS
                     Type: address
                     Source: "state.order.tokenS"
                    MemberAccess to member order
                       Type: struct LoopringProtocol.Order memory
                       Source: "state.order"
                      Identifier state
                         Type: struct LoopringProtocolImpl.OrderState memory
                         Source: "state"
                  MemberAccess to member owner
                     Type: address
                     Source: "state.order.owner"
                    MemberAccess to member order
                       Type: struct LoopringProtocol.Order memory
                       Source: "state.order"
                      Identifier state
                         Type: struct LoopringProtocolImpl.OrderState memory
                         Source: "state"
                  MemberAccess to member feeRecepient
                     Type: address
                     Source: "ring.feeRecepient"
                    Identifier ring
                       Type: struct LoopringProtocolImpl.Ring memory
                       Source: "ring"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "prev.splitB + state.splitS"
                    MemberAccess to member splitB
                       Type: uint256
                       Source: "prev.splitB"
                      Identifier prev
                         Type: struct LoopringProtocolImpl.OrderState memory
                         Source: "prev"
                    MemberAccess to member splitS
                       Type: uint256
                       Source: "state.splitS"
                      Identifier state
                         Type: struct LoopringProtocolImpl.OrderState memory
                         Source: "state"
          IfStatement
             Source: "if (state.lrcReward > 0) {\r\n                delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    ring.feeRecepient,\r\n                    state.order.owner,\r\n                    state.lrcReward\r\n                );\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: [???]
               Source: "state.lrcReward > 0"
              MemberAccess to member lrcReward
                 Type: uint256
                 Source: "state.lrcReward"
                Identifier state
                   Type: struct LoopringProtocolImpl.OrderState memory
                   Source: "state"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{\r\n                delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    ring.feeRecepient,\r\n                    state.order.owner,\r\n                    state.lrcReward\r\n                );\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    ring.feeRecepient,\r\n                    state.order.owner,\r\n                    state.lrcReward\r\n                )"
                FunctionCall
                   Type: bool
                   Source: "delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    ring.feeRecepient,\r\n                    state.order.owner,\r\n                    state.lrcReward\r\n                )"
                  MemberAccess to member transferToken
                     Type: function (address,address,address,uint256) external returns (bool)
                     Source: "delegate.transferToken"
                    Identifier delegate
                       Type: contract TokenTransferDelegate
                       Source: "delegate"
                  Identifier lrcTokenAddress
                     Type: address
                     Source: "lrcTokenAddress"
                  MemberAccess to member feeRecepient
                     Type: address
                     Source: "ring.feeRecepient"
                    Identifier ring
                       Type: struct LoopringProtocolImpl.Ring memory
                       Source: "ring"
                  MemberAccess to member owner
                     Type: address
                     Source: "state.order.owner"
                    MemberAccess to member order
                       Type: struct LoopringProtocol.Order memory
                       Source: "state.order"
                      Identifier state
                         Type: struct LoopringProtocolImpl.OrderState memory
                         Source: "state"
                  MemberAccess to member lrcReward
                     Type: uint256
                     Source: "state.lrcReward"
                    Identifier state
                       Type: struct LoopringProtocolImpl.OrderState memory
                       Source: "state"
          IfStatement
             Source: "if (state.lrcFee > 0) {\r\n                delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    state.lrcFee\r\n                );\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: [???]
               Source: "state.lrcFee > 0"
              MemberAccess to member lrcFee
                 Type: uint256
                 Source: "state.lrcFee"
                Identifier state
                   Type: struct LoopringProtocolImpl.OrderState memory
                   Source: "state"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{\r\n                delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    state.lrcFee\r\n                );\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    state.lrcFee\r\n                )"
                FunctionCall
                   Type: bool
                   Source: "delegate.transferToken(\r\n                    lrcTokenAddress,\r\n                    state.order.owner,\r\n                    ring.feeRecepient,\r\n                    state.lrcFee\r\n                )"
                  MemberAccess to member transferToken
                     Type: function (address,address,address,uint256) external returns (bool)
                     Source: "delegate.transferToken"
                    Identifier delegate
                       Type: contract TokenTransferDelegate
                       Source: "delegate"
                  Identifier lrcTokenAddress
                     Type: address
                     Source: "lrcTokenAddress"
                  MemberAccess to member owner
                     Type: address
                     Source: "state.order.owner"
                    MemberAccess to member order
                       Type: struct LoopringProtocol.Order memory
                       Source: "state.order"
                      Identifier state
                         Type: struct LoopringProtocolImpl.OrderState memory
                         Source: "state"
                  MemberAccess to member feeRecepient
                     Type: address
                     Source: "ring.feeRecepient"
                    Identifier ring
                       Type: struct LoopringProtocolImpl.Ring memory
                       Source: "ring"
                  MemberAccess to member lrcFee
                     Type: uint256
                     Source: "state.lrcFee"
                    Identifier state
                       Type: struct LoopringProtocolImpl.OrderState memory
                       Source: "state"
          IfStatement
             Source: "if (state.order.buyNoMoreThanAmountB) {\r\n                filled[state.orderHash] += next.fillAmountS;\r\n            } else {\r\n                filled[state.orderHash] += state.fillAmountS;\r\n            }"
            MemberAccess to member buyNoMoreThanAmountB
               Type: bool
               Gas costs: [???]
               Source: "state.order.buyNoMoreThanAmountB"
              MemberAccess to member order
                 Type: struct LoopringProtocol.Order memory
                 Source: "state.order"
                Identifier state
                   Type: struct LoopringProtocolImpl.OrderState memory
                   Source: "state"
            Block
               Source: "{\r\n                filled[state.orderHash] += next.fillAmountS;\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "filled[state.orderHash] += next.fillAmountS"
                Assignment using operator +=
                   Type: uint256
                   Source: "filled[state.orderHash] += next.fillAmountS"
                  IndexAccess
                     Type: uint256
                     Source: "filled[state.orderHash]"
                    Identifier filled
                       Type: mapping(bytes32 => uint256)
                       Source: "filled"
                    MemberAccess to member orderHash
                       Type: bytes32
                       Source: "state.orderHash"
                      Identifier state
                         Type: struct LoopringProtocolImpl.OrderState memory
                         Source: "state"
                  MemberAccess to member fillAmountS
                     Type: uint256
                     Source: "next.fillAmountS"
                    Identifier next
                       Type: struct LoopringProtocolImpl.OrderState memory
                       Source: "next"
            Block
               Source: "{\r\n                filled[state.orderHash] += state.fillAmountS;\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "filled[state.orderHash] += state.fillAmountS"
                Assignment using operator +=
                   Type: uint256
                   Source: "filled[state.orderHash] += state.fillAmountS"
                  IndexAccess
                     Type: uint256
                     Source: "filled[state.orderHash]"
                    Identifier filled
                       Type: mapping(bytes32 => uint256)
                       Source: "filled"
                    MemberAccess to member orderHash
                       Type: bytes32
                       Source: "state.orderHash"
                      Identifier state
                         Type: struct LoopringProtocolImpl.OrderState memory
                         Source: "state"
                  MemberAccess to member fillAmountS
                     Type: uint256
                     Source: "state.fillAmountS"
                    Identifier state
                       Type: struct LoopringProtocolImpl.OrderState memory
                       Source: "state"
          ExpressionStatement
             Gas costs: [???]
             Source: "OrderFilled(\r\n                ringIndex,\r\n                block.timestamp,\r\n                block.number,\r\n                ring.ringhash,\r\n                prev.orderHash,\r\n                state.orderHash,\r\n                next.orderHash,\r\n                state.fillAmountS + state.splitS,\r\n                next.fillAmountS - state.splitB,\r\n                state.lrcReward,\r\n                state.lrcFee\r\n            )"
            FunctionCall
               Type: tuple()
               Source: "OrderFilled(\r\n                ringIndex,\r\n                block.timestamp,\r\n                block.number,\r\n                ring.ringhash,\r\n                prev.orderHash,\r\n                state.orderHash,\r\n                next.orderHash,\r\n                state.fillAmountS + state.splitS,\r\n                next.fillAmountS - state.splitB,\r\n                state.lrcReward,\r\n                state.lrcFee\r\n            )"
              Identifier OrderFilled
                 Type: function (uint256,uint256,uint256,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256)
                 Source: "OrderFilled"
              Identifier ringIndex
                 Type: uint256
                 Source: "ringIndex"
              MemberAccess to member timestamp
                 Type: uint256
                 Source: "block.timestamp"
                Identifier block
                   Type: block
                   Source: "block"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              MemberAccess to member ringhash
                 Type: bytes32
                 Source: "ring.ringhash"
                Identifier ring
                   Type: struct LoopringProtocolImpl.Ring memory
                   Source: "ring"
              MemberAccess to member orderHash
                 Type: bytes32
                 Source: "prev.orderHash"
                Identifier prev
                   Type: struct LoopringProtocolImpl.OrderState memory
                   Source: "prev"
              MemberAccess to member orderHash
                 Type: bytes32
                 Source: "state.orderHash"
                Identifier state
                   Type: struct LoopringProtocolImpl.OrderState memory
                   Source: "state"
              MemberAccess to member orderHash
                 Type: bytes32
                 Source: "next.orderHash"
                Identifier next
                   Type: struct LoopringProtocolImpl.OrderState memory
                   Source: "next"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "state.fillAmountS + state.splitS"
                MemberAccess to member fillAmountS
                   Type: uint256
                   Source: "state.fillAmountS"
                  Identifier state
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "state"
                MemberAccess to member splitS
                   Type: uint256
                   Source: "state.splitS"
                  Identifier state
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "state"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "next.fillAmountS - state.splitB"
                MemberAccess to member fillAmountS
                   Type: uint256
                   Source: "next.fillAmountS"
                  Identifier next
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "next"
                MemberAccess to member splitB
                   Type: uint256
                   Source: "state.splitB"
                  Identifier state
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "state"
              MemberAccess to member lrcReward
                 Type: uint256
                 Source: "state.lrcReward"
                Identifier state
                   Type: struct LoopringProtocolImpl.OrderState memory
                   Source: "state"
              MemberAccess to member lrcFee
                 Type: uint256
                 Source: "state.lrcFee"
                Identifier state
                   Type: struct LoopringProtocolImpl.OrderState memory
                   Source: "state"
  FunctionDefinition "verifyMinerSuppliedFillRates" - const
     Source: "function verifyMinerSuppliedFillRates(Ring ring)\r\n        internal\r\n        constant\r\n    {\r\n        var orders = ring.orders;\r\n        uint ringSize = orders.length;\r\n        uint[] memory rateRatios = new uint[](ringSize);\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            uint s1b0 = orders[i].rate.amountS.mul(orders[i].order.amountB);\r\n            uint s0b1 = orders[i].order.amountS.mul(orders[i].rate.amountB);\r\n\r\n            ErrorLib.check(\r\n                s1b0 <= s0b1,\r\n                \"miner supplied exchange rate provides invalid discount\"\r\n            );\r\n\r\n            rateRatios[i] = RATE_RATIO_SCALE.mul(s1b0).div(s0b1);\r\n        }\r\n\r\n        uint cvs = UintLib.cvsquare(rateRatios, RATE_RATIO_SCALE);\r\n\r\n        ErrorLib.check(\r\n            cvs <= rateRatioCVSThreshold,\r\n            \"miner supplied exchange rate is not evenly discounted\"\r\n        );\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Ring ring)"
      VariableDeclaration "ring"
         Type: struct LoopringProtocolImpl.Ring memory
         Source: "Ring ring"
        UserDefinedTypeName "Ring"
           Source: "Ring"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        var orders = ring.orders;\r\n        uint ringSize = orders.length;\r\n        uint[] memory rateRatios = new uint[](ringSize);\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            uint s1b0 = orders[i].rate.amountS.mul(orders[i].order.amountB);\r\n            uint s0b1 = orders[i].order.amountS.mul(orders[i].rate.amountB);\r\n\r\n            ErrorLib.check(\r\n                s1b0 <= s0b1,\r\n                \"miner supplied exchange rate provides invalid discount\"\r\n            );\r\n\r\n            rateRatios[i] = RATE_RATIO_SCALE.mul(s1b0).div(s0b1);\r\n        }\r\n\r\n        uint cvs = UintLib.cvsquare(rateRatios, RATE_RATIO_SCALE);\r\n\r\n        ErrorLib.check(\r\n            cvs <= rateRatioCVSThreshold,\r\n            \"miner supplied exchange rate is not evenly discounted\"\r\n        );\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "var orders = ring.orders"
        VariableDeclaration "orders"
           Type: struct LoopringProtocolImpl.OrderState memory[] memory
           Source: "var orders"
        MemberAccess to member orders
           Type: struct LoopringProtocolImpl.OrderState memory[] memory
           Source: "ring.orders"
          Identifier ring
             Type: struct LoopringProtocolImpl.Ring memory
             Source: "ring"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint ringSize = orders.length"
        VariableDeclaration "ringSize"
           Type: uint256
           Source: "uint ringSize"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "orders.length"
          Identifier orders
             Type: struct LoopringProtocolImpl.OrderState memory[] memory
             Source: "orders"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint[] memory rateRatios = new uint[](ringSize)"
        VariableDeclaration "rateRatios"
           Type: uint256[] memory
           Source: "uint[] memory rateRatios"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](ringSize)"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          Identifier ringSize
             Type: uint256
             Source: "ringSize"
      ForStatement
         Source: "for (uint i = 0; i < ringSize; i++) {\r\n            uint s1b0 = orders[i].rate.amountS.mul(orders[i].order.amountB);\r\n            uint s0b1 = orders[i].order.amountS.mul(orders[i].rate.amountB);\r\n\r\n            ErrorLib.check(\r\n                s1b0 <= s0b1,\r\n                \"miner supplied exchange rate provides invalid discount\"\r\n            );\r\n\r\n            rateRatios[i] = RATE_RATIO_SCALE.mul(s1b0).div(s0b1);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < ringSize"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier ringSize
             Type: uint256
             Source: "ringSize"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            uint s1b0 = orders[i].rate.amountS.mul(orders[i].order.amountB);\r\n            uint s0b1 = orders[i].order.amountS.mul(orders[i].rate.amountB);\r\n\r\n            ErrorLib.check(\r\n                s1b0 <= s0b1,\r\n                \"miner supplied exchange rate provides invalid discount\"\r\n            );\r\n\r\n            rateRatios[i] = RATE_RATIO_SCALE.mul(s1b0).div(s0b1);\r\n        }"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "uint s1b0 = orders[i].rate.amountS.mul(orders[i].order.amountB)"
            VariableDeclaration "s1b0"
               Type: uint256
               Source: "uint s1b0"
              ElementaryTypeName uint
                 Source: "uint"
            FunctionCall
               Type: uint256
               Source: "orders[i].rate.amountS.mul(orders[i].order.amountB)"
              MemberAccess to member mul
                 Type: function (uint256,uint256) view returns (uint256)
                 Source: "orders[i].rate.amountS.mul"
                MemberAccess to member amountS
                   Type: uint256
                   Source: "orders[i].rate.amountS"
                  MemberAccess to member rate
                     Type: struct LoopringProtocolImpl.Rate memory
                     Source: "orders[i].rate"
                    IndexAccess
                       Type: struct LoopringProtocolImpl.OrderState memory
                       Source: "orders[i]"
                      Identifier orders
                         Type: struct LoopringProtocolImpl.OrderState memory[] memory
                         Source: "orders"
                      Identifier i
                         Type: uint256
                         Source: "i"
              MemberAccess to member amountB
                 Type: uint256
                 Source: "orders[i].order.amountB"
                MemberAccess to member order
                   Type: struct LoopringProtocol.Order memory
                   Source: "orders[i].order"
                  IndexAccess
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "orders[i]"
                    Identifier orders
                       Type: struct LoopringProtocolImpl.OrderState memory[] memory
                       Source: "orders"
                    Identifier i
                       Type: uint256
                       Source: "i"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "uint s0b1 = orders[i].order.amountS.mul(orders[i].rate.amountB)"
            VariableDeclaration "s0b1"
               Type: uint256
               Source: "uint s0b1"
              ElementaryTypeName uint
                 Source: "uint"
            FunctionCall
               Type: uint256
               Source: "orders[i].order.amountS.mul(orders[i].rate.amountB)"
              MemberAccess to member mul
                 Type: function (uint256,uint256) view returns (uint256)
                 Source: "orders[i].order.amountS.mul"
                MemberAccess to member amountS
                   Type: uint256
                   Source: "orders[i].order.amountS"
                  MemberAccess to member order
                     Type: struct LoopringProtocol.Order memory
                     Source: "orders[i].order"
                    IndexAccess
                       Type: struct LoopringProtocolImpl.OrderState memory
                       Source: "orders[i]"
                      Identifier orders
                         Type: struct LoopringProtocolImpl.OrderState memory[] memory
                         Source: "orders"
                      Identifier i
                         Type: uint256
                         Source: "i"
              MemberAccess to member amountB
                 Type: uint256
                 Source: "orders[i].rate.amountB"
                MemberAccess to member rate
                   Type: struct LoopringProtocolImpl.Rate memory
                   Source: "orders[i].rate"
                  IndexAccess
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "orders[i]"
                    Identifier orders
                       Type: struct LoopringProtocolImpl.OrderState memory[] memory
                       Source: "orders"
                    Identifier i
                       Type: uint256
                       Source: "i"
          ExpressionStatement
             Gas costs: [???]
             Source: "ErrorLib.check(\r\n                s1b0 <= s0b1,\r\n                \"miner supplied exchange rate provides invalid discount\"\r\n            )"
            FunctionCall
               Type: tuple()
               Source: "ErrorLib.check(\r\n                s1b0 <= s0b1,\r\n                \"miner supplied exchange rate provides invalid discount\"\r\n            )"
              MemberAccess to member check
                 Type: function (bool,string memory) view
                 Source: "ErrorLib.check"
                Identifier ErrorLib
                   Type: type(library ErrorLib)
                   Source: "ErrorLib"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "s1b0 <= s0b1"
                Identifier s1b0
                   Type: uint256
                   Source: "s1b0"
                Identifier s0b1
                   Type: uint256
                   Source: "s0b1"
              Literal, token: [no token] value: miner supplied exchange rate provides invalid discount
                 Type: literal_string "miner supplied exchange rate provides invalid discount"
                 Source: "\"miner supplied exchange rate provides invalid discount\""
          ExpressionStatement
             Gas costs: [???]
             Source: "rateRatios[i] = RATE_RATIO_SCALE.mul(s1b0).div(s0b1)"
            Assignment using operator =
               Type: uint256
               Source: "rateRatios[i] = RATE_RATIO_SCALE.mul(s1b0).div(s0b1)"
              IndexAccess
                 Type: uint256
                 Source: "rateRatios[i]"
                Identifier rateRatios
                   Type: uint256[] memory
                   Source: "rateRatios"
                Identifier i
                   Type: uint256
                   Source: "i"
              FunctionCall
                 Type: uint256
                 Source: "RATE_RATIO_SCALE.mul(s1b0).div(s0b1)"
                MemberAccess to member div
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "RATE_RATIO_SCALE.mul(s1b0).div"
                  FunctionCall
                     Type: uint256
                     Source: "RATE_RATIO_SCALE.mul(s1b0)"
                    MemberAccess to member mul
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "RATE_RATIO_SCALE.mul"
                      Identifier RATE_RATIO_SCALE
                         Type: uint256
                         Source: "RATE_RATIO_SCALE"
                    Identifier s1b0
                       Type: uint256
                       Source: "s1b0"
                Identifier s0b1
                   Type: uint256
                   Source: "s0b1"
      VariableDeclarationStatement
         Gas costs: 15
         Source: "uint cvs = UintLib.cvsquare(rateRatios, RATE_RATIO_SCALE)"
        VariableDeclaration "cvs"
           Type: uint256
           Source: "uint cvs"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "UintLib.cvsquare(rateRatios, RATE_RATIO_SCALE)"
          MemberAccess to member cvsquare
             Type: function (uint256[] memory,uint256) view returns (uint256)
             Source: "UintLib.cvsquare"
            Identifier UintLib
               Type: type(library UintLib)
               Source: "UintLib"
          Identifier rateRatios
             Type: uint256[] memory
             Source: "rateRatios"
          Identifier RATE_RATIO_SCALE
             Type: uint256
             Source: "RATE_RATIO_SCALE"
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            cvs <= rateRatioCVSThreshold,\r\n            \"miner supplied exchange rate is not evenly discounted\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            cvs <= rateRatioCVSThreshold,\r\n            \"miner supplied exchange rate is not evenly discounted\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator <=
             Type: bool
             Source: "cvs <= rateRatioCVSThreshold"
            Identifier cvs
               Type: uint256
               Source: "cvs"
            Identifier rateRatioCVSThreshold
               Type: uint256
               Source: "rateRatioCVSThreshold"
          Literal, token: [no token] value: miner supplied exchange rate is not evenly discounted
             Type: literal_string "miner supplied exchange rate is not evenly discounted"
             Source: "\"miner supplied exchange rate is not evenly discounted\""
  FunctionDefinition "calculateRingFees" - const
     Source: "function calculateRingFees(Ring ring)\r\n        internal\r\n        constant\r\n    {\r\n        uint minerLrcSpendable = getLRCSpendable(ring.feeRecepient);\r\n        uint ringSize = ring.orders.length;\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            var state = ring.orders[i];\r\n            var next = ring.orders[i.next(ringSize)];\r\n\r\n            if (state.feeSelection == FEE_SELECT_LRC) {\r\n\r\n                uint lrcSpendable = getLRCSpendable(state.order.owner);\r\n\r\n                if (lrcSpendable < state.lrcFee) {\r\n                    ErrorLib.check(\r\n                        !ring.throwIfLRCIsInsuffcient,\r\n                        \"order LRC balance insuffcient\"\r\n                    );\r\n\r\n                    state.lrcFee = lrcSpendable;\r\n                    minerLrcSpendable += lrcSpendable;\r\n                }\r\n\r\n            } else if (state.feeSelection == FEE_SELECT_MARGIN_SPLIT) {\r\n                if (minerLrcSpendable >= state.lrcFee) {\r\n                    if (state.order.buyNoMoreThanAmountB) {\r\n                        uint splitS = next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub(\r\n                            state.fillAmountS\r\n                        );\r\n\r\n                        state.splitS = splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    } else {\r\n                        uint splitB = next.fillAmountS.sub(state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)\r\n                        );\r\n\r\n                        state.splitB = splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    }\r\n\r\n                    // This implicits order with smaller index in the ring will\r\n                    // be paid LRC reward first, so the orders in the ring does\r\n                    // mater.\r\n                    if (state.splitS > 0 || state.splitB > 0) {\r\n                        minerLrcSpendable = minerLrcSpendable.sub(state.lrcFee);\r\n                        state.lrcReward = state.lrcFee;\r\n                    }\r\n                    state.lrcFee = 0;\r\n                }\r\n            } else {\r\n                ErrorLib.error(\"unsupported fee selection value\");\r\n            }\r\n        }\r\n\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Ring ring)"
      VariableDeclaration "ring"
         Type: struct LoopringProtocolImpl.Ring memory
         Source: "Ring ring"
        UserDefinedTypeName "Ring"
           Source: "Ring"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint minerLrcSpendable = getLRCSpendable(ring.feeRecepient);\r\n        uint ringSize = ring.orders.length;\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            var state = ring.orders[i];\r\n            var next = ring.orders[i.next(ringSize)];\r\n\r\n            if (state.feeSelection == FEE_SELECT_LRC) {\r\n\r\n                uint lrcSpendable = getLRCSpendable(state.order.owner);\r\n\r\n                if (lrcSpendable < state.lrcFee) {\r\n                    ErrorLib.check(\r\n                        !ring.throwIfLRCIsInsuffcient,\r\n                        \"order LRC balance insuffcient\"\r\n                    );\r\n\r\n                    state.lrcFee = lrcSpendable;\r\n                    minerLrcSpendable += lrcSpendable;\r\n                }\r\n\r\n            } else if (state.feeSelection == FEE_SELECT_MARGIN_SPLIT) {\r\n                if (minerLrcSpendable >= state.lrcFee) {\r\n                    if (state.order.buyNoMoreThanAmountB) {\r\n                        uint splitS = next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub(\r\n                            state.fillAmountS\r\n                        );\r\n\r\n                        state.splitS = splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    } else {\r\n                        uint splitB = next.fillAmountS.sub(state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)\r\n                        );\r\n\r\n                        state.splitB = splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    }\r\n\r\n                    // This implicits order with smaller index in the ring will\r\n                    // be paid LRC reward first, so the orders in the ring does\r\n                    // mater.\r\n                    if (state.splitS > 0 || state.splitB > 0) {\r\n                        minerLrcSpendable = minerLrcSpendable.sub(state.lrcFee);\r\n                        state.lrcReward = state.lrcFee;\r\n                    }\r\n                    state.lrcFee = 0;\r\n                }\r\n            } else {\r\n                ErrorLib.error(\"unsupported fee selection value\");\r\n            }\r\n        }\r\n\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint minerLrcSpendable = getLRCSpendable(ring.feeRecepient)"
        VariableDeclaration "minerLrcSpendable"
           Type: uint256
           Source: "uint minerLrcSpendable"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getLRCSpendable(ring.feeRecepient)"
          Identifier getLRCSpendable
             Type: function (address) view returns (uint256)
             Source: "getLRCSpendable"
          MemberAccess to member feeRecepient
             Type: address
             Source: "ring.feeRecepient"
            Identifier ring
               Type: struct LoopringProtocolImpl.Ring memory
               Source: "ring"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint ringSize = ring.orders.length"
        VariableDeclaration "ringSize"
           Type: uint256
           Source: "uint ringSize"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "ring.orders.length"
          MemberAccess to member orders
             Type: struct LoopringProtocolImpl.OrderState memory[] memory
             Source: "ring.orders"
            Identifier ring
               Type: struct LoopringProtocolImpl.Ring memory
               Source: "ring"
      ForStatement
         Source: "for (uint i = 0; i < ringSize; i++) {\r\n            var state = ring.orders[i];\r\n            var next = ring.orders[i.next(ringSize)];\r\n\r\n            if (state.feeSelection == FEE_SELECT_LRC) {\r\n\r\n                uint lrcSpendable = getLRCSpendable(state.order.owner);\r\n\r\n                if (lrcSpendable < state.lrcFee) {\r\n                    ErrorLib.check(\r\n                        !ring.throwIfLRCIsInsuffcient,\r\n                        \"order LRC balance insuffcient\"\r\n                    );\r\n\r\n                    state.lrcFee = lrcSpendable;\r\n                    minerLrcSpendable += lrcSpendable;\r\n                }\r\n\r\n            } else if (state.feeSelection == FEE_SELECT_MARGIN_SPLIT) {\r\n                if (minerLrcSpendable >= state.lrcFee) {\r\n                    if (state.order.buyNoMoreThanAmountB) {\r\n                        uint splitS = next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub(\r\n                            state.fillAmountS\r\n                        );\r\n\r\n                        state.splitS = splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    } else {\r\n                        uint splitB = next.fillAmountS.sub(state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)\r\n                        );\r\n\r\n                        state.splitB = splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    }\r\n\r\n                    // This implicits order with smaller index in the ring will\r\n                    // be paid LRC reward first, so the orders in the ring does\r\n                    // mater.\r\n                    if (state.splitS > 0 || state.splitB > 0) {\r\n                        minerLrcSpendable = minerLrcSpendable.sub(state.lrcFee);\r\n                        state.lrcReward = state.lrcFee;\r\n                    }\r\n                    state.lrcFee = 0;\r\n                }\r\n            } else {\r\n                ErrorLib.error(\"unsupported fee selection value\");\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < ringSize"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier ringSize
             Type: uint256
             Source: "ringSize"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            var state = ring.orders[i];\r\n            var next = ring.orders[i.next(ringSize)];\r\n\r\n            if (state.feeSelection == FEE_SELECT_LRC) {\r\n\r\n                uint lrcSpendable = getLRCSpendable(state.order.owner);\r\n\r\n                if (lrcSpendable < state.lrcFee) {\r\n                    ErrorLib.check(\r\n                        !ring.throwIfLRCIsInsuffcient,\r\n                        \"order LRC balance insuffcient\"\r\n                    );\r\n\r\n                    state.lrcFee = lrcSpendable;\r\n                    minerLrcSpendable += lrcSpendable;\r\n                }\r\n\r\n            } else if (state.feeSelection == FEE_SELECT_MARGIN_SPLIT) {\r\n                if (minerLrcSpendable >= state.lrcFee) {\r\n                    if (state.order.buyNoMoreThanAmountB) {\r\n                        uint splitS = next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub(\r\n                            state.fillAmountS\r\n                        );\r\n\r\n                        state.splitS = splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    } else {\r\n                        uint splitB = next.fillAmountS.sub(state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)\r\n                        );\r\n\r\n                        state.splitB = splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    }\r\n\r\n                    // This implicits order with smaller index in the ring will\r\n                    // be paid LRC reward first, so the orders in the ring does\r\n                    // mater.\r\n                    if (state.splitS > 0 || state.splitB > 0) {\r\n                        minerLrcSpendable = minerLrcSpendable.sub(state.lrcFee);\r\n                        state.lrcReward = state.lrcFee;\r\n                    }\r\n                    state.lrcFee = 0;\r\n                }\r\n            } else {\r\n                ErrorLib.error(\"unsupported fee selection value\");\r\n            }\r\n        }"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "var state = ring.orders[i]"
            VariableDeclaration "state"
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "var state"
            IndexAccess
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "ring.orders[i]"
              MemberAccess to member orders
                 Type: struct LoopringProtocolImpl.OrderState memory[] memory
                 Source: "ring.orders"
                Identifier ring
                   Type: struct LoopringProtocolImpl.Ring memory
                   Source: "ring"
              Identifier i
                 Type: uint256
                 Source: "i"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "var next = ring.orders[i.next(ringSize)]"
            VariableDeclaration "next"
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "var next"
            IndexAccess
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "ring.orders[i.next(ringSize)]"
              MemberAccess to member orders
                 Type: struct LoopringProtocolImpl.OrderState memory[] memory
                 Source: "ring.orders"
                Identifier ring
                   Type: struct LoopringProtocolImpl.Ring memory
                   Source: "ring"
              FunctionCall
                 Type: uint256
                 Source: "i.next(ringSize)"
                MemberAccess to member next
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "i.next"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Identifier ringSize
                   Type: uint256
                   Source: "ringSize"
          IfStatement
             Source: "if (state.feeSelection == FEE_SELECT_LRC) {\r\n\r\n                uint lrcSpendable = getLRCSpendable(state.order.owner);\r\n\r\n                if (lrcSpendable < state.lrcFee) {\r\n                    ErrorLib.check(\r\n                        !ring.throwIfLRCIsInsuffcient,\r\n                        \"order LRC balance insuffcient\"\r\n                    );\r\n\r\n                    state.lrcFee = lrcSpendable;\r\n                    minerLrcSpendable += lrcSpendable;\r\n                }\r\n\r\n            } else if (state.feeSelection == FEE_SELECT_MARGIN_SPLIT) {\r\n                if (minerLrcSpendable >= state.lrcFee) {\r\n                    if (state.order.buyNoMoreThanAmountB) {\r\n                        uint splitS = next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub(\r\n                            state.fillAmountS\r\n                        );\r\n\r\n                        state.splitS = splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    } else {\r\n                        uint splitB = next.fillAmountS.sub(state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)\r\n                        );\r\n\r\n                        state.splitB = splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    }\r\n\r\n                    // This implicits order with smaller index in the ring will\r\n                    // be paid LRC reward first, so the orders in the ring does\r\n                    // mater.\r\n                    if (state.splitS > 0 || state.splitB > 0) {\r\n                        minerLrcSpendable = minerLrcSpendable.sub(state.lrcFee);\r\n                        state.lrcReward = state.lrcFee;\r\n                    }\r\n                    state.lrcFee = 0;\r\n                }\r\n            } else {\r\n                ErrorLib.error(\"unsupported fee selection value\");\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: [???]
               Source: "state.feeSelection == FEE_SELECT_LRC"
              MemberAccess to member feeSelection
                 Type: uint8
                 Source: "state.feeSelection"
                Identifier state
                   Type: struct LoopringProtocolImpl.OrderState memory
                   Source: "state"
              Identifier FEE_SELECT_LRC
                 Type: uint256
                 Source: "FEE_SELECT_LRC"
            Block
               Source: "{\r\n\r\n                uint lrcSpendable = getLRCSpendable(state.order.owner);\r\n\r\n                if (lrcSpendable < state.lrcFee) {\r\n                    ErrorLib.check(\r\n                        !ring.throwIfLRCIsInsuffcient,\r\n                        \"order LRC balance insuffcient\"\r\n                    );\r\n\r\n                    state.lrcFee = lrcSpendable;\r\n                    minerLrcSpendable += lrcSpendable;\r\n                }\r\n\r\n            }"
              VariableDeclarationStatement
                 Gas costs: [???]
                 Source: "uint lrcSpendable = getLRCSpendable(state.order.owner)"
                VariableDeclaration "lrcSpendable"
                   Type: uint256
                   Source: "uint lrcSpendable"
                  ElementaryTypeName uint
                     Source: "uint"
                FunctionCall
                   Type: uint256
                   Source: "getLRCSpendable(state.order.owner)"
                  Identifier getLRCSpendable
                     Type: function (address) view returns (uint256)
                     Source: "getLRCSpendable"
                  MemberAccess to member owner
                     Type: address
                     Source: "state.order.owner"
                    MemberAccess to member order
                       Type: struct LoopringProtocol.Order memory
                       Source: "state.order"
                      Identifier state
                         Type: struct LoopringProtocolImpl.OrderState memory
                         Source: "state"
              IfStatement
                 Source: "if (lrcSpendable < state.lrcFee) {\r\n                    ErrorLib.check(\r\n                        !ring.throwIfLRCIsInsuffcient,\r\n                        \"order LRC balance insuffcient\"\r\n                    );\r\n\r\n                    state.lrcFee = lrcSpendable;\r\n                    minerLrcSpendable += lrcSpendable;\r\n                }"
                BinaryOperation using operator <
                   Type: bool
                   Gas costs: [???]
                   Source: "lrcSpendable < state.lrcFee"
                  Identifier lrcSpendable
                     Type: uint256
                     Source: "lrcSpendable"
                  MemberAccess to member lrcFee
                     Type: uint256
                     Source: "state.lrcFee"
                    Identifier state
                       Type: struct LoopringProtocolImpl.OrderState memory
                       Source: "state"
                Block
                   Source: "{\r\n                    ErrorLib.check(\r\n                        !ring.throwIfLRCIsInsuffcient,\r\n                        \"order LRC balance insuffcient\"\r\n                    );\r\n\r\n                    state.lrcFee = lrcSpendable;\r\n                    minerLrcSpendable += lrcSpendable;\r\n                }"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "ErrorLib.check(\r\n                        !ring.throwIfLRCIsInsuffcient,\r\n                        \"order LRC balance insuffcient\"\r\n                    )"
                    FunctionCall
                       Type: tuple()
                       Source: "ErrorLib.check(\r\n                        !ring.throwIfLRCIsInsuffcient,\r\n                        \"order LRC balance insuffcient\"\r\n                    )"
                      MemberAccess to member check
                         Type: function (bool,string memory) view
                         Source: "ErrorLib.check"
                        Identifier ErrorLib
                           Type: type(library ErrorLib)
                           Source: "ErrorLib"
                      UnaryOperation (prefix) !
                         Type: bool
                         Source: "!ring.throwIfLRCIsInsuffcient"
                        MemberAccess to member throwIfLRCIsInsuffcient
                           Type: bool
                           Source: "ring.throwIfLRCIsInsuffcient"
                          Identifier ring
                             Type: struct LoopringProtocolImpl.Ring memory
                             Source: "ring"
                      Literal, token: [no token] value: order LRC balance insuffcient
                         Type: literal_string "order LRC balance insuffcient"
                         Source: "\"order LRC balance insuffcient\""
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "state.lrcFee = lrcSpendable"
                    Assignment using operator =
                       Type: uint256
                       Source: "state.lrcFee = lrcSpendable"
                      MemberAccess to member lrcFee
                         Type: uint256
                         Source: "state.lrcFee"
                        Identifier state
                           Type: struct LoopringProtocolImpl.OrderState memory
                           Source: "state"
                      Identifier lrcSpendable
                         Type: uint256
                         Source: "lrcSpendable"
                  ExpressionStatement
                     Gas costs: 14
                     Source: "minerLrcSpendable += lrcSpendable"
                    Assignment using operator +=
                       Type: uint256
                       Source: "minerLrcSpendable += lrcSpendable"
                      Identifier minerLrcSpendable
                         Type: uint256
                         Source: "minerLrcSpendable"
                      Identifier lrcSpendable
                         Type: uint256
                         Source: "lrcSpendable"
            IfStatement
               Source: "if (state.feeSelection == FEE_SELECT_MARGIN_SPLIT) {\r\n                if (minerLrcSpendable >= state.lrcFee) {\r\n                    if (state.order.buyNoMoreThanAmountB) {\r\n                        uint splitS = next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub(\r\n                            state.fillAmountS\r\n                        );\r\n\r\n                        state.splitS = splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    } else {\r\n                        uint splitB = next.fillAmountS.sub(state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)\r\n                        );\r\n\r\n                        state.splitB = splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    }\r\n\r\n                    // This implicits order with smaller index in the ring will\r\n                    // be paid LRC reward first, so the orders in the ring does\r\n                    // mater.\r\n                    if (state.splitS > 0 || state.splitB > 0) {\r\n                        minerLrcSpendable = minerLrcSpendable.sub(state.lrcFee);\r\n                        state.lrcReward = state.lrcFee;\r\n                    }\r\n                    state.lrcFee = 0;\r\n                }\r\n            } else {\r\n                ErrorLib.error(\"unsupported fee selection value\");\r\n            }"
              BinaryOperation using operator ==
                 Type: bool
                 Gas costs: [???]
                 Source: "state.feeSelection == FEE_SELECT_MARGIN_SPLIT"
                MemberAccess to member feeSelection
                   Type: uint8
                   Source: "state.feeSelection"
                  Identifier state
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "state"
                Identifier FEE_SELECT_MARGIN_SPLIT
                   Type: uint256
                   Source: "FEE_SELECT_MARGIN_SPLIT"
              Block
                 Source: "{\r\n                if (minerLrcSpendable >= state.lrcFee) {\r\n                    if (state.order.buyNoMoreThanAmountB) {\r\n                        uint splitS = next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub(\r\n                            state.fillAmountS\r\n                        );\r\n\r\n                        state.splitS = splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    } else {\r\n                        uint splitB = next.fillAmountS.sub(state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)\r\n                        );\r\n\r\n                        state.splitB = splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    }\r\n\r\n                    // This implicits order with smaller index in the ring will\r\n                    // be paid LRC reward first, so the orders in the ring does\r\n                    // mater.\r\n                    if (state.splitS > 0 || state.splitB > 0) {\r\n                        minerLrcSpendable = minerLrcSpendable.sub(state.lrcFee);\r\n                        state.lrcReward = state.lrcFee;\r\n                    }\r\n                    state.lrcFee = 0;\r\n                }\r\n            }"
                IfStatement
                   Source: "if (minerLrcSpendable >= state.lrcFee) {\r\n                    if (state.order.buyNoMoreThanAmountB) {\r\n                        uint splitS = next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub(\r\n                            state.fillAmountS\r\n                        );\r\n\r\n                        state.splitS = splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    } else {\r\n                        uint splitB = next.fillAmountS.sub(state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)\r\n                        );\r\n\r\n                        state.splitB = splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    }\r\n\r\n                    // This implicits order with smaller index in the ring will\r\n                    // be paid LRC reward first, so the orders in the ring does\r\n                    // mater.\r\n                    if (state.splitS > 0 || state.splitB > 0) {\r\n                        minerLrcSpendable = minerLrcSpendable.sub(state.lrcFee);\r\n                        state.lrcReward = state.lrcFee;\r\n                    }\r\n                    state.lrcFee = 0;\r\n                }"
                  BinaryOperation using operator >=
                     Type: bool
                     Gas costs: [???]
                     Source: "minerLrcSpendable >= state.lrcFee"
                    Identifier minerLrcSpendable
                       Type: uint256
                       Source: "minerLrcSpendable"
                    MemberAccess to member lrcFee
                       Type: uint256
                       Source: "state.lrcFee"
                      Identifier state
                         Type: struct LoopringProtocolImpl.OrderState memory
                         Source: "state"
                  Block
                     Source: "{\r\n                    if (state.order.buyNoMoreThanAmountB) {\r\n                        uint splitS = next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub(\r\n                            state.fillAmountS\r\n                        );\r\n\r\n                        state.splitS = splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    } else {\r\n                        uint splitB = next.fillAmountS.sub(state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)\r\n                        );\r\n\r\n                        state.splitB = splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    }\r\n\r\n                    // This implicits order with smaller index in the ring will\r\n                    // be paid LRC reward first, so the orders in the ring does\r\n                    // mater.\r\n                    if (state.splitS > 0 || state.splitB > 0) {\r\n                        minerLrcSpendable = minerLrcSpendable.sub(state.lrcFee);\r\n                        state.lrcReward = state.lrcFee;\r\n                    }\r\n                    state.lrcFee = 0;\r\n                }"
                    IfStatement
                       Source: "if (state.order.buyNoMoreThanAmountB) {\r\n                        uint splitS = next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub(\r\n                            state.fillAmountS\r\n                        );\r\n\r\n                        state.splitS = splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    } else {\r\n                        uint splitB = next.fillAmountS.sub(state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)\r\n                        );\r\n\r\n                        state.splitB = splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    }"
                      MemberAccess to member buyNoMoreThanAmountB
                         Type: bool
                         Gas costs: [???]
                         Source: "state.order.buyNoMoreThanAmountB"
                        MemberAccess to member order
                           Type: struct LoopringProtocol.Order memory
                           Source: "state.order"
                          Identifier state
                             Type: struct LoopringProtocolImpl.OrderState memory
                             Source: "state"
                      Block
                         Source: "{\r\n                        uint splitS = next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub(\r\n                            state.fillAmountS\r\n                        );\r\n\r\n                        state.splitS = splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    }"
                        VariableDeclarationStatement
                           Gas costs: [???]
                           Source: "uint splitS = next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub(\r\n                            state.fillAmountS\r\n                        )"
                          VariableDeclaration "splitS"
                             Type: uint256
                             Source: "uint splitS"
                            ElementaryTypeName uint
                               Source: "uint"
                          FunctionCall
                             Type: uint256
                             Source: "next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub(\r\n                            state.fillAmountS\r\n                        )"
                            MemberAccess to member sub
                               Type: function (uint256,uint256) view returns (uint256)
                               Source: "next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        ).sub"
                              FunctionCall
                                 Type: uint256
                                 Source: "next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div(\r\n                            state.order.amountB\r\n                        )"
                                MemberAccess to member div
                                   Type: function (uint256,uint256) view returns (uint256)
                                   Source: "next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        ).div"
                                  FunctionCall
                                     Type: uint256
                                     Source: "next.fillAmountS.mul(\r\n                            state.order.amountS\r\n                        )"
                                    MemberAccess to member mul
                                       Type: function (uint256,uint256) view returns (uint256)
                                       Source: "next.fillAmountS.mul"
                                      MemberAccess to member fillAmountS
                                         Type: uint256
                                         Source: "next.fillAmountS"
                                        Identifier next
                                           Type: struct LoopringProtocolImpl.OrderState memory
                                           Source: "next"
                                    MemberAccess to member amountS
                                       Type: uint256
                                       Source: "state.order.amountS"
                                      MemberAccess to member order
                                         Type: struct LoopringProtocol.Order memory
                                         Source: "state.order"
                                        Identifier state
                                           Type: struct LoopringProtocolImpl.OrderState memory
                                           Source: "state"
                                MemberAccess to member amountB
                                   Type: uint256
                                   Source: "state.order.amountB"
                                  MemberAccess to member order
                                     Type: struct LoopringProtocol.Order memory
                                     Source: "state.order"
                                    Identifier state
                                       Type: struct LoopringProtocolImpl.OrderState memory
                                       Source: "state"
                            MemberAccess to member fillAmountS
                               Type: uint256
                               Source: "state.fillAmountS"
                              Identifier state
                                 Type: struct LoopringProtocolImpl.OrderState memory
                                 Source: "state"
                        ExpressionStatement
                           Gas costs: [???]
                           Source: "state.splitS = splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        )"
                          Assignment using operator =
                             Type: uint256
                             Source: "state.splitS = splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        )"
                            MemberAccess to member splitS
                               Type: uint256
                               Source: "state.splitS"
                              Identifier state
                                 Type: struct LoopringProtocolImpl.OrderState memory
                                 Source: "state"
                            FunctionCall
                               Type: uint256
                               Source: "splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        )"
                              MemberAccess to member div
                                 Type: function (uint256,uint256) view returns (uint256)
                                 Source: "splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div"
                                FunctionCall
                                   Type: uint256
                                   Source: "splitS.mul(\r\n                            state.order.marginSplitPercentage\r\n                        )"
                                  MemberAccess to member mul
                                     Type: function (uint256,uint256) view returns (uint256)
                                     Source: "splitS.mul"
                                    Identifier splitS
                                       Type: uint256
                                       Source: "splitS"
                                  MemberAccess to member marginSplitPercentage
                                     Type: uint8
                                     Source: "state.order.marginSplitPercentage"
                                    MemberAccess to member order
                                       Type: struct LoopringProtocol.Order memory
                                       Source: "state.order"
                                      Identifier state
                                         Type: struct LoopringProtocolImpl.OrderState memory
                                         Source: "state"
                              Identifier MARGIN_SPLIT_PERCENTAGE_BASE
                                 Type: uint256
                                 Source: "MARGIN_SPLIT_PERCENTAGE_BASE"
                      Block
                         Source: "{\r\n                        uint splitB = next.fillAmountS.sub(state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)\r\n                        );\r\n\r\n                        state.splitB = splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        );\r\n                    }"
                        VariableDeclarationStatement
                           Gas costs: [???]
                           Source: "uint splitB = next.fillAmountS.sub(state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)\r\n                        )"
                          VariableDeclaration "splitB"
                             Type: uint256
                             Source: "uint splitB"
                            ElementaryTypeName uint
                               Source: "uint"
                          FunctionCall
                             Type: uint256
                             Source: "next.fillAmountS.sub(state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)\r\n                        )"
                            MemberAccess to member sub
                               Type: function (uint256,uint256) view returns (uint256)
                               Source: "next.fillAmountS.sub"
                              MemberAccess to member fillAmountS
                                 Type: uint256
                                 Source: "next.fillAmountS"
                                Identifier next
                                   Type: struct LoopringProtocolImpl.OrderState memory
                                   Source: "next"
                            FunctionCall
                               Type: uint256
                               Source: "state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div(state.order.amountS)"
                              MemberAccess to member div
                                 Type: function (uint256,uint256) view returns (uint256)
                                 Source: "state.fillAmountS\r\n                            .mul(state.order.amountB)\r\n                            .div"
                                FunctionCall
                                   Type: uint256
                                   Source: "state.fillAmountS\r\n                            .mul(state.order.amountB)"
                                  MemberAccess to member mul
                                     Type: function (uint256,uint256) view returns (uint256)
                                     Source: "state.fillAmountS\r\n                            .mul"
                                    MemberAccess to member fillAmountS
                                       Type: uint256
                                       Source: "state.fillAmountS"
                                      Identifier state
                                         Type: struct LoopringProtocolImpl.OrderState memory
                                         Source: "state"
                                  MemberAccess to member amountB
                                     Type: uint256
                                     Source: "state.order.amountB"
                                    MemberAccess to member order
                                       Type: struct LoopringProtocol.Order memory
                                       Source: "state.order"
                                      Identifier state
                                         Type: struct LoopringProtocolImpl.OrderState memory
                                         Source: "state"
                              MemberAccess to member amountS
                                 Type: uint256
                                 Source: "state.order.amountS"
                                MemberAccess to member order
                                   Type: struct LoopringProtocol.Order memory
                                   Source: "state.order"
                                  Identifier state
                                     Type: struct LoopringProtocolImpl.OrderState memory
                                     Source: "state"
                        ExpressionStatement
                           Gas costs: [???]
                           Source: "state.splitB = splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        )"
                          Assignment using operator =
                             Type: uint256
                             Source: "state.splitB = splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        )"
                            MemberAccess to member splitB
                               Type: uint256
                               Source: "state.splitB"
                              Identifier state
                                 Type: struct LoopringProtocolImpl.OrderState memory
                                 Source: "state"
                            FunctionCall
                               Type: uint256
                               Source: "splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div(\r\n                            MARGIN_SPLIT_PERCENTAGE_BASE\r\n                        )"
                              MemberAccess to member div
                                 Type: function (uint256,uint256) view returns (uint256)
                                 Source: "splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        ).div"
                                FunctionCall
                                   Type: uint256
                                   Source: "splitB.mul(\r\n                            state.order.marginSplitPercentage\r\n                        )"
                                  MemberAccess to member mul
                                     Type: function (uint256,uint256) view returns (uint256)
                                     Source: "splitB.mul"
                                    Identifier splitB
                                       Type: uint256
                                       Source: "splitB"
                                  MemberAccess to member marginSplitPercentage
                                     Type: uint8
                                     Source: "state.order.marginSplitPercentage"
                                    MemberAccess to member order
                                       Type: struct LoopringProtocol.Order memory
                                       Source: "state.order"
                                      Identifier state
                                         Type: struct LoopringProtocolImpl.OrderState memory
                                         Source: "state"
                              Identifier MARGIN_SPLIT_PERCENTAGE_BASE
                                 Type: uint256
                                 Source: "MARGIN_SPLIT_PERCENTAGE_BASE"
                    IfStatement
                       Source: "if (state.splitS > 0 || state.splitB > 0) {\r\n                        minerLrcSpendable = minerLrcSpendable.sub(state.lrcFee);\r\n                        state.lrcReward = state.lrcFee;\r\n                    }"
                      BinaryOperation using operator ||
                         Type: bool
                         Gas costs: [???]
                         Source: "state.splitS > 0 || state.splitB > 0"
                        BinaryOperation using operator >
                           Type: bool
                           Source: "state.splitS > 0"
                          MemberAccess to member splitS
                             Type: uint256
                             Source: "state.splitS"
                            Identifier state
                               Type: struct LoopringProtocolImpl.OrderState memory
                               Source: "state"
                          Literal, token: [no token] value: 0
                             Type: int_const 0
                             Source: "0"
                        BinaryOperation using operator >
                           Type: bool
                           Source: "state.splitB > 0"
                          MemberAccess to member splitB
                             Type: uint256
                             Source: "state.splitB"
                            Identifier state
                               Type: struct LoopringProtocolImpl.OrderState memory
                               Source: "state"
                          Literal, token: [no token] value: 0
                             Type: int_const 0
                             Source: "0"
                      Block
                         Source: "{\r\n                        minerLrcSpendable = minerLrcSpendable.sub(state.lrcFee);\r\n                        state.lrcReward = state.lrcFee;\r\n                    }"
                        ExpressionStatement
                           Gas costs: [???]
                           Source: "minerLrcSpendable = minerLrcSpendable.sub(state.lrcFee)"
                          Assignment using operator =
                             Type: uint256
                             Source: "minerLrcSpendable = minerLrcSpendable.sub(state.lrcFee)"
                            Identifier minerLrcSpendable
                               Type: uint256
                               Source: "minerLrcSpendable"
                            FunctionCall
                               Type: uint256
                               Source: "minerLrcSpendable.sub(state.lrcFee)"
                              MemberAccess to member sub
                                 Type: function (uint256,uint256) view returns (uint256)
                                 Source: "minerLrcSpendable.sub"
                                Identifier minerLrcSpendable
                                   Type: uint256
                                   Source: "minerLrcSpendable"
                              MemberAccess to member lrcFee
                                 Type: uint256
                                 Source: "state.lrcFee"
                                Identifier state
                                   Type: struct LoopringProtocolImpl.OrderState memory
                                   Source: "state"
                        ExpressionStatement
                           Gas costs: [???]
                           Source: "state.lrcReward = state.lrcFee"
                          Assignment using operator =
                             Type: uint256
                             Source: "state.lrcReward = state.lrcFee"
                            MemberAccess to member lrcReward
                               Type: uint256
                               Source: "state.lrcReward"
                              Identifier state
                                 Type: struct LoopringProtocolImpl.OrderState memory
                                 Source: "state"
                            MemberAccess to member lrcFee
                               Type: uint256
                               Source: "state.lrcFee"
                              Identifier state
                                 Type: struct LoopringProtocolImpl.OrderState memory
                                 Source: "state"
                    ExpressionStatement
                       Gas costs: [???]
                       Source: "state.lrcFee = 0"
                      Assignment using operator =
                         Type: uint256
                         Source: "state.lrcFee = 0"
                        MemberAccess to member lrcFee
                           Type: uint256
                           Source: "state.lrcFee"
                          Identifier state
                             Type: struct LoopringProtocolImpl.OrderState memory
                             Source: "state"
                        Literal, token: [no token] value: 0
                           Type: int_const 0
                           Source: "0"
              Block
                 Source: "{\r\n                ErrorLib.error(\"unsupported fee selection value\");\r\n            }"
                ExpressionStatement
                   Gas costs: [???]
                   Source: "ErrorLib.error(\"unsupported fee selection value\")"
                  FunctionCall
                     Type: tuple()
                     Source: "ErrorLib.error(\"unsupported fee selection value\")"
                    MemberAccess to member error
                       Type: function (string memory) view
                       Source: "ErrorLib.error"
                      Identifier ErrorLib
                         Type: type(library ErrorLib)
                         Source: "ErrorLib"
                    Literal, token: [no token] value: unsupported fee selection value
                       Type: literal_string "unsupported fee selection value"
                       Source: "\"unsupported fee selection value\""
  FunctionDefinition "calculateRingFillAmount" - const
     Source: "function calculateRingFillAmount(Ring ring)\r\n        internal\r\n        constant\r\n    {\r\n        uint ringSize = ring.orders.length;\r\n        uint smallestIdx = 0;\r\n        uint i;\r\n        uint j;\r\n\r\n        for (i = 0; i < ringSize; i++) {\r\n            j = i.next(ringSize);\r\n\r\n            uint res = calculateOrderFillAmount(\r\n                ring.orders[i],\r\n                ring.orders[j]\r\n            );\r\n\r\n            if (res == 1) {\r\n                smallestIdx = i;\r\n            } else if (res == 2) {\r\n                smallestIdx = j;\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < smallestIdx; i++) {\r\n            j = i.next(ringSize);\r\n            calculateOrderFillAmount(\r\n                ring.orders[i],\r\n                ring.orders[j]\r\n            );\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Ring ring)"
      VariableDeclaration "ring"
         Type: struct LoopringProtocolImpl.Ring memory
         Source: "Ring ring"
        UserDefinedTypeName "Ring"
           Source: "Ring"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint ringSize = ring.orders.length;\r\n        uint smallestIdx = 0;\r\n        uint i;\r\n        uint j;\r\n\r\n        for (i = 0; i < ringSize; i++) {\r\n            j = i.next(ringSize);\r\n\r\n            uint res = calculateOrderFillAmount(\r\n                ring.orders[i],\r\n                ring.orders[j]\r\n            );\r\n\r\n            if (res == 1) {\r\n                smallestIdx = i;\r\n            } else if (res == 2) {\r\n                smallestIdx = j;\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < smallestIdx; i++) {\r\n            j = i.next(ringSize);\r\n            calculateOrderFillAmount(\r\n                ring.orders[i],\r\n                ring.orders[j]\r\n            );\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint ringSize = ring.orders.length"
        VariableDeclaration "ringSize"
           Type: uint256
           Source: "uint ringSize"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "ring.orders.length"
          MemberAccess to member orders
             Type: struct LoopringProtocolImpl.OrderState memory[] memory
             Source: "ring.orders"
            Identifier ring
               Type: struct LoopringProtocolImpl.Ring memory
               Source: "ring"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint smallestIdx = 0"
        VariableDeclaration "smallestIdx"
           Type: uint256
           Source: "uint smallestIdx"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint i"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint i"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint j"
        VariableDeclaration "j"
           Type: uint256
           Source: "uint j"
          ElementaryTypeName uint
             Source: "uint"
      ForStatement
         Source: "for (i = 0; i < ringSize; i++) {\r\n            j = i.next(ringSize);\r\n\r\n            uint res = calculateOrderFillAmount(\r\n                ring.orders[i],\r\n                ring.orders[j]\r\n            );\r\n\r\n            if (res == 1) {\r\n                smallestIdx = i;\r\n            } else if (res == 2) {\r\n                smallestIdx = j;\r\n            }\r\n        }"
        ExpressionStatement
           Gas costs: 8
           Source: "i = 0"
          Assignment using operator =
             Type: uint256
             Source: "i = 0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < ringSize"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier ringSize
             Type: uint256
             Source: "ringSize"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            j = i.next(ringSize);\r\n\r\n            uint res = calculateOrderFillAmount(\r\n                ring.orders[i],\r\n                ring.orders[j]\r\n            );\r\n\r\n            if (res == 1) {\r\n                smallestIdx = i;\r\n            } else if (res == 2) {\r\n                smallestIdx = j;\r\n            }\r\n        }"
          ExpressionStatement
             Gas costs: 41
             Source: "j = i.next(ringSize)"
            Assignment using operator =
               Type: uint256
               Source: "j = i.next(ringSize)"
              Identifier j
                 Type: uint256
                 Source: "j"
              FunctionCall
                 Type: uint256
                 Source: "i.next(ringSize)"
                MemberAccess to member next
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "i.next"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Identifier ringSize
                   Type: uint256
                   Source: "ringSize"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "uint res = calculateOrderFillAmount(\r\n                ring.orders[i],\r\n                ring.orders[j]\r\n            )"
            VariableDeclaration "res"
               Type: uint256
               Source: "uint res"
              ElementaryTypeName uint
                 Source: "uint"
            FunctionCall
               Type: uint256
               Source: "calculateOrderFillAmount(\r\n                ring.orders[i],\r\n                ring.orders[j]\r\n            )"
              Identifier calculateOrderFillAmount
                 Type: function (struct LoopringProtocolImpl.OrderState memory,struct LoopringProtocolImpl.OrderState memory) view returns (uint256)
                 Source: "calculateOrderFillAmount"
              IndexAccess
                 Type: struct LoopringProtocolImpl.OrderState memory
                 Source: "ring.orders[i]"
                MemberAccess to member orders
                   Type: struct LoopringProtocolImpl.OrderState memory[] memory
                   Source: "ring.orders"
                  Identifier ring
                     Type: struct LoopringProtocolImpl.Ring memory
                     Source: "ring"
                Identifier i
                   Type: uint256
                   Source: "i"
              IndexAccess
                 Type: struct LoopringProtocolImpl.OrderState memory
                 Source: "ring.orders[j]"
                MemberAccess to member orders
                   Type: struct LoopringProtocolImpl.OrderState memory[] memory
                   Source: "ring.orders"
                  Identifier ring
                     Type: struct LoopringProtocolImpl.Ring memory
                     Source: "ring"
                Identifier j
                   Type: uint256
                   Source: "j"
          IfStatement
             Source: "if (res == 1) {\r\n                smallestIdx = i;\r\n            } else if (res == 2) {\r\n                smallestIdx = j;\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 9
               Source: "res == 1"
              Identifier res
                 Type: uint256
                 Source: "res"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            Block
               Source: "{\r\n                smallestIdx = i;\r\n            }"
              ExpressionStatement
                 Gas costs: 8
                 Source: "smallestIdx = i"
                Assignment using operator =
                   Type: uint256
                   Source: "smallestIdx = i"
                  Identifier smallestIdx
                     Type: uint256
                     Source: "smallestIdx"
                  Identifier i
                     Type: uint256
                     Source: "i"
            IfStatement
               Source: "if (res == 2) {\r\n                smallestIdx = j;\r\n            }"
              BinaryOperation using operator ==
                 Type: bool
                 Gas costs: 9
                 Source: "res == 2"
                Identifier res
                   Type: uint256
                   Source: "res"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
              Block
                 Source: "{\r\n                smallestIdx = j;\r\n            }"
                ExpressionStatement
                   Gas costs: 8
                   Source: "smallestIdx = j"
                  Assignment using operator =
                     Type: uint256
                     Source: "smallestIdx = j"
                    Identifier smallestIdx
                       Type: uint256
                       Source: "smallestIdx"
                    Identifier j
                       Type: uint256
                       Source: "j"
      ForStatement
         Source: "for (i = 0; i < smallestIdx; i++) {\r\n            j = i.next(ringSize);\r\n            calculateOrderFillAmount(\r\n                ring.orders[i],\r\n                ring.orders[j]\r\n            );\r\n        }"
        ExpressionStatement
           Gas costs: 8
           Source: "i = 0"
          Assignment using operator =
             Type: uint256
             Source: "i = 0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < smallestIdx"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier smallestIdx
             Type: uint256
             Source: "smallestIdx"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            j = i.next(ringSize);\r\n            calculateOrderFillAmount(\r\n                ring.orders[i],\r\n                ring.orders[j]\r\n            );\r\n        }"
          ExpressionStatement
             Gas costs: 41
             Source: "j = i.next(ringSize)"
            Assignment using operator =
               Type: uint256
               Source: "j = i.next(ringSize)"
              Identifier j
                 Type: uint256
                 Source: "j"
              FunctionCall
                 Type: uint256
                 Source: "i.next(ringSize)"
                MemberAccess to member next
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "i.next"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Identifier ringSize
                   Type: uint256
                   Source: "ringSize"
          ExpressionStatement
             Gas costs: [???]
             Source: "calculateOrderFillAmount(\r\n                ring.orders[i],\r\n                ring.orders[j]\r\n            )"
            FunctionCall
               Type: uint256
               Source: "calculateOrderFillAmount(\r\n                ring.orders[i],\r\n                ring.orders[j]\r\n            )"
              Identifier calculateOrderFillAmount
                 Type: function (struct LoopringProtocolImpl.OrderState memory,struct LoopringProtocolImpl.OrderState memory) view returns (uint256)
                 Source: "calculateOrderFillAmount"
              IndexAccess
                 Type: struct LoopringProtocolImpl.OrderState memory
                 Source: "ring.orders[i]"
                MemberAccess to member orders
                   Type: struct LoopringProtocolImpl.OrderState memory[] memory
                   Source: "ring.orders"
                  Identifier ring
                     Type: struct LoopringProtocolImpl.Ring memory
                     Source: "ring"
                Identifier i
                   Type: uint256
                   Source: "i"
              IndexAccess
                 Type: struct LoopringProtocolImpl.OrderState memory
                 Source: "ring.orders[j]"
                MemberAccess to member orders
                   Type: struct LoopringProtocolImpl.OrderState memory[] memory
                   Source: "ring.orders"
                  Identifier ring
                     Type: struct LoopringProtocolImpl.Ring memory
                     Source: "ring"
                Identifier j
                   Type: uint256
                   Source: "j"
  FunctionDefinition "calculateOrderFillAmount" - const
     Source: "function calculateOrderFillAmount(\r\n        OrderState state,\r\n        OrderState next\r\n        )\r\n        internal\r\n        constant\r\n        returns (uint whichIsSmaller)\r\n    {\r\n        uint fillAmountB = state.fillAmountS.mul(\r\n            state.rate.amountB\r\n        ).div(\r\n            state.rate.amountS\r\n        );\r\n\r\n        if (state.order.buyNoMoreThanAmountB) {\r\n            if (fillAmountB > state.order.amountB) {\r\n                fillAmountB = state.order.amountB;\r\n\r\n                state.fillAmountS = fillAmountB.mul(\r\n                    state.rate.amountS\r\n                ).div(\r\n                    state.rate.amountB\r\n                );\r\n\r\n                whichIsSmaller = 1;\r\n            }\r\n        }\r\n\r\n        state.lrcFee = state.order.lrcFee.mul(\r\n            state.fillAmountS\r\n        ).div(\r\n            state.order.amountS\r\n        );\r\n\r\n        if (fillAmountB <= next.fillAmountS) {\r\n            next.fillAmountS = fillAmountB;\r\n        } else {\r\n            whichIsSmaller = 2;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        OrderState state,\r\n        OrderState next\r\n        )"
      VariableDeclaration "state"
         Type: struct LoopringProtocolImpl.OrderState memory
         Source: "OrderState state"
        UserDefinedTypeName "OrderState"
           Source: "OrderState"
      VariableDeclaration "next"
         Type: struct LoopringProtocolImpl.OrderState memory
         Source: "OrderState next"
        UserDefinedTypeName "OrderState"
           Source: "OrderState"
    ParameterList
       Gas costs: 3
       Source: "(uint whichIsSmaller)"
      VariableDeclaration "whichIsSmaller"
         Type: uint256
         Source: "uint whichIsSmaller"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint fillAmountB = state.fillAmountS.mul(\r\n            state.rate.amountB\r\n        ).div(\r\n            state.rate.amountS\r\n        );\r\n\r\n        if (state.order.buyNoMoreThanAmountB) {\r\n            if (fillAmountB > state.order.amountB) {\r\n                fillAmountB = state.order.amountB;\r\n\r\n                state.fillAmountS = fillAmountB.mul(\r\n                    state.rate.amountS\r\n                ).div(\r\n                    state.rate.amountB\r\n                );\r\n\r\n                whichIsSmaller = 1;\r\n            }\r\n        }\r\n\r\n        state.lrcFee = state.order.lrcFee.mul(\r\n            state.fillAmountS\r\n        ).div(\r\n            state.order.amountS\r\n        );\r\n\r\n        if (fillAmountB <= next.fillAmountS) {\r\n            next.fillAmountS = fillAmountB;\r\n        } else {\r\n            whichIsSmaller = 2;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint fillAmountB = state.fillAmountS.mul(\r\n            state.rate.amountB\r\n        ).div(\r\n            state.rate.amountS\r\n        )"
        VariableDeclaration "fillAmountB"
           Type: uint256
           Source: "uint fillAmountB"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "state.fillAmountS.mul(\r\n            state.rate.amountB\r\n        ).div(\r\n            state.rate.amountS\r\n        )"
          MemberAccess to member div
             Type: function (uint256,uint256) view returns (uint256)
             Source: "state.fillAmountS.mul(\r\n            state.rate.amountB\r\n        ).div"
            FunctionCall
               Type: uint256
               Source: "state.fillAmountS.mul(\r\n            state.rate.amountB\r\n        )"
              MemberAccess to member mul
                 Type: function (uint256,uint256) view returns (uint256)
                 Source: "state.fillAmountS.mul"
                MemberAccess to member fillAmountS
                   Type: uint256
                   Source: "state.fillAmountS"
                  Identifier state
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "state"
              MemberAccess to member amountB
                 Type: uint256
                 Source: "state.rate.amountB"
                MemberAccess to member rate
                   Type: struct LoopringProtocolImpl.Rate memory
                   Source: "state.rate"
                  Identifier state
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "state"
          MemberAccess to member amountS
             Type: uint256
             Source: "state.rate.amountS"
            MemberAccess to member rate
               Type: struct LoopringProtocolImpl.Rate memory
               Source: "state.rate"
              Identifier state
                 Type: struct LoopringProtocolImpl.OrderState memory
                 Source: "state"
      IfStatement
         Source: "if (state.order.buyNoMoreThanAmountB) {\r\n            if (fillAmountB > state.order.amountB) {\r\n                fillAmountB = state.order.amountB;\r\n\r\n                state.fillAmountS = fillAmountB.mul(\r\n                    state.rate.amountS\r\n                ).div(\r\n                    state.rate.amountB\r\n                );\r\n\r\n                whichIsSmaller = 1;\r\n            }\r\n        }"
        MemberAccess to member buyNoMoreThanAmountB
           Type: bool
           Gas costs: [???]
           Source: "state.order.buyNoMoreThanAmountB"
          MemberAccess to member order
             Type: struct LoopringProtocol.Order memory
             Source: "state.order"
            Identifier state
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "state"
        Block
           Source: "{\r\n            if (fillAmountB > state.order.amountB) {\r\n                fillAmountB = state.order.amountB;\r\n\r\n                state.fillAmountS = fillAmountB.mul(\r\n                    state.rate.amountS\r\n                ).div(\r\n                    state.rate.amountB\r\n                );\r\n\r\n                whichIsSmaller = 1;\r\n            }\r\n        }"
          IfStatement
             Source: "if (fillAmountB > state.order.amountB) {\r\n                fillAmountB = state.order.amountB;\r\n\r\n                state.fillAmountS = fillAmountB.mul(\r\n                    state.rate.amountS\r\n                ).div(\r\n                    state.rate.amountB\r\n                );\r\n\r\n                whichIsSmaller = 1;\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: [???]
               Source: "fillAmountB > state.order.amountB"
              Identifier fillAmountB
                 Type: uint256
                 Source: "fillAmountB"
              MemberAccess to member amountB
                 Type: uint256
                 Source: "state.order.amountB"
                MemberAccess to member order
                   Type: struct LoopringProtocol.Order memory
                   Source: "state.order"
                  Identifier state
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "state"
            Block
               Source: "{\r\n                fillAmountB = state.order.amountB;\r\n\r\n                state.fillAmountS = fillAmountB.mul(\r\n                    state.rate.amountS\r\n                ).div(\r\n                    state.rate.amountB\r\n                );\r\n\r\n                whichIsSmaller = 1;\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "fillAmountB = state.order.amountB"
                Assignment using operator =
                   Type: uint256
                   Source: "fillAmountB = state.order.amountB"
                  Identifier fillAmountB
                     Type: uint256
                     Source: "fillAmountB"
                  MemberAccess to member amountB
                     Type: uint256
                     Source: "state.order.amountB"
                    MemberAccess to member order
                       Type: struct LoopringProtocol.Order memory
                       Source: "state.order"
                      Identifier state
                         Type: struct LoopringProtocolImpl.OrderState memory
                         Source: "state"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "state.fillAmountS = fillAmountB.mul(\r\n                    state.rate.amountS\r\n                ).div(\r\n                    state.rate.amountB\r\n                )"
                Assignment using operator =
                   Type: uint256
                   Source: "state.fillAmountS = fillAmountB.mul(\r\n                    state.rate.amountS\r\n                ).div(\r\n                    state.rate.amountB\r\n                )"
                  MemberAccess to member fillAmountS
                     Type: uint256
                     Source: "state.fillAmountS"
                    Identifier state
                       Type: struct LoopringProtocolImpl.OrderState memory
                       Source: "state"
                  FunctionCall
                     Type: uint256
                     Source: "fillAmountB.mul(\r\n                    state.rate.amountS\r\n                ).div(\r\n                    state.rate.amountB\r\n                )"
                    MemberAccess to member div
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "fillAmountB.mul(\r\n                    state.rate.amountS\r\n                ).div"
                      FunctionCall
                         Type: uint256
                         Source: "fillAmountB.mul(\r\n                    state.rate.amountS\r\n                )"
                        MemberAccess to member mul
                           Type: function (uint256,uint256) view returns (uint256)
                           Source: "fillAmountB.mul"
                          Identifier fillAmountB
                             Type: uint256
                             Source: "fillAmountB"
                        MemberAccess to member amountS
                           Type: uint256
                           Source: "state.rate.amountS"
                          MemberAccess to member rate
                             Type: struct LoopringProtocolImpl.Rate memory
                             Source: "state.rate"
                            Identifier state
                               Type: struct LoopringProtocolImpl.OrderState memory
                               Source: "state"
                    MemberAccess to member amountB
                       Type: uint256
                       Source: "state.rate.amountB"
                      MemberAccess to member rate
                         Type: struct LoopringProtocolImpl.Rate memory
                         Source: "state.rate"
                        Identifier state
                           Type: struct LoopringProtocolImpl.OrderState memory
                           Source: "state"
              ExpressionStatement
                 Gas costs: 8
                 Source: "whichIsSmaller = 1"
                Assignment using operator =
                   Type: uint256
                   Source: "whichIsSmaller = 1"
                  Identifier whichIsSmaller
                     Type: uint256
                     Source: "whichIsSmaller"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
      ExpressionStatement
         Gas costs: [???]
         Source: "state.lrcFee = state.order.lrcFee.mul(\r\n            state.fillAmountS\r\n        ).div(\r\n            state.order.amountS\r\n        )"
        Assignment using operator =
           Type: uint256
           Source: "state.lrcFee = state.order.lrcFee.mul(\r\n            state.fillAmountS\r\n        ).div(\r\n            state.order.amountS\r\n        )"
          MemberAccess to member lrcFee
             Type: uint256
             Source: "state.lrcFee"
            Identifier state
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "state"
          FunctionCall
             Type: uint256
             Source: "state.order.lrcFee.mul(\r\n            state.fillAmountS\r\n        ).div(\r\n            state.order.amountS\r\n        )"
            MemberAccess to member div
               Type: function (uint256,uint256) view returns (uint256)
               Source: "state.order.lrcFee.mul(\r\n            state.fillAmountS\r\n        ).div"
              FunctionCall
                 Type: uint256
                 Source: "state.order.lrcFee.mul(\r\n            state.fillAmountS\r\n        )"
                MemberAccess to member mul
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "state.order.lrcFee.mul"
                  MemberAccess to member lrcFee
                     Type: uint256
                     Source: "state.order.lrcFee"
                    MemberAccess to member order
                       Type: struct LoopringProtocol.Order memory
                       Source: "state.order"
                      Identifier state
                         Type: struct LoopringProtocolImpl.OrderState memory
                         Source: "state"
                MemberAccess to member fillAmountS
                   Type: uint256
                   Source: "state.fillAmountS"
                  Identifier state
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "state"
            MemberAccess to member amountS
               Type: uint256
               Source: "state.order.amountS"
              MemberAccess to member order
                 Type: struct LoopringProtocol.Order memory
                 Source: "state.order"
                Identifier state
                   Type: struct LoopringProtocolImpl.OrderState memory
                   Source: "state"
      IfStatement
         Source: "if (fillAmountB <= next.fillAmountS) {\r\n            next.fillAmountS = fillAmountB;\r\n        } else {\r\n            whichIsSmaller = 2;\r\n        }"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: [???]
           Source: "fillAmountB <= next.fillAmountS"
          Identifier fillAmountB
             Type: uint256
             Source: "fillAmountB"
          MemberAccess to member fillAmountS
             Type: uint256
             Source: "next.fillAmountS"
            Identifier next
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "next"
        Block
           Source: "{\r\n            next.fillAmountS = fillAmountB;\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "next.fillAmountS = fillAmountB"
            Assignment using operator =
               Type: uint256
               Source: "next.fillAmountS = fillAmountB"
              MemberAccess to member fillAmountS
                 Type: uint256
                 Source: "next.fillAmountS"
                Identifier next
                   Type: struct LoopringProtocolImpl.OrderState memory
                   Source: "next"
              Identifier fillAmountB
                 Type: uint256
                 Source: "fillAmountB"
        Block
           Source: "{\r\n            whichIsSmaller = 2;\r\n        }"
          ExpressionStatement
             Gas costs: 8
             Source: "whichIsSmaller = 2"
            Assignment using operator =
               Type: uint256
               Source: "whichIsSmaller = 2"
              Identifier whichIsSmaller
                 Type: uint256
                 Source: "whichIsSmaller"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
  FunctionDefinition "scaleRingBasedOnHistoricalRecords" - const
     Source: "function scaleRingBasedOnHistoricalRecords(Ring ring)\r\n        internal\r\n        constant\r\n    {\r\n        uint ringSize = ring.orders.length;\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            var state = ring.orders[i];\r\n            var order = state.order;\r\n\r\n            if (order.buyNoMoreThanAmountB) {\r\n                uint amountB = order.amountB.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                );\r\n\r\n                order.amountS = amountB.mul(order.amountS).div(order.amountB);\r\n                order.lrcFee = amountB.mul(order.lrcFee).div(order.amountB);\r\n\r\n                order.amountB = amountB;\r\n            } else {\r\n                uint amountS = order.amountS.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                );\r\n\r\n                order.amountB = amountS.mul(order.amountB).div(order.amountS);\r\n                order.lrcFee = amountS.mul(order.lrcFee).div(order.amountS);\r\n\r\n                order.amountS = amountS;\r\n            }\r\n\r\n            ErrorLib.check(order.amountS > 0, \"amountS is zero\");\r\n            ErrorLib.check(order.amountB > 0, \"amountB is zero\");\r\n\r\n            state.fillAmountS = order.amountS.min256(state.availableAmountS);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Ring ring)"
      VariableDeclaration "ring"
         Type: struct LoopringProtocolImpl.Ring memory
         Source: "Ring ring"
        UserDefinedTypeName "Ring"
           Source: "Ring"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint ringSize = ring.orders.length;\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            var state = ring.orders[i];\r\n            var order = state.order;\r\n\r\n            if (order.buyNoMoreThanAmountB) {\r\n                uint amountB = order.amountB.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                );\r\n\r\n                order.amountS = amountB.mul(order.amountS).div(order.amountB);\r\n                order.lrcFee = amountB.mul(order.lrcFee).div(order.amountB);\r\n\r\n                order.amountB = amountB;\r\n            } else {\r\n                uint amountS = order.amountS.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                );\r\n\r\n                order.amountB = amountS.mul(order.amountB).div(order.amountS);\r\n                order.lrcFee = amountS.mul(order.lrcFee).div(order.amountS);\r\n\r\n                order.amountS = amountS;\r\n            }\r\n\r\n            ErrorLib.check(order.amountS > 0, \"amountS is zero\");\r\n            ErrorLib.check(order.amountB > 0, \"amountB is zero\");\r\n\r\n            state.fillAmountS = order.amountS.min256(state.availableAmountS);\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint ringSize = ring.orders.length"
        VariableDeclaration "ringSize"
           Type: uint256
           Source: "uint ringSize"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "ring.orders.length"
          MemberAccess to member orders
             Type: struct LoopringProtocolImpl.OrderState memory[] memory
             Source: "ring.orders"
            Identifier ring
               Type: struct LoopringProtocolImpl.Ring memory
               Source: "ring"
      ForStatement
         Source: "for (uint i = 0; i < ringSize; i++) {\r\n            var state = ring.orders[i];\r\n            var order = state.order;\r\n\r\n            if (order.buyNoMoreThanAmountB) {\r\n                uint amountB = order.amountB.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                );\r\n\r\n                order.amountS = amountB.mul(order.amountS).div(order.amountB);\r\n                order.lrcFee = amountB.mul(order.lrcFee).div(order.amountB);\r\n\r\n                order.amountB = amountB;\r\n            } else {\r\n                uint amountS = order.amountS.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                );\r\n\r\n                order.amountB = amountS.mul(order.amountB).div(order.amountS);\r\n                order.lrcFee = amountS.mul(order.lrcFee).div(order.amountS);\r\n\r\n                order.amountS = amountS;\r\n            }\r\n\r\n            ErrorLib.check(order.amountS > 0, \"amountS is zero\");\r\n            ErrorLib.check(order.amountB > 0, \"amountB is zero\");\r\n\r\n            state.fillAmountS = order.amountS.min256(state.availableAmountS);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < ringSize"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier ringSize
             Type: uint256
             Source: "ringSize"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            var state = ring.orders[i];\r\n            var order = state.order;\r\n\r\n            if (order.buyNoMoreThanAmountB) {\r\n                uint amountB = order.amountB.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                );\r\n\r\n                order.amountS = amountB.mul(order.amountS).div(order.amountB);\r\n                order.lrcFee = amountB.mul(order.lrcFee).div(order.amountB);\r\n\r\n                order.amountB = amountB;\r\n            } else {\r\n                uint amountS = order.amountS.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                );\r\n\r\n                order.amountB = amountS.mul(order.amountB).div(order.amountS);\r\n                order.lrcFee = amountS.mul(order.lrcFee).div(order.amountS);\r\n\r\n                order.amountS = amountS;\r\n            }\r\n\r\n            ErrorLib.check(order.amountS > 0, \"amountS is zero\");\r\n            ErrorLib.check(order.amountB > 0, \"amountB is zero\");\r\n\r\n            state.fillAmountS = order.amountS.min256(state.availableAmountS);\r\n        }"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "var state = ring.orders[i]"
            VariableDeclaration "state"
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "var state"
            IndexAccess
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "ring.orders[i]"
              MemberAccess to member orders
                 Type: struct LoopringProtocolImpl.OrderState memory[] memory
                 Source: "ring.orders"
                Identifier ring
                   Type: struct LoopringProtocolImpl.Ring memory
                   Source: "ring"
              Identifier i
                 Type: uint256
                 Source: "i"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "var order = state.order"
            VariableDeclaration "order"
               Type: struct LoopringProtocol.Order memory
               Source: "var order"
            MemberAccess to member order
               Type: struct LoopringProtocol.Order memory
               Source: "state.order"
              Identifier state
                 Type: struct LoopringProtocolImpl.OrderState memory
                 Source: "state"
          IfStatement
             Source: "if (order.buyNoMoreThanAmountB) {\r\n                uint amountB = order.amountB.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                );\r\n\r\n                order.amountS = amountB.mul(order.amountS).div(order.amountB);\r\n                order.lrcFee = amountB.mul(order.lrcFee).div(order.amountB);\r\n\r\n                order.amountB = amountB;\r\n            } else {\r\n                uint amountS = order.amountS.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                );\r\n\r\n                order.amountB = amountS.mul(order.amountB).div(order.amountS);\r\n                order.lrcFee = amountS.mul(order.lrcFee).div(order.amountS);\r\n\r\n                order.amountS = amountS;\r\n            }"
            MemberAccess to member buyNoMoreThanAmountB
               Type: bool
               Gas costs: [???]
               Source: "order.buyNoMoreThanAmountB"
              Identifier order
                 Type: struct LoopringProtocol.Order memory
                 Source: "order"
            Block
               Source: "{\r\n                uint amountB = order.amountB.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                );\r\n\r\n                order.amountS = amountB.mul(order.amountS).div(order.amountB);\r\n                order.lrcFee = amountB.mul(order.lrcFee).div(order.amountB);\r\n\r\n                order.amountB = amountB;\r\n            }"
              VariableDeclarationStatement
                 Gas costs: [???]
                 Source: "uint amountB = order.amountB.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                )"
                VariableDeclaration "amountB"
                   Type: uint256
                   Source: "uint amountB"
                  ElementaryTypeName uint
                     Source: "uint"
                FunctionCall
                   Type: uint256
                   Source: "order.amountB.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                )"
                  MemberAccess to member tolerantSub
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "order.amountB.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub"
                    FunctionCall
                       Type: uint256
                       Source: "order.amountB.sub(\r\n                    filled[state.orderHash]\r\n                )"
                      MemberAccess to member sub
                         Type: function (uint256,uint256) view returns (uint256)
                         Source: "order.amountB.sub"
                        MemberAccess to member amountB
                           Type: uint256
                           Source: "order.amountB"
                          Identifier order
                             Type: struct LoopringProtocol.Order memory
                             Source: "order"
                      IndexAccess
                         Type: uint256
                         Source: "filled[state.orderHash]"
                        Identifier filled
                           Type: mapping(bytes32 => uint256)
                           Source: "filled"
                        MemberAccess to member orderHash
                           Type: bytes32
                           Source: "state.orderHash"
                          Identifier state
                             Type: struct LoopringProtocolImpl.OrderState memory
                             Source: "state"
                  IndexAccess
                     Type: uint256
                     Source: "cancelled[state.orderHash]"
                    Identifier cancelled
                       Type: mapping(bytes32 => uint256)
                       Source: "cancelled"
                    MemberAccess to member orderHash
                       Type: bytes32
                       Source: "state.orderHash"
                      Identifier state
                         Type: struct LoopringProtocolImpl.OrderState memory
                         Source: "state"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "order.amountS = amountB.mul(order.amountS).div(order.amountB)"
                Assignment using operator =
                   Type: uint256
                   Source: "order.amountS = amountB.mul(order.amountS).div(order.amountB)"
                  MemberAccess to member amountS
                     Type: uint256
                     Source: "order.amountS"
                    Identifier order
                       Type: struct LoopringProtocol.Order memory
                       Source: "order"
                  FunctionCall
                     Type: uint256
                     Source: "amountB.mul(order.amountS).div(order.amountB)"
                    MemberAccess to member div
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "amountB.mul(order.amountS).div"
                      FunctionCall
                         Type: uint256
                         Source: "amountB.mul(order.amountS)"
                        MemberAccess to member mul
                           Type: function (uint256,uint256) view returns (uint256)
                           Source: "amountB.mul"
                          Identifier amountB
                             Type: uint256
                             Source: "amountB"
                        MemberAccess to member amountS
                           Type: uint256
                           Source: "order.amountS"
                          Identifier order
                             Type: struct LoopringProtocol.Order memory
                             Source: "order"
                    MemberAccess to member amountB
                       Type: uint256
                       Source: "order.amountB"
                      Identifier order
                         Type: struct LoopringProtocol.Order memory
                         Source: "order"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "order.lrcFee = amountB.mul(order.lrcFee).div(order.amountB)"
                Assignment using operator =
                   Type: uint256
                   Source: "order.lrcFee = amountB.mul(order.lrcFee).div(order.amountB)"
                  MemberAccess to member lrcFee
                     Type: uint256
                     Source: "order.lrcFee"
                    Identifier order
                       Type: struct LoopringProtocol.Order memory
                       Source: "order"
                  FunctionCall
                     Type: uint256
                     Source: "amountB.mul(order.lrcFee).div(order.amountB)"
                    MemberAccess to member div
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "amountB.mul(order.lrcFee).div"
                      FunctionCall
                         Type: uint256
                         Source: "amountB.mul(order.lrcFee)"
                        MemberAccess to member mul
                           Type: function (uint256,uint256) view returns (uint256)
                           Source: "amountB.mul"
                          Identifier amountB
                             Type: uint256
                             Source: "amountB"
                        MemberAccess to member lrcFee
                           Type: uint256
                           Source: "order.lrcFee"
                          Identifier order
                             Type: struct LoopringProtocol.Order memory
                             Source: "order"
                    MemberAccess to member amountB
                       Type: uint256
                       Source: "order.amountB"
                      Identifier order
                         Type: struct LoopringProtocol.Order memory
                         Source: "order"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "order.amountB = amountB"
                Assignment using operator =
                   Type: uint256
                   Source: "order.amountB = amountB"
                  MemberAccess to member amountB
                     Type: uint256
                     Source: "order.amountB"
                    Identifier order
                       Type: struct LoopringProtocol.Order memory
                       Source: "order"
                  Identifier amountB
                     Type: uint256
                     Source: "amountB"
            Block
               Source: "{\r\n                uint amountS = order.amountS.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                );\r\n\r\n                order.amountB = amountS.mul(order.amountB).div(order.amountS);\r\n                order.lrcFee = amountS.mul(order.lrcFee).div(order.amountS);\r\n\r\n                order.amountS = amountS;\r\n            }"
              VariableDeclarationStatement
                 Gas costs: [???]
                 Source: "uint amountS = order.amountS.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                )"
                VariableDeclaration "amountS"
                   Type: uint256
                   Source: "uint amountS"
                  ElementaryTypeName uint
                     Source: "uint"
                FunctionCall
                   Type: uint256
                   Source: "order.amountS.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub(\r\n                    cancelled[state.orderHash]\r\n                )"
                  MemberAccess to member tolerantSub
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "order.amountS.sub(\r\n                    filled[state.orderHash]\r\n                ).tolerantSub"
                    FunctionCall
                       Type: uint256
                       Source: "order.amountS.sub(\r\n                    filled[state.orderHash]\r\n                )"
                      MemberAccess to member sub
                         Type: function (uint256,uint256) view returns (uint256)
                         Source: "order.amountS.sub"
                        MemberAccess to member amountS
                           Type: uint256
                           Source: "order.amountS"
                          Identifier order
                             Type: struct LoopringProtocol.Order memory
                             Source: "order"
                      IndexAccess
                         Type: uint256
                         Source: "filled[state.orderHash]"
                        Identifier filled
                           Type: mapping(bytes32 => uint256)
                           Source: "filled"
                        MemberAccess to member orderHash
                           Type: bytes32
                           Source: "state.orderHash"
                          Identifier state
                             Type: struct LoopringProtocolImpl.OrderState memory
                             Source: "state"
                  IndexAccess
                     Type: uint256
                     Source: "cancelled[state.orderHash]"
                    Identifier cancelled
                       Type: mapping(bytes32 => uint256)
                       Source: "cancelled"
                    MemberAccess to member orderHash
                       Type: bytes32
                       Source: "state.orderHash"
                      Identifier state
                         Type: struct LoopringProtocolImpl.OrderState memory
                         Source: "state"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "order.amountB = amountS.mul(order.amountB).div(order.amountS)"
                Assignment using operator =
                   Type: uint256
                   Source: "order.amountB = amountS.mul(order.amountB).div(order.amountS)"
                  MemberAccess to member amountB
                     Type: uint256
                     Source: "order.amountB"
                    Identifier order
                       Type: struct LoopringProtocol.Order memory
                       Source: "order"
                  FunctionCall
                     Type: uint256
                     Source: "amountS.mul(order.amountB).div(order.amountS)"
                    MemberAccess to member div
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "amountS.mul(order.amountB).div"
                      FunctionCall
                         Type: uint256
                         Source: "amountS.mul(order.amountB)"
                        MemberAccess to member mul
                           Type: function (uint256,uint256) view returns (uint256)
                           Source: "amountS.mul"
                          Identifier amountS
                             Type: uint256
                             Source: "amountS"
                        MemberAccess to member amountB
                           Type: uint256
                           Source: "order.amountB"
                          Identifier order
                             Type: struct LoopringProtocol.Order memory
                             Source: "order"
                    MemberAccess to member amountS
                       Type: uint256
                       Source: "order.amountS"
                      Identifier order
                         Type: struct LoopringProtocol.Order memory
                         Source: "order"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "order.lrcFee = amountS.mul(order.lrcFee).div(order.amountS)"
                Assignment using operator =
                   Type: uint256
                   Source: "order.lrcFee = amountS.mul(order.lrcFee).div(order.amountS)"
                  MemberAccess to member lrcFee
                     Type: uint256
                     Source: "order.lrcFee"
                    Identifier order
                       Type: struct LoopringProtocol.Order memory
                       Source: "order"
                  FunctionCall
                     Type: uint256
                     Source: "amountS.mul(order.lrcFee).div(order.amountS)"
                    MemberAccess to member div
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "amountS.mul(order.lrcFee).div"
                      FunctionCall
                         Type: uint256
                         Source: "amountS.mul(order.lrcFee)"
                        MemberAccess to member mul
                           Type: function (uint256,uint256) view returns (uint256)
                           Source: "amountS.mul"
                          Identifier amountS
                             Type: uint256
                             Source: "amountS"
                        MemberAccess to member lrcFee
                           Type: uint256
                           Source: "order.lrcFee"
                          Identifier order
                             Type: struct LoopringProtocol.Order memory
                             Source: "order"
                    MemberAccess to member amountS
                       Type: uint256
                       Source: "order.amountS"
                      Identifier order
                         Type: struct LoopringProtocol.Order memory
                         Source: "order"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "order.amountS = amountS"
                Assignment using operator =
                   Type: uint256
                   Source: "order.amountS = amountS"
                  MemberAccess to member amountS
                     Type: uint256
                     Source: "order.amountS"
                    Identifier order
                       Type: struct LoopringProtocol.Order memory
                       Source: "order"
                  Identifier amountS
                     Type: uint256
                     Source: "amountS"
          ExpressionStatement
             Gas costs: [???]
             Source: "ErrorLib.check(order.amountS > 0, \"amountS is zero\")"
            FunctionCall
               Type: tuple()
               Source: "ErrorLib.check(order.amountS > 0, \"amountS is zero\")"
              MemberAccess to member check
                 Type: function (bool,string memory) view
                 Source: "ErrorLib.check"
                Identifier ErrorLib
                   Type: type(library ErrorLib)
                   Source: "ErrorLib"
              BinaryOperation using operator >
                 Type: bool
                 Source: "order.amountS > 0"
                MemberAccess to member amountS
                   Type: uint256
                   Source: "order.amountS"
                  Identifier order
                     Type: struct LoopringProtocol.Order memory
                     Source: "order"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              Literal, token: [no token] value: amountS is zero
                 Type: literal_string "amountS is zero"
                 Source: "\"amountS is zero\""
          ExpressionStatement
             Gas costs: [???]
             Source: "ErrorLib.check(order.amountB > 0, \"amountB is zero\")"
            FunctionCall
               Type: tuple()
               Source: "ErrorLib.check(order.amountB > 0, \"amountB is zero\")"
              MemberAccess to member check
                 Type: function (bool,string memory) view
                 Source: "ErrorLib.check"
                Identifier ErrorLib
                   Type: type(library ErrorLib)
                   Source: "ErrorLib"
              BinaryOperation using operator >
                 Type: bool
                 Source: "order.amountB > 0"
                MemberAccess to member amountB
                   Type: uint256
                   Source: "order.amountB"
                  Identifier order
                     Type: struct LoopringProtocol.Order memory
                     Source: "order"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              Literal, token: [no token] value: amountB is zero
                 Type: literal_string "amountB is zero"
                 Source: "\"amountB is zero\""
          ExpressionStatement
             Gas costs: [???]
             Source: "state.fillAmountS = order.amountS.min256(state.availableAmountS)"
            Assignment using operator =
               Type: uint256
               Source: "state.fillAmountS = order.amountS.min256(state.availableAmountS)"
              MemberAccess to member fillAmountS
                 Type: uint256
                 Source: "state.fillAmountS"
                Identifier state
                   Type: struct LoopringProtocolImpl.OrderState memory
                   Source: "state"
              FunctionCall
                 Type: uint256
                 Source: "order.amountS.min256(state.availableAmountS)"
                MemberAccess to member min256
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "order.amountS.min256"
                  MemberAccess to member amountS
                     Type: uint256
                     Source: "order.amountS"
                    Identifier order
                       Type: struct LoopringProtocol.Order memory
                       Source: "order"
                MemberAccess to member availableAmountS
                   Type: uint256
                   Source: "state.availableAmountS"
                  Identifier state
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "state"
  FunctionDefinition "getSpendable" - const
     Source: "function getSpendable(\r\n        address tokenAddress,\r\n        address tokenOwner\r\n        )\r\n        internal\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return TokenTransferDelegate(\r\n            delegateAddress\r\n        ).getSpendable(\r\n            tokenAddress,\r\n            tokenOwner\r\n        );\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address tokenAddress,\r\n        address tokenOwner\r\n        )"
      VariableDeclaration "tokenAddress"
         Type: address
         Source: "address tokenAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "tokenOwner"
         Type: address
         Source: "address tokenOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return TokenTransferDelegate(\r\n            delegateAddress\r\n        ).getSpendable(\r\n            tokenAddress,\r\n            tokenOwner\r\n        );\r\n    }"
      Return
         Gas costs: [???]
         Source: "return TokenTransferDelegate(\r\n            delegateAddress\r\n        ).getSpendable(\r\n            tokenAddress,\r\n            tokenOwner\r\n        )"
        FunctionCall
           Type: uint256
           Source: "TokenTransferDelegate(\r\n            delegateAddress\r\n        ).getSpendable(\r\n            tokenAddress,\r\n            tokenOwner\r\n        )"
          MemberAccess to member getSpendable
             Type: function (address,address) view external returns (uint256)
             Source: "TokenTransferDelegate(\r\n            delegateAddress\r\n        ).getSpendable"
            FunctionCall
               Type: contract TokenTransferDelegate
               Source: "TokenTransferDelegate(\r\n            delegateAddress\r\n        )"
              Identifier TokenTransferDelegate
                 Type: type(contract TokenTransferDelegate)
                 Source: "TokenTransferDelegate"
              Identifier delegateAddress
                 Type: address
                 Source: "delegateAddress"
          Identifier tokenAddress
             Type: address
             Source: "tokenAddress"
          Identifier tokenOwner
             Type: address
             Source: "tokenOwner"
  FunctionDefinition "getLRCSpendable" - const
     Source: "function getLRCSpendable(address tokenOwner)\r\n        internal\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return getSpendable(lrcTokenAddress, tokenOwner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address tokenOwner)"
      VariableDeclaration "tokenOwner"
         Type: address
         Source: "address tokenOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return getSpendable(lrcTokenAddress, tokenOwner);\r\n    }"
      Return
         Gas costs: 262
         Source: "return getSpendable(lrcTokenAddress, tokenOwner)"
        FunctionCall
           Type: uint256
           Source: "getSpendable(lrcTokenAddress, tokenOwner)"
          Identifier getSpendable
             Type: function (address,address) view returns (uint256)
             Source: "getSpendable"
          Identifier lrcTokenAddress
             Type: address
             Source: "lrcTokenAddress"
          Identifier tokenOwner
             Type: address
             Source: "tokenOwner"
  FunctionDefinition "verifyInputDataIntegrity" - const
     Source: "function verifyInputDataIntegrity(\r\n        uint ringSize,\r\n        address[2][]    addressList,\r\n        uint[7][]       uintArgsList,\r\n        uint8[2][]      uint8ArgsList,\r\n        bool[]          buyNoMoreThanAmountBList,\r\n        uint8[]         vList,\r\n        bytes32[]       rList,\r\n        bytes32[]       sList\r\n        )\r\n        internal\r\n        constant\r\n    {\r\n        ErrorLib.check(\r\n            ringSize == addressList.length,\r\n            \"ring data is inconsistent - addressList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize == uintArgsList.length,\r\n            \"ring data is inconsistent - uintArgsList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize == uint8ArgsList.length,\r\n            \"ring data is inconsistent - uint8ArgsList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize == buyNoMoreThanAmountBList.length,\r\n            \"ring data is inconsistent - buyNoMoreThanAmountBList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize + 1 == vList.length,\r\n            \"ring data is inconsistent - vList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize + 1 == rList.length,\r\n            \"ring data is inconsistent - rList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize + 1 == sList.length,\r\n            \"ring data is inconsistent - sList\"\r\n        );\r\n\r\n        // Validate ring-mining related arguments.\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            ErrorLib.check(\r\n                uintArgsList[i][6] > 0,\r\n                \"order rateAmountS is zero\"\r\n            );\r\n\r\n            ErrorLib.check(\r\n                uint8ArgsList[i][1] <= FEE_SELECT_MAX_VALUE,\r\n                \"invalid order fee selection\"\r\n            );\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint ringSize,\r\n        address[2][]    addressList,\r\n        uint[7][]       uintArgsList,\r\n        uint8[2][]      uint8ArgsList,\r\n        bool[]          buyNoMoreThanAmountBList,\r\n        uint8[]         vList,\r\n        bytes32[]       rList,\r\n        bytes32[]       sList\r\n        )"
      VariableDeclaration "ringSize"
         Type: uint256
         Source: "uint ringSize"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "addressList"
         Type: address[2] memory[] memory
         Source: "address[2][]    addressList"
        ArrayTypeName
           Source: "address[2][]"
          ArrayTypeName
             Source: "address[2]"
            ElementaryTypeName address
               Source: "address"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
      VariableDeclaration "uintArgsList"
         Type: uint256[7] memory[] memory
         Source: "uint[7][]       uintArgsList"
        ArrayTypeName
           Source: "uint[7][]"
          ArrayTypeName
             Source: "uint[7]"
            ElementaryTypeName uint
               Source: "uint"
            Literal, token: [no token] value: 7
               Type unknown.
               Source: "7"
      VariableDeclaration "uint8ArgsList"
         Type: uint8[2] memory[] memory
         Source: "uint8[2][]      uint8ArgsList"
        ArrayTypeName
           Source: "uint8[2][]"
          ArrayTypeName
             Source: "uint8[2]"
            ElementaryTypeName uint8
               Source: "uint8"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
      VariableDeclaration "buyNoMoreThanAmountBList"
         Type: bool[] memory
         Source: "bool[]          buyNoMoreThanAmountBList"
        ArrayTypeName
           Source: "bool[]"
          ElementaryTypeName bool
             Source: "bool"
      VariableDeclaration "vList"
         Type: uint8[] memory
         Source: "uint8[]         vList"
        ArrayTypeName
           Source: "uint8[]"
          ElementaryTypeName uint8
             Source: "uint8"
      VariableDeclaration "rList"
         Type: bytes32[] memory
         Source: "bytes32[]       rList"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclaration "sList"
         Type: bytes32[] memory
         Source: "bytes32[]       sList"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        ErrorLib.check(\r\n            ringSize == addressList.length,\r\n            \"ring data is inconsistent - addressList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize == uintArgsList.length,\r\n            \"ring data is inconsistent - uintArgsList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize == uint8ArgsList.length,\r\n            \"ring data is inconsistent - uint8ArgsList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize == buyNoMoreThanAmountBList.length,\r\n            \"ring data is inconsistent - buyNoMoreThanAmountBList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize + 1 == vList.length,\r\n            \"ring data is inconsistent - vList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize + 1 == rList.length,\r\n            \"ring data is inconsistent - rList\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            ringSize + 1 == sList.length,\r\n            \"ring data is inconsistent - sList\"\r\n        );\r\n\r\n        // Validate ring-mining related arguments.\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            ErrorLib.check(\r\n                uintArgsList[i][6] > 0,\r\n                \"order rateAmountS is zero\"\r\n            );\r\n\r\n            ErrorLib.check(\r\n                uint8ArgsList[i][1] <= FEE_SELECT_MAX_VALUE,\r\n                \"invalid order fee selection\"\r\n            );\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            ringSize == addressList.length,\r\n            \"ring data is inconsistent - addressList\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            ringSize == addressList.length,\r\n            \"ring data is inconsistent - addressList\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator ==
             Type: bool
             Source: "ringSize == addressList.length"
            Identifier ringSize
               Type: uint256
               Source: "ringSize"
            MemberAccess to member length
               Type: uint256
               Source: "addressList.length"
              Identifier addressList
                 Type: address[2] memory[] memory
                 Source: "addressList"
          Literal, token: [no token] value: ring data is inconsistent - addressList
             Type: literal_string "ring data is inconsistent - addressList"
             Source: "\"ring data is inconsistent - addressList\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            ringSize == uintArgsList.length,\r\n            \"ring data is inconsistent - uintArgsList\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            ringSize == uintArgsList.length,\r\n            \"ring data is inconsistent - uintArgsList\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator ==
             Type: bool
             Source: "ringSize == uintArgsList.length"
            Identifier ringSize
               Type: uint256
               Source: "ringSize"
            MemberAccess to member length
               Type: uint256
               Source: "uintArgsList.length"
              Identifier uintArgsList
                 Type: uint256[7] memory[] memory
                 Source: "uintArgsList"
          Literal, token: [no token] value: ring data is inconsistent - uintArgsList
             Type: literal_string "ring data is inconsistent - uintArgsList"
             Source: "\"ring data is inconsistent - uintArgsList\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            ringSize == uint8ArgsList.length,\r\n            \"ring data is inconsistent - uint8ArgsList\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            ringSize == uint8ArgsList.length,\r\n            \"ring data is inconsistent - uint8ArgsList\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator ==
             Type: bool
             Source: "ringSize == uint8ArgsList.length"
            Identifier ringSize
               Type: uint256
               Source: "ringSize"
            MemberAccess to member length
               Type: uint256
               Source: "uint8ArgsList.length"
              Identifier uint8ArgsList
                 Type: uint8[2] memory[] memory
                 Source: "uint8ArgsList"
          Literal, token: [no token] value: ring data is inconsistent - uint8ArgsList
             Type: literal_string "ring data is inconsistent - uint8ArgsList"
             Source: "\"ring data is inconsistent - uint8ArgsList\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            ringSize == buyNoMoreThanAmountBList.length,\r\n            \"ring data is inconsistent - buyNoMoreThanAmountBList\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            ringSize == buyNoMoreThanAmountBList.length,\r\n            \"ring data is inconsistent - buyNoMoreThanAmountBList\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator ==
             Type: bool
             Source: "ringSize == buyNoMoreThanAmountBList.length"
            Identifier ringSize
               Type: uint256
               Source: "ringSize"
            MemberAccess to member length
               Type: uint256
               Source: "buyNoMoreThanAmountBList.length"
              Identifier buyNoMoreThanAmountBList
                 Type: bool[] memory
                 Source: "buyNoMoreThanAmountBList"
          Literal, token: [no token] value: ring data is inconsistent - buyNoMoreThanAmountBList
             Type: literal_string "ring data is inconsistent - buyNoMoreThanAmountBList"
             Source: "\"ring data is inconsistent - buyNoMoreThanAmountBList\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            ringSize + 1 == vList.length,\r\n            \"ring data is inconsistent - vList\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            ringSize + 1 == vList.length,\r\n            \"ring data is inconsistent - vList\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator ==
             Type: bool
             Source: "ringSize + 1 == vList.length"
            BinaryOperation using operator +
               Type: uint256
               Source: "ringSize + 1"
              Identifier ringSize
                 Type: uint256
                 Source: "ringSize"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            MemberAccess to member length
               Type: uint256
               Source: "vList.length"
              Identifier vList
                 Type: uint8[] memory
                 Source: "vList"
          Literal, token: [no token] value: ring data is inconsistent - vList
             Type: literal_string "ring data is inconsistent - vList"
             Source: "\"ring data is inconsistent - vList\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            ringSize + 1 == rList.length,\r\n            \"ring data is inconsistent - rList\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            ringSize + 1 == rList.length,\r\n            \"ring data is inconsistent - rList\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator ==
             Type: bool
             Source: "ringSize + 1 == rList.length"
            BinaryOperation using operator +
               Type: uint256
               Source: "ringSize + 1"
              Identifier ringSize
                 Type: uint256
                 Source: "ringSize"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            MemberAccess to member length
               Type: uint256
               Source: "rList.length"
              Identifier rList
                 Type: bytes32[] memory
                 Source: "rList"
          Literal, token: [no token] value: ring data is inconsistent - rList
             Type: literal_string "ring data is inconsistent - rList"
             Source: "\"ring data is inconsistent - rList\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            ringSize + 1 == sList.length,\r\n            \"ring data is inconsistent - sList\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            ringSize + 1 == sList.length,\r\n            \"ring data is inconsistent - sList\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator ==
             Type: bool
             Source: "ringSize + 1 == sList.length"
            BinaryOperation using operator +
               Type: uint256
               Source: "ringSize + 1"
              Identifier ringSize
                 Type: uint256
                 Source: "ringSize"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            MemberAccess to member length
               Type: uint256
               Source: "sList.length"
              Identifier sList
                 Type: bytes32[] memory
                 Source: "sList"
          Literal, token: [no token] value: ring data is inconsistent - sList
             Type: literal_string "ring data is inconsistent - sList"
             Source: "\"ring data is inconsistent - sList\""
      ForStatement
         Source: "for (uint i = 0; i < ringSize; i++) {\r\n            ErrorLib.check(\r\n                uintArgsList[i][6] > 0,\r\n                \"order rateAmountS is zero\"\r\n            );\r\n\r\n            ErrorLib.check(\r\n                uint8ArgsList[i][1] <= FEE_SELECT_MAX_VALUE,\r\n                \"invalid order fee selection\"\r\n            );\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < ringSize"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier ringSize
             Type: uint256
             Source: "ringSize"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            ErrorLib.check(\r\n                uintArgsList[i][6] > 0,\r\n                \"order rateAmountS is zero\"\r\n            );\r\n\r\n            ErrorLib.check(\r\n                uint8ArgsList[i][1] <= FEE_SELECT_MAX_VALUE,\r\n                \"invalid order fee selection\"\r\n            );\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "ErrorLib.check(\r\n                uintArgsList[i][6] > 0,\r\n                \"order rateAmountS is zero\"\r\n            )"
            FunctionCall
               Type: tuple()
               Source: "ErrorLib.check(\r\n                uintArgsList[i][6] > 0,\r\n                \"order rateAmountS is zero\"\r\n            )"
              MemberAccess to member check
                 Type: function (bool,string memory) view
                 Source: "ErrorLib.check"
                Identifier ErrorLib
                   Type: type(library ErrorLib)
                   Source: "ErrorLib"
              BinaryOperation using operator >
                 Type: bool
                 Source: "uintArgsList[i][6] > 0"
                IndexAccess
                   Type: uint256
                   Source: "uintArgsList[i][6]"
                  IndexAccess
                     Type: uint256[7] memory
                     Source: "uintArgsList[i]"
                    Identifier uintArgsList
                       Type: uint256[7] memory[] memory
                       Source: "uintArgsList"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  Literal, token: [no token] value: 6
                     Type: int_const 6
                     Source: "6"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              Literal, token: [no token] value: order rateAmountS is zero
                 Type: literal_string "order rateAmountS is zero"
                 Source: "\"order rateAmountS is zero\""
          ExpressionStatement
             Gas costs: [???]
             Source: "ErrorLib.check(\r\n                uint8ArgsList[i][1] <= FEE_SELECT_MAX_VALUE,\r\n                \"invalid order fee selection\"\r\n            )"
            FunctionCall
               Type: tuple()
               Source: "ErrorLib.check(\r\n                uint8ArgsList[i][1] <= FEE_SELECT_MAX_VALUE,\r\n                \"invalid order fee selection\"\r\n            )"
              MemberAccess to member check
                 Type: function (bool,string memory) view
                 Source: "ErrorLib.check"
                Identifier ErrorLib
                   Type: type(library ErrorLib)
                   Source: "ErrorLib"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "uint8ArgsList[i][1] <= FEE_SELECT_MAX_VALUE"
                IndexAccess
                   Type: uint8
                   Source: "uint8ArgsList[i][1]"
                  IndexAccess
                     Type: uint8[2] memory
                     Source: "uint8ArgsList[i]"
                    Identifier uint8ArgsList
                       Type: uint8[2] memory[] memory
                       Source: "uint8ArgsList"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
                Identifier FEE_SELECT_MAX_VALUE
                   Type: uint256
                   Source: "FEE_SELECT_MAX_VALUE"
              Literal, token: [no token] value: invalid order fee selection
                 Type: literal_string "invalid order fee selection"
                 Source: "\"invalid order fee selection\""
  FunctionDefinition "assembleOrders" - const
     Source: "function assembleOrders(\r\n        uint            ringSize,\r\n        address[2][]    addressList,\r\n        uint[7][]       uintArgsList,\r\n        uint8[2][]      uint8ArgsList,\r\n        bool[]          buyNoMoreThanAmountBList,\r\n        uint8[]         vList,\r\n        bytes32[]       rList,\r\n        bytes32[]       sList\r\n        )\r\n        internal\r\n        constant\r\n        returns (OrderState[])\r\n    {\r\n        var orders = new OrderState[](ringSize);\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            uint j = i.next(ringSize);\r\n\r\n            var order = Order(\r\n                addressList[i][0],\r\n                addressList[i][1],\r\n                addressList[j][1],\r\n                uintArgsList[i][0],\r\n                uintArgsList[i][1],\r\n                uintArgsList[i][2],\r\n                uintArgsList[i][3],\r\n                uintArgsList[i][4],\r\n                uintArgsList[i][5],\r\n                buyNoMoreThanAmountBList[i],\r\n                uint8ArgsList[i][0],\r\n                vList[i],\r\n                rList[i],\r\n                sList[i]\r\n            );\r\n\r\n            bytes32 orderHash = calculateOrderHash(order);\r\n\r\n            verifySignature(\r\n                order.owner,\r\n                orderHash,\r\n                order.v,\r\n                order.r,\r\n                order.s\r\n            );\r\n\r\n            validateOrder(order);\r\n\r\n            orders[i] = OrderState(\r\n                order,\r\n                orderHash,\r\n                uint8ArgsList[i][1],  // feeSelection\r\n                Rate(uintArgsList[i][6], order.amountB),\r\n                getSpendable(order.tokenS, order.owner),\r\n                0,   // fillAmountS\r\n                0,   // lrcReward\r\n                0,   // lrcFee\r\n                0,   // splitS\r\n                0    // splitB\r\n            );\r\n\r\n            ErrorLib.check(\r\n                orders[i].availableAmountS > 0,\r\n                \"order spendable amountS is zero\"\r\n            );\r\n        }\r\n\r\n        return orders;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint            ringSize,\r\n        address[2][]    addressList,\r\n        uint[7][]       uintArgsList,\r\n        uint8[2][]      uint8ArgsList,\r\n        bool[]          buyNoMoreThanAmountBList,\r\n        uint8[]         vList,\r\n        bytes32[]       rList,\r\n        bytes32[]       sList\r\n        )"
      VariableDeclaration "ringSize"
         Type: uint256
         Source: "uint            ringSize"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "addressList"
         Type: address[2] memory[] memory
         Source: "address[2][]    addressList"
        ArrayTypeName
           Source: "address[2][]"
          ArrayTypeName
             Source: "address[2]"
            ElementaryTypeName address
               Source: "address"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
      VariableDeclaration "uintArgsList"
         Type: uint256[7] memory[] memory
         Source: "uint[7][]       uintArgsList"
        ArrayTypeName
           Source: "uint[7][]"
          ArrayTypeName
             Source: "uint[7]"
            ElementaryTypeName uint
               Source: "uint"
            Literal, token: [no token] value: 7
               Type unknown.
               Source: "7"
      VariableDeclaration "uint8ArgsList"
         Type: uint8[2] memory[] memory
         Source: "uint8[2][]      uint8ArgsList"
        ArrayTypeName
           Source: "uint8[2][]"
          ArrayTypeName
             Source: "uint8[2]"
            ElementaryTypeName uint8
               Source: "uint8"
            Literal, token: [no token] value: 2
               Type unknown.
               Source: "2"
      VariableDeclaration "buyNoMoreThanAmountBList"
         Type: bool[] memory
         Source: "bool[]          buyNoMoreThanAmountBList"
        ArrayTypeName
           Source: "bool[]"
          ElementaryTypeName bool
             Source: "bool"
      VariableDeclaration "vList"
         Type: uint8[] memory
         Source: "uint8[]         vList"
        ArrayTypeName
           Source: "uint8[]"
          ElementaryTypeName uint8
             Source: "uint8"
      VariableDeclaration "rList"
         Type: bytes32[] memory
         Source: "bytes32[]       rList"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclaration "sList"
         Type: bytes32[] memory
         Source: "bytes32[]       sList"
        ArrayTypeName
           Source: "bytes32[]"
          ElementaryTypeName bytes32
             Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(OrderState[])"
      VariableDeclaration ""
         Type: struct LoopringProtocolImpl.OrderState memory[] memory
         Source: "OrderState[]"
        ArrayTypeName
           Source: "OrderState[]"
          UserDefinedTypeName "OrderState"
             Source: "OrderState"
    Block
       Source: "{\r\n        var orders = new OrderState[](ringSize);\r\n\r\n        for (uint i = 0; i < ringSize; i++) {\r\n            uint j = i.next(ringSize);\r\n\r\n            var order = Order(\r\n                addressList[i][0],\r\n                addressList[i][1],\r\n                addressList[j][1],\r\n                uintArgsList[i][0],\r\n                uintArgsList[i][1],\r\n                uintArgsList[i][2],\r\n                uintArgsList[i][3],\r\n                uintArgsList[i][4],\r\n                uintArgsList[i][5],\r\n                buyNoMoreThanAmountBList[i],\r\n                uint8ArgsList[i][0],\r\n                vList[i],\r\n                rList[i],\r\n                sList[i]\r\n            );\r\n\r\n            bytes32 orderHash = calculateOrderHash(order);\r\n\r\n            verifySignature(\r\n                order.owner,\r\n                orderHash,\r\n                order.v,\r\n                order.r,\r\n                order.s\r\n            );\r\n\r\n            validateOrder(order);\r\n\r\n            orders[i] = OrderState(\r\n                order,\r\n                orderHash,\r\n                uint8ArgsList[i][1],  // feeSelection\r\n                Rate(uintArgsList[i][6], order.amountB),\r\n                getSpendable(order.tokenS, order.owner),\r\n                0,   // fillAmountS\r\n                0,   // lrcReward\r\n                0,   // lrcFee\r\n                0,   // splitS\r\n                0    // splitB\r\n            );\r\n\r\n            ErrorLib.check(\r\n                orders[i].availableAmountS > 0,\r\n                \"order spendable amountS is zero\"\r\n            );\r\n        }\r\n\r\n        return orders;\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "var orders = new OrderState[](ringSize)"
        VariableDeclaration "orders"
           Type: struct LoopringProtocolImpl.OrderState memory[] memory
           Source: "var orders"
        FunctionCall
           Type: struct LoopringProtocolImpl.OrderState memory[] memory
           Source: "new OrderState[](ringSize)"
          NewExpression
             Type: function (uint256) pure returns (struct LoopringProtocolImpl.OrderState memory[] memory)
             Source: "new OrderState[]"
            ArrayTypeName
               Source: "OrderState[]"
              UserDefinedTypeName "OrderState"
                 Source: "OrderState"
          Identifier ringSize
             Type: uint256
             Source: "ringSize"
      ForStatement
         Source: "for (uint i = 0; i < ringSize; i++) {\r\n            uint j = i.next(ringSize);\r\n\r\n            var order = Order(\r\n                addressList[i][0],\r\n                addressList[i][1],\r\n                addressList[j][1],\r\n                uintArgsList[i][0],\r\n                uintArgsList[i][1],\r\n                uintArgsList[i][2],\r\n                uintArgsList[i][3],\r\n                uintArgsList[i][4],\r\n                uintArgsList[i][5],\r\n                buyNoMoreThanAmountBList[i],\r\n                uint8ArgsList[i][0],\r\n                vList[i],\r\n                rList[i],\r\n                sList[i]\r\n            );\r\n\r\n            bytes32 orderHash = calculateOrderHash(order);\r\n\r\n            verifySignature(\r\n                order.owner,\r\n                orderHash,\r\n                order.v,\r\n                order.r,\r\n                order.s\r\n            );\r\n\r\n            validateOrder(order);\r\n\r\n            orders[i] = OrderState(\r\n                order,\r\n                orderHash,\r\n                uint8ArgsList[i][1],  // feeSelection\r\n                Rate(uintArgsList[i][6], order.amountB),\r\n                getSpendable(order.tokenS, order.owner),\r\n                0,   // fillAmountS\r\n                0,   // lrcReward\r\n                0,   // lrcFee\r\n                0,   // splitS\r\n                0    // splitB\r\n            );\r\n\r\n            ErrorLib.check(\r\n                orders[i].availableAmountS > 0,\r\n                \"order spendable amountS is zero\"\r\n            );\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < ringSize"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier ringSize
             Type: uint256
             Source: "ringSize"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            uint j = i.next(ringSize);\r\n\r\n            var order = Order(\r\n                addressList[i][0],\r\n                addressList[i][1],\r\n                addressList[j][1],\r\n                uintArgsList[i][0],\r\n                uintArgsList[i][1],\r\n                uintArgsList[i][2],\r\n                uintArgsList[i][3],\r\n                uintArgsList[i][4],\r\n                uintArgsList[i][5],\r\n                buyNoMoreThanAmountBList[i],\r\n                uint8ArgsList[i][0],\r\n                vList[i],\r\n                rList[i],\r\n                sList[i]\r\n            );\r\n\r\n            bytes32 orderHash = calculateOrderHash(order);\r\n\r\n            verifySignature(\r\n                order.owner,\r\n                orderHash,\r\n                order.v,\r\n                order.r,\r\n                order.s\r\n            );\r\n\r\n            validateOrder(order);\r\n\r\n            orders[i] = OrderState(\r\n                order,\r\n                orderHash,\r\n                uint8ArgsList[i][1],  // feeSelection\r\n                Rate(uintArgsList[i][6], order.amountB),\r\n                getSpendable(order.tokenS, order.owner),\r\n                0,   // fillAmountS\r\n                0,   // lrcReward\r\n                0,   // lrcFee\r\n                0,   // splitS\r\n                0    // splitB\r\n            );\r\n\r\n            ErrorLib.check(\r\n                orders[i].availableAmountS > 0,\r\n                \"order spendable amountS is zero\"\r\n            );\r\n        }"
          VariableDeclarationStatement
             Gas costs: 44
             Source: "uint j = i.next(ringSize)"
            VariableDeclaration "j"
               Type: uint256
               Source: "uint j"
              ElementaryTypeName uint
                 Source: "uint"
            FunctionCall
               Type: uint256
               Source: "i.next(ringSize)"
              MemberAccess to member next
                 Type: function (uint256,uint256) view returns (uint256)
                 Source: "i.next"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier ringSize
                 Type: uint256
                 Source: "ringSize"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "var order = Order(\r\n                addressList[i][0],\r\n                addressList[i][1],\r\n                addressList[j][1],\r\n                uintArgsList[i][0],\r\n                uintArgsList[i][1],\r\n                uintArgsList[i][2],\r\n                uintArgsList[i][3],\r\n                uintArgsList[i][4],\r\n                uintArgsList[i][5],\r\n                buyNoMoreThanAmountBList[i],\r\n                uint8ArgsList[i][0],\r\n                vList[i],\r\n                rList[i],\r\n                sList[i]\r\n            )"
            VariableDeclaration "order"
               Type: struct LoopringProtocol.Order memory
               Source: "var order"
            FunctionCall
               Type: struct LoopringProtocol.Order memory
               Source: "Order(\r\n                addressList[i][0],\r\n                addressList[i][1],\r\n                addressList[j][1],\r\n                uintArgsList[i][0],\r\n                uintArgsList[i][1],\r\n                uintArgsList[i][2],\r\n                uintArgsList[i][3],\r\n                uintArgsList[i][4],\r\n                uintArgsList[i][5],\r\n                buyNoMoreThanAmountBList[i],\r\n                uint8ArgsList[i][0],\r\n                vList[i],\r\n                rList[i],\r\n                sList[i]\r\n            )"
              Identifier Order
                 Type: type(struct LoopringProtocol.Order storage pointer)
                 Source: "Order"
              IndexAccess
                 Type: address
                 Source: "addressList[i][0]"
                IndexAccess
                   Type: address[2] memory
                   Source: "addressList[i]"
                  Identifier addressList
                     Type: address[2] memory[] memory
                     Source: "addressList"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: address
                 Source: "addressList[i][1]"
                IndexAccess
                   Type: address[2] memory
                   Source: "addressList[i]"
                  Identifier addressList
                     Type: address[2] memory[] memory
                     Source: "addressList"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: address
                 Source: "addressList[j][1]"
                IndexAccess
                   Type: address[2] memory
                   Source: "addressList[j]"
                  Identifier addressList
                     Type: address[2] memory[] memory
                     Source: "addressList"
                  Identifier j
                     Type: uint256
                     Source: "j"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "uintArgsList[i][0]"
                IndexAccess
                   Type: uint256[7] memory
                   Source: "uintArgsList[i]"
                  Identifier uintArgsList
                     Type: uint256[7] memory[] memory
                     Source: "uintArgsList"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "uintArgsList[i][1]"
                IndexAccess
                   Type: uint256[7] memory
                   Source: "uintArgsList[i]"
                  Identifier uintArgsList
                     Type: uint256[7] memory[] memory
                     Source: "uintArgsList"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "uintArgsList[i][2]"
                IndexAccess
                   Type: uint256[7] memory
                   Source: "uintArgsList[i]"
                  Identifier uintArgsList
                     Type: uint256[7] memory[] memory
                     Source: "uintArgsList"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
              IndexAccess
                 Type: uint256
                 Source: "uintArgsList[i][3]"
                IndexAccess
                   Type: uint256[7] memory
                   Source: "uintArgsList[i]"
                  Identifier uintArgsList
                     Type: uint256[7] memory[] memory
                     Source: "uintArgsList"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: [no token] value: 3
                   Type: int_const 3
                   Source: "3"
              IndexAccess
                 Type: uint256
                 Source: "uintArgsList[i][4]"
                IndexAccess
                   Type: uint256[7] memory
                   Source: "uintArgsList[i]"
                  Identifier uintArgsList
                     Type: uint256[7] memory[] memory
                     Source: "uintArgsList"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: [no token] value: 4
                   Type: int_const 4
                   Source: "4"
              IndexAccess
                 Type: uint256
                 Source: "uintArgsList[i][5]"
                IndexAccess
                   Type: uint256[7] memory
                   Source: "uintArgsList[i]"
                  Identifier uintArgsList
                     Type: uint256[7] memory[] memory
                     Source: "uintArgsList"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: [no token] value: 5
                   Type: int_const 5
                   Source: "5"
              IndexAccess
                 Type: bool
                 Source: "buyNoMoreThanAmountBList[i]"
                Identifier buyNoMoreThanAmountBList
                   Type: bool[] memory
                   Source: "buyNoMoreThanAmountBList"
                Identifier i
                   Type: uint256
                   Source: "i"
              IndexAccess
                 Type: uint8
                 Source: "uint8ArgsList[i][0]"
                IndexAccess
                   Type: uint8[2] memory
                   Source: "uint8ArgsList[i]"
                  Identifier uint8ArgsList
                     Type: uint8[2] memory[] memory
                     Source: "uint8ArgsList"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint8
                 Source: "vList[i]"
                Identifier vList
                   Type: uint8[] memory
                   Source: "vList"
                Identifier i
                   Type: uint256
                   Source: "i"
              IndexAccess
                 Type: bytes32
                 Source: "rList[i]"
                Identifier rList
                   Type: bytes32[] memory
                   Source: "rList"
                Identifier i
                   Type: uint256
                   Source: "i"
              IndexAccess
                 Type: bytes32
                 Source: "sList[i]"
                Identifier sList
                   Type: bytes32[] memory
                   Source: "sList"
                Identifier i
                   Type: uint256
                   Source: "i"
          VariableDeclarationStatement
             Gas costs: 26
             Source: "bytes32 orderHash = calculateOrderHash(order)"
            VariableDeclaration "orderHash"
               Type: bytes32
               Source: "bytes32 orderHash"
              ElementaryTypeName bytes32
                 Source: "bytes32"
            FunctionCall
               Type: bytes32
               Source: "calculateOrderHash(order)"
              Identifier calculateOrderHash
                 Type: function (struct LoopringProtocol.Order memory) view returns (bytes32)
                 Source: "calculateOrderHash"
              Identifier order
                 Type: struct LoopringProtocol.Order memory
                 Source: "order"
          ExpressionStatement
             Gas costs: [???]
             Source: "verifySignature(\r\n                order.owner,\r\n                orderHash,\r\n                order.v,\r\n                order.r,\r\n                order.s\r\n            )"
            FunctionCall
               Type: tuple()
               Source: "verifySignature(\r\n                order.owner,\r\n                orderHash,\r\n                order.v,\r\n                order.r,\r\n                order.s\r\n            )"
              Identifier verifySignature
                 Type: function (address,bytes32,uint8,bytes32,bytes32) view
                 Source: "verifySignature"
              MemberAccess to member owner
                 Type: address
                 Source: "order.owner"
                Identifier order
                   Type: struct LoopringProtocol.Order memory
                   Source: "order"
              Identifier orderHash
                 Type: bytes32
                 Source: "orderHash"
              MemberAccess to member v
                 Type: uint8
                 Source: "order.v"
                Identifier order
                   Type: struct LoopringProtocol.Order memory
                   Source: "order"
              MemberAccess to member r
                 Type: bytes32
                 Source: "order.r"
                Identifier order
                   Type: struct LoopringProtocol.Order memory
                   Source: "order"
              MemberAccess to member s
                 Type: bytes32
                 Source: "order.s"
                Identifier order
                   Type: struct LoopringProtocol.Order memory
                   Source: "order"
          ExpressionStatement
             Gas costs: 7
             Source: "validateOrder(order)"
            FunctionCall
               Type: tuple()
               Source: "validateOrder(order)"
              Identifier validateOrder
                 Type: function (struct LoopringProtocol.Order memory) view
                 Source: "validateOrder"
              Identifier order
                 Type: struct LoopringProtocol.Order memory
                 Source: "order"
          ExpressionStatement
             Gas costs: [???]
             Source: "orders[i] = OrderState(\r\n                order,\r\n                orderHash,\r\n                uint8ArgsList[i][1],  // feeSelection\r\n                Rate(uintArgsList[i][6], order.amountB),\r\n                getSpendable(order.tokenS, order.owner),\r\n                0,   // fillAmountS\r\n                0,   // lrcReward\r\n                0,   // lrcFee\r\n                0,   // splitS\r\n                0    // splitB\r\n            )"
            Assignment using operator =
               Type: struct LoopringProtocolImpl.OrderState memory
               Source: "orders[i] = OrderState(\r\n                order,\r\n                orderHash,\r\n                uint8ArgsList[i][1],  // feeSelection\r\n                Rate(uintArgsList[i][6], order.amountB),\r\n                getSpendable(order.tokenS, order.owner),\r\n                0,   // fillAmountS\r\n                0,   // lrcReward\r\n                0,   // lrcFee\r\n                0,   // splitS\r\n                0    // splitB\r\n            )"
              IndexAccess
                 Type: struct LoopringProtocolImpl.OrderState memory
                 Source: "orders[i]"
                Identifier orders
                   Type: struct LoopringProtocolImpl.OrderState memory[] memory
                   Source: "orders"
                Identifier i
                   Type: uint256
                   Source: "i"
              FunctionCall
                 Type: struct LoopringProtocolImpl.OrderState memory
                 Source: "OrderState(\r\n                order,\r\n                orderHash,\r\n                uint8ArgsList[i][1],  // feeSelection\r\n                Rate(uintArgsList[i][6], order.amountB),\r\n                getSpendable(order.tokenS, order.owner),\r\n                0,   // fillAmountS\r\n                0,   // lrcReward\r\n                0,   // lrcFee\r\n                0,   // splitS\r\n                0    // splitB\r\n            )"
                Identifier OrderState
                   Type: type(struct LoopringProtocolImpl.OrderState storage pointer)
                   Source: "OrderState"
                Identifier order
                   Type: struct LoopringProtocol.Order memory
                   Source: "order"
                Identifier orderHash
                   Type: bytes32
                   Source: "orderHash"
                IndexAccess
                   Type: uint8
                   Source: "uint8ArgsList[i][1]"
                  IndexAccess
                     Type: uint8[2] memory
                     Source: "uint8ArgsList[i]"
                    Identifier uint8ArgsList
                       Type: uint8[2] memory[] memory
                       Source: "uint8ArgsList"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
                FunctionCall
                   Type: struct LoopringProtocolImpl.Rate memory
                   Source: "Rate(uintArgsList[i][6], order.amountB)"
                  Identifier Rate
                     Type: type(struct LoopringProtocolImpl.Rate storage pointer)
                     Source: "Rate"
                  IndexAccess
                     Type: uint256
                     Source: "uintArgsList[i][6]"
                    IndexAccess
                       Type: uint256[7] memory
                       Source: "uintArgsList[i]"
                      Identifier uintArgsList
                         Type: uint256[7] memory[] memory
                         Source: "uintArgsList"
                      Identifier i
                         Type: uint256
                         Source: "i"
                    Literal, token: [no token] value: 6
                       Type: int_const 6
                       Source: "6"
                  MemberAccess to member amountB
                     Type: uint256
                     Source: "order.amountB"
                    Identifier order
                       Type: struct LoopringProtocol.Order memory
                       Source: "order"
                FunctionCall
                   Type: uint256
                   Source: "getSpendable(order.tokenS, order.owner)"
                  Identifier getSpendable
                     Type: function (address,address) view returns (uint256)
                     Source: "getSpendable"
                  MemberAccess to member tokenS
                     Type: address
                     Source: "order.tokenS"
                    Identifier order
                       Type: struct LoopringProtocol.Order memory
                       Source: "order"
                  MemberAccess to member owner
                     Type: address
                     Source: "order.owner"
                    Identifier order
                       Type: struct LoopringProtocol.Order memory
                       Source: "order"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
          ExpressionStatement
             Gas costs: [???]
             Source: "ErrorLib.check(\r\n                orders[i].availableAmountS > 0,\r\n                \"order spendable amountS is zero\"\r\n            )"
            FunctionCall
               Type: tuple()
               Source: "ErrorLib.check(\r\n                orders[i].availableAmountS > 0,\r\n                \"order spendable amountS is zero\"\r\n            )"
              MemberAccess to member check
                 Type: function (bool,string memory) view
                 Source: "ErrorLib.check"
                Identifier ErrorLib
                   Type: type(library ErrorLib)
                   Source: "ErrorLib"
              BinaryOperation using operator >
                 Type: bool
                 Source: "orders[i].availableAmountS > 0"
                MemberAccess to member availableAmountS
                   Type: uint256
                   Source: "orders[i].availableAmountS"
                  IndexAccess
                     Type: struct LoopringProtocolImpl.OrderState memory
                     Source: "orders[i]"
                    Identifier orders
                       Type: struct LoopringProtocolImpl.OrderState memory[] memory
                       Source: "orders"
                    Identifier i
                       Type: uint256
                       Source: "i"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              Literal, token: [no token] value: order spendable amountS is zero
                 Type: literal_string "order spendable amountS is zero"
                 Source: "\"order spendable amountS is zero\""
      Return
         Gas costs: 8
         Source: "return orders"
        Identifier orders
           Type: struct LoopringProtocolImpl.OrderState memory[] memory
           Source: "orders"
  FunctionDefinition "validateOrder" - const
     Source: "function validateOrder(Order order)\r\n        internal\r\n        constant\r\n    {\r\n        ErrorLib.check(\r\n            order.owner != address(0),\r\n            \"invalid order owner\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.tokenS != address(0),\r\n            \"invalid order tokenS\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.tokenB != address(0),\r\n            \"invalid order tokenB\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.amountS > 0,\r\n            \"invalid order amountS\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.amountB > 0,\r\n            \"invalid order amountB\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.timestamp <= block.timestamp,\r\n            \"order is too early to match\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.timestamp > cutoffs[order.owner],\r\n            \"order is cut off\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.ttl > 0,\r\n            \"order ttl is 0\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.timestamp + order.ttl > block.timestamp,\r\n            \"order is expired\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.salt > 0,\r\n            \"invalid order salt\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.marginSplitPercentage <= MARGIN_SPLIT_PERCENTAGE_BASE,\r\n            \"invalid order marginSplitPercentage\"\r\n        );\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Order order)"
      VariableDeclaration "order"
         Type: struct LoopringProtocol.Order memory
         Source: "Order order"
        UserDefinedTypeName "Order"
           Source: "Order"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        ErrorLib.check(\r\n            order.owner != address(0),\r\n            \"invalid order owner\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.tokenS != address(0),\r\n            \"invalid order tokenS\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.tokenB != address(0),\r\n            \"invalid order tokenB\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.amountS > 0,\r\n            \"invalid order amountS\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.amountB > 0,\r\n            \"invalid order amountB\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.timestamp <= block.timestamp,\r\n            \"order is too early to match\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.timestamp > cutoffs[order.owner],\r\n            \"order is cut off\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.ttl > 0,\r\n            \"order ttl is 0\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.timestamp + order.ttl > block.timestamp,\r\n            \"order is expired\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.salt > 0,\r\n            \"invalid order salt\"\r\n        );\r\n\r\n        ErrorLib.check(\r\n            order.marginSplitPercentage <= MARGIN_SPLIT_PERCENTAGE_BASE,\r\n            \"invalid order marginSplitPercentage\"\r\n        );\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            order.owner != address(0),\r\n            \"invalid order owner\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            order.owner != address(0),\r\n            \"invalid order owner\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator !=
             Type: bool
             Source: "order.owner != address(0)"
            MemberAccess to member owner
               Type: address
               Source: "order.owner"
              Identifier order
                 Type: struct LoopringProtocol.Order memory
                 Source: "order"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Literal, token: [no token] value: invalid order owner
             Type: literal_string "invalid order owner"
             Source: "\"invalid order owner\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            order.tokenS != address(0),\r\n            \"invalid order tokenS\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            order.tokenS != address(0),\r\n            \"invalid order tokenS\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator !=
             Type: bool
             Source: "order.tokenS != address(0)"
            MemberAccess to member tokenS
               Type: address
               Source: "order.tokenS"
              Identifier order
                 Type: struct LoopringProtocol.Order memory
                 Source: "order"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Literal, token: [no token] value: invalid order tokenS
             Type: literal_string "invalid order tokenS"
             Source: "\"invalid order tokenS\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            order.tokenB != address(0),\r\n            \"invalid order tokenB\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            order.tokenB != address(0),\r\n            \"invalid order tokenB\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator !=
             Type: bool
             Source: "order.tokenB != address(0)"
            MemberAccess to member tokenB
               Type: address
               Source: "order.tokenB"
              Identifier order
                 Type: struct LoopringProtocol.Order memory
                 Source: "order"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Literal, token: [no token] value: invalid order tokenB
             Type: literal_string "invalid order tokenB"
             Source: "\"invalid order tokenB\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            order.amountS > 0,\r\n            \"invalid order amountS\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            order.amountS > 0,\r\n            \"invalid order amountS\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator >
             Type: bool
             Source: "order.amountS > 0"
            MemberAccess to member amountS
               Type: uint256
               Source: "order.amountS"
              Identifier order
                 Type: struct LoopringProtocol.Order memory
                 Source: "order"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: invalid order amountS
             Type: literal_string "invalid order amountS"
             Source: "\"invalid order amountS\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            order.amountB > 0,\r\n            \"invalid order amountB\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            order.amountB > 0,\r\n            \"invalid order amountB\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator >
             Type: bool
             Source: "order.amountB > 0"
            MemberAccess to member amountB
               Type: uint256
               Source: "order.amountB"
              Identifier order
                 Type: struct LoopringProtocol.Order memory
                 Source: "order"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: invalid order amountB
             Type: literal_string "invalid order amountB"
             Source: "\"invalid order amountB\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            order.timestamp <= block.timestamp,\r\n            \"order is too early to match\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            order.timestamp <= block.timestamp,\r\n            \"order is too early to match\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator <=
             Type: bool
             Source: "order.timestamp <= block.timestamp"
            MemberAccess to member timestamp
               Type: uint256
               Source: "order.timestamp"
              Identifier order
                 Type: struct LoopringProtocol.Order memory
                 Source: "order"
            MemberAccess to member timestamp
               Type: uint256
               Source: "block.timestamp"
              Identifier block
                 Type: block
                 Source: "block"
          Literal, token: [no token] value: order is too early to match
             Type: literal_string "order is too early to match"
             Source: "\"order is too early to match\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            order.timestamp > cutoffs[order.owner],\r\n            \"order is cut off\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            order.timestamp > cutoffs[order.owner],\r\n            \"order is cut off\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator >
             Type: bool
             Source: "order.timestamp > cutoffs[order.owner]"
            MemberAccess to member timestamp
               Type: uint256
               Source: "order.timestamp"
              Identifier order
                 Type: struct LoopringProtocol.Order memory
                 Source: "order"
            IndexAccess
               Type: uint256
               Source: "cutoffs[order.owner]"
              Identifier cutoffs
                 Type: mapping(address => uint256)
                 Source: "cutoffs"
              MemberAccess to member owner
                 Type: address
                 Source: "order.owner"
                Identifier order
                   Type: struct LoopringProtocol.Order memory
                   Source: "order"
          Literal, token: [no token] value: order is cut off
             Type: literal_string "order is cut off"
             Source: "\"order is cut off\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            order.ttl > 0,\r\n            \"order ttl is 0\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            order.ttl > 0,\r\n            \"order ttl is 0\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator >
             Type: bool
             Source: "order.ttl > 0"
            MemberAccess to member ttl
               Type: uint256
               Source: "order.ttl"
              Identifier order
                 Type: struct LoopringProtocol.Order memory
                 Source: "order"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: order ttl is 0
             Type: literal_string "order ttl is 0"
             Source: "\"order ttl is 0\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            order.timestamp + order.ttl > block.timestamp,\r\n            \"order is expired\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            order.timestamp + order.ttl > block.timestamp,\r\n            \"order is expired\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator >
             Type: bool
             Source: "order.timestamp + order.ttl > block.timestamp"
            BinaryOperation using operator +
               Type: uint256
               Source: "order.timestamp + order.ttl"
              MemberAccess to member timestamp
                 Type: uint256
                 Source: "order.timestamp"
                Identifier order
                   Type: struct LoopringProtocol.Order memory
                   Source: "order"
              MemberAccess to member ttl
                 Type: uint256
                 Source: "order.ttl"
                Identifier order
                   Type: struct LoopringProtocol.Order memory
                   Source: "order"
            MemberAccess to member timestamp
               Type: uint256
               Source: "block.timestamp"
              Identifier block
                 Type: block
                 Source: "block"
          Literal, token: [no token] value: order is expired
             Type: literal_string "order is expired"
             Source: "\"order is expired\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            order.salt > 0,\r\n            \"invalid order salt\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            order.salt > 0,\r\n            \"invalid order salt\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator >
             Type: bool
             Source: "order.salt > 0"
            MemberAccess to member salt
               Type: uint256
               Source: "order.salt"
              Identifier order
                 Type: struct LoopringProtocol.Order memory
                 Source: "order"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: invalid order salt
             Type: literal_string "invalid order salt"
             Source: "\"invalid order salt\""
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(\r\n            order.marginSplitPercentage <= MARGIN_SPLIT_PERCENTAGE_BASE,\r\n            \"invalid order marginSplitPercentage\"\r\n        )"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(\r\n            order.marginSplitPercentage <= MARGIN_SPLIT_PERCENTAGE_BASE,\r\n            \"invalid order marginSplitPercentage\"\r\n        )"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator <=
             Type: bool
             Source: "order.marginSplitPercentage <= MARGIN_SPLIT_PERCENTAGE_BASE"
            MemberAccess to member marginSplitPercentage
               Type: uint8
               Source: "order.marginSplitPercentage"
              Identifier order
                 Type: struct LoopringProtocol.Order memory
                 Source: "order"
            Identifier MARGIN_SPLIT_PERCENTAGE_BASE
               Type: uint256
               Source: "MARGIN_SPLIT_PERCENTAGE_BASE"
          Literal, token: [no token] value: invalid order marginSplitPercentage
             Type: literal_string "invalid order marginSplitPercentage"
             Source: "\"invalid order marginSplitPercentage\""
  FunctionDefinition "calculateOrderHash" - const
     Source: "function calculateOrderHash(Order order)\r\n        internal\r\n        constant\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            address(this),\r\n            order.owner,\r\n            order.tokenS,\r\n            order.tokenB,\r\n            order.amountS,\r\n            order.amountB,\r\n            order.timestamp,\r\n            order.ttl,\r\n            order.salt,\r\n            order.lrcFee,\r\n            order.buyNoMoreThanAmountB,\r\n            order.marginSplitPercentage\r\n        );\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Order order)"
      VariableDeclaration "order"
         Type: struct LoopringProtocol.Order memory
         Source: "Order order"
        UserDefinedTypeName "Order"
           Source: "Order"
    ParameterList
       Gas costs: 3
       Source: "(bytes32)"
      VariableDeclaration ""
         Type: bytes32
         Source: "bytes32"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        return keccak256(\r\n            address(this),\r\n            order.owner,\r\n            order.tokenS,\r\n            order.tokenB,\r\n            order.amountS,\r\n            order.amountB,\r\n            order.timestamp,\r\n            order.ttl,\r\n            order.salt,\r\n            order.lrcFee,\r\n            order.buyNoMoreThanAmountB,\r\n            order.marginSplitPercentage\r\n        );\r\n    }"
      Return
         Gas costs: [???]
         Source: "return keccak256(\r\n            address(this),\r\n            order.owner,\r\n            order.tokenS,\r\n            order.tokenB,\r\n            order.amountS,\r\n            order.amountB,\r\n            order.timestamp,\r\n            order.ttl,\r\n            order.salt,\r\n            order.lrcFee,\r\n            order.buyNoMoreThanAmountB,\r\n            order.marginSplitPercentage\r\n        )"
        FunctionCall
           Type: bytes32
           Source: "keccak256(\r\n            address(this),\r\n            order.owner,\r\n            order.tokenS,\r\n            order.tokenB,\r\n            order.amountS,\r\n            order.amountB,\r\n            order.timestamp,\r\n            order.ttl,\r\n            order.salt,\r\n            order.lrcFee,\r\n            order.buyNoMoreThanAmountB,\r\n            order.marginSplitPercentage\r\n        )"
          Identifier keccak256
             Type: function () pure returns (bytes32)
             Source: "keccak256"
          FunctionCall
             Type: address
             Source: "address(this)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier this
               Type: contract LoopringProtocolImpl
               Source: "this"
          MemberAccess to member owner
             Type: address
             Source: "order.owner"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
          MemberAccess to member tokenS
             Type: address
             Source: "order.tokenS"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
          MemberAccess to member tokenB
             Type: address
             Source: "order.tokenB"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
          MemberAccess to member amountS
             Type: uint256
             Source: "order.amountS"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
          MemberAccess to member amountB
             Type: uint256
             Source: "order.amountB"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
          MemberAccess to member timestamp
             Type: uint256
             Source: "order.timestamp"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
          MemberAccess to member ttl
             Type: uint256
             Source: "order.ttl"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
          MemberAccess to member salt
             Type: uint256
             Source: "order.salt"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
          MemberAccess to member lrcFee
             Type: uint256
             Source: "order.lrcFee"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
          MemberAccess to member buyNoMoreThanAmountB
             Type: bool
             Source: "order.buyNoMoreThanAmountB"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
          MemberAccess to member marginSplitPercentage
             Type: uint8
             Source: "order.marginSplitPercentage"
            Identifier order
               Type: struct LoopringProtocol.Order memory
               Source: "order"
  FunctionDefinition "verifySignature" - const
     Source: "function verifySignature(\r\n        address signer,\r\n        bytes32 hash,\r\n        uint8   v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        internal\r\n        constant\r\n    {\r\n        address addr = ecrecover(\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n\r\n        ErrorLib.check(signer == addr, \"invalid signature\");\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address signer,\r\n        bytes32 hash,\r\n        uint8   v,\r\n        bytes32 r,\r\n        bytes32 s)"
      VariableDeclaration "signer"
         Type: address
         Source: "address signer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "hash"
         Type: bytes32
         Source: "bytes32 hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "v"
         Type: uint8
         Source: "uint8   v"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "r"
         Type: bytes32
         Source: "bytes32 r"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "s"
         Type: bytes32
         Source: "bytes32 s"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        address addr = ecrecover(\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n\r\n        ErrorLib.check(signer == addr, \"invalid signature\");\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "address addr = ecrecover(\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\r\n            v,\r\n            r,\r\n            s\r\n        )"
        VariableDeclaration "addr"
           Type: address
           Source: "address addr"
          ElementaryTypeName address
             Source: "address"
        FunctionCall
           Type: address
           Source: "ecrecover(\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\r\n            v,\r\n            r,\r\n            s\r\n        )"
          Identifier ecrecover
             Type: function (bytes32,uint8,bytes32,bytes32) pure returns (address)
             Source: "ecrecover"
          FunctionCall
             Type: bytes32
             Source: "keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash)"
            Identifier keccak256
               Type: function () pure returns (bytes32)
               Source: "keccak256"
            Literal, token: [no token] value: Ethereum Signed Message:
32
               Type: literal_string "Ethereum Signed Message:
32"
               Source: "\"\\x19Ethereum Signed Message:\\n32\""
            Identifier hash
               Type: bytes32
               Source: "hash"
          Identifier v
             Type: uint8
             Source: "v"
          Identifier r
             Type: bytes32
             Source: "r"
          Identifier s
             Type: bytes32
             Source: "s"
      ExpressionStatement
         Gas costs: [???]
         Source: "ErrorLib.check(signer == addr, \"invalid signature\")"
        FunctionCall
           Type: tuple()
           Source: "ErrorLib.check(signer == addr, \"invalid signature\")"
          MemberAccess to member check
             Type: function (bool,string memory) view
             Source: "ErrorLib.check"
            Identifier ErrorLib
               Type: type(library ErrorLib)
               Source: "ErrorLib"
          BinaryOperation using operator ==
             Type: bool
             Source: "signer == addr"
            Identifier signer
               Type: address
               Source: "signer"
            Identifier addr
               Type: address
               Source: "addr"
          Literal, token: [no token] value: invalid signature
             Type: literal_string "invalid signature"
             Source: "\"invalid signature\""
