Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x80c1a36dcbdca742f59f09fda16c43e6ad877c2b.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^ 0.4 .15;"
ContractDefinition "ERC20"
   Gas costs: [???]
   Source: "contract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint public totalSupply"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) constant returns (uint);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) constant returns (uint);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint value) returns (bool ok);"
    ParameterList
       Source: "(address to, uint value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint value) returns (bool ok);"
    ParameterList
       Source: "(address from, address to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint value) returns (bool ok);"
    ParameterList
       Source: "(address spender, uint value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "SafeMath"
   Source: "contract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "safeMul"
     Source: "function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 88
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "safeDiv"
     Source: "function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }"
      ExpressionStatement
         Gas costs: 29
         Source: "assert(b > 0)"
        FunctionCall
           Type: tuple()
           Source: "assert(b > 0)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >
             Type: bool
             Source: "b > 0"
            Identifier b
               Type: uint256
               Source: "b"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 74
         Source: "assert(a == b * c + a % b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == b * c + a % b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "a == b * c + a % b"
            Identifier a
               Type: uint256
               Source: "a"
            BinaryOperation using operator +
               Type: uint256
               Source: "b * c + a % b"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "b * c"
                Identifier b
                   Type: uint256
                   Source: "b"
                Identifier c
                   Type: uint256
                   Source: "c"
              BinaryOperation using operator %
                 Type: uint256
                 Source: "a % b"
                Identifier a
                   Type: uint256
                   Source: "a"
                Identifier b
                   Type: uint256
                   Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "safeSub"
     Source: "function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "safeAdd"
     Source: "function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 66
         Source: "assert(c>=a && c>=b)"
        FunctionCall
           Type: tuple()
           Source: "assert(c>=a && c>=b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator &&
             Type: bool
             Source: "c>=a && c>=b"
            BinaryOperation using operator >=
               Type: bool
               Source: "c>=a"
              Identifier c
                 Type: uint256
                 Source: "c"
              Identifier a
                 Type: uint256
                 Source: "a"
            BinaryOperation using operator >=
               Type: bool
               Source: "c>=b"
              Identifier c
                 Type: uint256
                 Source: "c"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is ERC20, SafeMath {\r\n\r\n  mapping(address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  /**\r\n   *\r\n   * Fix for the ERC20 short address attack\r\n   *\r\n   * http://vessenes.com/the-erc20-short-address-attack-explained/\r\n   */\r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length < size + 4) revert();\r\n     _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value)  returns (bool success) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert();\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint) balances"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint
           Source: "uint"
  ModifierDefinition "onlyPayloadSize"
     Source: "modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length < size + 4) revert();\r\n     _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint size)"
      VariableDeclaration "size"
         Type: uint256
         Source: "uint size"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n     if(msg.data.length < size + 4) revert();\r\n     _;\r\n  }"
      IfStatement
         Source: "if(msg.data.length < size + 4) revert()"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 22
           Source: "msg.data.length < size + 4"
          MemberAccess to member length
             Type: uint256
             Source: "msg.data.length"
            MemberAccess to member data
               Type: bytes calldata
               Source: "msg.data"
              Identifier msg
                 Type: msg
                 Source: "msg"
          BinaryOperation using operator +
             Type: uint256
             Source: "size + 4"
            Identifier size
               Type: uint256
               Source: "size"
            Literal, token: [no token] value: 4
               Type: int_const 4
               Source: "4"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 3
       Source: "onlyPayloadSize(2 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 64
         Source: "2 * 32"
        Literal, token: [no token] value: 2
           Type: int_const 2
           Source: "2"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 20422
         Source: "balances[msg.sender] = safeSub(balances[msg.sender], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = safeSub(balances[msg.sender], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "safeSub(balances[msg.sender], _value)"
            Identifier safeSub
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeSub"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20418
         Source: "balances[_to] = safeAdd(balances[_to], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = safeAdd(balances[_to], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "safeAdd(balances[_to], _value)"
            Identifier safeAdd
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeAdd"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value)  returns (bool success) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 396
         Source: "var _allowance = allowed[_from][msg.sender]"
        VariableDeclaration "_allowance"
           Type: uint256
           Source: "var _allowance"
        IndexAccess
           Type: uint256
           Source: "allowed[_from][msg.sender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_from]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _from
               Type: address
               Source: "_from"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20407
         Source: "balances[_to] = safeAdd(balances[_to], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = safeAdd(balances[_to], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "safeAdd(balances[_to], _value)"
            Identifier safeAdd
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeAdd"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20407
         Source: "balances[_from] = safeSub(balances[_from], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_from] = safeSub(balances[_from], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "safeSub(balances[_from], _value)"
            Identifier safeSub
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeSub"
            IndexAccess
               Type: uint256
               Source: "balances[_from]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20217
         Source: "allowed[_from][msg.sender] = safeSub(_allowance, _value)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[_from][msg.sender] = safeSub(_allowance, _value)"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "safeSub(_allowance, _value)"
            Identifier safeSub
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeSub"
            Identifier _allowance
               Type: uint256
               Source: "_allowance"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint balance"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return balances[_owner];\r\n  }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert();\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert();\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
      IfStatement
         Source: "if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert()"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 431
           Source: "(_value != 0) && (allowed[msg.sender][_spender] != 0)"
          TupleExpression
             Type: bool
             Source: "(_value != 0)"
            BinaryOperation using operator !=
               Type: bool
               Source: "_value != 0"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          TupleExpression
             Type: bool
             Source: "(allowed[msg.sender][_spender] != 0)"
            BinaryOperation using operator !=
               Type: bool
               Source: "allowed[msg.sender][_spender] != 0"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint remaining"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return allowed[_owner][_spender];\r\n  }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
ContractDefinition "owned"
   Source: "contract owned {\r\n    address owner;\r\n\r\n    modifier onlyOwner() {\r\n      require(msg.sender == owner);\r\n      _;\r\n    }\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: 0
     Source: "address owner"
    ElementaryTypeName address
       Source: "address"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n      require(msg.sender == owner);\r\n      _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n      require(msg.sender == owner);\r\n      _;\r\n    }"
      ExpressionStatement
         Gas costs: 564
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 2
         Source: "_"
ContractDefinition "Fish"
   Source: "contract Fish is owned, StandardToken {\r\n\r\n  string public constant TermsOfUse = \"https://github.com/triangles-things/fish.project/blob/master/terms-of-use.md\";\r\n\r\n  /*\r\n   * State variables\r\n   */\r\n\r\n  string public constant symbol = \"FSH\";\r\n  string public constant name = \"Fish\";\r\n  uint8 public constant decimals = 3;\r\n\r\n  /*\r\n   * Constructor function\r\n   */\r\n\r\n  function Fish() {\r\n    owner = msg.sender;\r\n    balances[msg.sender] = 1;                                                   // Owner can now be a referral\r\n    totalSupply = 1;\r\n    buyPrice_wie= 100000000000000;                                              // 100 szabo per one token. One unit = 1000 tokens. 1 ether = 10 units\r\n    sellPrice_wie = buyPrice_wie * sell_ppc / 100;\r\n  }\r\n\r\n  function () payable { revert(); }\r\n\r\n  /*\r\n   * SECTION: PRICE GROWTH\r\n   *\r\n   * This section is responsible for daily price increase. Once per day the buy price will be increased \r\n   * through adjustPrice modifier. The price update happens before buy and sell functions are executed.\r\n   * Contract owner has only one way to control the growth rate here - setGrowth.\r\n   */\r\n\r\n  // Growth rate is present in parts per million (ppm)\r\n  uint32 public dailyGrowth_ppm = 6100;                                         // default growth is 20% (0.61% per day)\r\n  uint public dailyGrowthUpdated_date = now;                                    // Don't update it on first day of contract\r\n  \r\n  uint32 private constant dailyGrowthMin_ppm =  6096;                           // 20% every month in price growth or 0.00610 daily\r\n  uint32 private constant dailyGrowthMax_ppm = 23374;                           // 100% in growth every month or 0,02337 daily\r\n  \r\n  uint32 public constant sell_ppc = 90;                                         // Sell price is 90% of buy price\r\n\r\n  event DailyGrowthUpdate(uint _newRate_ppm);\r\n  event PriceAdjusted(uint _newBuyPrice_wei, uint _newSellPrice_wei);\r\n\r\n  /*\r\n   * MODIFIER\r\n   * If last update happened more than one day ago, update the price, save the time of current price update\r\n   * Adjust sell price and log the event\r\n   */\r\n  modifier adjustPrice() {\r\n    if ( (dailyGrowthUpdated_date + 1 days) < now ) {\r\n      dailyGrowthUpdated_date = now;\r\n      buyPrice_wie = buyPrice_wie * (1000000 + dailyGrowth_ppm) / 1000000;\r\n      sellPrice_wie = buyPrice_wie * sell_ppc / 100;\r\n      PriceAdjusted(buyPrice_wie, sellPrice_wie);\r\n    }\r\n    _;\r\n  }\r\n\r\n  /* \r\n   * OWNER ONLY; EXTERNAL METHOD\r\n   * setGrowth can accept values within range from 20% to 100% of growth per month (based on 30 days per month assumption).\r\n   * \r\n   *   Formula is:\r\n   *\r\n   *       buyPrice_eth = buyPrice_eth * (1000000 + dailyGrowthMin_ppm) / 1000000;\r\n   *       ^new value     ^current value  ^1.0061 (if dailyGrowth_ppm == 6100)\r\n   *\r\n   *       1.0061^30 = 1.20 (if dailyGrowth_ppm == 6100)\r\n   *       1.023374^30 = 2 (if dailyGrowth_ppm == 23374)\r\n   * \r\n   *  Some other daily rates\r\n   *\r\n   *   Per month -> Value in ppm\r\n   *      1.3    ->  8783\r\n   *      1.4    -> 11278\r\n   *      1.5    -> 13607\r\n   *      1.6    -> 15790\r\n   *      1.7    -> 17844\r\n   *      1.8    -> 19786\r\n   */\r\n  function setGrowth(uint32 _newGrowth_ppm) onlyOwner external returns(bool result) {\r\n    if (_newGrowth_ppm >= dailyGrowthMin_ppm &&\r\n        _newGrowth_ppm <= dailyGrowthMax_ppm\r\n    ) {\r\n      dailyGrowth_ppm = _newGrowth_ppm;\r\n      DailyGrowthUpdate(_newGrowth_ppm);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /* \r\n   * SECTION: TRADING\r\n   *\r\n   * This section is responsible purely for trading the tokens. User can buy tokens, user can sell tokens.\r\n   *\r\n   */\r\n\r\n  uint256 public sellPrice_wie;\r\n  uint256 public buyPrice_wie;\r\n\r\n  /*\r\n   * EXTERNAL METHOD\r\n   * User can buy arbitrary amount of tokens. Before amount of tokens will be calculated, the price of tokens \r\n   * has to be adjusted. This happens in adjustPrice modified before function call.\r\n   *\r\n   * Short description of this method\r\n   *\r\n   *   Calculate tokens that user is buying\r\n   *   Assign awards ro refereals\r\n   *   Add some bounty for new users who set referral before first buy\r\n   *   Send tokens that belong to contract or if there is non issue more and send them to user\r\n   *\r\n   * Read -> https://github.com/triangles-things/fish.project/blob/master/terms-of-use.md\r\n   */\r\n  function buy() adjustPrice payable external {\r\n    require(msg.value >= buyPrice_wie);\r\n    var amount = safeDiv(msg.value, buyPrice_wie);\r\n\r\n    assignBountryToReferals(msg.sender, amount);                                // First assign bounty\r\n\r\n    // Buy discount if User is a new user and has set referral\r\n    if ( balances[msg.sender] == 0 && referrals[msg.sender][0] != 0 ) {\r\n      // Check that user has to wait at least two weeks before he get break even on what he will get\r\n      amount = amount * (100 + landingDiscount_ppc) / 100;\r\n    }\r\n\r\n    issueTo(msg.sender, amount);\r\n  }\r\n\r\n  /*\r\n   * EXTERNAL METHOD\r\n   * User can sell tokens back to contract.\r\n   *\r\n   * Short description of this method\r\n   *\r\n   *   Adjust price\r\n   *   Calculate tokens price that user is selling \r\n   *   Make all possible checks\r\n   *   Transfer the money\r\n   */\r\n  function sell(uint256 _amount) adjustPrice external {\r\n    require(_amount > 0 && balances[msg.sender] >= _amount);\r\n    uint moneyWorth = safeMul(_amount, sellPrice_wie);\r\n    require(this.balance > moneyWorth);                                         // We can't sell if we don't have enough money\r\n    \r\n    if (\r\n        balances[this] + _amount > balances[this] &&\r\n        balances[msg.sender] - _amount < balances[msg.sender]\r\n    ) {\r\n      balances[this] = safeAdd(balances[this], _amount);                        // adds the amount to owner's balance\r\n      balances[msg.sender] = safeSub(balances[msg.sender], _amount);            // subtracts the amount from seller's balance\r\n      if (!msg.sender.send(moneyWorth)) {                                       // sends ether to the seller. It's important\r\n        revert();                                                               // to do this last to avoid recursion attacks\r\n      } else {\r\n        Transfer(msg.sender, this, _amount);                                    // executes an event reflecting on the change\r\n      }        \r\n    } else {\r\n      revert();                                                                 // checks if the sender has enough to sell\r\n    }  \r\n  }\r\n\r\n  /*\r\n   * PRIVATE METHOD\r\n   * Issue  new tokens to contract\r\n   */\r\n  function issueTo(address _beneficiary, uint256 _amount_tkns) private {\r\n    if (\r\n        balances[this] >= _amount_tkns\r\n    ) {\r\n      // All tokens are taken from balance\r\n      balances[this] = safeSub(balances[this], _amount_tkns);\r\n      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\r\n    } else {\r\n      // Balance will be lowered and new tokens will be issued\r\n      uint diff = safeSub(_amount_tkns, balances[this]);\r\n\r\n      totalSupply = safeAdd(totalSupply, diff);\r\n      balances[this] = 0;\r\n      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\r\n    }\r\n    \r\n    Transfer(this, _beneficiary, _amount_tkns);\r\n  }\r\n  \r\n  /*\r\n   * SECTION: BOUNTIES\r\n   *\r\n   * This section describes all possible awards.\r\n   */\r\n    \r\n  mapping(address => address[3]) referrals;\r\n  mapping(address => uint256) bounties;\r\n\r\n  uint32 public constant landingDiscount_ppc = 4;                               // Landing discount is 4%\r\n\r\n  /*\r\n   * EXTERNAL METHOD \r\n   * Set your referral first. You will get 4% more tokens on your first buy and trigger a\r\n   * reward of whoever told you about this contract. A win-win scenario.\r\n   */\r\n  function referral(address _referral) external returns(bool) {\r\n    if ( balances[_referral] > 0 &&                                              // Referral participated already\r\n         balances[msg.sender] == 0  &&                                          // Sender is a new user\r\n         referrals[msg.sender][0] == 0                                           // Not returning user. User can not reassign their referrals but they can assign them later on\r\n    ) {\r\n      var referral_referrals = referrals[_referral];\r\n      referrals[msg.sender] = [_referral, referral_referrals[0], referral_referrals[1]];\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /*\r\n   * PRIVATE METHOD\r\n   * Award bounties to referrals.\r\n   */ \r\n  function assignBountryToReferals(address _referralsOf, uint256 _amount) private {\r\n    var refs = referrals[_referralsOf];\r\n    \r\n    if (refs[0] != 0) {\r\n     issueTo(refs[0], (_amount * 4) / 100);                                     // 4% bounty to direct referral\r\n      if (refs[1] != 0) {\r\n        issueTo(refs[1], (_amount * 2) / 100);                                  // 2% bounty to referral of referral\r\n        if (refs[2] != 0) {\r\n          issueTo(refs[2], (_amount * 1) / 100);                                // 1% bounty to referral of referral of referral\r\n       }\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n   * OWNER ONLY; EXTERNAL METHOD\r\n   * Santa is coming! Who ever made impact to promote the Fish and can prove it will get the bonus\r\n   */\r\n  function assignBounty(address _account, uint256 _amount) onlyOwner external returns(bool) {\r\n    require(_amount > 0); \r\n     \r\n    if (balances[_account] > 0 &&                                               // Account had participated already\r\n        bounties[_account] + _amount <= 1000000                                 // no more than 100 token units per account\r\n    ) {\r\n      issueTo(_account, _amount);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "owned"
    UserDefinedTypeName "owned"
       Source: "owned"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  VariableDeclaration "TermsOfUse"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant TermsOfUse = \"https://github.com/triangles-things/fish.project/blob/master/terms-of-use.md\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: https://github.com/triangles-things/fish.project/blob/master/terms-of-use.md
       Type: literal_string "https://github.com/triangles-things/fish.project/blob/master/terms-of-use.md"
       Source: "\"https://github.com/triangles-things/fish.project/blob/master/terms-of-use.md\""
  VariableDeclaration "symbol"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant symbol = \"FSH\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: FSH
       Type: literal_string "FSH"
       Source: "\"FSH\""
  VariableDeclaration "name"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant name = \"Fish\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Fish
       Type: literal_string "Fish"
       Source: "\"Fish\""
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: [???]
     Source: "uint8 public constant decimals = 3"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 3
       Type: int_const 3
       Source: "3"
  FunctionDefinition "Fish" - public
     Source: "function Fish() {\r\n    owner = msg.sender;\r\n    balances[msg.sender] = 1;                                                   // Owner can now be a referral\r\n    totalSupply = 1;\r\n    buyPrice_wie= 100000000000000;                                              // 100 szabo per one token. One unit = 1000 tokens. 1 ether = 10 units\r\n    sellPrice_wie = buyPrice_wie * sell_ppc / 100;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    owner = msg.sender;\r\n    balances[msg.sender] = 1;                                                   // Owner can now be a referral\r\n    totalSupply = 1;\r\n    buyPrice_wie= 100000000000000;                                              // 100 szabo per one token. One unit = 1000 tokens. 1 ether = 10 units\r\n    sellPrice_wie = buyPrice_wie * sell_ppc / 100;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] = 1"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = 1"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = 1"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = 1"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "buyPrice_wie= 100000000000000"
        Assignment using operator =
           Type: uint256
           Source: "buyPrice_wie= 100000000000000"
          Identifier buyPrice_wie
             Type: uint256
             Source: "buyPrice_wie"
          Literal, token: [no token] value: 100000000000000
             Type: int_const 100000000000000
             Source: "100000000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "sellPrice_wie = buyPrice_wie * sell_ppc / 100"
        Assignment using operator =
           Type: uint256
           Source: "sellPrice_wie = buyPrice_wie * sell_ppc / 100"
          Identifier sellPrice_wie
             Type: uint256
             Source: "sellPrice_wie"
          BinaryOperation using operator /
             Type: uint256
             Source: "buyPrice_wie * sell_ppc / 100"
            BinaryOperation using operator *
               Type: uint256
               Source: "buyPrice_wie * sell_ppc"
              Identifier buyPrice_wie
                 Type: uint256
                 Source: "buyPrice_wie"
              Identifier sell_ppc
                 Type: uint32
                 Source: "sell_ppc"
            Literal, token: [no token] value: 100
               Type: int_const 100
               Source: "100"
  FunctionDefinition "" - public
     Source: "function () payable { revert(); }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ revert(); }"
      ExpressionStatement
         Gas costs: 6
         Source: "revert()"
        FunctionCall
           Type: tuple()
           Source: "revert()"
          Identifier revert
             Type: function () pure
             Source: "revert"
  VariableDeclaration "dailyGrowth_ppm"
     Type: uint32
     Gas costs: [???]
     Source: "uint32 public dailyGrowth_ppm = 6100"
    ElementaryTypeName uint32
       Source: "uint32"
    Literal, token: [no token] value: 6100
       Type: int_const 6100
       Source: "6100"
  VariableDeclaration "dailyGrowthUpdated_date"
     Type: uint256
     Gas costs: [???]
     Source: "uint public dailyGrowthUpdated_date = now"
    ElementaryTypeName uint
       Source: "uint"
    Identifier now
       Type: uint256
       Source: "now"
  VariableDeclaration "dailyGrowthMin_ppm"
     Type: uint32
     Gas costs: 3
     Source: "uint32 private constant dailyGrowthMin_ppm =  6096"
    ElementaryTypeName uint32
       Source: "uint32"
    Literal, token: [no token] value: 6096
       Type: int_const 6096
       Source: "6096"
  VariableDeclaration "dailyGrowthMax_ppm"
     Type: uint32
     Gas costs: 3
     Source: "uint32 private constant dailyGrowthMax_ppm = 23374"
    ElementaryTypeName uint32
       Source: "uint32"
    Literal, token: [no token] value: 23374
       Type: int_const 23374
       Source: "23374"
  VariableDeclaration "sell_ppc"
     Type: uint32
     Gas costs: [???]
     Source: "uint32 public constant sell_ppc = 90"
    ElementaryTypeName uint32
       Source: "uint32"
    Literal, token: [no token] value: 90
       Type: int_const 90
       Source: "90"
  EventDefinition "DailyGrowthUpdate"
     Gas costs: 0
     Source: "event DailyGrowthUpdate(uint _newRate_ppm);"
    ParameterList
       Source: "(uint _newRate_ppm)"
      VariableDeclaration "_newRate_ppm"
         Type: uint256
         Source: "uint _newRate_ppm"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "PriceAdjusted"
     Gas costs: 0
     Source: "event PriceAdjusted(uint _newBuyPrice_wei, uint _newSellPrice_wei);"
    ParameterList
       Source: "(uint _newBuyPrice_wei, uint _newSellPrice_wei)"
      VariableDeclaration "_newBuyPrice_wei"
         Type: uint256
         Source: "uint _newBuyPrice_wei"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_newSellPrice_wei"
         Type: uint256
         Source: "uint _newSellPrice_wei"
        ElementaryTypeName uint
           Source: "uint"
  ModifierDefinition "adjustPrice"
     Source: "modifier adjustPrice() {\r\n    if ( (dailyGrowthUpdated_date + 1 days) < now ) {\r\n      dailyGrowthUpdated_date = now;\r\n      buyPrice_wie = buyPrice_wie * (1000000 + dailyGrowth_ppm) / 1000000;\r\n      sellPrice_wie = buyPrice_wie * sell_ppc / 100;\r\n      PriceAdjusted(buyPrice_wie, sellPrice_wie);\r\n    }\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    if ( (dailyGrowthUpdated_date + 1 days) < now ) {\r\n      dailyGrowthUpdated_date = now;\r\n      buyPrice_wie = buyPrice_wie * (1000000 + dailyGrowth_ppm) / 1000000;\r\n      sellPrice_wie = buyPrice_wie * sell_ppc / 100;\r\n      PriceAdjusted(buyPrice_wie, sellPrice_wie);\r\n    }\r\n    _;\r\n  }"
      IfStatement
         Source: "if ( (dailyGrowthUpdated_date + 1 days) < now ) {\r\n      dailyGrowthUpdated_date = now;\r\n      buyPrice_wie = buyPrice_wie * (1000000 + dailyGrowth_ppm) / 1000000;\r\n      sellPrice_wie = buyPrice_wie * sell_ppc / 100;\r\n      PriceAdjusted(buyPrice_wie, sellPrice_wie);\r\n    }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 428
           Source: "(dailyGrowthUpdated_date + 1 days) < now"
          TupleExpression
             Type: uint256
             Source: "(dailyGrowthUpdated_date + 1 days)"
            BinaryOperation using operator +
               Type: uint256
               Source: "dailyGrowthUpdated_date + 1 days"
              Identifier dailyGrowthUpdated_date
                 Type: uint256
                 Source: "dailyGrowthUpdated_date"
              Literal, token: [no token] value: 1
                 Type: int_const 86400
                 Source: "1 days"
          Identifier now
             Type: uint256
             Source: "now"
        Block
           Source: "{\r\n      dailyGrowthUpdated_date = now;\r\n      buyPrice_wie = buyPrice_wie * (1000000 + dailyGrowth_ppm) / 1000000;\r\n      sellPrice_wie = buyPrice_wie * sell_ppc / 100;\r\n      PriceAdjusted(buyPrice_wie, sellPrice_wie);\r\n    }"
          ExpressionStatement
             Gas costs: 40026
             Source: "dailyGrowthUpdated_date = now"
            Assignment using operator =
               Type: uint256
               Source: "dailyGrowthUpdated_date = now"
              Identifier dailyGrowthUpdated_date
                 Type: uint256
                 Source: "dailyGrowthUpdated_date"
              Identifier now
                 Type: uint256
                 Source: "now"
          ExpressionStatement
             Gas costs: 41002
             Source: "buyPrice_wie = buyPrice_wie * (1000000 + dailyGrowth_ppm) / 1000000"
            Assignment using operator =
               Type: uint256
               Source: "buyPrice_wie = buyPrice_wie * (1000000 + dailyGrowth_ppm) / 1000000"
              Identifier buyPrice_wie
                 Type: uint256
                 Source: "buyPrice_wie"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "buyPrice_wie * (1000000 + dailyGrowth_ppm) / 1000000"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "buyPrice_wie * (1000000 + dailyGrowth_ppm)"
                  Identifier buyPrice_wie
                     Type: uint256
                     Source: "buyPrice_wie"
                  TupleExpression
                     Type: uint32
                     Source: "(1000000 + dailyGrowth_ppm)"
                    BinaryOperation using operator +
                       Type: uint32
                       Source: "1000000 + dailyGrowth_ppm"
                      Literal, token: [no token] value: 1000000
                         Type: int_const 1000000
                         Source: "1000000"
                      Identifier dailyGrowth_ppm
                         Type: uint32
                         Source: "dailyGrowth_ppm"
                Literal, token: [no token] value: 1000000
                   Type: int_const 1000000
                   Source: "1000000"
          ExpressionStatement
             Gas costs: 40512
             Source: "sellPrice_wie = buyPrice_wie * sell_ppc / 100"
            Assignment using operator =
               Type: uint256
               Source: "sellPrice_wie = buyPrice_wie * sell_ppc / 100"
              Identifier sellPrice_wie
                 Type: uint256
                 Source: "sellPrice_wie"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "buyPrice_wie * sell_ppc / 100"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "buyPrice_wie * sell_ppc"
                  Identifier buyPrice_wie
                     Type: uint256
                     Source: "buyPrice_wie"
                  Identifier sell_ppc
                     Type: uint32
                     Source: "sell_ppc"
                Literal, token: [no token] value: 100
                   Type: int_const 100
                   Source: "100"
          ExpressionStatement
             Gas costs: [???]
             Source: "PriceAdjusted(buyPrice_wie, sellPrice_wie)"
            FunctionCall
               Type: tuple()
               Source: "PriceAdjusted(buyPrice_wie, sellPrice_wie)"
              Identifier PriceAdjusted
                 Type: function (uint256,uint256)
                 Source: "PriceAdjusted"
              Identifier buyPrice_wie
                 Type: uint256
                 Source: "buyPrice_wie"
              Identifier sellPrice_wie
                 Type: uint256
                 Source: "sellPrice_wie"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "setGrowth" - public
     Source: "function setGrowth(uint32 _newGrowth_ppm) onlyOwner external returns(bool result) {\r\n    if (_newGrowth_ppm >= dailyGrowthMin_ppm &&\r\n        _newGrowth_ppm <= dailyGrowthMax_ppm\r\n    ) {\r\n      dailyGrowth_ppm = _newGrowth_ppm;\r\n      DailyGrowthUpdate(_newGrowth_ppm);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint32 _newGrowth_ppm)"
      VariableDeclaration "_newGrowth_ppm"
         Type: uint32
         Source: "uint32 _newGrowth_ppm"
        ElementaryTypeName uint32
           Source: "uint32"
    ParameterList
       Gas costs: 3
       Source: "(bool result)"
      VariableDeclaration "result"
         Type: bool
         Source: "bool result"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    if (_newGrowth_ppm >= dailyGrowthMin_ppm &&\r\n        _newGrowth_ppm <= dailyGrowthMax_ppm\r\n    ) {\r\n      dailyGrowth_ppm = _newGrowth_ppm;\r\n      DailyGrowthUpdate(_newGrowth_ppm);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }"
      IfStatement
         Source: "if (_newGrowth_ppm >= dailyGrowthMin_ppm &&\r\n        _newGrowth_ppm <= dailyGrowthMax_ppm\r\n    ) {\r\n      dailyGrowth_ppm = _newGrowth_ppm;\r\n      DailyGrowthUpdate(_newGrowth_ppm);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 64
           Source: "_newGrowth_ppm >= dailyGrowthMin_ppm &&\r\n        _newGrowth_ppm <= dailyGrowthMax_ppm"
          BinaryOperation using operator >=
             Type: bool
             Source: "_newGrowth_ppm >= dailyGrowthMin_ppm"
            Identifier _newGrowth_ppm
               Type: uint32
               Source: "_newGrowth_ppm"
            Identifier dailyGrowthMin_ppm
               Type: uint32
               Source: "dailyGrowthMin_ppm"
          BinaryOperation using operator <=
             Type: bool
             Source: "_newGrowth_ppm <= dailyGrowthMax_ppm"
            Identifier _newGrowth_ppm
               Type: uint32
               Source: "_newGrowth_ppm"
            Identifier dailyGrowthMax_ppm
               Type: uint32
               Source: "dailyGrowthMax_ppm"
        Block
           Source: "{\r\n      dailyGrowth_ppm = _newGrowth_ppm;\r\n      DailyGrowthUpdate(_newGrowth_ppm);\r\n      return true;\r\n    }"
          ExpressionStatement
             Gas costs: 20267
             Source: "dailyGrowth_ppm = _newGrowth_ppm"
            Assignment using operator =
               Type: uint32
               Source: "dailyGrowth_ppm = _newGrowth_ppm"
              Identifier dailyGrowth_ppm
                 Type: uint32
                 Source: "dailyGrowth_ppm"
              Identifier _newGrowth_ppm
                 Type: uint32
                 Source: "_newGrowth_ppm"
          ExpressionStatement
             Gas costs: [???]
             Source: "DailyGrowthUpdate(_newGrowth_ppm)"
            FunctionCall
               Type: tuple()
               Source: "DailyGrowthUpdate(_newGrowth_ppm)"
              Identifier DailyGrowthUpdate
                 Type: function (uint256)
                 Source: "DailyGrowthUpdate"
              Identifier _newGrowth_ppm
                 Type: uint32
                 Source: "_newGrowth_ppm"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{\r\n      return false;\r\n    }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  VariableDeclaration "sellPrice_wie"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public sellPrice_wie"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "buyPrice_wie"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public buyPrice_wie"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "buy" - public
     Source: "function buy() adjustPrice payable external {\r\n    require(msg.value >= buyPrice_wie);\r\n    var amount = safeDiv(msg.value, buyPrice_wie);\r\n\r\n    assignBountryToReferals(msg.sender, amount);                                // First assign bounty\r\n\r\n    // Buy discount if User is a new user and has set referral\r\n    if ( balances[msg.sender] == 0 && referrals[msg.sender][0] != 0 ) {\r\n      // Check that user has to wait at least two weeks before he get break even on what he will get\r\n      amount = amount * (100 + landingDiscount_ppc) / 100;\r\n    }\r\n\r\n    issueTo(msg.sender, amount);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "adjustPrice"
       Gas costs: 0
       Source: "adjustPrice"
      Identifier adjustPrice
         Type: modifier ()
         Source: "adjustPrice"
    Block
       Source: "{\r\n    require(msg.value >= buyPrice_wie);\r\n    var amount = safeDiv(msg.value, buyPrice_wie);\r\n\r\n    assignBountryToReferals(msg.sender, amount);                                // First assign bounty\r\n\r\n    // Buy discount if User is a new user and has set referral\r\n    if ( balances[msg.sender] == 0 && referrals[msg.sender][0] != 0 ) {\r\n      // Check that user has to wait at least two weeks before he get break even on what he will get\r\n      amount = amount * (100 + landingDiscount_ppc) / 100;\r\n    }\r\n\r\n    issueTo(msg.sender, amount);\r\n  }"
      ExpressionStatement
         Gas costs: 237
         Source: "require(msg.value >= buyPrice_wie)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value >= buyPrice_wie)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.value >= buyPrice_wie"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier buyPrice_wie
               Type: uint256
               Source: "buyPrice_wie"
      VariableDeclarationStatement
         Gas costs: 217
         Source: "var amount = safeDiv(msg.value, buyPrice_wie)"
        VariableDeclaration "amount"
           Type: uint256
           Source: "var amount"
        FunctionCall
           Type: uint256
           Source: "safeDiv(msg.value, buyPrice_wie)"
          Identifier safeDiv
             Type: function (uint256,uint256) returns (uint256)
             Source: "safeDiv"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier buyPrice_wie
             Type: uint256
             Source: "buyPrice_wie"
      ExpressionStatement
         Gas costs: 9
         Source: "assignBountryToReferals(msg.sender, amount)"
        FunctionCall
           Type: tuple()
           Source: "assignBountryToReferals(msg.sender, amount)"
          Identifier assignBountryToReferals
             Type: function (address,uint256)
             Source: "assignBountryToReferals"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier amount
             Type: uint256
             Source: "amount"
      IfStatement
         Source: "if ( balances[msg.sender] == 0 && referrals[msg.sender][0] != 0 ) {\r\n      // Check that user has to wait at least two weeks before he get break even on what he will get\r\n      amount = amount * (100 + landingDiscount_ppc) / 100;\r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 710
           Source: "balances[msg.sender] == 0 && referrals[msg.sender][0] != 0"
          BinaryOperation using operator ==
             Type: bool
             Source: "balances[msg.sender] == 0"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator !=
             Type: bool
             Source: "referrals[msg.sender][0] != 0"
            IndexAccess
               Type: address
               Source: "referrals[msg.sender][0]"
              IndexAccess
                 Type: address[3] storage ref
                 Source: "referrals[msg.sender]"
                Identifier referrals
                   Type: mapping(address => address[3] storage ref)
                   Source: "referrals"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n      // Check that user has to wait at least two weeks before he get break even on what he will get\r\n      amount = amount * (100 + landingDiscount_ppc) / 100;\r\n    }"
          ExpressionStatement
             Gas costs: 56
             Source: "amount = amount * (100 + landingDiscount_ppc) / 100"
            Assignment using operator =
               Type: uint256
               Source: "amount = amount * (100 + landingDiscount_ppc) / 100"
              Identifier amount
                 Type: uint256
                 Source: "amount"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "amount * (100 + landingDiscount_ppc) / 100"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "amount * (100 + landingDiscount_ppc)"
                  Identifier amount
                     Type: uint256
                     Source: "amount"
                  TupleExpression
                     Type: uint32
                     Source: "(100 + landingDiscount_ppc)"
                    BinaryOperation using operator +
                       Type: uint32
                       Source: "100 + landingDiscount_ppc"
                      Literal, token: [no token] value: 100
                         Type: int_const 100
                         Source: "100"
                      Identifier landingDiscount_ppc
                         Type: uint32
                         Source: "landingDiscount_ppc"
                Literal, token: [no token] value: 100
                   Type: int_const 100
                   Source: "100"
      ExpressionStatement
         Gas costs: 9
         Source: "issueTo(msg.sender, amount)"
        FunctionCall
           Type: tuple()
           Source: "issueTo(msg.sender, amount)"
          Identifier issueTo
             Type: function (address,uint256)
             Source: "issueTo"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier amount
             Type: uint256
             Source: "amount"
  FunctionDefinition "sell" - public
     Source: "function sell(uint256 _amount) adjustPrice external {\r\n    require(_amount > 0 && balances[msg.sender] >= _amount);\r\n    uint moneyWorth = safeMul(_amount, sellPrice_wie);\r\n    require(this.balance > moneyWorth);                                         // We can't sell if we don't have enough money\r\n    \r\n    if (\r\n        balances[this] + _amount > balances[this] &&\r\n        balances[msg.sender] - _amount < balances[msg.sender]\r\n    ) {\r\n      balances[this] = safeAdd(balances[this], _amount);                        // adds the amount to owner's balance\r\n      balances[msg.sender] = safeSub(balances[msg.sender], _amount);            // subtracts the amount from seller's balance\r\n      if (!msg.sender.send(moneyWorth)) {                                       // sends ether to the seller. It's important\r\n        revert();                                                               // to do this last to avoid recursion attacks\r\n      } else {\r\n        Transfer(msg.sender, this, _amount);                                    // executes an event reflecting on the change\r\n      }        \r\n    } else {\r\n      revert();                                                                 // checks if the sender has enough to sell\r\n    }  \r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _amount)"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "adjustPrice"
       Gas costs: 0
       Source: "adjustPrice"
      Identifier adjustPrice
         Type: modifier ()
         Source: "adjustPrice"
    Block
       Source: "{\r\n    require(_amount > 0 && balances[msg.sender] >= _amount);\r\n    uint moneyWorth = safeMul(_amount, sellPrice_wie);\r\n    require(this.balance > moneyWorth);                                         // We can't sell if we don't have enough money\r\n    \r\n    if (\r\n        balances[this] + _amount > balances[this] &&\r\n        balances[msg.sender] - _amount < balances[msg.sender]\r\n    ) {\r\n      balances[this] = safeAdd(balances[this], _amount);                        // adds the amount to owner's balance\r\n      balances[msg.sender] = safeSub(balances[msg.sender], _amount);            // subtracts the amount from seller's balance\r\n      if (!msg.sender.send(moneyWorth)) {                                       // sends ether to the seller. It's important\r\n        revert();                                                               // to do this last to avoid recursion attacks\r\n      } else {\r\n        Transfer(msg.sender, this, _amount);                                    // executes an event reflecting on the change\r\n      }        \r\n    } else {\r\n      revert();                                                                 // checks if the sender has enough to sell\r\n    }  \r\n  }"
      ExpressionStatement
         Gas costs: 364
         Source: "require(_amount > 0 && balances[msg.sender] >= _amount)"
        FunctionCall
           Type: tuple()
           Source: "require(_amount > 0 && balances[msg.sender] >= _amount)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_amount > 0 && balances[msg.sender] >= _amount"
            BinaryOperation using operator >
               Type: bool
               Source: "_amount > 0"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator >=
               Type: bool
               Source: "balances[msg.sender] >= _amount"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
      VariableDeclarationStatement
         Gas costs: 218
         Source: "uint moneyWorth = safeMul(_amount, sellPrice_wie)"
        VariableDeclaration "moneyWorth"
           Type: uint256
           Source: "uint moneyWorth"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "safeMul(_amount, sellPrice_wie)"
          Identifier safeMul
             Type: function (uint256,uint256) returns (uint256)
             Source: "safeMul"
          Identifier _amount
             Type: uint256
             Source: "_amount"
          Identifier sellPrice_wie
             Type: uint256
             Source: "sellPrice_wie"
      ExpressionStatement
         Gas costs: 440
         Source: "require(this.balance > moneyWorth)"
        FunctionCall
           Type: tuple()
           Source: "require(this.balance > moneyWorth)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "this.balance > moneyWorth"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract Fish
                 Source: "this"
            Identifier moneyWorth
               Type: uint256
               Source: "moneyWorth"
      IfStatement
         Source: "if (\r\n        balances[this] + _amount > balances[this] &&\r\n        balances[msg.sender] - _amount < balances[msg.sender]\r\n    ) {\r\n      balances[this] = safeAdd(balances[this], _amount);                        // adds the amount to owner's balance\r\n      balances[msg.sender] = safeSub(balances[msg.sender], _amount);            // subtracts the amount from seller's balance\r\n      if (!msg.sender.send(moneyWorth)) {                                       // sends ether to the seller. It's important\r\n        revert();                                                               // to do this last to avoid recursion attacks\r\n      } else {\r\n        Transfer(msg.sender, this, _amount);                                    // executes an event reflecting on the change\r\n      }        \r\n    } else {\r\n      revert();                                                                 // checks if the sender has enough to sell\r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 1220
           Source: "balances[this] + _amount > balances[this] &&\r\n        balances[msg.sender] - _amount < balances[msg.sender]"
          BinaryOperation using operator >
             Type: bool
             Source: "balances[this] + _amount > balances[this]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balances[this] + _amount"
              IndexAccess
                 Type: uint256
                 Source: "balances[this]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier this
                   Type: contract Fish
                   Source: "this"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
            IndexAccess
               Type: uint256
               Source: "balances[this]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier this
                 Type: contract Fish
                 Source: "this"
          BinaryOperation using operator <
             Type: bool
             Source: "balances[msg.sender] - _amount < balances[msg.sender]"
            BinaryOperation using operator -
               Type: uint256
               Source: "balances[msg.sender] - _amount"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
        Block
           Source: "{\r\n      balances[this] = safeAdd(balances[this], _amount);                        // adds the amount to owner's balance\r\n      balances[msg.sender] = safeSub(balances[msg.sender], _amount);            // subtracts the amount from seller's balance\r\n      if (!msg.sender.send(moneyWorth)) {                                       // sends ether to the seller. It's important\r\n        revert();                                                               // to do this last to avoid recursion attacks\r\n      } else {\r\n        Transfer(msg.sender, this, _amount);                                    // executes an event reflecting on the change\r\n      }        \r\n    }"
          ExpressionStatement
             Gas costs: 20422
             Source: "balances[this] = safeAdd(balances[this], _amount)"
            Assignment using operator =
               Type: uint256
               Source: "balances[this] = safeAdd(balances[this], _amount)"
              IndexAccess
                 Type: uint256
                 Source: "balances[this]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier this
                   Type: contract Fish
                   Source: "this"
              FunctionCall
                 Type: uint256
                 Source: "safeAdd(balances[this], _amount)"
                Identifier safeAdd
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "safeAdd"
                IndexAccess
                   Type: uint256
                   Source: "balances[this]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  Identifier this
                     Type: contract Fish
                     Source: "this"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
          ExpressionStatement
             Gas costs: 20416
             Source: "balances[msg.sender] = safeSub(balances[msg.sender], _amount)"
            Assignment using operator =
               Type: uint256
               Source: "balances[msg.sender] = safeSub(balances[msg.sender], _amount)"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              FunctionCall
                 Type: uint256
                 Source: "safeSub(balances[msg.sender], _amount)"
                Identifier safeSub
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "safeSub"
                IndexAccess
                   Type: uint256
                   Source: "balances[msg.sender]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
          IfStatement
             Source: "if (!msg.sender.send(moneyWorth)) {                                       // sends ether to the seller. It's important\r\n        revert();                                                               // to do this last to avoid recursion attacks\r\n      } else {\r\n        Transfer(msg.sender, this, _amount);                                    // executes an event reflecting on the change\r\n      }"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: [???]
               Source: "!msg.sender.send(moneyWorth)"
              FunctionCall
                 Type: bool
                 Source: "msg.sender.send(moneyWorth)"
                MemberAccess to member send
                   Type: function (uint256) returns (bool)
                   Source: "msg.sender.send"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier moneyWorth
                   Type: uint256
                   Source: "moneyWorth"
            Block
               Source: "{                                       // sends ether to the seller. It's important\r\n        revert();                                                               // to do this last to avoid recursion attacks\r\n      }"
              ExpressionStatement
                 Gas costs: 6
                 Source: "revert()"
                FunctionCall
                   Type: tuple()
                   Source: "revert()"
                  Identifier revert
                     Type: function () pure
                     Source: "revert"
            Block
               Source: "{\r\n        Transfer(msg.sender, this, _amount);                                    // executes an event reflecting on the change\r\n      }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "Transfer(msg.sender, this, _amount)"
                FunctionCall
                   Type: tuple()
                   Source: "Transfer(msg.sender, this, _amount)"
                  Identifier Transfer
                     Type: function (address,address,uint256)
                     Source: "Transfer"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier this
                     Type: contract Fish
                     Source: "this"
                  Identifier _amount
                     Type: uint256
                     Source: "_amount"
        Block
           Source: "{\r\n      revert();                                                                 // checks if the sender has enough to sell\r\n    }"
          ExpressionStatement
             Gas costs: 6
             Source: "revert()"
            FunctionCall
               Type: tuple()
               Source: "revert()"
              Identifier revert
                 Type: function () pure
                 Source: "revert"
  FunctionDefinition "issueTo"
     Source: "function issueTo(address _beneficiary, uint256 _amount_tkns) private {\r\n    if (\r\n        balances[this] >= _amount_tkns\r\n    ) {\r\n      // All tokens are taken from balance\r\n      balances[this] = safeSub(balances[this], _amount_tkns);\r\n      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\r\n    } else {\r\n      // Balance will be lowered and new tokens will be issued\r\n      uint diff = safeSub(_amount_tkns, balances[this]);\r\n\r\n      totalSupply = safeAdd(totalSupply, diff);\r\n      balances[this] = 0;\r\n      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\r\n    }\r\n    \r\n    Transfer(this, _beneficiary, _amount_tkns);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _beneficiary, uint256 _amount_tkns)"
      VariableDeclaration "_beneficiary"
         Type: address
         Source: "address _beneficiary"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount_tkns"
         Type: uint256
         Source: "uint256 _amount_tkns"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    if (\r\n        balances[this] >= _amount_tkns\r\n    ) {\r\n      // All tokens are taken from balance\r\n      balances[this] = safeSub(balances[this], _amount_tkns);\r\n      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\r\n    } else {\r\n      // Balance will be lowered and new tokens will be issued\r\n      uint diff = safeSub(_amount_tkns, balances[this]);\r\n\r\n      totalSupply = safeAdd(totalSupply, diff);\r\n      balances[this] = 0;\r\n      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\r\n    }\r\n    \r\n    Transfer(this, _beneficiary, _amount_tkns);\r\n  }"
      IfStatement
         Source: "if (\r\n        balances[this] >= _amount_tkns\r\n    ) {\r\n      // All tokens are taken from balance\r\n      balances[this] = safeSub(balances[this], _amount_tkns);\r\n      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\r\n    } else {\r\n      // Balance will be lowered and new tokens will be issued\r\n      uint diff = safeSub(_amount_tkns, balances[this]);\r\n\r\n      totalSupply = safeAdd(totalSupply, diff);\r\n      balances[this] = 0;\r\n      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\r\n    }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 307
           Source: "balances[this] >= _amount_tkns"
          IndexAccess
             Type: uint256
             Source: "balances[this]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier this
               Type: contract Fish
               Source: "this"
          Identifier _amount_tkns
             Type: uint256
             Source: "_amount_tkns"
        Block
           Source: "{\r\n      // All tokens are taken from balance\r\n      balances[this] = safeSub(balances[this], _amount_tkns);\r\n      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\r\n    }"
          ExpressionStatement
             Gas costs: 20422
             Source: "balances[this] = safeSub(balances[this], _amount_tkns)"
            Assignment using operator =
               Type: uint256
               Source: "balances[this] = safeSub(balances[this], _amount_tkns)"
              IndexAccess
                 Type: uint256
                 Source: "balances[this]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier this
                   Type: contract Fish
                   Source: "this"
              FunctionCall
                 Type: uint256
                 Source: "safeSub(balances[this], _amount_tkns)"
                Identifier safeSub
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "safeSub"
                IndexAccess
                   Type: uint256
                   Source: "balances[this]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  Identifier this
                     Type: contract Fish
                     Source: "this"
                Identifier _amount_tkns
                   Type: uint256
                   Source: "_amount_tkns"
          ExpressionStatement
             Gas costs: 20418
             Source: "balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns)"
            Assignment using operator =
               Type: uint256
               Source: "balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns)"
              IndexAccess
                 Type: uint256
                 Source: "balances[_beneficiary]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _beneficiary
                   Type: address
                   Source: "_beneficiary"
              FunctionCall
                 Type: uint256
                 Source: "safeAdd(balances[_beneficiary], _amount_tkns)"
                Identifier safeAdd
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "safeAdd"
                IndexAccess
                   Type: uint256
                   Source: "balances[_beneficiary]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  Identifier _beneficiary
                     Type: address
                     Source: "_beneficiary"
                Identifier _amount_tkns
                   Type: uint256
                   Source: "_amount_tkns"
        Block
           Source: "{\r\n      // Balance will be lowered and new tokens will be issued\r\n      uint diff = safeSub(_amount_tkns, balances[this]);\r\n\r\n      totalSupply = safeAdd(totalSupply, diff);\r\n      balances[this] = 0;\r\n      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\r\n    }"
          VariableDeclarationStatement
             Gas costs: 324
             Source: "uint diff = safeSub(_amount_tkns, balances[this])"
            VariableDeclaration "diff"
               Type: uint256
               Source: "uint diff"
              ElementaryTypeName uint
                 Source: "uint"
            FunctionCall
               Type: uint256
               Source: "safeSub(_amount_tkns, balances[this])"
              Identifier safeSub
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "safeSub"
              Identifier _amount_tkns
                 Type: uint256
                 Source: "_amount_tkns"
              IndexAccess
                 Type: uint256
                 Source: "balances[this]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier this
                   Type: contract Fish
                   Source: "this"
          ExpressionStatement
             Gas costs: 20232
             Source: "totalSupply = safeAdd(totalSupply, diff)"
            Assignment using operator =
               Type: uint256
               Source: "totalSupply = safeAdd(totalSupply, diff)"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
              FunctionCall
                 Type: uint256
                 Source: "safeAdd(totalSupply, diff)"
                Identifier safeAdd
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "safeAdd"
                Identifier totalSupply
                   Type: uint256
                   Source: "totalSupply"
                Identifier diff
                   Type: uint256
                   Source: "diff"
          ExpressionStatement
             Gas costs: 5109
             Source: "balances[this] = 0"
            Assignment using operator =
               Type: uint256
               Source: "balances[this] = 0"
              IndexAccess
                 Type: uint256
                 Source: "balances[this]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier this
                   Type: contract Fish
                   Source: "this"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          ExpressionStatement
             Gas costs: 20418
             Source: "balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns)"
            Assignment using operator =
               Type: uint256
               Source: "balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns)"
              IndexAccess
                 Type: uint256
                 Source: "balances[_beneficiary]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _beneficiary
                   Type: address
                   Source: "_beneficiary"
              FunctionCall
                 Type: uint256
                 Source: "safeAdd(balances[_beneficiary], _amount_tkns)"
                Identifier safeAdd
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "safeAdd"
                IndexAccess
                   Type: uint256
                   Source: "balances[_beneficiary]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  Identifier _beneficiary
                     Type: address
                     Source: "_beneficiary"
                Identifier _amount_tkns
                   Type: uint256
                   Source: "_amount_tkns"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(this, _beneficiary, _amount_tkns)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(this, _beneficiary, _amount_tkns)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier this
             Type: contract Fish
             Source: "this"
          Identifier _beneficiary
             Type: address
             Source: "_beneficiary"
          Identifier _amount_tkns
             Type: uint256
             Source: "_amount_tkns"
  VariableDeclaration "referrals"
     Type: mapping(address => address[3] storage ref)
     Gas costs: 0
     Source: "mapping(address => address[3]) referrals"
    Mapping
       Source: "mapping(address => address[3])"
      ElementaryTypeName address
         Source: "address"
      ArrayTypeName
         Source: "address[3]"
        ElementaryTypeName address
           Source: "address"
        Literal, token: [no token] value: 3
           Type unknown.
           Source: "3"
  VariableDeclaration "bounties"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) bounties"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "landingDiscount_ppc"
     Type: uint32
     Gas costs: [???]
     Source: "uint32 public constant landingDiscount_ppc = 4"
    ElementaryTypeName uint32
       Source: "uint32"
    Literal, token: [no token] value: 4
       Type: int_const 4
       Source: "4"
  FunctionDefinition "referral" - public
     Source: "function referral(address _referral) external returns(bool) {\r\n    if ( balances[_referral] > 0 &&                                              // Referral participated already\r\n         balances[msg.sender] == 0  &&                                          // Sender is a new user\r\n         referrals[msg.sender][0] == 0                                           // Not returning user. User can not reassign their referrals but they can assign them later on\r\n    ) {\r\n      var referral_referrals = referrals[_referral];\r\n      referrals[msg.sender] = [_referral, referral_referrals[0], referral_referrals[1]];\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _referral)"
      VariableDeclaration "_referral"
         Type: address
         Source: "address _referral"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    if ( balances[_referral] > 0 &&                                              // Referral participated already\r\n         balances[msg.sender] == 0  &&                                          // Sender is a new user\r\n         referrals[msg.sender][0] == 0                                           // Not returning user. User can not reassign their referrals but they can assign them later on\r\n    ) {\r\n      var referral_referrals = referrals[_referral];\r\n      referrals[msg.sender] = [_referral, referral_referrals[0], referral_referrals[1]];\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  }"
      IfStatement
         Source: "if ( balances[_referral] > 0 &&                                              // Referral participated already\r\n         balances[msg.sender] == 0  &&                                          // Sender is a new user\r\n         referrals[msg.sender][0] == 0                                           // Not returning user. User can not reassign their referrals but they can assign them later on\r\n    ) {\r\n      var referral_referrals = referrals[_referral];\r\n      referrals[msg.sender] = [_referral, referral_referrals[0], referral_referrals[1]];\r\n      return true;\r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 1034
           Source: "balances[_referral] > 0 &&                                              // Referral participated already\r\n         balances[msg.sender] == 0  &&                                          // Sender is a new user\r\n         referrals[msg.sender][0] == 0"
          BinaryOperation using operator &&
             Type: bool
             Source: "balances[_referral] > 0 &&                                              // Referral participated already\r\n         balances[msg.sender] == 0"
            BinaryOperation using operator >
               Type: bool
               Source: "balances[_referral] > 0"
              IndexAccess
                 Type: uint256
                 Source: "balances[_referral]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _referral
                   Type: address
                   Source: "_referral"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "balances[msg.sender] == 0"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          BinaryOperation using operator ==
             Type: bool
             Source: "referrals[msg.sender][0] == 0"
            IndexAccess
               Type: address
               Source: "referrals[msg.sender][0]"
              IndexAccess
                 Type: address[3] storage ref
                 Source: "referrals[msg.sender]"
                Identifier referrals
                   Type: mapping(address => address[3] storage ref)
                   Source: "referrals"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n      var referral_referrals = referrals[_referral];\r\n      referrals[msg.sender] = [_referral, referral_referrals[0], referral_referrals[1]];\r\n      return true;\r\n    }"
          VariableDeclarationStatement
             Gas costs: 107
             Source: "var referral_referrals = referrals[_referral]"
            VariableDeclaration "referral_referrals"
               Type: address[3] storage pointer
               Source: "var referral_referrals"
            IndexAccess
               Type: address[3] storage ref
               Source: "referrals[_referral]"
              Identifier referrals
                 Type: mapping(address => address[3] storage ref)
                 Source: "referrals"
              Identifier _referral
                 Type: address
                 Source: "_referral"
          ExpressionStatement
             Gas costs: [???]
             Source: "referrals[msg.sender] = [_referral, referral_referrals[0], referral_referrals[1]]"
            Assignment using operator =
               Type: address[3] storage ref
               Source: "referrals[msg.sender] = [_referral, referral_referrals[0], referral_referrals[1]]"
              IndexAccess
                 Type: address[3] storage ref
                 Source: "referrals[msg.sender]"
                Identifier referrals
                   Type: mapping(address => address[3] storage ref)
                   Source: "referrals"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              TupleExpression
                 Type: address[3] memory
                 Source: "[_referral, referral_referrals[0], referral_referrals[1]]"
                Identifier _referral
                   Type: address
                   Source: "_referral"
                IndexAccess
                   Type: address
                   Source: "referral_referrals[0]"
                  Identifier referral_referrals
                     Type: address[3] storage pointer
                     Source: "referral_referrals"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                IndexAccess
                   Type: address
                   Source: "referral_referrals[1]"
                  Identifier referral_referrals
                     Type: address[3] storage pointer
                     Source: "referral_referrals"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      Return
         Gas costs: 8
         Source: "return false"
        Literal, token: false value: false
           Type: bool
           Source: "false"
  FunctionDefinition "assignBountryToReferals"
     Source: "function assignBountryToReferals(address _referralsOf, uint256 _amount) private {\r\n    var refs = referrals[_referralsOf];\r\n    \r\n    if (refs[0] != 0) {\r\n     issueTo(refs[0], (_amount * 4) / 100);                                     // 4% bounty to direct referral\r\n      if (refs[1] != 0) {\r\n        issueTo(refs[1], (_amount * 2) / 100);                                  // 2% bounty to referral of referral\r\n        if (refs[2] != 0) {\r\n          issueTo(refs[2], (_amount * 1) / 100);                                // 1% bounty to referral of referral of referral\r\n       }\r\n      }\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _referralsOf, uint256 _amount)"
      VariableDeclaration "_referralsOf"
         Type: address
         Source: "address _referralsOf"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    var refs = referrals[_referralsOf];\r\n    \r\n    if (refs[0] != 0) {\r\n     issueTo(refs[0], (_amount * 4) / 100);                                     // 4% bounty to direct referral\r\n      if (refs[1] != 0) {\r\n        issueTo(refs[1], (_amount * 2) / 100);                                  // 2% bounty to referral of referral\r\n        if (refs[2] != 0) {\r\n          issueTo(refs[2], (_amount * 1) / 100);                                // 1% bounty to referral of referral of referral\r\n       }\r\n      }\r\n    }\r\n  }"
      VariableDeclarationStatement
         Gas costs: 107
         Source: "var refs = referrals[_referralsOf]"
        VariableDeclaration "refs"
           Type: address[3] storage pointer
           Source: "var refs"
        IndexAccess
           Type: address[3] storage ref
           Source: "referrals[_referralsOf]"
          Identifier referrals
             Type: mapping(address => address[3] storage ref)
             Source: "referrals"
          Identifier _referralsOf
             Type: address
             Source: "_referralsOf"
      IfStatement
         Source: "if (refs[0] != 0) {\r\n     issueTo(refs[0], (_amount * 4) / 100);                                     // 4% bounty to direct referral\r\n      if (refs[1] != 0) {\r\n        issueTo(refs[1], (_amount * 2) / 100);                                  // 2% bounty to referral of referral\r\n        if (refs[2] != 0) {\r\n          issueTo(refs[2], (_amount * 1) / 100);                                // 1% bounty to referral of referral of referral\r\n       }\r\n      }\r\n    }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 289
           Source: "refs[0] != 0"
          IndexAccess
             Type: address
             Source: "refs[0]"
            Identifier refs
               Type: address[3] storage pointer
               Source: "refs"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n     issueTo(refs[0], (_amount * 4) / 100);                                     // 4% bounty to direct referral\r\n      if (refs[1] != 0) {\r\n        issueTo(refs[1], (_amount * 2) / 100);                                  // 2% bounty to referral of referral\r\n        if (refs[2] != 0) {\r\n          issueTo(refs[2], (_amount * 1) / 100);                                // 1% bounty to referral of referral of referral\r\n       }\r\n      }\r\n    }"
          ExpressionStatement
             Gas costs: 331
             Source: "issueTo(refs[0], (_amount * 4) / 100)"
            FunctionCall
               Type: tuple()
               Source: "issueTo(refs[0], (_amount * 4) / 100)"
              Identifier issueTo
                 Type: function (address,uint256)
                 Source: "issueTo"
              IndexAccess
                 Type: address
                 Source: "refs[0]"
                Identifier refs
                   Type: address[3] storage pointer
                   Source: "refs"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "(_amount * 4) / 100"
                TupleExpression
                   Type: uint256
                   Source: "(_amount * 4)"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "_amount * 4"
                    Identifier _amount
                       Type: uint256
                       Source: "_amount"
                    Literal, token: [no token] value: 4
                       Type: int_const 4
                       Source: "4"
                Literal, token: [no token] value: 100
                   Type: int_const 100
                   Source: "100"
          IfStatement
             Source: "if (refs[1] != 0) {\r\n        issueTo(refs[1], (_amount * 2) / 100);                                  // 2% bounty to referral of referral\r\n        if (refs[2] != 0) {\r\n          issueTo(refs[2], (_amount * 1) / 100);                                // 1% bounty to referral of referral of referral\r\n       }\r\n      }"
            BinaryOperation using operator !=
               Type: bool
               Gas costs: 289
               Source: "refs[1] != 0"
              IndexAccess
                 Type: address
                 Source: "refs[1]"
                Identifier refs
                   Type: address[3] storage pointer
                   Source: "refs"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{\r\n        issueTo(refs[1], (_amount * 2) / 100);                                  // 2% bounty to referral of referral\r\n        if (refs[2] != 0) {\r\n          issueTo(refs[2], (_amount * 1) / 100);                                // 1% bounty to referral of referral of referral\r\n       }\r\n      }"
              ExpressionStatement
                 Gas costs: 331
                 Source: "issueTo(refs[1], (_amount * 2) / 100)"
                FunctionCall
                   Type: tuple()
                   Source: "issueTo(refs[1], (_amount * 2) / 100)"
                  Identifier issueTo
                     Type: function (address,uint256)
                     Source: "issueTo"
                  IndexAccess
                     Type: address
                     Source: "refs[1]"
                    Identifier refs
                       Type: address[3] storage pointer
                       Source: "refs"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "(_amount * 2) / 100"
                    TupleExpression
                       Type: uint256
                       Source: "(_amount * 2)"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "_amount * 2"
                        Identifier _amount
                           Type: uint256
                           Source: "_amount"
                        Literal, token: [no token] value: 2
                           Type: int_const 2
                           Source: "2"
                    Literal, token: [no token] value: 100
                       Type: int_const 100
                       Source: "100"
              IfStatement
                 Source: "if (refs[2] != 0) {\r\n          issueTo(refs[2], (_amount * 1) / 100);                                // 1% bounty to referral of referral of referral\r\n       }"
                BinaryOperation using operator !=
                   Type: bool
                   Gas costs: 289
                   Source: "refs[2] != 0"
                  IndexAccess
                     Type: address
                     Source: "refs[2]"
                    Identifier refs
                       Type: address[3] storage pointer
                       Source: "refs"
                    Literal, token: [no token] value: 2
                       Type: int_const 2
                       Source: "2"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                Block
                   Source: "{\r\n          issueTo(refs[2], (_amount * 1) / 100);                                // 1% bounty to referral of referral of referral\r\n       }"
                  ExpressionStatement
                     Gas costs: 331
                     Source: "issueTo(refs[2], (_amount * 1) / 100)"
                    FunctionCall
                       Type: tuple()
                       Source: "issueTo(refs[2], (_amount * 1) / 100)"
                      Identifier issueTo
                         Type: function (address,uint256)
                         Source: "issueTo"
                      IndexAccess
                         Type: address
                         Source: "refs[2]"
                        Identifier refs
                           Type: address[3] storage pointer
                           Source: "refs"
                        Literal, token: [no token] value: 2
                           Type: int_const 2
                           Source: "2"
                      BinaryOperation using operator /
                         Type: uint256
                         Source: "(_amount * 1) / 100"
                        TupleExpression
                           Type: uint256
                           Source: "(_amount * 1)"
                          BinaryOperation using operator *
                             Type: uint256
                             Source: "_amount * 1"
                            Identifier _amount
                               Type: uint256
                               Source: "_amount"
                            Literal, token: [no token] value: 1
                               Type: int_const 1
                               Source: "1"
                        Literal, token: [no token] value: 100
                           Type: int_const 100
                           Source: "100"
  FunctionDefinition "assignBounty" - public
     Source: "function assignBounty(address _account, uint256 _amount) onlyOwner external returns(bool) {\r\n    require(_amount > 0); \r\n     \r\n    if (balances[_account] > 0 &&                                               // Account had participated already\r\n        bounties[_account] + _amount <= 1000000                                 // no more than 100 token units per account\r\n    ) {\r\n      issueTo(_account, _amount);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _account, uint256 _amount)"
      VariableDeclaration "_account"
         Type: address
         Source: "address _account"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(_amount > 0); \r\n     \r\n    if (balances[_account] > 0 &&                                               // Account had participated already\r\n        bounties[_account] + _amount <= 1000000                                 // no more than 100 token units per account\r\n    ) {\r\n      issueTo(_account, _amount);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }"
      ExpressionStatement
         Gas costs: 35
         Source: "require(_amount > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_amount > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "_amount > 0"
            Identifier _amount
               Type: uint256
               Source: "_amount"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      IfStatement
         Source: "if (balances[_account] > 0 &&                                               // Account had participated already\r\n        bounties[_account] + _amount <= 1000000                                 // no more than 100 token units per account\r\n    ) {\r\n      issueTo(_account, _amount);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 641
           Source: "balances[_account] > 0 &&                                               // Account had participated already\r\n        bounties[_account] + _amount <= 1000000"
          BinaryOperation using operator >
             Type: bool
             Source: "balances[_account] > 0"
            IndexAccess
               Type: uint256
               Source: "balances[_account]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _account
                 Type: address
                 Source: "_account"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator <=
             Type: bool
             Source: "bounties[_account] + _amount <= 1000000"
            BinaryOperation using operator +
               Type: uint256
               Source: "bounties[_account] + _amount"
              IndexAccess
                 Type: uint256
                 Source: "bounties[_account]"
                Identifier bounties
                   Type: mapping(address => uint256)
                   Source: "bounties"
                Identifier _account
                   Type: address
                   Source: "_account"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
            Literal, token: [no token] value: 1000000
               Type: int_const 1000000
               Source: "1000000"
        Block
           Source: "{\r\n      issueTo(_account, _amount);\r\n      return true;\r\n    }"
          ExpressionStatement
             Gas costs: 21
             Source: "issueTo(_account, _amount)"
            FunctionCall
               Type: tuple()
               Source: "issueTo(_account, _amount)"
              Identifier issueTo
                 Type: function (address,uint256)
                 Source: "issueTo"
              Identifier _account
                 Type: address
                 Source: "_account"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{\r\n      return false;\r\n    }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
