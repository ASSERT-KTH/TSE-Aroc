Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xc7413ae0e8e3ac3bf186f47850a05bb5603294de.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity >=0.4.10;"
ContractDefinition "Token"
   Gas costs: 0
   Source: "contract Token {\r\n    function transferFrom(address from, address to, uint amount) returns(bool);\r\n    function transfer(address to, uint amount) returns(bool);\r\n    function balanceOf(address addr) constant returns(uint);\r\n}"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint amount) returns(bool);"
    ParameterList
       Source: "(address from, address to, uint amount)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint amount) returns(bool);"
    ParameterList
       Source: "(address to, uint amount)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address addr) constant returns(uint);"
    ParameterList
       Source: "(address addr)"
      VariableDeclaration "addr"
         Type: address
         Source: "address addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "Owned"
   Source: "contract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n     * Events\r\n     */\r\n    event ChangedOwner(address indexed new_owner);\r\n\r\n    /**\r\n     * Functionality\r\n     */\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) onlyOwner external {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n            newOwner = 0x0;\r\n            ChangedOwner(owner);\r\n        }\r\n    }\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "newOwner"
     Type: address
     Gas costs: [???]
     Source: "address public newOwner"
    ElementaryTypeName address
       Source: "address"
  EventDefinition "ChangedOwner"
     Gas costs: 0
     Source: "event ChangedOwner(address indexed new_owner);"
    ParameterList
       Source: "(address indexed new_owner)"
      VariableDeclaration "new_owner"
         Type: address
         Source: "address indexed new_owner"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "Owned" - public
     Source: "function Owned() {\r\n        owner = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 3102
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "changeOwner" - public
     Source: "function changeOwner(address _newOwner) onlyOwner external {\r\n        newOwner = _newOwner;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _newOwner)"
      VariableDeclaration "_newOwner"
         Type: address
         Source: "address _newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        newOwner = _newOwner;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "newOwner = _newOwner"
        Assignment using operator =
           Type: address
           Source: "newOwner = _newOwner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
          Identifier _newOwner
             Type: address
             Source: "_newOwner"
  FunctionDefinition "acceptOwnership" - public
     Source: "function acceptOwnership() external {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n            newOwner = 0x0;\r\n            ChangedOwner(owner);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n            newOwner = 0x0;\r\n            ChangedOwner(owner);\r\n        }\r\n    }"
      IfStatement
         Source: "if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n            newOwner = 0x0;\r\n            ChangedOwner(owner);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 256
           Source: "msg.sender == newOwner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier newOwner
             Type: address
             Source: "newOwner"
        Block
           Source: "{\r\n            owner = newOwner;\r\n            newOwner = 0x0;\r\n            ChangedOwner(owner);\r\n        }"
          ExpressionStatement
             Gas costs: 20503
             Source: "owner = newOwner"
            Assignment using operator =
               Type: address
               Source: "owner = newOwner"
              Identifier owner
                 Type: address
                 Source: "owner"
              Identifier newOwner
                 Type: address
                 Source: "newOwner"
          ExpressionStatement
             Gas costs: 20267
             Source: "newOwner = 0x0"
            Assignment using operator =
               Type: address
               Source: "newOwner = 0x0"
              Identifier newOwner
                 Type: address
                 Source: "newOwner"
              Literal, token: [no token] value: 0x0
                 Type: int_const 0
                 Source: "0x0"
          ExpressionStatement
             Gas costs: 1406
             Source: "ChangedOwner(owner)"
            FunctionCall
               Type: tuple()
               Source: "ChangedOwner(owner)"
              Identifier ChangedOwner
                 Type: function (address)
                 Source: "ChangedOwner"
              Identifier owner
                 Type: address
                 Source: "owner"
ContractDefinition "Savings"
   Source: "contract Savings is Owned {\r\n    /**\r\n     * Periods is the total monthly withdrawable amount, not counting the\r\n     * special withdrawal.\r\n     */\r\n    uint public periods;\r\n\r\n    /**\r\n     * t0special is an additional multiplier that determines what\r\n     * fraction of the total distribution is distributed in the\r\n     * one-off withdrawal event. It is used in conjunction with\r\n     * a periodic multiplier (p) to determine the total savings withdrawable\r\n     * to the user at that point in time.\r\n     *\r\n     * The value is not set, it is calculated based on periods\r\n     */\r\n    uint public t0special;\r\n\r\n    uint constant public intervalSecs = 30 days;\r\n    uint constant public precision = 10 ** 18;\r\n\r\n\r\n    /**\r\n     * Events\r\n     */\r\n    event Withdraws(address indexed who, uint amount);\r\n    event Deposit(address indexed who, uint amount);\r\n\r\n    bool public inited;\r\n    bool public locked;\r\n    uint public startBlockTimestamp = 0;\r\n\r\n    Token public token;\r\n\r\n    // face value deposited by an address before locking\r\n    mapping (address => uint) public deposited;\r\n\r\n    // total face value deposited; sum of deposited\r\n    uint public totalfv;\r\n\r\n    // the total remaining value\r\n    uint public remainder;\r\n\r\n    /**\r\n     * Total tokens owned by the contract after locking, and possibly\r\n     * updated by the foundation after subsequent sales.\r\n     */\r\n    uint public total;\r\n\r\n    // the total value withdrawn\r\n    mapping (address => uint256) public withdrawn;\r\n\r\n    bool public nullified;\r\n\r\n    modifier notNullified() { require(!nullified); _; }\r\n\r\n    modifier preLock() { require(!locked && startBlockTimestamp == 0); _; }\r\n\r\n    /**\r\n     * Lock called, deposits no longer available.\r\n     */\r\n    modifier postLock() { require(locked); _; }\r\n\r\n    /**\r\n     * Prestart, state is after lock, before start\r\n     */\r\n    modifier preStart() { require(locked && startBlockTimestamp == 0); _; }\r\n\r\n    /**\r\n     * Start called, the savings contract is now finalized, and withdrawals\r\n     * are now permitted.\r\n     */\r\n    modifier postStart() { require(locked && startBlockTimestamp != 0); _; }\r\n\r\n    /**\r\n     * Uninitialized state, before init is called. Mainly used as a guard to\r\n     * finalize periods and t0special.\r\n     */\r\n    modifier notInitialized() { require(!inited); _; }\r\n\r\n    /**\r\n     * Post initialization state, mainly used to guarantee that\r\n     * periods and t0special have been set properly before starting\r\n     * the withdrawal process.\r\n     */\r\n    modifier initialized() { require(inited); _; }\r\n\r\n    /**\r\n     * Revert under all conditions for fallback, cheaper mistakes\r\n     * in the future?\r\n     */\r\n    function() {\r\n        revert();\r\n    }\r\n\r\n    /**\r\n     * Nullify functionality is intended to disable the contract.\r\n     */\r\n    function nullify() onlyOwner {\r\n        nullified = true;\r\n    }\r\n\r\n    /**\r\n     * Initialization function, should be called after contract deployment. The\r\n     * addition of this function allows contract compilation to be simplified\r\n     * to one contract, instead of two.\r\n     *\r\n     * periods and t0special are finalized, and effectively invariant, after\r\n     * init is called for the first time.\r\n     */\r\n    function init(uint _periods, uint _t0special) onlyOwner notInitialized {\r\n        require(_periods != 0);\r\n        periods = _periods;\r\n        t0special = _t0special;\r\n    }\r\n\r\n    function finalizeInit() onlyOwner notInitialized {\r\n        inited = true;\r\n    }\r\n\r\n    function setToken(address tok) onlyOwner {\r\n        token = Token(tok);\r\n    }\r\n\r\n    /**\r\n     * Lock is called by the owner to lock the savings contract\r\n     * so that no more deposits may be made.\r\n     */\r\n    function lock() onlyOwner {\r\n        locked = true;\r\n    }\r\n\r\n    /**\r\n     * Starts the distribution of savings, it should be called\r\n     * after lock(), once all of the bonus tokens are send to this contract,\r\n     * and multiMint has been called.\r\n     */\r\n    function start(uint _startBlockTimestamp) onlyOwner initialized preStart {\r\n        startBlockTimestamp = _startBlockTimestamp;\r\n        uint256 tokenBalance = token.balanceOf(this);\r\n        total = tokenBalance;\r\n        remainder = tokenBalance;\r\n    }\r\n\r\n    /**\r\n     * Check withdrawal is live, useful for checking whether\r\n     * the savings contract is \"live\", withdrawal enabled, started.\r\n     */\r\n    function isStarted() constant returns(bool) {\r\n        return locked && startBlockTimestamp != 0;\r\n    }\r\n\r\n    // if someone accidentally transfers tokens to this contract,\r\n    // the owner can return them as long as distribution hasn't started\r\n\r\n    /**\r\n     * Used to refund users who accidentaly transferred tokens to this\r\n     * contract, only available before contract is locked\r\n     */\r\n    function refundTokens(address addr, uint amount) onlyOwner preLock {\r\n        token.transfer(addr, amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * Update the total balance, to be called in case of subsequent sales. Updates\r\n     * the total recorded balance of the contract by the difference in expected\r\n     * remainder and the current balance. This means any positive difference will\r\n     * be \"recorded\" into the contract, and distributed within the remaining\r\n     * months of the TRS.\r\n     */\r\n    function updateTotal() onlyOwner postLock {\r\n        uint current = token.balanceOf(this);\r\n        require(current >= remainder); // for sanity\r\n\r\n        uint difference = (current - remainder);\r\n        total += difference;\r\n        remainder = current;\r\n    }\r\n\r\n    /**\r\n     * Calculates the monthly period, starting after the startBlockTimestamp,\r\n     * periodAt will return 0 for all timestamps before startBlockTimestamp.\r\n     *\r\n     * Therefore period 0 is the range of time in which we have called start(),\r\n     * but have not yet passed startBlockTimestamp. Period 1 is the\r\n     * first monthly period, and so-forth all the way until the last\r\n     * period == periods.\r\n     *\r\n     * NOTE: not guarded since no state modifications are made. However,\r\n     * it will return invalid data before the postStart state. It is\r\n     * up to the user to manually check that the contract is in\r\n     * postStart state.\r\n     */\r\n    function periodAt(uint _blockTimestamp) constant returns(uint) {\r\n        /**\r\n         * Lower bound, consider period 0 to be the time between\r\n         * start() and startBlockTimestamp\r\n         */\r\n        if (startBlockTimestamp > _blockTimestamp)\r\n            return 0;\r\n\r\n        /**\r\n         * Calculate the appropriate period, and set an upper bound of\r\n         * periods - 1.\r\n         */\r\n        uint p = ((_blockTimestamp - startBlockTimestamp) / intervalSecs) + 1;\r\n        if (p > periods)\r\n            p = periods;\r\n        return p;\r\n    }\r\n\r\n    // what withdrawal period are we in?\r\n    // returns the period number from [0, periods)\r\n    function period() constant returns(uint) {\r\n        return periodAt(block.timestamp);\r\n    }\r\n\r\n    // deposit your tokens to be saved\r\n    //\r\n    // the despositor must have approve()'d the tokens\r\n    // to be transferred by this contract\r\n    function deposit(uint tokens) notNullified {\r\n        depositTo(msg.sender, tokens);\r\n    }\r\n\r\n\r\n    function depositTo(address beneficiary, uint tokens) preLock notNullified {\r\n        require(token.transferFrom(msg.sender, this, tokens));\r\n        deposited[beneficiary] += tokens;\r\n        totalfv += tokens;\r\n        Deposit(beneficiary, tokens);\r\n    }\r\n\r\n    // convenience function for owner: deposit on behalf of many\r\n    function bulkDepositTo(uint256[] bits) onlyOwner {\r\n        uint256 lomask = (1 << 96) - 1;\r\n        for (uint i=0; i<bits.length; i++) {\r\n            address a = address(bits[i]>>96);\r\n            uint val = bits[i]&lomask;\r\n            depositTo(a, val);\r\n        }\r\n    }\r\n\r\n    // withdraw withdraws tokens to the sender\r\n    // withdraw can be called at most once per redemption period\r\n    function withdraw() notNullified returns(bool) {\r\n        return withdrawTo(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Calculates the fraction of total (one-off + monthly) withdrawable\r\n     * given the current timestamp. No guards due to function being constant.\r\n     * Will output invalid data until the postStart state. It is up to the user\r\n     * to manually confirm contract is in postStart state.\r\n     */\r\n    function availableForWithdrawalAt(uint256 blockTimestamp) constant returns (uint256) {\r\n        /**\r\n         * Calculate the total withdrawable, giving a numerator with range:\r\n         * [0.25 * 10 ** 18, 1 * 10 ** 18]\r\n         */\r\n        return ((t0special + periodAt(blockTimestamp)) * precision) / (t0special + periods);\r\n    }\r\n\r\n    /**\r\n     * Business logic of _withdrawTo, the code is separated this way mainly for\r\n     * testing. We can inject and test parameters freely without worrying about the\r\n     * blockchain model.\r\n     *\r\n     * NOTE: Since function is constant, no guards are applied. This function will give\r\n     * invalid outputs unless in postStart state. It is up to user to manually check\r\n     * that the correct state is given (isStart() == true)\r\n     */\r\n    function _withdrawTo(uint _deposit, uint _withdrawn, uint _blockTimestamp, uint _total) constant returns (uint) {\r\n        uint256 fraction = availableForWithdrawalAt(_blockTimestamp);\r\n\r\n        /**\r\n         * There are concerns that the multiplication could possibly\r\n         * overflow, however this should not be the case if we calculate\r\n         * the upper bound based on our known parameters:\r\n         *\r\n         * Lets assume the minted token amount to be 500 million (reasonable),\r\n         * given a precision of 8 decimal places, we get:\r\n         * deposited[addr] = 5 * (10 ** 8) * (10 ** 8) = 5 * (10 ** 16)\r\n         *\r\n         * The max for fraction = 10 ** 18, and the max for total is\r\n         * also 5 * (10 ** 16).\r\n         *\r\n         * Therefore:\r\n         * deposited[addr] * fraction * total = 2.5 * (10 ** 51)\r\n         *\r\n         * The maximum for a uint256 is = 1.15 * (10 ** 77)\r\n         */\r\n        uint256 withdrawable = ((_deposit * fraction * _total) / totalfv) / precision;\r\n\r\n        // check that we can withdraw something\r\n        if (withdrawable > _withdrawn) {\r\n            return withdrawable - _withdrawn;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Public facing withdrawTo, injects business logic with\r\n     * the correct model.\r\n     */\r\n    function withdrawTo(address addr) postStart notNullified returns (bool) {\r\n        uint _d = deposited[addr];\r\n        uint _w = withdrawn[addr];\r\n\r\n        uint diff = _withdrawTo(_d, _w, block.timestamp, total);\r\n\r\n        // no withdrawal could be made\r\n        if (diff == 0) {\r\n            return false;\r\n        }\r\n\r\n        // check that we cannot withdraw more than max\r\n        require((diff + _w) <= ((_d * total) / totalfv));\r\n\r\n        // transfer and increment\r\n        require(token.transfer(addr, diff));\r\n\r\n        withdrawn[addr] += diff;\r\n        remainder -= diff;\r\n        Withdraws(addr, diff);\r\n        return true;\r\n    }\r\n\r\n    // force withdrawal to many addresses\r\n    function bulkWithdraw(address[] addrs) notNullified {\r\n        for (uint i=0; i<addrs.length; i++)\r\n            withdrawTo(addrs[i]);\r\n    }\r\n\r\n    // Code off the chain informs this contract about\r\n    // tokens that were minted to it on behalf of a depositor.\r\n    //\r\n    // Note: the function signature here is known to New Alchemy's\r\n    // tooling, which is why it is arguably misnamed.\r\n    uint public mintingNonce;\r\n    function multiMint(uint nonce, uint256[] bits) onlyOwner preLock {\r\n\r\n        if (nonce != mintingNonce) return;\r\n        mintingNonce += 1;\r\n        uint256 lomask = (1 << 96) - 1;\r\n        uint sum = 0;\r\n        for (uint i=0; i<bits.length; i++) {\r\n            address a = address(bits[i]>>96);\r\n            uint value = bits[i]&lomask;\r\n            deposited[a] += value;\r\n            sum += value;\r\n            Deposit(a, value);\r\n        }\r\n        totalfv += sum;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Owned"
    UserDefinedTypeName "Owned"
       Source: "Owned"
  VariableDeclaration "periods"
     Type: uint256
     Gas costs: [???]
     Source: "uint public periods"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "t0special"
     Type: uint256
     Gas costs: [???]
     Source: "uint public t0special"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "intervalSecs"
     Type: uint256
     Gas costs: [???]
     Source: "uint constant public intervalSecs = 30 days"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 30
       Type: int_const 2592000
       Source: "30 days"
  VariableDeclaration "precision"
     Type: uint256
     Gas costs: [???]
     Source: "uint constant public precision = 10 ** 18"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator **
       Type: int_const 1000000000000000000
       Source: "10 ** 18"
      Literal, token: [no token] value: 10
         Type: int_const 10
         Source: "10"
      Literal, token: [no token] value: 18
         Type: int_const 18
         Source: "18"
  EventDefinition "Withdraws"
     Gas costs: 0
     Source: "event Withdraws(address indexed who, uint amount);"
    ParameterList
       Source: "(address indexed who, uint amount)"
      VariableDeclaration "who"
         Type: address
         Source: "address indexed who"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Deposit"
     Gas costs: 0
     Source: "event Deposit(address indexed who, uint amount);"
    ParameterList
       Source: "(address indexed who, uint amount)"
      VariableDeclaration "who"
         Type: address
         Source: "address indexed who"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "inited"
     Type: bool
     Gas costs: [???]
     Source: "bool public inited"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "locked"
     Type: bool
     Gas costs: [???]
     Source: "bool public locked"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "startBlockTimestamp"
     Type: uint256
     Gas costs: [???]
     Source: "uint public startBlockTimestamp = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "token"
     Type: contract Token
     Gas costs: [???]
     Source: "Token public token"
    UserDefinedTypeName "Token"
       Source: "Token"
  VariableDeclaration "deposited"
     Type: mapping(address => uint256)
     Gas costs: [???]
     Source: "mapping (address => uint) public deposited"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "totalfv"
     Type: uint256
     Gas costs: [???]
     Source: "uint public totalfv"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "remainder"
     Type: uint256
     Gas costs: [???]
     Source: "uint public remainder"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "total"
     Type: uint256
     Gas costs: [???]
     Source: "uint public total"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "withdrawn"
     Type: mapping(address => uint256)
     Gas costs: [???]
     Source: "mapping (address => uint256) public withdrawn"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "nullified"
     Type: bool
     Gas costs: [???]
     Source: "bool public nullified"
    ElementaryTypeName bool
       Source: "bool"
  ModifierDefinition "notNullified"
     Source: "modifier notNullified() { require(!nullified); _; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ require(!nullified); _; }"
      ExpressionStatement
         Gas costs: 1340
         Source: "require(!nullified)"
        FunctionCall
           Type: tuple()
           Source: "require(!nullified)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!nullified"
            Identifier nullified
               Type: bool
               Source: "nullified"
      PlaceholderStatement
         Gas costs: 1
         Source: "_"
  ModifierDefinition "preLock"
     Source: "modifier preLock() { require(!locked && startBlockTimestamp == 0); _; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ require(!locked && startBlockTimestamp == 0); _; }"
      ExpressionStatement
         Gas costs: 1647
         Source: "require(!locked && startBlockTimestamp == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(!locked && startBlockTimestamp == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "!locked && startBlockTimestamp == 0"
            UnaryOperation (prefix) !
               Type: bool
               Source: "!locked"
              Identifier locked
                 Type: bool
                 Source: "locked"
            BinaryOperation using operator ==
               Type: bool
               Source: "startBlockTimestamp == 0"
              Identifier startBlockTimestamp
                 Type: uint256
                 Source: "startBlockTimestamp"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      PlaceholderStatement
         Gas costs: 1
         Source: "_"
  ModifierDefinition "postLock"
     Source: "modifier postLock() { require(locked); _; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ require(locked); _; }"
      ExpressionStatement
         Gas costs: 315
         Source: "require(locked)"
        FunctionCall
           Type: tuple()
           Source: "require(locked)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier locked
             Type: bool
             Source: "locked"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "preStart"
     Source: "modifier preStart() { require(locked && startBlockTimestamp == 0); _; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ require(locked && startBlockTimestamp == 0); _; }"
      ExpressionStatement
         Gas costs: 546
         Source: "require(locked && startBlockTimestamp == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(locked && startBlockTimestamp == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "locked && startBlockTimestamp == 0"
            Identifier locked
               Type: bool
               Source: "locked"
            BinaryOperation using operator ==
               Type: bool
               Source: "startBlockTimestamp == 0"
              Identifier startBlockTimestamp
                 Type: uint256
                 Source: "startBlockTimestamp"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "postStart"
     Source: "modifier postStart() { require(locked && startBlockTimestamp != 0); _; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ require(locked && startBlockTimestamp != 0); _; }"
      ExpressionStatement
         Gas costs: 549
         Source: "require(locked && startBlockTimestamp != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(locked && startBlockTimestamp != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "locked && startBlockTimestamp != 0"
            Identifier locked
               Type: bool
               Source: "locked"
            BinaryOperation using operator !=
               Type: bool
               Source: "startBlockTimestamp != 0"
              Identifier startBlockTimestamp
                 Type: uint256
                 Source: "startBlockTimestamp"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "notInitialized"
     Source: "modifier notInitialized() { require(!inited); _; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ require(!inited); _; }"
      ExpressionStatement
         Gas costs: 536
         Source: "require(!inited)"
        FunctionCall
           Type: tuple()
           Source: "require(!inited)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!inited"
            Identifier inited
               Type: bool
               Source: "inited"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "initialized"
     Source: "modifier initialized() { require(inited); _; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ require(inited); _; }"
      ExpressionStatement
         Gas costs: 265
         Source: "require(inited)"
        FunctionCall
           Type: tuple()
           Source: "require(inited)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier inited
             Type: bool
             Source: "inited"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "" - public
     Source: "function() {\r\n        revert();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        revert();\r\n    }"
      ExpressionStatement
         Gas costs: 6
         Source: "revert()"
        FunctionCall
           Type: tuple()
           Source: "revert()"
          Identifier revert
             Type: function () pure
             Source: "revert"
  FunctionDefinition "nullify" - public
     Source: "function nullify() onlyOwner {\r\n        nullified = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        nullified = true;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "nullified = true"
        Assignment using operator =
           Type: bool
           Source: "nullified = true"
          Identifier nullified
             Type: bool
             Source: "nullified"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "init" - public
     Source: "function init(uint _periods, uint _t0special) onlyOwner notInitialized {\r\n        require(_periods != 0);\r\n        periods = _periods;\r\n        t0special = _t0special;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _periods, uint _t0special)"
      VariableDeclaration "_periods"
         Type: uint256
         Source: "uint _periods"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_t0special"
         Type: uint256
         Source: "uint _t0special"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "notInitialized"
       Gas costs: 0
       Source: "notInitialized"
      Identifier notInitialized
         Type: modifier ()
         Source: "notInitialized"
    Block
       Source: "{\r\n        require(_periods != 0);\r\n        periods = _periods;\r\n        t0special = _t0special;\r\n    }"
      ExpressionStatement
         Gas costs: 38
         Source: "require(_periods != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_periods != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_periods != 0"
            Identifier _periods
               Type: uint256
               Source: "_periods"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20014
         Source: "periods = _periods"
        Assignment using operator =
           Type: uint256
           Source: "periods = _periods"
          Identifier periods
             Type: uint256
             Source: "periods"
          Identifier _periods
             Type: uint256
             Source: "_periods"
      ExpressionStatement
         Gas costs: 20014
         Source: "t0special = _t0special"
        Assignment using operator =
           Type: uint256
           Source: "t0special = _t0special"
          Identifier t0special
             Type: uint256
             Source: "t0special"
          Identifier _t0special
             Type: uint256
             Source: "_t0special"
  FunctionDefinition "finalizeInit" - public
     Source: "function finalizeInit() onlyOwner notInitialized {\r\n        inited = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "notInitialized"
       Gas costs: 0
       Source: "notInitialized"
      Identifier notInitialized
         Type: modifier ()
         Source: "notInitialized"
    Block
       Source: "{\r\n        inited = true;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "inited = true"
        Assignment using operator =
           Type: bool
           Source: "inited = true"
          Identifier inited
             Type: bool
             Source: "inited"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "setToken" - public
     Source: "function setToken(address tok) onlyOwner {\r\n        token = Token(tok);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address tok)"
      VariableDeclaration "tok"
         Type: address
         Source: "address tok"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        token = Token(tok);\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "token = Token(tok)"
        Assignment using operator =
           Type: contract Token
           Source: "token = Token(tok)"
          Identifier token
             Type: contract Token
             Source: "token"
          FunctionCall
             Type: contract Token
             Source: "Token(tok)"
            Identifier Token
               Type: type(contract Token)
               Source: "Token"
            Identifier tok
               Type: address
               Source: "tok"
  FunctionDefinition "lock" - public
     Source: "function lock() onlyOwner {\r\n        locked = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        locked = true;\r\n    }"
      ExpressionStatement
         Gas costs: 20317
         Source: "locked = true"
        Assignment using operator =
           Type: bool
           Source: "locked = true"
          Identifier locked
             Type: bool
             Source: "locked"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "start" - public
     Source: "function start(uint _startBlockTimestamp) onlyOwner initialized preStart {\r\n        startBlockTimestamp = _startBlockTimestamp;\r\n        uint256 tokenBalance = token.balanceOf(this);\r\n        total = tokenBalance;\r\n        remainder = tokenBalance;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _startBlockTimestamp)"
      VariableDeclaration "_startBlockTimestamp"
         Type: uint256
         Source: "uint _startBlockTimestamp"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "initialized"
       Gas costs: 0
       Source: "initialized"
      Identifier initialized
         Type: modifier ()
         Source: "initialized"
    ModifierInvocation "preStart"
       Gas costs: 0
       Source: "preStart"
      Identifier preStart
         Type: modifier ()
         Source: "preStart"
    Block
       Source: "{\r\n        startBlockTimestamp = _startBlockTimestamp;\r\n        uint256 tokenBalance = token.balanceOf(this);\r\n        total = tokenBalance;\r\n        remainder = tokenBalance;\r\n    }"
      ExpressionStatement
         Gas costs: 20014
         Source: "startBlockTimestamp = _startBlockTimestamp"
        Assignment using operator =
           Type: uint256
           Source: "startBlockTimestamp = _startBlockTimestamp"
          Identifier startBlockTimestamp
             Type: uint256
             Source: "startBlockTimestamp"
          Identifier _startBlockTimestamp
             Type: uint256
             Source: "_startBlockTimestamp"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint256 tokenBalance = token.balanceOf(this)"
        VariableDeclaration "tokenBalance"
           Type: uint256
           Source: "uint256 tokenBalance"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "token.balanceOf(this)"
          MemberAccess to member balanceOf
             Type: function (address) view external returns (uint256)
             Source: "token.balanceOf"
            Identifier token
               Type: contract Token
               Source: "token"
          Identifier this
             Type: contract Savings
             Source: "this"
      ExpressionStatement
         Gas costs: 20014
         Source: "total = tokenBalance"
        Assignment using operator =
           Type: uint256
           Source: "total = tokenBalance"
          Identifier total
             Type: uint256
             Source: "total"
          Identifier tokenBalance
             Type: uint256
             Source: "tokenBalance"
      ExpressionStatement
         Gas costs: 20014
         Source: "remainder = tokenBalance"
        Assignment using operator =
           Type: uint256
           Source: "remainder = tokenBalance"
          Identifier remainder
             Type: uint256
             Source: "remainder"
          Identifier tokenBalance
             Type: uint256
             Source: "tokenBalance"
  FunctionDefinition "isStarted" - public - const
     Source: "function isStarted() constant returns(bool) {\r\n        return locked && startBlockTimestamp != 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        return locked && startBlockTimestamp != 0;\r\n    }"
      Return
         Gas costs: 528
         Source: "return locked && startBlockTimestamp != 0"
        BinaryOperation using operator &&
           Type: bool
           Source: "locked && startBlockTimestamp != 0"
          Identifier locked
             Type: bool
             Source: "locked"
          BinaryOperation using operator !=
             Type: bool
             Source: "startBlockTimestamp != 0"
            Identifier startBlockTimestamp
               Type: uint256
               Source: "startBlockTimestamp"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "refundTokens" - public
     Source: "function refundTokens(address addr, uint amount) onlyOwner preLock {\r\n        token.transfer(addr, amount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address addr, uint amount)"
      VariableDeclaration "addr"
         Type: address
         Source: "address addr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "preLock"
       Gas costs: 0
       Source: "preLock"
      Identifier preLock
         Type: modifier ()
         Source: "preLock"
    Block
       Source: "{\r\n        token.transfer(addr, amount);\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.transfer(addr, amount)"
        FunctionCall
           Type: bool
           Source: "token.transfer(addr, amount)"
          MemberAccess to member transfer
             Type: function (address,uint256) external returns (bool)
             Source: "token.transfer"
            Identifier token
               Type: contract Token
               Source: "token"
          Identifier addr
             Type: address
             Source: "addr"
          Identifier amount
             Type: uint256
             Source: "amount"
  FunctionDefinition "updateTotal" - public
     Source: "function updateTotal() onlyOwner postLock {\r\n        uint current = token.balanceOf(this);\r\n        require(current >= remainder); // for sanity\r\n\r\n        uint difference = (current - remainder);\r\n        total += difference;\r\n        remainder = current;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "postLock"
       Gas costs: 0
       Source: "postLock"
      Identifier postLock
         Type: modifier ()
         Source: "postLock"
    Block
       Source: "{\r\n        uint current = token.balanceOf(this);\r\n        require(current >= remainder); // for sanity\r\n\r\n        uint difference = (current - remainder);\r\n        total += difference;\r\n        remainder = current;\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint current = token.balanceOf(this)"
        VariableDeclaration "current"
           Type: uint256
           Source: "uint current"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "token.balanceOf(this)"
          MemberAccess to member balanceOf
             Type: function (address) view external returns (uint256)
             Source: "token.balanceOf"
            Identifier token
               Type: contract Token
               Source: "token"
          Identifier this
             Type: contract Savings
             Source: "this"
      ExpressionStatement
         Gas costs: 238
         Source: "require(current >= remainder)"
        FunctionCall
           Type: tuple()
           Source: "require(current >= remainder)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "current >= remainder"
            Identifier current
               Type: uint256
               Source: "current"
            Identifier remainder
               Type: uint256
               Source: "remainder"
      VariableDeclarationStatement
         Gas costs: 217
         Source: "uint difference = (current - remainder)"
        VariableDeclaration "difference"
           Type: uint256
           Source: "uint difference"
          ElementaryTypeName uint
             Source: "uint"
        TupleExpression
           Type: uint256
           Source: "(current - remainder)"
          BinaryOperation using operator -
             Type: uint256
             Source: "current - remainder"
            Identifier current
               Type: uint256
               Source: "current"
            Identifier remainder
               Type: uint256
               Source: "remainder"
      ExpressionStatement
         Gas costs: 20233
         Source: "total += difference"
        Assignment using operator +=
           Type: uint256
           Source: "total += difference"
          Identifier total
             Type: uint256
             Source: "total"
          Identifier difference
             Type: uint256
             Source: "difference"
      ExpressionStatement
         Gas costs: 20014
         Source: "remainder = current"
        Assignment using operator =
           Type: uint256
           Source: "remainder = current"
          Identifier remainder
             Type: uint256
             Source: "remainder"
          Identifier current
             Type: uint256
             Source: "current"
  FunctionDefinition "periodAt" - public - const
     Source: "function periodAt(uint _blockTimestamp) constant returns(uint) {\r\n        /**\r\n         * Lower bound, consider period 0 to be the time between\r\n         * start() and startBlockTimestamp\r\n         */\r\n        if (startBlockTimestamp > _blockTimestamp)\r\n            return 0;\r\n\r\n        /**\r\n         * Calculate the appropriate period, and set an upper bound of\r\n         * periods - 1.\r\n         */\r\n        uint p = ((_blockTimestamp - startBlockTimestamp) / intervalSecs) + 1;\r\n        if (p > periods)\r\n            p = periods;\r\n        return p;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _blockTimestamp)"
      VariableDeclaration "_blockTimestamp"
         Type: uint256
         Source: "uint _blockTimestamp"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        /**\r\n         * Lower bound, consider period 0 to be the time between\r\n         * start() and startBlockTimestamp\r\n         */\r\n        if (startBlockTimestamp > _blockTimestamp)\r\n            return 0;\r\n\r\n        /**\r\n         * Calculate the appropriate period, and set an upper bound of\r\n         * periods - 1.\r\n         */\r\n        uint p = ((_blockTimestamp - startBlockTimestamp) / intervalSecs) + 1;\r\n        if (p > periods)\r\n            p = periods;\r\n        return p;\r\n    }"
      IfStatement
         Source: "if (startBlockTimestamp > _blockTimestamp)\r\n            return 0"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "startBlockTimestamp > _blockTimestamp"
          Identifier startBlockTimestamp
             Type: uint256
             Source: "startBlockTimestamp"
          Identifier _blockTimestamp
             Type: uint256
             Source: "_blockTimestamp"
        Return
           Gas costs: 19
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      VariableDeclarationStatement
         Gas costs: 251
         Source: "uint p = ((_blockTimestamp - startBlockTimestamp) / intervalSecs) + 1"
        VariableDeclaration "p"
           Type: uint256
           Source: "uint p"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "((_blockTimestamp - startBlockTimestamp) / intervalSecs) + 1"
          TupleExpression
             Type: uint256
             Source: "((_blockTimestamp - startBlockTimestamp) / intervalSecs)"
            BinaryOperation using operator /
               Type: uint256
               Source: "(_blockTimestamp - startBlockTimestamp) / intervalSecs"
              TupleExpression
                 Type: uint256
                 Source: "(_blockTimestamp - startBlockTimestamp)"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "_blockTimestamp - startBlockTimestamp"
                  Identifier _blockTimestamp
                     Type: uint256
                     Source: "_blockTimestamp"
                  Identifier startBlockTimestamp
                     Type: uint256
                     Source: "startBlockTimestamp"
              Identifier intervalSecs
                 Type: uint256
                 Source: "intervalSecs"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      IfStatement
         Source: "if (p > periods)\r\n            p = periods"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "p > periods"
          Identifier p
             Type: uint256
             Source: "p"
          Identifier periods
             Type: uint256
             Source: "periods"
        ExpressionStatement
           Gas costs: 208
           Source: "p = periods"
          Assignment using operator =
             Type: uint256
             Source: "p = periods"
            Identifier p
               Type: uint256
               Source: "p"
            Identifier periods
               Type: uint256
               Source: "periods"
      Return
         Gas costs: 8
         Source: "return p"
        Identifier p
           Type: uint256
           Source: "p"
  FunctionDefinition "period" - public - const
     Source: "function period() constant returns(uint) {\r\n        return periodAt(block.timestamp);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return periodAt(block.timestamp);\r\n    }"
      Return
         Gas costs: 22
         Source: "return periodAt(block.timestamp)"
        FunctionCall
           Type: uint256
           Source: "periodAt(block.timestamp)"
          Identifier periodAt
             Type: function (uint256) view returns (uint256)
             Source: "periodAt"
          MemberAccess to member timestamp
             Type: uint256
             Source: "block.timestamp"
            Identifier block
               Type: block
               Source: "block"
  FunctionDefinition "deposit" - public
     Source: "function deposit(uint tokens) notNullified {\r\n        depositTo(msg.sender, tokens);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint tokens)"
      VariableDeclaration "tokens"
         Type: uint256
         Source: "uint tokens"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "notNullified"
       Gas costs: 0
       Source: "notNullified"
      Identifier notNullified
         Type: modifier ()
         Source: "notNullified"
    Block
       Source: "{\r\n        depositTo(msg.sender, tokens);\r\n    }"
      ExpressionStatement
         Gas costs: 20
         Source: "depositTo(msg.sender, tokens)"
        FunctionCall
           Type: tuple()
           Source: "depositTo(msg.sender, tokens)"
          Identifier depositTo
             Type: function (address,uint256)
             Source: "depositTo"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier tokens
             Type: uint256
             Source: "tokens"
  FunctionDefinition "depositTo" - public
     Source: "function depositTo(address beneficiary, uint tokens) preLock notNullified {\r\n        require(token.transferFrom(msg.sender, this, tokens));\r\n        deposited[beneficiary] += tokens;\r\n        totalfv += tokens;\r\n        Deposit(beneficiary, tokens);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address beneficiary, uint tokens)"
      VariableDeclaration "beneficiary"
         Type: address
         Source: "address beneficiary"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "tokens"
         Type: uint256
         Source: "uint tokens"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "preLock"
       Gas costs: 0
       Source: "preLock"
      Identifier preLock
         Type: modifier ()
         Source: "preLock"
    ModifierInvocation "notNullified"
       Gas costs: 0
       Source: "notNullified"
      Identifier notNullified
         Type: modifier ()
         Source: "notNullified"
    Block
       Source: "{\r\n        require(token.transferFrom(msg.sender, this, tokens));\r\n        deposited[beneficiary] += tokens;\r\n        totalfv += tokens;\r\n        Deposit(beneficiary, tokens);\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(token.transferFrom(msg.sender, this, tokens))"
        FunctionCall
           Type: tuple()
           Source: "require(token.transferFrom(msg.sender, this, tokens))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "token.transferFrom(msg.sender, this, tokens)"
            MemberAccess to member transferFrom
               Type: function (address,address,uint256) external returns (bool)
               Source: "token.transferFrom"
              Identifier token
                 Type: contract Token
                 Source: "token"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier this
               Type: contract Savings
               Source: "this"
            Identifier tokens
               Type: uint256
               Source: "tokens"
      ExpressionStatement
         Gas costs: 20329
         Source: "deposited[beneficiary] += tokens"
        Assignment using operator +=
           Type: uint256
           Source: "deposited[beneficiary] += tokens"
          IndexAccess
             Type: uint256
             Source: "deposited[beneficiary]"
            Identifier deposited
               Type: mapping(address => uint256)
               Source: "deposited"
            Identifier beneficiary
               Type: address
               Source: "beneficiary"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalfv += tokens"
        Assignment using operator +=
           Type: uint256
           Source: "totalfv += tokens"
          Identifier totalfv
             Type: uint256
             Source: "totalfv"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "Deposit(beneficiary, tokens)"
        FunctionCall
           Type: tuple()
           Source: "Deposit(beneficiary, tokens)"
          Identifier Deposit
             Type: function (address,uint256)
             Source: "Deposit"
          Identifier beneficiary
             Type: address
             Source: "beneficiary"
          Identifier tokens
             Type: uint256
             Source: "tokens"
  FunctionDefinition "bulkDepositTo" - public
     Source: "function bulkDepositTo(uint256[] bits) onlyOwner {\r\n        uint256 lomask = (1 << 96) - 1;\r\n        for (uint i=0; i<bits.length; i++) {\r\n            address a = address(bits[i]>>96);\r\n            uint val = bits[i]&lomask;\r\n            depositTo(a, val);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256[] bits)"
      VariableDeclaration "bits"
         Type: uint256[] memory
         Source: "uint256[] bits"
        ArrayTypeName
           Source: "uint256[]"
          ElementaryTypeName uint256
             Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        uint256 lomask = (1 << 96) - 1;\r\n        for (uint i=0; i<bits.length; i++) {\r\n            address a = address(bits[i]>>96);\r\n            uint val = bits[i]&lomask;\r\n            depositTo(a, val);\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint256 lomask = (1 << 96) - 1"
        VariableDeclaration "lomask"
           Type: uint256
           Source: "uint256 lomask"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator -
           Type: int_const 79228162514264337593543950335
           Source: "(1 << 96) - 1"
          TupleExpression
             Type: int_const 79228162514264337593543950336
             Source: "(1 << 96)"
            BinaryOperation using operator <<
               Type: int_const 79228162514264337593543950336
               Source: "1 << 96"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
              Literal, token: [no token] value: 96
                 Type: int_const 96
                 Source: "96"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ForStatement
         Source: "for (uint i=0; i<bits.length; i++) {\r\n            address a = address(bits[i]>>96);\r\n            uint val = bits[i]&lomask;\r\n            depositTo(a, val);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "i<bits.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "bits.length"
            Identifier bits
               Type: uint256[] memory
               Source: "bits"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            address a = address(bits[i]>>96);\r\n            uint val = bits[i]&lomask;\r\n            depositTo(a, val);\r\n        }"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "address a = address(bits[i]>>96)"
            VariableDeclaration "a"
               Type: address
               Source: "address a"
              ElementaryTypeName address
                 Source: "address"
            FunctionCall
               Type: address
               Source: "address(bits[i]>>96)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              BinaryOperation using operator >>
                 Type: uint256
                 Source: "bits[i]>>96"
                IndexAccess
                   Type: uint256
                   Source: "bits[i]"
                  Identifier bits
                     Type: uint256[] memory
                     Source: "bits"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: [no token] value: 96
                   Type: int_const 96
                   Source: "96"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "uint val = bits[i]&lomask"
            VariableDeclaration "val"
               Type: uint256
               Source: "uint val"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator &
               Type: uint256
               Source: "bits[i]&lomask"
              IndexAccess
                 Type: uint256
                 Source: "bits[i]"
                Identifier bits
                   Type: uint256[] memory
                   Source: "bits"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier lomask
                 Type: uint256
                 Source: "lomask"
          ExpressionStatement
             Gas costs: 21
             Source: "depositTo(a, val)"
            FunctionCall
               Type: tuple()
               Source: "depositTo(a, val)"
              Identifier depositTo
                 Type: function (address,uint256)
                 Source: "depositTo"
              Identifier a
                 Type: address
                 Source: "a"
              Identifier val
                 Type: uint256
                 Source: "val"
  FunctionDefinition "withdraw" - public
     Source: "function withdraw() notNullified returns(bool) {\r\n        return withdrawTo(msg.sender);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "notNullified"
       Gas costs: 0
       Source: "notNullified"
      Identifier notNullified
         Type: modifier ()
         Source: "notNullified"
    Block
       Source: "{\r\n        return withdrawTo(msg.sender);\r\n    }"
      Return
         Gas costs: 22
         Source: "return withdrawTo(msg.sender)"
        FunctionCall
           Type: bool
           Source: "withdrawTo(msg.sender)"
          Identifier withdrawTo
             Type: function (address) returns (bool)
             Source: "withdrawTo"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "availableForWithdrawalAt" - public - const
     Source: "function availableForWithdrawalAt(uint256 blockTimestamp) constant returns (uint256) {\r\n        /**\r\n         * Calculate the total withdrawable, giving a numerator with range:\r\n         * [0.25 * 10 ** 18, 1 * 10 ** 18]\r\n         */\r\n        return ((t0special + periodAt(blockTimestamp)) * precision) / (t0special + periods);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 blockTimestamp)"
      VariableDeclaration "blockTimestamp"
         Type: uint256
         Source: "uint256 blockTimestamp"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        /**\r\n         * Calculate the total withdrawable, giving a numerator with range:\r\n         * [0.25 * 10 ** 18, 1 * 10 ** 18]\r\n         */\r\n        return ((t0special + periodAt(blockTimestamp)) * precision) / (t0special + periods);\r\n    }"
      Return
         Gas costs: 660
         Source: "return ((t0special + periodAt(blockTimestamp)) * precision) / (t0special + periods)"
        BinaryOperation using operator /
           Type: uint256
           Source: "((t0special + periodAt(blockTimestamp)) * precision) / (t0special + periods)"
          TupleExpression
             Type: uint256
             Source: "((t0special + periodAt(blockTimestamp)) * precision)"
            BinaryOperation using operator *
               Type: uint256
               Source: "(t0special + periodAt(blockTimestamp)) * precision"
              TupleExpression
                 Type: uint256
                 Source: "(t0special + periodAt(blockTimestamp))"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "t0special + periodAt(blockTimestamp)"
                  Identifier t0special
                     Type: uint256
                     Source: "t0special"
                  FunctionCall
                     Type: uint256
                     Source: "periodAt(blockTimestamp)"
                    Identifier periodAt
                       Type: function (uint256) view returns (uint256)
                       Source: "periodAt"
                    Identifier blockTimestamp
                       Type: uint256
                       Source: "blockTimestamp"
              Identifier precision
                 Type: uint256
                 Source: "precision"
          TupleExpression
             Type: uint256
             Source: "(t0special + periods)"
            BinaryOperation using operator +
               Type: uint256
               Source: "t0special + periods"
              Identifier t0special
                 Type: uint256
                 Source: "t0special"
              Identifier periods
                 Type: uint256
                 Source: "periods"
  FunctionDefinition "_withdrawTo" - public - const
     Source: "function _withdrawTo(uint _deposit, uint _withdrawn, uint _blockTimestamp, uint _total) constant returns (uint) {\r\n        uint256 fraction = availableForWithdrawalAt(_blockTimestamp);\r\n\r\n        /**\r\n         * There are concerns that the multiplication could possibly\r\n         * overflow, however this should not be the case if we calculate\r\n         * the upper bound based on our known parameters:\r\n         *\r\n         * Lets assume the minted token amount to be 500 million (reasonable),\r\n         * given a precision of 8 decimal places, we get:\r\n         * deposited[addr] = 5 * (10 ** 8) * (10 ** 8) = 5 * (10 ** 16)\r\n         *\r\n         * The max for fraction = 10 ** 18, and the max for total is\r\n         * also 5 * (10 ** 16).\r\n         *\r\n         * Therefore:\r\n         * deposited[addr] * fraction * total = 2.5 * (10 ** 51)\r\n         *\r\n         * The maximum for a uint256 is = 1.15 * (10 ** 77)\r\n         */\r\n        uint256 withdrawable = ((_deposit * fraction * _total) / totalfv) / precision;\r\n\r\n        // check that we can withdraw something\r\n        if (withdrawable > _withdrawn) {\r\n            return withdrawable - _withdrawn;\r\n        }\r\n        return 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _deposit, uint _withdrawn, uint _blockTimestamp, uint _total)"
      VariableDeclaration "_deposit"
         Type: uint256
         Source: "uint _deposit"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_withdrawn"
         Type: uint256
         Source: "uint _withdrawn"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_blockTimestamp"
         Type: uint256
         Source: "uint _blockTimestamp"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_total"
         Type: uint256
         Source: "uint _total"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint256 fraction = availableForWithdrawalAt(_blockTimestamp);\r\n\r\n        /**\r\n         * There are concerns that the multiplication could possibly\r\n         * overflow, however this should not be the case if we calculate\r\n         * the upper bound based on our known parameters:\r\n         *\r\n         * Lets assume the minted token amount to be 500 million (reasonable),\r\n         * given a precision of 8 decimal places, we get:\r\n         * deposited[addr] = 5 * (10 ** 8) * (10 ** 8) = 5 * (10 ** 16)\r\n         *\r\n         * The max for fraction = 10 ** 18, and the max for total is\r\n         * also 5 * (10 ** 16).\r\n         *\r\n         * Therefore:\r\n         * deposited[addr] * fraction * total = 2.5 * (10 ** 51)\r\n         *\r\n         * The maximum for a uint256 is = 1.15 * (10 ** 77)\r\n         */\r\n        uint256 withdrawable = ((_deposit * fraction * _total) / totalfv) / precision;\r\n\r\n        // check that we can withdraw something\r\n        if (withdrawable > _withdrawn) {\r\n            return withdrawable - _withdrawn;\r\n        }\r\n        return 0;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint256 fraction = availableForWithdrawalAt(_blockTimestamp)"
        VariableDeclaration "fraction"
           Type: uint256
           Source: "uint256 fraction"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "availableForWithdrawalAt(_blockTimestamp)"
          Identifier availableForWithdrawalAt
             Type: function (uint256) view returns (uint256)
             Source: "availableForWithdrawalAt"
          Identifier _blockTimestamp
             Type: uint256
             Source: "_blockTimestamp"
      VariableDeclarationStatement
         Gas costs: 286
         Source: "uint256 withdrawable = ((_deposit * fraction * _total) / totalfv) / precision"
        VariableDeclaration "withdrawable"
           Type: uint256
           Source: "uint256 withdrawable"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "((_deposit * fraction * _total) / totalfv) / precision"
          TupleExpression
             Type: uint256
             Source: "((_deposit * fraction * _total) / totalfv)"
            BinaryOperation using operator /
               Type: uint256
               Source: "(_deposit * fraction * _total) / totalfv"
              TupleExpression
                 Type: uint256
                 Source: "(_deposit * fraction * _total)"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "_deposit * fraction * _total"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "_deposit * fraction"
                    Identifier _deposit
                       Type: uint256
                       Source: "_deposit"
                    Identifier fraction
                       Type: uint256
                       Source: "fraction"
                  Identifier _total
                     Type: uint256
                     Source: "_total"
              Identifier totalfv
                 Type: uint256
                 Source: "totalfv"
          Identifier precision
             Type: uint256
             Source: "precision"
      IfStatement
         Source: "if (withdrawable > _withdrawn) {\r\n            return withdrawable - _withdrawn;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "withdrawable > _withdrawn"
          Identifier withdrawable
             Type: uint256
             Source: "withdrawable"
          Identifier _withdrawn
             Type: uint256
             Source: "_withdrawn"
        Block
           Source: "{\r\n            return withdrawable - _withdrawn;\r\n        }"
          Return
             Gas costs: 25
             Source: "return withdrawable - _withdrawn"
            BinaryOperation using operator -
               Type: uint256
               Source: "withdrawable - _withdrawn"
              Identifier withdrawable
                 Type: uint256
                 Source: "withdrawable"
              Identifier _withdrawn
                 Type: uint256
                 Source: "_withdrawn"
      Return
         Gas costs: 8
         Source: "return 0"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
  FunctionDefinition "withdrawTo" - public
     Source: "function withdrawTo(address addr) postStart notNullified returns (bool) {\r\n        uint _d = deposited[addr];\r\n        uint _w = withdrawn[addr];\r\n\r\n        uint diff = _withdrawTo(_d, _w, block.timestamp, total);\r\n\r\n        // no withdrawal could be made\r\n        if (diff == 0) {\r\n            return false;\r\n        }\r\n\r\n        // check that we cannot withdraw more than max\r\n        require((diff + _w) <= ((_d * total) / totalfv));\r\n\r\n        // transfer and increment\r\n        require(token.transfer(addr, diff));\r\n\r\n        withdrawn[addr] += diff;\r\n        remainder -= diff;\r\n        Withdraws(addr, diff);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address addr)"
      VariableDeclaration "addr"
         Type: address
         Source: "address addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "postStart"
       Gas costs: 0
       Source: "postStart"
      Identifier postStart
         Type: modifier ()
         Source: "postStart"
    ModifierInvocation "notNullified"
       Gas costs: 0
       Source: "notNullified"
      Identifier notNullified
         Type: modifier ()
         Source: "notNullified"
    Block
       Source: "{\r\n        uint _d = deposited[addr];\r\n        uint _w = withdrawn[addr];\r\n\r\n        uint diff = _withdrawTo(_d, _w, block.timestamp, total);\r\n\r\n        // no withdrawal could be made\r\n        if (diff == 0) {\r\n            return false;\r\n        }\r\n\r\n        // check that we cannot withdraw more than max\r\n        require((diff + _w) <= ((_d * total) / totalfv));\r\n\r\n        // transfer and increment\r\n        require(token.transfer(addr, diff));\r\n\r\n        withdrawn[addr] += diff;\r\n        remainder -= diff;\r\n        Withdraws(addr, diff);\r\n        return true;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 307
         Source: "uint _d = deposited[addr]"
        VariableDeclaration "_d"
           Type: uint256
           Source: "uint _d"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "deposited[addr]"
          Identifier deposited
             Type: mapping(address => uint256)
             Source: "deposited"
          Identifier addr
             Type: address
             Source: "addr"
      VariableDeclarationStatement
         Gas costs: 301
         Source: "uint _w = withdrawn[addr]"
        VariableDeclaration "_w"
           Type: uint256
           Source: "uint _w"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "withdrawn[addr]"
          Identifier withdrawn
             Type: mapping(address => uint256)
             Source: "withdrawn"
          Identifier addr
             Type: address
             Source: "addr"
      VariableDeclarationStatement
         Gas costs: 234
         Source: "uint diff = _withdrawTo(_d, _w, block.timestamp, total)"
        VariableDeclaration "diff"
           Type: uint256
           Source: "uint diff"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "_withdrawTo(_d, _w, block.timestamp, total)"
          Identifier _withdrawTo
             Type: function (uint256,uint256,uint256,uint256) view returns (uint256)
             Source: "_withdrawTo"
          Identifier _d
             Type: uint256
             Source: "_d"
          Identifier _w
             Type: uint256
             Source: "_w"
          MemberAccess to member timestamp
             Type: uint256
             Source: "block.timestamp"
            Identifier block
               Type: block
               Source: "block"
          Identifier total
             Type: uint256
             Source: "total"
      IfStatement
         Source: "if (diff == 0) {\r\n            return false;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "diff == 0"
          Identifier diff
             Type: uint256
             Source: "diff"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            return false;\r\n        }"
          Return
             Gas costs: 19
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      ExpressionStatement
         Gas costs: 483
         Source: "require((diff + _w) <= ((_d * total) / totalfv))"
        FunctionCall
           Type: tuple()
           Source: "require((diff + _w) <= ((_d * total) / totalfv))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "(diff + _w) <= ((_d * total) / totalfv)"
            TupleExpression
               Type: uint256
               Source: "(diff + _w)"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "diff + _w"
                Identifier diff
                   Type: uint256
                   Source: "diff"
                Identifier _w
                   Type: uint256
                   Source: "_w"
            TupleExpression
               Type: uint256
               Source: "((_d * total) / totalfv)"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "(_d * total) / totalfv"
                TupleExpression
                   Type: uint256
                   Source: "(_d * total)"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "_d * total"
                    Identifier _d
                       Type: uint256
                       Source: "_d"
                    Identifier total
                       Type: uint256
                       Source: "total"
                Identifier totalfv
                   Type: uint256
                   Source: "totalfv"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(token.transfer(addr, diff))"
        FunctionCall
           Type: tuple()
           Source: "require(token.transfer(addr, diff))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "token.transfer(addr, diff)"
            MemberAccess to member transfer
               Type: function (address,uint256) external returns (bool)
               Source: "token.transfer"
              Identifier token
                 Type: contract Token
                 Source: "token"
            Identifier addr
               Type: address
               Source: "addr"
            Identifier diff
               Type: uint256
               Source: "diff"
      ExpressionStatement
         Gas costs: 20329
         Source: "withdrawn[addr] += diff"
        Assignment using operator +=
           Type: uint256
           Source: "withdrawn[addr] += diff"
          IndexAccess
             Type: uint256
             Source: "withdrawn[addr]"
            Identifier withdrawn
               Type: mapping(address => uint256)
               Source: "withdrawn"
            Identifier addr
               Type: address
               Source: "addr"
          Identifier diff
             Type: uint256
             Source: "diff"
      ExpressionStatement
         Gas costs: 20233
         Source: "remainder -= diff"
        Assignment using operator -=
           Type: uint256
           Source: "remainder -= diff"
          Identifier remainder
             Type: uint256
             Source: "remainder"
          Identifier diff
             Type: uint256
             Source: "diff"
      ExpressionStatement
         Gas costs: [???]
         Source: "Withdraws(addr, diff)"
        FunctionCall
           Type: tuple()
           Source: "Withdraws(addr, diff)"
          Identifier Withdraws
             Type: function (address,uint256)
             Source: "Withdraws"
          Identifier addr
             Type: address
             Source: "addr"
          Identifier diff
             Type: uint256
             Source: "diff"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "bulkWithdraw" - public
     Source: "function bulkWithdraw(address[] addrs) notNullified {\r\n        for (uint i=0; i<addrs.length; i++)\r\n            withdrawTo(addrs[i]);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] addrs)"
      VariableDeclaration "addrs"
         Type: address[] memory
         Source: "address[] addrs"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "notNullified"
       Gas costs: 0
       Source: "notNullified"
      Identifier notNullified
         Type: modifier ()
         Source: "notNullified"
    Block
       Source: "{\r\n        for (uint i=0; i<addrs.length; i++)\r\n            withdrawTo(addrs[i]);\r\n    }"
      ForStatement
         Source: "for (uint i=0; i<addrs.length; i++)\r\n            withdrawTo(addrs[i])"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "i<addrs.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "addrs.length"
            Identifier addrs
               Type: address[] memory
               Source: "addrs"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        ExpressionStatement
           Gas costs: [???]
           Source: "withdrawTo(addrs[i])"
          FunctionCall
             Type: bool
             Source: "withdrawTo(addrs[i])"
            Identifier withdrawTo
               Type: function (address) returns (bool)
               Source: "withdrawTo"
            IndexAccess
               Type: address
               Source: "addrs[i]"
              Identifier addrs
                 Type: address[] memory
                 Source: "addrs"
              Identifier i
                 Type: uint256
                 Source: "i"
  VariableDeclaration "mintingNonce"
     Type: uint256
     Gas costs: [???]
     Source: "uint public mintingNonce"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "multiMint" - public
     Source: "function multiMint(uint nonce, uint256[] bits) onlyOwner preLock {\r\n\r\n        if (nonce != mintingNonce) return;\r\n        mintingNonce += 1;\r\n        uint256 lomask = (1 << 96) - 1;\r\n        uint sum = 0;\r\n        for (uint i=0; i<bits.length; i++) {\r\n            address a = address(bits[i]>>96);\r\n            uint value = bits[i]&lomask;\r\n            deposited[a] += value;\r\n            sum += value;\r\n            Deposit(a, value);\r\n        }\r\n        totalfv += sum;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint nonce, uint256[] bits)"
      VariableDeclaration "nonce"
         Type: uint256
         Source: "uint nonce"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "bits"
         Type: uint256[] memory
         Source: "uint256[] bits"
        ArrayTypeName
           Source: "uint256[]"
          ElementaryTypeName uint256
             Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "preLock"
       Gas costs: 0
       Source: "preLock"
      Identifier preLock
         Type: modifier ()
         Source: "preLock"
    Block
       Source: "{\r\n\r\n        if (nonce != mintingNonce) return;\r\n        mintingNonce += 1;\r\n        uint256 lomask = (1 << 96) - 1;\r\n        uint sum = 0;\r\n        for (uint i=0; i<bits.length; i++) {\r\n            address a = address(bits[i]>>96);\r\n            uint value = bits[i]&lomask;\r\n            deposited[a] += value;\r\n            sum += value;\r\n            Deposit(a, value);\r\n        }\r\n        totalfv += sum;\r\n    }"
      IfStatement
         Source: "if (nonce != mintingNonce) return;"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 212
           Source: "nonce != mintingNonce"
          Identifier nonce
             Type: uint256
             Source: "nonce"
          Identifier mintingNonce
             Type: uint256
             Source: "mintingNonce"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 20233
         Source: "mintingNonce += 1"
        Assignment using operator +=
           Type: uint256
           Source: "mintingNonce += 1"
          Identifier mintingNonce
             Type: uint256
             Source: "mintingNonce"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint256 lomask = (1 << 96) - 1"
        VariableDeclaration "lomask"
           Type: uint256
           Source: "uint256 lomask"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator -
           Type: int_const 79228162514264337593543950335
           Source: "(1 << 96) - 1"
          TupleExpression
             Type: int_const 79228162514264337593543950336
             Source: "(1 << 96)"
            BinaryOperation using operator <<
               Type: int_const 79228162514264337593543950336
               Source: "1 << 96"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
              Literal, token: [no token] value: 96
                 Type: int_const 96
                 Source: "96"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint sum = 0"
        VariableDeclaration "sum"
           Type: uint256
           Source: "uint sum"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for (uint i=0; i<bits.length; i++) {\r\n            address a = address(bits[i]>>96);\r\n            uint value = bits[i]&lomask;\r\n            deposited[a] += value;\r\n            sum += value;\r\n            Deposit(a, value);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "i<bits.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "bits.length"
            Identifier bits
               Type: uint256[] memory
               Source: "bits"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            address a = address(bits[i]>>96);\r\n            uint value = bits[i]&lomask;\r\n            deposited[a] += value;\r\n            sum += value;\r\n            Deposit(a, value);\r\n        }"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "address a = address(bits[i]>>96)"
            VariableDeclaration "a"
               Type: address
               Source: "address a"
              ElementaryTypeName address
                 Source: "address"
            FunctionCall
               Type: address
               Source: "address(bits[i]>>96)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              BinaryOperation using operator >>
                 Type: uint256
                 Source: "bits[i]>>96"
                IndexAccess
                   Type: uint256
                   Source: "bits[i]"
                  Identifier bits
                     Type: uint256[] memory
                     Source: "bits"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: [no token] value: 96
                   Type: int_const 96
                   Source: "96"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "uint value = bits[i]&lomask"
            VariableDeclaration "value"
               Type: uint256
               Source: "uint value"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator &
               Type: uint256
               Source: "bits[i]&lomask"
              IndexAccess
                 Type: uint256
                 Source: "bits[i]"
                Identifier bits
                   Type: uint256[] memory
                   Source: "bits"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier lomask
                 Type: uint256
                 Source: "lomask"
          ExpressionStatement
             Gas costs: 20329
             Source: "deposited[a] += value"
            Assignment using operator +=
               Type: uint256
               Source: "deposited[a] += value"
              IndexAccess
                 Type: uint256
                 Source: "deposited[a]"
                Identifier deposited
                   Type: mapping(address => uint256)
                   Source: "deposited"
                Identifier a
                   Type: address
                   Source: "a"
              Identifier value
                 Type: uint256
                 Source: "value"
          ExpressionStatement
             Gas costs: 14
             Source: "sum += value"
            Assignment using operator +=
               Type: uint256
               Source: "sum += value"
              Identifier sum
                 Type: uint256
                 Source: "sum"
              Identifier value
                 Type: uint256
                 Source: "value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Deposit(a, value)"
            FunctionCall
               Type: tuple()
               Source: "Deposit(a, value)"
              Identifier Deposit
                 Type: function (address,uint256)
                 Source: "Deposit"
              Identifier a
                 Type: address
                 Source: "a"
              Identifier value
                 Type: uint256
                 Source: "value"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalfv += sum"
        Assignment using operator +=
           Type: uint256
           Source: "totalfv += sum"
          Identifier totalfv
             Type: uint256
             Source: "totalfv"
          Identifier sum
             Type: uint256
             Source: "sum"
