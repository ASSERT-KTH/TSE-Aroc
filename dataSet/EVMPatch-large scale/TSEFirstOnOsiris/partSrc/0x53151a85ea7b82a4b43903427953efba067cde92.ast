Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x53151a85ea7b82a4b43903427953efba067cde92.sol =======
ContractDefinition "SafeMath"
   Source: "contract SafeMath {\r\n    \r\n    uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        require(x <= MAX_UINT256 - y);\r\n        return x + y;\r\n    }\r\n\r\n    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        require(x >= y);\r\n        return x - y;\r\n    }\r\n\r\n    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (y == 0) {\r\n            return 0;\r\n        }\r\n        require(x <= (MAX_UINT256 / y));\r\n        return x * y;\r\n    }\r\n}"
  VariableDeclaration "MAX_UINT256"
     Type: uint256
     Gas costs: 0
     Source: "uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
       Type: int_const 1157...(70 digits omitted)...9935
       Source: "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
  FunctionDefinition "safeAdd" - const
     Source: "function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        require(x <= MAX_UINT256 - y);\r\n        return x + y;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256 z)"
      VariableDeclaration "z"
         Type: uint256
         Source: "uint256 z"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        require(x <= MAX_UINT256 - y);\r\n        return x + y;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(x <= MAX_UINT256 - y)"
        FunctionCall
           Type: tuple()
           Source: "require(x <= MAX_UINT256 - y)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "x <= MAX_UINT256 - y"
            Identifier x
               Type: uint256
               Source: "x"
            BinaryOperation using operator -
               Type: uint256
               Source: "MAX_UINT256 - y"
              Identifier MAX_UINT256
                 Type: uint256
                 Source: "MAX_UINT256"
              Identifier y
                 Type: uint256
                 Source: "y"
      Return
         Gas costs: 0
         Source: "return x + y"
        BinaryOperation using operator +
           Type: uint256
           Source: "x + y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
  FunctionDefinition "safeSub" - const
     Source: "function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        require(x >= y);\r\n        return x - y;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256 z)"
      VariableDeclaration "z"
         Type: uint256
         Source: "uint256 z"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        require(x >= y);\r\n        return x - y;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(x >= y)"
        FunctionCall
           Type: tuple()
           Source: "require(x >= y)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "x >= y"
            Identifier x
               Type: uint256
               Source: "x"
            Identifier y
               Type: uint256
               Source: "y"
      Return
         Gas costs: 0
         Source: "return x - y"
        BinaryOperation using operator -
           Type: uint256
           Source: "x - y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
  FunctionDefinition "safeMul" - const
     Source: "function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (y == 0) {\r\n            return 0;\r\n        }\r\n        require(x <= (MAX_UINT256 / y));\r\n        return x * y;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256 z)"
      VariableDeclaration "z"
         Type: uint256
         Source: "uint256 z"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        if (y == 0) {\r\n            return 0;\r\n        }\r\n        require(x <= (MAX_UINT256 / y));\r\n        return x * y;\r\n    }"
      IfStatement
         Source: "if (y == 0) {\r\n            return 0;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "y == 0"
          Identifier y
             Type: uint256
             Source: "y"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            return 0;\r\n        }"
          Return
             Gas costs: 0
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(x <= (MAX_UINT256 / y))"
        FunctionCall
           Type: tuple()
           Source: "require(x <= (MAX_UINT256 / y))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "x <= (MAX_UINT256 / y)"
            Identifier x
               Type: uint256
               Source: "x"
            TupleExpression
               Type: uint256
               Source: "(MAX_UINT256 / y)"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "MAX_UINT256 / y"
                Identifier MAX_UINT256
                   Type: uint256
                   Source: "MAX_UINT256"
                Identifier y
                   Type: uint256
                   Source: "y"
      Return
         Gas costs: 0
         Source: "return x * y"
        BinaryOperation using operator *
           Type: uint256
           Source: "x * y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
ContractDefinition "Owned"
   Source: "contract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "newOwner"
     Type: address
     Gas costs: [???]
     Source: "address public newOwner"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "Owned" - public
     Source: "function Owned() {\r\n        owner = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 3260
         Source: "assert(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "assert(msg.sender == owner)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 1
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _newOwner)"
      VariableDeclaration "_newOwner"
         Type: address
         Source: "address _newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }"
      ExpressionStatement
         Gas costs: 336
         Source: "require(_newOwner != owner)"
        FunctionCall
           Type: tuple()
           Source: "require(_newOwner != owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_newOwner != owner"
            Identifier _newOwner
               Type: address
               Source: "_newOwner"
            Identifier owner
               Type: address
               Source: "owner"
      ExpressionStatement
         Gas costs: 20267
         Source: "newOwner = _newOwner"
        Assignment using operator =
           Type: address
           Source: "newOwner = _newOwner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
          Identifier _newOwner
             Type: address
             Source: "_newOwner"
  FunctionDefinition "acceptOwnership" - public
     Source: "function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }"
      ExpressionStatement
         Gas costs: 282
         Source: "require(msg.sender == newOwner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == newOwner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == newOwner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier newOwner
               Type: address
               Source: "newOwner"
      ExpressionStatement
         Gas costs: [???]
         Source: "OwnerUpdate(owner, newOwner)"
        FunctionCall
           Type: tuple()
           Source: "OwnerUpdate(owner, newOwner)"
          Identifier OwnerUpdate
             Type: function (address,address)
             Source: "OwnerUpdate"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
      ExpressionStatement
         Gas costs: 20553
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
      ExpressionStatement
         Gas costs: 20267
         Source: "newOwner = 0x0"
        Assignment using operator =
           Type: address
           Source: "newOwner = 0x0"
          Identifier newOwner
             Type: address
             Source: "newOwner"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
  EventDefinition "OwnerUpdate"
     Gas costs: 0
     Source: "event OwnerUpdate(address _prevOwner, address _newOwner);"
    ParameterList
       Source: "(address _prevOwner, address _newOwner)"
      VariableDeclaration "_prevOwner"
         Type: address
         Source: "address _prevOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_newOwner"
         Type: address
         Source: "address _newOwner"
        ElementaryTypeName address
           Source: "address"
ContractDefinition "Lockable"
   Source: "contract Lockable is Owned {\r\n\r\n    uint256 public lockedUntilBlock;\r\n\r\n    event ContractLocked(uint256 _untilBlock, string _reason);\r\n\r\n    modifier lockAffected {\r\n        require(block.number > lockedUntilBlock);\r\n        _;\r\n    }\r\n\r\n    function lockFromSelf(uint256 _untilBlock, string _reason) internal {\r\n        lockedUntilBlock = _untilBlock;\r\n        ContractLocked(_untilBlock, _reason);\r\n    }\r\n\r\n\r\n    function lockUntil(uint256 _untilBlock, string _reason) onlyOwner public {\r\n        lockedUntilBlock = _untilBlock;\r\n        ContractLocked(_untilBlock, _reason);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Owned"
    UserDefinedTypeName "Owned"
       Source: "Owned"
  VariableDeclaration "lockedUntilBlock"
     Type: uint256
     Gas costs: 0
     Source: "uint256 public lockedUntilBlock"
    ElementaryTypeName uint256
       Source: "uint256"
  EventDefinition "ContractLocked"
     Gas costs: 0
     Source: "event ContractLocked(uint256 _untilBlock, string _reason);"
    ParameterList
       Source: "(uint256 _untilBlock, string _reason)"
      VariableDeclaration "_untilBlock"
         Type: uint256
         Source: "uint256 _untilBlock"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_reason"
         Type: string memory
         Source: "string _reason"
        ElementaryTypeName string
           Source: "string"
  ModifierDefinition "lockAffected"
     Source: "modifier lockAffected {\r\n        require(block.number > lockedUntilBlock);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(block.number > lockedUntilBlock);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(block.number > lockedUntilBlock)"
        FunctionCall
           Type: tuple()
           Source: "require(block.number > lockedUntilBlock)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "block.number > lockedUntilBlock"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier lockedUntilBlock
               Type: uint256
               Source: "lockedUntilBlock"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "lockFromSelf"
     Source: "function lockFromSelf(uint256 _untilBlock, string _reason) internal {\r\n        lockedUntilBlock = _untilBlock;\r\n        ContractLocked(_untilBlock, _reason);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _untilBlock, string _reason)"
      VariableDeclaration "_untilBlock"
         Type: uint256
         Source: "uint256 _untilBlock"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_reason"
         Type: string memory
         Source: "string _reason"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        lockedUntilBlock = _untilBlock;\r\n        ContractLocked(_untilBlock, _reason);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "lockedUntilBlock = _untilBlock"
        Assignment using operator =
           Type: uint256
           Source: "lockedUntilBlock = _untilBlock"
          Identifier lockedUntilBlock
             Type: uint256
             Source: "lockedUntilBlock"
          Identifier _untilBlock
             Type: uint256
             Source: "_untilBlock"
      ExpressionStatement
         Gas costs: 0
         Source: "ContractLocked(_untilBlock, _reason)"
        FunctionCall
           Type: tuple()
           Source: "ContractLocked(_untilBlock, _reason)"
          Identifier ContractLocked
             Type: function (uint256,string memory)
             Source: "ContractLocked"
          Identifier _untilBlock
             Type: uint256
             Source: "_untilBlock"
          Identifier _reason
             Type: string memory
             Source: "_reason"
  FunctionDefinition "lockUntil" - public
     Source: "function lockUntil(uint256 _untilBlock, string _reason) onlyOwner public {\r\n        lockedUntilBlock = _untilBlock;\r\n        ContractLocked(_untilBlock, _reason);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _untilBlock, string _reason)"
      VariableDeclaration "_untilBlock"
         Type: uint256
         Source: "uint256 _untilBlock"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_reason"
         Type: string memory
         Source: "string _reason"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        lockedUntilBlock = _untilBlock;\r\n        ContractLocked(_untilBlock, _reason);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "lockedUntilBlock = _untilBlock"
        Assignment using operator =
           Type: uint256
           Source: "lockedUntilBlock = _untilBlock"
          Identifier lockedUntilBlock
             Type: uint256
             Source: "lockedUntilBlock"
          Identifier _untilBlock
             Type: uint256
             Source: "_untilBlock"
      ExpressionStatement
         Gas costs: 0
         Source: "ContractLocked(_untilBlock, _reason)"
        FunctionCall
           Type: tuple()
           Source: "ContractLocked(_untilBlock, _reason)"
          Identifier ContractLocked
             Type: function (uint256,string memory)
             Source: "ContractLocked"
          Identifier _untilBlock
             Type: uint256
             Source: "_untilBlock"
          Identifier _reason
             Type: string memory
             Source: "_reason"
ContractDefinition "ReentrancyHandlingContract"
   Source: "contract ReentrancyHandlingContract{\r\n\r\n    bool locked;\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}"
  VariableDeclaration "locked"
     Type: bool
     Gas costs: 0
     Source: "bool locked"
    ElementaryTypeName bool
       Source: "bool"
  ModifierDefinition "noReentrancy"
     Source: "modifier noReentrancy() {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }"
      ExpressionStatement
         Gas costs: 268
         Source: "require(!locked)"
        FunctionCall
           Type: tuple()
           Source: "require(!locked)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!locked"
            Identifier locked
               Type: bool
               Source: "locked"
      ExpressionStatement
         Gas costs: 20267
         Source: "locked = true"
        Assignment using operator =
           Type: bool
           Source: "locked = true"
          Identifier locked
             Type: bool
             Source: "locked"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
      ExpressionStatement
         Gas costs: 20267
         Source: "locked = false"
        Assignment using operator =
           Type: bool
           Source: "locked = false"
          Identifier locked
             Type: bool
             Source: "locked"
          Literal, token: false value: false
             Type: bool
             Source: "false"
ContractDefinition "tokenRecipientInterface"
   Gas costs: 0
   Source: "contract tokenRecipientInterface {\r\n  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}"
  FunctionDefinition "receiveApproval" - public
     Source: "function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);"
    ParameterList
       Source: "(address _from, uint256 _value, address _token, bytes _extraData)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: ""
ContractDefinition "ERC20TokenInterface"
   Gas costs: 0
   Source: "contract ERC20TokenInterface {\r\n  function totalSupply() public constant returns (uint256 _totalSupply);\r\n  function balanceOf(address _owner) public constant returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() public constant returns (uint256 _totalSupply);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256 _totalSupply)"
      VariableDeclaration "_totalSupply"
         Type: uint256
         Source: "uint256 _totalSupply"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public constant returns (uint256 balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public constant returns (uint256 remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "SportifyTokenInterface"
   Gas costs: 0
   Source: "contract SportifyTokenInterface {\r\n    function mint(address _to, uint256 _amount) public;\r\n}"
  FunctionDefinition "mint" - public
     Source: "function mint(address _to, uint256 _amount) public;"
    ParameterList
       Source: "(address _to, uint256 _amount)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
ContractDefinition "Crowdsale"
   Source: "contract Crowdsale is ReentrancyHandlingContract, Owned {\r\n\r\n  struct ContributorData {\r\n    uint contributionAmount;\r\n    uint tokensIssued;\r\n  }\r\n\r\n  mapping(address => ContributorData) public contributorList;\r\n  uint nextContributorIndex;\r\n  mapping(uint => address) contributorIndexes;\r\n\r\n  state public crowdsaleState = state.pendingStart;\r\n  enum state { pendingStart, crowdsale, crowdsaleEnded }\r\n\r\n  uint public crowdsaleStartBlock;\r\n  uint public crowdsaleEndedBlock;\r\n\r\n  event CrowdsaleStarted(uint blockNumber);\r\n  event CrowdsaleEnded(uint blockNumber);\r\n  event ErrorSendingETH(address to, uint amount);\r\n  event MinCapReached(uint blockNumber);\r\n  event MaxCapReached(uint blockNumber);\r\n\r\n  address tokenAddress = 0x0;\r\n  uint decimals = 18;\r\n\r\n  uint ethToTokenConversion;\r\n\r\n  uint public minCap;\r\n  uint public maxCap;\r\n  uint public ethRaised;\r\n  uint public tokenTotalSupply = 200000000 * 10**decimals;\r\n\r\n  address public multisigAddress;\r\n  uint blocksInADay;\r\n\r\n  uint nextContributorToClaim;\r\n  mapping(address => bool) hasClaimedEthWhenFail;\r\n\r\n  uint crowdsaleTokenCap =          134000000 * 10**decimals;\r\n  uint foundersAndTeamTokens =       36000000 * 10**decimals;\r\n  uint advisorAndAmbassadorTokens =  20000000 * 10**decimals;\r\n  uint futurePromoEventTokens =      10000000 * 10**decimals;\r\n  bool foundersAndTeamTokensClaimed = false;\r\n  bool advisorAndAmbassadorTokensClaimed = false;\r\n  bool futurePromoEventTokensClaimed = false;\r\n\r\n  //\r\n  // Unnamed function that runs when eth is sent to the contract\r\n  //\r\n  function() noReentrancy payable public {\r\n    require(msg.value != 0);                        // Throw if value is 0\r\n    require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\r\n\r\n    bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\r\n\r\n    if (crowdsaleState == state.crowdsale) {\r\n      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\r\n    } else {\r\n      refundTransaction(stateChanged);              // Set state and return funds or throw\r\n    }\r\n  }\r\n\r\n  //\r\n  // Check crowdsale state and calibrate it\r\n  //\r\n  function checkCrowdsaleState() internal returns (bool) {\r\n    if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded) {                        // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number);                                                             // Raise event\r\n      return true;\r\n    }\r\n\r\n    if (block.number > crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {            // Check if we are in crowdsale state\r\n      if (crowdsaleState != state.crowdsale) {                                                  // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }\r\n    } else {\r\n      if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {       // Check if crowdsale is over\r\n        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\r\n        CrowdsaleEnded(block.number);                                                           // Raise event\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //\r\n  // Decide if throw or only return ether\r\n  //\r\n  function refundTransaction(bool _stateChanged) internal {\r\n    if (_stateChanged) {\r\n      msg.sender.transfer(msg.value);\r\n    } else {\r\n      revert();\r\n    }\r\n  }\r\n\r\n  function calculateEthToToken(uint _eth, uint _blockNumber) constant public returns(uint) {\r\n    if (_blockNumber < crowdsaleStartBlock + blocksInADay * 3) {\r\n      return _eth * 3298;\r\n    }\r\n    if (_eth >= 100*10**decimals) {\r\n      return _eth * 3298;\r\n    }\r\n    if (_blockNumber > crowdsaleStartBlock) {\r\n      return _eth * 2998;\r\n    }\r\n  }\r\n\r\n  //\r\n  // Issue tokens and return if there is overflow\r\n  //\r\n  function processTransaction(address _contributor, uint _amount) internal{\r\n    uint contributionAmount = _amount;\r\n    uint returnAmount = 0;\r\n\r\n    if (_amount > (maxCap - ethRaised)) {                                          // Check if max contribution is lower than _amount sent\r\n      contributionAmount = maxCap - ethRaised;                                     // Set that user contibutes his maximum alowed contribution\r\n      returnAmount = _amount - contributionAmount;                                 // Calculate howmuch he must get back\r\n    }\r\n\r\n    if (ethRaised + contributionAmount > minCap && minCap > ethRaised) {\r\n      MinCapReached(block.number);\r\n    }\r\n\r\n    if (ethRaised + contributionAmount == maxCap && ethRaised < maxCap) {\r\n      MaxCapReached(block.number);\r\n    }\r\n\r\n    if (contributorList[_contributor].contributionAmount == 0) {\r\n        contributorIndexes[nextContributorIndex] = _contributor;\r\n        nextContributorIndex += 1;\r\n    }\r\n\r\n    contributorList[_contributor].contributionAmount += contributionAmount;\r\n    ethRaised += contributionAmount;                                              // Add to eth raised\r\n\r\n    uint tokenAmount = calculateEthToToken(contributionAmount, block.number);     // Calculate how much tokens must contributor get\r\n    if (tokenAmount > 0) {\r\n      SportifyTokenInterface(tokenAddress).mint(_contributor, tokenAmount);       // Issue new tokens\r\n      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\r\n    }\r\n    if (returnAmount != 0) {\r\n      _contributor.transfer(returnAmount);\r\n    } \r\n  }\r\n\r\n  function pushAngelInvestmentData(address _address, uint _ethContributed) onlyOwner public {\r\n      assert(ethRaised + _ethContributed <= maxCap);\r\n      processTransaction(_address, _ethContributed);\r\n  }\r\n  function depositAngelInvestmentEth() payable onlyOwner public {}\r\n  \r\n\r\n  //\r\n  // Method is needed for recovering tokens accedentaly sent to token address\r\n  //\r\n  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\r\n    ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n  }\r\n\r\n  //\r\n  // withdrawEth when minimum cap is reached\r\n  //\r\n  function withdrawEth() onlyOwner public {\r\n    require(this.balance != 0);\r\n    require(ethRaised >= minCap);\r\n\r\n    multisigAddress.transfer(this.balance);\r\n  }\r\n\r\n  //\r\n  // Users can claim their contribution if min cap is not raised\r\n  //\r\n  function claimEthIfFailed() public {\r\n    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);    // Check if crowdsale has failed\r\n    require(contributorList[msg.sender].contributionAmount > 0);          // Check if contributor has contributed to crowdsaleEndedBlock\r\n    require(!hasClaimedEthWhenFail[msg.sender]);                          // Check if contributor has already claimed his eth\r\n\r\n    uint ethContributed = contributorList[msg.sender].contributionAmount; // Get contributors contribution\r\n    hasClaimedEthWhenFail[msg.sender] = true;                             // Set that he has claimed\r\n    if (!msg.sender.send(ethContributed)) {                                // Refund eth\r\n      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\r\n    }\r\n  }\r\n\r\n  //\r\n  // Owner can batch return contributors contributions(eth)\r\n  //\r\n  function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\r\n    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);                // Check if crowdsale has failed\r\n    address currentParticipantAddress;\r\n    uint contribution;\r\n    for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\r\n      if (currentParticipantAddress == 0x0) {\r\n        return;                                                                       // Check if all the participants were compensated\r\n      }\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)) {                          // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                                    // Repeat\r\n    }\r\n  }\r\n\r\n  //\r\n  // If there were any issue/attach with refund owner can withraw eth at the end for manual recovery\r\n  //\r\n  function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\r\n    require(this.balance != 0);                                  // Check if there are any eth to claim\r\n    require(block.number > crowdsaleEndedBlock);                 // Check if crowdsale is over\r\n    require(contributorIndexes[nextContributorToClaim] == 0x0);  // Check if all the users were refunded\r\n    multisigAddress.transfer(this.balance);                      // Withdraw to multisig\r\n  }\r\n\r\n  function claimTeamTokens(address _to, uint _choice) onlyOwner public {\r\n    require(crowdsaleState == state.crowdsaleEnded);\r\n    require(ethRaised >= minCap);\r\n\r\n    uint mintAmount;\r\n    if (_choice == 1) {\r\n      assert(!advisorAndAmbassadorTokensClaimed);\r\n      mintAmount = advisorAndAmbassadorTokens;\r\n      advisorAndAmbassadorTokensClaimed = true;\r\n    } else if (_choice == 2) {\r\n      assert(!futurePromoEventTokensClaimed);\r\n      mintAmount = futurePromoEventTokens;\r\n      futurePromoEventTokensClaimed = true;\r\n    } else if (_choice == 3) {\r\n      assert(!foundersAndTeamTokensClaimed);\r\n      assert(advisorAndAmbassadorTokensClaimed);\r\n      assert(futurePromoEventTokensClaimed);\r\n      assert(tokenTotalSupply > ERC20TokenInterface(tokenAddress).totalSupply());\r\n      mintAmount = tokenTotalSupply - ERC20TokenInterface(tokenAddress).totalSupply();\r\n      foundersAndTeamTokensClaimed = true;\r\n    } else {\r\n      revert();\r\n    }\r\n    SportifyTokenInterface(tokenAddress).mint(_to, mintAmount);\r\n  }\r\n\r\n\r\n  //\r\n  // Owner can set multisig address for crowdsale\r\n  //\r\n  function setMultisigAddress(address _newAddress) onlyOwner public {\r\n    multisigAddress = _newAddress;\r\n  }\r\n\r\n  //\r\n  // Owner can set token address where mints will happen\r\n  //\r\n  function setToken(address _newAddress) onlyOwner public {\r\n    tokenAddress = _newAddress;\r\n  }\r\n\r\n  function getTokenAddress() constant public returns(address) {\r\n    return tokenAddress;\r\n  }\r\n\r\n  function investorCount() constant public returns(uint) {\r\n    return nextContributorIndex;\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ReentrancyHandlingContract"
    UserDefinedTypeName "ReentrancyHandlingContract"
       Source: "ReentrancyHandlingContract"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Owned"
    UserDefinedTypeName "Owned"
       Source: "Owned"
  StructDefinition "ContributorData"
     Gas costs: 0
     Source: "struct ContributorData {\r\n    uint contributionAmount;\r\n    uint tokensIssued;\r\n  }"
    VariableDeclaration "contributionAmount"
       Type: uint256
       Source: "uint contributionAmount"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "tokensIssued"
       Type: uint256
       Source: "uint tokensIssued"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "contributorList"
     Type: mapping(address => struct Crowdsale.ContributorData storage ref)
     Gas costs: [???]
     Source: "mapping(address => ContributorData) public contributorList"
    Mapping
       Source: "mapping(address => ContributorData)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "ContributorData"
         Source: "ContributorData"
  VariableDeclaration "nextContributorIndex"
     Type: uint256
     Gas costs: 0
     Source: "uint nextContributorIndex"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "contributorIndexes"
     Type: mapping(uint256 => address)
     Gas costs: 0
     Source: "mapping(uint => address) contributorIndexes"
    Mapping
       Source: "mapping(uint => address)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "crowdsaleState"
     Type: enum Crowdsale.state
     Gas costs: [???]
     Source: "state public crowdsaleState = state.pendingStart"
    UserDefinedTypeName "state"
       Source: "state"
    MemberAccess to member pendingStart
       Type: enum Crowdsale.state
       Source: "state.pendingStart"
      Identifier state
         Type: type(enum Crowdsale.state)
         Source: "state"
  EnumDefinition "state"
    EnumValue "pendingStart"
    EnumValue "crowdsale"
    EnumValue "crowdsaleEnded"
  VariableDeclaration "crowdsaleStartBlock"
     Type: uint256
     Gas costs: [???]
     Source: "uint public crowdsaleStartBlock"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "crowdsaleEndedBlock"
     Type: uint256
     Gas costs: [???]
     Source: "uint public crowdsaleEndedBlock"
    ElementaryTypeName uint
       Source: "uint"
  EventDefinition "CrowdsaleStarted"
     Gas costs: 0
     Source: "event CrowdsaleStarted(uint blockNumber);"
    ParameterList
       Source: "(uint blockNumber)"
      VariableDeclaration "blockNumber"
         Type: uint256
         Source: "uint blockNumber"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "CrowdsaleEnded"
     Gas costs: 0
     Source: "event CrowdsaleEnded(uint blockNumber);"
    ParameterList
       Source: "(uint blockNumber)"
      VariableDeclaration "blockNumber"
         Type: uint256
         Source: "uint blockNumber"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "ErrorSendingETH"
     Gas costs: 0
     Source: "event ErrorSendingETH(address to, uint amount);"
    ParameterList
       Source: "(address to, uint amount)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "MinCapReached"
     Gas costs: 0
     Source: "event MinCapReached(uint blockNumber);"
    ParameterList
       Source: "(uint blockNumber)"
      VariableDeclaration "blockNumber"
         Type: uint256
         Source: "uint blockNumber"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "MaxCapReached"
     Gas costs: 0
     Source: "event MaxCapReached(uint blockNumber);"
    ParameterList
       Source: "(uint blockNumber)"
      VariableDeclaration "blockNumber"
         Type: uint256
         Source: "uint blockNumber"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "tokenAddress"
     Type: address
     Gas costs: 0
     Source: "address tokenAddress = 0x0"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x0
       Type: int_const 0
       Source: "0x0"
  VariableDeclaration "decimals"
     Type: uint256
     Gas costs: 0
     Source: "uint decimals = 18"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "ethToTokenConversion"
     Type: uint256
     Gas costs: 0
     Source: "uint ethToTokenConversion"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "minCap"
     Type: uint256
     Gas costs: [???]
     Source: "uint public minCap"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "maxCap"
     Type: uint256
     Gas costs: [???]
     Source: "uint public maxCap"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "ethRaised"
     Type: uint256
     Gas costs: [???]
     Source: "uint public ethRaised"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "tokenTotalSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint public tokenTotalSupply = 200000000 * 10**decimals"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: uint256
       Source: "200000000 * 10**decimals"
      Literal, token: [no token] value: 200000000
         Type: int_const 200000000
         Source: "200000000"
      BinaryOperation using operator **
         Type: uint256
         Source: "10**decimals"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Identifier decimals
           Type: uint256
           Source: "decimals"
  VariableDeclaration "multisigAddress"
     Type: address
     Gas costs: [???]
     Source: "address public multisigAddress"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "blocksInADay"
     Type: uint256
     Gas costs: 0
     Source: "uint blocksInADay"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "nextContributorToClaim"
     Type: uint256
     Gas costs: 0
     Source: "uint nextContributorToClaim"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "hasClaimedEthWhenFail"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping(address => bool) hasClaimedEthWhenFail"
    Mapping
       Source: "mapping(address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "crowdsaleTokenCap"
     Type: uint256
     Gas costs: 0
     Source: "uint crowdsaleTokenCap =          134000000 * 10**decimals"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: uint256
       Source: "134000000 * 10**decimals"
      Literal, token: [no token] value: 134000000
         Type: int_const 134000000
         Source: "134000000"
      BinaryOperation using operator **
         Type: uint256
         Source: "10**decimals"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Identifier decimals
           Type: uint256
           Source: "decimals"
  VariableDeclaration "foundersAndTeamTokens"
     Type: uint256
     Gas costs: 0
     Source: "uint foundersAndTeamTokens =       36000000 * 10**decimals"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: uint256
       Source: "36000000 * 10**decimals"
      Literal, token: [no token] value: 36000000
         Type: int_const 36000000
         Source: "36000000"
      BinaryOperation using operator **
         Type: uint256
         Source: "10**decimals"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Identifier decimals
           Type: uint256
           Source: "decimals"
  VariableDeclaration "advisorAndAmbassadorTokens"
     Type: uint256
     Gas costs: 0
     Source: "uint advisorAndAmbassadorTokens =  20000000 * 10**decimals"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: uint256
       Source: "20000000 * 10**decimals"
      Literal, token: [no token] value: 20000000
         Type: int_const 20000000
         Source: "20000000"
      BinaryOperation using operator **
         Type: uint256
         Source: "10**decimals"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Identifier decimals
           Type: uint256
           Source: "decimals"
  VariableDeclaration "futurePromoEventTokens"
     Type: uint256
     Gas costs: 0
     Source: "uint futurePromoEventTokens =      10000000 * 10**decimals"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: uint256
       Source: "10000000 * 10**decimals"
      Literal, token: [no token] value: 10000000
         Type: int_const 10000000
         Source: "10000000"
      BinaryOperation using operator **
         Type: uint256
         Source: "10**decimals"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Identifier decimals
           Type: uint256
           Source: "decimals"
  VariableDeclaration "foundersAndTeamTokensClaimed"
     Type: bool
     Gas costs: 0
     Source: "bool foundersAndTeamTokensClaimed = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "advisorAndAmbassadorTokensClaimed"
     Type: bool
     Gas costs: 0
     Source: "bool advisorAndAmbassadorTokensClaimed = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "futurePromoEventTokensClaimed"
     Type: bool
     Gas costs: 0
     Source: "bool futurePromoEventTokensClaimed = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  FunctionDefinition "" - public
     Source: "function() noReentrancy payable public {\r\n    require(msg.value != 0);                        // Throw if value is 0\r\n    require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\r\n\r\n    bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\r\n\r\n    if (crowdsaleState == state.crowdsale) {\r\n      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\r\n    } else {\r\n      refundTransaction(stateChanged);              // Set state and return funds or throw\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "noReentrancy"
       Gas costs: 0
       Source: "noReentrancy"
      Identifier noReentrancy
         Type: modifier ()
         Source: "noReentrancy"
    Block
       Source: "{\r\n    require(msg.value != 0);                        // Throw if value is 0\r\n    require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\r\n\r\n    bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\r\n\r\n    if (crowdsaleState == state.crowdsale) {\r\n      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\r\n    } else {\r\n      refundTransaction(stateChanged);              // Set state and return funds or throw\r\n    }\r\n  }"
      ExpressionStatement
         Gas costs: 37
         Source: "require(msg.value != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "msg.value != 0"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 326
         Source: "require(crowdsaleState != state.crowdsaleEnded)"
        FunctionCall
           Type: tuple()
           Source: "require(crowdsaleState != state.crowdsaleEnded)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "crowdsaleState != state.crowdsaleEnded"
            Identifier crowdsaleState
               Type: enum Crowdsale.state
               Source: "crowdsaleState"
            MemberAccess to member crowdsaleEnded
               Type: enum Crowdsale.state
               Source: "state.crowdsaleEnded"
              Identifier state
                 Type: type(enum Crowdsale.state)
                 Source: "state"
      VariableDeclarationStatement
         Gas costs: 12
         Source: "bool stateChanged = checkCrowdsaleState()"
        VariableDeclaration "stateChanged"
           Type: bool
           Source: "bool stateChanged"
          ElementaryTypeName bool
             Source: "bool"
        FunctionCall
           Type: bool
           Source: "checkCrowdsaleState()"
          Identifier checkCrowdsaleState
             Type: function () returns (bool)
             Source: "checkCrowdsaleState"
      IfStatement
         Source: "if (crowdsaleState == state.crowdsale) {\r\n      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\r\n    } else {\r\n      refundTransaction(stateChanged);              // Set state and return funds or throw\r\n    }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 297
           Source: "crowdsaleState == state.crowdsale"
          Identifier crowdsaleState
             Type: enum Crowdsale.state
             Source: "crowdsaleState"
          MemberAccess to member crowdsale
             Type: enum Crowdsale.state
             Source: "state.crowdsale"
            Identifier state
               Type: type(enum Crowdsale.state)
               Source: "state"
        Block
           Source: "{\r\n      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\r\n    }"
          ExpressionStatement
             Gas costs: 19
             Source: "processTransaction(msg.sender, msg.value)"
            FunctionCall
               Type: tuple()
               Source: "processTransaction(msg.sender, msg.value)"
              Identifier processTransaction
                 Type: function (address,uint256)
                 Source: "processTransaction"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
        Block
           Source: "{\r\n      refundTransaction(stateChanged);              // Set state and return funds or throw\r\n    }"
          ExpressionStatement
             Gas costs: 7
             Source: "refundTransaction(stateChanged)"
            FunctionCall
               Type: tuple()
               Source: "refundTransaction(stateChanged)"
              Identifier refundTransaction
                 Type: function (bool)
                 Source: "refundTransaction"
              Identifier stateChanged
                 Type: bool
                 Source: "stateChanged"
  FunctionDefinition "checkCrowdsaleState"
     Source: "function checkCrowdsaleState() internal returns (bool) {\r\n    if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded) {                        // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number);                                                             // Raise event\r\n      return true;\r\n    }\r\n\r\n    if (block.number > crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {            // Check if we are in crowdsale state\r\n      if (crowdsaleState != state.crowdsale) {                                                  // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }\r\n    } else {\r\n      if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {       // Check if crowdsale is over\r\n        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\r\n        CrowdsaleEnded(block.number);                                                           // Raise event\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded) {                        // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number);                                                             // Raise event\r\n      return true;\r\n    }\r\n\r\n    if (block.number > crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {            // Check if we are in crowdsale state\r\n      if (crowdsaleState != state.crowdsale) {                                                  // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }\r\n    } else {\r\n      if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {       // Check if crowdsale is over\r\n        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\r\n        CrowdsaleEnded(block.number);                                                           // Raise event\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }"
      IfStatement
         Source: "if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded) {                        // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number);                                                             // Raise event\r\n      return true;\r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 731
           Source: "ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded"
          BinaryOperation using operator ==
             Type: bool
             Source: "ethRaised == maxCap"
            Identifier ethRaised
               Type: uint256
               Source: "ethRaised"
            Identifier maxCap
               Type: uint256
               Source: "maxCap"
          BinaryOperation using operator !=
             Type: bool
             Source: "crowdsaleState != state.crowdsaleEnded"
            Identifier crowdsaleState
               Type: enum Crowdsale.state
               Source: "crowdsaleState"
            MemberAccess to member crowdsaleEnded
               Type: enum Crowdsale.state
               Source: "state.crowdsaleEnded"
              Identifier state
                 Type: type(enum Crowdsale.state)
                 Source: "state"
        Block
           Source: "{                        // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number);                                                             // Raise event\r\n      return true;\r\n    }"
          ExpressionStatement
             Gas costs: 20287
             Source: "crowdsaleState = state.crowdsaleEnded"
            Assignment using operator =
               Type: enum Crowdsale.state
               Source: "crowdsaleState = state.crowdsaleEnded"
              Identifier crowdsaleState
                 Type: enum Crowdsale.state
                 Source: "crowdsaleState"
              MemberAccess to member crowdsaleEnded
                 Type: enum Crowdsale.state
                 Source: "state.crowdsaleEnded"
                Identifier state
                   Type: type(enum Crowdsale.state)
                   Source: "state"
          ExpressionStatement
             Gas costs: [???]
             Source: "CrowdsaleEnded(block.number)"
            FunctionCall
               Type: tuple()
               Source: "CrowdsaleEnded(block.number)"
              Identifier CrowdsaleEnded
                 Type: function (uint256)
                 Source: "CrowdsaleEnded"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      IfStatement
         Source: "if (block.number > crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {            // Check if we are in crowdsale state\r\n      if (crowdsaleState != state.crowdsale) {                                                  // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }\r\n    } else {\r\n      if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {       // Check if crowdsale is over\r\n        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\r\n        CrowdsaleEnded(block.number);                                                           // Raise event\r\n        return true;\r\n      }\r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 441
           Source: "block.number > crowdsaleStartBlock && block.number <= crowdsaleEndedBlock"
          BinaryOperation using operator >
             Type: bool
             Source: "block.number > crowdsaleStartBlock"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier crowdsaleStartBlock
               Type: uint256
               Source: "crowdsaleStartBlock"
          BinaryOperation using operator <=
             Type: bool
             Source: "block.number <= crowdsaleEndedBlock"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier crowdsaleEndedBlock
               Type: uint256
               Source: "crowdsaleEndedBlock"
        Block
           Source: "{            // Check if we are in crowdsale state\r\n      if (crowdsaleState != state.crowdsale) {                                                  // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }\r\n    }"
          IfStatement
             Source: "if (crowdsaleState != state.crowdsale) {                                                  // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }"
            BinaryOperation using operator !=
               Type: bool
               Gas costs: 300
               Source: "crowdsaleState != state.crowdsale"
              Identifier crowdsaleState
                 Type: enum Crowdsale.state
                 Source: "crowdsaleState"
              MemberAccess to member crowdsale
                 Type: enum Crowdsale.state
                 Source: "state.crowdsale"
                Identifier state
                   Type: type(enum Crowdsale.state)
                   Source: "state"
            Block
               Source: "{                                                  // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }"
              ExpressionStatement
                 Gas costs: 20287
                 Source: "crowdsaleState = state.crowdsale"
                Assignment using operator =
                   Type: enum Crowdsale.state
                   Source: "crowdsaleState = state.crowdsale"
                  Identifier crowdsaleState
                     Type: enum Crowdsale.state
                     Source: "crowdsaleState"
                  MemberAccess to member crowdsale
                     Type: enum Crowdsale.state
                     Source: "state.crowdsale"
                    Identifier state
                       Type: type(enum Crowdsale.state)
                       Source: "state"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "CrowdsaleStarted(block.number)"
                FunctionCall
                   Type: tuple()
                   Source: "CrowdsaleStarted(block.number)"
                  Identifier CrowdsaleStarted
                     Type: function (uint256)
                     Source: "CrowdsaleStarted"
                  MemberAccess to member number
                     Type: uint256
                     Source: "block.number"
                    Identifier block
                       Type: block
                       Source: "block"
              Return
                 Gas costs: 19
                 Source: "return true"
                Literal, token: true value: true
                   Type: bool
                   Source: "true"
        Block
           Source: "{\r\n      if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {       // Check if crowdsale is over\r\n        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\r\n        CrowdsaleEnded(block.number);                                                           // Raise event\r\n        return true;\r\n      }\r\n    }"
          IfStatement
             Source: "if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {       // Check if crowdsale is over\r\n        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\r\n        CrowdsaleEnded(block.number);                                                           // Raise event\r\n        return true;\r\n      }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 530
               Source: "crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "crowdsaleState != state.crowdsaleEnded"
                Identifier crowdsaleState
                   Type: enum Crowdsale.state
                   Source: "crowdsaleState"
                MemberAccess to member crowdsaleEnded
                   Type: enum Crowdsale.state
                   Source: "state.crowdsaleEnded"
                  Identifier state
                     Type: type(enum Crowdsale.state)
                     Source: "state"
              BinaryOperation using operator >
                 Type: bool
                 Source: "block.number > crowdsaleEndedBlock"
                MemberAccess to member number
                   Type: uint256
                   Source: "block.number"
                  Identifier block
                     Type: block
                     Source: "block"
                Identifier crowdsaleEndedBlock
                   Type: uint256
                   Source: "crowdsaleEndedBlock"
            Block
               Source: "{       // Check if crowdsale is over\r\n        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\r\n        CrowdsaleEnded(block.number);                                                           // Raise event\r\n        return true;\r\n      }"
              ExpressionStatement
                 Gas costs: 20287
                 Source: "crowdsaleState = state.crowdsaleEnded"
                Assignment using operator =
                   Type: enum Crowdsale.state
                   Source: "crowdsaleState = state.crowdsaleEnded"
                  Identifier crowdsaleState
                     Type: enum Crowdsale.state
                     Source: "crowdsaleState"
                  MemberAccess to member crowdsaleEnded
                     Type: enum Crowdsale.state
                     Source: "state.crowdsaleEnded"
                    Identifier state
                       Type: type(enum Crowdsale.state)
                       Source: "state"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "CrowdsaleEnded(block.number)"
                FunctionCall
                   Type: tuple()
                   Source: "CrowdsaleEnded(block.number)"
                  Identifier CrowdsaleEnded
                     Type: function (uint256)
                     Source: "CrowdsaleEnded"
                  MemberAccess to member number
                     Type: uint256
                     Source: "block.number"
                    Identifier block
                       Type: block
                       Source: "block"
              Return
                 Gas costs: 19
                 Source: "return true"
                Literal, token: true value: true
                   Type: bool
                   Source: "true"
      Return
         Gas costs: 8
         Source: "return false"
        Literal, token: false value: false
           Type: bool
           Source: "false"
  FunctionDefinition "refundTransaction"
     Source: "function refundTransaction(bool _stateChanged) internal {\r\n    if (_stateChanged) {\r\n      msg.sender.transfer(msg.value);\r\n    } else {\r\n      revert();\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bool _stateChanged)"
      VariableDeclaration "_stateChanged"
         Type: bool
         Source: "bool _stateChanged"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    if (_stateChanged) {\r\n      msg.sender.transfer(msg.value);\r\n    } else {\r\n      revert();\r\n    }\r\n  }"
      IfStatement
         Source: "if (_stateChanged) {\r\n      msg.sender.transfer(msg.value);\r\n    } else {\r\n      revert();\r\n    }"
        Identifier _stateChanged
           Type: bool
           Gas costs: 3
           Source: "_stateChanged"
        Block
           Source: "{\r\n      msg.sender.transfer(msg.value);\r\n    }"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.transfer(msg.value)"
            FunctionCall
               Type: tuple()
               Source: "msg.sender.transfer(msg.value)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "msg.sender.transfer"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
        Block
           Source: "{\r\n      revert();\r\n    }"
          ExpressionStatement
             Gas costs: 6
             Source: "revert()"
            FunctionCall
               Type: tuple()
               Source: "revert()"
              Identifier revert
                 Type: function () pure
                 Source: "revert"
  FunctionDefinition "calculateEthToToken" - public - const
     Source: "function calculateEthToToken(uint _eth, uint _blockNumber) constant public returns(uint) {\r\n    if (_blockNumber < crowdsaleStartBlock + blocksInADay * 3) {\r\n      return _eth * 3298;\r\n    }\r\n    if (_eth >= 100*10**decimals) {\r\n      return _eth * 3298;\r\n    }\r\n    if (_blockNumber > crowdsaleStartBlock) {\r\n      return _eth * 2998;\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint _eth, uint _blockNumber)"
      VariableDeclaration "_eth"
         Type: uint256
         Source: "uint _eth"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_blockNumber"
         Type: uint256
         Source: "uint _blockNumber"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    if (_blockNumber < crowdsaleStartBlock + blocksInADay * 3) {\r\n      return _eth * 3298;\r\n    }\r\n    if (_eth >= 100*10**decimals) {\r\n      return _eth * 3298;\r\n    }\r\n    if (_blockNumber > crowdsaleStartBlock) {\r\n      return _eth * 2998;\r\n    }\r\n  }"
      IfStatement
         Source: "if (_blockNumber < crowdsaleStartBlock + blocksInADay * 3) {\r\n      return _eth * 3298;\r\n    }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 423
           Source: "_blockNumber < crowdsaleStartBlock + blocksInADay * 3"
          Identifier _blockNumber
             Type: uint256
             Source: "_blockNumber"
          BinaryOperation using operator +
             Type: uint256
             Source: "crowdsaleStartBlock + blocksInADay * 3"
            Identifier crowdsaleStartBlock
               Type: uint256
               Source: "crowdsaleStartBlock"
            BinaryOperation using operator *
               Type: uint256
               Source: "blocksInADay * 3"
              Identifier blocksInADay
                 Type: uint256
                 Source: "blocksInADay"
              Literal, token: [no token] value: 3
                 Type: int_const 3
                 Source: "3"
        Block
           Source: "{\r\n      return _eth * 3298;\r\n    }"
          Return
             Gas costs: 27
             Source: "return _eth * 3298"
            BinaryOperation using operator *
               Type: uint256
               Source: "_eth * 3298"
              Identifier _eth
                 Type: uint256
                 Source: "_eth"
              Literal, token: [no token] value: 3298
                 Type: int_const 3298
                 Source: "3298"
      IfStatement
         Source: "if (_eth >= 100*10**decimals) {\r\n      return _eth * 3298;\r\n    }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 1833
           Source: "_eth >= 100*10**decimals"
          Identifier _eth
             Type: uint256
             Source: "_eth"
          BinaryOperation using operator *
             Type: uint256
             Source: "100*10**decimals"
            Literal, token: [no token] value: 100
               Type: int_const 100
               Source: "100"
            BinaryOperation using operator **
               Type: uint256
               Source: "10**decimals"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Identifier decimals
                 Type: uint256
                 Source: "decimals"
        Block
           Source: "{\r\n      return _eth * 3298;\r\n    }"
          Return
             Gas costs: 27
             Source: "return _eth * 3298"
            BinaryOperation using operator *
               Type: uint256
               Source: "_eth * 3298"
              Identifier _eth
                 Type: uint256
                 Source: "_eth"
              Literal, token: [no token] value: 3298
                 Type: int_const 3298
                 Source: "3298"
      IfStatement
         Source: "if (_blockNumber > crowdsaleStartBlock) {\r\n      return _eth * 2998;\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "_blockNumber > crowdsaleStartBlock"
          Identifier _blockNumber
             Type: uint256
             Source: "_blockNumber"
          Identifier crowdsaleStartBlock
             Type: uint256
             Source: "crowdsaleStartBlock"
        Block
           Source: "{\r\n      return _eth * 2998;\r\n    }"
          Return
             Gas costs: 27
             Source: "return _eth * 2998"
            BinaryOperation using operator *
               Type: uint256
               Source: "_eth * 2998"
              Identifier _eth
                 Type: uint256
                 Source: "_eth"
              Literal, token: [no token] value: 2998
                 Type: int_const 2998
                 Source: "2998"
  FunctionDefinition "processTransaction"
     Source: "function processTransaction(address _contributor, uint _amount) internal{\r\n    uint contributionAmount = _amount;\r\n    uint returnAmount = 0;\r\n\r\n    if (_amount > (maxCap - ethRaised)) {                                          // Check if max contribution is lower than _amount sent\r\n      contributionAmount = maxCap - ethRaised;                                     // Set that user contibutes his maximum alowed contribution\r\n      returnAmount = _amount - contributionAmount;                                 // Calculate howmuch he must get back\r\n    }\r\n\r\n    if (ethRaised + contributionAmount > minCap && minCap > ethRaised) {\r\n      MinCapReached(block.number);\r\n    }\r\n\r\n    if (ethRaised + contributionAmount == maxCap && ethRaised < maxCap) {\r\n      MaxCapReached(block.number);\r\n    }\r\n\r\n    if (contributorList[_contributor].contributionAmount == 0) {\r\n        contributorIndexes[nextContributorIndex] = _contributor;\r\n        nextContributorIndex += 1;\r\n    }\r\n\r\n    contributorList[_contributor].contributionAmount += contributionAmount;\r\n    ethRaised += contributionAmount;                                              // Add to eth raised\r\n\r\n    uint tokenAmount = calculateEthToToken(contributionAmount, block.number);     // Calculate how much tokens must contributor get\r\n    if (tokenAmount > 0) {\r\n      SportifyTokenInterface(tokenAddress).mint(_contributor, tokenAmount);       // Issue new tokens\r\n      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\r\n    }\r\n    if (returnAmount != 0) {\r\n      _contributor.transfer(returnAmount);\r\n    } \r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _contributor, uint _amount)"
      VariableDeclaration "_contributor"
         Type: address
         Source: "address _contributor"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    uint contributionAmount = _amount;\r\n    uint returnAmount = 0;\r\n\r\n    if (_amount > (maxCap - ethRaised)) {                                          // Check if max contribution is lower than _amount sent\r\n      contributionAmount = maxCap - ethRaised;                                     // Set that user contibutes his maximum alowed contribution\r\n      returnAmount = _amount - contributionAmount;                                 // Calculate howmuch he must get back\r\n    }\r\n\r\n    if (ethRaised + contributionAmount > minCap && minCap > ethRaised) {\r\n      MinCapReached(block.number);\r\n    }\r\n\r\n    if (ethRaised + contributionAmount == maxCap && ethRaised < maxCap) {\r\n      MaxCapReached(block.number);\r\n    }\r\n\r\n    if (contributorList[_contributor].contributionAmount == 0) {\r\n        contributorIndexes[nextContributorIndex] = _contributor;\r\n        nextContributorIndex += 1;\r\n    }\r\n\r\n    contributorList[_contributor].contributionAmount += contributionAmount;\r\n    ethRaised += contributionAmount;                                              // Add to eth raised\r\n\r\n    uint tokenAmount = calculateEthToToken(contributionAmount, block.number);     // Calculate how much tokens must contributor get\r\n    if (tokenAmount > 0) {\r\n      SportifyTokenInterface(tokenAddress).mint(_contributor, tokenAmount);       // Issue new tokens\r\n      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\r\n    }\r\n    if (returnAmount != 0) {\r\n      _contributor.transfer(returnAmount);\r\n    } \r\n  }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint contributionAmount = _amount"
        VariableDeclaration "contributionAmount"
           Type: uint256
           Source: "uint contributionAmount"
          ElementaryTypeName uint
             Source: "uint"
        Identifier _amount
           Type: uint256
           Source: "_amount"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint returnAmount = 0"
        VariableDeclaration "returnAmount"
           Type: uint256
           Source: "uint returnAmount"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      IfStatement
         Source: "if (_amount > (maxCap - ethRaised)) {                                          // Check if max contribution is lower than _amount sent\r\n      contributionAmount = maxCap - ethRaised;                                     // Set that user contibutes his maximum alowed contribution\r\n      returnAmount = _amount - contributionAmount;                                 // Calculate howmuch he must get back\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 415
           Source: "_amount > (maxCap - ethRaised)"
          Identifier _amount
             Type: uint256
             Source: "_amount"
          TupleExpression
             Type: uint256
             Source: "(maxCap - ethRaised)"
            BinaryOperation using operator -
               Type: uint256
               Source: "maxCap - ethRaised"
              Identifier maxCap
                 Type: uint256
                 Source: "maxCap"
              Identifier ethRaised
                 Type: uint256
                 Source: "ethRaised"
        Block
           Source: "{                                          // Check if max contribution is lower than _amount sent\r\n      contributionAmount = maxCap - ethRaised;                                     // Set that user contibutes his maximum alowed contribution\r\n      returnAmount = _amount - contributionAmount;                                 // Calculate howmuch he must get back\r\n    }"
          ExpressionStatement
             Gas costs: 414
             Source: "contributionAmount = maxCap - ethRaised"
            Assignment using operator =
               Type: uint256
               Source: "contributionAmount = maxCap - ethRaised"
              Identifier contributionAmount
                 Type: uint256
                 Source: "contributionAmount"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "maxCap - ethRaised"
                Identifier maxCap
                   Type: uint256
                   Source: "maxCap"
                Identifier ethRaised
                   Type: uint256
                   Source: "ethRaised"
          ExpressionStatement
             Gas costs: 14
             Source: "returnAmount = _amount - contributionAmount"
            Assignment using operator =
               Type: uint256
               Source: "returnAmount = _amount - contributionAmount"
              Identifier returnAmount
                 Type: uint256
                 Source: "returnAmount"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "_amount - contributionAmount"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
                Identifier contributionAmount
                   Type: uint256
                   Source: "contributionAmount"
      IfStatement
         Source: "if (ethRaised + contributionAmount > minCap && minCap > ethRaised) {\r\n      MinCapReached(block.number);\r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 846
           Source: "ethRaised + contributionAmount > minCap && minCap > ethRaised"
          BinaryOperation using operator >
             Type: bool
             Source: "ethRaised + contributionAmount > minCap"
            BinaryOperation using operator +
               Type: uint256
               Source: "ethRaised + contributionAmount"
              Identifier ethRaised
                 Type: uint256
                 Source: "ethRaised"
              Identifier contributionAmount
                 Type: uint256
                 Source: "contributionAmount"
            Identifier minCap
               Type: uint256
               Source: "minCap"
          BinaryOperation using operator >
             Type: bool
             Source: "minCap > ethRaised"
            Identifier minCap
               Type: uint256
               Source: "minCap"
            Identifier ethRaised
               Type: uint256
               Source: "ethRaised"
        Block
           Source: "{\r\n      MinCapReached(block.number);\r\n    }"
          ExpressionStatement
             Gas costs: [???]
             Source: "MinCapReached(block.number)"
            FunctionCall
               Type: tuple()
               Source: "MinCapReached(block.number)"
              Identifier MinCapReached
                 Type: function (uint256)
                 Source: "MinCapReached"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
      IfStatement
         Source: "if (ethRaised + contributionAmount == maxCap && ethRaised < maxCap) {\r\n      MaxCapReached(block.number);\r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 846
           Source: "ethRaised + contributionAmount == maxCap && ethRaised < maxCap"
          BinaryOperation using operator ==
             Type: bool
             Source: "ethRaised + contributionAmount == maxCap"
            BinaryOperation using operator +
               Type: uint256
               Source: "ethRaised + contributionAmount"
              Identifier ethRaised
                 Type: uint256
                 Source: "ethRaised"
              Identifier contributionAmount
                 Type: uint256
                 Source: "contributionAmount"
            Identifier maxCap
               Type: uint256
               Source: "maxCap"
          BinaryOperation using operator <
             Type: bool
             Source: "ethRaised < maxCap"
            Identifier ethRaised
               Type: uint256
               Source: "ethRaised"
            Identifier maxCap
               Type: uint256
               Source: "maxCap"
        Block
           Source: "{\r\n      MaxCapReached(block.number);\r\n    }"
          ExpressionStatement
             Gas costs: [???]
             Source: "MaxCapReached(block.number)"
            FunctionCall
               Type: tuple()
               Source: "MaxCapReached(block.number)"
              Identifier MaxCapReached
                 Type: function (uint256)
                 Source: "MaxCapReached"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
      IfStatement
         Source: "if (contributorList[_contributor].contributionAmount == 0) {\r\n        contributorIndexes[nextContributorIndex] = _contributor;\r\n        nextContributorIndex += 1;\r\n    }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 311
           Source: "contributorList[_contributor].contributionAmount == 0"
          MemberAccess to member contributionAmount
             Type: uint256
             Source: "contributorList[_contributor].contributionAmount"
            IndexAccess
               Type: struct Crowdsale.ContributorData storage ref
               Source: "contributorList[_contributor]"
              Identifier contributorList
                 Type: mapping(address => struct Crowdsale.ContributorData storage ref)
                 Source: "contributorList"
              Identifier _contributor
                 Type: address
                 Source: "_contributor"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n        contributorIndexes[nextContributorIndex] = _contributor;\r\n        nextContributorIndex += 1;\r\n    }"
          ExpressionStatement
             Gas costs: 20551
             Source: "contributorIndexes[nextContributorIndex] = _contributor"
            Assignment using operator =
               Type: address
               Source: "contributorIndexes[nextContributorIndex] = _contributor"
              IndexAccess
                 Type: address
                 Source: "contributorIndexes[nextContributorIndex]"
                Identifier contributorIndexes
                   Type: mapping(uint256 => address)
                   Source: "contributorIndexes"
                Identifier nextContributorIndex
                   Type: uint256
                   Source: "nextContributorIndex"
              Identifier _contributor
                 Type: address
                 Source: "_contributor"
          ExpressionStatement
             Gas costs: 20233
             Source: "nextContributorIndex += 1"
            Assignment using operator +=
               Type: uint256
               Source: "nextContributorIndex += 1"
              Identifier nextContributorIndex
                 Type: uint256
                 Source: "nextContributorIndex"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      ExpressionStatement
         Gas costs: 20335
         Source: "contributorList[_contributor].contributionAmount += contributionAmount"
        Assignment using operator +=
           Type: uint256
           Source: "contributorList[_contributor].contributionAmount += contributionAmount"
          MemberAccess to member contributionAmount
             Type: uint256
             Source: "contributorList[_contributor].contributionAmount"
            IndexAccess
               Type: struct Crowdsale.ContributorData storage ref
               Source: "contributorList[_contributor]"
              Identifier contributorList
                 Type: mapping(address => struct Crowdsale.ContributorData storage ref)
                 Source: "contributorList"
              Identifier _contributor
                 Type: address
                 Source: "_contributor"
          Identifier contributionAmount
             Type: uint256
             Source: "contributionAmount"
      ExpressionStatement
         Gas costs: 20233
         Source: "ethRaised += contributionAmount"
        Assignment using operator +=
           Type: uint256
           Source: "ethRaised += contributionAmount"
          Identifier ethRaised
             Type: uint256
             Source: "ethRaised"
          Identifier contributionAmount
             Type: uint256
             Source: "contributionAmount"
      VariableDeclarationStatement
         Gas costs: 28
         Source: "uint tokenAmount = calculateEthToToken(contributionAmount, block.number)"
        VariableDeclaration "tokenAmount"
           Type: uint256
           Source: "uint tokenAmount"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "calculateEthToToken(contributionAmount, block.number)"
          Identifier calculateEthToToken
             Type: function (uint256,uint256) view returns (uint256)
             Source: "calculateEthToToken"
          Identifier contributionAmount
             Type: uint256
             Source: "contributionAmount"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
      IfStatement
         Source: "if (tokenAmount > 0) {\r\n      SportifyTokenInterface(tokenAddress).mint(_contributor, tokenAmount);       // Issue new tokens\r\n      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "tokenAmount > 0"
          Identifier tokenAmount
             Type: uint256
             Source: "tokenAmount"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n      SportifyTokenInterface(tokenAddress).mint(_contributor, tokenAmount);       // Issue new tokens\r\n      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\r\n    }"
          ExpressionStatement
             Gas costs: [???]
             Source: "SportifyTokenInterface(tokenAddress).mint(_contributor, tokenAmount)"
            FunctionCall
               Type: tuple()
               Source: "SportifyTokenInterface(tokenAddress).mint(_contributor, tokenAmount)"
              MemberAccess to member mint
                 Type: function (address,uint256) external
                 Source: "SportifyTokenInterface(tokenAddress).mint"
                FunctionCall
                   Type: contract SportifyTokenInterface
                   Source: "SportifyTokenInterface(tokenAddress)"
                  Identifier SportifyTokenInterface
                     Type: type(contract SportifyTokenInterface)
                     Source: "SportifyTokenInterface"
                  Identifier tokenAddress
                     Type: address
                     Source: "tokenAddress"
              Identifier _contributor
                 Type: address
                 Source: "_contributor"
              Identifier tokenAmount
                 Type: uint256
                 Source: "tokenAmount"
          ExpressionStatement
             Gas costs: 20335
             Source: "contributorList[_contributor].tokensIssued += tokenAmount"
            Assignment using operator +=
               Type: uint256
               Source: "contributorList[_contributor].tokensIssued += tokenAmount"
              MemberAccess to member tokensIssued
                 Type: uint256
                 Source: "contributorList[_contributor].tokensIssued"
                IndexAccess
                   Type: struct Crowdsale.ContributorData storage ref
                   Source: "contributorList[_contributor]"
                  Identifier contributorList
                     Type: mapping(address => struct Crowdsale.ContributorData storage ref)
                     Source: "contributorList"
                  Identifier _contributor
                     Type: address
                     Source: "_contributor"
              Identifier tokenAmount
                 Type: uint256
                 Source: "tokenAmount"
      IfStatement
         Source: "if (returnAmount != 0) {\r\n      _contributor.transfer(returnAmount);\r\n    }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 12
           Source: "returnAmount != 0"
          Identifier returnAmount
             Type: uint256
             Source: "returnAmount"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n      _contributor.transfer(returnAmount);\r\n    }"
          ExpressionStatement
             Gas costs: [???]
             Source: "_contributor.transfer(returnAmount)"
            FunctionCall
               Type: tuple()
               Source: "_contributor.transfer(returnAmount)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "_contributor.transfer"
                Identifier _contributor
                   Type: address
                   Source: "_contributor"
              Identifier returnAmount
                 Type: uint256
                 Source: "returnAmount"
  FunctionDefinition "pushAngelInvestmentData" - public
     Source: "function pushAngelInvestmentData(address _address, uint _ethContributed) onlyOwner public {\r\n      assert(ethRaised + _ethContributed <= maxCap);\r\n      processTransaction(_address, _ethContributed);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _address, uint _ethContributed)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_ethContributed"
         Type: uint256
         Source: "uint _ethContributed"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n      assert(ethRaised + _ethContributed <= maxCap);\r\n      processTransaction(_address, _ethContributed);\r\n  }"
      ExpressionStatement
         Gas costs: 438
         Source: "assert(ethRaised + _ethContributed <= maxCap)"
        FunctionCall
           Type: tuple()
           Source: "assert(ethRaised + _ethContributed <= maxCap)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "ethRaised + _ethContributed <= maxCap"
            BinaryOperation using operator +
               Type: uint256
               Source: "ethRaised + _ethContributed"
              Identifier ethRaised
                 Type: uint256
                 Source: "ethRaised"
              Identifier _ethContributed
                 Type: uint256
                 Source: "_ethContributed"
            Identifier maxCap
               Type: uint256
               Source: "maxCap"
      ExpressionStatement
         Gas costs: 10
         Source: "processTransaction(_address, _ethContributed)"
        FunctionCall
           Type: tuple()
           Source: "processTransaction(_address, _ethContributed)"
          Identifier processTransaction
             Type: function (address,uint256)
             Source: "processTransaction"
          Identifier _address
             Type: address
             Source: "_address"
          Identifier _ethContributed
             Type: uint256
             Source: "_ethContributed"
  FunctionDefinition "depositAngelInvestmentEth" - public
     Source: "function depositAngelInvestmentEth() payable onlyOwner public {}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "salvageTokensFromContract" - public
     Source: "function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\r\n    ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _tokenAddress, address _to, uint _amount)"
      VariableDeclaration "_tokenAddress"
         Type: address
         Source: "address _tokenAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n  }"
      ExpressionStatement
         Gas costs: [???]
         Source: "ERC20TokenInterface(_tokenAddress).transfer(_to, _amount)"
        FunctionCall
           Type: bool
           Source: "ERC20TokenInterface(_tokenAddress).transfer(_to, _amount)"
          MemberAccess to member transfer
             Type: function (address,uint256) external returns (bool)
             Source: "ERC20TokenInterface(_tokenAddress).transfer"
            FunctionCall
               Type: contract ERC20TokenInterface
               Source: "ERC20TokenInterface(_tokenAddress)"
              Identifier ERC20TokenInterface
                 Type: type(contract ERC20TokenInterface)
                 Source: "ERC20TokenInterface"
              Identifier _tokenAddress
                 Type: address
                 Source: "_tokenAddress"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
  FunctionDefinition "withdrawEth" - public
     Source: "function withdrawEth() onlyOwner public {\r\n    require(this.balance != 0);\r\n    require(ethRaised >= minCap);\r\n\r\n    multisigAddress.transfer(this.balance);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(this.balance != 0);\r\n    require(ethRaised >= minCap);\r\n\r\n    multisigAddress.transfer(this.balance);\r\n  }"
      ExpressionStatement
         Gas costs: 443
         Source: "require(this.balance != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(this.balance != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "this.balance != 0"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract Crowdsale
                 Source: "this"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 438
         Source: "require(ethRaised >= minCap)"
        FunctionCall
           Type: tuple()
           Source: "require(ethRaised >= minCap)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "ethRaised >= minCap"
            Identifier ethRaised
               Type: uint256
               Source: "ethRaised"
            Identifier minCap
               Type: uint256
               Source: "minCap"
      ExpressionStatement
         Gas costs: [???]
         Source: "multisigAddress.transfer(this.balance)"
        FunctionCall
           Type: tuple()
           Source: "multisigAddress.transfer(this.balance)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "multisigAddress.transfer"
            Identifier multisigAddress
               Type: address
               Source: "multisigAddress"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract Crowdsale
               Source: "this"
  FunctionDefinition "claimEthIfFailed" - public
     Source: "function claimEthIfFailed() public {\r\n    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);    // Check if crowdsale has failed\r\n    require(contributorList[msg.sender].contributionAmount > 0);          // Check if contributor has contributed to crowdsaleEndedBlock\r\n    require(!hasClaimedEthWhenFail[msg.sender]);                          // Check if contributor has already claimed his eth\r\n\r\n    uint ethContributed = contributorList[msg.sender].contributionAmount; // Get contributors contribution\r\n    hasClaimedEthWhenFail[msg.sender] = true;                             // Set that he has claimed\r\n    if (!msg.sender.send(ethContributed)) {                                // Refund eth\r\n      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);    // Check if crowdsale has failed\r\n    require(contributorList[msg.sender].contributionAmount > 0);          // Check if contributor has contributed to crowdsaleEndedBlock\r\n    require(!hasClaimedEthWhenFail[msg.sender]);                          // Check if contributor has already claimed his eth\r\n\r\n    uint ethContributed = contributorList[msg.sender].contributionAmount; // Get contributors contribution\r\n    hasClaimedEthWhenFail[msg.sender] = true;                             // Set that he has claimed\r\n    if (!msg.sender.send(ethContributed)) {                                // Refund eth\r\n      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\r\n    }\r\n  }"
      ExpressionStatement
         Gas costs: 665
         Source: "require(block.number > crowdsaleEndedBlock && ethRaised < minCap)"
        FunctionCall
           Type: tuple()
           Source: "require(block.number > crowdsaleEndedBlock && ethRaised < minCap)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "block.number > crowdsaleEndedBlock && ethRaised < minCap"
            BinaryOperation using operator >
               Type: bool
               Source: "block.number > crowdsaleEndedBlock"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              Identifier crowdsaleEndedBlock
                 Type: uint256
                 Source: "crowdsaleEndedBlock"
            BinaryOperation using operator <
               Type: bool
               Source: "ethRaised < minCap"
              Identifier ethRaised
                 Type: uint256
                 Source: "ethRaised"
              Identifier minCap
                 Type: uint256
                 Source: "minCap"
      ExpressionStatement
         Gas costs: 336
         Source: "require(contributorList[msg.sender].contributionAmount > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(contributorList[msg.sender].contributionAmount > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "contributorList[msg.sender].contributionAmount > 0"
            MemberAccess to member contributionAmount
               Type: uint256
               Source: "contributorList[msg.sender].contributionAmount"
              IndexAccess
                 Type: struct Crowdsale.ContributorData storage ref
                 Source: "contributorList[msg.sender]"
                Identifier contributorList
                   Type: mapping(address => struct Crowdsale.ContributorData storage ref)
                   Source: "contributorList"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 363
         Source: "require(!hasClaimedEthWhenFail[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(!hasClaimedEthWhenFail[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!hasClaimedEthWhenFail[msg.sender]"
            IndexAccess
               Type: bool
               Source: "hasClaimedEthWhenFail[msg.sender]"
              Identifier hasClaimedEthWhenFail
                 Type: mapping(address => bool)
                 Source: "hasClaimedEthWhenFail"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      VariableDeclarationStatement
         Gas costs: 312
         Source: "uint ethContributed = contributorList[msg.sender].contributionAmount"
        VariableDeclaration "ethContributed"
           Type: uint256
           Source: "uint ethContributed"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member contributionAmount
           Type: uint256
           Source: "contributorList[msg.sender].contributionAmount"
          IndexAccess
             Type: struct Crowdsale.ContributorData storage ref
             Source: "contributorList[msg.sender]"
            Identifier contributorList
               Type: mapping(address => struct Crowdsale.ContributorData storage ref)
               Source: "contributorList"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 20356
         Source: "hasClaimedEthWhenFail[msg.sender] = true"
        Assignment using operator =
           Type: bool
           Source: "hasClaimedEthWhenFail[msg.sender] = true"
          IndexAccess
             Type: bool
             Source: "hasClaimedEthWhenFail[msg.sender]"
            Identifier hasClaimedEthWhenFail
               Type: mapping(address => bool)
               Source: "hasClaimedEthWhenFail"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      IfStatement
         Source: "if (!msg.sender.send(ethContributed)) {                                // Refund eth\r\n      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\r\n    }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!msg.sender.send(ethContributed)"
          FunctionCall
             Type: bool
             Source: "msg.sender.send(ethContributed)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "msg.sender.send"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier ethContributed
               Type: uint256
               Source: "ethContributed"
        Block
           Source: "{                                // Refund eth\r\n      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\r\n    }"
          ExpressionStatement
             Gas costs: [???]
             Source: "ErrorSendingETH(msg.sender, ethContributed)"
            FunctionCall
               Type: tuple()
               Source: "ErrorSendingETH(msg.sender, ethContributed)"
              Identifier ErrorSendingETH
                 Type: function (address,uint256)
                 Source: "ErrorSendingETH"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier ethContributed
                 Type: uint256
                 Source: "ethContributed"
  FunctionDefinition "batchReturnEthIfFailed" - public
     Source: "function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\r\n    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);                // Check if crowdsale has failed\r\n    address currentParticipantAddress;\r\n    uint contribution;\r\n    for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\r\n      if (currentParticipantAddress == 0x0) {\r\n        return;                                                                       // Check if all the participants were compensated\r\n      }\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)) {                          // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                                    // Repeat\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint _numberOfReturns)"
      VariableDeclaration "_numberOfReturns"
         Type: uint256
         Source: "uint _numberOfReturns"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);                // Check if crowdsale has failed\r\n    address currentParticipantAddress;\r\n    uint contribution;\r\n    for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\r\n      if (currentParticipantAddress == 0x0) {\r\n        return;                                                                       // Check if all the participants were compensated\r\n      }\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)) {                          // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                                    // Repeat\r\n    }\r\n  }"
      ExpressionStatement
         Gas costs: 665
         Source: "require(block.number > crowdsaleEndedBlock && ethRaised < minCap)"
        FunctionCall
           Type: tuple()
           Source: "require(block.number > crowdsaleEndedBlock && ethRaised < minCap)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "block.number > crowdsaleEndedBlock && ethRaised < minCap"
            BinaryOperation using operator >
               Type: bool
               Source: "block.number > crowdsaleEndedBlock"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              Identifier crowdsaleEndedBlock
                 Type: uint256
                 Source: "crowdsaleEndedBlock"
            BinaryOperation using operator <
               Type: bool
               Source: "ethRaised < minCap"
              Identifier ethRaised
                 Type: uint256
                 Source: "ethRaised"
              Identifier minCap
                 Type: uint256
                 Source: "minCap"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "address currentParticipantAddress"
        VariableDeclaration "currentParticipantAddress"
           Type: address
           Source: "address currentParticipantAddress"
          ElementaryTypeName address
             Source: "address"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint contribution"
        VariableDeclaration "contribution"
           Type: uint256
           Source: "uint contribution"
          ElementaryTypeName uint
             Source: "uint"
      ForStatement
         Source: "for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\r\n      if (currentParticipantAddress == 0x0) {\r\n        return;                                                                       // Check if all the participants were compensated\r\n      }\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)) {                          // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                                    // Repeat\r\n    }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint cnt = 0"
          VariableDeclaration "cnt"
             Type: uint256
             Source: "uint cnt"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "cnt < _numberOfReturns"
          Identifier cnt
             Type: uint256
             Source: "cnt"
          Identifier _numberOfReturns
             Type: uint256
             Source: "_numberOfReturns"
        ExpressionStatement
           Gas costs: 19
           Source: "cnt++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "cnt++"
            Identifier cnt
               Type: uint256
               Source: "cnt"
        Block
           Source: "{\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\r\n      if (currentParticipantAddress == 0x0) {\r\n        return;                                                                       // Check if all the participants were compensated\r\n      }\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)) {                          // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                                    // Repeat\r\n    }"
          ExpressionStatement
             Gas costs: 528
             Source: "currentParticipantAddress = contributorIndexes[nextContributorToClaim]"
            Assignment using operator =
               Type: address
               Source: "currentParticipantAddress = contributorIndexes[nextContributorToClaim]"
              Identifier currentParticipantAddress
                 Type: address
                 Source: "currentParticipantAddress"
              IndexAccess
                 Type: address
                 Source: "contributorIndexes[nextContributorToClaim]"
                Identifier contributorIndexes
                   Type: mapping(uint256 => address)
                   Source: "contributorIndexes"
                Identifier nextContributorToClaim
                   Type: uint256
                   Source: "nextContributorToClaim"
          IfStatement
             Source: "if (currentParticipantAddress == 0x0) {\r\n        return;                                                                       // Check if all the participants were compensated\r\n      }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 15
               Source: "currentParticipantAddress == 0x0"
              Identifier currentParticipantAddress
                 Type: address
                 Source: "currentParticipantAddress"
              Literal, token: [no token] value: 0x0
                 Type: int_const 0
                 Source: "0x0"
            Block
               Source: "{\r\n        return;                                                                       // Check if all the participants were compensated\r\n      }"
              Return
                 Gas costs: 11
                 Source: "return;"
          IfStatement
             Source: "if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)) {                          // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: 338
               Source: "!hasClaimedEthWhenFail[currentParticipantAddress]"
              IndexAccess
                 Type: bool
                 Source: "hasClaimedEthWhenFail[currentParticipantAddress]"
                Identifier hasClaimedEthWhenFail
                   Type: mapping(address => bool)
                   Source: "hasClaimedEthWhenFail"
                Identifier currentParticipantAddress
                   Type: address
                   Source: "currentParticipantAddress"
            Block
               Source: "{                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)) {                          // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }"
              ExpressionStatement
                 Gas costs: 310
                 Source: "contribution = contributorList[currentParticipantAddress].contributionAmount"
                Assignment using operator =
                   Type: uint256
                   Source: "contribution = contributorList[currentParticipantAddress].contributionAmount"
                  Identifier contribution
                     Type: uint256
                     Source: "contribution"
                  MemberAccess to member contributionAmount
                     Type: uint256
                     Source: "contributorList[currentParticipantAddress].contributionAmount"
                    IndexAccess
                       Type: struct Crowdsale.ContributorData storage ref
                       Source: "contributorList[currentParticipantAddress]"
                      Identifier contributorList
                         Type: mapping(address => struct Crowdsale.ContributorData storage ref)
                         Source: "contributorList"
                      Identifier currentParticipantAddress
                         Type: address
                         Source: "currentParticipantAddress"
              ExpressionStatement
                 Gas costs: 20357
                 Source: "hasClaimedEthWhenFail[currentParticipantAddress] = true"
                Assignment using operator =
                   Type: bool
                   Source: "hasClaimedEthWhenFail[currentParticipantAddress] = true"
                  IndexAccess
                     Type: bool
                     Source: "hasClaimedEthWhenFail[currentParticipantAddress]"
                    Identifier hasClaimedEthWhenFail
                       Type: mapping(address => bool)
                       Source: "hasClaimedEthWhenFail"
                    Identifier currentParticipantAddress
                       Type: address
                       Source: "currentParticipantAddress"
                  Literal, token: true value: true
                     Type: bool
                     Source: "true"
              IfStatement
                 Source: "if (!currentParticipantAddress.send(contribution)) {                          // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }"
                UnaryOperation (prefix) !
                   Type: bool
                   Gas costs: [???]
                   Source: "!currentParticipantAddress.send(contribution)"
                  FunctionCall
                     Type: bool
                     Source: "currentParticipantAddress.send(contribution)"
                    MemberAccess to member send
                       Type: function (uint256) returns (bool)
                       Source: "currentParticipantAddress.send"
                      Identifier currentParticipantAddress
                         Type: address
                         Source: "currentParticipantAddress"
                    Identifier contribution
                       Type: uint256
                       Source: "contribution"
                Block
                   Source: "{                          // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "ErrorSendingETH(currentParticipantAddress, contribution)"
                    FunctionCall
                       Type: tuple()
                       Source: "ErrorSendingETH(currentParticipantAddress, contribution)"
                      Identifier ErrorSendingETH
                         Type: function (address,uint256)
                         Source: "ErrorSendingETH"
                      Identifier currentParticipantAddress
                         Type: address
                         Source: "currentParticipantAddress"
                      Identifier contribution
                         Type: uint256
                         Source: "contribution"
          ExpressionStatement
             Gas costs: 20233
             Source: "nextContributorToClaim += 1"
            Assignment using operator +=
               Type: uint256
               Source: "nextContributorToClaim += 1"
              Identifier nextContributorToClaim
                 Type: uint256
                 Source: "nextContributorToClaim"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
  FunctionDefinition "withdrawRemainingBalanceForManualRecovery" - public
     Source: "function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\r\n    require(this.balance != 0);                                  // Check if there are any eth to claim\r\n    require(block.number > crowdsaleEndedBlock);                 // Check if crowdsale is over\r\n    require(contributorIndexes[nextContributorToClaim] == 0x0);  // Check if all the users were refunded\r\n    multisigAddress.transfer(this.balance);                      // Withdraw to multisig\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(this.balance != 0);                                  // Check if there are any eth to claim\r\n    require(block.number > crowdsaleEndedBlock);                 // Check if crowdsale is over\r\n    require(contributorIndexes[nextContributorToClaim] == 0x0);  // Check if all the users were refunded\r\n    multisigAddress.transfer(this.balance);                      // Withdraw to multisig\r\n  }"
      ExpressionStatement
         Gas costs: 443
         Source: "require(this.balance != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(this.balance != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "this.balance != 0"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract Crowdsale
                 Source: "this"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 234
         Source: "require(block.number > crowdsaleEndedBlock)"
        FunctionCall
           Type: tuple()
           Source: "require(block.number > crowdsaleEndedBlock)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "block.number > crowdsaleEndedBlock"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier crowdsaleEndedBlock
               Type: uint256
               Source: "crowdsaleEndedBlock"
      ExpressionStatement
         Gas costs: 561
         Source: "require(contributorIndexes[nextContributorToClaim] == 0x0)"
        FunctionCall
           Type: tuple()
           Source: "require(contributorIndexes[nextContributorToClaim] == 0x0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "contributorIndexes[nextContributorToClaim] == 0x0"
            IndexAccess
               Type: address
               Source: "contributorIndexes[nextContributorToClaim]"
              Identifier contributorIndexes
                 Type: mapping(uint256 => address)
                 Source: "contributorIndexes"
              Identifier nextContributorToClaim
                 Type: uint256
                 Source: "nextContributorToClaim"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      ExpressionStatement
         Gas costs: [???]
         Source: "multisigAddress.transfer(this.balance)"
        FunctionCall
           Type: tuple()
           Source: "multisigAddress.transfer(this.balance)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "multisigAddress.transfer"
            Identifier multisigAddress
               Type: address
               Source: "multisigAddress"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract Crowdsale
               Source: "this"
  FunctionDefinition "claimTeamTokens" - public
     Source: "function claimTeamTokens(address _to, uint _choice) onlyOwner public {\r\n    require(crowdsaleState == state.crowdsaleEnded);\r\n    require(ethRaised >= minCap);\r\n\r\n    uint mintAmount;\r\n    if (_choice == 1) {\r\n      assert(!advisorAndAmbassadorTokensClaimed);\r\n      mintAmount = advisorAndAmbassadorTokens;\r\n      advisorAndAmbassadorTokensClaimed = true;\r\n    } else if (_choice == 2) {\r\n      assert(!futurePromoEventTokensClaimed);\r\n      mintAmount = futurePromoEventTokens;\r\n      futurePromoEventTokensClaimed = true;\r\n    } else if (_choice == 3) {\r\n      assert(!foundersAndTeamTokensClaimed);\r\n      assert(advisorAndAmbassadorTokensClaimed);\r\n      assert(futurePromoEventTokensClaimed);\r\n      assert(tokenTotalSupply > ERC20TokenInterface(tokenAddress).totalSupply());\r\n      mintAmount = tokenTotalSupply - ERC20TokenInterface(tokenAddress).totalSupply();\r\n      foundersAndTeamTokensClaimed = true;\r\n    } else {\r\n      revert();\r\n    }\r\n    SportifyTokenInterface(tokenAddress).mint(_to, mintAmount);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _choice)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_choice"
         Type: uint256
         Source: "uint _choice"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(crowdsaleState == state.crowdsaleEnded);\r\n    require(ethRaised >= minCap);\r\n\r\n    uint mintAmount;\r\n    if (_choice == 1) {\r\n      assert(!advisorAndAmbassadorTokensClaimed);\r\n      mintAmount = advisorAndAmbassadorTokens;\r\n      advisorAndAmbassadorTokensClaimed = true;\r\n    } else if (_choice == 2) {\r\n      assert(!futurePromoEventTokensClaimed);\r\n      mintAmount = futurePromoEventTokens;\r\n      futurePromoEventTokensClaimed = true;\r\n    } else if (_choice == 3) {\r\n      assert(!foundersAndTeamTokensClaimed);\r\n      assert(advisorAndAmbassadorTokensClaimed);\r\n      assert(futurePromoEventTokensClaimed);\r\n      assert(tokenTotalSupply > ERC20TokenInterface(tokenAddress).totalSupply());\r\n      mintAmount = tokenTotalSupply - ERC20TokenInterface(tokenAddress).totalSupply();\r\n      foundersAndTeamTokensClaimed = true;\r\n    } else {\r\n      revert();\r\n    }\r\n    SportifyTokenInterface(tokenAddress).mint(_to, mintAmount);\r\n  }"
      ExpressionStatement
         Gas costs: 323
         Source: "require(crowdsaleState == state.crowdsaleEnded)"
        FunctionCall
           Type: tuple()
           Source: "require(crowdsaleState == state.crowdsaleEnded)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "crowdsaleState == state.crowdsaleEnded"
            Identifier crowdsaleState
               Type: enum Crowdsale.state
               Source: "crowdsaleState"
            MemberAccess to member crowdsaleEnded
               Type: enum Crowdsale.state
               Source: "state.crowdsaleEnded"
              Identifier state
                 Type: type(enum Crowdsale.state)
                 Source: "state"
      ExpressionStatement
         Gas costs: 438
         Source: "require(ethRaised >= minCap)"
        FunctionCall
           Type: tuple()
           Source: "require(ethRaised >= minCap)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "ethRaised >= minCap"
            Identifier ethRaised
               Type: uint256
               Source: "ethRaised"
            Identifier minCap
               Type: uint256
               Source: "minCap"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint mintAmount"
        VariableDeclaration "mintAmount"
           Type: uint256
           Source: "uint mintAmount"
          ElementaryTypeName uint
             Source: "uint"
      IfStatement
         Source: "if (_choice == 1) {\r\n      assert(!advisorAndAmbassadorTokensClaimed);\r\n      mintAmount = advisorAndAmbassadorTokens;\r\n      advisorAndAmbassadorTokensClaimed = true;\r\n    } else if (_choice == 2) {\r\n      assert(!futurePromoEventTokensClaimed);\r\n      mintAmount = futurePromoEventTokens;\r\n      futurePromoEventTokensClaimed = true;\r\n    } else if (_choice == 3) {\r\n      assert(!foundersAndTeamTokensClaimed);\r\n      assert(advisorAndAmbassadorTokensClaimed);\r\n      assert(futurePromoEventTokensClaimed);\r\n      assert(tokenTotalSupply > ERC20TokenInterface(tokenAddress).totalSupply());\r\n      mintAmount = tokenTotalSupply - ERC20TokenInterface(tokenAddress).totalSupply();\r\n      foundersAndTeamTokensClaimed = true;\r\n    } else {\r\n      revert();\r\n    }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "_choice == 1"
          Identifier _choice
             Type: uint256
             Source: "_choice"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        Block
           Source: "{\r\n      assert(!advisorAndAmbassadorTokensClaimed);\r\n      mintAmount = advisorAndAmbassadorTokens;\r\n      advisorAndAmbassadorTokensClaimed = true;\r\n    }"
          ExpressionStatement
             Gas costs: 312
             Source: "assert(!advisorAndAmbassadorTokensClaimed)"
            FunctionCall
               Type: tuple()
               Source: "assert(!advisorAndAmbassadorTokensClaimed)"
              Identifier assert
                 Type: function (bool) pure
                 Source: "assert"
              UnaryOperation (prefix) !
                 Type: bool
                 Source: "!advisorAndAmbassadorTokensClaimed"
                Identifier advisorAndAmbassadorTokensClaimed
                   Type: bool
                   Source: "advisorAndAmbassadorTokensClaimed"
          ExpressionStatement
             Gas costs: 208
             Source: "mintAmount = advisorAndAmbassadorTokens"
            Assignment using operator =
               Type: uint256
               Source: "mintAmount = advisorAndAmbassadorTokens"
              Identifier mintAmount
                 Type: uint256
                 Source: "mintAmount"
              Identifier advisorAndAmbassadorTokens
                 Type: uint256
                 Source: "advisorAndAmbassadorTokens"
          ExpressionStatement
             Gas costs: 20317
             Source: "advisorAndAmbassadorTokensClaimed = true"
            Assignment using operator =
               Type: bool
               Source: "advisorAndAmbassadorTokensClaimed = true"
              Identifier advisorAndAmbassadorTokensClaimed
                 Type: bool
                 Source: "advisorAndAmbassadorTokensClaimed"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
        IfStatement
           Source: "if (_choice == 2) {\r\n      assert(!futurePromoEventTokensClaimed);\r\n      mintAmount = futurePromoEventTokens;\r\n      futurePromoEventTokensClaimed = true;\r\n    } else if (_choice == 3) {\r\n      assert(!foundersAndTeamTokensClaimed);\r\n      assert(advisorAndAmbassadorTokensClaimed);\r\n      assert(futurePromoEventTokensClaimed);\r\n      assert(tokenTotalSupply > ERC20TokenInterface(tokenAddress).totalSupply());\r\n      mintAmount = tokenTotalSupply - ERC20TokenInterface(tokenAddress).totalSupply();\r\n      foundersAndTeamTokensClaimed = true;\r\n    } else {\r\n      revert();\r\n    }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 9
             Source: "_choice == 2"
            Identifier _choice
               Type: uint256
               Source: "_choice"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
          Block
             Source: "{\r\n      assert(!futurePromoEventTokensClaimed);\r\n      mintAmount = futurePromoEventTokens;\r\n      futurePromoEventTokensClaimed = true;\r\n    }"
            ExpressionStatement
               Gas costs: 312
               Source: "assert(!futurePromoEventTokensClaimed)"
              FunctionCall
                 Type: tuple()
                 Source: "assert(!futurePromoEventTokensClaimed)"
                Identifier assert
                   Type: function (bool) pure
                   Source: "assert"
                UnaryOperation (prefix) !
                   Type: bool
                   Source: "!futurePromoEventTokensClaimed"
                  Identifier futurePromoEventTokensClaimed
                     Type: bool
                     Source: "futurePromoEventTokensClaimed"
            ExpressionStatement
               Gas costs: 208
               Source: "mintAmount = futurePromoEventTokens"
              Assignment using operator =
                 Type: uint256
                 Source: "mintAmount = futurePromoEventTokens"
                Identifier mintAmount
                   Type: uint256
                   Source: "mintAmount"
                Identifier futurePromoEventTokens
                   Type: uint256
                   Source: "futurePromoEventTokens"
            ExpressionStatement
               Gas costs: 20317
               Source: "futurePromoEventTokensClaimed = true"
              Assignment using operator =
                 Type: bool
                 Source: "futurePromoEventTokensClaimed = true"
                Identifier futurePromoEventTokensClaimed
                   Type: bool
                   Source: "futurePromoEventTokensClaimed"
                Literal, token: true value: true
                   Type: bool
                   Source: "true"
          IfStatement
             Source: "if (_choice == 3) {\r\n      assert(!foundersAndTeamTokensClaimed);\r\n      assert(advisorAndAmbassadorTokensClaimed);\r\n      assert(futurePromoEventTokensClaimed);\r\n      assert(tokenTotalSupply > ERC20TokenInterface(tokenAddress).totalSupply());\r\n      mintAmount = tokenTotalSupply - ERC20TokenInterface(tokenAddress).totalSupply();\r\n      foundersAndTeamTokensClaimed = true;\r\n    } else {\r\n      revert();\r\n    }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 9
               Source: "_choice == 3"
              Identifier _choice
                 Type: uint256
                 Source: "_choice"
              Literal, token: [no token] value: 3
                 Type: int_const 3
                 Source: "3"
            Block
               Source: "{\r\n      assert(!foundersAndTeamTokensClaimed);\r\n      assert(advisorAndAmbassadorTokensClaimed);\r\n      assert(futurePromoEventTokensClaimed);\r\n      assert(tokenTotalSupply > ERC20TokenInterface(tokenAddress).totalSupply());\r\n      mintAmount = tokenTotalSupply - ERC20TokenInterface(tokenAddress).totalSupply();\r\n      foundersAndTeamTokensClaimed = true;\r\n    }"
              ExpressionStatement
                 Gas costs: 262
                 Source: "assert(!foundersAndTeamTokensClaimed)"
                FunctionCall
                   Type: tuple()
                   Source: "assert(!foundersAndTeamTokensClaimed)"
                  Identifier assert
                     Type: function (bool) pure
                     Source: "assert"
                  UnaryOperation (prefix) !
                     Type: bool
                     Source: "!foundersAndTeamTokensClaimed"
                    Identifier foundersAndTeamTokensClaimed
                       Type: bool
                       Source: "foundersAndTeamTokensClaimed"
              ExpressionStatement
                 Gas costs: 309
                 Source: "assert(advisorAndAmbassadorTokensClaimed)"
                FunctionCall
                   Type: tuple()
                   Source: "assert(advisorAndAmbassadorTokensClaimed)"
                  Identifier assert
                     Type: function (bool) pure
                     Source: "assert"
                  Identifier advisorAndAmbassadorTokensClaimed
                     Type: bool
                     Source: "advisorAndAmbassadorTokensClaimed"
              ExpressionStatement
                 Gas costs: 309
                 Source: "assert(futurePromoEventTokensClaimed)"
                FunctionCall
                   Type: tuple()
                   Source: "assert(futurePromoEventTokensClaimed)"
                  Identifier assert
                     Type: function (bool) pure
                     Source: "assert"
                  Identifier futurePromoEventTokensClaimed
                     Type: bool
                     Source: "futurePromoEventTokensClaimed"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "assert(tokenTotalSupply > ERC20TokenInterface(tokenAddress).totalSupply())"
                FunctionCall
                   Type: tuple()
                   Source: "assert(tokenTotalSupply > ERC20TokenInterface(tokenAddress).totalSupply())"
                  Identifier assert
                     Type: function (bool) pure
                     Source: "assert"
                  BinaryOperation using operator >
                     Type: bool
                     Source: "tokenTotalSupply > ERC20TokenInterface(tokenAddress).totalSupply()"
                    Identifier tokenTotalSupply
                       Type: uint256
                       Source: "tokenTotalSupply"
                    FunctionCall
                       Type: uint256
                       Source: "ERC20TokenInterface(tokenAddress).totalSupply()"
                      MemberAccess to member totalSupply
                         Type: function () view external returns (uint256)
                         Source: "ERC20TokenInterface(tokenAddress).totalSupply"
                        FunctionCall
                           Type: contract ERC20TokenInterface
                           Source: "ERC20TokenInterface(tokenAddress)"
                          Identifier ERC20TokenInterface
                             Type: type(contract ERC20TokenInterface)
                             Source: "ERC20TokenInterface"
                          Identifier tokenAddress
                             Type: address
                             Source: "tokenAddress"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "mintAmount = tokenTotalSupply - ERC20TokenInterface(tokenAddress).totalSupply()"
                Assignment using operator =
                   Type: uint256
                   Source: "mintAmount = tokenTotalSupply - ERC20TokenInterface(tokenAddress).totalSupply()"
                  Identifier mintAmount
                     Type: uint256
                     Source: "mintAmount"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "tokenTotalSupply - ERC20TokenInterface(tokenAddress).totalSupply()"
                    Identifier tokenTotalSupply
                       Type: uint256
                       Source: "tokenTotalSupply"
                    FunctionCall
                       Type: uint256
                       Source: "ERC20TokenInterface(tokenAddress).totalSupply()"
                      MemberAccess to member totalSupply
                         Type: function () view external returns (uint256)
                         Source: "ERC20TokenInterface(tokenAddress).totalSupply"
                        FunctionCall
                           Type: contract ERC20TokenInterface
                           Source: "ERC20TokenInterface(tokenAddress)"
                          Identifier ERC20TokenInterface
                             Type: type(contract ERC20TokenInterface)
                             Source: "ERC20TokenInterface"
                          Identifier tokenAddress
                             Type: address
                             Source: "tokenAddress"
              ExpressionStatement
                 Gas costs: 20267
                 Source: "foundersAndTeamTokensClaimed = true"
                Assignment using operator =
                   Type: bool
                   Source: "foundersAndTeamTokensClaimed = true"
                  Identifier foundersAndTeamTokensClaimed
                     Type: bool
                     Source: "foundersAndTeamTokensClaimed"
                  Literal, token: true value: true
                     Type: bool
                     Source: "true"
            Block
               Source: "{\r\n      revert();\r\n    }"
              ExpressionStatement
                 Gas costs: 6
                 Source: "revert()"
                FunctionCall
                   Type: tuple()
                   Source: "revert()"
                  Identifier revert
                     Type: function () pure
                     Source: "revert"
      ExpressionStatement
         Gas costs: [???]
         Source: "SportifyTokenInterface(tokenAddress).mint(_to, mintAmount)"
        FunctionCall
           Type: tuple()
           Source: "SportifyTokenInterface(tokenAddress).mint(_to, mintAmount)"
          MemberAccess to member mint
             Type: function (address,uint256) external
             Source: "SportifyTokenInterface(tokenAddress).mint"
            FunctionCall
               Type: contract SportifyTokenInterface
               Source: "SportifyTokenInterface(tokenAddress)"
              Identifier SportifyTokenInterface
                 Type: type(contract SportifyTokenInterface)
                 Source: "SportifyTokenInterface"
              Identifier tokenAddress
                 Type: address
                 Source: "tokenAddress"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier mintAmount
             Type: uint256
             Source: "mintAmount"
  FunctionDefinition "setMultisigAddress" - public
     Source: "function setMultisigAddress(address _newAddress) onlyOwner public {\r\n    multisigAddress = _newAddress;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _newAddress)"
      VariableDeclaration "_newAddress"
         Type: address
         Source: "address _newAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    multisigAddress = _newAddress;\r\n  }"
      ExpressionStatement
         Gas costs: 20267
         Source: "multisigAddress = _newAddress"
        Assignment using operator =
           Type: address
           Source: "multisigAddress = _newAddress"
          Identifier multisigAddress
             Type: address
             Source: "multisigAddress"
          Identifier _newAddress
             Type: address
             Source: "_newAddress"
  FunctionDefinition "setToken" - public
     Source: "function setToken(address _newAddress) onlyOwner public {\r\n    tokenAddress = _newAddress;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _newAddress)"
      VariableDeclaration "_newAddress"
         Type: address
         Source: "address _newAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    tokenAddress = _newAddress;\r\n  }"
      ExpressionStatement
         Gas costs: 20267
         Source: "tokenAddress = _newAddress"
        Assignment using operator =
           Type: address
           Source: "tokenAddress = _newAddress"
          Identifier tokenAddress
             Type: address
             Source: "tokenAddress"
          Identifier _newAddress
             Type: address
             Source: "_newAddress"
  FunctionDefinition "getTokenAddress" - public - const
     Source: "function getTokenAddress() constant public returns(address) {\r\n    return tokenAddress;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n    return tokenAddress;\r\n  }"
      Return
         Gas costs: 244
         Source: "return tokenAddress"
        Identifier tokenAddress
           Type: address
           Source: "tokenAddress"
  FunctionDefinition "investorCount" - public - const
     Source: "function investorCount() constant public returns(uint) {\r\n    return nextContributorIndex;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return nextContributorIndex;\r\n  }"
      Return
         Gas costs: 208
         Source: "return nextContributorIndex"
        Identifier nextContributorIndex
           Type: uint256
           Source: "nextContributorIndex"
ContractDefinition "SportifyCrowdsale"
   Source: "contract SportifyCrowdsale is Crowdsale {\r\n  \r\n  function SportifyCrowdsale() { \r\n\r\n    crowdsaleStartBlock = 4595138;\r\n    crowdsaleEndedBlock = 4708120;\r\n\r\n    minCap = 4190000000000000000000;\r\n    maxCap = 40629000000000000000000;\r\n\r\n    blocksInADay = 6646;\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Crowdsale"
    UserDefinedTypeName "Crowdsale"
       Source: "Crowdsale"
  FunctionDefinition "SportifyCrowdsale" - public
     Source: "function SportifyCrowdsale() { \r\n\r\n    crowdsaleStartBlock = 4595138;\r\n    crowdsaleEndedBlock = 4708120;\r\n\r\n    minCap = 4190000000000000000000;\r\n    maxCap = 40629000000000000000000;\r\n\r\n    blocksInADay = 6646;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ \r\n\r\n    crowdsaleStartBlock = 4595138;\r\n    crowdsaleEndedBlock = 4708120;\r\n\r\n    minCap = 4190000000000000000000;\r\n    maxCap = 40629000000000000000000;\r\n\r\n    blocksInADay = 6646;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "crowdsaleStartBlock = 4595138"
        Assignment using operator =
           Type: uint256
           Source: "crowdsaleStartBlock = 4595138"
          Identifier crowdsaleStartBlock
             Type: uint256
             Source: "crowdsaleStartBlock"
          Literal, token: [no token] value: 4595138
             Type: int_const 4595138
             Source: "4595138"
      ExpressionStatement
         Gas costs: 0
         Source: "crowdsaleEndedBlock = 4708120"
        Assignment using operator =
           Type: uint256
           Source: "crowdsaleEndedBlock = 4708120"
          Identifier crowdsaleEndedBlock
             Type: uint256
             Source: "crowdsaleEndedBlock"
          Literal, token: [no token] value: 4708120
             Type: int_const 4708120
             Source: "4708120"
      ExpressionStatement
         Gas costs: 0
         Source: "minCap = 4190000000000000000000"
        Assignment using operator =
           Type: uint256
           Source: "minCap = 4190000000000000000000"
          Identifier minCap
             Type: uint256
             Source: "minCap"
          Literal, token: [no token] value: 4190000000000000000000
             Type: int_const 4190000000000000000000
             Source: "4190000000000000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "maxCap = 40629000000000000000000"
        Assignment using operator =
           Type: uint256
           Source: "maxCap = 40629000000000000000000"
          Identifier maxCap
             Type: uint256
             Source: "maxCap"
          Literal, token: [no token] value: 40629000000000000000000
             Type: int_const 40629000000000000000000
             Source: "40629000000000000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "blocksInADay = 6646"
        Assignment using operator =
           Type: uint256
           Source: "blocksInADay = 6646"
          Identifier blocksInADay
             Type: uint256
             Source: "blocksInADay"
          Literal, token: [no token] value: 6646
             Type: int_const 6646
             Source: "6646"
