Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x85bc00724203d53536072b000c44a2cc16cd12c5.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.8;"
ContractDefinition "PassDao"
   Source: "contract PassDao {\r\n    \r\n    struct revision {\r\n        // Address of the Committee Room smart contract\r\n        address committeeRoom;\r\n        // Address of the share manager smart contract\r\n        address shareManager;\r\n        // Address of the token manager smart contract\r\n        address tokenManager;\r\n        // Address of the project creator smart contract\r\n        uint startDate;\r\n    }\r\n    // The revisions of the application until today\r\n    revision[] public revisions;\r\n\r\n    struct project {\r\n        // The address of the smart contract\r\n        address contractAddress;\r\n        // The unix effective start date of the contract\r\n        uint startDate;\r\n    }\r\n    // The projects of the Dao\r\n    project[] public projects;\r\n\r\n    // Map with the indexes of the projects\r\n    mapping (address => uint) projectID;\r\n    \r\n    // The address of the meta project\r\n    address metaProject;\r\n\r\n    \r\n// Events\r\n\r\n    event Upgrade(uint indexed RevisionID, address CommitteeRoom, address ShareManager, address TokenManager);\r\n    event NewProject(address Project);\r\n\r\n// Constant functions  \r\n    \r\n    /// @return The effective committee room\r\n    function ActualCommitteeRoom() constant returns (address) {\r\n        return revisions[0].committeeRoom;\r\n    }\r\n    \r\n    /// @return The meta project\r\n    function MetaProject() constant returns (address) {\r\n        return metaProject;\r\n    }\r\n\r\n    /// @return The effective share manager\r\n    function ActualShareManager() constant returns (address) {\r\n        return revisions[0].shareManager;\r\n    }\r\n\r\n    /// @return The effective token manager\r\n    function ActualTokenManager() constant returns (address) {\r\n        return revisions[0].tokenManager;\r\n    }\r\n\r\n// modifiers\r\n\r\n    modifier onlyPassCommitteeRoom {if (msg.sender != revisions[0].committeeRoom  \r\n        && revisions[0].committeeRoom != 0) throw; _;}\r\n    \r\n// Constructor function\r\n\r\n    function PassDao() {\r\n        projects.length = 1;\r\n        revisions.length = 1;\r\n    }\r\n    \r\n// Register functions\r\n\r\n    /// @dev Function to allow the actual Committee Room upgrading the application\r\n    /// @param _newCommitteeRoom The address of the new committee room\r\n    /// @param _newShareManager The address of the new share manager\r\n    /// @param _newTokenManager The address of the new token manager\r\n    /// @return The index of the revision\r\n    function upgrade(\r\n        address _newCommitteeRoom, \r\n        address _newShareManager, \r\n        address _newTokenManager) onlyPassCommitteeRoom returns (uint) {\r\n        \r\n        uint _revisionID = revisions.length++;\r\n        revision r = revisions[_revisionID];\r\n\r\n        if (_newCommitteeRoom != 0) r.committeeRoom = _newCommitteeRoom; else r.committeeRoom = revisions[0].committeeRoom;\r\n        if (_newShareManager != 0) r.shareManager = _newShareManager; else r.shareManager = revisions[0].shareManager;\r\n        if (_newTokenManager != 0) r.tokenManager = _newTokenManager; else r.tokenManager = revisions[0].tokenManager;\r\n\r\n        r.startDate = now;\r\n        \r\n        revisions[0] = r;\r\n        \r\n        Upgrade(_revisionID, _newCommitteeRoom, _newShareManager, _newTokenManager);\r\n            \r\n        return _revisionID;\r\n    }\r\n\r\n    /// @dev Function to set the meta project\r\n    /// @param _projectAddress The address of the meta project\r\n    function addMetaProject(address _projectAddress) onlyPassCommitteeRoom {\r\n\r\n        metaProject = _projectAddress;\r\n    }\r\n    \r\n    /// @dev Function to allow the committee room to add a project when ordering\r\n    /// @param _projectAddress The address of the project\r\n    function addProject(address _projectAddress) onlyPassCommitteeRoom {\r\n\r\n        if (projectID[_projectAddress] == 0) {\r\n\r\n            uint _projectID = projects.length++;\r\n            project p = projects[_projectID];\r\n        \r\n            projectID[_projectAddress] = _projectID;\r\n            p.contractAddress = _projectAddress; \r\n            p.startDate = now;\r\n            \r\n            NewProject(_projectAddress);\r\n        }\r\n    }\r\n    \r\n}"
  StructDefinition "revision"
     Gas costs: 0
     Source: "struct revision {\r\n        // Address of the Committee Room smart contract\r\n        address committeeRoom;\r\n        // Address of the share manager smart contract\r\n        address shareManager;\r\n        // Address of the token manager smart contract\r\n        address tokenManager;\r\n        // Address of the project creator smart contract\r\n        uint startDate;\r\n    }"
    VariableDeclaration "committeeRoom"
       Type: address
       Source: "address committeeRoom"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "shareManager"
       Type: address
       Source: "address shareManager"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "tokenManager"
       Type: address
       Source: "address tokenManager"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "startDate"
       Type: uint256
       Source: "uint startDate"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "revisions"
     Type: struct PassDao.revision storage ref[] storage ref
     Gas costs: 0
     Source: "revision[] public revisions"
    ArrayTypeName
       Source: "revision[]"
      UserDefinedTypeName "revision"
         Source: "revision"
  StructDefinition "project"
     Gas costs: 0
     Source: "struct project {\r\n        // The address of the smart contract\r\n        address contractAddress;\r\n        // The unix effective start date of the contract\r\n        uint startDate;\r\n    }"
    VariableDeclaration "contractAddress"
       Type: address
       Source: "address contractAddress"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "startDate"
       Type: uint256
       Source: "uint startDate"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "projects"
     Type: struct PassDao.project storage ref[] storage ref
     Gas costs: 0
     Source: "project[] public projects"
    ArrayTypeName
       Source: "project[]"
      UserDefinedTypeName "project"
         Source: "project"
  VariableDeclaration "projectID"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint) projectID"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "metaProject"
     Type: address
     Gas costs: 0
     Source: "address metaProject"
    ElementaryTypeName address
       Source: "address"
  EventDefinition "Upgrade"
     Gas costs: 0
     Source: "event Upgrade(uint indexed RevisionID, address CommitteeRoom, address ShareManager, address TokenManager);"
    ParameterList
       Source: "(uint indexed RevisionID, address CommitteeRoom, address ShareManager, address TokenManager)"
      VariableDeclaration "RevisionID"
         Type: uint256
         Source: "uint indexed RevisionID"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "CommitteeRoom"
         Type: address
         Source: "address CommitteeRoom"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "ShareManager"
         Type: address
         Source: "address ShareManager"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "TokenManager"
         Type: address
         Source: "address TokenManager"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "NewProject"
     Gas costs: 0
     Source: "event NewProject(address Project);"
    ParameterList
       Source: "(address Project)"
      VariableDeclaration "Project"
         Type: address
         Source: "address Project"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "ActualCommitteeRoom" - public - const
     Source: "function ActualCommitteeRoom() constant returns (address) {\r\n        return revisions[0].committeeRoom;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return revisions[0].committeeRoom;\r\n    }"
      Return
         Gas costs: 0
         Source: "return revisions[0].committeeRoom"
        MemberAccess to member committeeRoom
           Type: address
           Source: "revisions[0].committeeRoom"
          IndexAccess
             Type: struct PassDao.revision storage ref
             Source: "revisions[0]"
            Identifier revisions
               Type: struct PassDao.revision storage ref[] storage ref
               Source: "revisions"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "MetaProject" - public - const
     Source: "function MetaProject() constant returns (address) {\r\n        return metaProject;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return metaProject;\r\n    }"
      Return
         Gas costs: 0
         Source: "return metaProject"
        Identifier metaProject
           Type: address
           Source: "metaProject"
  FunctionDefinition "ActualShareManager" - public - const
     Source: "function ActualShareManager() constant returns (address) {\r\n        return revisions[0].shareManager;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return revisions[0].shareManager;\r\n    }"
      Return
         Gas costs: 0
         Source: "return revisions[0].shareManager"
        MemberAccess to member shareManager
           Type: address
           Source: "revisions[0].shareManager"
          IndexAccess
             Type: struct PassDao.revision storage ref
             Source: "revisions[0]"
            Identifier revisions
               Type: struct PassDao.revision storage ref[] storage ref
               Source: "revisions"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "ActualTokenManager" - public - const
     Source: "function ActualTokenManager() constant returns (address) {\r\n        return revisions[0].tokenManager;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return revisions[0].tokenManager;\r\n    }"
      Return
         Gas costs: 0
         Source: "return revisions[0].tokenManager"
        MemberAccess to member tokenManager
           Type: address
           Source: "revisions[0].tokenManager"
          IndexAccess
             Type: struct PassDao.revision storage ref
             Source: "revisions[0]"
            Identifier revisions
               Type: struct PassDao.revision storage ref[] storage ref
               Source: "revisions"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  ModifierDefinition "onlyPassCommitteeRoom"
     Source: "modifier onlyPassCommitteeRoom {if (msg.sender != revisions[0].committeeRoom  \r\n        && revisions[0].committeeRoom != 0) throw; _;}"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{if (msg.sender != revisions[0].committeeRoom  \r\n        && revisions[0].committeeRoom != 0) throw; _;}"
      IfStatement
         Source: "if (msg.sender != revisions[0].committeeRoom  \r\n        && revisions[0].committeeRoom != 0) throw"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "msg.sender != revisions[0].committeeRoom  \r\n        && revisions[0].committeeRoom != 0"
          BinaryOperation using operator !=
             Type: bool
             Source: "msg.sender != revisions[0].committeeRoom"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            MemberAccess to member committeeRoom
               Type: address
               Source: "revisions[0].committeeRoom"
              IndexAccess
                 Type: struct PassDao.revision storage ref
                 Source: "revisions[0]"
                Identifier revisions
                   Type: struct PassDao.revision storage ref[] storage ref
                   Source: "revisions"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
          BinaryOperation using operator !=
             Type: bool
             Source: "revisions[0].committeeRoom != 0"
            MemberAccess to member committeeRoom
               Type: address
               Source: "revisions[0].committeeRoom"
              IndexAccess
                 Type: struct PassDao.revision storage ref
                 Source: "revisions[0]"
                Identifier revisions
                   Type: struct PassDao.revision storage ref[] storage ref
                   Source: "revisions"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Throw
           Gas costs: 0
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "PassDao" - public
     Source: "function PassDao() {\r\n        projects.length = 1;\r\n        revisions.length = 1;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        projects.length = 1;\r\n        revisions.length = 1;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "projects.length = 1"
        Assignment using operator =
           Type: uint256
           Source: "projects.length = 1"
          MemberAccess to member length
             Type: uint256
             Source: "projects.length"
            Identifier projects
               Type: struct PassDao.project storage ref[] storage ref
               Source: "projects"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "revisions.length = 1"
        Assignment using operator =
           Type: uint256
           Source: "revisions.length = 1"
          MemberAccess to member length
             Type: uint256
             Source: "revisions.length"
            Identifier revisions
               Type: struct PassDao.revision storage ref[] storage ref
               Source: "revisions"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
  FunctionDefinition "upgrade" - public
     Source: "function upgrade(\r\n        address _newCommitteeRoom, \r\n        address _newShareManager, \r\n        address _newTokenManager) onlyPassCommitteeRoom returns (uint) {\r\n        \r\n        uint _revisionID = revisions.length++;\r\n        revision r = revisions[_revisionID];\r\n\r\n        if (_newCommitteeRoom != 0) r.committeeRoom = _newCommitteeRoom; else r.committeeRoom = revisions[0].committeeRoom;\r\n        if (_newShareManager != 0) r.shareManager = _newShareManager; else r.shareManager = revisions[0].shareManager;\r\n        if (_newTokenManager != 0) r.tokenManager = _newTokenManager; else r.tokenManager = revisions[0].tokenManager;\r\n\r\n        r.startDate = now;\r\n        \r\n        revisions[0] = r;\r\n        \r\n        Upgrade(_revisionID, _newCommitteeRoom, _newShareManager, _newTokenManager);\r\n            \r\n        return _revisionID;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _newCommitteeRoom, \r\n        address _newShareManager, \r\n        address _newTokenManager)"
      VariableDeclaration "_newCommitteeRoom"
         Type: address
         Source: "address _newCommitteeRoom"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_newShareManager"
         Type: address
         Source: "address _newShareManager"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_newTokenManager"
         Type: address
         Source: "address _newTokenManager"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "onlyPassCommitteeRoom"
       Gas costs: 0
       Source: "onlyPassCommitteeRoom"
      Identifier onlyPassCommitteeRoom
         Type: modifier ()
         Source: "onlyPassCommitteeRoom"
    Block
       Source: "{\r\n        \r\n        uint _revisionID = revisions.length++;\r\n        revision r = revisions[_revisionID];\r\n\r\n        if (_newCommitteeRoom != 0) r.committeeRoom = _newCommitteeRoom; else r.committeeRoom = revisions[0].committeeRoom;\r\n        if (_newShareManager != 0) r.shareManager = _newShareManager; else r.shareManager = revisions[0].shareManager;\r\n        if (_newTokenManager != 0) r.tokenManager = _newTokenManager; else r.tokenManager = revisions[0].tokenManager;\r\n\r\n        r.startDate = now;\r\n        \r\n        revisions[0] = r;\r\n        \r\n        Upgrade(_revisionID, _newCommitteeRoom, _newShareManager, _newTokenManager);\r\n            \r\n        return _revisionID;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint _revisionID = revisions.length++"
        VariableDeclaration "_revisionID"
           Type: uint256
           Source: "uint _revisionID"
          ElementaryTypeName uint
             Source: "uint"
        UnaryOperation (postfix) ++
           Type: uint256
           Source: "revisions.length++"
          MemberAccess to member length
             Type: uint256
             Source: "revisions.length"
            Identifier revisions
               Type: struct PassDao.revision storage ref[] storage ref
               Source: "revisions"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "revision r = revisions[_revisionID]"
        VariableDeclaration "r"
           Type: struct PassDao.revision storage pointer
           Source: "revision r"
          UserDefinedTypeName "revision"
             Source: "revision"
        IndexAccess
           Type: struct PassDao.revision storage ref
           Source: "revisions[_revisionID]"
          Identifier revisions
             Type: struct PassDao.revision storage ref[] storage ref
             Source: "revisions"
          Identifier _revisionID
             Type: uint256
             Source: "_revisionID"
      IfStatement
         Source: "if (_newCommitteeRoom != 0) r.committeeRoom = _newCommitteeRoom; else r.committeeRoom = revisions[0].committeeRoom"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "_newCommitteeRoom != 0"
          Identifier _newCommitteeRoom
             Type: address
             Source: "_newCommitteeRoom"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 0
           Source: "r.committeeRoom = _newCommitteeRoom"
          Assignment using operator =
             Type: address
             Source: "r.committeeRoom = _newCommitteeRoom"
            MemberAccess to member committeeRoom
               Type: address
               Source: "r.committeeRoom"
              Identifier r
                 Type: struct PassDao.revision storage pointer
                 Source: "r"
            Identifier _newCommitteeRoom
               Type: address
               Source: "_newCommitteeRoom"
        ExpressionStatement
           Gas costs: 0
           Source: "r.committeeRoom = revisions[0].committeeRoom"
          Assignment using operator =
             Type: address
             Source: "r.committeeRoom = revisions[0].committeeRoom"
            MemberAccess to member committeeRoom
               Type: address
               Source: "r.committeeRoom"
              Identifier r
                 Type: struct PassDao.revision storage pointer
                 Source: "r"
            MemberAccess to member committeeRoom
               Type: address
               Source: "revisions[0].committeeRoom"
              IndexAccess
                 Type: struct PassDao.revision storage ref
                 Source: "revisions[0]"
                Identifier revisions
                   Type: struct PassDao.revision storage ref[] storage ref
                   Source: "revisions"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
      IfStatement
         Source: "if (_newShareManager != 0) r.shareManager = _newShareManager; else r.shareManager = revisions[0].shareManager"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "_newShareManager != 0"
          Identifier _newShareManager
             Type: address
             Source: "_newShareManager"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 0
           Source: "r.shareManager = _newShareManager"
          Assignment using operator =
             Type: address
             Source: "r.shareManager = _newShareManager"
            MemberAccess to member shareManager
               Type: address
               Source: "r.shareManager"
              Identifier r
                 Type: struct PassDao.revision storage pointer
                 Source: "r"
            Identifier _newShareManager
               Type: address
               Source: "_newShareManager"
        ExpressionStatement
           Gas costs: 0
           Source: "r.shareManager = revisions[0].shareManager"
          Assignment using operator =
             Type: address
             Source: "r.shareManager = revisions[0].shareManager"
            MemberAccess to member shareManager
               Type: address
               Source: "r.shareManager"
              Identifier r
                 Type: struct PassDao.revision storage pointer
                 Source: "r"
            MemberAccess to member shareManager
               Type: address
               Source: "revisions[0].shareManager"
              IndexAccess
                 Type: struct PassDao.revision storage ref
                 Source: "revisions[0]"
                Identifier revisions
                   Type: struct PassDao.revision storage ref[] storage ref
                   Source: "revisions"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
      IfStatement
         Source: "if (_newTokenManager != 0) r.tokenManager = _newTokenManager; else r.tokenManager = revisions[0].tokenManager"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "_newTokenManager != 0"
          Identifier _newTokenManager
             Type: address
             Source: "_newTokenManager"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 0
           Source: "r.tokenManager = _newTokenManager"
          Assignment using operator =
             Type: address
             Source: "r.tokenManager = _newTokenManager"
            MemberAccess to member tokenManager
               Type: address
               Source: "r.tokenManager"
              Identifier r
                 Type: struct PassDao.revision storage pointer
                 Source: "r"
            Identifier _newTokenManager
               Type: address
               Source: "_newTokenManager"
        ExpressionStatement
           Gas costs: 0
           Source: "r.tokenManager = revisions[0].tokenManager"
          Assignment using operator =
             Type: address
             Source: "r.tokenManager = revisions[0].tokenManager"
            MemberAccess to member tokenManager
               Type: address
               Source: "r.tokenManager"
              Identifier r
                 Type: struct PassDao.revision storage pointer
                 Source: "r"
            MemberAccess to member tokenManager
               Type: address
               Source: "revisions[0].tokenManager"
              IndexAccess
                 Type: struct PassDao.revision storage ref
                 Source: "revisions[0]"
                Identifier revisions
                   Type: struct PassDao.revision storage ref[] storage ref
                   Source: "revisions"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "r.startDate = now"
        Assignment using operator =
           Type: uint256
           Source: "r.startDate = now"
          MemberAccess to member startDate
             Type: uint256
             Source: "r.startDate"
            Identifier r
               Type: struct PassDao.revision storage pointer
               Source: "r"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 0
         Source: "revisions[0] = r"
        Assignment using operator =
           Type: struct PassDao.revision storage ref
           Source: "revisions[0] = r"
          IndexAccess
             Type: struct PassDao.revision storage ref
             Source: "revisions[0]"
            Identifier revisions
               Type: struct PassDao.revision storage ref[] storage ref
               Source: "revisions"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Identifier r
             Type: struct PassDao.revision storage pointer
             Source: "r"
      ExpressionStatement
         Gas costs: 0
         Source: "Upgrade(_revisionID, _newCommitteeRoom, _newShareManager, _newTokenManager)"
        FunctionCall
           Type: tuple()
           Source: "Upgrade(_revisionID, _newCommitteeRoom, _newShareManager, _newTokenManager)"
          Identifier Upgrade
             Type: function (uint256,address,address,address)
             Source: "Upgrade"
          Identifier _revisionID
             Type: uint256
             Source: "_revisionID"
          Identifier _newCommitteeRoom
             Type: address
             Source: "_newCommitteeRoom"
          Identifier _newShareManager
             Type: address
             Source: "_newShareManager"
          Identifier _newTokenManager
             Type: address
             Source: "_newTokenManager"
      Return
         Gas costs: 0
         Source: "return _revisionID"
        Identifier _revisionID
           Type: uint256
           Source: "_revisionID"
  FunctionDefinition "addMetaProject" - public
     Source: "function addMetaProject(address _projectAddress) onlyPassCommitteeRoom {\r\n\r\n        metaProject = _projectAddress;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _projectAddress)"
      VariableDeclaration "_projectAddress"
         Type: address
         Source: "address _projectAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyPassCommitteeRoom"
       Gas costs: 0
       Source: "onlyPassCommitteeRoom"
      Identifier onlyPassCommitteeRoom
         Type: modifier ()
         Source: "onlyPassCommitteeRoom"
    Block
       Source: "{\r\n\r\n        metaProject = _projectAddress;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "metaProject = _projectAddress"
        Assignment using operator =
           Type: address
           Source: "metaProject = _projectAddress"
          Identifier metaProject
             Type: address
             Source: "metaProject"
          Identifier _projectAddress
             Type: address
             Source: "_projectAddress"
  FunctionDefinition "addProject" - public
     Source: "function addProject(address _projectAddress) onlyPassCommitteeRoom {\r\n\r\n        if (projectID[_projectAddress] == 0) {\r\n\r\n            uint _projectID = projects.length++;\r\n            project p = projects[_projectID];\r\n        \r\n            projectID[_projectAddress] = _projectID;\r\n            p.contractAddress = _projectAddress; \r\n            p.startDate = now;\r\n            \r\n            NewProject(_projectAddress);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _projectAddress)"
      VariableDeclaration "_projectAddress"
         Type: address
         Source: "address _projectAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyPassCommitteeRoom"
       Gas costs: 0
       Source: "onlyPassCommitteeRoom"
      Identifier onlyPassCommitteeRoom
         Type: modifier ()
         Source: "onlyPassCommitteeRoom"
    Block
       Source: "{\r\n\r\n        if (projectID[_projectAddress] == 0) {\r\n\r\n            uint _projectID = projects.length++;\r\n            project p = projects[_projectID];\r\n        \r\n            projectID[_projectAddress] = _projectID;\r\n            p.contractAddress = _projectAddress; \r\n            p.startDate = now;\r\n            \r\n            NewProject(_projectAddress);\r\n        }\r\n    }"
      IfStatement
         Source: "if (projectID[_projectAddress] == 0) {\r\n\r\n            uint _projectID = projects.length++;\r\n            project p = projects[_projectID];\r\n        \r\n            projectID[_projectAddress] = _projectID;\r\n            p.contractAddress = _projectAddress; \r\n            p.startDate = now;\r\n            \r\n            NewProject(_projectAddress);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "projectID[_projectAddress] == 0"
          IndexAccess
             Type: uint256
             Source: "projectID[_projectAddress]"
            Identifier projectID
               Type: mapping(address => uint256)
               Source: "projectID"
            Identifier _projectAddress
               Type: address
               Source: "_projectAddress"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n\r\n            uint _projectID = projects.length++;\r\n            project p = projects[_projectID];\r\n        \r\n            projectID[_projectAddress] = _projectID;\r\n            p.contractAddress = _projectAddress; \r\n            p.startDate = now;\r\n            \r\n            NewProject(_projectAddress);\r\n        }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "uint _projectID = projects.length++"
            VariableDeclaration "_projectID"
               Type: uint256
               Source: "uint _projectID"
              ElementaryTypeName uint
                 Source: "uint"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "projects.length++"
              MemberAccess to member length
                 Type: uint256
                 Source: "projects.length"
                Identifier projects
                   Type: struct PassDao.project storage ref[] storage ref
                   Source: "projects"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "project p = projects[_projectID]"
            VariableDeclaration "p"
               Type: struct PassDao.project storage pointer
               Source: "project p"
              UserDefinedTypeName "project"
                 Source: "project"
            IndexAccess
               Type: struct PassDao.project storage ref
               Source: "projects[_projectID]"
              Identifier projects
                 Type: struct PassDao.project storage ref[] storage ref
                 Source: "projects"
              Identifier _projectID
                 Type: uint256
                 Source: "_projectID"
          ExpressionStatement
             Gas costs: 0
             Source: "projectID[_projectAddress] = _projectID"
            Assignment using operator =
               Type: uint256
               Source: "projectID[_projectAddress] = _projectID"
              IndexAccess
                 Type: uint256
                 Source: "projectID[_projectAddress]"
                Identifier projectID
                   Type: mapping(address => uint256)
                   Source: "projectID"
                Identifier _projectAddress
                   Type: address
                   Source: "_projectAddress"
              Identifier _projectID
                 Type: uint256
                 Source: "_projectID"
          ExpressionStatement
             Gas costs: 0
             Source: "p.contractAddress = _projectAddress"
            Assignment using operator =
               Type: address
               Source: "p.contractAddress = _projectAddress"
              MemberAccess to member contractAddress
                 Type: address
                 Source: "p.contractAddress"
                Identifier p
                   Type: struct PassDao.project storage pointer
                   Source: "p"
              Identifier _projectAddress
                 Type: address
                 Source: "_projectAddress"
          ExpressionStatement
             Gas costs: 0
             Source: "p.startDate = now"
            Assignment using operator =
               Type: uint256
               Source: "p.startDate = now"
              MemberAccess to member startDate
                 Type: uint256
                 Source: "p.startDate"
                Identifier p
                   Type: struct PassDao.project storage pointer
                   Source: "p"
              Identifier now
                 Type: uint256
                 Source: "now"
          ExpressionStatement
             Gas costs: 0
             Source: "NewProject(_projectAddress)"
            FunctionCall
               Type: tuple()
               Source: "NewProject(_projectAddress)"
              Identifier NewProject
                 Type: function (address)
                 Source: "NewProject"
              Identifier _projectAddress
                 Type: address
                 Source: "_projectAddress"
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.8;"
ContractDefinition "PassTokenManagerInterface"
   Gas costs: [???]
   Source: "contract PassTokenManagerInterface {\r\n\r\n    // The Pass Dao smart contract\r\n    PassDao public passDao;\r\n    // The adress of the creator of this smart contract\r\n    address creator;\r\n    \r\n    // The token name for display purpose\r\n    string public name;\r\n    // The token symbol for display purpose\r\n    string public symbol;\r\n    // The quantity of decimals for display purpose\r\n    uint8 public decimals;\r\n    // Total amount of tokens\r\n    uint256 totalTokenSupply;\r\n\r\n    // True if tokens, false if Dao shares\r\n    bool token;\r\n    // If true, the shares or tokens can be transferred\r\n    bool transferable;\r\n\r\n    // The address of the last Manager before cloning\r\n    address public clonedFrom;\r\n    // True if the initial token supply is over\r\n    bool initialTokenSupplyDone;\r\n\r\n    // Array of token or share holders (used for cloning)\r\n    address[] holders;\r\n    // Map with the indexes of the holders (used for cloning)\r\n    mapping (address => uint) holderID;\r\n    \r\n    // Array with all balances\r\n    mapping (address => uint256) balances;\r\n    // Array with all allowances\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    struct funding {\r\n        // The address which sets partners and manages the funding (not mandatory)\r\n        address moderator;\r\n        // The amount (in wei) of the funding\r\n        uint amountToFund;\r\n        // The funded amount (in wei)\r\n        uint fundedAmount;\r\n        // A unix timestamp, denoting the start time of the funding\r\n        uint startTime; \r\n        // A unix timestamp, denoting the closing time of the funding\r\n        uint closingTime;  \r\n        // The price multiplier for a share or a token without considering the inflation rate\r\n        uint initialPriceMultiplier;\r\n        // Rate per year in percentage applied to the share or token price \r\n        uint inflationRate; \r\n        // The total amount of wei given\r\n        uint totalWeiGiven;\r\n    } \r\n    // Map with the fundings rules for each Dao proposal\r\n    mapping (uint => funding) public fundings;\r\n\r\n    // The index of the last funding and proposal\r\n    uint lastProposalID;\r\n    // The index of the last fueled funding and proposal\r\n    uint public lastFueledFundingID;\r\n    \r\n    struct amountsGiven {\r\n        uint weiAmount;\r\n        uint tokenAmount;\r\n    }\r\n    // Map with the amounts given for each proposal \r\n    mapping (uint => mapping (address => amountsGiven)) public Given;\r\n    \r\n    // Map of blocked Dao share accounts. Points to the date when the share holder can transfer shares\r\n    mapping (address => uint) public blockedDeadLine; \r\n\r\n    // @return The client of this manager\r\n    function Client() constant returns (address);\r\n    \r\n    /// @return The total supply of shares or tokens \r\n    function totalSupply() constant external returns (uint256);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n     function balanceOf(address _owner) constant external returns (uint256 balance);\r\n\r\n    /// @return True if tokens can be transferred\r\n    function Transferable() constant external returns (bool);\r\n    \r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Quantity of remaining tokens of _owner that _spender is allowed to spend\r\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\r\n    \r\n    /// @param _proposalID Index of the funding or proposal\r\n    /// @return The result (in wei) of the funding\r\n    function FundedAmount(uint _proposalID) constant external returns (uint);\r\n\r\n    /// @param _proposalID Index of the funding or proposal\r\n    /// @return The amount to fund\r\n    function AmountToFund(uint _proposalID) constant external returns (uint);\r\n    \r\n    /// @param _proposalID Index of the funding or proposal\r\n    /// @return the token price multiplier\r\n    function priceMultiplier(uint _proposalID) constant internal returns (uint);\r\n    \r\n    /// @param _proposalID Index of the funding or proposal\r\n    /// @param _saleDate in case of presale, the date of the presale\r\n    /// @return the share or token price divisor condidering the sale date and the inflation rate\r\n    function priceDivisor(\r\n        uint _proposalID, \r\n        uint _saleDate) constant internal returns (uint);\r\n    \r\n    /// @param _proposalID Index of the funding or proposal\r\n    /// @return the actual price divisor of a share or token\r\n    function actualPriceDivisor(uint _proposalID) constant internal returns (uint);\r\n\r\n    /// @dev Internal function to calculate the amount in tokens according to a price    \r\n    /// @param _weiAmount The amount (in wei)\r\n    /// @param _priceMultiplier The price multiplier\r\n    /// @param _priceDivisor The price divisor\r\n    /// @return the amount in tokens \r\n    function TokenAmount(\r\n        uint _weiAmount,\r\n        uint _priceMultiplier, \r\n        uint _priceDivisor) constant internal returns (uint);\r\n\r\n    /// @dev Internal function to calculate the amount in wei according to a price    \r\n    /// @param _tokenAmount The amount (in wei)\r\n    /// @param _priceMultiplier The price multiplier\r\n    /// @param _priceDivisor The price divisor\r\n    /// @return the amount in wei\r\n    function weiAmount(\r\n        uint _tokenAmount, \r\n        uint _priceMultiplier, \r\n        uint _priceDivisor) constant internal returns (uint);\r\n        \r\n    /// @param _tokenAmount The amount in tokens\r\n    /// @param _proposalID Index of the client proposal. 0 if not linked to a proposal.\r\n    /// @return the actual token price in wei\r\n    function TokenPriceInWei(uint _tokenAmount, uint _proposalID) constant returns (uint);\r\n    \r\n    /// @return The index of the last funding and client's proposal \r\n    function LastProposalID() constant returns (uint);\r\n\r\n    /// @return The number of share or token holders (used for cloning)\r\n    function numberOfHolders() constant returns (uint);\r\n\r\n    /// @param _index The index of the holder\r\n    /// @return the address of the holder\r\n    function HolderAddress(uint _index) constant external returns (address);\r\n   \r\n    /// @dev The constructor function\r\n    /// @param _passDao Address of the pass Dao smart contract\r\n    /// @param _clonedFrom The address of the last Manager before cloning\r\n    /// @param _tokenName The token name for display purpose\r\n    /// @param _tokenSymbol The token symbol for display purpose\r\n    /// @param _tokenDecimals The quantity of decimals for display purpose\r\n    /// @param  _token True if tokens, false if shares\r\n    /// @param  _transferable True if tokens can be transferred\r\n    /// @param _initialPriceMultiplier Price multiplier without considering any inflation rate\r\n    /// @param _inflationRate If 0, the token price doesn't change during the funding\r\n    //function PassTokenManager(\r\n    //    address _passDao,\r\n    //    address _clonedFrom,\r\n    //    string _tokenName,\r\n    //    string _tokenSymbol,\r\n    //    uint8 _tokenDecimals,\r\n    //    bool _token,\r\n    //    bool _transferable,\r\n    //    uint _initialPriceMultiplier,\r\n    //    uint _inflationRate);\r\n    \r\n    /// @dev Function to create initial tokens    \r\n    /// @param _recipient The beneficiary of the created tokens\r\n    /// @param _quantity The quantity of tokens to create    \r\n    /// @param _last True if the initial token suppy is over\r\n    /// @return Whether the function was successful or not     \r\n    function initialTokenSupply(\r\n        address _recipient, \r\n        uint _quantity,\r\n        bool _last) returns (bool success);\r\n        \r\n    /// @notice Function to clone tokens before upgrading\r\n    /// @param _from The index of the first holder\r\n    /// @param _to The index of the last holder\r\n    /// @return Whether the function was successful or not \r\n    function cloneTokens(\r\n        uint _from,\r\n        uint _to) returns (bool success);\r\n\r\n    /// @dev Internal function to add a new token or share holder\r\n    /// @param _holder The address of the token or share holder\r\n    function addHolder(address _holder) internal;\r\n    \r\n    /// @dev Internal function to create initial tokens    \r\n    /// @param _holder The beneficiary of the created tokens\r\n    /// @param _tokenAmount The amount in tokens to create\r\n    function createTokens(\r\n        address _holder, \r\n        uint _tokenAmount) internal;\r\n        \r\n    /// @notice Function used by the client to pay with shares or tokens\r\n    /// @param _recipient The address of the recipient of shares or tokens\r\n    /// @param _amount The amount (in Wei) to calculate the quantity of shares or tokens to create\r\n    /// @return the rewarded amount in tokens or shares\r\n    function rewardTokensForClient(\r\n        address _recipient, \r\n        uint _amount) external  returns (uint);\r\n        \r\n    /// @notice Function to set a funding\r\n    /// @param _moderator The address of the smart contract to manage a private funding\r\n    /// @param _initialPriceMultiplier Price multiplier without considering any inflation rate\r\n    /// @param _amountToFund The amount (in wei) of the funding\r\n    /// @param _minutesFundingPeriod Period in minutes of the funding\r\n    /// @param _inflationRate If 0, the token price doesn't change during the funding\r\n    /// @param _proposalID Index of the client proposal\r\n    function setFundingRules(\r\n        address _moderator,\r\n        uint _initialPriceMultiplier,\r\n        uint _amountToFund,\r\n        uint _minutesFundingPeriod, \r\n        uint _inflationRate,\r\n        uint _proposalID) external;\r\n\r\n    /// @dev Internal function for the sale of shares or tokens\r\n    /// @param _proposalID Index of the client proposal\r\n    /// @param _recipient The recipient address of shares or tokens\r\n    /// @param _amount The funded amount (in wei)\r\n    /// @param _saleDate In case of presale, the date of the presale\r\n    /// @param _presale True if presale\r\n    /// @return Whether the creation was successful or not\r\n    function sale(\r\n        uint _proposalID,\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _saleDate,\r\n        bool _presale\r\n    ) internal returns (bool success);\r\n    \r\n    /// @dev Internal function to close the actual funding\r\n    /// @param _proposalID Index of the client proposal\r\n    function closeFunding(uint _proposalID) internal;\r\n   \r\n    /// @notice Function to send tokens or refund after the closing time of the funding proposals\r\n    /// @param _from The first proposal. 0 if not linked to a proposal\r\n    /// @param _to The last proposal\r\n    /// @param _buyer The address of the buyer\r\n    /// @return Whether the function was successful or not \r\n    function sendPendingAmounts(        \r\n        uint _from,\r\n        uint _to,\r\n        address _buyer) returns (bool);\r\n        \r\n    /// @notice Function to get fees, shares or refund after the closing time of the funding proposals\r\n    /// @return Whether the function was successful or not\r\n    function withdrawPendingAmounts() returns (bool);\r\n    \r\n    /// @notice Function used by the main partner to set the start time of the funding\r\n    /// @param _proposalID Index of the client proposal\r\n    /// @param _startTime The unix start date of the funding \r\n    function setFundingStartTime(\r\n        uint _proposalID, \r\n        uint _startTime) external;\r\n    \r\n    /// @notice Function used by the main partner to set the funding fueled\r\n    /// @param _proposalID Index of the client proposal\r\n    function setFundingFueled(uint _proposalID) external;\r\n\r\n    /// @notice Function to able the transfer of Dao shares or contractor tokens\r\n    function ableTransfer();\r\n\r\n    /// @notice Function to disable the transfer of Dao shares\r\n    function disableTransfer();\r\n\r\n    /// @notice Function used by the client to block the transfer of shares from and to a share holder\r\n    /// @param _shareHolder The address of the share holder\r\n    /// @param _deadLine When the account will be unblocked\r\n    function blockTransfer(\r\n        address _shareHolder, \r\n        uint _deadLine) external;\r\n    \r\n    /// @dev Internal function to send `_value` token to `_to` from `_From`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The quantity of shares or tokens to be transferred\r\n    /// @return Whether the function was successful or not \r\n    function transferFromTo(\r\n        address _from,\r\n        address _to, \r\n        uint256 _value\r\n        ) internal returns (bool success);\r\n    \r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The quantity of shares or tokens to be transferred\r\n    /// @return Whether the function was successful or not \r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The quantity of shares or tokens to be transferred\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n        ) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(\r\n        address _spender, \r\n        uint256 _value) returns (bool success);\r\n    \r\n    event TokensCreated(address indexed Sender, address indexed TokenHolder, uint TokenAmount);\r\n    event FundingRulesSet(address indexed Moderator, uint indexed ProposalId, uint AmountToFund, uint indexed StartTime, uint ClosingTime);\r\n    event FundingFueled(uint indexed ProposalID, uint FundedAmount);\r\n    event TransferAble();\r\n    event TransferDisable();\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Refund(address indexed Buyer, uint Amount);\r\n    \r\n}"
  VariableDeclaration "passDao"
     Type: contract PassDao
     Source: "PassDao public passDao"
    UserDefinedTypeName "PassDao"
       Source: "PassDao"
  VariableDeclaration "creator"
     Type: address
     Source: "address creator"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "name"
     Type: string storage ref
     Source: "string public name"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "symbol"
     Type: string storage ref
     Source: "string public symbol"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "decimals"
     Type: uint8
     Source: "uint8 public decimals"
    ElementaryTypeName uint8
       Source: "uint8"
  VariableDeclaration "totalTokenSupply"
     Type: uint256
     Source: "uint256 totalTokenSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "token"
     Type: bool
     Source: "bool token"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "transferable"
     Type: bool
     Source: "bool transferable"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "clonedFrom"
     Type: address
     Source: "address public clonedFrom"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "initialTokenSupplyDone"
     Type: bool
     Source: "bool initialTokenSupplyDone"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "holders"
     Type: address[] storage ref
     Source: "address[] holders"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "holderID"
     Type: mapping(address => uint256)
     Source: "mapping (address => uint) holderID"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Source: "mapping (address => uint256) balances"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  StructDefinition "funding"
     Source: "struct funding {\r\n        // The address which sets partners and manages the funding (not mandatory)\r\n        address moderator;\r\n        // The amount (in wei) of the funding\r\n        uint amountToFund;\r\n        // The funded amount (in wei)\r\n        uint fundedAmount;\r\n        // A unix timestamp, denoting the start time of the funding\r\n        uint startTime; \r\n        // A unix timestamp, denoting the closing time of the funding\r\n        uint closingTime;  \r\n        // The price multiplier for a share or a token without considering the inflation rate\r\n        uint initialPriceMultiplier;\r\n        // Rate per year in percentage applied to the share or token price \r\n        uint inflationRate; \r\n        // The total amount of wei given\r\n        uint totalWeiGiven;\r\n    }"
    VariableDeclaration "moderator"
       Type: address
       Source: "address moderator"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "amountToFund"
       Type: uint256
       Source: "uint amountToFund"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "fundedAmount"
       Type: uint256
       Source: "uint fundedAmount"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "startTime"
       Type: uint256
       Source: "uint startTime"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "closingTime"
       Type: uint256
       Source: "uint closingTime"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "initialPriceMultiplier"
       Type: uint256
       Source: "uint initialPriceMultiplier"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "inflationRate"
       Type: uint256
       Source: "uint inflationRate"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "totalWeiGiven"
       Type: uint256
       Source: "uint totalWeiGiven"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "fundings"
     Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
     Source: "mapping (uint => funding) public fundings"
    Mapping
       Source: "mapping (uint => funding)"
      ElementaryTypeName uint
         Source: "uint"
      UserDefinedTypeName "funding"
         Source: "funding"
  VariableDeclaration "lastProposalID"
     Type: uint256
     Source: "uint lastProposalID"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "lastFueledFundingID"
     Type: uint256
     Source: "uint public lastFueledFundingID"
    ElementaryTypeName uint
       Source: "uint"
  StructDefinition "amountsGiven"
     Source: "struct amountsGiven {\r\n        uint weiAmount;\r\n        uint tokenAmount;\r\n    }"
    VariableDeclaration "weiAmount"
       Type: uint256
       Source: "uint weiAmount"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "tokenAmount"
       Type: uint256
       Source: "uint tokenAmount"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "Given"
     Type: mapping(uint256 => mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref))
     Source: "mapping (uint => mapping (address => amountsGiven)) public Given"
    Mapping
       Source: "mapping (uint => mapping (address => amountsGiven))"
      ElementaryTypeName uint
         Source: "uint"
      Mapping
         Source: "mapping (address => amountsGiven)"
        ElementaryTypeName address
           Source: "address"
        UserDefinedTypeName "amountsGiven"
           Source: "amountsGiven"
  VariableDeclaration "blockedDeadLine"
     Type: mapping(address => uint256)
     Source: "mapping (address => uint) public blockedDeadLine"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  FunctionDefinition "Client" - public - const
     Source: "function Client() constant returns (address);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() constant external returns (uint256);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant external returns (uint256 balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "Transferable" - public - const
     Source: "function Transferable() constant external returns (bool);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant external returns (uint256 remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "FundedAmount" - public - const
     Source: "function FundedAmount(uint _proposalID) constant external returns (uint);"
    ParameterList
       Source: "(uint _proposalID)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "AmountToFund" - public - const
     Source: "function AmountToFund(uint _proposalID) constant external returns (uint);"
    ParameterList
       Source: "(uint _proposalID)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "priceMultiplier" - const
     Source: "function priceMultiplier(uint _proposalID) constant internal returns (uint);"
    ParameterList
       Source: "(uint _proposalID)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "priceDivisor" - const
     Source: "function priceDivisor(\r\n        uint _proposalID, \r\n        uint _saleDate) constant internal returns (uint);"
    ParameterList
       Source: "(\r\n        uint _proposalID, \r\n        uint _saleDate)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_saleDate"
         Type: uint256
         Source: "uint _saleDate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "actualPriceDivisor" - const
     Source: "function actualPriceDivisor(uint _proposalID) constant internal returns (uint);"
    ParameterList
       Source: "(uint _proposalID)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "TokenAmount" - const
     Source: "function TokenAmount(\r\n        uint _weiAmount,\r\n        uint _priceMultiplier, \r\n        uint _priceDivisor) constant internal returns (uint);"
    ParameterList
       Source: "(\r\n        uint _weiAmount,\r\n        uint _priceMultiplier, \r\n        uint _priceDivisor)"
      VariableDeclaration "_weiAmount"
         Type: uint256
         Source: "uint _weiAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_priceMultiplier"
         Type: uint256
         Source: "uint _priceMultiplier"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_priceDivisor"
         Type: uint256
         Source: "uint _priceDivisor"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "weiAmount" - const
     Source: "function weiAmount(\r\n        uint _tokenAmount, \r\n        uint _priceMultiplier, \r\n        uint _priceDivisor) constant internal returns (uint);"
    ParameterList
       Source: "(\r\n        uint _tokenAmount, \r\n        uint _priceMultiplier, \r\n        uint _priceDivisor)"
      VariableDeclaration "_tokenAmount"
         Type: uint256
         Source: "uint _tokenAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_priceMultiplier"
         Type: uint256
         Source: "uint _priceMultiplier"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_priceDivisor"
         Type: uint256
         Source: "uint _priceDivisor"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "TokenPriceInWei" - public - const
     Source: "function TokenPriceInWei(uint _tokenAmount, uint _proposalID) constant returns (uint);"
    ParameterList
       Source: "(uint _tokenAmount, uint _proposalID)"
      VariableDeclaration "_tokenAmount"
         Type: uint256
         Source: "uint _tokenAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "LastProposalID" - public - const
     Source: "function LastProposalID() constant returns (uint);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "numberOfHolders" - public - const
     Source: "function numberOfHolders() constant returns (uint);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "HolderAddress" - public - const
     Source: "function HolderAddress(uint _index) constant external returns (address);"
    ParameterList
       Source: "(uint _index)"
      VariableDeclaration "_index"
         Type: uint256
         Source: "uint _index"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "initialTokenSupply" - public
     Source: "function initialTokenSupply(\r\n        address _recipient, \r\n        uint _quantity,\r\n        bool _last) returns (bool success);"
    ParameterList
       Source: "(\r\n        address _recipient, \r\n        uint _quantity,\r\n        bool _last)"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_quantity"
         Type: uint256
         Source: "uint _quantity"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_last"
         Type: bool
         Source: "bool _last"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "cloneTokens" - public
     Source: "function cloneTokens(\r\n        uint _from,\r\n        uint _to) returns (bool success);"
    ParameterList
       Source: "(\r\n        uint _from,\r\n        uint _to)"
      VariableDeclaration "_from"
         Type: uint256
         Source: "uint _from"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_to"
         Type: uint256
         Source: "uint _to"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "addHolder"
     Source: "function addHolder(address _holder) internal;"
    ParameterList
       Source: "(address _holder)"
      VariableDeclaration "_holder"
         Type: address
         Source: "address _holder"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: ""
  FunctionDefinition "createTokens"
     Source: "function createTokens(\r\n        address _holder, \r\n        uint _tokenAmount) internal;"
    ParameterList
       Source: "(\r\n        address _holder, \r\n        uint _tokenAmount)"
      VariableDeclaration "_holder"
         Type: address
         Source: "address _holder"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokenAmount"
         Type: uint256
         Source: "uint _tokenAmount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  FunctionDefinition "rewardTokensForClient" - public
     Source: "function rewardTokensForClient(\r\n        address _recipient, \r\n        uint _amount) external  returns (uint);"
    ParameterList
       Source: "(\r\n        address _recipient, \r\n        uint _amount)"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "setFundingRules" - public
     Source: "function setFundingRules(\r\n        address _moderator,\r\n        uint _initialPriceMultiplier,\r\n        uint _amountToFund,\r\n        uint _minutesFundingPeriod, \r\n        uint _inflationRate,\r\n        uint _proposalID) external;"
    ParameterList
       Source: "(\r\n        address _moderator,\r\n        uint _initialPriceMultiplier,\r\n        uint _amountToFund,\r\n        uint _minutesFundingPeriod, \r\n        uint _inflationRate,\r\n        uint _proposalID)"
      VariableDeclaration "_moderator"
         Type: address
         Source: "address _moderator"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_initialPriceMultiplier"
         Type: uint256
         Source: "uint _initialPriceMultiplier"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_amountToFund"
         Type: uint256
         Source: "uint _amountToFund"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_minutesFundingPeriod"
         Type: uint256
         Source: "uint _minutesFundingPeriod"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_inflationRate"
         Type: uint256
         Source: "uint _inflationRate"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  FunctionDefinition "sale"
     Source: "function sale(\r\n        uint _proposalID,\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _saleDate,\r\n        bool _presale\r\n    ) internal returns (bool success);"
    ParameterList
       Source: "(\r\n        uint _proposalID,\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _saleDate,\r\n        bool _presale\r\n    )"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_saleDate"
         Type: uint256
         Source: "uint _saleDate"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_presale"
         Type: bool
         Source: "bool _presale"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "closeFunding"
     Source: "function closeFunding(uint _proposalID) internal;"
    ParameterList
       Source: "(uint _proposalID)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  FunctionDefinition "sendPendingAmounts" - public
     Source: "function sendPendingAmounts(        \r\n        uint _from,\r\n        uint _to,\r\n        address _buyer) returns (bool);"
    ParameterList
       Source: "(        \r\n        uint _from,\r\n        uint _to,\r\n        address _buyer)"
      VariableDeclaration "_from"
         Type: uint256
         Source: "uint _from"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_to"
         Type: uint256
         Source: "uint _to"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_buyer"
         Type: address
         Source: "address _buyer"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "withdrawPendingAmounts" - public
     Source: "function withdrawPendingAmounts() returns (bool);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "setFundingStartTime" - public
     Source: "function setFundingStartTime(\r\n        uint _proposalID, \r\n        uint _startTime) external;"
    ParameterList
       Source: "(\r\n        uint _proposalID, \r\n        uint _startTime)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_startTime"
         Type: uint256
         Source: "uint _startTime"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  FunctionDefinition "setFundingFueled" - public
     Source: "function setFundingFueled(uint _proposalID) external;"
    ParameterList
       Source: "(uint _proposalID)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  FunctionDefinition "ableTransfer" - public
     Source: "function ableTransfer();"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
  FunctionDefinition "disableTransfer" - public
     Source: "function disableTransfer();"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
  FunctionDefinition "blockTransfer" - public
     Source: "function blockTransfer(\r\n        address _shareHolder, \r\n        uint _deadLine) external;"
    ParameterList
       Source: "(\r\n        address _shareHolder, \r\n        uint _deadLine)"
      VariableDeclaration "_shareHolder"
         Type: address
         Source: "address _shareHolder"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_deadLine"
         Type: uint256
         Source: "uint _deadLine"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  FunctionDefinition "transferFromTo"
     Source: "function transferFromTo(\r\n        address _from,\r\n        address _to, \r\n        uint256 _value\r\n        ) internal returns (bool success);"
    ParameterList
       Source: "(\r\n        address _from,\r\n        address _to, \r\n        uint256 _value\r\n        )"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n        ) returns (bool success);"
    ParameterList
       Source: "(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n        )"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(\r\n        address _spender, \r\n        uint256 _value) returns (bool success);"
    ParameterList
       Source: "(\r\n        address _spender, \r\n        uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "TokensCreated"
     Source: "event TokensCreated(address indexed Sender, address indexed TokenHolder, uint TokenAmount);"
    ParameterList
       Source: "(address indexed Sender, address indexed TokenHolder, uint TokenAmount)"
      VariableDeclaration "Sender"
         Type: address
         Source: "address indexed Sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "TokenHolder"
         Type: address
         Source: "address indexed TokenHolder"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "TokenAmount"
         Type: uint256
         Source: "uint TokenAmount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "FundingRulesSet"
     Source: "event FundingRulesSet(address indexed Moderator, uint indexed ProposalId, uint AmountToFund, uint indexed StartTime, uint ClosingTime);"
    ParameterList
       Source: "(address indexed Moderator, uint indexed ProposalId, uint AmountToFund, uint indexed StartTime, uint ClosingTime)"
      VariableDeclaration "Moderator"
         Type: address
         Source: "address indexed Moderator"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "ProposalId"
         Type: uint256
         Source: "uint indexed ProposalId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "AmountToFund"
         Type: uint256
         Source: "uint AmountToFund"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "StartTime"
         Type: uint256
         Source: "uint indexed StartTime"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "ClosingTime"
         Type: uint256
         Source: "uint ClosingTime"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "FundingFueled"
     Source: "event FundingFueled(uint indexed ProposalID, uint FundedAmount);"
    ParameterList
       Source: "(uint indexed ProposalID, uint FundedAmount)"
      VariableDeclaration "ProposalID"
         Type: uint256
         Source: "uint indexed ProposalID"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "FundedAmount"
         Type: uint256
         Source: "uint FundedAmount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "TransferAble"
     Source: "event TransferAble();"
    ParameterList
       Source: "()"
  EventDefinition "TransferDisable"
     Source: "event TransferDisable();"
    ParameterList
       Source: "()"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Refund"
     Source: "event Refund(address indexed Buyer, uint Amount);"
    ParameterList
       Source: "(address indexed Buyer, uint Amount)"
      VariableDeclaration "Buyer"
         Type: address
         Source: "address indexed Buyer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "Amount"
         Type: uint256
         Source: "uint Amount"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "PassTokenManager"
   Source: "contract PassTokenManager is PassTokenManagerInterface {\r\n\r\n// Constant functions\r\n\r\n    function Client() constant returns (address) {\r\n        return passDao.ActualCommitteeRoom();\r\n    }\r\n   \r\n    function totalSupply() constant external returns (uint256) {\r\n        return totalTokenSupply;\r\n    }\r\n    \r\n    function balanceOf(address _owner) constant external returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n     \r\n    function Transferable() constant external returns (bool) {\r\n        return transferable;\r\n    }\r\n \r\n    function allowance(\r\n        address _owner, \r\n        address _spender) constant external returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function FundedAmount(uint _proposalID) constant external returns (uint) {\r\n        return fundings[_proposalID].fundedAmount;\r\n    }\r\n  \r\n    function AmountToFund(uint _proposalID) constant external returns (uint) {\r\n\r\n        if (now > fundings[_proposalID].closingTime\r\n            || now < fundings[_proposalID].startTime) {\r\n            return 0;   \r\n            } else return fundings[_proposalID].amountToFund;\r\n    }\r\n    \r\n    function priceMultiplier(uint _proposalID) constant internal returns (uint) {\r\n        return fundings[_proposalID].initialPriceMultiplier;\r\n    }\r\n    \r\n    function priceDivisor(uint _proposalID, uint _saleDate) constant internal returns (uint) {\r\n        uint _date = _saleDate;\r\n        \r\n        if (_saleDate > fundings[_proposalID].closingTime) _date = fundings[_proposalID].closingTime;\r\n        if (_saleDate < fundings[_proposalID].startTime) _date = fundings[_proposalID].startTime;\r\n\r\n        return 100 + 100*fundings[_proposalID].inflationRate*(_date - fundings[_proposalID].startTime)/(100*365 days);\r\n    }\r\n    \r\n    function actualPriceDivisor(uint _proposalID) constant internal returns (uint) {\r\n        return priceDivisor(_proposalID, now);\r\n    }\r\n    \r\n    function TokenAmount(\r\n        uint _weiAmount, \r\n        uint _priceMultiplier, \r\n        uint _priceDivisor) constant internal returns (uint) {\r\n        \r\n        uint _a = _weiAmount*_priceMultiplier;\r\n        uint _multiplier = 100*_a;\r\n        uint _amount = _multiplier/_priceDivisor;\r\n        if (_a/_weiAmount != _priceMultiplier\r\n            || _multiplier/100 != _a) return 0; \r\n        \r\n        return _amount;\r\n    }\r\n    \r\n    function weiAmount(\r\n        uint _tokenAmount, \r\n        uint _priceMultiplier, \r\n        uint _priceDivisor) constant internal returns (uint) {\r\n        \r\n        uint _multiplier = _tokenAmount*_priceDivisor;\r\n        uint _divisor = 100*_priceMultiplier;\r\n        uint _amount = _multiplier/_divisor;\r\n        if (_multiplier/_tokenAmount != _priceDivisor\r\n            || _divisor/100 != _priceMultiplier) return 0; \r\n\r\n        return _amount;\r\n    }\r\n    \r\n    function TokenPriceInWei(uint _tokenAmount, uint _proposalID) constant returns (uint) {\r\n        return weiAmount(_tokenAmount, priceMultiplier(_proposalID), actualPriceDivisor(_proposalID));\r\n    }\r\n    \r\n    function LastProposalID() constant returns (uint) {\r\n        return lastProposalID;\r\n    }\r\n    \r\n    function numberOfHolders() constant returns (uint) {\r\n        return holders.length - 1;\r\n    }\r\n    \r\n    function HolderAddress(uint _index) constant external returns (address) {\r\n        return holders[_index];\r\n    }\r\n\r\n// Modifiers\r\n\r\n    // Modifier that allows only the client ..\r\n    modifier onlyClient {if (msg.sender != Client()) throw; _;}\r\n      \r\n    // Modifier for share Manager functions\r\n    modifier onlyShareManager {if (token) throw; _;}\r\n\r\n    // Modifier for token Manager functions\r\n    modifier onlyTokenManager {if (!token) throw; _;}\r\n  \r\n// Constructor function\r\n\r\n    function PassTokenManager(\r\n        PassDao _passDao,\r\n        address _clonedFrom,\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _tokenDecimals,\r\n        bool _token,\r\n        bool _transferable,\r\n        uint _initialPriceMultiplier,\r\n        uint _inflationRate) {\r\n\r\n        passDao = _passDao;\r\n        creator = msg.sender;\r\n        \r\n        clonedFrom = _clonedFrom;            \r\n\r\n        name = _tokenName;\r\n        symbol = _tokenSymbol;\r\n        decimals = _tokenDecimals;\r\n\r\n        token = _token;\r\n        transferable = _transferable;\r\n\r\n        fundings[0].initialPriceMultiplier = _initialPriceMultiplier;\r\n        fundings[0].inflationRate = _inflationRate;\r\n\r\n        holders.length = 1;\r\n    }\r\n\r\n// Setting functions\r\n\r\n    function initialTokenSupply(\r\n        address _recipient, \r\n        uint _quantity,\r\n        bool _last) returns (bool success) {\r\n\r\n        if (initialTokenSupplyDone) throw;\r\n        \r\n        addHolder(_recipient);\r\n        if (_recipient != 0 && _quantity != 0) createTokens(_recipient, _quantity);\r\n        \r\n        if (_last) initialTokenSupplyDone = true;\r\n        \r\n        return true;\r\n    }\r\n\r\n    function cloneTokens(\r\n        uint _from,\r\n        uint _to) returns (bool success) {\r\n        \r\n        initialTokenSupplyDone = true;\r\n        if (_from == 0) _from = 1;\r\n        \r\n        PassTokenManager _clonedFrom = PassTokenManager(clonedFrom);\r\n        uint _numberOfHolders = _clonedFrom.numberOfHolders();\r\n        if (_to == 0 || _to > _numberOfHolders) _to = _numberOfHolders;\r\n        \r\n        address _holder;\r\n        uint _balance;\r\n\r\n        for (uint i = _from; i <= _to; i++) {\r\n            _holder = _clonedFrom.HolderAddress(i);\r\n            _balance = _clonedFrom.balanceOf(_holder);\r\n            if (balances[_holder] == 0 && _balance != 0) {\r\n                addHolder(_holder);\r\n                createTokens(_holder, _balance);\r\n            }\r\n        }\r\n    }\r\n        \r\n// Token creation\r\n\r\n    function addHolder(address _holder) internal {\r\n        \r\n        if (holderID[_holder] == 0) {\r\n            \r\n            uint _holderID = holders.length++;\r\n            holders[_holderID] = _holder;\r\n            holderID[_holder] = _holderID;\r\n        }\r\n    }\r\n\r\n    function createTokens(\r\n        address _holder, \r\n        uint _tokenAmount) internal {\r\n\r\n        balances[_holder] += _tokenAmount; \r\n        totalTokenSupply += _tokenAmount;\r\n        TokensCreated(msg.sender, _holder, _tokenAmount);\r\n    }\r\n    \r\n    function rewardTokensForClient(\r\n        address _recipient, \r\n        uint _amount\r\n        ) external onlyClient returns (uint) {\r\n\r\n        uint _tokenAmount = TokenAmount(_amount, priceMultiplier(0), actualPriceDivisor(0));\r\n        if (_tokenAmount == 0) throw;\r\n\r\n        addHolder(_recipient);\r\n        createTokens(_recipient, _tokenAmount);\r\n\r\n        return _tokenAmount;\r\n    }\r\n    \r\n    function setFundingRules(\r\n        address _moderator,\r\n        uint _initialPriceMultiplier,\r\n        uint _amountToFund,\r\n        uint _minutesFundingPeriod, \r\n        uint _inflationRate,\r\n        uint _proposalID\r\n    ) external onlyClient {\r\n\r\n        if (_moderator == address(this)\r\n            || _moderator == Client()\r\n            || _amountToFund == 0\r\n            || _minutesFundingPeriod == 0\r\n            || fundings[_proposalID].totalWeiGiven != 0\r\n            ) throw;\r\n            \r\n        fundings[_proposalID].moderator = _moderator;\r\n\r\n        fundings[_proposalID].amountToFund = _amountToFund;\r\n        fundings[_proposalID].fundedAmount = 0;\r\n\r\n        if (_initialPriceMultiplier == 0) {\r\n            if (now < fundings[0].closingTime) {\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastProposalID)/actualPriceDivisor(lastProposalID);\r\n            } else {\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastFueledFundingID)/actualPriceDivisor(lastFueledFundingID);\r\n            }\r\n            fundings[0].initialPriceMultiplier = fundings[_proposalID].initialPriceMultiplier;\r\n        }\r\n        else {\r\n            fundings[_proposalID].initialPriceMultiplier = _initialPriceMultiplier;\r\n            fundings[0].initialPriceMultiplier = _initialPriceMultiplier;\r\n        }\r\n        \r\n        if (_inflationRate == 0) fundings[_proposalID].inflationRate = fundings[0].inflationRate;\r\n        else {\r\n            fundings[_proposalID].inflationRate = _inflationRate;\r\n            fundings[0].inflationRate = _inflationRate;\r\n        }\r\n        \r\n        fundings[_proposalID].startTime = now;\r\n        fundings[0].startTime = now;\r\n        \r\n        fundings[_proposalID].closingTime = now + _minutesFundingPeriod * 1 minutes;\r\n        fundings[0].closingTime = fundings[_proposalID].closingTime;\r\n        \r\n        fundings[_proposalID].totalWeiGiven = 0;\r\n        \r\n        lastProposalID = _proposalID;\r\n        \r\n        FundingRulesSet(_moderator, _proposalID,  _amountToFund, fundings[_proposalID].startTime, fundings[_proposalID].closingTime);\r\n    } \r\n    \r\n    function sale(\r\n        uint _proposalID,\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _saleDate,\r\n        bool _presale) internal returns (bool success) {\r\n\r\n        if (_saleDate == 0) _saleDate = now;\r\n\r\n        if (_saleDate > fundings[_proposalID].closingTime\r\n            || _saleDate < fundings[_proposalID].startTime\r\n            || fundings[_proposalID].totalWeiGiven + _amount > fundings[_proposalID].amountToFund) return;\r\n\r\n        uint _tokenAmount = TokenAmount(_amount, priceMultiplier(_proposalID), priceDivisor(_proposalID, _saleDate));\r\n        if (_tokenAmount == 0) return;\r\n        \r\n        addHolder(_recipient);\r\n        if (_presale) {\r\n            Given[_proposalID][_recipient].tokenAmount += _tokenAmount;\r\n        }\r\n        else createTokens(_recipient, _tokenAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function closeFunding(uint _proposalID) internal {\r\n        fundings[_proposalID].fundedAmount = fundings[_proposalID].totalWeiGiven;\r\n        lastFueledFundingID = _proposalID;\r\n        fundings[_proposalID].closingTime = now;\r\n        FundingFueled(_proposalID, fundings[_proposalID].fundedAmount);\r\n    }\r\n\r\n    function sendPendingAmounts(        \r\n        uint _from,\r\n        uint _to,\r\n        address _buyer) returns (bool) {\r\n        \r\n        if (_from == 0) _from = 1;\r\n        if (_to == 0) _to = lastProposalID;\r\n        if (_buyer == 0) _buyer = msg.sender;\r\n\r\n        uint _amount;\r\n        uint _tokenAmount;\r\n        \r\n        for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (now > fundings[i].closingTime && Given[i][_buyer].weiAmount != 0) {\r\n                \r\n                if (fundings[i].fundedAmount == 0) _amount += Given[i][_buyer].weiAmount;\r\n                else _tokenAmount += Given[i][_buyer].tokenAmount;\r\n\r\n                fundings[i].totalWeiGiven -= Given[i][_buyer].weiAmount;\r\n                Given[i][_buyer].tokenAmount = 0;\r\n                Given[i][_buyer].weiAmount = 0;\r\n            }\r\n        }\r\n\r\n        if (_tokenAmount > 0) {\r\n            createTokens(_buyer, _tokenAmount);\r\n            return true;\r\n        }\r\n        \r\n        if (_amount > 0) {\r\n            if (!_buyer.send(_amount)) throw;\r\n            Refund(_buyer, _amount);\r\n        } else return true;\r\n    }\r\n    \r\n\r\n    function withdrawPendingAmounts() returns (bool) {\r\n        \r\n        return sendPendingAmounts(0, 0, msg.sender);\r\n    }        \r\n\r\n// Funding Moderator functions\r\n\r\n    function setFundingStartTime(uint _proposalID, uint _startTime) external {\r\n        if ((msg.sender !=  fundings[_proposalID].moderator) || now > fundings[_proposalID].closingTime) throw;\r\n        fundings[_proposalID].startTime = _startTime;\r\n    }\r\n\r\n    function setFundingFueled(uint _proposalID) external {\r\n\r\n        if ((msg.sender !=  fundings[_proposalID].moderator) || now > fundings[_proposalID].closingTime) throw;\r\n\r\n        closeFunding(_proposalID);\r\n    }\r\n    \r\n// Tokens transfer management    \r\n    \r\n    function ableTransfer() onlyClient {\r\n        if (!transferable) {\r\n            transferable = true;\r\n            TransferAble();\r\n        }\r\n    }\r\n\r\n    function disableTransfer() onlyClient {\r\n        if (transferable) {\r\n            transferable = false;\r\n            TransferDisable();\r\n        }\r\n    }\r\n    \r\n    function blockTransfer(address _shareHolder, uint _deadLine) external onlyClient onlyShareManager {\r\n        if (_deadLine > blockedDeadLine[_shareHolder]) {\r\n            blockedDeadLine[_shareHolder] = _deadLine;\r\n        }\r\n    }\r\n    \r\n    function transferFromTo(\r\n        address _from,\r\n        address _to, \r\n        uint256 _value\r\n        ) internal returns (bool success) {  \r\n\r\n        if ((transferable)\r\n            && now > blockedDeadLine[_from]\r\n            && now > blockedDeadLine[_to]\r\n            && _to != address(this)\r\n            && balances[_from] >= _value\r\n            && balances[_to] + _value > balances[_to]) {\r\n\r\n            addHolder(_to);\r\n            balances[_from] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n\r\n        } else return false;\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) returns (bool success) {  \r\n        if (!transferFromTo(msg.sender, _to, _value)) throw;\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n        ) returns (bool success) { \r\n        \r\n        if (allowed[_from][msg.sender] < _value\r\n            || !transferFromTo(_from, _to, _value)) throw;\r\n            \r\n        allowed[_from][msg.sender] -= _value;\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n    \r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "PassTokenManagerInterface"
    UserDefinedTypeName "PassTokenManagerInterface"
       Source: "PassTokenManagerInterface"
  FunctionDefinition "Client" - public - const
     Source: "function Client() constant returns (address) {\r\n        return passDao.ActualCommitteeRoom();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return passDao.ActualCommitteeRoom();\r\n    }"
      Return
         Gas costs: [???]
         Source: "return passDao.ActualCommitteeRoom()"
        FunctionCall
           Type: address
           Source: "passDao.ActualCommitteeRoom()"
          MemberAccess to member ActualCommitteeRoom
             Type: function () view external returns (address)
             Source: "passDao.ActualCommitteeRoom"
            Identifier passDao
               Type: contract PassDao
               Source: "passDao"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() constant external returns (uint256) {\r\n        return totalTokenSupply;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return totalTokenSupply;\r\n    }"
      Return
         Gas costs: 208
         Source: "return totalTokenSupply"
        Identifier totalTokenSupply
           Type: uint256
           Source: "totalTokenSupply"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant external returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balances[_owner];\r\n    }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "Transferable" - public - const
     Source: "function Transferable() constant external returns (bool) {\r\n        return transferable;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        return transferable;\r\n    }"
      Return
         Gas costs: 294
         Source: "return transferable"
        Identifier transferable
           Type: bool
           Source: "transferable"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(\r\n        address _owner, \r\n        address _spender) constant external returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _owner, \r\n        address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  FunctionDefinition "FundedAmount" - public - const
     Source: "function FundedAmount(uint _proposalID) constant external returns (uint) {\r\n        return fundings[_proposalID].fundedAmount;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _proposalID)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return fundings[_proposalID].fundedAmount;\r\n    }"
      Return
         Gas costs: 298
         Source: "return fundings[_proposalID].fundedAmount"
        MemberAccess to member fundedAmount
           Type: uint256
           Source: "fundings[_proposalID].fundedAmount"
          IndexAccess
             Type: struct PassTokenManagerInterface.funding storage ref
             Source: "fundings[_proposalID]"
            Identifier fundings
               Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
               Source: "fundings"
            Identifier _proposalID
               Type: uint256
               Source: "_proposalID"
  FunctionDefinition "AmountToFund" - public - const
     Source: "function AmountToFund(uint _proposalID) constant external returns (uint) {\r\n\r\n        if (now > fundings[_proposalID].closingTime\r\n            || now < fundings[_proposalID].startTime) {\r\n            return 0;   \r\n            } else return fundings[_proposalID].amountToFund;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _proposalID)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        if (now > fundings[_proposalID].closingTime\r\n            || now < fundings[_proposalID].startTime) {\r\n            return 0;   \r\n            } else return fundings[_proposalID].amountToFund;\r\n    }"
      IfStatement
         Source: "if (now > fundings[_proposalID].closingTime\r\n            || now < fundings[_proposalID].startTime) {\r\n            return 0;   \r\n            } else return fundings[_proposalID].amountToFund"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 615
           Source: "now > fundings[_proposalID].closingTime\r\n            || now < fundings[_proposalID].startTime"
          BinaryOperation using operator >
             Type: bool
             Source: "now > fundings[_proposalID].closingTime"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member closingTime
               Type: uint256
               Source: "fundings[_proposalID].closingTime"
              IndexAccess
                 Type: struct PassTokenManagerInterface.funding storage ref
                 Source: "fundings[_proposalID]"
                Identifier fundings
                   Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                   Source: "fundings"
                Identifier _proposalID
                   Type: uint256
                   Source: "_proposalID"
          BinaryOperation using operator <
             Type: bool
             Source: "now < fundings[_proposalID].startTime"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member startTime
               Type: uint256
               Source: "fundings[_proposalID].startTime"
              IndexAccess
                 Type: struct PassTokenManagerInterface.funding storage ref
                 Source: "fundings[_proposalID]"
                Identifier fundings
                   Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                   Source: "fundings"
                Identifier _proposalID
                   Type: uint256
                   Source: "_proposalID"
        Block
           Source: "{\r\n            return 0;   \r\n            }"
          Return
             Gas costs: 19
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Return
           Gas costs: 298
           Source: "return fundings[_proposalID].amountToFund"
          MemberAccess to member amountToFund
             Type: uint256
             Source: "fundings[_proposalID].amountToFund"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
  FunctionDefinition "priceMultiplier" - const
     Source: "function priceMultiplier(uint _proposalID) constant internal returns (uint) {\r\n        return fundings[_proposalID].initialPriceMultiplier;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _proposalID)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return fundings[_proposalID].initialPriceMultiplier;\r\n    }"
      Return
         Gas costs: 298
         Source: "return fundings[_proposalID].initialPriceMultiplier"
        MemberAccess to member initialPriceMultiplier
           Type: uint256
           Source: "fundings[_proposalID].initialPriceMultiplier"
          IndexAccess
             Type: struct PassTokenManagerInterface.funding storage ref
             Source: "fundings[_proposalID]"
            Identifier fundings
               Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
               Source: "fundings"
            Identifier _proposalID
               Type: uint256
               Source: "_proposalID"
  FunctionDefinition "priceDivisor" - const
     Source: "function priceDivisor(uint _proposalID, uint _saleDate) constant internal returns (uint) {\r\n        uint _date = _saleDate;\r\n        \r\n        if (_saleDate > fundings[_proposalID].closingTime) _date = fundings[_proposalID].closingTime;\r\n        if (_saleDate < fundings[_proposalID].startTime) _date = fundings[_proposalID].startTime;\r\n\r\n        return 100 + 100*fundings[_proposalID].inflationRate*(_date - fundings[_proposalID].startTime)/(100*365 days);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _proposalID, uint _saleDate)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_saleDate"
         Type: uint256
         Source: "uint _saleDate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint _date = _saleDate;\r\n        \r\n        if (_saleDate > fundings[_proposalID].closingTime) _date = fundings[_proposalID].closingTime;\r\n        if (_saleDate < fundings[_proposalID].startTime) _date = fundings[_proposalID].startTime;\r\n\r\n        return 100 + 100*fundings[_proposalID].inflationRate*(_date - fundings[_proposalID].startTime)/(100*365 days);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint _date = _saleDate"
        VariableDeclaration "_date"
           Type: uint256
           Source: "uint _date"
          ElementaryTypeName uint
             Source: "uint"
        Identifier _saleDate
           Type: uint256
           Source: "_saleDate"
      IfStatement
         Source: "if (_saleDate > fundings[_proposalID].closingTime) _date = fundings[_proposalID].closingTime"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 299
           Source: "_saleDate > fundings[_proposalID].closingTime"
          Identifier _saleDate
             Type: uint256
             Source: "_saleDate"
          MemberAccess to member closingTime
             Type: uint256
             Source: "fundings[_proposalID].closingTime"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
        ExpressionStatement
           Gas costs: 298
           Source: "_date = fundings[_proposalID].closingTime"
          Assignment using operator =
             Type: uint256
             Source: "_date = fundings[_proposalID].closingTime"
            Identifier _date
               Type: uint256
               Source: "_date"
            MemberAccess to member closingTime
               Type: uint256
               Source: "fundings[_proposalID].closingTime"
              IndexAccess
                 Type: struct PassTokenManagerInterface.funding storage ref
                 Source: "fundings[_proposalID]"
                Identifier fundings
                   Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                   Source: "fundings"
                Identifier _proposalID
                   Type: uint256
                   Source: "_proposalID"
      IfStatement
         Source: "if (_saleDate < fundings[_proposalID].startTime) _date = fundings[_proposalID].startTime"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 299
           Source: "_saleDate < fundings[_proposalID].startTime"
          Identifier _saleDate
             Type: uint256
             Source: "_saleDate"
          MemberAccess to member startTime
             Type: uint256
             Source: "fundings[_proposalID].startTime"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
        ExpressionStatement
           Gas costs: 298
           Source: "_date = fundings[_proposalID].startTime"
          Assignment using operator =
             Type: uint256
             Source: "_date = fundings[_proposalID].startTime"
            Identifier _date
               Type: uint256
               Source: "_date"
            MemberAccess to member startTime
               Type: uint256
               Source: "fundings[_proposalID].startTime"
              IndexAccess
                 Type: struct PassTokenManagerInterface.funding storage ref
                 Source: "fundings[_proposalID]"
                Identifier fundings
                   Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                   Source: "fundings"
                Identifier _proposalID
                   Type: uint256
                   Source: "_proposalID"
      Return
         Gas costs: 641
         Source: "return 100 + 100*fundings[_proposalID].inflationRate*(_date - fundings[_proposalID].startTime)/(100*365 days)"
        BinaryOperation using operator +
           Type: uint256
           Source: "100 + 100*fundings[_proposalID].inflationRate*(_date - fundings[_proposalID].startTime)/(100*365 days)"
          Literal, token: [no token] value: 100
             Type: int_const 100
             Source: "100"
          BinaryOperation using operator /
             Type: uint256
             Source: "100*fundings[_proposalID].inflationRate*(_date - fundings[_proposalID].startTime)/(100*365 days)"
            BinaryOperation using operator *
               Type: uint256
               Source: "100*fundings[_proposalID].inflationRate*(_date - fundings[_proposalID].startTime)"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "100*fundings[_proposalID].inflationRate"
                Literal, token: [no token] value: 100
                   Type: int_const 100
                   Source: "100"
                MemberAccess to member inflationRate
                   Type: uint256
                   Source: "fundings[_proposalID].inflationRate"
                  IndexAccess
                     Type: struct PassTokenManagerInterface.funding storage ref
                     Source: "fundings[_proposalID]"
                    Identifier fundings
                       Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                       Source: "fundings"
                    Identifier _proposalID
                       Type: uint256
                       Source: "_proposalID"
              TupleExpression
                 Type: uint256
                 Source: "(_date - fundings[_proposalID].startTime)"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "_date - fundings[_proposalID].startTime"
                  Identifier _date
                     Type: uint256
                     Source: "_date"
                  MemberAccess to member startTime
                     Type: uint256
                     Source: "fundings[_proposalID].startTime"
                    IndexAccess
                       Type: struct PassTokenManagerInterface.funding storage ref
                       Source: "fundings[_proposalID]"
                      Identifier fundings
                         Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                         Source: "fundings"
                      Identifier _proposalID
                         Type: uint256
                         Source: "_proposalID"
            TupleExpression
               Type: int_const 3153600000
               Source: "(100*365 days)"
              BinaryOperation using operator *
                 Type: int_const 3153600000
                 Source: "100*365 days"
                Literal, token: [no token] value: 100
                   Type: int_const 100
                   Source: "100"
                Literal, token: [no token] value: 365
                   Type: int_const 31536000
                   Source: "365 days"
  FunctionDefinition "actualPriceDivisor" - const
     Source: "function actualPriceDivisor(uint _proposalID) constant internal returns (uint) {\r\n        return priceDivisor(_proposalID, now);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _proposalID)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return priceDivisor(_proposalID, now);\r\n    }"
      Return
         Gas costs: 14
         Source: "return priceDivisor(_proposalID, now)"
        FunctionCall
           Type: uint256
           Source: "priceDivisor(_proposalID, now)"
          Identifier priceDivisor
             Type: function (uint256,uint256) view returns (uint256)
             Source: "priceDivisor"
          Identifier _proposalID
             Type: uint256
             Source: "_proposalID"
          Identifier now
             Type: uint256
             Source: "now"
  FunctionDefinition "TokenAmount" - const
     Source: "function TokenAmount(\r\n        uint _weiAmount, \r\n        uint _priceMultiplier, \r\n        uint _priceDivisor) constant internal returns (uint) {\r\n        \r\n        uint _a = _weiAmount*_priceMultiplier;\r\n        uint _multiplier = 100*_a;\r\n        uint _amount = _multiplier/_priceDivisor;\r\n        if (_a/_weiAmount != _priceMultiplier\r\n            || _multiplier/100 != _a) return 0; \r\n        \r\n        return _amount;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint _weiAmount, \r\n        uint _priceMultiplier, \r\n        uint _priceDivisor)"
      VariableDeclaration "_weiAmount"
         Type: uint256
         Source: "uint _weiAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_priceMultiplier"
         Type: uint256
         Source: "uint _priceMultiplier"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_priceDivisor"
         Type: uint256
         Source: "uint _priceDivisor"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        \r\n        uint _a = _weiAmount*_priceMultiplier;\r\n        uint _multiplier = 100*_a;\r\n        uint _amount = _multiplier/_priceDivisor;\r\n        if (_a/_weiAmount != _priceMultiplier\r\n            || _multiplier/100 != _a) return 0; \r\n        \r\n        return _amount;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint _a = _weiAmount*_priceMultiplier"
        VariableDeclaration "_a"
           Type: uint256
           Source: "uint _a"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "_weiAmount*_priceMultiplier"
          Identifier _weiAmount
             Type: uint256
             Source: "_weiAmount"
          Identifier _priceMultiplier
             Type: uint256
             Source: "_priceMultiplier"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint _multiplier = 100*_a"
        VariableDeclaration "_multiplier"
           Type: uint256
           Source: "uint _multiplier"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "100*_a"
          Literal, token: [no token] value: 100
             Type: int_const 100
             Source: "100"
          Identifier _a
             Type: uint256
             Source: "_a"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint _amount = _multiplier/_priceDivisor"
        VariableDeclaration "_amount"
           Type: uint256
           Source: "uint _amount"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "_multiplier/_priceDivisor"
          Identifier _multiplier
             Type: uint256
             Source: "_multiplier"
          Identifier _priceDivisor
             Type: uint256
             Source: "_priceDivisor"
      IfStatement
         Source: "if (_a/_weiAmount != _priceMultiplier\r\n            || _multiplier/100 != _a) return 0"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 105
           Source: "_a/_weiAmount != _priceMultiplier\r\n            || _multiplier/100 != _a"
          BinaryOperation using operator !=
             Type: bool
             Source: "_a/_weiAmount != _priceMultiplier"
            BinaryOperation using operator /
               Type: uint256
               Source: "_a/_weiAmount"
              Identifier _a
                 Type: uint256
                 Source: "_a"
              Identifier _weiAmount
                 Type: uint256
                 Source: "_weiAmount"
            Identifier _priceMultiplier
               Type: uint256
               Source: "_priceMultiplier"
          BinaryOperation using operator !=
             Type: bool
             Source: "_multiplier/100 != _a"
            BinaryOperation using operator /
               Type: uint256
               Source: "_multiplier/100"
              Identifier _multiplier
                 Type: uint256
                 Source: "_multiplier"
              Literal, token: [no token] value: 100
                 Type: int_const 100
                 Source: "100"
            Identifier _a
               Type: uint256
               Source: "_a"
        Return
           Gas costs: 19
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      Return
         Gas costs: 8
         Source: "return _amount"
        Identifier _amount
           Type: uint256
           Source: "_amount"
  FunctionDefinition "weiAmount" - const
     Source: "function weiAmount(\r\n        uint _tokenAmount, \r\n        uint _priceMultiplier, \r\n        uint _priceDivisor) constant internal returns (uint) {\r\n        \r\n        uint _multiplier = _tokenAmount*_priceDivisor;\r\n        uint _divisor = 100*_priceMultiplier;\r\n        uint _amount = _multiplier/_divisor;\r\n        if (_multiplier/_tokenAmount != _priceDivisor\r\n            || _divisor/100 != _priceMultiplier) return 0; \r\n\r\n        return _amount;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint _tokenAmount, \r\n        uint _priceMultiplier, \r\n        uint _priceDivisor)"
      VariableDeclaration "_tokenAmount"
         Type: uint256
         Source: "uint _tokenAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_priceMultiplier"
         Type: uint256
         Source: "uint _priceMultiplier"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_priceDivisor"
         Type: uint256
         Source: "uint _priceDivisor"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        \r\n        uint _multiplier = _tokenAmount*_priceDivisor;\r\n        uint _divisor = 100*_priceMultiplier;\r\n        uint _amount = _multiplier/_divisor;\r\n        if (_multiplier/_tokenAmount != _priceDivisor\r\n            || _divisor/100 != _priceMultiplier) return 0; \r\n\r\n        return _amount;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint _multiplier = _tokenAmount*_priceDivisor"
        VariableDeclaration "_multiplier"
           Type: uint256
           Source: "uint _multiplier"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "_tokenAmount*_priceDivisor"
          Identifier _tokenAmount
             Type: uint256
             Source: "_tokenAmount"
          Identifier _priceDivisor
             Type: uint256
             Source: "_priceDivisor"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint _divisor = 100*_priceMultiplier"
        VariableDeclaration "_divisor"
           Type: uint256
           Source: "uint _divisor"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "100*_priceMultiplier"
          Literal, token: [no token] value: 100
             Type: int_const 100
             Source: "100"
          Identifier _priceMultiplier
             Type: uint256
             Source: "_priceMultiplier"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint _amount = _multiplier/_divisor"
        VariableDeclaration "_amount"
           Type: uint256
           Source: "uint _amount"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "_multiplier/_divisor"
          Identifier _multiplier
             Type: uint256
             Source: "_multiplier"
          Identifier _divisor
             Type: uint256
             Source: "_divisor"
      IfStatement
         Source: "if (_multiplier/_tokenAmount != _priceDivisor\r\n            || _divisor/100 != _priceMultiplier) return 0"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 105
           Source: "_multiplier/_tokenAmount != _priceDivisor\r\n            || _divisor/100 != _priceMultiplier"
          BinaryOperation using operator !=
             Type: bool
             Source: "_multiplier/_tokenAmount != _priceDivisor"
            BinaryOperation using operator /
               Type: uint256
               Source: "_multiplier/_tokenAmount"
              Identifier _multiplier
                 Type: uint256
                 Source: "_multiplier"
              Identifier _tokenAmount
                 Type: uint256
                 Source: "_tokenAmount"
            Identifier _priceDivisor
               Type: uint256
               Source: "_priceDivisor"
          BinaryOperation using operator !=
             Type: bool
             Source: "_divisor/100 != _priceMultiplier"
            BinaryOperation using operator /
               Type: uint256
               Source: "_divisor/100"
              Identifier _divisor
                 Type: uint256
                 Source: "_divisor"
              Literal, token: [no token] value: 100
                 Type: int_const 100
                 Source: "100"
            Identifier _priceMultiplier
               Type: uint256
               Source: "_priceMultiplier"
        Return
           Gas costs: 19
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      Return
         Gas costs: 8
         Source: "return _amount"
        Identifier _amount
           Type: uint256
           Source: "_amount"
  FunctionDefinition "TokenPriceInWei" - public - const
     Source: "function TokenPriceInWei(uint _tokenAmount, uint _proposalID) constant returns (uint) {\r\n        return weiAmount(_tokenAmount, priceMultiplier(_proposalID), actualPriceDivisor(_proposalID));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _tokenAmount, uint _proposalID)"
      VariableDeclaration "_tokenAmount"
         Type: uint256
         Source: "uint _tokenAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return weiAmount(_tokenAmount, priceMultiplier(_proposalID), actualPriceDivisor(_proposalID));\r\n    }"
      Return
         Gas costs: 48
         Source: "return weiAmount(_tokenAmount, priceMultiplier(_proposalID), actualPriceDivisor(_proposalID))"
        FunctionCall
           Type: uint256
           Source: "weiAmount(_tokenAmount, priceMultiplier(_proposalID), actualPriceDivisor(_proposalID))"
          Identifier weiAmount
             Type: function (uint256,uint256,uint256) view returns (uint256)
             Source: "weiAmount"
          Identifier _tokenAmount
             Type: uint256
             Source: "_tokenAmount"
          FunctionCall
             Type: uint256
             Source: "priceMultiplier(_proposalID)"
            Identifier priceMultiplier
               Type: function (uint256) view returns (uint256)
               Source: "priceMultiplier"
            Identifier _proposalID
               Type: uint256
               Source: "_proposalID"
          FunctionCall
             Type: uint256
             Source: "actualPriceDivisor(_proposalID)"
            Identifier actualPriceDivisor
               Type: function (uint256) view returns (uint256)
               Source: "actualPriceDivisor"
            Identifier _proposalID
               Type: uint256
               Source: "_proposalID"
  FunctionDefinition "LastProposalID" - public - const
     Source: "function LastProposalID() constant returns (uint) {\r\n        return lastProposalID;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return lastProposalID;\r\n    }"
      Return
         Gas costs: 208
         Source: "return lastProposalID"
        Identifier lastProposalID
           Type: uint256
           Source: "lastProposalID"
  FunctionDefinition "numberOfHolders" - public - const
     Source: "function numberOfHolders() constant returns (uint) {\r\n        return holders.length - 1;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return holders.length - 1;\r\n    }"
      Return
         Gas costs: 222
         Source: "return holders.length - 1"
        BinaryOperation using operator -
           Type: uint256
           Source: "holders.length - 1"
          MemberAccess to member length
             Type: uint256
             Source: "holders.length"
            Identifier holders
               Type: address[] storage ref
               Source: "holders"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
  FunctionDefinition "HolderAddress" - public - const
     Source: "function HolderAddress(uint _index) constant external returns (address) {\r\n        return holders[_index];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _index)"
      VariableDeclaration "_index"
         Type: uint256
         Source: "uint _index"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return holders[_index];\r\n    }"
      Return
         Gas costs: 533
         Source: "return holders[_index]"
        IndexAccess
           Type: address
           Source: "holders[_index]"
          Identifier holders
             Type: address[] storage ref
             Source: "holders"
          Identifier _index
             Type: uint256
             Source: "_index"
  ModifierDefinition "onlyClient"
     Source: "modifier onlyClient {if (msg.sender != Client()) throw; _;}"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{if (msg.sender != Client()) throw; _;}"
      IfStatement
         Source: "if (msg.sender != Client()) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 199
           Source: "msg.sender != Client()"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          FunctionCall
             Type: address
             Source: "Client()"
            Identifier Client
               Type: function () view returns (address)
               Source: "Client"
        Throw
           Gas costs: 36
           Source: "throw"
      PlaceholderStatement
         Gas costs: 1
         Source: "_"
  ModifierDefinition "onlyShareManager"
     Source: "modifier onlyShareManager {if (token) throw; _;}"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{if (token) throw; _;}"
      IfStatement
         Source: "if (token) throw"
        Identifier token
           Type: bool
           Gas costs: 478
           Source: "token"
        Throw
           Gas costs: 12
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyTokenManager"
     Source: "modifier onlyTokenManager {if (!token) throw; _;}"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{if (!token) throw; _;}"
      IfStatement
         Source: "if (!token) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 0
           Source: "!token"
          Identifier token
             Type: bool
             Source: "token"
        Throw
           Gas costs: 0
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "PassTokenManager" - public
     Source: "function PassTokenManager(\r\n        PassDao _passDao,\r\n        address _clonedFrom,\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _tokenDecimals,\r\n        bool _token,\r\n        bool _transferable,\r\n        uint _initialPriceMultiplier,\r\n        uint _inflationRate) {\r\n\r\n        passDao = _passDao;\r\n        creator = msg.sender;\r\n        \r\n        clonedFrom = _clonedFrom;            \r\n\r\n        name = _tokenName;\r\n        symbol = _tokenSymbol;\r\n        decimals = _tokenDecimals;\r\n\r\n        token = _token;\r\n        transferable = _transferable;\r\n\r\n        fundings[0].initialPriceMultiplier = _initialPriceMultiplier;\r\n        fundings[0].inflationRate = _inflationRate;\r\n\r\n        holders.length = 1;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        PassDao _passDao,\r\n        address _clonedFrom,\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _tokenDecimals,\r\n        bool _token,\r\n        bool _transferable,\r\n        uint _initialPriceMultiplier,\r\n        uint _inflationRate)"
      VariableDeclaration "_passDao"
         Type: contract PassDao
         Source: "PassDao _passDao"
        UserDefinedTypeName "PassDao"
           Source: "PassDao"
      VariableDeclaration "_clonedFrom"
         Type: address
         Source: "address _clonedFrom"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokenName"
         Type: string memory
         Source: "string _tokenName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_tokenSymbol"
         Type: string memory
         Source: "string _tokenSymbol"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_tokenDecimals"
         Type: uint8
         Source: "uint8 _tokenDecimals"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "_token"
         Type: bool
         Source: "bool _token"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "_transferable"
         Type: bool
         Source: "bool _transferable"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "_initialPriceMultiplier"
         Type: uint256
         Source: "uint _initialPriceMultiplier"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_inflationRate"
         Type: uint256
         Source: "uint _inflationRate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\r\n        passDao = _passDao;\r\n        creator = msg.sender;\r\n        \r\n        clonedFrom = _clonedFrom;            \r\n\r\n        name = _tokenName;\r\n        symbol = _tokenSymbol;\r\n        decimals = _tokenDecimals;\r\n\r\n        token = _token;\r\n        transferable = _transferable;\r\n\r\n        fundings[0].initialPriceMultiplier = _initialPriceMultiplier;\r\n        fundings[0].inflationRate = _inflationRate;\r\n\r\n        holders.length = 1;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "passDao = _passDao"
        Assignment using operator =
           Type: contract PassDao
           Source: "passDao = _passDao"
          Identifier passDao
             Type: contract PassDao
             Source: "passDao"
          Identifier _passDao
             Type: contract PassDao
             Source: "_passDao"
      ExpressionStatement
         Gas costs: 0
         Source: "creator = msg.sender"
        Assignment using operator =
           Type: address
           Source: "creator = msg.sender"
          Identifier creator
             Type: address
             Source: "creator"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "clonedFrom = _clonedFrom"
        Assignment using operator =
           Type: address
           Source: "clonedFrom = _clonedFrom"
          Identifier clonedFrom
             Type: address
             Source: "clonedFrom"
          Identifier _clonedFrom
             Type: address
             Source: "_clonedFrom"
      ExpressionStatement
         Gas costs: 0
         Source: "name = _tokenName"
        Assignment using operator =
           Type: string storage ref
           Source: "name = _tokenName"
          Identifier name
             Type: string storage ref
             Source: "name"
          Identifier _tokenName
             Type: string memory
             Source: "_tokenName"
      ExpressionStatement
         Gas costs: 0
         Source: "symbol = _tokenSymbol"
        Assignment using operator =
           Type: string storage ref
           Source: "symbol = _tokenSymbol"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
          Identifier _tokenSymbol
             Type: string memory
             Source: "_tokenSymbol"
      ExpressionStatement
         Gas costs: 0
         Source: "decimals = _tokenDecimals"
        Assignment using operator =
           Type: uint8
           Source: "decimals = _tokenDecimals"
          Identifier decimals
             Type: uint8
             Source: "decimals"
          Identifier _tokenDecimals
             Type: uint8
             Source: "_tokenDecimals"
      ExpressionStatement
         Gas costs: 0
         Source: "token = _token"
        Assignment using operator =
           Type: bool
           Source: "token = _token"
          Identifier token
             Type: bool
             Source: "token"
          Identifier _token
             Type: bool
             Source: "_token"
      ExpressionStatement
         Gas costs: 0
         Source: "transferable = _transferable"
        Assignment using operator =
           Type: bool
           Source: "transferable = _transferable"
          Identifier transferable
             Type: bool
             Source: "transferable"
          Identifier _transferable
             Type: bool
             Source: "_transferable"
      ExpressionStatement
         Gas costs: 0
         Source: "fundings[0].initialPriceMultiplier = _initialPriceMultiplier"
        Assignment using operator =
           Type: uint256
           Source: "fundings[0].initialPriceMultiplier = _initialPriceMultiplier"
          MemberAccess to member initialPriceMultiplier
             Type: uint256
             Source: "fundings[0].initialPriceMultiplier"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[0]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Identifier _initialPriceMultiplier
             Type: uint256
             Source: "_initialPriceMultiplier"
      ExpressionStatement
         Gas costs: 0
         Source: "fundings[0].inflationRate = _inflationRate"
        Assignment using operator =
           Type: uint256
           Source: "fundings[0].inflationRate = _inflationRate"
          MemberAccess to member inflationRate
             Type: uint256
             Source: "fundings[0].inflationRate"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[0]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Identifier _inflationRate
             Type: uint256
             Source: "_inflationRate"
      ExpressionStatement
         Gas costs: 0
         Source: "holders.length = 1"
        Assignment using operator =
           Type: uint256
           Source: "holders.length = 1"
          MemberAccess to member length
             Type: uint256
             Source: "holders.length"
            Identifier holders
               Type: address[] storage ref
               Source: "holders"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
  FunctionDefinition "initialTokenSupply" - public
     Source: "function initialTokenSupply(\r\n        address _recipient, \r\n        uint _quantity,\r\n        bool _last) returns (bool success) {\r\n\r\n        if (initialTokenSupplyDone) throw;\r\n        \r\n        addHolder(_recipient);\r\n        if (_recipient != 0 && _quantity != 0) createTokens(_recipient, _quantity);\r\n        \r\n        if (_last) initialTokenSupplyDone = true;\r\n        \r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _recipient, \r\n        uint _quantity,\r\n        bool _last)"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_quantity"
         Type: uint256
         Source: "uint _quantity"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_last"
         Type: bool
         Source: "bool _last"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n        if (initialTokenSupplyDone) throw;\r\n        \r\n        addHolder(_recipient);\r\n        if (_recipient != 0 && _quantity != 0) createTokens(_recipient, _quantity);\r\n        \r\n        if (_last) initialTokenSupplyDone = true;\r\n        \r\n        return true;\r\n    }"
      IfStatement
         Source: "if (initialTokenSupplyDone) throw"
        Identifier initialTokenSupplyDone
           Type: bool
           Gas costs: 289
           Source: "initialTokenSupplyDone"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 7
         Source: "addHolder(_recipient)"
        FunctionCall
           Type: tuple()
           Source: "addHolder(_recipient)"
          Identifier addHolder
             Type: function (address)
             Source: "addHolder"
          Identifier _recipient
             Type: address
             Source: "_recipient"
      IfStatement
         Source: "if (_recipient != 0 && _quantity != 0) createTokens(_recipient, _quantity)"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 52
           Source: "_recipient != 0 && _quantity != 0"
          BinaryOperation using operator !=
             Type: bool
             Source: "_recipient != 0"
            Identifier _recipient
               Type: address
               Source: "_recipient"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator !=
             Type: bool
             Source: "_quantity != 0"
            Identifier _quantity
               Type: uint256
               Source: "_quantity"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        ExpressionStatement
           Gas costs: 21
           Source: "createTokens(_recipient, _quantity)"
          FunctionCall
             Type: tuple()
             Source: "createTokens(_recipient, _quantity)"
            Identifier createTokens
               Type: function (address,uint256)
               Source: "createTokens"
            Identifier _recipient
               Type: address
               Source: "_recipient"
            Identifier _quantity
               Type: uint256
               Source: "_quantity"
      IfStatement
         Source: "if (_last) initialTokenSupplyDone = true"
        Identifier _last
           Type: bool
           Gas costs: 3
           Source: "_last"
        ExpressionStatement
           Gas costs: 20317
           Source: "initialTokenSupplyDone = true"
          Assignment using operator =
             Type: bool
             Source: "initialTokenSupplyDone = true"
            Identifier initialTokenSupplyDone
               Type: bool
               Source: "initialTokenSupplyDone"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "cloneTokens" - public
     Source: "function cloneTokens(\r\n        uint _from,\r\n        uint _to) returns (bool success) {\r\n        \r\n        initialTokenSupplyDone = true;\r\n        if (_from == 0) _from = 1;\r\n        \r\n        PassTokenManager _clonedFrom = PassTokenManager(clonedFrom);\r\n        uint _numberOfHolders = _clonedFrom.numberOfHolders();\r\n        if (_to == 0 || _to > _numberOfHolders) _to = _numberOfHolders;\r\n        \r\n        address _holder;\r\n        uint _balance;\r\n\r\n        for (uint i = _from; i <= _to; i++) {\r\n            _holder = _clonedFrom.HolderAddress(i);\r\n            _balance = _clonedFrom.balanceOf(_holder);\r\n            if (balances[_holder] == 0 && _balance != 0) {\r\n                addHolder(_holder);\r\n                createTokens(_holder, _balance);\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint _from,\r\n        uint _to)"
      VariableDeclaration "_from"
         Type: uint256
         Source: "uint _from"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_to"
         Type: uint256
         Source: "uint _to"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        \r\n        initialTokenSupplyDone = true;\r\n        if (_from == 0) _from = 1;\r\n        \r\n        PassTokenManager _clonedFrom = PassTokenManager(clonedFrom);\r\n        uint _numberOfHolders = _clonedFrom.numberOfHolders();\r\n        if (_to == 0 || _to > _numberOfHolders) _to = _numberOfHolders;\r\n        \r\n        address _holder;\r\n        uint _balance;\r\n\r\n        for (uint i = _from; i <= _to; i++) {\r\n            _holder = _clonedFrom.HolderAddress(i);\r\n            _balance = _clonedFrom.balanceOf(_holder);\r\n            if (balances[_holder] == 0 && _balance != 0) {\r\n                addHolder(_holder);\r\n                createTokens(_holder, _balance);\r\n            }\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 20317
         Source: "initialTokenSupplyDone = true"
        Assignment using operator =
           Type: bool
           Source: "initialTokenSupplyDone = true"
          Identifier initialTokenSupplyDone
             Type: bool
             Source: "initialTokenSupplyDone"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      IfStatement
         Source: "if (_from == 0) _from = 1"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "_from == 0"
          Identifier _from
             Type: uint256
             Source: "_from"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 8
           Source: "_from = 1"
          Assignment using operator =
             Type: uint256
             Source: "_from = 1"
            Identifier _from
               Type: uint256
               Source: "_from"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      VariableDeclarationStatement
         Gas costs: 297
         Source: "PassTokenManager _clonedFrom = PassTokenManager(clonedFrom)"
        VariableDeclaration "_clonedFrom"
           Type: contract PassTokenManager
           Source: "PassTokenManager _clonedFrom"
          UserDefinedTypeName "PassTokenManager"
             Source: "PassTokenManager"
        FunctionCall
           Type: contract PassTokenManager
           Source: "PassTokenManager(clonedFrom)"
          Identifier PassTokenManager
             Type: type(contract PassTokenManager)
             Source: "PassTokenManager"
          Identifier clonedFrom
             Type: address
             Source: "clonedFrom"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint _numberOfHolders = _clonedFrom.numberOfHolders()"
        VariableDeclaration "_numberOfHolders"
           Type: uint256
           Source: "uint _numberOfHolders"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "_clonedFrom.numberOfHolders()"
          MemberAccess to member numberOfHolders
             Type: function () view external returns (uint256)
             Source: "_clonedFrom.numberOfHolders"
            Identifier _clonedFrom
               Type: contract PassTokenManager
               Source: "_clonedFrom"
      IfStatement
         Source: "if (_to == 0 || _to > _numberOfHolders) _to = _numberOfHolders"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 37
           Source: "_to == 0 || _to > _numberOfHolders"
          BinaryOperation using operator ==
             Type: bool
             Source: "_to == 0"
            Identifier _to
               Type: uint256
               Source: "_to"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator >
             Type: bool
             Source: "_to > _numberOfHolders"
            Identifier _to
               Type: uint256
               Source: "_to"
            Identifier _numberOfHolders
               Type: uint256
               Source: "_numberOfHolders"
        ExpressionStatement
           Gas costs: 8
           Source: "_to = _numberOfHolders"
          Assignment using operator =
             Type: uint256
             Source: "_to = _numberOfHolders"
            Identifier _to
               Type: uint256
               Source: "_to"
            Identifier _numberOfHolders
               Type: uint256
               Source: "_numberOfHolders"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "address _holder"
        VariableDeclaration "_holder"
           Type: address
           Source: "address _holder"
          ElementaryTypeName address
             Source: "address"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint _balance"
        VariableDeclaration "_balance"
           Type: uint256
           Source: "uint _balance"
          ElementaryTypeName uint
             Source: "uint"
      ForStatement
         Source: "for (uint i = _from; i <= _to; i++) {\r\n            _holder = _clonedFrom.HolderAddress(i);\r\n            _balance = _clonedFrom.balanceOf(_holder);\r\n            if (balances[_holder] == 0 && _balance != 0) {\r\n                addHolder(_holder);\r\n                createTokens(_holder, _balance);\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = _from"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Identifier _from
             Type: uint256
             Source: "_from"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 12
           Source: "i <= _to"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier _to
             Type: uint256
             Source: "_to"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            _holder = _clonedFrom.HolderAddress(i);\r\n            _balance = _clonedFrom.balanceOf(_holder);\r\n            if (balances[_holder] == 0 && _balance != 0) {\r\n                addHolder(_holder);\r\n                createTokens(_holder, _balance);\r\n            }\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "_holder = _clonedFrom.HolderAddress(i)"
            Assignment using operator =
               Type: address
               Source: "_holder = _clonedFrom.HolderAddress(i)"
              Identifier _holder
                 Type: address
                 Source: "_holder"
              FunctionCall
                 Type: address
                 Source: "_clonedFrom.HolderAddress(i)"
                MemberAccess to member HolderAddress
                   Type: function (uint256) view external returns (address)
                   Source: "_clonedFrom.HolderAddress"
                  Identifier _clonedFrom
                     Type: contract PassTokenManager
                     Source: "_clonedFrom"
                Identifier i
                   Type: uint256
                   Source: "i"
          ExpressionStatement
             Gas costs: [???]
             Source: "_balance = _clonedFrom.balanceOf(_holder)"
            Assignment using operator =
               Type: uint256
               Source: "_balance = _clonedFrom.balanceOf(_holder)"
              Identifier _balance
                 Type: uint256
                 Source: "_balance"
              FunctionCall
                 Type: uint256
                 Source: "_clonedFrom.balanceOf(_holder)"
                MemberAccess to member balanceOf
                   Type: function (address) view external returns (uint256)
                   Source: "_clonedFrom.balanceOf"
                  Identifier _clonedFrom
                     Type: contract PassTokenManager
                     Source: "_clonedFrom"
                Identifier _holder
                   Type: address
                   Source: "_holder"
          IfStatement
             Source: "if (balances[_holder] == 0 && _balance != 0) {\r\n                addHolder(_holder);\r\n                createTokens(_holder, _balance);\r\n            }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 339
               Source: "balances[_holder] == 0 && _balance != 0"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "balances[_holder] == 0"
                IndexAccess
                   Type: uint256
                   Source: "balances[_holder]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  Identifier _holder
                     Type: address
                     Source: "_holder"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "_balance != 0"
                Identifier _balance
                   Type: uint256
                   Source: "_balance"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            Block
               Source: "{\r\n                addHolder(_holder);\r\n                createTokens(_holder, _balance);\r\n            }"
              ExpressionStatement
                 Gas costs: 18
                 Source: "addHolder(_holder)"
                FunctionCall
                   Type: tuple()
                   Source: "addHolder(_holder)"
                  Identifier addHolder
                     Type: function (address)
                     Source: "addHolder"
                  Identifier _holder
                     Type: address
                     Source: "_holder"
              ExpressionStatement
                 Gas costs: 10
                 Source: "createTokens(_holder, _balance)"
                FunctionCall
                   Type: tuple()
                   Source: "createTokens(_holder, _balance)"
                  Identifier createTokens
                     Type: function (address,uint256)
                     Source: "createTokens"
                  Identifier _holder
                     Type: address
                     Source: "_holder"
                  Identifier _balance
                     Type: uint256
                     Source: "_balance"
  FunctionDefinition "addHolder"
     Source: "function addHolder(address _holder) internal {\r\n        \r\n        if (holderID[_holder] == 0) {\r\n            \r\n            uint _holderID = holders.length++;\r\n            holders[_holderID] = _holder;\r\n            holderID[_holder] = _holderID;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _holder)"
      VariableDeclaration "_holder"
         Type: address
         Source: "address _holder"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        \r\n        if (holderID[_holder] == 0) {\r\n            \r\n            uint _holderID = holders.length++;\r\n            holders[_holderID] = _holder;\r\n            holderID[_holder] = _holderID;\r\n        }\r\n    }"
      IfStatement
         Source: "if (holderID[_holder] == 0) {\r\n            \r\n            uint _holderID = holders.length++;\r\n            holders[_holderID] = _holder;\r\n            holderID[_holder] = _holderID;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 305
           Source: "holderID[_holder] == 0"
          IndexAccess
             Type: uint256
             Source: "holderID[_holder]"
            Identifier holderID
               Type: mapping(address => uint256)
               Source: "holderID"
            Identifier _holder
               Type: address
               Source: "_holder"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            \r\n            uint _holderID = holders.length++;\r\n            holders[_holderID] = _holder;\r\n            holderID[_holder] = _holderID;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 239
             Source: "uint _holderID = holders.length++"
            VariableDeclaration "_holderID"
               Type: uint256
               Source: "uint _holderID"
              ElementaryTypeName uint
                 Source: "uint"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "holders.length++"
              MemberAccess to member length
                 Type: uint256
                 Source: "holders.length"
                Identifier holders
                   Type: address[] storage ref
                   Source: "holders"
          ExpressionStatement
             Gas costs: 20556
             Source: "holders[_holderID] = _holder"
            Assignment using operator =
               Type: address
               Source: "holders[_holderID] = _holder"
              IndexAccess
                 Type: address
                 Source: "holders[_holderID]"
                Identifier holders
                   Type: address[] storage ref
                   Source: "holders"
                Identifier _holderID
                   Type: uint256
                   Source: "_holderID"
              Identifier _holder
                 Type: address
                 Source: "_holder"
          ExpressionStatement
             Gas costs: 20107
             Source: "holderID[_holder] = _holderID"
            Assignment using operator =
               Type: uint256
               Source: "holderID[_holder] = _holderID"
              IndexAccess
                 Type: uint256
                 Source: "holderID[_holder]"
                Identifier holderID
                   Type: mapping(address => uint256)
                   Source: "holderID"
                Identifier _holder
                   Type: address
                   Source: "_holder"
              Identifier _holderID
                 Type: uint256
                 Source: "_holderID"
  FunctionDefinition "createTokens"
     Source: "function createTokens(\r\n        address _holder, \r\n        uint _tokenAmount) internal {\r\n\r\n        balances[_holder] += _tokenAmount; \r\n        totalTokenSupply += _tokenAmount;\r\n        TokensCreated(msg.sender, _holder, _tokenAmount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _holder, \r\n        uint _tokenAmount)"
      VariableDeclaration "_holder"
         Type: address
         Source: "address _holder"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokenAmount"
         Type: uint256
         Source: "uint _tokenAmount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\r\n        balances[_holder] += _tokenAmount; \r\n        totalTokenSupply += _tokenAmount;\r\n        TokensCreated(msg.sender, _holder, _tokenAmount);\r\n    }"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[_holder] += _tokenAmount"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_holder] += _tokenAmount"
          IndexAccess
             Type: uint256
             Source: "balances[_holder]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _holder
               Type: address
               Source: "_holder"
          Identifier _tokenAmount
             Type: uint256
             Source: "_tokenAmount"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalTokenSupply += _tokenAmount"
        Assignment using operator +=
           Type: uint256
           Source: "totalTokenSupply += _tokenAmount"
          Identifier totalTokenSupply
             Type: uint256
             Source: "totalTokenSupply"
          Identifier _tokenAmount
             Type: uint256
             Source: "_tokenAmount"
      ExpressionStatement
         Gas costs: [???]
         Source: "TokensCreated(msg.sender, _holder, _tokenAmount)"
        FunctionCall
           Type: tuple()
           Source: "TokensCreated(msg.sender, _holder, _tokenAmount)"
          Identifier TokensCreated
             Type: function (address,address,uint256)
             Source: "TokensCreated"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _holder
             Type: address
             Source: "_holder"
          Identifier _tokenAmount
             Type: uint256
             Source: "_tokenAmount"
  FunctionDefinition "rewardTokensForClient" - public
     Source: "function rewardTokensForClient(\r\n        address _recipient, \r\n        uint _amount\r\n        ) external onlyClient returns (uint) {\r\n\r\n        uint _tokenAmount = TokenAmount(_amount, priceMultiplier(0), actualPriceDivisor(0));\r\n        if (_tokenAmount == 0) throw;\r\n\r\n        addHolder(_recipient);\r\n        createTokens(_recipient, _tokenAmount);\r\n\r\n        return _tokenAmount;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _recipient, \r\n        uint _amount\r\n        )"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "onlyClient"
       Gas costs: 0
       Source: "onlyClient"
      Identifier onlyClient
         Type: modifier ()
         Source: "onlyClient"
    Block
       Source: "{\r\n\r\n        uint _tokenAmount = TokenAmount(_amount, priceMultiplier(0), actualPriceDivisor(0));\r\n        if (_tokenAmount == 0) throw;\r\n\r\n        addHolder(_recipient);\r\n        createTokens(_recipient, _tokenAmount);\r\n\r\n        return _tokenAmount;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 40
         Source: "uint _tokenAmount = TokenAmount(_amount, priceMultiplier(0), actualPriceDivisor(0))"
        VariableDeclaration "_tokenAmount"
           Type: uint256
           Source: "uint _tokenAmount"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "TokenAmount(_amount, priceMultiplier(0), actualPriceDivisor(0))"
          Identifier TokenAmount
             Type: function (uint256,uint256,uint256) view returns (uint256)
             Source: "TokenAmount"
          Identifier _amount
             Type: uint256
             Source: "_amount"
          FunctionCall
             Type: uint256
             Source: "priceMultiplier(0)"
            Identifier priceMultiplier
               Type: function (uint256) view returns (uint256)
               Source: "priceMultiplier"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          FunctionCall
             Type: uint256
             Source: "actualPriceDivisor(0)"
            Identifier actualPriceDivisor
               Type: function (uint256) view returns (uint256)
               Source: "actualPriceDivisor"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      IfStatement
         Source: "if (_tokenAmount == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "_tokenAmount == 0"
          Identifier _tokenAmount
             Type: uint256
             Source: "_tokenAmount"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 18
         Source: "addHolder(_recipient)"
        FunctionCall
           Type: tuple()
           Source: "addHolder(_recipient)"
          Identifier addHolder
             Type: function (address)
             Source: "addHolder"
          Identifier _recipient
             Type: address
             Source: "_recipient"
      ExpressionStatement
         Gas costs: 21
         Source: "createTokens(_recipient, _tokenAmount)"
        FunctionCall
           Type: tuple()
           Source: "createTokens(_recipient, _tokenAmount)"
          Identifier createTokens
             Type: function (address,uint256)
             Source: "createTokens"
          Identifier _recipient
             Type: address
             Source: "_recipient"
          Identifier _tokenAmount
             Type: uint256
             Source: "_tokenAmount"
      Return
         Gas costs: 8
         Source: "return _tokenAmount"
        Identifier _tokenAmount
           Type: uint256
           Source: "_tokenAmount"
  FunctionDefinition "setFundingRules" - public
     Source: "function setFundingRules(\r\n        address _moderator,\r\n        uint _initialPriceMultiplier,\r\n        uint _amountToFund,\r\n        uint _minutesFundingPeriod, \r\n        uint _inflationRate,\r\n        uint _proposalID\r\n    ) external onlyClient {\r\n\r\n        if (_moderator == address(this)\r\n            || _moderator == Client()\r\n            || _amountToFund == 0\r\n            || _minutesFundingPeriod == 0\r\n            || fundings[_proposalID].totalWeiGiven != 0\r\n            ) throw;\r\n            \r\n        fundings[_proposalID].moderator = _moderator;\r\n\r\n        fundings[_proposalID].amountToFund = _amountToFund;\r\n        fundings[_proposalID].fundedAmount = 0;\r\n\r\n        if (_initialPriceMultiplier == 0) {\r\n            if (now < fundings[0].closingTime) {\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastProposalID)/actualPriceDivisor(lastProposalID);\r\n            } else {\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastFueledFundingID)/actualPriceDivisor(lastFueledFundingID);\r\n            }\r\n            fundings[0].initialPriceMultiplier = fundings[_proposalID].initialPriceMultiplier;\r\n        }\r\n        else {\r\n            fundings[_proposalID].initialPriceMultiplier = _initialPriceMultiplier;\r\n            fundings[0].initialPriceMultiplier = _initialPriceMultiplier;\r\n        }\r\n        \r\n        if (_inflationRate == 0) fundings[_proposalID].inflationRate = fundings[0].inflationRate;\r\n        else {\r\n            fundings[_proposalID].inflationRate = _inflationRate;\r\n            fundings[0].inflationRate = _inflationRate;\r\n        }\r\n        \r\n        fundings[_proposalID].startTime = now;\r\n        fundings[0].startTime = now;\r\n        \r\n        fundings[_proposalID].closingTime = now + _minutesFundingPeriod * 1 minutes;\r\n        fundings[0].closingTime = fundings[_proposalID].closingTime;\r\n        \r\n        fundings[_proposalID].totalWeiGiven = 0;\r\n        \r\n        lastProposalID = _proposalID;\r\n        \r\n        FundingRulesSet(_moderator, _proposalID,  _amountToFund, fundings[_proposalID].startTime, fundings[_proposalID].closingTime);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _moderator,\r\n        uint _initialPriceMultiplier,\r\n        uint _amountToFund,\r\n        uint _minutesFundingPeriod, \r\n        uint _inflationRate,\r\n        uint _proposalID\r\n    )"
      VariableDeclaration "_moderator"
         Type: address
         Source: "address _moderator"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_initialPriceMultiplier"
         Type: uint256
         Source: "uint _initialPriceMultiplier"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_amountToFund"
         Type: uint256
         Source: "uint _amountToFund"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_minutesFundingPeriod"
         Type: uint256
         Source: "uint _minutesFundingPeriod"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_inflationRate"
         Type: uint256
         Source: "uint _inflationRate"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyClient"
       Gas costs: 0
       Source: "onlyClient"
      Identifier onlyClient
         Type: modifier ()
         Source: "onlyClient"
    Block
       Source: "{\r\n\r\n        if (_moderator == address(this)\r\n            || _moderator == Client()\r\n            || _amountToFund == 0\r\n            || _minutesFundingPeriod == 0\r\n            || fundings[_proposalID].totalWeiGiven != 0\r\n            ) throw;\r\n            \r\n        fundings[_proposalID].moderator = _moderator;\r\n\r\n        fundings[_proposalID].amountToFund = _amountToFund;\r\n        fundings[_proposalID].fundedAmount = 0;\r\n\r\n        if (_initialPriceMultiplier == 0) {\r\n            if (now < fundings[0].closingTime) {\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastProposalID)/actualPriceDivisor(lastProposalID);\r\n            } else {\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastFueledFundingID)/actualPriceDivisor(lastFueledFundingID);\r\n            }\r\n            fundings[0].initialPriceMultiplier = fundings[_proposalID].initialPriceMultiplier;\r\n        }\r\n        else {\r\n            fundings[_proposalID].initialPriceMultiplier = _initialPriceMultiplier;\r\n            fundings[0].initialPriceMultiplier = _initialPriceMultiplier;\r\n        }\r\n        \r\n        if (_inflationRate == 0) fundings[_proposalID].inflationRate = fundings[0].inflationRate;\r\n        else {\r\n            fundings[_proposalID].inflationRate = _inflationRate;\r\n            fundings[0].inflationRate = _inflationRate;\r\n        }\r\n        \r\n        fundings[_proposalID].startTime = now;\r\n        fundings[0].startTime = now;\r\n        \r\n        fundings[_proposalID].closingTime = now + _minutesFundingPeriod * 1 minutes;\r\n        fundings[0].closingTime = fundings[_proposalID].closingTime;\r\n        \r\n        fundings[_proposalID].totalWeiGiven = 0;\r\n        \r\n        lastProposalID = _proposalID;\r\n        \r\n        FundingRulesSet(_moderator, _proposalID,  _amountToFund, fundings[_proposalID].startTime, fundings[_proposalID].closingTime);\r\n    }"
      IfStatement
         Source: "if (_moderator == address(this)\r\n            || _moderator == Client()\r\n            || _amountToFund == 0\r\n            || _minutesFundingPeriod == 0\r\n            || fundings[_proposalID].totalWeiGiven != 0\r\n            ) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 449
           Source: "_moderator == address(this)\r\n            || _moderator == Client()\r\n            || _amountToFund == 0\r\n            || _minutesFundingPeriod == 0\r\n            || fundings[_proposalID].totalWeiGiven != 0"
          BinaryOperation using operator ||
             Type: bool
             Source: "_moderator == address(this)\r\n            || _moderator == Client()\r\n            || _amountToFund == 0\r\n            || _minutesFundingPeriod == 0"
            BinaryOperation using operator ||
               Type: bool
               Source: "_moderator == address(this)\r\n            || _moderator == Client()\r\n            || _amountToFund == 0"
              BinaryOperation using operator ||
                 Type: bool
                 Source: "_moderator == address(this)\r\n            || _moderator == Client()"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "_moderator == address(this)"
                  Identifier _moderator
                     Type: address
                     Source: "_moderator"
                  FunctionCall
                     Type: address
                     Source: "address(this)"
                    ElementaryTypeNameExpression address
                       Type: type(address)
                       Source: "address"
                    Identifier this
                       Type: contract PassTokenManager
                       Source: "this"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "_moderator == Client()"
                  Identifier _moderator
                     Type: address
                     Source: "_moderator"
                  FunctionCall
                     Type: address
                     Source: "Client()"
                    Identifier Client
                       Type: function () view returns (address)
                       Source: "Client"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "_amountToFund == 0"
                Identifier _amountToFund
                   Type: uint256
                   Source: "_amountToFund"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "_minutesFundingPeriod == 0"
              Identifier _minutesFundingPeriod
                 Type: uint256
                 Source: "_minutesFundingPeriod"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          BinaryOperation using operator !=
             Type: bool
             Source: "fundings[_proposalID].totalWeiGiven != 0"
            MemberAccess to member totalWeiGiven
               Type: uint256
               Source: "fundings[_proposalID].totalWeiGiven"
              IndexAccess
                 Type: struct PassTokenManagerInterface.funding storage ref
                 Source: "fundings[_proposalID]"
                Identifier fundings
                   Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                   Source: "fundings"
                Identifier _proposalID
                   Type: uint256
                   Source: "_proposalID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20357
         Source: "fundings[_proposalID].moderator = _moderator"
        Assignment using operator =
           Type: address
           Source: "fundings[_proposalID].moderator = _moderator"
          MemberAccess to member moderator
             Type: address
             Source: "fundings[_proposalID].moderator"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
          Identifier _moderator
             Type: address
             Source: "_moderator"
      ExpressionStatement
         Gas costs: 20098
         Source: "fundings[_proposalID].amountToFund = _amountToFund"
        Assignment using operator =
           Type: uint256
           Source: "fundings[_proposalID].amountToFund = _amountToFund"
          MemberAccess to member amountToFund
             Type: uint256
             Source: "fundings[_proposalID].amountToFund"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
          Identifier _amountToFund
             Type: uint256
             Source: "_amountToFund"
      ExpressionStatement
         Gas costs: 5098
         Source: "fundings[_proposalID].fundedAmount = 0"
        Assignment using operator =
           Type: uint256
           Source: "fundings[_proposalID].fundedAmount = 0"
          MemberAccess to member fundedAmount
             Type: uint256
             Source: "fundings[_proposalID].fundedAmount"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      IfStatement
         Source: "if (_initialPriceMultiplier == 0) {\r\n            if (now < fundings[0].closingTime) {\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastProposalID)/actualPriceDivisor(lastProposalID);\r\n            } else {\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastFueledFundingID)/actualPriceDivisor(lastFueledFundingID);\r\n            }\r\n            fundings[0].initialPriceMultiplier = fundings[_proposalID].initialPriceMultiplier;\r\n        }\r\n        else {\r\n            fundings[_proposalID].initialPriceMultiplier = _initialPriceMultiplier;\r\n            fundings[0].initialPriceMultiplier = _initialPriceMultiplier;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "_initialPriceMultiplier == 0"
          Identifier _initialPriceMultiplier
             Type: uint256
             Source: "_initialPriceMultiplier"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            if (now < fundings[0].closingTime) {\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastProposalID)/actualPriceDivisor(lastProposalID);\r\n            } else {\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastFueledFundingID)/actualPriceDivisor(lastFueledFundingID);\r\n            }\r\n            fundings[0].initialPriceMultiplier = fundings[_proposalID].initialPriceMultiplier;\r\n        }"
          IfStatement
             Source: "if (now < fundings[0].closingTime) {\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastProposalID)/actualPriceDivisor(lastProposalID);\r\n            } else {\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastFueledFundingID)/actualPriceDivisor(lastFueledFundingID);\r\n            }"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 298
               Source: "now < fundings[0].closingTime"
              Identifier now
                 Type: uint256
                 Source: "now"
              MemberAccess to member closingTime
                 Type: uint256
                 Source: "fundings[0].closingTime"
                IndexAccess
                   Type: struct PassTokenManagerInterface.funding storage ref
                   Source: "fundings[0]"
                  Identifier fundings
                     Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                     Source: "fundings"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
            Block
               Source: "{\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastProposalID)/actualPriceDivisor(lastProposalID);\r\n            }"
              ExpressionStatement
                 Gas costs: 20573
                 Source: "fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastProposalID)/actualPriceDivisor(lastProposalID)"
                Assignment using operator =
                   Type: uint256
                   Source: "fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastProposalID)/actualPriceDivisor(lastProposalID)"
                  MemberAccess to member initialPriceMultiplier
                     Type: uint256
                     Source: "fundings[_proposalID].initialPriceMultiplier"
                    IndexAccess
                       Type: struct PassTokenManagerInterface.funding storage ref
                       Source: "fundings[_proposalID]"
                      Identifier fundings
                         Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                         Source: "fundings"
                      Identifier _proposalID
                         Type: uint256
                         Source: "_proposalID"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "100*priceMultiplier(lastProposalID)/actualPriceDivisor(lastProposalID)"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "100*priceMultiplier(lastProposalID)"
                      Literal, token: [no token] value: 100
                         Type: int_const 100
                         Source: "100"
                      FunctionCall
                         Type: uint256
                         Source: "priceMultiplier(lastProposalID)"
                        Identifier priceMultiplier
                           Type: function (uint256) view returns (uint256)
                           Source: "priceMultiplier"
                        Identifier lastProposalID
                           Type: uint256
                           Source: "lastProposalID"
                    FunctionCall
                       Type: uint256
                       Source: "actualPriceDivisor(lastProposalID)"
                      Identifier actualPriceDivisor
                         Type: function (uint256) view returns (uint256)
                         Source: "actualPriceDivisor"
                      Identifier lastProposalID
                         Type: uint256
                         Source: "lastProposalID"
            Block
               Source: "{\r\n                fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastFueledFundingID)/actualPriceDivisor(lastFueledFundingID);\r\n            }"
              ExpressionStatement
                 Gas costs: 20573
                 Source: "fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastFueledFundingID)/actualPriceDivisor(lastFueledFundingID)"
                Assignment using operator =
                   Type: uint256
                   Source: "fundings[_proposalID].initialPriceMultiplier = 100*priceMultiplier(lastFueledFundingID)/actualPriceDivisor(lastFueledFundingID)"
                  MemberAccess to member initialPriceMultiplier
                     Type: uint256
                     Source: "fundings[_proposalID].initialPriceMultiplier"
                    IndexAccess
                       Type: struct PassTokenManagerInterface.funding storage ref
                       Source: "fundings[_proposalID]"
                      Identifier fundings
                         Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                         Source: "fundings"
                      Identifier _proposalID
                         Type: uint256
                         Source: "_proposalID"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "100*priceMultiplier(lastFueledFundingID)/actualPriceDivisor(lastFueledFundingID)"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "100*priceMultiplier(lastFueledFundingID)"
                      Literal, token: [no token] value: 100
                         Type: int_const 100
                         Source: "100"
                      FunctionCall
                         Type: uint256
                         Source: "priceMultiplier(lastFueledFundingID)"
                        Identifier priceMultiplier
                           Type: function (uint256) view returns (uint256)
                           Source: "priceMultiplier"
                        Identifier lastFueledFundingID
                           Type: uint256
                           Source: "lastFueledFundingID"
                    FunctionCall
                       Type: uint256
                       Source: "actualPriceDivisor(lastFueledFundingID)"
                      Identifier actualPriceDivisor
                         Type: function (uint256) view returns (uint256)
                         Source: "actualPriceDivisor"
                      Identifier lastFueledFundingID
                         Type: uint256
                         Source: "lastFueledFundingID"
          ExpressionStatement
             Gas costs: 20388
             Source: "fundings[0].initialPriceMultiplier = fundings[_proposalID].initialPriceMultiplier"
            Assignment using operator =
               Type: uint256
               Source: "fundings[0].initialPriceMultiplier = fundings[_proposalID].initialPriceMultiplier"
              MemberAccess to member initialPriceMultiplier
                 Type: uint256
                 Source: "fundings[0].initialPriceMultiplier"
                IndexAccess
                   Type: struct PassTokenManagerInterface.funding storage ref
                   Source: "fundings[0]"
                  Identifier fundings
                     Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                     Source: "fundings"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              MemberAccess to member initialPriceMultiplier
                 Type: uint256
                 Source: "fundings[_proposalID].initialPriceMultiplier"
                IndexAccess
                   Type: struct PassTokenManagerInterface.funding storage ref
                   Source: "fundings[_proposalID]"
                  Identifier fundings
                     Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                     Source: "fundings"
                  Identifier _proposalID
                     Type: uint256
                     Source: "_proposalID"
        Block
           Source: "{\r\n            fundings[_proposalID].initialPriceMultiplier = _initialPriceMultiplier;\r\n            fundings[0].initialPriceMultiplier = _initialPriceMultiplier;\r\n        }"
          ExpressionStatement
             Gas costs: 20104
             Source: "fundings[_proposalID].initialPriceMultiplier = _initialPriceMultiplier"
            Assignment using operator =
               Type: uint256
               Source: "fundings[_proposalID].initialPriceMultiplier = _initialPriceMultiplier"
              MemberAccess to member initialPriceMultiplier
                 Type: uint256
                 Source: "fundings[_proposalID].initialPriceMultiplier"
                IndexAccess
                   Type: struct PassTokenManagerInterface.funding storage ref
                   Source: "fundings[_proposalID]"
                  Identifier fundings
                     Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                     Source: "fundings"
                  Identifier _proposalID
                     Type: uint256
                     Source: "_proposalID"
              Identifier _initialPriceMultiplier
                 Type: uint256
                 Source: "_initialPriceMultiplier"
          ExpressionStatement
             Gas costs: 20098
             Source: "fundings[0].initialPriceMultiplier = _initialPriceMultiplier"
            Assignment using operator =
               Type: uint256
               Source: "fundings[0].initialPriceMultiplier = _initialPriceMultiplier"
              MemberAccess to member initialPriceMultiplier
                 Type: uint256
                 Source: "fundings[0].initialPriceMultiplier"
                IndexAccess
                   Type: struct PassTokenManagerInterface.funding storage ref
                   Source: "fundings[0]"
                  Identifier fundings
                     Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                     Source: "fundings"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              Identifier _initialPriceMultiplier
                 Type: uint256
                 Source: "_initialPriceMultiplier"
      IfStatement
         Source: "if (_inflationRate == 0) fundings[_proposalID].inflationRate = fundings[0].inflationRate;\r\n        else {\r\n            fundings[_proposalID].inflationRate = _inflationRate;\r\n            fundings[0].inflationRate = _inflationRate;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "_inflationRate == 0"
          Identifier _inflationRate
             Type: uint256
             Source: "_inflationRate"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 20388
           Source: "fundings[_proposalID].inflationRate = fundings[0].inflationRate"
          Assignment using operator =
             Type: uint256
             Source: "fundings[_proposalID].inflationRate = fundings[0].inflationRate"
            MemberAccess to member inflationRate
               Type: uint256
               Source: "fundings[_proposalID].inflationRate"
              IndexAccess
                 Type: struct PassTokenManagerInterface.funding storage ref
                 Source: "fundings[_proposalID]"
                Identifier fundings
                   Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                   Source: "fundings"
                Identifier _proposalID
                   Type: uint256
                   Source: "_proposalID"
            MemberAccess to member inflationRate
               Type: uint256
               Source: "fundings[0].inflationRate"
              IndexAccess
                 Type: struct PassTokenManagerInterface.funding storage ref
                 Source: "fundings[0]"
                Identifier fundings
                   Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                   Source: "fundings"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
        Block
           Source: "{\r\n            fundings[_proposalID].inflationRate = _inflationRate;\r\n            fundings[0].inflationRate = _inflationRate;\r\n        }"
          ExpressionStatement
             Gas costs: 20104
             Source: "fundings[_proposalID].inflationRate = _inflationRate"
            Assignment using operator =
               Type: uint256
               Source: "fundings[_proposalID].inflationRate = _inflationRate"
              MemberAccess to member inflationRate
                 Type: uint256
                 Source: "fundings[_proposalID].inflationRate"
                IndexAccess
                   Type: struct PassTokenManagerInterface.funding storage ref
                   Source: "fundings[_proposalID]"
                  Identifier fundings
                     Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                     Source: "fundings"
                  Identifier _proposalID
                     Type: uint256
                     Source: "_proposalID"
              Identifier _inflationRate
                 Type: uint256
                 Source: "_inflationRate"
          ExpressionStatement
             Gas costs: 20098
             Source: "fundings[0].inflationRate = _inflationRate"
            Assignment using operator =
               Type: uint256
               Source: "fundings[0].inflationRate = _inflationRate"
              MemberAccess to member inflationRate
                 Type: uint256
                 Source: "fundings[0].inflationRate"
                IndexAccess
                   Type: struct PassTokenManagerInterface.funding storage ref
                   Source: "fundings[0]"
                  Identifier fundings
                     Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                     Source: "fundings"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              Identifier _inflationRate
                 Type: uint256
                 Source: "_inflationRate"
      ExpressionStatement
         Gas costs: 20103
         Source: "fundings[_proposalID].startTime = now"
        Assignment using operator =
           Type: uint256
           Source: "fundings[_proposalID].startTime = now"
          MemberAccess to member startTime
             Type: uint256
             Source: "fundings[_proposalID].startTime"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 20097
         Source: "fundings[0].startTime = now"
        Assignment using operator =
           Type: uint256
           Source: "fundings[0].startTime = now"
          MemberAccess to member startTime
             Type: uint256
             Source: "fundings[0].startTime"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[0]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 20111
         Source: "fundings[_proposalID].closingTime = now + _minutesFundingPeriod * 1 minutes"
        Assignment using operator =
           Type: uint256
           Source: "fundings[_proposalID].closingTime = now + _minutesFundingPeriod * 1 minutes"
          MemberAccess to member closingTime
             Type: uint256
             Source: "fundings[_proposalID].closingTime"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + _minutesFundingPeriod * 1 minutes"
            Identifier now
               Type: uint256
               Source: "now"
            BinaryOperation using operator *
               Type: uint256
               Source: "_minutesFundingPeriod * 1 minutes"
              Identifier _minutesFundingPeriod
                 Type: uint256
                 Source: "_minutesFundingPeriod"
              Literal, token: [no token] value: 1
                 Type: int_const 60
                 Source: "1 minutes"
      ExpressionStatement
         Gas costs: 20382
         Source: "fundings[0].closingTime = fundings[_proposalID].closingTime"
        Assignment using operator =
           Type: uint256
           Source: "fundings[0].closingTime = fundings[_proposalID].closingTime"
          MemberAccess to member closingTime
             Type: uint256
             Source: "fundings[0].closingTime"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[0]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          MemberAccess to member closingTime
             Type: uint256
             Source: "fundings[_proposalID].closingTime"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
      ExpressionStatement
         Gas costs: 5098
         Source: "fundings[_proposalID].totalWeiGiven = 0"
        Assignment using operator =
           Type: uint256
           Source: "fundings[_proposalID].totalWeiGiven = 0"
          MemberAccess to member totalWeiGiven
             Type: uint256
             Source: "fundings[_proposalID].totalWeiGiven"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 20014
         Source: "lastProposalID = _proposalID"
        Assignment using operator =
           Type: uint256
           Source: "lastProposalID = _proposalID"
          Identifier lastProposalID
             Type: uint256
             Source: "lastProposalID"
          Identifier _proposalID
             Type: uint256
             Source: "_proposalID"
      ExpressionStatement
         Gas costs: [???]
         Source: "FundingRulesSet(_moderator, _proposalID,  _amountToFund, fundings[_proposalID].startTime, fundings[_proposalID].closingTime)"
        FunctionCall
           Type: tuple()
           Source: "FundingRulesSet(_moderator, _proposalID,  _amountToFund, fundings[_proposalID].startTime, fundings[_proposalID].closingTime)"
          Identifier FundingRulesSet
             Type: function (address,uint256,uint256,uint256,uint256)
             Source: "FundingRulesSet"
          Identifier _moderator
             Type: address
             Source: "_moderator"
          Identifier _proposalID
             Type: uint256
             Source: "_proposalID"
          Identifier _amountToFund
             Type: uint256
             Source: "_amountToFund"
          MemberAccess to member startTime
             Type: uint256
             Source: "fundings[_proposalID].startTime"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
          MemberAccess to member closingTime
             Type: uint256
             Source: "fundings[_proposalID].closingTime"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
  FunctionDefinition "sale"
     Source: "function sale(\r\n        uint _proposalID,\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _saleDate,\r\n        bool _presale) internal returns (bool success) {\r\n\r\n        if (_saleDate == 0) _saleDate = now;\r\n\r\n        if (_saleDate > fundings[_proposalID].closingTime\r\n            || _saleDate < fundings[_proposalID].startTime\r\n            || fundings[_proposalID].totalWeiGiven + _amount > fundings[_proposalID].amountToFund) return;\r\n\r\n        uint _tokenAmount = TokenAmount(_amount, priceMultiplier(_proposalID), priceDivisor(_proposalID, _saleDate));\r\n        if (_tokenAmount == 0) return;\r\n        \r\n        addHolder(_recipient);\r\n        if (_presale) {\r\n            Given[_proposalID][_recipient].tokenAmount += _tokenAmount;\r\n        }\r\n        else createTokens(_recipient, _tokenAmount);\r\n\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint _proposalID,\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _saleDate,\r\n        bool _presale)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_saleDate"
         Type: uint256
         Source: "uint _saleDate"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_presale"
         Type: bool
         Source: "bool _presale"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n        if (_saleDate == 0) _saleDate = now;\r\n\r\n        if (_saleDate > fundings[_proposalID].closingTime\r\n            || _saleDate < fundings[_proposalID].startTime\r\n            || fundings[_proposalID].totalWeiGiven + _amount > fundings[_proposalID].amountToFund) return;\r\n\r\n        uint _tokenAmount = TokenAmount(_amount, priceMultiplier(_proposalID), priceDivisor(_proposalID, _saleDate));\r\n        if (_tokenAmount == 0) return;\r\n        \r\n        addHolder(_recipient);\r\n        if (_presale) {\r\n            Given[_proposalID][_recipient].tokenAmount += _tokenAmount;\r\n        }\r\n        else createTokens(_recipient, _tokenAmount);\r\n\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (_saleDate == 0) _saleDate = now"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "_saleDate == 0"
          Identifier _saleDate
             Type: uint256
             Source: "_saleDate"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 7
           Source: "_saleDate = now"
          Assignment using operator =
             Type: uint256
             Source: "_saleDate = now"
            Identifier _saleDate
               Type: uint256
               Source: "_saleDate"
            Identifier now
               Type: uint256
               Source: "now"
      IfStatement
         Source: "if (_saleDate > fundings[_proposalID].closingTime\r\n            || _saleDate < fundings[_proposalID].startTime\r\n            || fundings[_proposalID].totalWeiGiven + _amount > fundings[_proposalID].amountToFund) return;"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 1225
           Source: "_saleDate > fundings[_proposalID].closingTime\r\n            || _saleDate < fundings[_proposalID].startTime\r\n            || fundings[_proposalID].totalWeiGiven + _amount > fundings[_proposalID].amountToFund"
          BinaryOperation using operator ||
             Type: bool
             Source: "_saleDate > fundings[_proposalID].closingTime\r\n            || _saleDate < fundings[_proposalID].startTime"
            BinaryOperation using operator >
               Type: bool
               Source: "_saleDate > fundings[_proposalID].closingTime"
              Identifier _saleDate
                 Type: uint256
                 Source: "_saleDate"
              MemberAccess to member closingTime
                 Type: uint256
                 Source: "fundings[_proposalID].closingTime"
                IndexAccess
                   Type: struct PassTokenManagerInterface.funding storage ref
                   Source: "fundings[_proposalID]"
                  Identifier fundings
                     Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                     Source: "fundings"
                  Identifier _proposalID
                     Type: uint256
                     Source: "_proposalID"
            BinaryOperation using operator <
               Type: bool
               Source: "_saleDate < fundings[_proposalID].startTime"
              Identifier _saleDate
                 Type: uint256
                 Source: "_saleDate"
              MemberAccess to member startTime
                 Type: uint256
                 Source: "fundings[_proposalID].startTime"
                IndexAccess
                   Type: struct PassTokenManagerInterface.funding storage ref
                   Source: "fundings[_proposalID]"
                  Identifier fundings
                     Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                     Source: "fundings"
                  Identifier _proposalID
                     Type: uint256
                     Source: "_proposalID"
          BinaryOperation using operator >
             Type: bool
             Source: "fundings[_proposalID].totalWeiGiven + _amount > fundings[_proposalID].amountToFund"
            BinaryOperation using operator +
               Type: uint256
               Source: "fundings[_proposalID].totalWeiGiven + _amount"
              MemberAccess to member totalWeiGiven
                 Type: uint256
                 Source: "fundings[_proposalID].totalWeiGiven"
                IndexAccess
                   Type: struct PassTokenManagerInterface.funding storage ref
                   Source: "fundings[_proposalID]"
                  Identifier fundings
                     Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                     Source: "fundings"
                  Identifier _proposalID
                     Type: uint256
                     Source: "_proposalID"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
            MemberAccess to member amountToFund
               Type: uint256
               Source: "fundings[_proposalID].amountToFund"
              IndexAccess
                 Type: struct PassTokenManagerInterface.funding storage ref
                 Source: "fundings[_proposalID]"
                Identifier fundings
                   Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                   Source: "fundings"
                Identifier _proposalID
                   Type: uint256
                   Source: "_proposalID"
        Return
           Gas costs: 11
           Source: "return;"
      VariableDeclarationStatement
         Gas costs: 65
         Source: "uint _tokenAmount = TokenAmount(_amount, priceMultiplier(_proposalID), priceDivisor(_proposalID, _saleDate))"
        VariableDeclaration "_tokenAmount"
           Type: uint256
           Source: "uint _tokenAmount"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "TokenAmount(_amount, priceMultiplier(_proposalID), priceDivisor(_proposalID, _saleDate))"
          Identifier TokenAmount
             Type: function (uint256,uint256,uint256) view returns (uint256)
             Source: "TokenAmount"
          Identifier _amount
             Type: uint256
             Source: "_amount"
          FunctionCall
             Type: uint256
             Source: "priceMultiplier(_proposalID)"
            Identifier priceMultiplier
               Type: function (uint256) view returns (uint256)
               Source: "priceMultiplier"
            Identifier _proposalID
               Type: uint256
               Source: "_proposalID"
          FunctionCall
             Type: uint256
             Source: "priceDivisor(_proposalID, _saleDate)"
            Identifier priceDivisor
               Type: function (uint256,uint256) view returns (uint256)
               Source: "priceDivisor"
            Identifier _proposalID
               Type: uint256
               Source: "_proposalID"
            Identifier _saleDate
               Type: uint256
               Source: "_saleDate"
      IfStatement
         Source: "if (_tokenAmount == 0) return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "_tokenAmount == 0"
          Identifier _tokenAmount
             Type: uint256
             Source: "_tokenAmount"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 18
         Source: "addHolder(_recipient)"
        FunctionCall
           Type: tuple()
           Source: "addHolder(_recipient)"
          Identifier addHolder
             Type: function (address)
             Source: "addHolder"
          Identifier _recipient
             Type: address
             Source: "_recipient"
      IfStatement
         Source: "if (_presale) {\r\n            Given[_proposalID][_recipient].tokenAmount += _tokenAmount;\r\n        }\r\n        else createTokens(_recipient, _tokenAmount)"
        Identifier _presale
           Type: bool
           Gas costs: 3
           Source: "_presale"
        Block
           Source: "{\r\n            Given[_proposalID][_recipient].tokenAmount += _tokenAmount;\r\n        }"
          ExpressionStatement
             Gas costs: 20413
             Source: "Given[_proposalID][_recipient].tokenAmount += _tokenAmount"
            Assignment using operator +=
               Type: uint256
               Source: "Given[_proposalID][_recipient].tokenAmount += _tokenAmount"
              MemberAccess to member tokenAmount
                 Type: uint256
                 Source: "Given[_proposalID][_recipient].tokenAmount"
                IndexAccess
                   Type: struct PassTokenManagerInterface.amountsGiven storage ref
                   Source: "Given[_proposalID][_recipient]"
                  IndexAccess
                     Type: mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref)
                     Source: "Given[_proposalID]"
                    Identifier Given
                       Type: mapping(uint256 => mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref))
                       Source: "Given"
                    Identifier _proposalID
                       Type: uint256
                       Source: "_proposalID"
                  Identifier _recipient
                     Type: address
                     Source: "_recipient"
              Identifier _tokenAmount
                 Type: uint256
                 Source: "_tokenAmount"
        ExpressionStatement
           Gas costs: 21
           Source: "createTokens(_recipient, _tokenAmount)"
          FunctionCall
             Type: tuple()
             Source: "createTokens(_recipient, _tokenAmount)"
            Identifier createTokens
               Type: function (address,uint256)
               Source: "createTokens"
            Identifier _recipient
               Type: address
               Source: "_recipient"
            Identifier _tokenAmount
               Type: uint256
               Source: "_tokenAmount"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "closeFunding"
     Source: "function closeFunding(uint _proposalID) internal {\r\n        fundings[_proposalID].fundedAmount = fundings[_proposalID].totalWeiGiven;\r\n        lastFueledFundingID = _proposalID;\r\n        fundings[_proposalID].closingTime = now;\r\n        FundingFueled(_proposalID, fundings[_proposalID].fundedAmount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _proposalID)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        fundings[_proposalID].fundedAmount = fundings[_proposalID].totalWeiGiven;\r\n        lastFueledFundingID = _proposalID;\r\n        fundings[_proposalID].closingTime = now;\r\n        FundingFueled(_proposalID, fundings[_proposalID].fundedAmount);\r\n    }"
      ExpressionStatement
         Gas costs: 20388
         Source: "fundings[_proposalID].fundedAmount = fundings[_proposalID].totalWeiGiven"
        Assignment using operator =
           Type: uint256
           Source: "fundings[_proposalID].fundedAmount = fundings[_proposalID].totalWeiGiven"
          MemberAccess to member fundedAmount
             Type: uint256
             Source: "fundings[_proposalID].fundedAmount"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
          MemberAccess to member totalWeiGiven
             Type: uint256
             Source: "fundings[_proposalID].totalWeiGiven"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
      ExpressionStatement
         Gas costs: 20014
         Source: "lastFueledFundingID = _proposalID"
        Assignment using operator =
           Type: uint256
           Source: "lastFueledFundingID = _proposalID"
          Identifier lastFueledFundingID
             Type: uint256
             Source: "lastFueledFundingID"
          Identifier _proposalID
             Type: uint256
             Source: "_proposalID"
      ExpressionStatement
         Gas costs: 20097
         Source: "fundings[_proposalID].closingTime = now"
        Assignment using operator =
           Type: uint256
           Source: "fundings[_proposalID].closingTime = now"
          MemberAccess to member closingTime
             Type: uint256
             Source: "fundings[_proposalID].closingTime"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: [???]
         Source: "FundingFueled(_proposalID, fundings[_proposalID].fundedAmount)"
        FunctionCall
           Type: tuple()
           Source: "FundingFueled(_proposalID, fundings[_proposalID].fundedAmount)"
          Identifier FundingFueled
             Type: function (uint256,uint256)
             Source: "FundingFueled"
          Identifier _proposalID
             Type: uint256
             Source: "_proposalID"
          MemberAccess to member fundedAmount
             Type: uint256
             Source: "fundings[_proposalID].fundedAmount"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
  FunctionDefinition "sendPendingAmounts" - public
     Source: "function sendPendingAmounts(        \r\n        uint _from,\r\n        uint _to,\r\n        address _buyer) returns (bool) {\r\n        \r\n        if (_from == 0) _from = 1;\r\n        if (_to == 0) _to = lastProposalID;\r\n        if (_buyer == 0) _buyer = msg.sender;\r\n\r\n        uint _amount;\r\n        uint _tokenAmount;\r\n        \r\n        for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (now > fundings[i].closingTime && Given[i][_buyer].weiAmount != 0) {\r\n                \r\n                if (fundings[i].fundedAmount == 0) _amount += Given[i][_buyer].weiAmount;\r\n                else _tokenAmount += Given[i][_buyer].tokenAmount;\r\n\r\n                fundings[i].totalWeiGiven -= Given[i][_buyer].weiAmount;\r\n                Given[i][_buyer].tokenAmount = 0;\r\n                Given[i][_buyer].weiAmount = 0;\r\n            }\r\n        }\r\n\r\n        if (_tokenAmount > 0) {\r\n            createTokens(_buyer, _tokenAmount);\r\n            return true;\r\n        }\r\n        \r\n        if (_amount > 0) {\r\n            if (!_buyer.send(_amount)) throw;\r\n            Refund(_buyer, _amount);\r\n        } else return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(        \r\n        uint _from,\r\n        uint _to,\r\n        address _buyer)"
      VariableDeclaration "_from"
         Type: uint256
         Source: "uint _from"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_to"
         Type: uint256
         Source: "uint _to"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_buyer"
         Type: address
         Source: "address _buyer"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        \r\n        if (_from == 0) _from = 1;\r\n        if (_to == 0) _to = lastProposalID;\r\n        if (_buyer == 0) _buyer = msg.sender;\r\n\r\n        uint _amount;\r\n        uint _tokenAmount;\r\n        \r\n        for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (now > fundings[i].closingTime && Given[i][_buyer].weiAmount != 0) {\r\n                \r\n                if (fundings[i].fundedAmount == 0) _amount += Given[i][_buyer].weiAmount;\r\n                else _tokenAmount += Given[i][_buyer].tokenAmount;\r\n\r\n                fundings[i].totalWeiGiven -= Given[i][_buyer].weiAmount;\r\n                Given[i][_buyer].tokenAmount = 0;\r\n                Given[i][_buyer].weiAmount = 0;\r\n            }\r\n        }\r\n\r\n        if (_tokenAmount > 0) {\r\n            createTokens(_buyer, _tokenAmount);\r\n            return true;\r\n        }\r\n        \r\n        if (_amount > 0) {\r\n            if (!_buyer.send(_amount)) throw;\r\n            Refund(_buyer, _amount);\r\n        } else return true;\r\n    }"
      IfStatement
         Source: "if (_from == 0) _from = 1"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "_from == 0"
          Identifier _from
             Type: uint256
             Source: "_from"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 8
           Source: "_from = 1"
          Assignment using operator =
             Type: uint256
             Source: "_from = 1"
            Identifier _from
               Type: uint256
               Source: "_from"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      IfStatement
         Source: "if (_to == 0) _to = lastProposalID"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "_to == 0"
          Identifier _to
             Type: uint256
             Source: "_to"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 208
           Source: "_to = lastProposalID"
          Assignment using operator =
             Type: uint256
             Source: "_to = lastProposalID"
            Identifier _to
               Type: uint256
               Source: "_to"
            Identifier lastProposalID
               Type: uint256
               Source: "lastProposalID"
      IfStatement
         Source: "if (_buyer == 0) _buyer = msg.sender"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 15
           Source: "_buyer == 0"
          Identifier _buyer
             Type: address
             Source: "_buyer"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 7
           Source: "_buyer = msg.sender"
          Assignment using operator =
             Type: address
             Source: "_buyer = msg.sender"
            Identifier _buyer
               Type: address
               Source: "_buyer"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint _amount"
        VariableDeclaration "_amount"
           Type: uint256
           Source: "uint _amount"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint _tokenAmount"
        VariableDeclaration "_tokenAmount"
           Type: uint256
           Source: "uint _tokenAmount"
          ElementaryTypeName uint
             Source: "uint"
      ForStatement
         Source: "for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (now > fundings[i].closingTime && Given[i][_buyer].weiAmount != 0) {\r\n                \r\n                if (fundings[i].fundedAmount == 0) _amount += Given[i][_buyer].weiAmount;\r\n                else _tokenAmount += Given[i][_buyer].tokenAmount;\r\n\r\n                fundings[i].totalWeiGiven -= Given[i][_buyer].weiAmount;\r\n                Given[i][_buyer].tokenAmount = 0;\r\n                Given[i][_buyer].weiAmount = 0;\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = _from"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Identifier _from
             Type: uint256
             Source: "_from"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 12
           Source: "i <= _to"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier _to
             Type: uint256
             Source: "_to"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n\r\n            if (now > fundings[i].closingTime && Given[i][_buyer].weiAmount != 0) {\r\n                \r\n                if (fundings[i].fundedAmount == 0) _amount += Given[i][_buyer].weiAmount;\r\n                else _tokenAmount += Given[i][_buyer].tokenAmount;\r\n\r\n                fundings[i].totalWeiGiven -= Given[i][_buyer].weiAmount;\r\n                Given[i][_buyer].tokenAmount = 0;\r\n                Given[i][_buyer].weiAmount = 0;\r\n            }\r\n        }"
          IfStatement
             Source: "if (now > fundings[i].closingTime && Given[i][_buyer].weiAmount != 0) {\r\n                \r\n                if (fundings[i].fundedAmount == 0) _amount += Given[i][_buyer].weiAmount;\r\n                else _tokenAmount += Given[i][_buyer].tokenAmount;\r\n\r\n                fundings[i].totalWeiGiven -= Given[i][_buyer].weiAmount;\r\n                Given[i][_buyer].tokenAmount = 0;\r\n                Given[i][_buyer].weiAmount = 0;\r\n            }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 712
               Source: "now > fundings[i].closingTime && Given[i][_buyer].weiAmount != 0"
              BinaryOperation using operator >
                 Type: bool
                 Source: "now > fundings[i].closingTime"
                Identifier now
                   Type: uint256
                   Source: "now"
                MemberAccess to member closingTime
                   Type: uint256
                   Source: "fundings[i].closingTime"
                  IndexAccess
                     Type: struct PassTokenManagerInterface.funding storage ref
                     Source: "fundings[i]"
                    Identifier fundings
                       Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                       Source: "fundings"
                    Identifier i
                       Type: uint256
                       Source: "i"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "Given[i][_buyer].weiAmount != 0"
                MemberAccess to member weiAmount
                   Type: uint256
                   Source: "Given[i][_buyer].weiAmount"
                  IndexAccess
                     Type: struct PassTokenManagerInterface.amountsGiven storage ref
                     Source: "Given[i][_buyer]"
                    IndexAccess
                       Type: mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref)
                       Source: "Given[i]"
                      Identifier Given
                         Type: mapping(uint256 => mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref))
                         Source: "Given"
                      Identifier i
                         Type: uint256
                         Source: "i"
                    Identifier _buyer
                       Type: address
                       Source: "_buyer"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            Block
               Source: "{\r\n                \r\n                if (fundings[i].fundedAmount == 0) _amount += Given[i][_buyer].weiAmount;\r\n                else _tokenAmount += Given[i][_buyer].tokenAmount;\r\n\r\n                fundings[i].totalWeiGiven -= Given[i][_buyer].weiAmount;\r\n                Given[i][_buyer].tokenAmount = 0;\r\n                Given[i][_buyer].weiAmount = 0;\r\n            }"
              IfStatement
                 Source: "if (fundings[i].fundedAmount == 0) _amount += Given[i][_buyer].weiAmount;\r\n                else _tokenAmount += Given[i][_buyer].tokenAmount"
                BinaryOperation using operator ==
                   Type: bool
                   Gas costs: 299
                   Source: "fundings[i].fundedAmount == 0"
                  MemberAccess to member fundedAmount
                     Type: uint256
                     Source: "fundings[i].fundedAmount"
                    IndexAccess
                       Type: struct PassTokenManagerInterface.funding storage ref
                       Source: "fundings[i]"
                      Identifier fundings
                         Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                         Source: "fundings"
                      Identifier i
                         Type: uint256
                         Source: "i"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                ExpressionStatement
                   Gas costs: 394
                   Source: "_amount += Given[i][_buyer].weiAmount"
                  Assignment using operator +=
                     Type: uint256
                     Source: "_amount += Given[i][_buyer].weiAmount"
                    Identifier _amount
                       Type: uint256
                       Source: "_amount"
                    MemberAccess to member weiAmount
                       Type: uint256
                       Source: "Given[i][_buyer].weiAmount"
                      IndexAccess
                         Type: struct PassTokenManagerInterface.amountsGiven storage ref
                         Source: "Given[i][_buyer]"
                        IndexAccess
                           Type: mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref)
                           Source: "Given[i]"
                          Identifier Given
                             Type: mapping(uint256 => mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref))
                             Source: "Given"
                          Identifier i
                             Type: uint256
                             Source: "i"
                        Identifier _buyer
                           Type: address
                           Source: "_buyer"
                ExpressionStatement
                   Gas costs: 394
                   Source: "_tokenAmount += Given[i][_buyer].tokenAmount"
                  Assignment using operator +=
                     Type: uint256
                     Source: "_tokenAmount += Given[i][_buyer].tokenAmount"
                    Identifier _tokenAmount
                       Type: uint256
                       Source: "_tokenAmount"
                    MemberAccess to member tokenAmount
                       Type: uint256
                       Source: "Given[i][_buyer].tokenAmount"
                      IndexAccess
                         Type: struct PassTokenManagerInterface.amountsGiven storage ref
                         Source: "Given[i][_buyer]"
                        IndexAccess
                           Type: mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref)
                           Source: "Given[i]"
                          Identifier Given
                             Type: mapping(uint256 => mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref))
                             Source: "Given"
                          Identifier i
                             Type: uint256
                             Source: "i"
                        Identifier _buyer
                           Type: address
                           Source: "_buyer"
              ExpressionStatement
                 Gas costs: 20697
                 Source: "fundings[i].totalWeiGiven -= Given[i][_buyer].weiAmount"
                Assignment using operator -=
                   Type: uint256
                   Source: "fundings[i].totalWeiGiven -= Given[i][_buyer].weiAmount"
                  MemberAccess to member totalWeiGiven
                     Type: uint256
                     Source: "fundings[i].totalWeiGiven"
                    IndexAccess
                       Type: struct PassTokenManagerInterface.funding storage ref
                       Source: "fundings[i]"
                      Identifier fundings
                         Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                         Source: "fundings"
                      Identifier i
                         Type: uint256
                         Source: "i"
                  MemberAccess to member weiAmount
                     Type: uint256
                     Source: "Given[i][_buyer].weiAmount"
                    IndexAccess
                       Type: struct PassTokenManagerInterface.amountsGiven storage ref
                       Source: "Given[i][_buyer]"
                      IndexAccess
                         Type: mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref)
                         Source: "Given[i]"
                        Identifier Given
                           Type: mapping(uint256 => mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref))
                           Source: "Given"
                        Identifier i
                           Type: uint256
                           Source: "i"
                      Identifier _buyer
                         Type: address
                         Source: "_buyer"
              ExpressionStatement
                 Gas costs: 5188
                 Source: "Given[i][_buyer].tokenAmount = 0"
                Assignment using operator =
                   Type: uint256
                   Source: "Given[i][_buyer].tokenAmount = 0"
                  MemberAccess to member tokenAmount
                     Type: uint256
                     Source: "Given[i][_buyer].tokenAmount"
                    IndexAccess
                       Type: struct PassTokenManagerInterface.amountsGiven storage ref
                       Source: "Given[i][_buyer]"
                      IndexAccess
                         Type: mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref)
                         Source: "Given[i]"
                        Identifier Given
                           Type: mapping(uint256 => mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref))
                           Source: "Given"
                        Identifier i
                           Type: uint256
                           Source: "i"
                      Identifier _buyer
                         Type: address
                         Source: "_buyer"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              ExpressionStatement
                 Gas costs: 5188
                 Source: "Given[i][_buyer].weiAmount = 0"
                Assignment using operator =
                   Type: uint256
                   Source: "Given[i][_buyer].weiAmount = 0"
                  MemberAccess to member weiAmount
                     Type: uint256
                     Source: "Given[i][_buyer].weiAmount"
                    IndexAccess
                       Type: struct PassTokenManagerInterface.amountsGiven storage ref
                       Source: "Given[i][_buyer]"
                      IndexAccess
                         Type: mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref)
                         Source: "Given[i]"
                        Identifier Given
                           Type: mapping(uint256 => mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref))
                           Source: "Given"
                        Identifier i
                           Type: uint256
                           Source: "i"
                      Identifier _buyer
                         Type: address
                         Source: "_buyer"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
      IfStatement
         Source: "if (_tokenAmount > 0) {\r\n            createTokens(_buyer, _tokenAmount);\r\n            return true;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "_tokenAmount > 0"
          Identifier _tokenAmount
             Type: uint256
             Source: "_tokenAmount"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            createTokens(_buyer, _tokenAmount);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 21
             Source: "createTokens(_buyer, _tokenAmount)"
            FunctionCall
               Type: tuple()
               Source: "createTokens(_buyer, _tokenAmount)"
              Identifier createTokens
                 Type: function (address,uint256)
                 Source: "createTokens"
              Identifier _buyer
                 Type: address
                 Source: "_buyer"
              Identifier _tokenAmount
                 Type: uint256
                 Source: "_tokenAmount"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      IfStatement
         Source: "if (_amount > 0) {\r\n            if (!_buyer.send(_amount)) throw;\r\n            Refund(_buyer, _amount);\r\n        } else return true"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "_amount > 0"
          Identifier _amount
             Type: uint256
             Source: "_amount"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            if (!_buyer.send(_amount)) throw;\r\n            Refund(_buyer, _amount);\r\n        }"
          IfStatement
             Source: "if (!_buyer.send(_amount)) throw"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: [???]
               Source: "!_buyer.send(_amount)"
              FunctionCall
                 Type: bool
                 Source: "_buyer.send(_amount)"
                MemberAccess to member send
                   Type: function (uint256) returns (bool)
                   Source: "_buyer.send"
                  Identifier _buyer
                     Type: address
                     Source: "_buyer"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
            Throw
               Gas costs: 6
               Source: "throw"
          ExpressionStatement
             Gas costs: [???]
             Source: "Refund(_buyer, _amount)"
            FunctionCall
               Type: tuple()
               Source: "Refund(_buyer, _amount)"
              Identifier Refund
                 Type: function (address,uint256)
                 Source: "Refund"
              Identifier _buyer
                 Type: address
                 Source: "_buyer"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
        Return
           Gas costs: 19
           Source: "return true"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "withdrawPendingAmounts" - public
     Source: "function withdrawPendingAmounts() returns (bool) {\r\n        \r\n        return sendPendingAmounts(0, 0, msg.sender);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        \r\n        return sendPendingAmounts(0, 0, msg.sender);\r\n    }"
      Return
         Gas costs: 28
         Source: "return sendPendingAmounts(0, 0, msg.sender)"
        FunctionCall
           Type: bool
           Source: "sendPendingAmounts(0, 0, msg.sender)"
          Identifier sendPendingAmounts
             Type: function (uint256,uint256,address) returns (bool)
             Source: "sendPendingAmounts"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "setFundingStartTime" - public
     Source: "function setFundingStartTime(uint _proposalID, uint _startTime) external {\r\n        if ((msg.sender !=  fundings[_proposalID].moderator) || now > fundings[_proposalID].closingTime) throw;\r\n        fundings[_proposalID].startTime = _startTime;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _proposalID, uint _startTime)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_startTime"
         Type: uint256
         Source: "uint _startTime"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if ((msg.sender !=  fundings[_proposalID].moderator) || now > fundings[_proposalID].closingTime) throw;\r\n        fundings[_proposalID].startTime = _startTime;\r\n    }"
      IfStatement
         Source: "if ((msg.sender !=  fundings[_proposalID].moderator) || now > fundings[_proposalID].closingTime) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 666
           Source: "(msg.sender !=  fundings[_proposalID].moderator) || now > fundings[_proposalID].closingTime"
          TupleExpression
             Type: bool
             Source: "(msg.sender !=  fundings[_proposalID].moderator)"
            BinaryOperation using operator !=
               Type: bool
               Source: "msg.sender !=  fundings[_proposalID].moderator"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              MemberAccess to member moderator
                 Type: address
                 Source: "fundings[_proposalID].moderator"
                IndexAccess
                   Type: struct PassTokenManagerInterface.funding storage ref
                   Source: "fundings[_proposalID]"
                  Identifier fundings
                     Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                     Source: "fundings"
                  Identifier _proposalID
                     Type: uint256
                     Source: "_proposalID"
          BinaryOperation using operator >
             Type: bool
             Source: "now > fundings[_proposalID].closingTime"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member closingTime
               Type: uint256
               Source: "fundings[_proposalID].closingTime"
              IndexAccess
                 Type: struct PassTokenManagerInterface.funding storage ref
                 Source: "fundings[_proposalID]"
                Identifier fundings
                   Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                   Source: "fundings"
                Identifier _proposalID
                   Type: uint256
                   Source: "_proposalID"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20104
         Source: "fundings[_proposalID].startTime = _startTime"
        Assignment using operator =
           Type: uint256
           Source: "fundings[_proposalID].startTime = _startTime"
          MemberAccess to member startTime
             Type: uint256
             Source: "fundings[_proposalID].startTime"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
          Identifier _startTime
             Type: uint256
             Source: "_startTime"
  FunctionDefinition "setFundingFueled" - public
     Source: "function setFundingFueled(uint _proposalID) external {\r\n\r\n        if ((msg.sender !=  fundings[_proposalID].moderator) || now > fundings[_proposalID].closingTime) throw;\r\n\r\n        closeFunding(_proposalID);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _proposalID)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\r\n        if ((msg.sender !=  fundings[_proposalID].moderator) || now > fundings[_proposalID].closingTime) throw;\r\n\r\n        closeFunding(_proposalID);\r\n    }"
      IfStatement
         Source: "if ((msg.sender !=  fundings[_proposalID].moderator) || now > fundings[_proposalID].closingTime) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 666
           Source: "(msg.sender !=  fundings[_proposalID].moderator) || now > fundings[_proposalID].closingTime"
          TupleExpression
             Type: bool
             Source: "(msg.sender !=  fundings[_proposalID].moderator)"
            BinaryOperation using operator !=
               Type: bool
               Source: "msg.sender !=  fundings[_proposalID].moderator"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              MemberAccess to member moderator
                 Type: address
                 Source: "fundings[_proposalID].moderator"
                IndexAccess
                   Type: struct PassTokenManagerInterface.funding storage ref
                   Source: "fundings[_proposalID]"
                  Identifier fundings
                     Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                     Source: "fundings"
                  Identifier _proposalID
                     Type: uint256
                     Source: "_proposalID"
          BinaryOperation using operator >
             Type: bool
             Source: "now > fundings[_proposalID].closingTime"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member closingTime
               Type: uint256
               Source: "fundings[_proposalID].closingTime"
              IndexAccess
                 Type: struct PassTokenManagerInterface.funding storage ref
                 Source: "fundings[_proposalID]"
                Identifier fundings
                   Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                   Source: "fundings"
                Identifier _proposalID
                   Type: uint256
                   Source: "_proposalID"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 7
         Source: "closeFunding(_proposalID)"
        FunctionCall
           Type: tuple()
           Source: "closeFunding(_proposalID)"
          Identifier closeFunding
             Type: function (uint256)
             Source: "closeFunding"
          Identifier _proposalID
             Type: uint256
             Source: "_proposalID"
  FunctionDefinition "ableTransfer" - public
     Source: "function ableTransfer() onlyClient {\r\n        if (!transferable) {\r\n            transferable = true;\r\n            TransferAble();\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyClient"
       Gas costs: 0
       Source: "onlyClient"
      Identifier onlyClient
         Type: modifier ()
         Source: "onlyClient"
    Block
       Source: "{\r\n        if (!transferable) {\r\n            transferable = true;\r\n            TransferAble();\r\n        }\r\n    }"
      IfStatement
         Source: "if (!transferable) {\r\n            transferable = true;\r\n            TransferAble();\r\n        }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 292
           Source: "!transferable"
          Identifier transferable
             Type: bool
             Source: "transferable"
        Block
           Source: "{\r\n            transferable = true;\r\n            TransferAble();\r\n        }"
          ExpressionStatement
             Gas costs: 20317
             Source: "transferable = true"
            Assignment using operator =
               Type: bool
               Source: "transferable = true"
              Identifier transferable
                 Type: bool
                 Source: "transferable"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
          ExpressionStatement
             Gas costs: 786
             Source: "TransferAble()"
            FunctionCall
               Type: tuple()
               Source: "TransferAble()"
              Identifier TransferAble
                 Type: function ()
                 Source: "TransferAble"
  FunctionDefinition "disableTransfer" - public
     Source: "function disableTransfer() onlyClient {\r\n        if (transferable) {\r\n            transferable = false;\r\n            TransferDisable();\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyClient"
       Gas costs: 0
       Source: "onlyClient"
      Identifier onlyClient
         Type: modifier ()
         Source: "onlyClient"
    Block
       Source: "{\r\n        if (transferable) {\r\n            transferable = false;\r\n            TransferDisable();\r\n        }\r\n    }"
      IfStatement
         Source: "if (transferable) {\r\n            transferable = false;\r\n            TransferDisable();\r\n        }"
        Identifier transferable
           Type: bool
           Gas costs: 289
           Source: "transferable"
        Block
           Source: "{\r\n            transferable = false;\r\n            TransferDisable();\r\n        }"
          ExpressionStatement
             Gas costs: 20317
             Source: "transferable = false"
            Assignment using operator =
               Type: bool
               Source: "transferable = false"
              Identifier transferable
                 Type: bool
                 Source: "transferable"
              Literal, token: false value: false
                 Type: bool
                 Source: "false"
          ExpressionStatement
             Gas costs: 786
             Source: "TransferDisable()"
            FunctionCall
               Type: tuple()
               Source: "TransferDisable()"
              Identifier TransferDisable
                 Type: function ()
                 Source: "TransferDisable"
  FunctionDefinition "blockTransfer" - public
     Source: "function blockTransfer(address _shareHolder, uint _deadLine) external onlyClient onlyShareManager {\r\n        if (_deadLine > blockedDeadLine[_shareHolder]) {\r\n            blockedDeadLine[_shareHolder] = _deadLine;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _shareHolder, uint _deadLine)"
      VariableDeclaration "_shareHolder"
         Type: address
         Source: "address _shareHolder"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_deadLine"
         Type: uint256
         Source: "uint _deadLine"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyClient"
       Gas costs: 0
       Source: "onlyClient"
      Identifier onlyClient
         Type: modifier ()
         Source: "onlyClient"
    ModifierInvocation "onlyShareManager"
       Gas costs: 0
       Source: "onlyShareManager"
      Identifier onlyShareManager
         Type: modifier ()
         Source: "onlyShareManager"
    Block
       Source: "{\r\n        if (_deadLine > blockedDeadLine[_shareHolder]) {\r\n            blockedDeadLine[_shareHolder] = _deadLine;\r\n        }\r\n    }"
      IfStatement
         Source: "if (_deadLine > blockedDeadLine[_shareHolder]) {\r\n            blockedDeadLine[_shareHolder] = _deadLine;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 305
           Source: "_deadLine > blockedDeadLine[_shareHolder]"
          Identifier _deadLine
             Type: uint256
             Source: "_deadLine"
          IndexAccess
             Type: uint256
             Source: "blockedDeadLine[_shareHolder]"
            Identifier blockedDeadLine
               Type: mapping(address => uint256)
               Source: "blockedDeadLine"
            Identifier _shareHolder
               Type: address
               Source: "_shareHolder"
        Block
           Source: "{\r\n            blockedDeadLine[_shareHolder] = _deadLine;\r\n        }"
          ExpressionStatement
             Gas costs: 20110
             Source: "blockedDeadLine[_shareHolder] = _deadLine"
            Assignment using operator =
               Type: uint256
               Source: "blockedDeadLine[_shareHolder] = _deadLine"
              IndexAccess
                 Type: uint256
                 Source: "blockedDeadLine[_shareHolder]"
                Identifier blockedDeadLine
                   Type: mapping(address => uint256)
                   Source: "blockedDeadLine"
                Identifier _shareHolder
                   Type: address
                   Source: "_shareHolder"
              Identifier _deadLine
                 Type: uint256
                 Source: "_deadLine"
  FunctionDefinition "transferFromTo"
     Source: "function transferFromTo(\r\n        address _from,\r\n        address _to, \r\n        uint256 _value\r\n        ) internal returns (bool success) {  \r\n\r\n        if ((transferable)\r\n            && now > blockedDeadLine[_from]\r\n            && now > blockedDeadLine[_to]\r\n            && _to != address(this)\r\n            && balances[_from] >= _value\r\n            && balances[_to] + _value > balances[_to]) {\r\n\r\n            addHolder(_to);\r\n            balances[_from] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n\r\n        } else return false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _from,\r\n        address _to, \r\n        uint256 _value\r\n        )"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{  \r\n\r\n        if ((transferable)\r\n            && now > blockedDeadLine[_from]\r\n            && now > blockedDeadLine[_to]\r\n            && _to != address(this)\r\n            && balances[_from] >= _value\r\n            && balances[_to] + _value > balances[_to]) {\r\n\r\n            addHolder(_to);\r\n            balances[_from] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n\r\n        } else return false;\r\n    }"
      IfStatement
         Source: "if ((transferable)\r\n            && now > blockedDeadLine[_from]\r\n            && now > blockedDeadLine[_to]\r\n            && _to != address(this)\r\n            && balances[_from] >= _value\r\n            && balances[_to] + _value > balances[_to]) {\r\n\r\n            addHolder(_to);\r\n            balances[_from] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n\r\n        } else return false"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 1939
           Source: "(transferable)\r\n            && now > blockedDeadLine[_from]\r\n            && now > blockedDeadLine[_to]\r\n            && _to != address(this)\r\n            && balances[_from] >= _value\r\n            && balances[_to] + _value > balances[_to]"
          BinaryOperation using operator &&
             Type: bool
             Source: "(transferable)\r\n            && now > blockedDeadLine[_from]\r\n            && now > blockedDeadLine[_to]\r\n            && _to != address(this)\r\n            && balances[_from] >= _value"
            BinaryOperation using operator &&
               Type: bool
               Source: "(transferable)\r\n            && now > blockedDeadLine[_from]\r\n            && now > blockedDeadLine[_to]\r\n            && _to != address(this)"
              BinaryOperation using operator &&
                 Type: bool
                 Source: "(transferable)\r\n            && now > blockedDeadLine[_from]\r\n            && now > blockedDeadLine[_to]"
                BinaryOperation using operator &&
                   Type: bool
                   Source: "(transferable)\r\n            && now > blockedDeadLine[_from]"
                  TupleExpression
                     Type: bool
                     Source: "(transferable)"
                    Identifier transferable
                       Type: bool
                       Source: "transferable"
                  BinaryOperation using operator >
                     Type: bool
                     Source: "now > blockedDeadLine[_from]"
                    Identifier now
                       Type: uint256
                       Source: "now"
                    IndexAccess
                       Type: uint256
                       Source: "blockedDeadLine[_from]"
                      Identifier blockedDeadLine
                         Type: mapping(address => uint256)
                         Source: "blockedDeadLine"
                      Identifier _from
                         Type: address
                         Source: "_from"
                BinaryOperation using operator >
                   Type: bool
                   Source: "now > blockedDeadLine[_to]"
                  Identifier now
                     Type: uint256
                     Source: "now"
                  IndexAccess
                     Type: uint256
                     Source: "blockedDeadLine[_to]"
                    Identifier blockedDeadLine
                       Type: mapping(address => uint256)
                       Source: "blockedDeadLine"
                    Identifier _to
                       Type: address
                       Source: "_to"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "_to != address(this)"
                Identifier _to
                   Type: address
                   Source: "_to"
                FunctionCall
                   Type: address
                   Source: "address(this)"
                  ElementaryTypeNameExpression address
                     Type: type(address)
                     Source: "address"
                  Identifier this
                     Type: contract PassTokenManager
                     Source: "this"
            BinaryOperation using operator >=
               Type: bool
               Source: "balances[_from] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          BinaryOperation using operator >
             Type: bool
             Source: "balances[_to] + _value > balances[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balances[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
        Block
           Source: "{\r\n\r\n            addHolder(_to);\r\n            balances[_from] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n\r\n        }"
          ExpressionStatement
             Gas costs: 18
             Source: "addHolder(_to)"
            FunctionCall
               Type: tuple()
               Source: "addHolder(_to)"
              Identifier addHolder
                 Type: function (address)
                 Source: "addHolder"
              Identifier _to
                 Type: address
                 Source: "_to"
          ExpressionStatement
             Gas costs: 20329
             Source: "balances[_from] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[_from] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20323
             Source: "balances[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balances[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(_from, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(_from, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              Identifier _from
                 Type: address
                 Source: "_from"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Return
           Gas costs: 8
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success) {  \r\n        if (!transferFromTo(msg.sender, _to, _value)) throw;\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{  \r\n        if (!transferFromTo(msg.sender, _to, _value)) throw;\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (!transferFromTo(msg.sender, _to, _value)) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 15
           Source: "!transferFromTo(msg.sender, _to, _value)"
          FunctionCall
             Type: bool
             Source: "transferFromTo(msg.sender, _to, _value)"
            Identifier transferFromTo
               Type: function (address,address,uint256) returns (bool)
               Source: "transferFromTo"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier _to
               Type: address
               Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
        Throw
           Gas costs: 6
           Source: "throw"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n        ) returns (bool success) { \r\n        \r\n        if (allowed[_from][msg.sender] < _value\r\n            || !transferFromTo(_from, _to, _value)) throw;\r\n            \r\n        allowed[_from][msg.sender] -= _value;\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n        )"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{ \r\n        \r\n        if (allowed[_from][msg.sender] < _value\r\n            || !transferFromTo(_from, _to, _value)) throw;\r\n            \r\n        allowed[_from][msg.sender] -= _value;\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (allowed[_from][msg.sender] < _value\r\n            || !transferFromTo(_from, _to, _value)) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 440
           Source: "allowed[_from][msg.sender] < _value\r\n            || !transferFromTo(_from, _to, _value)"
          BinaryOperation using operator <
             Type: bool
             Source: "allowed[_from][msg.sender] < _value"
            IndexAccess
               Type: uint256
               Source: "allowed[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[_from]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!transferFromTo(_from, _to, _value)"
            FunctionCall
               Type: bool
               Source: "transferFromTo(_from, _to, _value)"
              Identifier transferFromTo
                 Type: function (address,address,uint256) returns (bool)
                 Source: "transferFromTo"
              Identifier _from
                 Type: address
                 Source: "_from"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20418
         Source: "allowed[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowed[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        allowed[msg.sender][_spender] = _value;\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.8;"
ContractDefinition "PassManager"
   Source: "contract PassManager is PassTokenManager {\r\n    \r\n    struct order {\r\n        address buyer;\r\n        uint weiGiven;\r\n    }\r\n    // Orders to buy tokens\r\n    order[] public orders;\r\n    // Number or orders to buy tokens\r\n    uint numberOfOrders;\r\n\r\n    // Map to know if an order was cloned from the precedent manager after an upgrade\r\n    mapping (uint => bool) orderCloned;\r\n    \r\n    function PassManager(\r\n        PassDao _passDao,\r\n        address _clonedFrom,\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _tokenDecimals,\r\n        bool _token,\r\n        bool _transferable,\r\n        uint _initialPriceMultiplier,\r\n        uint _inflationRate) \r\n        PassTokenManager( _passDao, _clonedFrom, _tokenName, _tokenSymbol, _tokenDecimals, \r\n            _token, _transferable, _initialPriceMultiplier, _inflationRate) { }\r\n    \r\n    /// @notice Function to receive payments\r\n    function () payable onlyShareManager { }\r\n    \r\n    /// @notice Function used by the client to send ethers\r\n    /// @param _recipient The address to send to\r\n    /// @param _amount The amount (in wei) to send\r\n    /// @return Whether the transfer was successful or not\r\n    function sendTo(\r\n        address _recipient,\r\n        uint _amount\r\n    ) external onlyClient returns (bool) {\r\n\r\n        if (_recipient.send(_amount)) return true;\r\n        else return false;\r\n    }\r\n\r\n    /// @dev Internal function to buy tokens and promote a proposal \r\n    /// @param _proposalID The index of the proposal\r\n    /// @param _buyer The address of the buyer\r\n    /// @param _date The unix date to consider for the share or token price calculation\r\n    /// @param _presale True if presale\r\n    /// @return Whether the function was successful or not \r\n    function buyTokensFor(\r\n        uint _proposalID,\r\n        address _buyer, \r\n        uint _date,\r\n        bool _presale) internal returns (bool) {\r\n\r\n        if (_proposalID == 0 || !sale(_proposalID, _buyer, msg.value, _date, _presale)) throw;\r\n\r\n        fundings[_proposalID].totalWeiGiven += msg.value;        \r\n        if (fundings[_proposalID].totalWeiGiven == fundings[_proposalID].amountToFund) closeFunding(_proposalID);\r\n\r\n        Given[_proposalID][_buyer].weiAmount += msg.value;\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /// @notice Function to buy tokens and promote a proposal \r\n    /// @param _proposalID The index of the proposal\r\n    /// @param _buyer The address of the buyer (not mandatory, msg.sender if 0)\r\n    /// @return Whether the function was successful or not \r\n    function buyTokensForProposal(\r\n        uint _proposalID, \r\n        address _buyer) payable returns (bool) {\r\n\r\n        if (_buyer == 0) _buyer = msg.sender;\r\n\r\n        if (fundings[_proposalID].moderator != 0) throw;\r\n\r\n        return buyTokensFor(_proposalID, _buyer, now, true);\r\n    }\r\n\r\n    /// @notice Function used by the moderator to buy shares or tokens\r\n    /// @param _proposalID Index of the client proposal\r\n    /// @param _buyer The address of the recipient of shares or tokens\r\n    /// @param _date The unix date to consider for the share or token price calculation\r\n    /// @param _presale True if presale\r\n    /// @return Whether the function was successful or not \r\n    function buyTokenFromModerator(\r\n        uint _proposalID,\r\n        address _buyer, \r\n        uint _date,\r\n        bool _presale) payable external returns (bool){\r\n\r\n        if (msg.sender != fundings[_proposalID].moderator) throw;\r\n\r\n        return buyTokensFor(_proposalID, _buyer, _date, _presale);\r\n    }\r\n\r\n    /// @dev Internal function to create a buy order\r\n    /// @param _buyer The address of the buyer\r\n    /// @param _weiGiven The amount in wei given by the buyer\r\n    function addOrder(\r\n        address _buyer, \r\n        uint _weiGiven) internal {\r\n\r\n        uint i;\r\n        numberOfOrders += 1;\r\n\r\n        if (numberOfOrders > orders.length) i = orders.length++;\r\n        else i = numberOfOrders - 1;\r\n        \r\n        orders[i].buyer = _buyer;\r\n        orders[i].weiGiven = _weiGiven;\r\n    }\r\n\r\n    /// @dev Internal function to remove a buy order\r\n    /// @param _order The index of the order to remove\r\n    function removeOrder(uint _order) internal {\r\n        \r\n        if (numberOfOrders - 1 < _order) return;\r\n\r\n        numberOfOrders -= 1;\r\n        if (numberOfOrders > 0) {\r\n            for (uint i = _order; i <= numberOfOrders - 1; i++) {\r\n                orders[i].buyer = orders[i+1].buyer;\r\n                orders[i].weiGiven = orders[i+1].weiGiven;\r\n            }\r\n        }\r\n        orders[numberOfOrders].buyer = 0;\r\n        orders[numberOfOrders].weiGiven = 0;\r\n    }\r\n    \r\n    /// @notice Function to create orders to buy tokens\r\n    /// @return Whether the function was successful or not\r\n    function buyTokens() payable returns (bool) {\r\n\r\n        if (!transferable || msg.value < 100 finney) throw;\r\n        \r\n        addOrder(msg.sender, msg.value);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /// @notice Function to sell tokens\r\n    /// @param _tokenAmount in tokens to sell\r\n    /// @param _from Index of the first order\r\n    /// @param _to Index of the last order\r\n    /// @return the revenue in wei\r\n    function sellTokens(\r\n        uint _tokenAmount,\r\n        uint _from,\r\n        uint _to) returns (uint) {\r\n\r\n        if (!transferable \r\n            || uint(balances[msg.sender]) < _amount \r\n            || numberOfOrders == 0) throw;\r\n        \r\n        if (_to == 0 || _to > numberOfOrders - 1) _to = numberOfOrders - 1;\r\n        \r\n        \r\n        uint _tokenAmounto;\r\n        uint _amount;\r\n        uint _totalAmount;\r\n        uint o = _from;\r\n\r\n        for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (_tokenAmount > 0 && orders[o].buyer != msg.sender) {\r\n\r\n                _tokenAmounto = TokenAmount(orders[o].weiGiven, priceMultiplier(0), actualPriceDivisor(0));\r\n\r\n                if (_tokenAmount >= _tokenAmounto \r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmounto)) {\r\n                            \r\n                    _tokenAmount -= _tokenAmounto;\r\n                    _totalAmount += orders[o].weiGiven;\r\n                    removeOrder(o);\r\n                }\r\n                else if (_tokenAmount < _tokenAmounto\r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmount)) {\r\n                        \r\n                    _amount = weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0));\r\n                    orders[o].weiGiven -= _amount;\r\n                    _totalAmount += _amount;\r\n                    i = _to + 1;\r\n                }\r\n                else o += 1;\r\n            } \r\n            else o += 1;\r\n        }\r\n        \r\n        if (!msg.sender.send(_totalAmount)) throw;\r\n        else return _totalAmount;\r\n    }    \r\n\r\n    /// @notice Function to remove your orders and refund\r\n    /// @param _from Index of the first order\r\n    /// @param _to Index of the last order\r\n    /// @return Whether the function was successful or not\r\n    function removeOrders(\r\n        uint _from,\r\n        uint _to) returns (bool) {\r\n\r\n        if (_to == 0 || _to > numberOfOrders) _to = numberOfOrders -1;\r\n        \r\n        uint _totalAmount;\r\n        uint o = _from;\r\n\r\n        for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (orders[o].buyer == msg.sender) {\r\n                \r\n                _totalAmount += orders[o].weiGiven;\r\n                removeOrder(o);\r\n\r\n            } else o += 1;\r\n        }\r\n\r\n        if (!msg.sender.send(_totalAmount)) throw;\r\n        else return true;\r\n    }\r\n    \r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "PassTokenManager"
    UserDefinedTypeName "PassTokenManager"
       Source: "PassTokenManager"
  StructDefinition "order"
     Gas costs: 0
     Source: "struct order {\r\n        address buyer;\r\n        uint weiGiven;\r\n    }"
    VariableDeclaration "buyer"
       Type: address
       Source: "address buyer"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "weiGiven"
       Type: uint256
       Source: "uint weiGiven"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "orders"
     Type: struct PassManager.order storage ref[] storage ref
     Gas costs: [???]
     Source: "order[] public orders"
    ArrayTypeName
       Source: "order[]"
      UserDefinedTypeName "order"
         Source: "order"
  VariableDeclaration "numberOfOrders"
     Type: uint256
     Gas costs: 0
     Source: "uint numberOfOrders"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "orderCloned"
     Type: mapping(uint256 => bool)
     Gas costs: 0
     Source: "mapping (uint => bool) orderCloned"
    Mapping
       Source: "mapping (uint => bool)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName bool
         Source: "bool"
  FunctionDefinition "PassManager" - public
     Source: "function PassManager(\r\n        PassDao _passDao,\r\n        address _clonedFrom,\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _tokenDecimals,\r\n        bool _token,\r\n        bool _transferable,\r\n        uint _initialPriceMultiplier,\r\n        uint _inflationRate) \r\n        PassTokenManager( _passDao, _clonedFrom, _tokenName, _tokenSymbol, _tokenDecimals, \r\n            _token, _transferable, _initialPriceMultiplier, _inflationRate) { }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        PassDao _passDao,\r\n        address _clonedFrom,\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _tokenDecimals,\r\n        bool _token,\r\n        bool _transferable,\r\n        uint _initialPriceMultiplier,\r\n        uint _inflationRate)"
      VariableDeclaration "_passDao"
         Type: contract PassDao
         Source: "PassDao _passDao"
        UserDefinedTypeName "PassDao"
           Source: "PassDao"
      VariableDeclaration "_clonedFrom"
         Type: address
         Source: "address _clonedFrom"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokenName"
         Type: string memory
         Source: "string _tokenName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_tokenSymbol"
         Type: string memory
         Source: "string _tokenSymbol"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_tokenDecimals"
         Type: uint8
         Source: "uint8 _tokenDecimals"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "_token"
         Type: bool
         Source: "bool _token"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "_transferable"
         Type: bool
         Source: "bool _transferable"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "_initialPriceMultiplier"
         Type: uint256
         Source: "uint _initialPriceMultiplier"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_inflationRate"
         Type: uint256
         Source: "uint _inflationRate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "PassTokenManager"
       Gas costs: 0
       Source: "PassTokenManager( _passDao, _clonedFrom, _tokenName, _tokenSymbol, _tokenDecimals, \r\n            _token, _transferable, _initialPriceMultiplier, _inflationRate)"
      Identifier PassTokenManager
         Type: type(contract PassTokenManager)
         Source: "PassTokenManager"
      Identifier _passDao
         Type: contract PassDao
         Source: "_passDao"
      Identifier _clonedFrom
         Type: address
         Source: "_clonedFrom"
      Identifier _tokenName
         Type: string memory
         Source: "_tokenName"
      Identifier _tokenSymbol
         Type: string memory
         Source: "_tokenSymbol"
      Identifier _tokenDecimals
         Type: uint8
         Source: "_tokenDecimals"
      Identifier _token
         Type: bool
         Source: "_token"
      Identifier _transferable
         Type: bool
         Source: "_transferable"
      Identifier _initialPriceMultiplier
         Type: uint256
         Source: "_initialPriceMultiplier"
      Identifier _inflationRate
         Type: uint256
         Source: "_inflationRate"
    Block
       Gas costs: 0
       Source: "{ }"
  FunctionDefinition "" - public
     Source: "function () payable onlyShareManager { }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyShareManager"
       Gas costs: 0
       Source: "onlyShareManager"
      Identifier onlyShareManager
         Type: modifier ()
         Source: "onlyShareManager"
    Block
       Gas costs: 0
       Source: "{ }"
  FunctionDefinition "sendTo" - public
     Source: "function sendTo(\r\n        address _recipient,\r\n        uint _amount\r\n    ) external onlyClient returns (bool) {\r\n\r\n        if (_recipient.send(_amount)) return true;\r\n        else return false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _recipient,\r\n        uint _amount\r\n    )"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyClient"
       Gas costs: 0
       Source: "onlyClient"
      Identifier onlyClient
         Type: modifier ()
         Source: "onlyClient"
    Block
       Source: "{\r\n\r\n        if (_recipient.send(_amount)) return true;\r\n        else return false;\r\n    }"
      IfStatement
         Source: "if (_recipient.send(_amount)) return true;\r\n        else return false"
        FunctionCall
           Type: bool
           Gas costs: [???]
           Source: "_recipient.send(_amount)"
          MemberAccess to member send
             Type: function (uint256) returns (bool)
             Source: "_recipient.send"
            Identifier _recipient
               Type: address
               Source: "_recipient"
          Identifier _amount
             Type: uint256
             Source: "_amount"
        Return
           Gas costs: 19
           Source: "return true"
          Literal, token: true value: true
             Type: bool
             Source: "true"
        Return
           Gas costs: 8
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "buyTokensFor"
     Source: "function buyTokensFor(\r\n        uint _proposalID,\r\n        address _buyer, \r\n        uint _date,\r\n        bool _presale) internal returns (bool) {\r\n\r\n        if (_proposalID == 0 || !sale(_proposalID, _buyer, msg.value, _date, _presale)) throw;\r\n\r\n        fundings[_proposalID].totalWeiGiven += msg.value;        \r\n        if (fundings[_proposalID].totalWeiGiven == fundings[_proposalID].amountToFund) closeFunding(_proposalID);\r\n\r\n        Given[_proposalID][_buyer].weiAmount += msg.value;\r\n        \r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint _proposalID,\r\n        address _buyer, \r\n        uint _date,\r\n        bool _presale)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_buyer"
         Type: address
         Source: "address _buyer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_date"
         Type: uint256
         Source: "uint _date"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_presale"
         Type: bool
         Source: "bool _presale"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n        if (_proposalID == 0 || !sale(_proposalID, _buyer, msg.value, _date, _presale)) throw;\r\n\r\n        fundings[_proposalID].totalWeiGiven += msg.value;        \r\n        if (fundings[_proposalID].totalWeiGiven == fundings[_proposalID].amountToFund) closeFunding(_proposalID);\r\n\r\n        Given[_proposalID][_buyer].weiAmount += msg.value;\r\n        \r\n        return true;\r\n    }"
      IfStatement
         Source: "if (_proposalID == 0 || !sale(_proposalID, _buyer, msg.value, _date, _presale)) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 49
           Source: "_proposalID == 0 || !sale(_proposalID, _buyer, msg.value, _date, _presale)"
          BinaryOperation using operator ==
             Type: bool
             Source: "_proposalID == 0"
            Identifier _proposalID
               Type: uint256
               Source: "_proposalID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!sale(_proposalID, _buyer, msg.value, _date, _presale)"
            FunctionCall
               Type: bool
               Source: "sale(_proposalID, _buyer, msg.value, _date, _presale)"
              Identifier sale
                 Type: function (uint256,address,uint256,uint256,bool) returns (bool)
                 Source: "sale"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
              Identifier _buyer
                 Type: address
                 Source: "_buyer"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _date
                 Type: uint256
                 Source: "_date"
              Identifier _presale
                 Type: bool
                 Source: "_presale"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20322
         Source: "fundings[_proposalID].totalWeiGiven += msg.value"
        Assignment using operator +=
           Type: uint256
           Source: "fundings[_proposalID].totalWeiGiven += msg.value"
          MemberAccess to member totalWeiGiven
             Type: uint256
             Source: "fundings[_proposalID].totalWeiGiven"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (fundings[_proposalID].totalWeiGiven == fundings[_proposalID].amountToFund) closeFunding(_proposalID)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 577
           Source: "fundings[_proposalID].totalWeiGiven == fundings[_proposalID].amountToFund"
          MemberAccess to member totalWeiGiven
             Type: uint256
             Source: "fundings[_proposalID].totalWeiGiven"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
          MemberAccess to member amountToFund
             Type: uint256
             Source: "fundings[_proposalID].amountToFund"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
        ExpressionStatement
           Gas costs: 18
           Source: "closeFunding(_proposalID)"
          FunctionCall
             Type: tuple()
             Source: "closeFunding(_proposalID)"
            Identifier closeFunding
               Type: function (uint256)
               Source: "closeFunding"
            Identifier _proposalID
               Type: uint256
               Source: "_proposalID"
      ExpressionStatement
         Gas costs: 20412
         Source: "Given[_proposalID][_buyer].weiAmount += msg.value"
        Assignment using operator +=
           Type: uint256
           Source: "Given[_proposalID][_buyer].weiAmount += msg.value"
          MemberAccess to member weiAmount
             Type: uint256
             Source: "Given[_proposalID][_buyer].weiAmount"
            IndexAccess
               Type: struct PassTokenManagerInterface.amountsGiven storage ref
               Source: "Given[_proposalID][_buyer]"
              IndexAccess
                 Type: mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref)
                 Source: "Given[_proposalID]"
                Identifier Given
                   Type: mapping(uint256 => mapping(address => struct PassTokenManagerInterface.amountsGiven storage ref))
                   Source: "Given"
                Identifier _proposalID
                   Type: uint256
                   Source: "_proposalID"
              Identifier _buyer
                 Type: address
                 Source: "_buyer"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "buyTokensForProposal" - public
     Source: "function buyTokensForProposal(\r\n        uint _proposalID, \r\n        address _buyer) payable returns (bool) {\r\n\r\n        if (_buyer == 0) _buyer = msg.sender;\r\n\r\n        if (fundings[_proposalID].moderator != 0) throw;\r\n\r\n        return buyTokensFor(_proposalID, _buyer, now, true);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint _proposalID, \r\n        address _buyer)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_buyer"
         Type: address
         Source: "address _buyer"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n        if (_buyer == 0) _buyer = msg.sender;\r\n\r\n        if (fundings[_proposalID].moderator != 0) throw;\r\n\r\n        return buyTokensFor(_proposalID, _buyer, now, true);\r\n    }"
      IfStatement
         Source: "if (_buyer == 0) _buyer = msg.sender"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 15
           Source: "_buyer == 0"
          Identifier _buyer
             Type: address
             Source: "_buyer"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 7
           Source: "_buyer = msg.sender"
          Assignment using operator =
             Type: address
             Source: "_buyer = msg.sender"
            Identifier _buyer
               Type: address
               Source: "_buyer"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      IfStatement
         Source: "if (fundings[_proposalID].moderator != 0) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 344
           Source: "fundings[_proposalID].moderator != 0"
          MemberAccess to member moderator
             Type: address
             Source: "fundings[_proposalID].moderator"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      Return
         Gas costs: 20
         Source: "return buyTokensFor(_proposalID, _buyer, now, true)"
        FunctionCall
           Type: bool
           Source: "buyTokensFor(_proposalID, _buyer, now, true)"
          Identifier buyTokensFor
             Type: function (uint256,address,uint256,bool) returns (bool)
             Source: "buyTokensFor"
          Identifier _proposalID
             Type: uint256
             Source: "_proposalID"
          Identifier _buyer
             Type: address
             Source: "_buyer"
          Identifier now
             Type: uint256
             Source: "now"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "buyTokenFromModerator" - public
     Source: "function buyTokenFromModerator(\r\n        uint _proposalID,\r\n        address _buyer, \r\n        uint _date,\r\n        bool _presale) payable external returns (bool){\r\n\r\n        if (msg.sender != fundings[_proposalID].moderator) throw;\r\n\r\n        return buyTokensFor(_proposalID, _buyer, _date, _presale);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint _proposalID,\r\n        address _buyer, \r\n        uint _date,\r\n        bool _presale)"
      VariableDeclaration "_proposalID"
         Type: uint256
         Source: "uint _proposalID"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_buyer"
         Type: address
         Source: "address _buyer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_date"
         Type: uint256
         Source: "uint _date"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_presale"
         Type: bool
         Source: "bool _presale"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n        if (msg.sender != fundings[_proposalID].moderator) throw;\r\n\r\n        return buyTokensFor(_proposalID, _buyer, _date, _presale);\r\n    }"
      IfStatement
         Source: "if (msg.sender != fundings[_proposalID].moderator) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 349
           Source: "msg.sender != fundings[_proposalID].moderator"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          MemberAccess to member moderator
             Type: address
             Source: "fundings[_proposalID].moderator"
            IndexAccess
               Type: struct PassTokenManagerInterface.funding storage ref
               Source: "fundings[_proposalID]"
              Identifier fundings
                 Type: mapping(uint256 => struct PassTokenManagerInterface.funding storage ref)
                 Source: "fundings"
              Identifier _proposalID
                 Type: uint256
                 Source: "_proposalID"
        Throw
           Gas costs: 6
           Source: "throw"
      Return
         Gas costs: 32
         Source: "return buyTokensFor(_proposalID, _buyer, _date, _presale)"
        FunctionCall
           Type: bool
           Source: "buyTokensFor(_proposalID, _buyer, _date, _presale)"
          Identifier buyTokensFor
             Type: function (uint256,address,uint256,bool) returns (bool)
             Source: "buyTokensFor"
          Identifier _proposalID
             Type: uint256
             Source: "_proposalID"
          Identifier _buyer
             Type: address
             Source: "_buyer"
          Identifier _date
             Type: uint256
             Source: "_date"
          Identifier _presale
             Type: bool
             Source: "_presale"
  FunctionDefinition "addOrder"
     Source: "function addOrder(\r\n        address _buyer, \r\n        uint _weiGiven) internal {\r\n\r\n        uint i;\r\n        numberOfOrders += 1;\r\n\r\n        if (numberOfOrders > orders.length) i = orders.length++;\r\n        else i = numberOfOrders - 1;\r\n        \r\n        orders[i].buyer = _buyer;\r\n        orders[i].weiGiven = _weiGiven;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _buyer, \r\n        uint _weiGiven)"
      VariableDeclaration "_buyer"
         Type: address
         Source: "address _buyer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_weiGiven"
         Type: uint256
         Source: "uint _weiGiven"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\r\n        uint i;\r\n        numberOfOrders += 1;\r\n\r\n        if (numberOfOrders > orders.length) i = orders.length++;\r\n        else i = numberOfOrders - 1;\r\n        \r\n        orders[i].buyer = _buyer;\r\n        orders[i].weiGiven = _weiGiven;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint i"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint i"
          ElementaryTypeName uint
             Source: "uint"
      ExpressionStatement
         Gas costs: 20233
         Source: "numberOfOrders += 1"
        Assignment using operator +=
           Type: uint256
           Source: "numberOfOrders += 1"
          Identifier numberOfOrders
             Type: uint256
             Source: "numberOfOrders"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      IfStatement
         Source: "if (numberOfOrders > orders.length) i = orders.length++;\r\n        else i = numberOfOrders - 1"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 417
           Source: "numberOfOrders > orders.length"
          Identifier numberOfOrders
             Type: uint256
             Source: "numberOfOrders"
          MemberAccess to member length
             Type: uint256
             Source: "orders.length"
            Identifier orders
               Type: struct PassManager.order storage ref[] storage ref
               Source: "orders"
        ExpressionStatement
           Gas costs: 236
           Source: "i = orders.length++"
          Assignment using operator =
             Type: uint256
             Source: "i = orders.length++"
            Identifier i
               Type: uint256
               Source: "i"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "orders.length++"
              MemberAccess to member length
                 Type: uint256
                 Source: "orders.length"
                Identifier orders
                   Type: struct PassManager.order storage ref[] storage ref
                   Source: "orders"
        ExpressionStatement
           Gas costs: 214
           Source: "i = numberOfOrders - 1"
          Assignment using operator =
             Type: uint256
             Source: "i = numberOfOrders - 1"
            Identifier i
               Type: uint256
               Source: "i"
            BinaryOperation using operator -
               Type: uint256
               Source: "numberOfOrders - 1"
              Identifier numberOfOrders
                 Type: uint256
                 Source: "numberOfOrders"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      ExpressionStatement
         Gas costs: 20573
         Source: "orders[i].buyer = _buyer"
        Assignment using operator =
           Type: address
           Source: "orders[i].buyer = _buyer"
          MemberAccess to member buyer
             Type: address
             Source: "orders[i].buyer"
            IndexAccess
               Type: struct PassManager.order storage ref
               Source: "orders[i]"
              Identifier orders
                 Type: struct PassManager.order storage ref[] storage ref
                 Source: "orders"
              Identifier i
                 Type: uint256
                 Source: "i"
          Identifier _buyer
             Type: address
             Source: "_buyer"
      ExpressionStatement
         Gas costs: 20320
         Source: "orders[i].weiGiven = _weiGiven"
        Assignment using operator =
           Type: uint256
           Source: "orders[i].weiGiven = _weiGiven"
          MemberAccess to member weiGiven
             Type: uint256
             Source: "orders[i].weiGiven"
            IndexAccess
               Type: struct PassManager.order storage ref
               Source: "orders[i]"
              Identifier orders
                 Type: struct PassManager.order storage ref[] storage ref
                 Source: "orders"
              Identifier i
                 Type: uint256
                 Source: "i"
          Identifier _weiGiven
             Type: uint256
             Source: "_weiGiven"
  FunctionDefinition "removeOrder"
     Source: "function removeOrder(uint _order) internal {\r\n        \r\n        if (numberOfOrders - 1 < _order) return;\r\n\r\n        numberOfOrders -= 1;\r\n        if (numberOfOrders > 0) {\r\n            for (uint i = _order; i <= numberOfOrders - 1; i++) {\r\n                orders[i].buyer = orders[i+1].buyer;\r\n                orders[i].weiGiven = orders[i+1].weiGiven;\r\n            }\r\n        }\r\n        orders[numberOfOrders].buyer = 0;\r\n        orders[numberOfOrders].weiGiven = 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _order)"
      VariableDeclaration "_order"
         Type: uint256
         Source: "uint _order"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        \r\n        if (numberOfOrders - 1 < _order) return;\r\n\r\n        numberOfOrders -= 1;\r\n        if (numberOfOrders > 0) {\r\n            for (uint i = _order; i <= numberOfOrders - 1; i++) {\r\n                orders[i].buyer = orders[i+1].buyer;\r\n                orders[i].weiGiven = orders[i+1].weiGiven;\r\n            }\r\n        }\r\n        orders[numberOfOrders].buyer = 0;\r\n        orders[numberOfOrders].weiGiven = 0;\r\n    }"
      IfStatement
         Source: "if (numberOfOrders - 1 < _order) return;"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 215
           Source: "numberOfOrders - 1 < _order"
          BinaryOperation using operator -
             Type: uint256
             Source: "numberOfOrders - 1"
            Identifier numberOfOrders
               Type: uint256
               Source: "numberOfOrders"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Identifier _order
             Type: uint256
             Source: "_order"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 20233
         Source: "numberOfOrders -= 1"
        Assignment using operator -=
           Type: uint256
           Source: "numberOfOrders -= 1"
          Identifier numberOfOrders
             Type: uint256
             Source: "numberOfOrders"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      IfStatement
         Source: "if (numberOfOrders > 0) {\r\n            for (uint i = _order; i <= numberOfOrders - 1; i++) {\r\n                orders[i].buyer = orders[i+1].buyer;\r\n                orders[i].weiGiven = orders[i+1].weiGiven;\r\n            }\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "numberOfOrders > 0"
          Identifier numberOfOrders
             Type: uint256
             Source: "numberOfOrders"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            for (uint i = _order; i <= numberOfOrders - 1; i++) {\r\n                orders[i].buyer = orders[i+1].buyer;\r\n                orders[i].weiGiven = orders[i+1].weiGiven;\r\n            }\r\n        }"
          ForStatement
             Source: "for (uint i = _order; i <= numberOfOrders - 1; i++) {\r\n                orders[i].buyer = orders[i+1].buyer;\r\n                orders[i].weiGiven = orders[i+1].weiGiven;\r\n            }"
            VariableDeclarationStatement
               Gas costs: 11
               Source: "uint i = _order"
              VariableDeclaration "i"
                 Type: uint256
                 Source: "uint i"
                ElementaryTypeName uint
                   Source: "uint"
              Identifier _order
                 Type: uint256
                 Source: "_order"
            BinaryOperation using operator <=
               Type: bool
               Gas costs: 218
               Source: "i <= numberOfOrders - 1"
              Identifier i
                 Type: uint256
                 Source: "i"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "numberOfOrders - 1"
                Identifier numberOfOrders
                   Type: uint256
                   Source: "numberOfOrders"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
            ExpressionStatement
               Gas costs: 19
               Source: "i++"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "i++"
                Identifier i
                   Type: uint256
                   Source: "i"
            Block
               Source: "{\r\n                orders[i].buyer = orders[i+1].buyer;\r\n                orders[i].weiGiven = orders[i+1].weiGiven;\r\n            }"
              ExpressionStatement
                 Gas costs: 21121
                 Source: "orders[i].buyer = orders[i+1].buyer"
                Assignment using operator =
                   Type: address
                   Source: "orders[i].buyer = orders[i+1].buyer"
                  MemberAccess to member buyer
                     Type: address
                     Source: "orders[i].buyer"
                    IndexAccess
                       Type: struct PassManager.order storage ref
                       Source: "orders[i]"
                      Identifier orders
                         Type: struct PassManager.order storage ref[] storage ref
                         Source: "orders"
                      Identifier i
                         Type: uint256
                         Source: "i"
                  MemberAccess to member buyer
                     Type: address
                     Source: "orders[i+1].buyer"
                    IndexAccess
                       Type: struct PassManager.order storage ref
                       Source: "orders[i+1]"
                      Identifier orders
                         Type: struct PassManager.order storage ref[] storage ref
                         Source: "orders"
                      BinaryOperation using operator +
                         Type: uint256
                         Source: "i+1"
                        Identifier i
                           Type: uint256
                           Source: "i"
                        Literal, token: [no token] value: 1
                           Type: int_const 1
                           Source: "1"
              ExpressionStatement
                 Gas costs: 20832
                 Source: "orders[i].weiGiven = orders[i+1].weiGiven"
                Assignment using operator =
                   Type: uint256
                   Source: "orders[i].weiGiven = orders[i+1].weiGiven"
                  MemberAccess to member weiGiven
                     Type: uint256
                     Source: "orders[i].weiGiven"
                    IndexAccess
                       Type: struct PassManager.order storage ref
                       Source: "orders[i]"
                      Identifier orders
                         Type: struct PassManager.order storage ref[] storage ref
                         Source: "orders"
                      Identifier i
                         Type: uint256
                         Source: "i"
                  MemberAccess to member weiGiven
                     Type: uint256
                     Source: "orders[i+1].weiGiven"
                    IndexAccess
                       Type: struct PassManager.order storage ref
                       Source: "orders[i+1]"
                      Identifier orders
                         Type: struct PassManager.order storage ref[] storage ref
                         Source: "orders"
                      BinaryOperation using operator +
                         Type: uint256
                         Source: "i+1"
                        Identifier i
                           Type: uint256
                           Source: "i"
                        Literal, token: [no token] value: 1
                           Type: int_const 1
                           Source: "1"
      ExpressionStatement
         Gas costs: 20773
         Source: "orders[numberOfOrders].buyer = 0"
        Assignment using operator =
           Type: address
           Source: "orders[numberOfOrders].buyer = 0"
          MemberAccess to member buyer
             Type: address
             Source: "orders[numberOfOrders].buyer"
            IndexAccess
               Type: struct PassManager.order storage ref
               Source: "orders[numberOfOrders]"
              Identifier orders
                 Type: struct PassManager.order storage ref[] storage ref
                 Source: "orders"
              Identifier numberOfOrders
                 Type: uint256
                 Source: "numberOfOrders"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 20520
         Source: "orders[numberOfOrders].weiGiven = 0"
        Assignment using operator =
           Type: uint256
           Source: "orders[numberOfOrders].weiGiven = 0"
          MemberAccess to member weiGiven
             Type: uint256
             Source: "orders[numberOfOrders].weiGiven"
            IndexAccess
               Type: struct PassManager.order storage ref
               Source: "orders[numberOfOrders]"
              Identifier orders
                 Type: struct PassManager.order storage ref[] storage ref
                 Source: "orders"
              Identifier numberOfOrders
                 Type: uint256
                 Source: "numberOfOrders"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "buyTokens" - public
     Source: "function buyTokens() payable returns (bool) {\r\n\r\n        if (!transferable || msg.value < 100 finney) throw;\r\n        \r\n        addOrder(msg.sender, msg.value);\r\n        \r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n        if (!transferable || msg.value < 100 finney) throw;\r\n        \r\n        addOrder(msg.sender, msg.value);\r\n        \r\n        return true;\r\n    }"
      IfStatement
         Source: "if (!transferable || msg.value < 100 finney) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 319
           Source: "!transferable || msg.value < 100 finney"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!transferable"
            Identifier transferable
               Type: bool
               Source: "transferable"
          BinaryOperation using operator <
             Type: bool
             Source: "msg.value < 100 finney"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 100
               Type: int_const 100000000000000000
               Source: "100 finney"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 8
         Source: "addOrder(msg.sender, msg.value)"
        FunctionCall
           Type: tuple()
           Source: "addOrder(msg.sender, msg.value)"
          Identifier addOrder
             Type: function (address,uint256)
             Source: "addOrder"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "sellTokens" - public
     Source: "function sellTokens(\r\n        uint _tokenAmount,\r\n        uint _from,\r\n        uint _to) returns (uint) {\r\n\r\n        if (!transferable \r\n            || uint(balances[msg.sender]) < _amount \r\n            || numberOfOrders == 0) throw;\r\n        \r\n        if (_to == 0 || _to > numberOfOrders - 1) _to = numberOfOrders - 1;\r\n        \r\n        \r\n        uint _tokenAmounto;\r\n        uint _amount;\r\n        uint _totalAmount;\r\n        uint o = _from;\r\n\r\n        for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (_tokenAmount > 0 && orders[o].buyer != msg.sender) {\r\n\r\n                _tokenAmounto = TokenAmount(orders[o].weiGiven, priceMultiplier(0), actualPriceDivisor(0));\r\n\r\n                if (_tokenAmount >= _tokenAmounto \r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmounto)) {\r\n                            \r\n                    _tokenAmount -= _tokenAmounto;\r\n                    _totalAmount += orders[o].weiGiven;\r\n                    removeOrder(o);\r\n                }\r\n                else if (_tokenAmount < _tokenAmounto\r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmount)) {\r\n                        \r\n                    _amount = weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0));\r\n                    orders[o].weiGiven -= _amount;\r\n                    _totalAmount += _amount;\r\n                    i = _to + 1;\r\n                }\r\n                else o += 1;\r\n            } \r\n            else o += 1;\r\n        }\r\n        \r\n        if (!msg.sender.send(_totalAmount)) throw;\r\n        else return _totalAmount;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint _tokenAmount,\r\n        uint _from,\r\n        uint _to)"
      VariableDeclaration "_tokenAmount"
         Type: uint256
         Source: "uint _tokenAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_from"
         Type: uint256
         Source: "uint _from"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_to"
         Type: uint256
         Source: "uint _to"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        if (!transferable \r\n            || uint(balances[msg.sender]) < _amount \r\n            || numberOfOrders == 0) throw;\r\n        \r\n        if (_to == 0 || _to > numberOfOrders - 1) _to = numberOfOrders - 1;\r\n        \r\n        \r\n        uint _tokenAmounto;\r\n        uint _amount;\r\n        uint _totalAmount;\r\n        uint o = _from;\r\n\r\n        for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (_tokenAmount > 0 && orders[o].buyer != msg.sender) {\r\n\r\n                _tokenAmounto = TokenAmount(orders[o].weiGiven, priceMultiplier(0), actualPriceDivisor(0));\r\n\r\n                if (_tokenAmount >= _tokenAmounto \r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmounto)) {\r\n                            \r\n                    _tokenAmount -= _tokenAmounto;\r\n                    _totalAmount += orders[o].weiGiven;\r\n                    removeOrder(o);\r\n                }\r\n                else if (_tokenAmount < _tokenAmounto\r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmount)) {\r\n                        \r\n                    _amount = weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0));\r\n                    orders[o].weiGiven -= _amount;\r\n                    _totalAmount += _amount;\r\n                    i = _to + 1;\r\n                }\r\n                else o += 1;\r\n            } \r\n            else o += 1;\r\n        }\r\n        \r\n        if (!msg.sender.send(_totalAmount)) throw;\r\n        else return _totalAmount;\r\n    }"
      IfStatement
         Source: "if (!transferable \r\n            || uint(balances[msg.sender]) < _amount \r\n            || numberOfOrders == 0) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 843
           Source: "!transferable \r\n            || uint(balances[msg.sender]) < _amount \r\n            || numberOfOrders == 0"
          BinaryOperation using operator ||
             Type: bool
             Source: "!transferable \r\n            || uint(balances[msg.sender]) < _amount"
            UnaryOperation (prefix) !
               Type: bool
               Source: "!transferable"
              Identifier transferable
                 Type: bool
                 Source: "transferable"
            BinaryOperation using operator <
               Type: bool
               Source: "uint(balances[msg.sender]) < _amount"
              FunctionCall
                 Type: uint256
                 Source: "uint(balances[msg.sender])"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                IndexAccess
                   Type: uint256
                   Source: "balances[msg.sender]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
          BinaryOperation using operator ==
             Type: bool
             Source: "numberOfOrders == 0"
            Identifier numberOfOrders
               Type: uint256
               Source: "numberOfOrders"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (_to == 0 || _to > numberOfOrders - 1) _to = numberOfOrders - 1"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 243
           Source: "_to == 0 || _to > numberOfOrders - 1"
          BinaryOperation using operator ==
             Type: bool
             Source: "_to == 0"
            Identifier _to
               Type: uint256
               Source: "_to"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator >
             Type: bool
             Source: "_to > numberOfOrders - 1"
            Identifier _to
               Type: uint256
               Source: "_to"
            BinaryOperation using operator -
               Type: uint256
               Source: "numberOfOrders - 1"
              Identifier numberOfOrders
                 Type: uint256
                 Source: "numberOfOrders"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
        ExpressionStatement
           Gas costs: 214
           Source: "_to = numberOfOrders - 1"
          Assignment using operator =
             Type: uint256
             Source: "_to = numberOfOrders - 1"
            Identifier _to
               Type: uint256
               Source: "_to"
            BinaryOperation using operator -
               Type: uint256
               Source: "numberOfOrders - 1"
              Identifier numberOfOrders
                 Type: uint256
                 Source: "numberOfOrders"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint _tokenAmounto"
        VariableDeclaration "_tokenAmounto"
           Type: uint256
           Source: "uint _tokenAmounto"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint _amount"
        VariableDeclaration "_amount"
           Type: uint256
           Source: "uint _amount"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint _totalAmount"
        VariableDeclaration "_totalAmount"
           Type: uint256
           Source: "uint _totalAmount"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint o = _from"
        VariableDeclaration "o"
           Type: uint256
           Source: "uint o"
          ElementaryTypeName uint
             Source: "uint"
        Identifier _from
           Type: uint256
           Source: "_from"
      ForStatement
         Source: "for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (_tokenAmount > 0 && orders[o].buyer != msg.sender) {\r\n\r\n                _tokenAmounto = TokenAmount(orders[o].weiGiven, priceMultiplier(0), actualPriceDivisor(0));\r\n\r\n                if (_tokenAmount >= _tokenAmounto \r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmounto)) {\r\n                            \r\n                    _tokenAmount -= _tokenAmounto;\r\n                    _totalAmount += orders[o].weiGiven;\r\n                    removeOrder(o);\r\n                }\r\n                else if (_tokenAmount < _tokenAmounto\r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmount)) {\r\n                        \r\n                    _amount = weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0));\r\n                    orders[o].weiGiven -= _amount;\r\n                    _totalAmount += _amount;\r\n                    i = _to + 1;\r\n                }\r\n                else o += 1;\r\n            } \r\n            else o += 1;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = _from"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Identifier _from
             Type: uint256
             Source: "_from"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 12
           Source: "i <= _to"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier _to
             Type: uint256
             Source: "_to"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n\r\n            if (_tokenAmount > 0 && orders[o].buyer != msg.sender) {\r\n\r\n                _tokenAmounto = TokenAmount(orders[o].weiGiven, priceMultiplier(0), actualPriceDivisor(0));\r\n\r\n                if (_tokenAmount >= _tokenAmounto \r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmounto)) {\r\n                            \r\n                    _tokenAmount -= _tokenAmounto;\r\n                    _totalAmount += orders[o].weiGiven;\r\n                    removeOrder(o);\r\n                }\r\n                else if (_tokenAmount < _tokenAmounto\r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmount)) {\r\n                        \r\n                    _amount = weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0));\r\n                    orders[o].weiGiven -= _amount;\r\n                    _totalAmount += _amount;\r\n                    i = _to + 1;\r\n                }\r\n                else o += 1;\r\n            } \r\n            else o += 1;\r\n        }"
          IfStatement
             Source: "if (_tokenAmount > 0 && orders[o].buyer != msg.sender) {\r\n\r\n                _tokenAmounto = TokenAmount(orders[o].weiGiven, priceMultiplier(0), actualPriceDivisor(0));\r\n\r\n                if (_tokenAmount >= _tokenAmounto \r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmounto)) {\r\n                            \r\n                    _tokenAmount -= _tokenAmounto;\r\n                    _totalAmount += orders[o].weiGiven;\r\n                    removeOrder(o);\r\n                }\r\n                else if (_tokenAmount < _tokenAmounto\r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmount)) {\r\n                        \r\n                    _amount = weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0));\r\n                    orders[o].weiGiven -= _amount;\r\n                    _totalAmount += _amount;\r\n                    i = _to + 1;\r\n                }\r\n                else o += 1;\r\n            } \r\n            else o += 1"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 596
               Source: "_tokenAmount > 0 && orders[o].buyer != msg.sender"
              BinaryOperation using operator >
                 Type: bool
                 Source: "_tokenAmount > 0"
                Identifier _tokenAmount
                   Type: uint256
                   Source: "_tokenAmount"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "orders[o].buyer != msg.sender"
                MemberAccess to member buyer
                   Type: address
                   Source: "orders[o].buyer"
                  IndexAccess
                     Type: struct PassManager.order storage ref
                     Source: "orders[o]"
                    Identifier orders
                       Type: struct PassManager.order storage ref[] storage ref
                       Source: "orders"
                    Identifier o
                       Type: uint256
                       Source: "o"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Block
               Source: "{\r\n\r\n                _tokenAmounto = TokenAmount(orders[o].weiGiven, priceMultiplier(0), actualPriceDivisor(0));\r\n\r\n                if (_tokenAmount >= _tokenAmounto \r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmounto)) {\r\n                            \r\n                    _tokenAmount -= _tokenAmounto;\r\n                    _totalAmount += orders[o].weiGiven;\r\n                    removeOrder(o);\r\n                }\r\n                else if (_tokenAmount < _tokenAmounto\r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmount)) {\r\n                        \r\n                    _amount = weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0));\r\n                    orders[o].weiGiven -= _amount;\r\n                    _totalAmount += _amount;\r\n                    i = _to + 1;\r\n                }\r\n                else o += 1;\r\n            }"
              ExpressionStatement
                 Gas costs: 565
                 Source: "_tokenAmounto = TokenAmount(orders[o].weiGiven, priceMultiplier(0), actualPriceDivisor(0))"
                Assignment using operator =
                   Type: uint256
                   Source: "_tokenAmounto = TokenAmount(orders[o].weiGiven, priceMultiplier(0), actualPriceDivisor(0))"
                  Identifier _tokenAmounto
                     Type: uint256
                     Source: "_tokenAmounto"
                  FunctionCall
                     Type: uint256
                     Source: "TokenAmount(orders[o].weiGiven, priceMultiplier(0), actualPriceDivisor(0))"
                    Identifier TokenAmount
                       Type: function (uint256,uint256,uint256) view returns (uint256)
                       Source: "TokenAmount"
                    MemberAccess to member weiGiven
                       Type: uint256
                       Source: "orders[o].weiGiven"
                      IndexAccess
                         Type: struct PassManager.order storage ref
                         Source: "orders[o]"
                        Identifier orders
                           Type: struct PassManager.order storage ref[] storage ref
                           Source: "orders"
                        Identifier o
                           Type: uint256
                           Source: "o"
                    FunctionCall
                       Type: uint256
                       Source: "priceMultiplier(0)"
                      Identifier priceMultiplier
                         Type: function (uint256) view returns (uint256)
                         Source: "priceMultiplier"
                      Literal, token: [no token] value: 0
                         Type: int_const 0
                         Source: "0"
                    FunctionCall
                       Type: uint256
                       Source: "actualPriceDivisor(0)"
                      Identifier actualPriceDivisor
                         Type: function (uint256) view returns (uint256)
                         Source: "actualPriceDivisor"
                      Literal, token: [no token] value: 0
                         Type: int_const 0
                         Source: "0"
              IfStatement
                 Source: "if (_tokenAmount >= _tokenAmounto \r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmounto)) {\r\n                            \r\n                    _tokenAmount -= _tokenAmounto;\r\n                    _totalAmount += orders[o].weiGiven;\r\n                    removeOrder(o);\r\n                }\r\n                else if (_tokenAmount < _tokenAmounto\r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmount)) {\r\n                        \r\n                    _amount = weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0));\r\n                    orders[o].weiGiven -= _amount;\r\n                    _totalAmount += _amount;\r\n                    i = _to + 1;\r\n                }\r\n                else o += 1"
                BinaryOperation using operator &&
                   Type: bool
                   Gas costs: 599
                   Source: "_tokenAmount >= _tokenAmounto \r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmounto)"
                  BinaryOperation using operator >=
                     Type: bool
                     Source: "_tokenAmount >= _tokenAmounto"
                    Identifier _tokenAmount
                       Type: uint256
                       Source: "_tokenAmount"
                    Identifier _tokenAmounto
                       Type: uint256
                       Source: "_tokenAmounto"
                  FunctionCall
                     Type: bool
                     Source: "transferFromTo(msg.sender, orders[o].buyer, _tokenAmounto)"
                    Identifier transferFromTo
                       Type: function (address,address,uint256) returns (bool)
                       Source: "transferFromTo"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                    MemberAccess to member buyer
                       Type: address
                       Source: "orders[o].buyer"
                      IndexAccess
                         Type: struct PassManager.order storage ref
                         Source: "orders[o]"
                        Identifier orders
                           Type: struct PassManager.order storage ref[] storage ref
                           Source: "orders"
                        Identifier o
                           Type: uint256
                           Source: "o"
                    Identifier _tokenAmounto
                       Type: uint256
                       Source: "_tokenAmounto"
                Block
                   Source: "{\r\n                            \r\n                    _tokenAmount -= _tokenAmounto;\r\n                    _totalAmount += orders[o].weiGiven;\r\n                    removeOrder(o);\r\n                }"
                  ExpressionStatement
                     Gas costs: 14
                     Source: "_tokenAmount -= _tokenAmounto"
                    Assignment using operator -=
                       Type: uint256
                       Source: "_tokenAmount -= _tokenAmounto"
                      Identifier _tokenAmount
                         Type: uint256
                         Source: "_tokenAmount"
                      Identifier _tokenAmounto
                         Type: uint256
                         Source: "_tokenAmounto"
                  ExpressionStatement
                     Gas costs: 520
                     Source: "_totalAmount += orders[o].weiGiven"
                    Assignment using operator +=
                       Type: uint256
                       Source: "_totalAmount += orders[o].weiGiven"
                      Identifier _totalAmount
                         Type: uint256
                         Source: "_totalAmount"
                      MemberAccess to member weiGiven
                         Type: uint256
                         Source: "orders[o].weiGiven"
                        IndexAccess
                           Type: struct PassManager.order storage ref
                           Source: "orders[o]"
                          Identifier orders
                             Type: struct PassManager.order storage ref[] storage ref
                             Source: "orders"
                          Identifier o
                             Type: uint256
                             Source: "o"
                  ExpressionStatement
                     Gas costs: 7
                     Source: "removeOrder(o)"
                    FunctionCall
                       Type: tuple()
                       Source: "removeOrder(o)"
                      Identifier removeOrder
                         Type: function (uint256)
                         Source: "removeOrder"
                      Identifier o
                         Type: uint256
                         Source: "o"
                IfStatement
                   Source: "if (_tokenAmount < _tokenAmounto\r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmount)) {\r\n                        \r\n                    _amount = weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0));\r\n                    orders[o].weiGiven -= _amount;\r\n                    _totalAmount += _amount;\r\n                    i = _to + 1;\r\n                }\r\n                else o += 1"
                  BinaryOperation using operator &&
                     Type: bool
                     Gas costs: 596
                     Source: "_tokenAmount < _tokenAmounto\r\n                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmount)"
                    BinaryOperation using operator <
                       Type: bool
                       Source: "_tokenAmount < _tokenAmounto"
                      Identifier _tokenAmount
                         Type: uint256
                         Source: "_tokenAmount"
                      Identifier _tokenAmounto
                         Type: uint256
                         Source: "_tokenAmounto"
                    FunctionCall
                       Type: bool
                       Source: "transferFromTo(msg.sender, orders[o].buyer, _tokenAmount)"
                      Identifier transferFromTo
                         Type: function (address,address,uint256) returns (bool)
                         Source: "transferFromTo"
                      MemberAccess to member sender
                         Type: address
                         Source: "msg.sender"
                        Identifier msg
                           Type: msg
                           Source: "msg"
                      MemberAccess to member buyer
                         Type: address
                         Source: "orders[o].buyer"
                        IndexAccess
                           Type: struct PassManager.order storage ref
                           Source: "orders[o]"
                          Identifier orders
                             Type: struct PassManager.order storage ref[] storage ref
                             Source: "orders"
                          Identifier o
                             Type: uint256
                             Source: "o"
                      Identifier _tokenAmount
                         Type: uint256
                         Source: "_tokenAmount"
                  Block
                     Source: "{\r\n                        \r\n                    _amount = weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0));\r\n                    orders[o].weiGiven -= _amount;\r\n                    _totalAmount += _amount;\r\n                    i = _to + 1;\r\n                }"
                    ExpressionStatement
                       Gas costs: 48
                       Source: "_amount = weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0))"
                      Assignment using operator =
                         Type: uint256
                         Source: "_amount = weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0))"
                        Identifier _amount
                           Type: uint256
                           Source: "_amount"
                        FunctionCall
                           Type: uint256
                           Source: "weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0))"
                          Identifier weiAmount
                             Type: function (uint256,uint256,uint256) view returns (uint256)
                             Source: "weiAmount"
                          Identifier _tokenAmount
                             Type: uint256
                             Source: "_tokenAmount"
                          FunctionCall
                             Type: uint256
                             Source: "priceMultiplier(0)"
                            Identifier priceMultiplier
                               Type: function (uint256) view returns (uint256)
                               Source: "priceMultiplier"
                            Literal, token: [no token] value: 0
                               Type: int_const 0
                               Source: "0"
                          FunctionCall
                             Type: uint256
                             Source: "actualPriceDivisor(0)"
                            Identifier actualPriceDivisor
                               Type: function (uint256) view returns (uint256)
                               Source: "actualPriceDivisor"
                            Literal, token: [no token] value: 0
                               Type: int_const 0
                               Source: "0"
                    ExpressionStatement
                       Gas costs: 20539
                       Source: "orders[o].weiGiven -= _amount"
                      Assignment using operator -=
                         Type: uint256
                         Source: "orders[o].weiGiven -= _amount"
                        MemberAccess to member weiGiven
                           Type: uint256
                           Source: "orders[o].weiGiven"
                          IndexAccess
                             Type: struct PassManager.order storage ref
                             Source: "orders[o]"
                            Identifier orders
                               Type: struct PassManager.order storage ref[] storage ref
                               Source: "orders"
                            Identifier o
                               Type: uint256
                               Source: "o"
                        Identifier _amount
                           Type: uint256
                           Source: "_amount"
                    ExpressionStatement
                       Gas costs: 14
                       Source: "_totalAmount += _amount"
                      Assignment using operator +=
                         Type: uint256
                         Source: "_totalAmount += _amount"
                        Identifier _totalAmount
                           Type: uint256
                           Source: "_totalAmount"
                        Identifier _amount
                           Type: uint256
                           Source: "_amount"
                    ExpressionStatement
                       Gas costs: 14
                       Source: "i = _to + 1"
                      Assignment using operator =
                         Type: uint256
                         Source: "i = _to + 1"
                        Identifier i
                           Type: uint256
                           Source: "i"
                        BinaryOperation using operator +
                           Type: uint256
                           Source: "_to + 1"
                          Identifier _to
                             Type: uint256
                             Source: "_to"
                          Literal, token: [no token] value: 1
                             Type: int_const 1
                             Source: "1"
                  ExpressionStatement
                     Gas costs: 14
                     Source: "o += 1"
                    Assignment using operator +=
                       Type: uint256
                       Source: "o += 1"
                      Identifier o
                         Type: uint256
                         Source: "o"
                      Literal, token: [no token] value: 1
                         Type: int_const 1
                         Source: "1"
            ExpressionStatement
               Gas costs: 14
               Source: "o += 1"
              Assignment using operator +=
                 Type: uint256
                 Source: "o += 1"
                Identifier o
                   Type: uint256
                   Source: "o"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      IfStatement
         Source: "if (!msg.sender.send(_totalAmount)) throw;\r\n        else return _totalAmount"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!msg.sender.send(_totalAmount)"
          FunctionCall
             Type: bool
             Source: "msg.sender.send(_totalAmount)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "msg.sender.send"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _totalAmount
               Type: uint256
               Source: "_totalAmount"
        Throw
           Gas costs: 6
           Source: "throw"
        Return
           Gas costs: 8
           Source: "return _totalAmount"
          Identifier _totalAmount
             Type: uint256
             Source: "_totalAmount"
  FunctionDefinition "removeOrders" - public
     Source: "function removeOrders(\r\n        uint _from,\r\n        uint _to) returns (bool) {\r\n\r\n        if (_to == 0 || _to > numberOfOrders) _to = numberOfOrders -1;\r\n        \r\n        uint _totalAmount;\r\n        uint o = _from;\r\n\r\n        for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (orders[o].buyer == msg.sender) {\r\n                \r\n                _totalAmount += orders[o].weiGiven;\r\n                removeOrder(o);\r\n\r\n            } else o += 1;\r\n        }\r\n\r\n        if (!msg.sender.send(_totalAmount)) throw;\r\n        else return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint _from,\r\n        uint _to)"
      VariableDeclaration "_from"
         Type: uint256
         Source: "uint _from"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_to"
         Type: uint256
         Source: "uint _to"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n        if (_to == 0 || _to > numberOfOrders) _to = numberOfOrders -1;\r\n        \r\n        uint _totalAmount;\r\n        uint o = _from;\r\n\r\n        for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (orders[o].buyer == msg.sender) {\r\n                \r\n                _totalAmount += orders[o].weiGiven;\r\n                removeOrder(o);\r\n\r\n            } else o += 1;\r\n        }\r\n\r\n        if (!msg.sender.send(_totalAmount)) throw;\r\n        else return true;\r\n    }"
      IfStatement
         Source: "if (_to == 0 || _to > numberOfOrders) _to = numberOfOrders -1"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 237
           Source: "_to == 0 || _to > numberOfOrders"
          BinaryOperation using operator ==
             Type: bool
             Source: "_to == 0"
            Identifier _to
               Type: uint256
               Source: "_to"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator >
             Type: bool
             Source: "_to > numberOfOrders"
            Identifier _to
               Type: uint256
               Source: "_to"
            Identifier numberOfOrders
               Type: uint256
               Source: "numberOfOrders"
        ExpressionStatement
           Gas costs: 214
           Source: "_to = numberOfOrders -1"
          Assignment using operator =
             Type: uint256
             Source: "_to = numberOfOrders -1"
            Identifier _to
               Type: uint256
               Source: "_to"
            BinaryOperation using operator -
               Type: uint256
               Source: "numberOfOrders -1"
              Identifier numberOfOrders
                 Type: uint256
                 Source: "numberOfOrders"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint _totalAmount"
        VariableDeclaration "_totalAmount"
           Type: uint256
           Source: "uint _totalAmount"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint o = _from"
        VariableDeclaration "o"
           Type: uint256
           Source: "uint o"
          ElementaryTypeName uint
             Source: "uint"
        Identifier _from
           Type: uint256
           Source: "_from"
      ForStatement
         Source: "for (uint i = _from; i <= _to; i++) {\r\n\r\n            if (orders[o].buyer == msg.sender) {\r\n                \r\n                _totalAmount += orders[o].weiGiven;\r\n                removeOrder(o);\r\n\r\n            } else o += 1;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = _from"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Identifier _from
             Type: uint256
             Source: "_from"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 12
           Source: "i <= _to"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier _to
             Type: uint256
             Source: "_to"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n\r\n            if (orders[o].buyer == msg.sender) {\r\n                \r\n                _totalAmount += orders[o].weiGiven;\r\n                removeOrder(o);\r\n\r\n            } else o += 1;\r\n        }"
          IfStatement
             Source: "if (orders[o].buyer == msg.sender) {\r\n                \r\n                _totalAmount += orders[o].weiGiven;\r\n                removeOrder(o);\r\n\r\n            } else o += 1"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 562
               Source: "orders[o].buyer == msg.sender"
              MemberAccess to member buyer
                 Type: address
                 Source: "orders[o].buyer"
                IndexAccess
                   Type: struct PassManager.order storage ref
                   Source: "orders[o]"
                  Identifier orders
                     Type: struct PassManager.order storage ref[] storage ref
                     Source: "orders"
                  Identifier o
                     Type: uint256
                     Source: "o"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Block
               Source: "{\r\n                \r\n                _totalAmount += orders[o].weiGiven;\r\n                removeOrder(o);\r\n\r\n            }"
              ExpressionStatement
                 Gas costs: 520
                 Source: "_totalAmount += orders[o].weiGiven"
                Assignment using operator +=
                   Type: uint256
                   Source: "_totalAmount += orders[o].weiGiven"
                  Identifier _totalAmount
                     Type: uint256
                     Source: "_totalAmount"
                  MemberAccess to member weiGiven
                     Type: uint256
                     Source: "orders[o].weiGiven"
                    IndexAccess
                       Type: struct PassManager.order storage ref
                       Source: "orders[o]"
                      Identifier orders
                         Type: struct PassManager.order storage ref[] storage ref
                         Source: "orders"
                      Identifier o
                         Type: uint256
                         Source: "o"
              ExpressionStatement
                 Gas costs: 18
                 Source: "removeOrder(o)"
                FunctionCall
                   Type: tuple()
                   Source: "removeOrder(o)"
                  Identifier removeOrder
                     Type: function (uint256)
                     Source: "removeOrder"
                  Identifier o
                     Type: uint256
                     Source: "o"
            ExpressionStatement
               Gas costs: 14
               Source: "o += 1"
              Assignment using operator +=
                 Type: uint256
                 Source: "o += 1"
                Identifier o
                   Type: uint256
                   Source: "o"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      IfStatement
         Source: "if (!msg.sender.send(_totalAmount)) throw;\r\n        else return true"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!msg.sender.send(_totalAmount)"
          FunctionCall
             Type: bool
             Source: "msg.sender.send(_totalAmount)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "msg.sender.send"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _totalAmount
               Type: uint256
               Source: "_totalAmount"
        Throw
           Gas costs: 6
           Source: "throw"
        Return
           Gas costs: 8
           Source: "return true"
          Literal, token: true value: true
             Type: bool
             Source: "true"
