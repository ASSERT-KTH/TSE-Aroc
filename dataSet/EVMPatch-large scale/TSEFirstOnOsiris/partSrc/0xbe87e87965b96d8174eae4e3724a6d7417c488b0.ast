Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xbe87e87965b96d8174eae4e3724a6d7417c488b0.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.6;"
ContractDefinition "tokenRecipient"
   Gas costs: 0
   Source: "contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }"
  FunctionDefinition "receiveApproval" - public
     Source: "function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);"
    ParameterList
       Source: "(address _from, uint256 _value, address _token, bytes _extraData)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: ""
ContractDefinition "EdgelessToken"
   Source: "contract EdgelessToken {\r\n    /* Public variables of the token */\r\n    string public standard = 'ERC20';\r\n    string public name = 'Edgeless';\r\n    string public symbol = 'EDG';\r\n    uint8 public decimals = 0;\r\n    uint256 public totalSupply;\r\n    uint256 public currentInterval = 1;\r\n    uint256 public intervalLength = 30 days;\r\n    uint256 public startTime = 1490112000;//from this time on tokens may be transfered (after ICO)\r\n    address public owner;\r\n    bool burned;//tells if tokens have been burned already\r\n\r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    /* Defines how many tokens of which addresses are locked in which interval*/\r\n    mapping(address => mapping(uint256=>uint256)) public locked;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Lock(address indexed owner, uint256 interval, uint256 value);\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function EdgelessToken() {\r\n        owner = 0x003230BBE64eccD66f62913679C8966Cf9F41166;\r\n        balanceOf[owner] = 500000000;              // Give the owner all initial tokens\r\n        totalSupply = 500000000;                   // Update total supply\r\n        for(uint8 i = 1; i < 13; i++)\t\t   // lock owner's final share of tokens for the first 12 months\r\n        \tlocked[owner][i] = 50000000;\r\n    }\r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) returns (bool success){\r\n        if (now < startTime) throw; //check if the crowdsale is already over\r\n        if (locked[msg.sender][getInterval()] >= balanceOf[msg.sender] || balanceOf[msg.sender]-locked[msg.sender][getInterval()] < _value) throw;   // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\r\n        balanceOf[_to] += _value;                            // Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\r\n        return true;\r\n    }\r\n\r\n    /* Allow another contract to spend some tokens in your behalf */\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /* Approve and then comunicate the approved contract in a single tx */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /* A contract attempts to get the coins */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (now < startTime && _from!=owner) throw; //check if the crowdsale is already over\r\n        if (locked[_from][getInterval()] >= balanceOf[_from] || balanceOf[_from]-locked[_from][getInterval()] < _value) throw;     // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\r\n        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance\r\n        balanceOf[_from] -= _value;                          // Subtract from the sender\r\n        balanceOf[_to] += _value;                            // Add the same to the recipient\r\n        allowance[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /* Lock a number of tokens */\r\n    function lock(address holder, uint256 _value) returns (bool success) {\r\n        if(holder==msg.sender||holder==tx.origin){\r\n            locked[holder][getInterval()]+=_value;\r\n            Lock(holder, currentInterval, _value);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /* Increase the interval, if sufficient time has passed */\r\n    function getInterval() returns (uint256 interval){\r\n        if (now > currentInterval * intervalLength + startTime) {\r\n            currentInterval = (now - startTime) / intervalLength + 1;\r\n        }\r\n        return currentInterval;\r\n    }\r\n\r\n    /* to be called when ICO is closed, burns the remaining tokens but the owners share (50 000 000) and the ones reserved\r\n    for the bounty program (10 000 000).\r\n    anybody may burn the tokens after ICO ended, but only once (in case the owner holds more tokens in the future). */\r\n    function burn(){\r\n    \t//if tokens have not been burned already and the ICO ended\r\n    \tif(!burned && now>startTime && balanceOf[owner] > 60000000){\r\n    \t\tuint difference = balanceOf[owner] - 60000000;\r\n    \t\tbalanceOf[owner] = 60000000;\r\n    \t\ttotalSupply -= difference;\r\n    \t\tburned = true;\r\n    \t}\r\n    }\r\n\r\n}"
  VariableDeclaration "standard"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public standard = 'ERC20'"
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: ERC20
       Type: literal_string "ERC20"
       Source: "'ERC20'"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public name = 'Edgeless'"
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Edgeless
       Type: literal_string "Edgeless"
       Source: "'Edgeless'"
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public symbol = 'EDG'"
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: EDG
       Type: literal_string "EDG"
       Source: "'EDG'"
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: [???]
     Source: "uint8 public decimals = 0"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "totalSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "currentInterval"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public currentInterval = 1"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 1
       Type: int_const 1
       Source: "1"
  VariableDeclaration "intervalLength"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public intervalLength = 30 days"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 30
       Type: int_const 2592000
       Source: "30 days"
  VariableDeclaration "startTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public startTime = 1490112000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 1490112000
       Type: int_const 1490112000
       Source: "1490112000"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "burned"
     Type: bool
     Gas costs: 0
     Source: "bool burned"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "balanceOf"
     Type: mapping(address => uint256)
     Gas costs: [???]
     Source: "mapping (address => uint256) public balanceOf"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowance"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: [???]
     Source: "mapping (address => mapping (address => uint256)) public allowance"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "locked"
     Type: mapping(address => mapping(uint256 => uint256))
     Gas costs: [???]
     Source: "mapping(address => mapping(uint256=>uint256)) public locked"
    Mapping
       Source: "mapping(address => mapping(uint256=>uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping(uint256=>uint256)"
        ElementaryTypeName uint256
           Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Gas costs: 0
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Gas costs: 0
     Source: "event Approval(address indexed owner, address indexed spender, uint256 value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint256 value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Lock"
     Gas costs: 0
     Source: "event Lock(address indexed owner, uint256 interval, uint256 value);"
    ParameterList
       Source: "(address indexed owner, uint256 interval, uint256 value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "interval"
         Type: uint256
         Source: "uint256 interval"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "EdgelessToken" - public
     Source: "function EdgelessToken() {\r\n        owner = 0x003230BBE64eccD66f62913679C8966Cf9F41166;\r\n        balanceOf[owner] = 500000000;              // Give the owner all initial tokens\r\n        totalSupply = 500000000;                   // Update total supply\r\n        for(uint8 i = 1; i < 13; i++)\t\t   // lock owner's final share of tokens for the first 12 months\r\n        \tlocked[owner][i] = 50000000;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = 0x003230BBE64eccD66f62913679C8966Cf9F41166;\r\n        balanceOf[owner] = 500000000;              // Give the owner all initial tokens\r\n        totalSupply = 500000000;                   // Update total supply\r\n        for(uint8 i = 1; i < 13; i++)\t\t   // lock owner's final share of tokens for the first 12 months\r\n        \tlocked[owner][i] = 50000000;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = 0x003230BBE64eccD66f62913679C8966Cf9F41166"
        Assignment using operator =
           Type: address
           Source: "owner = 0x003230BBE64eccD66f62913679C8966Cf9F41166"
          Identifier owner
             Type: address
             Source: "owner"
          Literal, token: [no token] value: 0x003230BBE64eccD66f62913679C8966Cf9F41166
             Type: address
             Source: "0x003230BBE64eccD66f62913679C8966Cf9F41166"
      ExpressionStatement
         Gas costs: 0
         Source: "balanceOf[owner] = 500000000"
        Assignment using operator =
           Type: uint256
           Source: "balanceOf[owner] = 500000000"
          IndexAccess
             Type: uint256
             Source: "balanceOf[owner]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier owner
               Type: address
               Source: "owner"
          Literal, token: [no token] value: 500000000
             Type: int_const 500000000
             Source: "500000000"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = 500000000"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = 500000000"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Literal, token: [no token] value: 500000000
             Type: int_const 500000000
             Source: "500000000"
      ForStatement
         Source: "for(uint8 i = 1; i < 13; i++)\t\t   // lock owner's final share of tokens for the first 12 months\r\n        \tlocked[owner][i] = 50000000"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint8 i = 1"
          VariableDeclaration "i"
             Type: uint8
             Source: "uint8 i"
            ElementaryTypeName uint8
               Source: "uint8"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < 13"
          Identifier i
             Type: uint8
             Source: "i"
          Literal, token: [no token] value: 13
             Type: int_const 13
             Source: "13"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint8
             Source: "i++"
            Identifier i
               Type: uint8
               Source: "i"
        ExpressionStatement
           Gas costs: 0
           Source: "locked[owner][i] = 50000000"
          Assignment using operator =
             Type: uint256
             Source: "locked[owner][i] = 50000000"
            IndexAccess
               Type: uint256
               Source: "locked[owner][i]"
              IndexAccess
                 Type: mapping(uint256 => uint256)
                 Source: "locked[owner]"
                Identifier locked
                   Type: mapping(address => mapping(uint256 => uint256))
                   Source: "locked"
                Identifier owner
                   Type: address
                   Source: "owner"
              Identifier i
                 Type: uint8
                 Source: "i"
            Literal, token: [no token] value: 50000000
               Type: int_const 50000000
               Source: "50000000"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success){\r\n        if (now < startTime) throw; //check if the crowdsale is already over\r\n        if (locked[msg.sender][getInterval()] >= balanceOf[msg.sender] || balanceOf[msg.sender]-locked[msg.sender][getInterval()] < _value) throw;   // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\r\n        balanceOf[_to] += _value;                            // Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if (now < startTime) throw; //check if the crowdsale is already over\r\n        if (locked[msg.sender][getInterval()] >= balanceOf[msg.sender] || balanceOf[msg.sender]-locked[msg.sender][getInterval()] < _value) throw;   // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\r\n        balanceOf[_to] += _value;                            // Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (now < startTime) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 208
           Source: "now < startTime"
          Identifier now
             Type: uint256
             Source: "now"
          Identifier startTime
             Type: uint256
             Source: "startTime"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (locked[msg.sender][getInterval()] >= balanceOf[msg.sender] || balanceOf[msg.sender]-locked[msg.sender][getInterval()] < _value) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: [???]
           Source: "locked[msg.sender][getInterval()] >= balanceOf[msg.sender] || balanceOf[msg.sender]-locked[msg.sender][getInterval()] < _value"
          BinaryOperation using operator >=
             Type: bool
             Source: "locked[msg.sender][getInterval()] >= balanceOf[msg.sender]"
            IndexAccess
               Type: uint256
               Source: "locked[msg.sender][getInterval()]"
              IndexAccess
                 Type: mapping(uint256 => uint256)
                 Source: "locked[msg.sender]"
                Identifier locked
                   Type: mapping(address => mapping(uint256 => uint256))
                   Source: "locked"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              FunctionCall
                 Type: uint256
                 Source: "getInterval()"
                Identifier getInterval
                   Type: function () returns (uint256)
                   Source: "getInterval"
            IndexAccess
               Type: uint256
               Source: "balanceOf[msg.sender]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          BinaryOperation using operator <
             Type: bool
             Source: "balanceOf[msg.sender]-locked[msg.sender][getInterval()] < _value"
            BinaryOperation using operator -
               Type: uint256
               Source: "balanceOf[msg.sender]-locked[msg.sender][getInterval()]"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[msg.sender]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              IndexAccess
                 Type: uint256
                 Source: "locked[msg.sender][getInterval()]"
                IndexAccess
                   Type: mapping(uint256 => uint256)
                   Source: "locked[msg.sender]"
                  Identifier locked
                     Type: mapping(address => mapping(uint256 => uint256))
                     Source: "locked"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                FunctionCall
                   Type: uint256
                   Source: "getInterval()"
                  Identifier getInterval
                     Type: function () returns (uint256)
                     Source: "getInterval"
            Identifier _value
               Type: uint256
               Source: "_value"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (balanceOf[_to] + _value < balanceOf[_to]) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 601
           Source: "balanceOf[_to] + _value < balanceOf[_to]"
          BinaryOperation using operator +
             Type: uint256
             Source: "balanceOf[_to] + _value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_to]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_to]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _to
               Type: address
               Source: "_to"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20328
         Source: "balanceOf[msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balanceOf[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_to]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowance[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowance[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowance[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowance[msg.sender]"
              Identifier allowance
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowance"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approveAndCall" - public
     Source: "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value, bytes _extraData)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "tokenRecipient spender = tokenRecipient(_spender)"
        VariableDeclaration "spender"
           Type: contract tokenRecipient
           Source: "tokenRecipient spender"
          UserDefinedTypeName "tokenRecipient"
             Source: "tokenRecipient"
        FunctionCall
           Type: contract tokenRecipient
           Source: "tokenRecipient(_spender)"
          Identifier tokenRecipient
             Type: type(contract tokenRecipient)
             Source: "tokenRecipient"
          Identifier _spender
             Type: address
             Source: "_spender"
      IfStatement
         Source: "if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 21
           Source: "approve(_spender, _value)"
          Identifier approve
             Type: function (address,uint256) returns (bool)
             Source: "approve"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
        Block
           Source: "{\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "spender.receiveApproval(msg.sender, _value, this, _extraData)"
            FunctionCall
               Type: tuple()
               Source: "spender.receiveApproval(msg.sender, _value, this, _extraData)"
              MemberAccess to member receiveApproval
                 Type: function (address,uint256,address,bytes memory) external
                 Source: "spender.receiveApproval"
                Identifier spender
                   Type: contract tokenRecipient
                   Source: "spender"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier this
                 Type: contract EdgelessToken
                 Source: "this"
              Identifier _extraData
                 Type: bytes memory
                 Source: "_extraData"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (now < startTime && _from!=owner) throw; //check if the crowdsale is already over\r\n        if (locked[_from][getInterval()] >= balanceOf[_from] || balanceOf[_from]-locked[_from][getInterval()] < _value) throw;     // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\r\n        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance\r\n        balanceOf[_from] -= _value;                          // Subtract from the sender\r\n        balanceOf[_to] += _value;                            // Add the same to the recipient\r\n        allowance[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if (now < startTime && _from!=owner) throw; //check if the crowdsale is already over\r\n        if (locked[_from][getInterval()] >= balanceOf[_from] || balanceOf[_from]-locked[_from][getInterval()] < _value) throw;     // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\r\n        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance\r\n        balanceOf[_from] -= _value;                          // Subtract from the sender\r\n        balanceOf[_to] += _value;                            // Add the same to the recipient\r\n        allowance[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (now < startTime && _from!=owner) throw"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 490
           Source: "now < startTime && _from!=owner"
          BinaryOperation using operator <
             Type: bool
             Source: "now < startTime"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier startTime
               Type: uint256
               Source: "startTime"
          BinaryOperation using operator !=
             Type: bool
             Source: "_from!=owner"
            Identifier _from
               Type: address
               Source: "_from"
            Identifier owner
               Type: address
               Source: "owner"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (locked[_from][getInterval()] >= balanceOf[_from] || balanceOf[_from]-locked[_from][getInterval()] < _value) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: [???]
           Source: "locked[_from][getInterval()] >= balanceOf[_from] || balanceOf[_from]-locked[_from][getInterval()] < _value"
          BinaryOperation using operator >=
             Type: bool
             Source: "locked[_from][getInterval()] >= balanceOf[_from]"
            IndexAccess
               Type: uint256
               Source: "locked[_from][getInterval()]"
              IndexAccess
                 Type: mapping(uint256 => uint256)
                 Source: "locked[_from]"
                Identifier locked
                   Type: mapping(address => mapping(uint256 => uint256))
                   Source: "locked"
                Identifier _from
                   Type: address
                   Source: "_from"
              FunctionCall
                 Type: uint256
                 Source: "getInterval()"
                Identifier getInterval
                   Type: function () returns (uint256)
                   Source: "getInterval"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_from]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _from
                 Type: address
                 Source: "_from"
          BinaryOperation using operator <
             Type: bool
             Source: "balanceOf[_from]-locked[_from][getInterval()] < _value"
            BinaryOperation using operator -
               Type: uint256
               Source: "balanceOf[_from]-locked[_from][getInterval()]"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[_from]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                Identifier _from
                   Type: address
                   Source: "_from"
              IndexAccess
                 Type: uint256
                 Source: "locked[_from][getInterval()]"
                IndexAccess
                   Type: mapping(uint256 => uint256)
                   Source: "locked[_from]"
                  Identifier locked
                     Type: mapping(address => mapping(uint256 => uint256))
                     Source: "locked"
                  Identifier _from
                     Type: address
                     Source: "_from"
                FunctionCall
                   Type: uint256
                   Source: "getInterval()"
                  Identifier getInterval
                     Type: function () returns (uint256)
                     Source: "getInterval"
            Identifier _value
               Type: uint256
               Source: "_value"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (balanceOf[_to] + _value < balanceOf[_to]) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 601
           Source: "balanceOf[_to] + _value < balanceOf[_to]"
          BinaryOperation using operator +
             Type: uint256
             Source: "balanceOf[_to] + _value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_to]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_to]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _to
               Type: address
               Source: "_to"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (_value > allowance[_from][msg.sender]) throw"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 394
           Source: "_value > allowance[_from][msg.sender]"
          Identifier _value
             Type: uint256
             Source: "_value"
          IndexAccess
             Type: uint256
             Source: "allowance[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowance[_from]"
              Identifier allowance
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowance"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20329
         Source: "balanceOf[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_from]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balanceOf[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_to]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20412
         Source: "allowance[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowance[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowance[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowance[_from]"
              Identifier allowance
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowance"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "lock" - public
     Source: "function lock(address holder, uint256 _value) returns (bool success) {\r\n        if(holder==msg.sender||holder==tx.origin){\r\n            locked[holder][getInterval()]+=_value;\r\n            Lock(holder, currentInterval, _value);\r\n            return true;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address holder, uint256 _value)"
      VariableDeclaration "holder"
         Type: address
         Source: "address holder"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if(holder==msg.sender||holder==tx.origin){\r\n            locked[holder][getInterval()]+=_value;\r\n            Lock(holder, currentInterval, _value);\r\n            return true;\r\n        }\r\n    }"
      IfStatement
         Source: "if(holder==msg.sender||holder==tx.origin){\r\n            locked[holder][getInterval()]+=_value;\r\n            Lock(holder, currentInterval, _value);\r\n            return true;\r\n        }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 59
           Source: "holder==msg.sender||holder==tx.origin"
          BinaryOperation using operator ==
             Type: bool
             Source: "holder==msg.sender"
            Identifier holder
               Type: address
               Source: "holder"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          BinaryOperation using operator ==
             Type: bool
             Source: "holder==tx.origin"
            Identifier holder
               Type: address
               Source: "holder"
            MemberAccess to member origin
               Type: address
               Source: "tx.origin"
              Identifier tx
                 Type: tx
                 Source: "tx"
        Block
           Source: "{\r\n            locked[holder][getInterval()]+=_value;\r\n            Lock(holder, currentInterval, _value);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "locked[holder][getInterval()]+=_value"
            Assignment using operator +=
               Type: uint256
               Source: "locked[holder][getInterval()]+=_value"
              IndexAccess
                 Type: uint256
                 Source: "locked[holder][getInterval()]"
                IndexAccess
                   Type: mapping(uint256 => uint256)
                   Source: "locked[holder]"
                  Identifier locked
                     Type: mapping(address => mapping(uint256 => uint256))
                     Source: "locked"
                  Identifier holder
                     Type: address
                     Source: "holder"
                FunctionCall
                   Type: uint256
                   Source: "getInterval()"
                  Identifier getInterval
                     Type: function () returns (uint256)
                     Source: "getInterval"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Lock(holder, currentInterval, _value)"
            FunctionCall
               Type: tuple()
               Source: "Lock(holder, currentInterval, _value)"
              Identifier Lock
                 Type: function (address,uint256,uint256)
                 Source: "Lock"
              Identifier holder
                 Type: address
                 Source: "holder"
              Identifier currentInterval
                 Type: uint256
                 Source: "currentInterval"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
  FunctionDefinition "getInterval" - public
     Source: "function getInterval() returns (uint256 interval){\r\n        if (now > currentInterval * intervalLength + startTime) {\r\n            currentInterval = (now - startTime) / intervalLength + 1;\r\n        }\r\n        return currentInterval;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256 interval)"
      VariableDeclaration "interval"
         Type: uint256
         Source: "uint256 interval"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        if (now > currentInterval * intervalLength + startTime) {\r\n            currentInterval = (now - startTime) / intervalLength + 1;\r\n        }\r\n        return currentInterval;\r\n    }"
      IfStatement
         Source: "if (now > currentInterval * intervalLength + startTime) {\r\n            currentInterval = (now - startTime) / intervalLength + 1;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 622
           Source: "now > currentInterval * intervalLength + startTime"
          Identifier now
             Type: uint256
             Source: "now"
          BinaryOperation using operator +
             Type: uint256
             Source: "currentInterval * intervalLength + startTime"
            BinaryOperation using operator *
               Type: uint256
               Source: "currentInterval * intervalLength"
              Identifier currentInterval
                 Type: uint256
                 Source: "currentInterval"
              Identifier intervalLength
                 Type: uint256
                 Source: "intervalLength"
            Identifier startTime
               Type: uint256
               Source: "startTime"
        Block
           Source: "{\r\n            currentInterval = (now - startTime) / intervalLength + 1;\r\n        }"
          ExpressionStatement
             Gas costs: 20456
             Source: "currentInterval = (now - startTime) / intervalLength + 1"
            Assignment using operator =
               Type: uint256
               Source: "currentInterval = (now - startTime) / intervalLength + 1"
              Identifier currentInterval
                 Type: uint256
                 Source: "currentInterval"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "(now - startTime) / intervalLength + 1"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "(now - startTime) / intervalLength"
                  TupleExpression
                     Type: uint256
                     Source: "(now - startTime)"
                    BinaryOperation using operator -
                       Type: uint256
                       Source: "now - startTime"
                      Identifier now
                         Type: uint256
                         Source: "now"
                      Identifier startTime
                         Type: uint256
                         Source: "startTime"
                  Identifier intervalLength
                     Type: uint256
                     Source: "intervalLength"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      Return
         Gas costs: 208
         Source: "return currentInterval"
        Identifier currentInterval
           Type: uint256
           Source: "currentInterval"
  FunctionDefinition "burn" - public
     Source: "function burn(){\r\n    \t//if tokens have not been burned already and the ICO ended\r\n    \tif(!burned && now>startTime && balanceOf[owner] > 60000000){\r\n    \t\tuint difference = balanceOf[owner] - 60000000;\r\n    \t\tbalanceOf[owner] = 60000000;\r\n    \t\ttotalSupply -= difference;\r\n    \t\tburned = true;\r\n    \t}\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    \t//if tokens have not been burned already and the ICO ended\r\n    \tif(!burned && now>startTime && balanceOf[owner] > 60000000){\r\n    \t\tuint difference = balanceOf[owner] - 60000000;\r\n    \t\tbalanceOf[owner] = 60000000;\r\n    \t\ttotalSupply -= difference;\r\n    \t\tburned = true;\r\n    \t}\r\n    }"
      IfStatement
         Source: "if(!burned && now>startTime && balanceOf[owner] > 60000000){\r\n    \t\tuint difference = balanceOf[owner] - 60000000;\r\n    \t\tbalanceOf[owner] = 60000000;\r\n    \t\ttotalSupply -= difference;\r\n    \t\tburned = true;\r\n    \t}"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 1085
           Source: "!burned && now>startTime && balanceOf[owner] > 60000000"
          BinaryOperation using operator &&
             Type: bool
             Source: "!burned && now>startTime"
            UnaryOperation (prefix) !
               Type: bool
               Source: "!burned"
              Identifier burned
                 Type: bool
                 Source: "burned"
            BinaryOperation using operator >
               Type: bool
               Source: "now>startTime"
              Identifier now
                 Type: uint256
                 Source: "now"
              Identifier startTime
                 Type: uint256
                 Source: "startTime"
          BinaryOperation using operator >
             Type: bool
             Source: "balanceOf[owner] > 60000000"
            IndexAccess
               Type: uint256
               Source: "balanceOf[owner]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier owner
                 Type: address
                 Source: "owner"
            Literal, token: [no token] value: 60000000
               Type: int_const 60000000
               Source: "60000000"
        Block
           Source: "{\r\n    \t\tuint difference = balanceOf[owner] - 60000000;\r\n    \t\tbalanceOf[owner] = 60000000;\r\n    \t\ttotalSupply -= difference;\r\n    \t\tburned = true;\r\n    \t}"
          VariableDeclarationStatement
             Gas costs: 549
             Source: "uint difference = balanceOf[owner] - 60000000"
            VariableDeclaration "difference"
               Type: uint256
               Source: "uint difference"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator -
               Type: uint256
               Source: "balanceOf[owner] - 60000000"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[owner]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                Identifier owner
                   Type: address
                   Source: "owner"
              Literal, token: [no token] value: 60000000
                 Type: int_const 60000000
                 Source: "60000000"
          ExpressionStatement
             Gas costs: 20340
             Source: "balanceOf[owner] = 60000000"
            Assignment using operator =
               Type: uint256
               Source: "balanceOf[owner] = 60000000"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[owner]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                Identifier owner
                   Type: address
                   Source: "owner"
              Literal, token: [no token] value: 60000000
                 Type: int_const 60000000
                 Source: "60000000"
          ExpressionStatement
             Gas costs: 20233
             Source: "totalSupply -= difference"
            Assignment using operator -=
               Type: uint256
               Source: "totalSupply -= difference"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
              Identifier difference
                 Type: uint256
                 Source: "difference"
          ExpressionStatement
             Gas costs: 20317
             Source: "burned = true"
            Assignment using operator =
               Type: bool
               Source: "burned = true"
              Identifier burned
                 Type: bool
                 Source: "burned"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
