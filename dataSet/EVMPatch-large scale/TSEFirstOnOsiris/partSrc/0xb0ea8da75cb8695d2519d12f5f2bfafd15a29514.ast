Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xb0ea8da75cb8695d2519d12f5f2bfafd15a29514.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.16;"
ContractDefinition "Token"
   Gas costs: [???]
   Source: "contract Token {   \r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public constant returns (uint256 balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public constant returns (uint256 remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is Token {\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {       \r\n        address sender = msg.sender;\r\n        require(balances[sender] >= _value);\r\n        balances[sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {      \r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }    \r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Token"
    UserDefinedTypeName "Token"
       Source: "Token"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balances"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool success) {       \r\n        address sender = msg.sender;\r\n        require(balances[sender] >= _value);\r\n        balances[sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(sender, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{       \r\n        address sender = msg.sender;\r\n        require(balances[sender] >= _value);\r\n        balances[sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(sender, _to, _value);\r\n        return true;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "address sender = msg.sender"
        VariableDeclaration "sender"
           Type: address
           Source: "address sender"
          ElementaryTypeName address
             Source: "address"
        MemberAccess to member sender
           Type: address
           Source: "msg.sender"
          Identifier msg
             Type: msg
             Source: "msg"
      ExpressionStatement
         Gas costs: 334
         Source: "require(balances[sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier sender
                 Type: address
                 Source: "sender"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier sender
               Type: address
               Source: "sender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier sender
             Type: address
             Source: "sender"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {      \r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{      \r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 753
         Source: "require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "balances[_from] >= _value && allowed[_from][msg.sender] >= _value"
            BinaryOperation using operator >=
               Type: bool
               Source: "balances[_from] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            BinaryOperation using operator >=
               Type: bool
               Source: "allowed[_from][msg.sender] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balances[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20412
         Source: "allowed[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowed[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balances[_owner];\r\n    }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {    \r\n    uint256 c = a / b;    \r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "mul"
     Source: "function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div"
     Source: "function div(uint256 a, uint256 b) internal returns (uint256) {    \r\n    uint256 c = a / b;    \r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{    \r\n    uint256 c = a / b;    \r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub"
     Source: "function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add"
     Source: "function add(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "GigaGivingToken"
   Source: "contract GigaGivingToken is StandardToken {\r\n    using SafeMath for uint256;\r\n         \r\n    uint256 private fundingGoal = 0 ether;\r\n    uint256 private amountRaised;\r\n\r\n    uint256 private constant PHASE_1_PRICE = 1600000000000000;\r\n    uint256 private constant PHASE_2_PRICE = 2000000000000000; \r\n    uint256 private constant PHASE_3_PRICE = 2500000000000000; \r\n    uint256 private constant PHASE_4_PRICE = 4000000000000000;\r\n    uint256 private constant PHASE_5_PRICE = 5000000000000000; \r\n    uint256 private constant DURATION = 5 weeks;  \r\n\r\n    uint256 public constant TOTAL_TOKENS = 15000000;\r\n    uint256 public constant  CROWDSALE_TOKENS = 12000000;  \r\n    \r\n\r\n    uint256 public startTime;\r\n    uint256 public tokenSupply;\r\n \r\n    address public creator;\r\n    address public beneficiary;\r\n\r\n    string public name = \"Giga Coin\";\r\n    string public symbol = \"GC\";\r\n    string public version = \"GC.7\";\r\n    uint256 public decimals = 0;  \r\n    \r\n    // GigaGivingToken public tokenReward;\r\n    mapping(address => uint256) public ethBalanceOf;\r\n    bool public fundingGoalReached = false;\r\n    bool public crowdsaleClosed = false;   \r\n    bool public refundsOpen = false;   \r\n\r\n    function GigaGivingToken (address icoBeneficiary) public {\r\n        creator = msg.sender;\r\n        beneficiary = icoBeneficiary;\r\n        totalSupply = TOTAL_TOKENS;         \r\n        \r\n        balances[beneficiary] = TOTAL_TOKENS.sub(CROWDSALE_TOKENS);\r\n        Transfer(0x0, icoBeneficiary, TOTAL_TOKENS.sub(CROWDSALE_TOKENS));\r\n\r\n        balances[this] = CROWDSALE_TOKENS;\r\n        Transfer(0x0, this, CROWDSALE_TOKENS);              \r\n        tokenSupply = CROWDSALE_TOKENS;\r\n        \r\n        startTime = 1510765200;\r\n    }   \r\n  \r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n        return true;\r\n    } \r\n  \r\n    function () public payable {\r\n        require(now >= startTime);\r\n        require(now <= startTime + DURATION);\r\n        require(!crowdsaleClosed);\r\n        require(msg.value > 0);\r\n        uint256 amount = msg.value;\r\n        uint256 coinTotal = 0;      \r\n        \r\n        if (now > startTime + 4 weeks) {\r\n            coinTotal = amount.div(PHASE_5_PRICE);\r\n        } else if (now > startTime + 3 weeks) {\r\n            coinTotal = amount.div(PHASE_4_PRICE);\r\n        } else if (now > startTime + 2 weeks) {\r\n            coinTotal = amount.div(PHASE_3_PRICE);\r\n        } else if (now > startTime + 1 weeks) {\r\n            coinTotal = amount.div(PHASE_2_PRICE);\r\n        } else {\r\n            coinTotal = amount.div(PHASE_1_PRICE);\r\n        }\r\n\r\n        ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].add(amount);              \r\n        balances[msg.sender] = balances[msg.sender].add(coinTotal);\r\n        balances[this] = balances[this].sub(coinTotal);\r\n        amountRaised = amountRaised.add(amount);\r\n        tokenSupply = tokenSupply.sub(coinTotal);\r\n        transfer(msg.sender, coinTotal);\r\n    }  \r\n\r\n    modifier afterDeadline() { \r\n        if (now >= (startTime + DURATION)) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    function checkGoalReached() public afterDeadline {\r\n        if (amountRaised >= fundingGoal) {\r\n            fundingGoalReached = true;\r\n        }\r\n        crowdsaleClosed = true;\r\n    }\r\n\r\n    function safeWithdrawal() public afterDeadline {\r\n        if (refundsOpen) {\r\n            uint amount = ethBalanceOf[msg.sender];\r\n            ethBalanceOf[msg.sender] = 0;\r\n            if (amount > 0) {\r\n                if (!msg.sender.send(amount)) {\r\n                    ethBalanceOf[msg.sender] = amount;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (fundingGoalReached && beneficiary == msg.sender) {\r\n            if (beneficiary.send(amountRaised)) {\r\n                this.transfer(msg.sender, tokenSupply);\r\n            } else {               \r\n                fundingGoalReached = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function enableRefunds() public afterDeadline {\r\n        require(msg.sender == beneficiary);\r\n        refundsOpen = true;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "fundingGoal"
     Type: uint256
     Gas costs: 0
     Source: "uint256 private fundingGoal = 0 ether"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0 ether"
  VariableDeclaration "amountRaised"
     Type: uint256
     Gas costs: 0
     Source: "uint256 private amountRaised"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "PHASE_1_PRICE"
     Type: uint256
     Gas costs: 3
     Source: "uint256 private constant PHASE_1_PRICE = 1600000000000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 1600000000000000
       Type: int_const 1600000000000000
       Source: "1600000000000000"
  VariableDeclaration "PHASE_2_PRICE"
     Type: uint256
     Gas costs: 3
     Source: "uint256 private constant PHASE_2_PRICE = 2000000000000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 2000000000000000
       Type: int_const 2000000000000000
       Source: "2000000000000000"
  VariableDeclaration "PHASE_3_PRICE"
     Type: uint256
     Gas costs: 3
     Source: "uint256 private constant PHASE_3_PRICE = 2500000000000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 2500000000000000
       Type: int_const 2500000000000000
       Source: "2500000000000000"
  VariableDeclaration "PHASE_4_PRICE"
     Type: uint256
     Gas costs: 3
     Source: "uint256 private constant PHASE_4_PRICE = 4000000000000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 4000000000000000
       Type: int_const 4000000000000000
       Source: "4000000000000000"
  VariableDeclaration "PHASE_5_PRICE"
     Type: uint256
     Gas costs: 3
     Source: "uint256 private constant PHASE_5_PRICE = 5000000000000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 5000000000000000
       Type: int_const 5000000000000000
       Source: "5000000000000000"
  VariableDeclaration "DURATION"
     Type: uint256
     Gas costs: 12
     Source: "uint256 private constant DURATION = 5 weeks"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 5
       Type: int_const 3024000
       Source: "5 weeks"
  VariableDeclaration "TOTAL_TOKENS"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant TOTAL_TOKENS = 15000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 15000000
       Type: int_const 15000000
       Source: "15000000"
  VariableDeclaration "CROWDSALE_TOKENS"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant  CROWDSALE_TOKENS = 12000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 12000000
       Type: int_const 12000000
       Source: "12000000"
  VariableDeclaration "startTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public startTime"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "tokenSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public tokenSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "creator"
     Type: address
     Gas costs: [???]
     Source: "address public creator"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "beneficiary"
     Type: address
     Gas costs: [???]
     Source: "address public beneficiary"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public name = \"Giga Coin\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Giga Coin
       Type: literal_string "Giga Coin"
       Source: "\"Giga Coin\""
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public symbol = \"GC\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: GC
       Type: literal_string "GC"
       Source: "\"GC\""
  VariableDeclaration "version"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public version = \"GC.7\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: GC.7
       Type: literal_string "GC.7"
       Source: "\"GC.7\""
  VariableDeclaration "decimals"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public decimals = 0"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "ethBalanceOf"
     Type: mapping(address => uint256)
     Gas costs: [???]
     Source: "mapping(address => uint256) public ethBalanceOf"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "fundingGoalReached"
     Type: bool
     Gas costs: [???]
     Source: "bool public fundingGoalReached = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "crowdsaleClosed"
     Type: bool
     Gas costs: [???]
     Source: "bool public crowdsaleClosed = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "refundsOpen"
     Type: bool
     Gas costs: [???]
     Source: "bool public refundsOpen = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  FunctionDefinition "GigaGivingToken" - public
     Source: "function GigaGivingToken (address icoBeneficiary) public {\r\n        creator = msg.sender;\r\n        beneficiary = icoBeneficiary;\r\n        totalSupply = TOTAL_TOKENS;         \r\n        \r\n        balances[beneficiary] = TOTAL_TOKENS.sub(CROWDSALE_TOKENS);\r\n        Transfer(0x0, icoBeneficiary, TOTAL_TOKENS.sub(CROWDSALE_TOKENS));\r\n\r\n        balances[this] = CROWDSALE_TOKENS;\r\n        Transfer(0x0, this, CROWDSALE_TOKENS);              \r\n        tokenSupply = CROWDSALE_TOKENS;\r\n        \r\n        startTime = 1510765200;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address icoBeneficiary)"
      VariableDeclaration "icoBeneficiary"
         Type: address
         Source: "address icoBeneficiary"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        creator = msg.sender;\r\n        beneficiary = icoBeneficiary;\r\n        totalSupply = TOTAL_TOKENS;         \r\n        \r\n        balances[beneficiary] = TOTAL_TOKENS.sub(CROWDSALE_TOKENS);\r\n        Transfer(0x0, icoBeneficiary, TOTAL_TOKENS.sub(CROWDSALE_TOKENS));\r\n\r\n        balances[this] = CROWDSALE_TOKENS;\r\n        Transfer(0x0, this, CROWDSALE_TOKENS);              \r\n        tokenSupply = CROWDSALE_TOKENS;\r\n        \r\n        startTime = 1510765200;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "creator = msg.sender"
        Assignment using operator =
           Type: address
           Source: "creator = msg.sender"
          Identifier creator
             Type: address
             Source: "creator"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "beneficiary = icoBeneficiary"
        Assignment using operator =
           Type: address
           Source: "beneficiary = icoBeneficiary"
          Identifier beneficiary
             Type: address
             Source: "beneficiary"
          Identifier icoBeneficiary
             Type: address
             Source: "icoBeneficiary"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = TOTAL_TOKENS"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = TOTAL_TOKENS"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier TOTAL_TOKENS
             Type: uint256
             Source: "TOTAL_TOKENS"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[beneficiary] = TOTAL_TOKENS.sub(CROWDSALE_TOKENS)"
        Assignment using operator =
           Type: uint256
           Source: "balances[beneficiary] = TOTAL_TOKENS.sub(CROWDSALE_TOKENS)"
          IndexAccess
             Type: uint256
             Source: "balances[beneficiary]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier beneficiary
               Type: address
               Source: "beneficiary"
          FunctionCall
             Type: uint256
             Source: "TOTAL_TOKENS.sub(CROWDSALE_TOKENS)"
            MemberAccess to member sub
               Type: function (uint256,uint256) returns (uint256)
               Source: "TOTAL_TOKENS.sub"
              Identifier TOTAL_TOKENS
                 Type: uint256
                 Source: "TOTAL_TOKENS"
            Identifier CROWDSALE_TOKENS
               Type: uint256
               Source: "CROWDSALE_TOKENS"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(0x0, icoBeneficiary, TOTAL_TOKENS.sub(CROWDSALE_TOKENS))"
        FunctionCall
           Type: tuple()
           Source: "Transfer(0x0, icoBeneficiary, TOTAL_TOKENS.sub(CROWDSALE_TOKENS))"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
          Identifier icoBeneficiary
             Type: address
             Source: "icoBeneficiary"
          FunctionCall
             Type: uint256
             Source: "TOTAL_TOKENS.sub(CROWDSALE_TOKENS)"
            MemberAccess to member sub
               Type: function (uint256,uint256) returns (uint256)
               Source: "TOTAL_TOKENS.sub"
              Identifier TOTAL_TOKENS
                 Type: uint256
                 Source: "TOTAL_TOKENS"
            Identifier CROWDSALE_TOKENS
               Type: uint256
               Source: "CROWDSALE_TOKENS"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[this] = CROWDSALE_TOKENS"
        Assignment using operator =
           Type: uint256
           Source: "balances[this] = CROWDSALE_TOKENS"
          IndexAccess
             Type: uint256
             Source: "balances[this]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier this
               Type: contract GigaGivingToken
               Source: "this"
          Identifier CROWDSALE_TOKENS
             Type: uint256
             Source: "CROWDSALE_TOKENS"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(0x0, this, CROWDSALE_TOKENS)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(0x0, this, CROWDSALE_TOKENS)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
          Identifier this
             Type: contract GigaGivingToken
             Source: "this"
          Identifier CROWDSALE_TOKENS
             Type: uint256
             Source: "CROWDSALE_TOKENS"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenSupply = CROWDSALE_TOKENS"
        Assignment using operator =
           Type: uint256
           Source: "tokenSupply = CROWDSALE_TOKENS"
          Identifier tokenSupply
             Type: uint256
             Source: "tokenSupply"
          Identifier CROWDSALE_TOKENS
             Type: uint256
             Source: "CROWDSALE_TOKENS"
      ExpressionStatement
         Gas costs: 0
         Source: "startTime = 1510765200"
        Assignment using operator =
           Type: uint256
           Source: "startTime = 1510765200"
          Identifier startTime
             Type: uint256
             Source: "startTime"
          Literal, token: [no token] value: 1510765200
             Type: int_const 1510765200
             Source: "1510765200"
  FunctionDefinition "approveAndCall" - public
     Source: "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value, bytes _extraData)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData))"
        FunctionCall
           Type: tuple()
           Source: "require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)"
            MemberAccess to member call
               Type: function () payable returns (bool)
               Source: "_spender.call"
              Identifier _spender
                 Type: address
                 Source: "_spender"
            FunctionCall
               Type: bytes4
               Source: "bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\")))"
              ElementaryTypeNameExpression bytes4
                 Type: type(bytes4)
                 Source: "bytes4"
              FunctionCall
                 Type: bytes32
                 Source: "bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))"
                ElementaryTypeNameExpression bytes32
                   Type: type(bytes32)
                   Source: "bytes32"
                FunctionCall
                   Type: bytes32
                   Source: "sha3(\"receiveApproval(address,uint256,address,bytes)\")"
                  Identifier sha3
                     Type: function () pure returns (bytes32)
                     Source: "sha3"
                  Literal, token: [no token] value: receiveApproval(address,uint256,address,bytes)
                     Type: literal_string "receiveApproval(address,uint256,address,bytes)"
                     Source: "\"receiveApproval(address,uint256,address,bytes)\""
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
            Identifier this
               Type: contract GigaGivingToken
               Source: "this"
            Identifier _extraData
               Type: bytes memory
               Source: "_extraData"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "" - public
     Source: "function () public payable {\r\n        require(now >= startTime);\r\n        require(now <= startTime + DURATION);\r\n        require(!crowdsaleClosed);\r\n        require(msg.value > 0);\r\n        uint256 amount = msg.value;\r\n        uint256 coinTotal = 0;      \r\n        \r\n        if (now > startTime + 4 weeks) {\r\n            coinTotal = amount.div(PHASE_5_PRICE);\r\n        } else if (now > startTime + 3 weeks) {\r\n            coinTotal = amount.div(PHASE_4_PRICE);\r\n        } else if (now > startTime + 2 weeks) {\r\n            coinTotal = amount.div(PHASE_3_PRICE);\r\n        } else if (now > startTime + 1 weeks) {\r\n            coinTotal = amount.div(PHASE_2_PRICE);\r\n        } else {\r\n            coinTotal = amount.div(PHASE_1_PRICE);\r\n        }\r\n\r\n        ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].add(amount);              \r\n        balances[msg.sender] = balances[msg.sender].add(coinTotal);\r\n        balances[this] = balances[this].sub(coinTotal);\r\n        amountRaised = amountRaised.add(amount);\r\n        tokenSupply = tokenSupply.sub(coinTotal);\r\n        transfer(msg.sender, coinTotal);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(now >= startTime);\r\n        require(now <= startTime + DURATION);\r\n        require(!crowdsaleClosed);\r\n        require(msg.value > 0);\r\n        uint256 amount = msg.value;\r\n        uint256 coinTotal = 0;      \r\n        \r\n        if (now > startTime + 4 weeks) {\r\n            coinTotal = amount.div(PHASE_5_PRICE);\r\n        } else if (now > startTime + 3 weeks) {\r\n            coinTotal = amount.div(PHASE_4_PRICE);\r\n        } else if (now > startTime + 2 weeks) {\r\n            coinTotal = amount.div(PHASE_3_PRICE);\r\n        } else if (now > startTime + 1 weeks) {\r\n            coinTotal = amount.div(PHASE_2_PRICE);\r\n        } else {\r\n            coinTotal = amount.div(PHASE_1_PRICE);\r\n        }\r\n\r\n        ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].add(amount);              \r\n        balances[msg.sender] = balances[msg.sender].add(coinTotal);\r\n        balances[this] = balances[this].sub(coinTotal);\r\n        amountRaised = amountRaised.add(amount);\r\n        tokenSupply = tokenSupply.sub(coinTotal);\r\n        transfer(msg.sender, coinTotal);\r\n    }"
      ExpressionStatement
         Gas costs: 237
         Source: "require(now >= startTime)"
        FunctionCall
           Type: tuple()
           Source: "require(now >= startTime)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "now >= startTime"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier startTime
               Type: uint256
               Source: "startTime"
      ExpressionStatement
         Gas costs: 240
         Source: "require(now <= startTime + DURATION)"
        FunctionCall
           Type: tuple()
           Source: "require(now <= startTime + DURATION)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "now <= startTime + DURATION"
            Identifier now
               Type: uint256
               Source: "now"
            BinaryOperation using operator +
               Type: uint256
               Source: "startTime + DURATION"
              Identifier startTime
                 Type: uint256
                 Source: "startTime"
              Identifier DURATION
                 Type: uint256
                 Source: "DURATION"
      ExpressionStatement
         Gas costs: 318
         Source: "require(!crowdsaleClosed)"
        FunctionCall
           Type: tuple()
           Source: "require(!crowdsaleClosed)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!crowdsaleClosed"
            Identifier crowdsaleClosed
               Type: bool
               Source: "crowdsaleClosed"
      ExpressionStatement
         Gas costs: 34
         Source: "require(msg.value > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "msg.value > 0"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint256 amount = msg.value"
        VariableDeclaration "amount"
           Type: uint256
           Source: "uint256 amount"
          ElementaryTypeName uint256
             Source: "uint256"
        MemberAccess to member value
           Type: uint256
           Source: "msg.value"
          Identifier msg
             Type: msg
             Source: "msg"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint256 coinTotal = 0"
        VariableDeclaration "coinTotal"
           Type: uint256
           Source: "uint256 coinTotal"
          ElementaryTypeName uint256
             Source: "uint256"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      IfStatement
         Source: "if (now > startTime + 4 weeks) {\r\n            coinTotal = amount.div(PHASE_5_PRICE);\r\n        } else if (now > startTime + 3 weeks) {\r\n            coinTotal = amount.div(PHASE_4_PRICE);\r\n        } else if (now > startTime + 2 weeks) {\r\n            coinTotal = amount.div(PHASE_3_PRICE);\r\n        } else if (now > startTime + 1 weeks) {\r\n            coinTotal = amount.div(PHASE_2_PRICE);\r\n        } else {\r\n            coinTotal = amount.div(PHASE_1_PRICE);\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 214
           Source: "now > startTime + 4 weeks"
          Identifier now
             Type: uint256
             Source: "now"
          BinaryOperation using operator +
             Type: uint256
             Source: "startTime + 4 weeks"
            Identifier startTime
               Type: uint256
               Source: "startTime"
            Literal, token: [no token] value: 4
               Type: int_const 2419200
               Source: "4 weeks"
        Block
           Source: "{\r\n            coinTotal = amount.div(PHASE_5_PRICE);\r\n        }"
          ExpressionStatement
             Gas costs: 38
             Source: "coinTotal = amount.div(PHASE_5_PRICE)"
            Assignment using operator =
               Type: uint256
               Source: "coinTotal = amount.div(PHASE_5_PRICE)"
              Identifier coinTotal
                 Type: uint256
                 Source: "coinTotal"
              FunctionCall
                 Type: uint256
                 Source: "amount.div(PHASE_5_PRICE)"
                MemberAccess to member div
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "amount.div"
                  Identifier amount
                     Type: uint256
                     Source: "amount"
                Identifier PHASE_5_PRICE
                   Type: uint256
                   Source: "PHASE_5_PRICE"
        IfStatement
           Source: "if (now > startTime + 3 weeks) {\r\n            coinTotal = amount.div(PHASE_4_PRICE);\r\n        } else if (now > startTime + 2 weeks) {\r\n            coinTotal = amount.div(PHASE_3_PRICE);\r\n        } else if (now > startTime + 1 weeks) {\r\n            coinTotal = amount.div(PHASE_2_PRICE);\r\n        } else {\r\n            coinTotal = amount.div(PHASE_1_PRICE);\r\n        }"
          BinaryOperation using operator >
             Type: bool
             Gas costs: 214
             Source: "now > startTime + 3 weeks"
            Identifier now
               Type: uint256
               Source: "now"
            BinaryOperation using operator +
               Type: uint256
               Source: "startTime + 3 weeks"
              Identifier startTime
                 Type: uint256
                 Source: "startTime"
              Literal, token: [no token] value: 3
                 Type: int_const 1814400
                 Source: "3 weeks"
          Block
             Source: "{\r\n            coinTotal = amount.div(PHASE_4_PRICE);\r\n        }"
            ExpressionStatement
               Gas costs: 38
               Source: "coinTotal = amount.div(PHASE_4_PRICE)"
              Assignment using operator =
                 Type: uint256
                 Source: "coinTotal = amount.div(PHASE_4_PRICE)"
                Identifier coinTotal
                   Type: uint256
                   Source: "coinTotal"
                FunctionCall
                   Type: uint256
                   Source: "amount.div(PHASE_4_PRICE)"
                  MemberAccess to member div
                     Type: function (uint256,uint256) returns (uint256)
                     Source: "amount.div"
                    Identifier amount
                       Type: uint256
                       Source: "amount"
                  Identifier PHASE_4_PRICE
                     Type: uint256
                     Source: "PHASE_4_PRICE"
          IfStatement
             Source: "if (now > startTime + 2 weeks) {\r\n            coinTotal = amount.div(PHASE_3_PRICE);\r\n        } else if (now > startTime + 1 weeks) {\r\n            coinTotal = amount.div(PHASE_2_PRICE);\r\n        } else {\r\n            coinTotal = amount.div(PHASE_1_PRICE);\r\n        }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 214
               Source: "now > startTime + 2 weeks"
              Identifier now
                 Type: uint256
                 Source: "now"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "startTime + 2 weeks"
                Identifier startTime
                   Type: uint256
                   Source: "startTime"
                Literal, token: [no token] value: 2
                   Type: int_const 1209600
                   Source: "2 weeks"
            Block
               Source: "{\r\n            coinTotal = amount.div(PHASE_3_PRICE);\r\n        }"
              ExpressionStatement
                 Gas costs: 38
                 Source: "coinTotal = amount.div(PHASE_3_PRICE)"
                Assignment using operator =
                   Type: uint256
                   Source: "coinTotal = amount.div(PHASE_3_PRICE)"
                  Identifier coinTotal
                     Type: uint256
                     Source: "coinTotal"
                  FunctionCall
                     Type: uint256
                     Source: "amount.div(PHASE_3_PRICE)"
                    MemberAccess to member div
                       Type: function (uint256,uint256) returns (uint256)
                       Source: "amount.div"
                      Identifier amount
                         Type: uint256
                         Source: "amount"
                    Identifier PHASE_3_PRICE
                       Type: uint256
                       Source: "PHASE_3_PRICE"
            IfStatement
               Source: "if (now > startTime + 1 weeks) {\r\n            coinTotal = amount.div(PHASE_2_PRICE);\r\n        } else {\r\n            coinTotal = amount.div(PHASE_1_PRICE);\r\n        }"
              BinaryOperation using operator >
                 Type: bool
                 Gas costs: 214
                 Source: "now > startTime + 1 weeks"
                Identifier now
                   Type: uint256
                   Source: "now"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "startTime + 1 weeks"
                  Identifier startTime
                     Type: uint256
                     Source: "startTime"
                  Literal, token: [no token] value: 1
                     Type: int_const 604800
                     Source: "1 weeks"
              Block
                 Source: "{\r\n            coinTotal = amount.div(PHASE_2_PRICE);\r\n        }"
                ExpressionStatement
                   Gas costs: 38
                   Source: "coinTotal = amount.div(PHASE_2_PRICE)"
                  Assignment using operator =
                     Type: uint256
                     Source: "coinTotal = amount.div(PHASE_2_PRICE)"
                    Identifier coinTotal
                       Type: uint256
                       Source: "coinTotal"
                    FunctionCall
                       Type: uint256
                       Source: "amount.div(PHASE_2_PRICE)"
                      MemberAccess to member div
                         Type: function (uint256,uint256) returns (uint256)
                         Source: "amount.div"
                        Identifier amount
                           Type: uint256
                           Source: "amount"
                      Identifier PHASE_2_PRICE
                         Type: uint256
                         Source: "PHASE_2_PRICE"
              Block
                 Source: "{\r\n            coinTotal = amount.div(PHASE_1_PRICE);\r\n        }"
                ExpressionStatement
                   Gas costs: 38
                   Source: "coinTotal = amount.div(PHASE_1_PRICE)"
                  Assignment using operator =
                     Type: uint256
                     Source: "coinTotal = amount.div(PHASE_1_PRICE)"
                    Identifier coinTotal
                       Type: uint256
                       Source: "coinTotal"
                    FunctionCall
                       Type: uint256
                       Source: "amount.div(PHASE_1_PRICE)"
                      MemberAccess to member div
                         Type: function (uint256,uint256) returns (uint256)
                         Source: "amount.div"
                        Identifier amount
                           Type: uint256
                           Source: "amount"
                      Identifier PHASE_1_PRICE
                         Type: uint256
                         Source: "PHASE_1_PRICE"
      ExpressionStatement
         Gas costs: 20437
         Source: "ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].add(amount)"
        Assignment using operator =
           Type: uint256
           Source: "ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].add(amount)"
          IndexAccess
             Type: uint256
             Source: "ethBalanceOf[msg.sender]"
            Identifier ethBalanceOf
               Type: mapping(address => uint256)
               Source: "ethBalanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "ethBalanceOf[msg.sender].add(amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) returns (uint256)
               Source: "ethBalanceOf[msg.sender].add"
              IndexAccess
                 Type: uint256
                 Source: "ethBalanceOf[msg.sender]"
                Identifier ethBalanceOf
                   Type: mapping(address => uint256)
                   Source: "ethBalanceOf"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier amount
               Type: uint256
               Source: "amount"
      ExpressionStatement
         Gas costs: 20431
         Source: "balances[msg.sender] = balances[msg.sender].add(coinTotal)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = balances[msg.sender].add(coinTotal)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "balances[msg.sender].add(coinTotal)"
            MemberAccess to member add
               Type: function (uint256,uint256) returns (uint256)
               Source: "balances[msg.sender].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier coinTotal
               Type: uint256
               Source: "coinTotal"
      ExpressionStatement
         Gas costs: 20431
         Source: "balances[this] = balances[this].sub(coinTotal)"
        Assignment using operator =
           Type: uint256
           Source: "balances[this] = balances[this].sub(coinTotal)"
          IndexAccess
             Type: uint256
             Source: "balances[this]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier this
               Type: contract GigaGivingToken
               Source: "this"
          FunctionCall
             Type: uint256
             Source: "balances[this].sub(coinTotal)"
            MemberAccess to member sub
               Type: function (uint256,uint256) returns (uint256)
               Source: "balances[this].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[this]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier this
                   Type: contract GigaGivingToken
                   Source: "this"
            Identifier coinTotal
               Type: uint256
               Source: "coinTotal"
      ExpressionStatement
         Gas costs: 20247
         Source: "amountRaised = amountRaised.add(amount)"
        Assignment using operator =
           Type: uint256
           Source: "amountRaised = amountRaised.add(amount)"
          Identifier amountRaised
             Type: uint256
             Source: "amountRaised"
          FunctionCall
             Type: uint256
             Source: "amountRaised.add(amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) returns (uint256)
               Source: "amountRaised.add"
              Identifier amountRaised
                 Type: uint256
                 Source: "amountRaised"
            Identifier amount
               Type: uint256
               Source: "amount"
      ExpressionStatement
         Gas costs: 20247
         Source: "tokenSupply = tokenSupply.sub(coinTotal)"
        Assignment using operator =
           Type: uint256
           Source: "tokenSupply = tokenSupply.sub(coinTotal)"
          Identifier tokenSupply
             Type: uint256
             Source: "tokenSupply"
          FunctionCall
             Type: uint256
             Source: "tokenSupply.sub(coinTotal)"
            MemberAccess to member sub
               Type: function (uint256,uint256) returns (uint256)
               Source: "tokenSupply.sub"
              Identifier tokenSupply
                 Type: uint256
                 Source: "tokenSupply"
            Identifier coinTotal
               Type: uint256
               Source: "coinTotal"
      ExpressionStatement
         Gas costs: 11
         Source: "transfer(msg.sender, coinTotal)"
        FunctionCall
           Type: bool
           Source: "transfer(msg.sender, coinTotal)"
          Identifier transfer
             Type: function (address,uint256) returns (bool)
             Source: "transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier coinTotal
             Type: uint256
             Source: "coinTotal"
  ModifierDefinition "afterDeadline"
     Source: "modifier afterDeadline() { \r\n        if (now >= (startTime + DURATION)) {\r\n            _;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ \r\n        if (now >= (startTime + DURATION)) {\r\n            _;\r\n        }\r\n    }"
      IfStatement
         Source: "if (now >= (startTime + DURATION)) {\r\n            _;\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 642
           Source: "now >= (startTime + DURATION)"
          Identifier now
             Type: uint256
             Source: "now"
          TupleExpression
             Type: uint256
             Source: "(startTime + DURATION)"
            BinaryOperation using operator +
               Type: uint256
               Source: "startTime + DURATION"
              Identifier startTime
                 Type: uint256
                 Source: "startTime"
              Identifier DURATION
                 Type: uint256
                 Source: "DURATION"
        Block
           Source: "{\r\n            _;\r\n        }"
          PlaceholderStatement
             Gas costs: 0
             Source: "_"
  FunctionDefinition "checkGoalReached" - public
     Source: "function checkGoalReached() public afterDeadline {\r\n        if (amountRaised >= fundingGoal) {\r\n            fundingGoalReached = true;\r\n        }\r\n        crowdsaleClosed = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "afterDeadline"
       Gas costs: 0
       Source: "afterDeadline"
      Identifier afterDeadline
         Type: modifier ()
         Source: "afterDeadline"
    Block
       Source: "{\r\n        if (amountRaised >= fundingGoal) {\r\n            fundingGoalReached = true;\r\n        }\r\n        crowdsaleClosed = true;\r\n    }"
      IfStatement
         Source: "if (amountRaised >= fundingGoal) {\r\n            fundingGoalReached = true;\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 412
           Source: "amountRaised >= fundingGoal"
          Identifier amountRaised
             Type: uint256
             Source: "amountRaised"
          Identifier fundingGoal
             Type: uint256
             Source: "fundingGoal"
        Block
           Source: "{\r\n            fundingGoalReached = true;\r\n        }"
          ExpressionStatement
             Gas costs: 20267
             Source: "fundingGoalReached = true"
            Assignment using operator =
               Type: bool
               Source: "fundingGoalReached = true"
              Identifier fundingGoalReached
                 Type: bool
                 Source: "fundingGoalReached"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
      ExpressionStatement
         Gas costs: 20317
         Source: "crowdsaleClosed = true"
        Assignment using operator =
           Type: bool
           Source: "crowdsaleClosed = true"
          Identifier crowdsaleClosed
             Type: bool
             Source: "crowdsaleClosed"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "safeWithdrawal" - public
     Source: "function safeWithdrawal() public afterDeadline {\r\n        if (refundsOpen) {\r\n            uint amount = ethBalanceOf[msg.sender];\r\n            ethBalanceOf[msg.sender] = 0;\r\n            if (amount > 0) {\r\n                if (!msg.sender.send(amount)) {\r\n                    ethBalanceOf[msg.sender] = amount;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (fundingGoalReached && beneficiary == msg.sender) {\r\n            if (beneficiary.send(amountRaised)) {\r\n                this.transfer(msg.sender, tokenSupply);\r\n            } else {               \r\n                fundingGoalReached = false;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "afterDeadline"
       Gas costs: 0
       Source: "afterDeadline"
      Identifier afterDeadline
         Type: modifier ()
         Source: "afterDeadline"
    Block
       Source: "{\r\n        if (refundsOpen) {\r\n            uint amount = ethBalanceOf[msg.sender];\r\n            ethBalanceOf[msg.sender] = 0;\r\n            if (amount > 0) {\r\n                if (!msg.sender.send(amount)) {\r\n                    ethBalanceOf[msg.sender] = amount;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (fundingGoalReached && beneficiary == msg.sender) {\r\n            if (beneficiary.send(amountRaised)) {\r\n                this.transfer(msg.sender, tokenSupply);\r\n            } else {               \r\n                fundingGoalReached = false;\r\n            }\r\n        }\r\n    }"
      IfStatement
         Source: "if (refundsOpen) {\r\n            uint amount = ethBalanceOf[msg.sender];\r\n            ethBalanceOf[msg.sender] = 0;\r\n            if (amount > 0) {\r\n                if (!msg.sender.send(amount)) {\r\n                    ethBalanceOf[msg.sender] = amount;\r\n                }\r\n            }\r\n        }"
        Identifier refundsOpen
           Type: bool
           Gas costs: 289
           Source: "refundsOpen"
        Block
           Source: "{\r\n            uint amount = ethBalanceOf[msg.sender];\r\n            ethBalanceOf[msg.sender] = 0;\r\n            if (amount > 0) {\r\n                if (!msg.sender.send(amount)) {\r\n                    ethBalanceOf[msg.sender] = amount;\r\n                }\r\n            }\r\n        }"
          VariableDeclarationStatement
             Gas costs: 306
             Source: "uint amount = ethBalanceOf[msg.sender]"
            VariableDeclaration "amount"
               Type: uint256
               Source: "uint amount"
              ElementaryTypeName uint
                 Source: "uint"
            IndexAccess
               Type: uint256
               Source: "ethBalanceOf[msg.sender]"
              Identifier ethBalanceOf
                 Type: mapping(address => uint256)
                 Source: "ethBalanceOf"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          ExpressionStatement
             Gas costs: 5103
             Source: "ethBalanceOf[msg.sender] = 0"
            Assignment using operator =
               Type: uint256
               Source: "ethBalanceOf[msg.sender] = 0"
              IndexAccess
                 Type: uint256
                 Source: "ethBalanceOf[msg.sender]"
                Identifier ethBalanceOf
                   Type: mapping(address => uint256)
                   Source: "ethBalanceOf"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          IfStatement
             Source: "if (amount > 0) {\r\n                if (!msg.sender.send(amount)) {\r\n                    ethBalanceOf[msg.sender] = amount;\r\n                }\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 9
               Source: "amount > 0"
              Identifier amount
                 Type: uint256
                 Source: "amount"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{\r\n                if (!msg.sender.send(amount)) {\r\n                    ethBalanceOf[msg.sender] = amount;\r\n                }\r\n            }"
              IfStatement
                 Source: "if (!msg.sender.send(amount)) {\r\n                    ethBalanceOf[msg.sender] = amount;\r\n                }"
                UnaryOperation (prefix) !
                   Type: bool
                   Gas costs: [???]
                   Source: "!msg.sender.send(amount)"
                  FunctionCall
                     Type: bool
                     Source: "msg.sender.send(amount)"
                    MemberAccess to member send
                       Type: function (uint256) returns (bool)
                       Source: "msg.sender.send"
                      MemberAccess to member sender
                         Type: address
                         Source: "msg.sender"
                        Identifier msg
                           Type: msg
                           Source: "msg"
                    Identifier amount
                       Type: uint256
                       Source: "amount"
                Block
                   Source: "{\r\n                    ethBalanceOf[msg.sender] = amount;\r\n                }"
                  ExpressionStatement
                     Gas costs: 20109
                     Source: "ethBalanceOf[msg.sender] = amount"
                    Assignment using operator =
                       Type: uint256
                       Source: "ethBalanceOf[msg.sender] = amount"
                      IndexAccess
                         Type: uint256
                         Source: "ethBalanceOf[msg.sender]"
                        Identifier ethBalanceOf
                           Type: mapping(address => uint256)
                           Source: "ethBalanceOf"
                        MemberAccess to member sender
                           Type: address
                           Source: "msg.sender"
                          Identifier msg
                             Type: msg
                             Source: "msg"
                      Identifier amount
                         Type: uint256
                         Source: "amount"
      IfStatement
         Source: "if (fundingGoalReached && beneficiary == msg.sender) {\r\n            if (beneficiary.send(amountRaised)) {\r\n                this.transfer(msg.sender, tokenSupply);\r\n            } else {               \r\n                fundingGoalReached = false;\r\n            }\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 517
           Source: "fundingGoalReached && beneficiary == msg.sender"
          Identifier fundingGoalReached
             Type: bool
             Source: "fundingGoalReached"
          BinaryOperation using operator ==
             Type: bool
             Source: "beneficiary == msg.sender"
            Identifier beneficiary
               Type: address
               Source: "beneficiary"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
        Block
           Source: "{\r\n            if (beneficiary.send(amountRaised)) {\r\n                this.transfer(msg.sender, tokenSupply);\r\n            } else {               \r\n                fundingGoalReached = false;\r\n            }\r\n        }"
          IfStatement
             Source: "if (beneficiary.send(amountRaised)) {\r\n                this.transfer(msg.sender, tokenSupply);\r\n            } else {               \r\n                fundingGoalReached = false;\r\n            }"
            FunctionCall
               Type: bool
               Gas costs: [???]
               Source: "beneficiary.send(amountRaised)"
              MemberAccess to member send
                 Type: function (uint256) returns (bool)
                 Source: "beneficiary.send"
                Identifier beneficiary
                   Type: address
                   Source: "beneficiary"
              Identifier amountRaised
                 Type: uint256
                 Source: "amountRaised"
            Block
               Source: "{\r\n                this.transfer(msg.sender, tokenSupply);\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "this.transfer(msg.sender, tokenSupply)"
                FunctionCall
                   Type: bool
                   Source: "this.transfer(msg.sender, tokenSupply)"
                  MemberAccess to member transfer
                     Type: function (address,uint256) external returns (bool)
                     Source: "this.transfer"
                    Identifier this
                       Type: contract GigaGivingToken
                       Source: "this"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier tokenSupply
                     Type: uint256
                     Source: "tokenSupply"
            Block
               Source: "{               \r\n                fundingGoalReached = false;\r\n            }"
              ExpressionStatement
                 Gas costs: 20267
                 Source: "fundingGoalReached = false"
                Assignment using operator =
                   Type: bool
                   Source: "fundingGoalReached = false"
                  Identifier fundingGoalReached
                     Type: bool
                     Source: "fundingGoalReached"
                  Literal, token: false value: false
                     Type: bool
                     Source: "false"
  FunctionDefinition "enableRefunds" - public
     Source: "function enableRefunds() public afterDeadline {\r\n        require(msg.sender == beneficiary);\r\n        refundsOpen = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "afterDeadline"
       Gas costs: 0
       Source: "afterDeadline"
      Identifier afterDeadline
         Type: modifier ()
         Source: "afterDeadline"
    Block
       Source: "{\r\n        require(msg.sender == beneficiary);\r\n        refundsOpen = true;\r\n    }"
      ExpressionStatement
         Gas costs: 282
         Source: "require(msg.sender == beneficiary)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == beneficiary)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == beneficiary"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier beneficiary
               Type: address
               Source: "beneficiary"
      ExpressionStatement
         Gas costs: 20317
         Source: "refundsOpen = true"
        Assignment using operator =
           Type: bool
           Source: "refundsOpen = true"
          Identifier refundsOpen
             Type: bool
             Source: "refundsOpen"
          Literal, token: true value: true
             Type: bool
             Source: "true"
