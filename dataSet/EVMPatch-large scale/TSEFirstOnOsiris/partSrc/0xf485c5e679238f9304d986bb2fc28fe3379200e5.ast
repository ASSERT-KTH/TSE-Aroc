Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xf485c5e679238f9304d986bb2fc28fe3379200e5.sol =======
ContractDefinition "Multiowned"
   Source: "contract Multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENT\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner, bytes32 operation);\r\n    event OwnerAdded(address newOwner, bytes32 operation);\r\n    event OwnerRemoved(address oldOwner, bytes32 operation);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement, bytes32 operation);\r\n    event Operation(bytes32 operation);\r\n\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyOwner {\r\n        if (isOwner(msg.sender))\r\n            _;\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlyManyOwners(bytes32 _operation) {\r\n        Operation(_operation);\r\n        if (confirmAndCheck(_operation))\r\n            _;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlyManyOwners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function Multiowned() public{\r\n        m_numOwners = 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        m_required = 1;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlyManyOwners(keccak256(msg.data)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to, keccak256(msg.data));\r\n    }\r\n    \r\n    function addOwner(address _owner) onlyManyOwners(keccak256(msg.data)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner,keccak256(msg.data));\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlyManyOwners(keccak256(msg.data)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner,keccak256(msg.data));\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlyManyOwners(keccak256(msg.data)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired,keccak256(msg.data));\r\n    }\r\n\r\n    function isOwner(address _addr) view public returns (bool){\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    //when the voting is complate, hasConfirmed return false\r\n    //if the voteing is ongoing, it returns whether _owner has voted the _operation\r\n    function hasConfirmed(bytes32 _operation, address _owner) view public returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        return !(pending.ownersDone & ownerIndexBit == 0);\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}"
  StructDefinition "PendingState"
     Gas costs: 0
     Source: "struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }"
    VariableDeclaration "yetNeeded"
       Type: uint256
       Source: "uint yetNeeded"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "ownersDone"
       Type: uint256
       Source: "uint ownersDone"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "index"
       Type: uint256
       Source: "uint index"
      ElementaryTypeName uint
         Source: "uint"
  EventDefinition "Confirmation"
     Gas costs: 0
     Source: "event Confirmation(address owner, bytes32 operation);"
    ParameterList
       Source: "(address owner, bytes32 operation)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "operation"
         Type: bytes32
         Source: "bytes32 operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
  EventDefinition "Revoke"
     Gas costs: 0
     Source: "event Revoke(address owner, bytes32 operation);"
    ParameterList
       Source: "(address owner, bytes32 operation)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "operation"
         Type: bytes32
         Source: "bytes32 operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
  EventDefinition "OwnerChanged"
     Gas costs: 0
     Source: "event OwnerChanged(address oldOwner, address newOwner, bytes32 operation);"
    ParameterList
       Source: "(address oldOwner, address newOwner, bytes32 operation)"
      VariableDeclaration "oldOwner"
         Type: address
         Source: "address oldOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "operation"
         Type: bytes32
         Source: "bytes32 operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
  EventDefinition "OwnerAdded"
     Gas costs: 0
     Source: "event OwnerAdded(address newOwner, bytes32 operation);"
    ParameterList
       Source: "(address newOwner, bytes32 operation)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "operation"
         Type: bytes32
         Source: "bytes32 operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
  EventDefinition "OwnerRemoved"
     Gas costs: 0
     Source: "event OwnerRemoved(address oldOwner, bytes32 operation);"
    ParameterList
       Source: "(address oldOwner, bytes32 operation)"
      VariableDeclaration "oldOwner"
         Type: address
         Source: "address oldOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "operation"
         Type: bytes32
         Source: "bytes32 operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
  EventDefinition "RequirementChanged"
     Gas costs: 0
     Source: "event RequirementChanged(uint newRequirement, bytes32 operation);"
    ParameterList
       Source: "(uint newRequirement, bytes32 operation)"
      VariableDeclaration "newRequirement"
         Type: uint256
         Source: "uint newRequirement"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "operation"
         Type: bytes32
         Source: "bytes32 operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
  EventDefinition "Operation"
     Gas costs: 0
     Source: "event Operation(bytes32 operation);"
    ParameterList
       Source: "(bytes32 operation)"
      VariableDeclaration "operation"
         Type: bytes32
         Source: "bytes32 operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner {\r\n        if (isOwner(msg.sender))\r\n            _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (isOwner(msg.sender))\r\n            _;\r\n    }"
      IfStatement
         Source: "if (isOwner(msg.sender))\r\n            _"
        FunctionCall
           Type: bool
           Gas costs: 6
           Source: "isOwner(msg.sender)"
          Identifier isOwner
             Type: function (address) view returns (bool)
             Source: "isOwner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
        PlaceholderStatement
           Gas costs: 0
           Source: "_"
  ModifierDefinition "onlyManyOwners"
     Source: "modifier onlyManyOwners(bytes32 _operation) {\r\n        Operation(_operation);\r\n        if (confirmAndCheck(_operation))\r\n            _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        Operation(_operation);\r\n        if (confirmAndCheck(_operation))\r\n            _;\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "Operation(_operation)"
        FunctionCall
           Type: tuple()
           Source: "Operation(_operation)"
          Identifier Operation
             Type: function (bytes32)
             Source: "Operation"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
      IfStatement
         Source: "if (confirmAndCheck(_operation))\r\n            _"
        FunctionCall
           Type: bool
           Gas costs: 79
           Source: "confirmAndCheck(_operation)"
          Identifier confirmAndCheck
             Type: function (bytes32) returns (bool)
             Source: "confirmAndCheck"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
        PlaceholderStatement
           Gas costs: 4
           Source: "_"
  FunctionDefinition "Multiowned" - public
     Source: "function Multiowned() public{\r\n        m_numOwners = 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        m_required = 1;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        m_numOwners = 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        m_required = 1;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "m_numOwners = 1"
        Assignment using operator =
           Type: uint256
           Source: "m_numOwners = 1"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "m_owners[1] = uint(msg.sender)"
        Assignment using operator =
           Type: uint256
           Source: "m_owners[1] = uint(msg.sender)"
          IndexAccess
             Type: uint256
             Source: "m_owners[1]"
            Identifier m_owners
               Type: uint256[256] storage ref
               Source: "m_owners"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          FunctionCall
             Type: uint256
             Source: "uint(msg.sender)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "m_ownerIndex[uint(msg.sender)] = 1"
        Assignment using operator =
           Type: uint256
           Source: "m_ownerIndex[uint(msg.sender)] = 1"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[uint(msg.sender)]"
            Identifier m_ownerIndex
               Type: mapping(uint256 => uint256)
               Source: "m_ownerIndex"
            FunctionCall
               Type: uint256
               Source: "uint(msg.sender)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "m_required = 1"
        Assignment using operator =
           Type: uint256
           Source: "m_required = 1"
          Identifier m_required
             Type: uint256
             Source: "m_required"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
  FunctionDefinition "revoke" - public
     Source: "function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 300
         Source: "uint ownerIndex = m_ownerIndex[uint(msg.sender)]"
        VariableDeclaration "ownerIndex"
           Type: uint256
           Source: "uint ownerIndex"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "m_ownerIndex[uint(msg.sender)]"
          Identifier m_ownerIndex
             Type: mapping(uint256 => uint256)
             Source: "m_ownerIndex"
          FunctionCall
             Type: uint256
             Source: "uint(msg.sender)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      IfStatement
         Source: "if (ownerIndex == 0) return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "ownerIndex == 0"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      VariableDeclarationStatement
         Gas costs: 1624
         Source: "uint ownerIndexBit = 2**ownerIndex"
        VariableDeclaration "ownerIndexBit"
           Type: uint256
           Source: "uint ownerIndexBit"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator **
           Type: uint256
           Source: "2**ownerIndex"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
      VariableDeclarationStatement
         Gas costs: 113
         Source: "var pending = m_pending[_operation]"
        VariableDeclaration "pending"
           Type: struct Multiowned.PendingState storage pointer
           Source: "var pending"
        IndexAccess
           Type: struct Multiowned.PendingState storage ref
           Source: "m_pending[_operation]"
          Identifier m_pending
             Type: mapping(bytes32 => struct Multiowned.PendingState storage ref)
             Source: "m_pending"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
      IfStatement
         Source: "if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 221
           Source: "pending.ownersDone & ownerIndexBit > 0"
          BinaryOperation using operator &
             Type: uint256
             Source: "pending.ownersDone & ownerIndexBit"
            MemberAccess to member ownersDone
               Type: uint256
               Source: "pending.ownersDone"
              Identifier pending
                 Type: struct Multiowned.PendingState storage pointer
                 Source: "pending"
            Identifier ownerIndexBit
               Type: uint256
               Source: "ownerIndexBit"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }"
          ExpressionStatement
             Gas costs: 20243
             Source: "pending.yetNeeded++"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "pending.yetNeeded++"
              MemberAccess to member yetNeeded
                 Type: uint256
                 Source: "pending.yetNeeded"
                Identifier pending
                   Type: struct Multiowned.PendingState storage pointer
                   Source: "pending"
          ExpressionStatement
             Gas costs: 20239
             Source: "pending.ownersDone -= ownerIndexBit"
            Assignment using operator -=
               Type: uint256
               Source: "pending.ownersDone -= ownerIndexBit"
              MemberAccess to member ownersDone
                 Type: uint256
                 Source: "pending.ownersDone"
                Identifier pending
                   Type: struct Multiowned.PendingState storage pointer
                   Source: "pending"
              Identifier ownerIndexBit
                 Type: uint256
                 Source: "ownerIndexBit"
          ExpressionStatement
             Gas costs: [???]
             Source: "Revoke(msg.sender, _operation)"
            FunctionCall
               Type: tuple()
               Source: "Revoke(msg.sender, _operation)"
              Identifier Revoke
                 Type: function (address,bytes32)
                 Source: "Revoke"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _operation
                 Type: bytes32
                 Source: "_operation"
  FunctionDefinition "changeOwner" - public
     Source: "function changeOwner(address _from, address _to) onlyManyOwners(keccak256(msg.data)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to, keccak256(msg.data));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyManyOwners"
       Gas costs: [???]
       Source: "onlyManyOwners(keccak256(msg.data))"
      Identifier onlyManyOwners
         Type: modifier (bytes32)
         Source: "onlyManyOwners"
      FunctionCall
         Type: bytes32
         Source: "keccak256(msg.data)"
        Identifier keccak256
           Type: function () pure returns (bytes32)
           Source: "keccak256"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to, keccak256(msg.data));\r\n    }"
      IfStatement
         Source: "if (isOwner(_to)) return;"
        FunctionCall
           Type: bool
           Gas costs: 18
           Source: "isOwner(_to)"
          Identifier isOwner
             Type: function (address) view returns (bool)
             Source: "isOwner"
          Identifier _to
             Type: address
             Source: "_to"
        Return
           Gas costs: 11
           Source: "return;"
      VariableDeclarationStatement
         Gas costs: 301
         Source: "uint ownerIndex = m_ownerIndex[uint(_from)]"
        VariableDeclaration "ownerIndex"
           Type: uint256
           Source: "uint ownerIndex"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "m_ownerIndex[uint(_from)]"
          Identifier m_ownerIndex
             Type: mapping(uint256 => uint256)
             Source: "m_ownerIndex"
          FunctionCall
             Type: uint256
             Source: "uint(_from)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            Identifier _from
               Type: address
               Source: "_from"
      IfStatement
         Source: "if (ownerIndex == 0) return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "ownerIndex == 0"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 15
         Source: "clearPending()"
        FunctionCall
           Type: tuple()
           Source: "clearPending()"
          Identifier clearPending
             Type: function ()
             Source: "clearPending"
      ExpressionStatement
         Gas costs: 20055
         Source: "m_owners[ownerIndex] = uint(_to)"
        Assignment using operator =
           Type: uint256
           Source: "m_owners[ownerIndex] = uint(_to)"
          IndexAccess
             Type: uint256
             Source: "m_owners[ownerIndex]"
            Identifier m_owners
               Type: uint256[256] storage ref
               Source: "m_owners"
            Identifier ownerIndex
               Type: uint256
               Source: "ownerIndex"
          FunctionCall
             Type: uint256
             Source: "uint(_to)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            Identifier _to
               Type: address
               Source: "_to"
      ExpressionStatement
         Gas costs: 5104
         Source: "m_ownerIndex[uint(_from)] = 0"
        Assignment using operator =
           Type: uint256
           Source: "m_ownerIndex[uint(_from)] = 0"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[uint(_from)]"
            Identifier m_ownerIndex
               Type: mapping(uint256 => uint256)
               Source: "m_ownerIndex"
            FunctionCall
               Type: uint256
               Source: "uint(_from)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              Identifier _from
                 Type: address
                 Source: "_from"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 20098
         Source: "m_ownerIndex[uint(_to)] = ownerIndex"
        Assignment using operator =
           Type: uint256
           Source: "m_ownerIndex[uint(_to)] = ownerIndex"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[uint(_to)]"
            Identifier m_ownerIndex
               Type: mapping(uint256 => uint256)
               Source: "m_ownerIndex"
            FunctionCall
               Type: uint256
               Source: "uint(_to)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              Identifier _to
                 Type: address
                 Source: "_to"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
      ExpressionStatement
         Gas costs: [???]
         Source: "OwnerChanged(_from, _to, keccak256(msg.data))"
        FunctionCall
           Type: tuple()
           Source: "OwnerChanged(_from, _to, keccak256(msg.data))"
          Identifier OwnerChanged
             Type: function (address,address,bytes32)
             Source: "OwnerChanged"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          FunctionCall
             Type: bytes32
             Source: "keccak256(msg.data)"
            Identifier keccak256
               Type: function () pure returns (bytes32)
               Source: "keccak256"
            MemberAccess to member data
               Type: bytes calldata
               Source: "msg.data"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "addOwner" - public
     Source: "function addOwner(address _owner) onlyManyOwners(keccak256(msg.data)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner,keccak256(msg.data));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyManyOwners"
       Gas costs: [???]
       Source: "onlyManyOwners(keccak256(msg.data))"
      Identifier onlyManyOwners
         Type: modifier (bytes32)
         Source: "onlyManyOwners"
      FunctionCall
         Type: bytes32
         Source: "keccak256(msg.data)"
        Identifier keccak256
           Type: function () pure returns (bytes32)
           Source: "keccak256"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner,keccak256(msg.data));\r\n    }"
      IfStatement
         Source: "if (isOwner(_owner)) return;"
        FunctionCall
           Type: bool
           Gas costs: 18
           Source: "isOwner(_owner)"
          Identifier isOwner
             Type: function (address) view returns (bool)
             Source: "isOwner"
          Identifier _owner
             Type: address
             Source: "_owner"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 15
         Source: "clearPending()"
        FunctionCall
           Type: tuple()
           Source: "clearPending()"
          Identifier clearPending
             Type: function ()
             Source: "clearPending"
      IfStatement
         Source: "if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners()"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 209
           Source: "m_numOwners >= c_maxOwners"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
          Identifier c_maxOwners
             Type: uint256
             Source: "c_maxOwners"
        ExpressionStatement
           Gas costs: 15
           Source: "reorganizeOwners()"
          FunctionCall
             Type: tuple()
             Source: "reorganizeOwners()"
            Identifier reorganizeOwners
               Type: function ()
               Source: "reorganizeOwners"
      IfStatement
         Source: "if (m_numOwners >= c_maxOwners)\r\n            return;"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 209
           Source: "m_numOwners >= c_maxOwners"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
          Identifier c_maxOwners
             Type: uint256
             Source: "c_maxOwners"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 20237
         Source: "m_numOwners++"
        UnaryOperation (postfix) ++
           Type: uint256
           Source: "m_numOwners++"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
      ExpressionStatement
         Gas costs: 20255
         Source: "m_owners[m_numOwners] = uint(_owner)"
        Assignment using operator =
           Type: uint256
           Source: "m_owners[m_numOwners] = uint(_owner)"
          IndexAccess
             Type: uint256
             Source: "m_owners[m_numOwners]"
            Identifier m_owners
               Type: uint256[256] storage ref
               Source: "m_owners"
            Identifier m_numOwners
               Type: uint256
               Source: "m_numOwners"
          FunctionCall
             Type: uint256
             Source: "uint(_owner)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            Identifier _owner
               Type: address
               Source: "_owner"
      ExpressionStatement
         Gas costs: 20304
         Source: "m_ownerIndex[uint(_owner)] = m_numOwners"
        Assignment using operator =
           Type: uint256
           Source: "m_ownerIndex[uint(_owner)] = m_numOwners"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[uint(_owner)]"
            Identifier m_ownerIndex
               Type: mapping(uint256 => uint256)
               Source: "m_ownerIndex"
            FunctionCall
               Type: uint256
               Source: "uint(_owner)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              Identifier _owner
                 Type: address
                 Source: "_owner"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
      ExpressionStatement
         Gas costs: [???]
         Source: "OwnerAdded(_owner,keccak256(msg.data))"
        FunctionCall
           Type: tuple()
           Source: "OwnerAdded(_owner,keccak256(msg.data))"
          Identifier OwnerAdded
             Type: function (address,bytes32)
             Source: "OwnerAdded"
          Identifier _owner
             Type: address
             Source: "_owner"
          FunctionCall
             Type: bytes32
             Source: "keccak256(msg.data)"
            Identifier keccak256
               Type: function () pure returns (bytes32)
               Source: "keccak256"
            MemberAccess to member data
               Type: bytes calldata
               Source: "msg.data"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "removeOwner" - public
     Source: "function removeOwner(address _owner) onlyManyOwners(keccak256(msg.data)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner,keccak256(msg.data));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyManyOwners"
       Gas costs: [???]
       Source: "onlyManyOwners(keccak256(msg.data))"
      Identifier onlyManyOwners
         Type: modifier (bytes32)
         Source: "onlyManyOwners"
      FunctionCall
         Type: bytes32
         Source: "keccak256(msg.data)"
        Identifier keccak256
           Type: function () pure returns (bytes32)
           Source: "keccak256"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner,keccak256(msg.data));\r\n    }"
      VariableDeclarationStatement
         Gas costs: 301
         Source: "uint ownerIndex = m_ownerIndex[uint(_owner)]"
        VariableDeclaration "ownerIndex"
           Type: uint256
           Source: "uint ownerIndex"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "m_ownerIndex[uint(_owner)]"
          Identifier m_ownerIndex
             Type: mapping(uint256 => uint256)
             Source: "m_ownerIndex"
          FunctionCall
             Type: uint256
             Source: "uint(_owner)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            Identifier _owner
               Type: address
               Source: "_owner"
      IfStatement
         Source: "if (ownerIndex == 0) return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "ownerIndex == 0"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      IfStatement
         Source: "if (m_required > m_numOwners - 1) return;"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 415
           Source: "m_required > m_numOwners - 1"
          Identifier m_required
             Type: uint256
             Source: "m_required"
          BinaryOperation using operator -
             Type: uint256
             Source: "m_numOwners - 1"
            Identifier m_numOwners
               Type: uint256
               Source: "m_numOwners"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 20049
         Source: "m_owners[ownerIndex] = 0"
        Assignment using operator =
           Type: uint256
           Source: "m_owners[ownerIndex] = 0"
          IndexAccess
             Type: uint256
             Source: "m_owners[ownerIndex]"
            Identifier m_owners
               Type: uint256[256] storage ref
               Source: "m_owners"
            Identifier ownerIndex
               Type: uint256
               Source: "ownerIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 5104
         Source: "m_ownerIndex[uint(_owner)] = 0"
        Assignment using operator =
           Type: uint256
           Source: "m_ownerIndex[uint(_owner)] = 0"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[uint(_owner)]"
            Identifier m_ownerIndex
               Type: mapping(uint256 => uint256)
               Source: "m_ownerIndex"
            FunctionCall
               Type: uint256
               Source: "uint(_owner)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              Identifier _owner
                 Type: address
                 Source: "_owner"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 4
         Source: "clearPending()"
        FunctionCall
           Type: tuple()
           Source: "clearPending()"
          Identifier clearPending
             Type: function ()
             Source: "clearPending"
      ExpressionStatement
         Gas costs: 4
         Source: "reorganizeOwners()"
        FunctionCall
           Type: tuple()
           Source: "reorganizeOwners()"
          Identifier reorganizeOwners
             Type: function ()
             Source: "reorganizeOwners"
      ExpressionStatement
         Gas costs: [???]
         Source: "OwnerRemoved(_owner,keccak256(msg.data))"
        FunctionCall
           Type: tuple()
           Source: "OwnerRemoved(_owner,keccak256(msg.data))"
          Identifier OwnerRemoved
             Type: function (address,bytes32)
             Source: "OwnerRemoved"
          Identifier _owner
             Type: address
             Source: "_owner"
          FunctionCall
             Type: bytes32
             Source: "keccak256(msg.data)"
            Identifier keccak256
               Type: function () pure returns (bytes32)
               Source: "keccak256"
            MemberAccess to member data
               Type: bytes calldata
               Source: "msg.data"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "changeRequirement" - public
     Source: "function changeRequirement(uint _newRequired) onlyManyOwners(keccak256(msg.data)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired,keccak256(msg.data));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _newRequired)"
      VariableDeclaration "_newRequired"
         Type: uint256
         Source: "uint _newRequired"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyManyOwners"
       Gas costs: [???]
       Source: "onlyManyOwners(keccak256(msg.data))"
      Identifier onlyManyOwners
         Type: modifier (bytes32)
         Source: "onlyManyOwners"
      FunctionCall
         Type: bytes32
         Source: "keccak256(msg.data)"
        Identifier keccak256
           Type: function () pure returns (bytes32)
           Source: "keccak256"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired,keccak256(msg.data));\r\n    }"
      IfStatement
         Source: "if (_newRequired > m_numOwners) return;"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "_newRequired > m_numOwners"
          Identifier _newRequired
             Type: uint256
             Source: "_newRequired"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 20014
         Source: "m_required = _newRequired"
        Assignment using operator =
           Type: uint256
           Source: "m_required = _newRequired"
          Identifier m_required
             Type: uint256
             Source: "m_required"
          Identifier _newRequired
             Type: uint256
             Source: "_newRequired"
      ExpressionStatement
         Gas costs: 15
         Source: "clearPending()"
        FunctionCall
           Type: tuple()
           Source: "clearPending()"
          Identifier clearPending
             Type: function ()
             Source: "clearPending"
      ExpressionStatement
         Gas costs: [???]
         Source: "RequirementChanged(_newRequired,keccak256(msg.data))"
        FunctionCall
           Type: tuple()
           Source: "RequirementChanged(_newRequired,keccak256(msg.data))"
          Identifier RequirementChanged
             Type: function (uint256,bytes32)
             Source: "RequirementChanged"
          Identifier _newRequired
             Type: uint256
             Source: "_newRequired"
          FunctionCall
             Type: bytes32
             Source: "keccak256(msg.data)"
            Identifier keccak256
               Type: function () pure returns (bytes32)
               Source: "keccak256"
            MemberAccess to member data
               Type: bytes calldata
               Source: "msg.data"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "isOwner" - public - const
     Source: "function isOwner(address _addr) view public returns (bool){\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _addr)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }"
      Return
         Gas costs: 304
         Source: "return m_ownerIndex[uint(_addr)] > 0"
        BinaryOperation using operator >
           Type: bool
           Source: "m_ownerIndex[uint(_addr)] > 0"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[uint(_addr)]"
            Identifier m_ownerIndex
               Type: mapping(uint256 => uint256)
               Source: "m_ownerIndex"
            FunctionCall
               Type: uint256
               Source: "uint(_addr)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              Identifier _addr
                 Type: address
                 Source: "_addr"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "hasConfirmed" - public - const
     Source: "function hasConfirmed(bytes32 _operation, address _owner) view public returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        return !(pending.ownersDone & ownerIndexBit == 0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation, address _owner)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        return !(pending.ownersDone & ownerIndexBit == 0);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 113
         Source: "var pending = m_pending[_operation]"
        VariableDeclaration "pending"
           Type: struct Multiowned.PendingState storage pointer
           Source: "var pending"
        IndexAccess
           Type: struct Multiowned.PendingState storage ref
           Source: "m_pending[_operation]"
          Identifier m_pending
             Type: mapping(bytes32 => struct Multiowned.PendingState storage ref)
             Source: "m_pending"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
      VariableDeclarationStatement
         Gas costs: 295
         Source: "uint ownerIndex = m_ownerIndex[uint(_owner)]"
        VariableDeclaration "ownerIndex"
           Type: uint256
           Source: "uint ownerIndex"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "m_ownerIndex[uint(_owner)]"
          Identifier m_ownerIndex
             Type: mapping(uint256 => uint256)
             Source: "m_ownerIndex"
          FunctionCall
             Type: uint256
             Source: "uint(_owner)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            Identifier _owner
               Type: address
               Source: "_owner"
      IfStatement
         Source: "if (ownerIndex == 0) return false"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "ownerIndex == 0"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      VariableDeclarationStatement
         Gas costs: 1624
         Source: "uint ownerIndexBit = 2**ownerIndex"
        VariableDeclaration "ownerIndexBit"
           Type: uint256
           Source: "uint ownerIndexBit"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator **
           Type: uint256
           Source: "2**ownerIndex"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
      Return
         Gas costs: 229
         Source: "return !(pending.ownersDone & ownerIndexBit == 0)"
        UnaryOperation (prefix) !
           Type: bool
           Source: "!(pending.ownersDone & ownerIndexBit == 0)"
          TupleExpression
             Type: bool
             Source: "(pending.ownersDone & ownerIndexBit == 0)"
            BinaryOperation using operator ==
               Type: bool
               Source: "pending.ownersDone & ownerIndexBit == 0"
              BinaryOperation using operator &
                 Type: uint256
                 Source: "pending.ownersDone & ownerIndexBit"
                MemberAccess to member ownersDone
                   Type: uint256
                   Source: "pending.ownersDone"
                  Identifier pending
                     Type: struct Multiowned.PendingState storage pointer
                     Source: "pending"
                Identifier ownerIndexBit
                   Type: uint256
                   Source: "ownerIndexBit"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
  FunctionDefinition "confirmAndCheck"
     Source: "function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 300
         Source: "uint ownerIndex = m_ownerIndex[uint(msg.sender)]"
        VariableDeclaration "ownerIndex"
           Type: uint256
           Source: "uint ownerIndex"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "m_ownerIndex[uint(msg.sender)]"
          Identifier m_ownerIndex
             Type: mapping(uint256 => uint256)
             Source: "m_ownerIndex"
          FunctionCall
             Type: uint256
             Source: "uint(msg.sender)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      IfStatement
         Source: "if (ownerIndex == 0) return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "ownerIndex == 0"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      VariableDeclarationStatement
         Gas costs: 113
         Source: "var pending = m_pending[_operation]"
        VariableDeclaration "pending"
           Type: struct Multiowned.PendingState storage pointer
           Source: "var pending"
        IndexAccess
           Type: struct Multiowned.PendingState storage ref
           Source: "m_pending[_operation]"
          Identifier m_pending
             Type: mapping(bytes32 => struct Multiowned.PendingState storage ref)
             Source: "m_pending"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
      IfStatement
         Source: "if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 215
           Source: "pending.yetNeeded == 0"
          MemberAccess to member yetNeeded
             Type: uint256
             Source: "pending.yetNeeded"
            Identifier pending
               Type: struct Multiowned.PendingState storage pointer
               Source: "pending"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }"
          ExpressionStatement
             Gas costs: 20220
             Source: "pending.yetNeeded = m_required"
            Assignment using operator =
               Type: uint256
               Source: "pending.yetNeeded = m_required"
              MemberAccess to member yetNeeded
                 Type: uint256
                 Source: "pending.yetNeeded"
                Identifier pending
                   Type: struct Multiowned.PendingState storage pointer
                   Source: "pending"
              Identifier m_required
                 Type: uint256
                 Source: "m_required"
          ExpressionStatement
             Gas costs: 5020
             Source: "pending.ownersDone = 0"
            Assignment using operator =
               Type: uint256
               Source: "pending.ownersDone = 0"
              MemberAccess to member ownersDone
                 Type: uint256
                 Source: "pending.ownersDone"
                Identifier pending
                   Type: struct Multiowned.PendingState storage pointer
                   Source: "pending"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          ExpressionStatement
             Gas costs: 20248
             Source: "pending.index = m_pendingIndex.length++"
            Assignment using operator =
               Type: uint256
               Source: "pending.index = m_pendingIndex.length++"
              MemberAccess to member index
                 Type: uint256
                 Source: "pending.index"
                Identifier pending
                   Type: struct Multiowned.PendingState storage pointer
                   Source: "pending"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "m_pendingIndex.length++"
                MemberAccess to member length
                   Type: uint256
                   Source: "m_pendingIndex.length"
                  Identifier m_pendingIndex
                     Type: bytes32[] storage ref
                     Source: "m_pendingIndex"
          ExpressionStatement
             Gas costs: 20518
             Source: "m_pendingIndex[pending.index] = _operation"
            Assignment using operator =
               Type: bytes32
               Source: "m_pendingIndex[pending.index] = _operation"
              IndexAccess
                 Type: bytes32
                 Source: "m_pendingIndex[pending.index]"
                Identifier m_pendingIndex
                   Type: bytes32[] storage ref
                   Source: "m_pendingIndex"
                MemberAccess to member index
                   Type: uint256
                   Source: "pending.index"
                  Identifier pending
                     Type: struct Multiowned.PendingState storage pointer
                     Source: "pending"
              Identifier _operation
                 Type: bytes32
                 Source: "_operation"
      VariableDeclarationStatement
         Gas costs: 1624
         Source: "uint ownerIndexBit = 2**ownerIndex"
        VariableDeclaration "ownerIndexBit"
           Type: uint256
           Source: "uint ownerIndexBit"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator **
           Type: uint256
           Source: "2**ownerIndex"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
      IfStatement
         Source: "if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 221
           Source: "pending.ownersDone & ownerIndexBit == 0"
          BinaryOperation using operator &
             Type: uint256
             Source: "pending.ownersDone & ownerIndexBit"
            MemberAccess to member ownersDone
               Type: uint256
               Source: "pending.ownersDone"
              Identifier pending
                 Type: struct Multiowned.PendingState storage pointer
                 Source: "pending"
            Identifier ownerIndexBit
               Type: uint256
               Source: "ownerIndexBit"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "Confirmation(msg.sender, _operation)"
            FunctionCall
               Type: tuple()
               Source: "Confirmation(msg.sender, _operation)"
              Identifier Confirmation
                 Type: function (address,bytes32)
                 Source: "Confirmation"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _operation
                 Type: bytes32
                 Source: "_operation"
          IfStatement
             Source: "if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }"
            BinaryOperation using operator <=
               Type: bool
               Gas costs: 218
               Source: "pending.yetNeeded <= 1"
              MemberAccess to member yetNeeded
                 Type: uint256
                 Source: "pending.yetNeeded"
                Identifier pending
                   Type: struct Multiowned.PendingState storage pointer
                   Source: "pending"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            Block
               Source: "{\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }"
              ExpressionStatement
                 Gas costs: 5606
                 Source: "delete m_pendingIndex[m_pending[_operation].index]"
                UnaryOperation (prefix) delete
                   Type: tuple()
                   Source: "delete m_pendingIndex[m_pending[_operation].index]"
                  IndexAccess
                     Type: bytes32
                     Source: "m_pendingIndex[m_pending[_operation].index]"
                    Identifier m_pendingIndex
                       Type: bytes32[] storage ref
                       Source: "m_pendingIndex"
                    MemberAccess to member index
                       Type: uint256
                       Source: "m_pending[_operation].index"
                      IndexAccess
                         Type: struct Multiowned.PendingState storage ref
                         Source: "m_pending[_operation]"
                        Identifier m_pending
                           Type: mapping(bytes32 => struct Multiowned.PendingState storage ref)
                           Source: "m_pending"
                        Identifier _operation
                           Type: bytes32
                           Source: "_operation"
              ExpressionStatement
                 Gas costs: 15154
                 Source: "delete m_pending[_operation]"
                UnaryOperation (prefix) delete
                   Type: tuple()
                   Source: "delete m_pending[_operation]"
                  IndexAccess
                     Type: struct Multiowned.PendingState storage ref
                     Source: "m_pending[_operation]"
                    Identifier m_pending
                       Type: mapping(bytes32 => struct Multiowned.PendingState storage ref)
                       Source: "m_pending"
                    Identifier _operation
                       Type: bytes32
                       Source: "_operation"
              Return
                 Gas costs: 19
                 Source: "return true"
                Literal, token: true value: true
                   Type: bool
                   Source: "true"
            Block
               Source: "{\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }"
              ExpressionStatement
                 Gas costs: 20246
                 Source: "pending.yetNeeded--"
                UnaryOperation (postfix) --
                   Type: uint256
                   Source: "pending.yetNeeded--"
                  MemberAccess to member yetNeeded
                     Type: uint256
                     Source: "pending.yetNeeded"
                    Identifier pending
                       Type: struct Multiowned.PendingState storage pointer
                       Source: "pending"
              ExpressionStatement
                 Gas costs: 20239
                 Source: "pending.ownersDone |= ownerIndexBit"
                Assignment using operator |=
                   Type: uint256
                   Source: "pending.ownersDone |= ownerIndexBit"
                  MemberAccess to member ownersDone
                     Type: uint256
                     Source: "pending.ownersDone"
                    Identifier pending
                       Type: struct Multiowned.PendingState storage pointer
                       Source: "pending"
                  Identifier ownerIndexBit
                     Type: uint256
                     Source: "ownerIndexBit"
  FunctionDefinition "reorganizeOwners"
     Source: "function reorganizeOwners() private {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint free = 1"
        VariableDeclaration "free"
           Type: uint256
           Source: "uint free"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 1
           Type: int_const 1
           Source: "1"
      WhileStatement
         Source: "while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 209
           Source: "free < m_numOwners"
          Identifier free
             Type: uint256
             Source: "free"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
        Block
           Source: "{\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }"
          WhileStatement
             Source: "while (free < m_numOwners && m_owners[free] != 0) free++"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 478
               Source: "free < m_numOwners && m_owners[free] != 0"
              BinaryOperation using operator <
                 Type: bool
                 Source: "free < m_numOwners"
                Identifier free
                   Type: uint256
                   Source: "free"
                Identifier m_numOwners
                   Type: uint256
                   Source: "m_numOwners"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "m_owners[free] != 0"
                IndexAccess
                   Type: uint256
                   Source: "m_owners[free]"
                  Identifier m_owners
                     Type: uint256[256] storage ref
                     Source: "m_owners"
                  Identifier free
                     Type: uint256
                     Source: "free"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            ExpressionStatement
               Gas costs: 19
               Source: "free++"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "free++"
                Identifier free
                   Type: uint256
                   Source: "free"
          WhileStatement
             Source: "while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 675
               Source: "m_numOwners > 1 && m_owners[m_numOwners] == 0"
              BinaryOperation using operator >
                 Type: bool
                 Source: "m_numOwners > 1"
                Identifier m_numOwners
                   Type: uint256
                   Source: "m_numOwners"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "m_owners[m_numOwners] == 0"
                IndexAccess
                   Type: uint256
                   Source: "m_owners[m_numOwners]"
                  Identifier m_owners
                     Type: uint256[256] storage ref
                     Source: "m_owners"
                  Identifier m_numOwners
                     Type: uint256
                     Source: "m_numOwners"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            ExpressionStatement
               Gas costs: 20240
               Source: "m_numOwners--"
              UnaryOperation (postfix) --
                 Type: uint256
                 Source: "m_numOwners--"
                Identifier m_numOwners
                   Type: uint256
                   Source: "m_numOwners"
          IfStatement
             Source: "if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 944
               Source: "free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0"
              BinaryOperation using operator &&
                 Type: bool
                 Source: "free < m_numOwners && m_owners[m_numOwners] != 0"
                BinaryOperation using operator <
                   Type: bool
                   Source: "free < m_numOwners"
                  Identifier free
                     Type: uint256
                     Source: "free"
                  Identifier m_numOwners
                     Type: uint256
                     Source: "m_numOwners"
                BinaryOperation using operator !=
                   Type: bool
                   Source: "m_owners[m_numOwners] != 0"
                  IndexAccess
                     Type: uint256
                     Source: "m_owners[m_numOwners]"
                    Identifier m_owners
                       Type: uint256[256] storage ref
                       Source: "m_owners"
                    Identifier m_numOwners
                       Type: uint256
                       Source: "m_numOwners"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "m_owners[free] == 0"
                IndexAccess
                   Type: uint256
                   Source: "m_owners[free]"
                  Identifier m_owners
                     Type: uint256[256] storage ref
                     Source: "m_owners"
                  Identifier free
                     Type: uint256
                     Source: "free"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            Block
               Source: "{\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }"
              ExpressionStatement
                 Gas costs: 20484
                 Source: "m_owners[free] = m_owners[m_numOwners]"
                Assignment using operator =
                   Type: uint256
                   Source: "m_owners[free] = m_owners[m_numOwners]"
                  IndexAccess
                     Type: uint256
                     Source: "m_owners[free]"
                    Identifier m_owners
                       Type: uint256[256] storage ref
                       Source: "m_owners"
                    Identifier free
                       Type: uint256
                       Source: "free"
                  IndexAccess
                     Type: uint256
                     Source: "m_owners[m_numOwners]"
                    Identifier m_owners
                       Type: uint256[256] storage ref
                       Source: "m_owners"
                    Identifier m_numOwners
                       Type: uint256
                       Source: "m_numOwners"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "m_ownerIndex[m_owners[free]] = free"
                Assignment using operator =
                   Type: uint256
                   Source: "m_ownerIndex[m_owners[free]] = free"
                  IndexAccess
                     Type: uint256
                     Source: "m_ownerIndex[m_owners[free]]"
                    Identifier m_ownerIndex
                       Type: mapping(uint256 => uint256)
                       Source: "m_ownerIndex"
                    IndexAccess
                       Type: uint256
                       Source: "m_owners[free]"
                      Identifier m_owners
                         Type: uint256[256] storage ref
                         Source: "m_owners"
                      Identifier free
                         Type: uint256
                         Source: "free"
                  Identifier free
                     Type: uint256
                     Source: "free"
              ExpressionStatement
                 Gas costs: 20249
                 Source: "m_owners[m_numOwners] = 0"
                Assignment using operator =
                   Type: uint256
                   Source: "m_owners[m_numOwners] = 0"
                  IndexAccess
                     Type: uint256
                     Source: "m_owners[m_numOwners]"
                    Identifier m_owners
                       Type: uint256[256] storage ref
                       Source: "m_owners"
                    Identifier m_numOwners
                       Type: uint256
                       Source: "m_numOwners"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
  FunctionDefinition "clearPending"
     Source: "function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 219
         Source: "uint length = m_pendingIndex.length"
        VariableDeclaration "length"
           Type: uint256
           Source: "uint length"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "m_pendingIndex.length"
          Identifier m_pendingIndex
             Type: bytes32[] storage ref
             Source: "m_pendingIndex"
      ForStatement
         Source: "for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]]"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < length"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier length
             Type: uint256
             Source: "length"
        ExpressionStatement
           Gas costs: 14
           Source: "++i"
          UnaryOperation (prefix) ++
             Type: uint256
             Source: "++i"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]]"
          BinaryOperation using operator !=
             Type: bool
             Gas costs: 518
             Source: "m_pendingIndex[i] != 0"
            IndexAccess
               Type: bytes32
               Source: "m_pendingIndex[i]"
              Identifier m_pendingIndex
                 Type: bytes32[] storage ref
                 Source: "m_pendingIndex"
              Identifier i
                 Type: uint256
                 Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          ExpressionStatement
             Gas costs: [???]
             Source: "delete m_pending[m_pendingIndex[i]]"
            UnaryOperation (prefix) delete
               Type: tuple()
               Source: "delete m_pending[m_pendingIndex[i]]"
              IndexAccess
                 Type: struct Multiowned.PendingState storage ref
                 Source: "m_pending[m_pendingIndex[i]]"
                Identifier m_pending
                   Type: mapping(bytes32 => struct Multiowned.PendingState storage ref)
                   Source: "m_pending"
                IndexAccess
                   Type: bytes32
                   Source: "m_pendingIndex[i]"
                  Identifier m_pendingIndex
                     Type: bytes32[] storage ref
                     Source: "m_pendingIndex"
                  Identifier i
                     Type: uint256
                     Source: "i"
      ExpressionStatement
         Gas costs: 16
         Source: "delete m_pendingIndex"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete m_pendingIndex"
          Identifier m_pendingIndex
             Type: bytes32[] storage ref
             Source: "m_pendingIndex"
  VariableDeclaration "m_required"
     Type: uint256
     Gas costs: [???]
     Source: "uint public m_required"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "m_numOwners"
     Type: uint256
     Gas costs: [???]
     Source: "uint public m_numOwners"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "m_owners"
     Type: uint256[256] storage ref
     Gas costs: 0
     Source: "uint[256] m_owners"
    ArrayTypeName
       Source: "uint[256]"
      ElementaryTypeName uint
         Source: "uint"
      Literal, token: [no token] value: 256
         Type unknown.
         Source: "256"
  VariableDeclaration "c_maxOwners"
     Type: uint256
     Gas costs: 6
     Source: "uint constant c_maxOwners = 250"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 250
       Type: int_const 250
       Source: "250"
  VariableDeclaration "m_ownerIndex"
     Type: mapping(uint256 => uint256)
     Gas costs: 0
     Source: "mapping(uint => uint) m_ownerIndex"
    Mapping
       Source: "mapping(uint => uint)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "m_pending"
     Type: mapping(bytes32 => struct Multiowned.PendingState storage ref)
     Gas costs: 0
     Source: "mapping(bytes32 => PendingState) m_pending"
    Mapping
       Source: "mapping(bytes32 => PendingState)"
      ElementaryTypeName bytes32
         Source: "bytes32"
      UserDefinedTypeName "PendingState"
         Source: "PendingState"
  VariableDeclaration "m_pendingIndex"
     Type: bytes32[] storage ref
     Gas costs: 0
     Source: "bytes32[] m_pendingIndex"
    ArrayTypeName
       Source: "bytes32[]"
      ElementaryTypeName bytes32
         Source: "bytes32"
ContractDefinition "Token"
   Gas costs: [???]
   Source: "contract Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public view returns (uint256 balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public view returns (uint256 remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is Token {\r\n\r\n    uint256 constant MAX_UINT256 = 2**256 - 1;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) view public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender)\r\n    view public returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Token"
    UserDefinedTypeName "Token"
       Source: "Token"
  VariableDeclaration "MAX_UINT256"
     Type: uint256
     Gas costs: 3
     Source: "uint256 constant MAX_UINT256 = 2**256 - 1"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator -
       Type: int_const 1157...(70 digits omitted)...9935
       Source: "2**256 - 1"
      BinaryOperation using operator **
         Type: int_const 1157...(70 digits omitted)...9936
         Source: "2**256"
        Literal, token: [no token] value: 2
           Type: int_const 2
           Source: "2"
        Literal, token: [no token] value: 256
           Type: int_const 256
           Source: "256"
      Literal, token: [no token] value: 1
         Type: int_const 1
         Source: "1"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 333
         Source: "require(balances[msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20328
         Source: "balances[msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 396
         Source: "uint256 allowance = allowed[_from][msg.sender]"
        VariableDeclaration "allowance"
           Type: uint256
           Source: "uint256 allowance"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "allowed[_from][msg.sender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_from]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _from
               Type: address
               Source: "_from"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 362
         Source: "require(balances[_from] >= _value && allowance >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_from] >= _value && allowance >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "balances[_from] >= _value && allowance >= _value"
            BinaryOperation using operator >=
               Type: bool
               Source: "balances[_from] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            BinaryOperation using operator >=
               Type: bool
               Source: "allowance >= _value"
              Identifier allowance
                 Type: uint256
                 Source: "allowance"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balances[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      IfStatement
         Source: "if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 6
           Source: "allowance < MAX_UINT256"
          Identifier allowance
             Type: uint256
             Source: "allowance"
          Identifier MAX_UINT256
             Type: uint256
             Source: "MAX_UINT256"
        Block
           Source: "{\r\n            allowed[_from][msg.sender] -= _value;\r\n        }"
          ExpressionStatement
             Gas costs: 20418
             Source: "allowed[_from][msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "allowed[_from][msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) view public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balances[_owner];\r\n    }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender)\r\n    view public returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balances"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "UGCoin"
   Source: "contract UGCoin is Multiowned, StandardToken {\r\n\r\n    event Freeze(address from, uint value);\r\n    event Defreeze(address ownerAddr, address userAddr, uint256 amount);\r\n    event ReturnToOwner(address ownerAddr, uint amount);\r\n    event Destroy(address from, uint value);\r\n\r\n    function UGCoin() public Multiowned(){\r\n        balances[msg.sender] = initialAmount;   // Give the creator all initial balances is defined in StandardToken.sol\r\n        totalSupply = initialAmount;              // Update total supply, totalSupply is defined in Tocken.sol\r\n    }\r\n\r\n    function() public {\r\n\r\n    }\r\n    \r\n    /* transfer UGC to DAS */\r\n    function freeze(uint256 _amount) external returns (bool success){\r\n        require(balances[msg.sender] >= _amount);\r\n        coinPool += _amount;\r\n        balances[msg.sender] -= _amount;\r\n        Freeze(msg.sender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /* transfer UGC from DAS */\r\n    function defreeze(address _userAddr, uint256 _amount) onlyOwner external returns (bool success){\r\n        require(balances[msg.sender] >= _amount); //msg.sender is a owner\r\n        require(coinPool >= _amount);\r\n        balances[_userAddr] += _amount;\r\n        balances[msg.sender] -= _amount;\r\n        ownersLoan[msg.sender] += _amount;\r\n        Defreeze(msg.sender, _userAddr, _amount);\r\n        return true;\r\n    }\r\n\r\n    function returnToOwner(address _ownerAddr, uint256 _amount) onlyManyOwners(keccak256(msg.data)) external returns (bool success){\r\n        require(coinPool >= _amount);\r\n        require(isOwner(_ownerAddr));\r\n        require(ownersLoan[_ownerAddr] >= _amount);\r\n        balances[_ownerAddr] += _amount;\r\n        coinPool -= _amount;\r\n        ownersLoan[_ownerAddr] -= _amount;\r\n        ReturnToOwner(_ownerAddr, _amount);\r\n        return true;\r\n    }\r\n    \r\n    function destroy(uint256 _amount) external returns (bool success){\r\n        require(balances[msg.sender] >= _amount);\r\n        balances[msg.sender] -= _amount;\r\n        totalSupply -= _amount;\r\n        Destroy(msg.sender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function getOwnersLoan(address _ownerAddr) view public returns (uint256){\r\n        return ownersLoan[_ownerAddr];\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. \r\n        //This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed when one does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n        return true;\r\n    }\r\n\r\n    string public name = \"UG Coin\";\r\n    uint8 public decimals = 18;\r\n    string public symbol = \"UGC\";\r\n    string public version = \"v0.1\";\r\n    uint256 public initialAmount = (10 ** 9) * (10 ** 18);\r\n    uint256 public coinPool = 0;      // coinPool is a pool for freezing UGC\r\n    mapping (address => uint256) ownersLoan;      // record the amount of UGC paid by oweners for freezing UGC\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Multiowned"
    UserDefinedTypeName "Multiowned"
       Source: "Multiowned"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  EventDefinition "Freeze"
     Gas costs: 0
     Source: "event Freeze(address from, uint value);"
    ParameterList
       Source: "(address from, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Defreeze"
     Gas costs: 0
     Source: "event Defreeze(address ownerAddr, address userAddr, uint256 amount);"
    ParameterList
       Source: "(address ownerAddr, address userAddr, uint256 amount)"
      VariableDeclaration "ownerAddr"
         Type: address
         Source: "address ownerAddr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "userAddr"
         Type: address
         Source: "address userAddr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "ReturnToOwner"
     Gas costs: 0
     Source: "event ReturnToOwner(address ownerAddr, uint amount);"
    ParameterList
       Source: "(address ownerAddr, uint amount)"
      VariableDeclaration "ownerAddr"
         Type: address
         Source: "address ownerAddr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Destroy"
     Gas costs: 0
     Source: "event Destroy(address from, uint value);"
    ParameterList
       Source: "(address from, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "UGCoin" - public
     Source: "function UGCoin() public Multiowned(){\r\n        balances[msg.sender] = initialAmount;   // Give the creator all initial balances is defined in StandardToken.sol\r\n        totalSupply = initialAmount;              // Update total supply, totalSupply is defined in Tocken.sol\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "Multiowned"
       Gas costs: 0
       Source: "Multiowned()"
      Identifier Multiowned
         Type: type(contract Multiowned)
         Source: "Multiowned"
    Block
       Source: "{\r\n        balances[msg.sender] = initialAmount;   // Give the creator all initial balances is defined in StandardToken.sol\r\n        totalSupply = initialAmount;              // Update total supply, totalSupply is defined in Tocken.sol\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] = initialAmount"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = initialAmount"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier initialAmount
             Type: uint256
             Source: "initialAmount"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = initialAmount"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = initialAmount"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier initialAmount
             Type: uint256
             Source: "initialAmount"
  FunctionDefinition "" - public
     Source: "function() public {\r\n\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Gas costs: 0
       Source: "{\r\n\r\n    }"
  FunctionDefinition "freeze" - public
     Source: "function freeze(uint256 _amount) external returns (bool success){\r\n        require(balances[msg.sender] >= _amount);\r\n        coinPool += _amount;\r\n        balances[msg.sender] -= _amount;\r\n        Freeze(msg.sender, _amount);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _amount)"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require(balances[msg.sender] >= _amount);\r\n        coinPool += _amount;\r\n        balances[msg.sender] -= _amount;\r\n        Freeze(msg.sender, _amount);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 333
         Source: "require(balances[msg.sender] >= _amount)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] >= _amount)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _amount"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 20233
         Source: "coinPool += _amount"
        Assignment using operator +=
           Type: uint256
           Source: "coinPool += _amount"
          Identifier coinPool
             Type: uint256
             Source: "coinPool"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: 20328
         Source: "balances[msg.sender] -= _amount"
        Assignment using operator -=
           Type: uint256
           Source: "balances[msg.sender] -= _amount"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Freeze(msg.sender, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Freeze(msg.sender, _amount)"
          Identifier Freeze
             Type: function (address,uint256)
             Source: "Freeze"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "defreeze" - public
     Source: "function defreeze(address _userAddr, uint256 _amount) onlyOwner external returns (bool success){\r\n        require(balances[msg.sender] >= _amount); //msg.sender is a owner\r\n        require(coinPool >= _amount);\r\n        balances[_userAddr] += _amount;\r\n        balances[msg.sender] -= _amount;\r\n        ownersLoan[msg.sender] += _amount;\r\n        Defreeze(msg.sender, _userAddr, _amount);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _userAddr, uint256 _amount)"
      VariableDeclaration "_userAddr"
         Type: address
         Source: "address _userAddr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(balances[msg.sender] >= _amount); //msg.sender is a owner\r\n        require(coinPool >= _amount);\r\n        balances[_userAddr] += _amount;\r\n        balances[msg.sender] -= _amount;\r\n        ownersLoan[msg.sender] += _amount;\r\n        Defreeze(msg.sender, _userAddr, _amount);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 333
         Source: "require(balances[msg.sender] >= _amount)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] >= _amount)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _amount"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 238
         Source: "require(coinPool >= _amount)"
        FunctionCall
           Type: tuple()
           Source: "require(coinPool >= _amount)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "coinPool >= _amount"
            Identifier coinPool
               Type: uint256
               Source: "coinPool"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[_userAddr] += _amount"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_userAddr] += _amount"
          IndexAccess
             Type: uint256
             Source: "balances[_userAddr]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _userAddr
               Type: address
               Source: "_userAddr"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: 20322
         Source: "balances[msg.sender] -= _amount"
        Assignment using operator -=
           Type: uint256
           Source: "balances[msg.sender] -= _amount"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: 20322
         Source: "ownersLoan[msg.sender] += _amount"
        Assignment using operator +=
           Type: uint256
           Source: "ownersLoan[msg.sender] += _amount"
          IndexAccess
             Type: uint256
             Source: "ownersLoan[msg.sender]"
            Identifier ownersLoan
               Type: mapping(address => uint256)
               Source: "ownersLoan"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Defreeze(msg.sender, _userAddr, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Defreeze(msg.sender, _userAddr, _amount)"
          Identifier Defreeze
             Type: function (address,address,uint256)
             Source: "Defreeze"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _userAddr
             Type: address
             Source: "_userAddr"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "returnToOwner" - public
     Source: "function returnToOwner(address _ownerAddr, uint256 _amount) onlyManyOwners(keccak256(msg.data)) external returns (bool success){\r\n        require(coinPool >= _amount);\r\n        require(isOwner(_ownerAddr));\r\n        require(ownersLoan[_ownerAddr] >= _amount);\r\n        balances[_ownerAddr] += _amount;\r\n        coinPool -= _amount;\r\n        ownersLoan[_ownerAddr] -= _amount;\r\n        ReturnToOwner(_ownerAddr, _amount);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _ownerAddr, uint256 _amount)"
      VariableDeclaration "_ownerAddr"
         Type: address
         Source: "address _ownerAddr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyManyOwners"
       Gas costs: [???]
       Source: "onlyManyOwners(keccak256(msg.data))"
      Identifier onlyManyOwners
         Type: modifier (bytes32)
         Source: "onlyManyOwners"
      FunctionCall
         Type: bytes32
         Source: "keccak256(msg.data)"
        Identifier keccak256
           Type: function () pure returns (bytes32)
           Source: "keccak256"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        require(coinPool >= _amount);\r\n        require(isOwner(_ownerAddr));\r\n        require(ownersLoan[_ownerAddr] >= _amount);\r\n        balances[_ownerAddr] += _amount;\r\n        coinPool -= _amount;\r\n        ownersLoan[_ownerAddr] -= _amount;\r\n        ReturnToOwner(_ownerAddr, _amount);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 238
         Source: "require(coinPool >= _amount)"
        FunctionCall
           Type: tuple()
           Source: "require(coinPool >= _amount)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "coinPool >= _amount"
            Identifier coinPool
               Type: uint256
               Source: "coinPool"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 44
         Source: "require(isOwner(_ownerAddr))"
        FunctionCall
           Type: tuple()
           Source: "require(isOwner(_ownerAddr))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "isOwner(_ownerAddr)"
            Identifier isOwner
               Type: function (address) view returns (bool)
               Source: "isOwner"
            Identifier _ownerAddr
               Type: address
               Source: "_ownerAddr"
      ExpressionStatement
         Gas costs: 334
         Source: "require(ownersLoan[_ownerAddr] >= _amount)"
        FunctionCall
           Type: tuple()
           Source: "require(ownersLoan[_ownerAddr] >= _amount)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "ownersLoan[_ownerAddr] >= _amount"
            IndexAccess
               Type: uint256
               Source: "ownersLoan[_ownerAddr]"
              Identifier ownersLoan
                 Type: mapping(address => uint256)
                 Source: "ownersLoan"
              Identifier _ownerAddr
                 Type: address
                 Source: "_ownerAddr"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[_ownerAddr] += _amount"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_ownerAddr] += _amount"
          IndexAccess
             Type: uint256
             Source: "balances[_ownerAddr]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _ownerAddr
               Type: address
               Source: "_ownerAddr"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: 20233
         Source: "coinPool -= _amount"
        Assignment using operator -=
           Type: uint256
           Source: "coinPool -= _amount"
          Identifier coinPool
             Type: uint256
             Source: "coinPool"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: 20323
         Source: "ownersLoan[_ownerAddr] -= _amount"
        Assignment using operator -=
           Type: uint256
           Source: "ownersLoan[_ownerAddr] -= _amount"
          IndexAccess
             Type: uint256
             Source: "ownersLoan[_ownerAddr]"
            Identifier ownersLoan
               Type: mapping(address => uint256)
               Source: "ownersLoan"
            Identifier _ownerAddr
               Type: address
               Source: "_ownerAddr"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "ReturnToOwner(_ownerAddr, _amount)"
        FunctionCall
           Type: tuple()
           Source: "ReturnToOwner(_ownerAddr, _amount)"
          Identifier ReturnToOwner
             Type: function (address,uint256)
             Source: "ReturnToOwner"
          Identifier _ownerAddr
             Type: address
             Source: "_ownerAddr"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "destroy" - public
     Source: "function destroy(uint256 _amount) external returns (bool success){\r\n        require(balances[msg.sender] >= _amount);\r\n        balances[msg.sender] -= _amount;\r\n        totalSupply -= _amount;\r\n        Destroy(msg.sender, _amount);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _amount)"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require(balances[msg.sender] >= _amount);\r\n        balances[msg.sender] -= _amount;\r\n        totalSupply -= _amount;\r\n        Destroy(msg.sender, _amount);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 333
         Source: "require(balances[msg.sender] >= _amount)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] >= _amount)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _amount"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 20328
         Source: "balances[msg.sender] -= _amount"
        Assignment using operator -=
           Type: uint256
           Source: "balances[msg.sender] -= _amount"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply -= _amount"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= _amount"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Destroy(msg.sender, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Destroy(msg.sender, _amount)"
          Identifier Destroy
             Type: function (address,uint256)
             Source: "Destroy"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "getOwnersLoan" - public - const
     Source: "function getOwnersLoan(address _ownerAddr) view public returns (uint256){\r\n        return ownersLoan[_ownerAddr];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _ownerAddr)"
      VariableDeclaration "_ownerAddr"
         Type: address
         Source: "address _ownerAddr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return ownersLoan[_ownerAddr];\r\n    }"
      Return
         Gas costs: 304
         Source: "return ownersLoan[_ownerAddr]"
        IndexAccess
           Type: uint256
           Source: "ownersLoan[_ownerAddr]"
          Identifier ownersLoan
             Type: mapping(address => uint256)
             Source: "ownersLoan"
          Identifier _ownerAddr
             Type: address
             Source: "_ownerAddr"
  FunctionDefinition "approveAndCall" - public
     Source: "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. \r\n        //This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed when one does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value, bytes _extraData)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. \r\n        //This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed when one does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData))"
        FunctionCall
           Type: tuple()
           Source: "require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)"
            MemberAccess to member call
               Type: function () payable returns (bool)
               Source: "_spender.call"
              Identifier _spender
                 Type: address
                 Source: "_spender"
            FunctionCall
               Type: bytes4
               Source: "bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\")))"
              ElementaryTypeNameExpression bytes4
                 Type: type(bytes4)
                 Source: "bytes4"
              FunctionCall
                 Type: bytes32
                 Source: "bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))"
                ElementaryTypeNameExpression bytes32
                   Type: type(bytes32)
                   Source: "bytes32"
                FunctionCall
                   Type: bytes32
                   Source: "keccak256(\"receiveApproval(address,uint256,address,bytes)\")"
                  Identifier keccak256
                     Type: function () pure returns (bytes32)
                     Source: "keccak256"
                  Literal, token: [no token] value: receiveApproval(address,uint256,address,bytes)
                     Type: literal_string "receiveApproval(address,uint256,address,bytes)"
                     Source: "\"receiveApproval(address,uint256,address,bytes)\""
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
            Identifier this
               Type: contract UGCoin
               Source: "this"
            Identifier _extraData
               Type: bytes memory
               Source: "_extraData"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public name = \"UG Coin\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: UG Coin
       Type: literal_string "UG Coin"
       Source: "\"UG Coin\""
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: [???]
     Source: "uint8 public decimals = 18"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public symbol = \"UGC\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: UGC
       Type: literal_string "UGC"
       Source: "\"UGC\""
  VariableDeclaration "version"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public version = \"v0.1\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: v0.1
       Type: literal_string "v0.1"
       Source: "\"v0.1\""
  VariableDeclaration "initialAmount"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public initialAmount = (10 ** 9) * (10 ** 18)"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator *
       Type: int_const 1000000000000000000000000000
       Source: "(10 ** 9) * (10 ** 18)"
      TupleExpression
         Type: int_const 1000000000
         Source: "(10 ** 9)"
        BinaryOperation using operator **
           Type: int_const 1000000000
           Source: "10 ** 9"
          Literal, token: [no token] value: 10
             Type: int_const 10
             Source: "10"
          Literal, token: [no token] value: 9
             Type: int_const 9
             Source: "9"
      TupleExpression
         Type: int_const 1000000000000000000
         Source: "(10 ** 18)"
        BinaryOperation using operator **
           Type: int_const 1000000000000000000
           Source: "10 ** 18"
          Literal, token: [no token] value: 10
             Type: int_const 10
             Source: "10"
          Literal, token: [no token] value: 18
             Type: int_const 18
             Source: "18"
  VariableDeclaration "coinPool"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public coinPool = 0"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "ownersLoan"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) ownersLoan"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
