Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x360e51857242661de8f3ec4e6c684b45b3c0de87.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.18;"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "sub"
     Source: "function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    require(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 38
         Source: "require(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "require(b <= a)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add"
     Source: "function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 38
         Source: "require(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "require(c >= a)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "SafeMath64"
   Source: "library SafeMath64 {\r\n  function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    uint64 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "sub"
     Source: "function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint64 a, uint64 b)"
      VariableDeclaration "a"
         Type: uint64
         Source: "uint64 a"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "b"
         Type: uint64
         Source: "uint64 b"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 3
       Source: "(uint64)"
      VariableDeclaration ""
         Type: uint64
         Source: "uint64"
        ElementaryTypeName uint64
           Source: "uint64"
    Block
       Source: "{\r\n    require(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "require(b <= a)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint64
               Source: "b"
            Identifier a
               Type: uint64
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint64
           Source: "a - b"
          Identifier a
             Type: uint64
             Source: "a"
          Identifier b
             Type: uint64
             Source: "b"
  FunctionDefinition "add"
     Source: "function add(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    uint64 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint64 a, uint64 b)"
      VariableDeclaration "a"
         Type: uint64
         Source: "uint64 a"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "b"
         Type: uint64
         Source: "uint64 b"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 3
       Source: "(uint64)"
      VariableDeclaration ""
         Type: uint64
         Source: "uint64"
        ElementaryTypeName uint64
           Source: "uint64"
    Block
       Source: "{\r\n    uint64 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint64 c = a + b"
        VariableDeclaration "c"
           Type: uint64
           Source: "uint64 c"
          ElementaryTypeName uint64
             Source: "uint64"
        BinaryOperation using operator +
           Type: uint64
           Source: "a + b"
          Identifier a
             Type: uint64
             Source: "a"
          Identifier b
             Type: uint64
             Source: "b"
      ExpressionStatement
         Gas costs: 50
         Source: "require(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "require(c >= a)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint64
               Source: "c"
            Identifier a
               Type: uint64
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint64
           Source: "c"
ContractDefinition "Ownable"
   Source: "contract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  EventDefinition "OwnershipTransferred"
     Gas costs: 0
     Source: "event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);"
    ParameterList
       Source: "(address indexed previousOwner, address indexed newOwner)"
      VariableDeclaration "previousOwner"
         Type: address
         Source: "address indexed previousOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address indexed newOwner"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "Ownable" - public
     Source: "function Ownable() public {\r\n    owner = msg.sender;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    owner = msg.sender;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 846
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(newOwner != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(newOwner != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "newOwner != address(0)"
            Identifier newOwner
               Type: address
               Source: "newOwner"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 1790
         Source: "OwnershipTransferred(owner, newOwner)"
        FunctionCall
           Type: tuple()
           Source: "OwnershipTransferred(owner, newOwner)"
          Identifier OwnershipTransferred
             Type: function (address,address)
             Source: "OwnershipTransferred"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
ContractDefinition "ERC20Basic"
   Gas costs: [???]
   Source: "contract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) public view returns (uint256);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address to, uint256 value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "ERC20"
   Gas costs: 0
   Source: "contract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
  InheritanceSpecifier
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) public view returns (uint256);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address from, address to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address spender, uint256 value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint256 value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint256 value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "DetailedERC20"
   Source: "contract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public name"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public symbol"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: [???]
     Source: "uint8 public decimals"
    ElementaryTypeName uint8
       Source: "uint8"
  FunctionDefinition "DetailedERC20" - public
     Source: "function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(string _name, string _symbol, uint8 _decimals)"
      VariableDeclaration "_name"
         Type: string memory
         Source: "string _name"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_symbol"
         Type: string memory
         Source: "string _symbol"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_decimals"
         Type: uint8
         Source: "uint8 _decimals"
        ElementaryTypeName uint8
           Source: "uint8"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "name = _name"
        Assignment using operator =
           Type: string storage ref
           Source: "name = _name"
          Identifier name
             Type: string storage ref
             Source: "name"
          Identifier _name
             Type: string memory
             Source: "_name"
      ExpressionStatement
         Gas costs: 0
         Source: "symbol = _symbol"
        Assignment using operator =
           Type: string storage ref
           Source: "symbol = _symbol"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
          Identifier _symbol
             Type: string memory
             Source: "_symbol"
      ExpressionStatement
         Gas costs: 0
         Source: "decimals = _decimals"
        Assignment using operator =
           Type: uint8
           Source: "decimals = _decimals"
          Identifier decimals
             Type: uint8
             Source: "decimals"
          Identifier _decimals
             Type: uint8
             Source: "_decimals"
ContractDefinition "Karma"
   Source: "contract Karma is Ownable, DetailedERC20(\"KarmaToken\", \"KARMA\", 0) {\r\n  // SafeMath libs are responsible for checking overflow.\r\n  using SafeMath for uint256;\r\n  using SafeMath64 for uint64;\r\n\r\n  // TODO ensure this all fits in a single 256 bit block.\r\n  struct User {\r\n    bytes20 username;\r\n    uint64 karma; \r\n    uint16 canWithdrawPeriod;\r\n    uint16 birthPeriod;\r\n  }\r\n\r\n  // Manage users.\r\n  mapping(address => User) public users;\r\n  mapping(bytes20 => address) public usernames;\r\n\r\n  // Manage dividend payments.\r\n  uint256 public epoch;\r\n  uint256 public dividend;\r\n  uint64 public numUsers;\r\n  uint64 public newUsers;\r\n  uint16 public currentPeriod = 1;\r\n\r\n  address public moderator;\r\n\r\n  mapping(address => mapping (address => uint256)) internal allowed;\r\n\r\n  event Mint(address indexed to, uint256 amount);\r\n  event PeriodEnd(uint16 period, uint256 amount, uint64 users);\r\n  event Donation(address indexed from, uint256 amount);\r\n  event Withdrawal(address indexed to, uint16 indexed period, uint256 amount);\r\n  event NewUser(address addr, bytes20 username, uint64 endowment);\r\n\r\n  modifier onlyMod() {\r\n    require(msg.sender == moderator);\r\n    _;\r\n  }\r\n\r\n  function Karma(uint256 _startEpoch) public {\r\n    epoch = _startEpoch;\r\n    moderator = msg.sender;\r\n  }\r\n\r\n  function() payable public {\r\n    Donation(msg.sender, msg.value);\r\n  }\r\n\r\n  /** \r\n   * Owner Functions \r\n   */\r\n\r\n  function setMod(address _newMod) public onlyOwner {\r\n    moderator = _newMod;\r\n  }\r\n\r\n  // Owner should call this on 1st of every month.\r\n  function newPeriod() public onlyOwner {\r\n    require(now >= epoch + 28 days);\r\n\r\n    // Calculate dividend.\r\n    uint64 existingUsers = numUsers;\r\n    if (existingUsers == 0) {\r\n      dividend = 0;\r\n    } else {\r\n      dividend = this.balance / existingUsers;\r\n    }\r\n\r\n    numUsers = numUsers.add(newUsers);\r\n    newUsers = 0;\r\n    currentPeriod++;\r\n    epoch = now;\r\n\r\n    PeriodEnd(currentPeriod-1, this.balance, existingUsers);\r\n  }\r\n\r\n  /**\r\n    * Mod Functions\r\n    */\r\n\r\n  function createUser(address _addr, bytes20 _username, uint64 _amount) public onlyMod {\r\n    newUser(_addr, _username, _amount);\r\n  }\r\n\r\n  // Send karma to existing account.\r\n  function mint(address _addr, uint64 _amount) public onlyMod {\r\n    require(users[_addr].canWithdrawPeriod != 0);\r\n\r\n    users[_addr].karma = users[_addr].karma.add(_amount);\r\n    totalSupply = totalSupply.add(_amount);\r\n    Mint(_addr, _amount);\r\n  }\r\n\r\n  // If a user has been bad, they won't be able to receive a dividend :(\r\n  function timeout(address _addr) public onlyMod {\r\n    require(users[_addr].canWithdrawPeriod != 0);\r\n\r\n    users[_addr].canWithdrawPeriod = currentPeriod + 1;\r\n  }\r\n\r\n  /**\r\n    * User Functions\r\n    */\r\n\r\n  // Owner will sign hash(address, username, amount), and address owner uses this \r\n  // signature to register their account.\r\n  function register(bytes20 _username, uint64 _endowment, bytes _sig) public {\r\n    require(recover(keccak256(msg.sender, _username, _endowment), _sig) == owner);\r\n    newUser(msg.sender, _username, _endowment);\r\n  }\r\n\r\n  // User can withdraw their share of donations from the previous month.\r\n  function withdraw() public {\r\n    require(users[msg.sender].canWithdrawPeriod != 0);\r\n    require(users[msg.sender].canWithdrawPeriod < currentPeriod);\r\n\r\n    users[msg.sender].canWithdrawPeriod = currentPeriod;\r\n    msg.sender.transfer(dividend);\r\n    Withdrawal(msg.sender, currentPeriod-1, dividend);\r\n  }\r\n\r\n  /**\r\n    * ERC20 Functions\r\n    */\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return users[_owner].karma;\r\n  }\r\n\r\n  // Contrary to most ERC20 implementations, require that recipient is existing user.\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(users[_to].canWithdrawPeriod != 0);\r\n    require(_value <= users[msg.sender].karma);\r\n\r\n    // Type assertion to uint64 is safe because we require that _value is < uint64 above.\r\n    users[msg.sender].karma = users[msg.sender].karma.sub(uint64(_value));\r\n    users[_to].karma = users[_to].karma.add(uint64(_value));\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  // Contrary to most ERC20 implementations, require that recipient is existing user.\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(users[_to].canWithdrawPeriod != 0);\r\n    require(_value <= users[_from].karma);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    users[_from].karma = users[_from].karma.sub(uint64(_value));\r\n    users[_to].karma = users[_to].karma.add(uint64(_value));\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n    * Private Functions\r\n    */\r\n\r\n  // https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ECRecovery.sol\r\n  function recover(bytes32 hash, bytes sig) internal pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n  // Ensures that username isn't taken, and account doesn't already exist for \r\n  // user's address.\r\n  function newUser(address _addr, bytes20 _username, uint64 _endowment) private {\r\n    require(usernames[_username] == address(0));\r\n    require(users[_addr].canWithdrawPeriod == 0);\r\n\r\n    users[_addr].canWithdrawPeriod = currentPeriod + 1;\r\n    users[_addr].birthPeriod = currentPeriod;\r\n    users[_addr].karma = _endowment;\r\n    users[_addr].username = _username;\r\n    usernames[_username] = _addr;\r\n\r\n    newUsers = newUsers.add(1);\r\n    totalSupply = totalSupply.add(_endowment);\r\n    NewUser(_addr, _username, _endowment);\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  InheritanceSpecifier
     Gas costs: 0
     Source: "DetailedERC20(\"KarmaToken\", \"KARMA\", 0)"
    UserDefinedTypeName "DetailedERC20"
       Source: "DetailedERC20"
    Literal, token: [no token] value: KarmaToken
       Type: literal_string "KarmaToken"
       Source: "\"KarmaToken\""
    Literal, token: [no token] value: KARMA
       Type: literal_string "KARMA"
       Source: "\"KARMA\""
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath64 for uint64;"
    UserDefinedTypeName "SafeMath64"
       Source: "SafeMath64"
    ElementaryTypeName uint64
       Source: "uint64"
  StructDefinition "User"
     Gas costs: 0
     Source: "struct User {\r\n    bytes20 username;\r\n    uint64 karma; \r\n    uint16 canWithdrawPeriod;\r\n    uint16 birthPeriod;\r\n  }"
    VariableDeclaration "username"
       Type: bytes20
       Source: "bytes20 username"
      ElementaryTypeName bytes20
         Source: "bytes20"
    VariableDeclaration "karma"
       Type: uint64
       Source: "uint64 karma"
      ElementaryTypeName uint64
         Source: "uint64"
    VariableDeclaration "canWithdrawPeriod"
       Type: uint16
       Source: "uint16 canWithdrawPeriod"
      ElementaryTypeName uint16
         Source: "uint16"
    VariableDeclaration "birthPeriod"
       Type: uint16
       Source: "uint16 birthPeriod"
      ElementaryTypeName uint16
         Source: "uint16"
  VariableDeclaration "users"
     Type: mapping(address => struct Karma.User storage ref)
     Gas costs: [???]
     Source: "mapping(address => User) public users"
    Mapping
       Source: "mapping(address => User)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "User"
         Source: "User"
  VariableDeclaration "usernames"
     Type: mapping(bytes20 => address)
     Gas costs: [???]
     Source: "mapping(bytes20 => address) public usernames"
    Mapping
       Source: "mapping(bytes20 => address)"
      ElementaryTypeName bytes20
         Source: "bytes20"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "epoch"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public epoch"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "dividend"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public dividend"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "numUsers"
     Type: uint64
     Gas costs: [???]
     Source: "uint64 public numUsers"
    ElementaryTypeName uint64
       Source: "uint64"
  VariableDeclaration "newUsers"
     Type: uint64
     Gas costs: [???]
     Source: "uint64 public newUsers"
    ElementaryTypeName uint64
       Source: "uint64"
  VariableDeclaration "currentPeriod"
     Type: uint16
     Gas costs: [???]
     Source: "uint16 public currentPeriod = 1"
    ElementaryTypeName uint16
       Source: "uint16"
    Literal, token: [no token] value: 1
       Type: int_const 1
       Source: "1"
  VariableDeclaration "moderator"
     Type: address
     Gas costs: [???]
     Source: "address public moderator"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping(address => mapping (address => uint256)) internal allowed"
    Mapping
       Source: "mapping(address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Mint"
     Gas costs: 0
     Source: "event Mint(address indexed to, uint256 amount);"
    ParameterList
       Source: "(address indexed to, uint256 amount)"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "PeriodEnd"
     Gas costs: 0
     Source: "event PeriodEnd(uint16 period, uint256 amount, uint64 users);"
    ParameterList
       Source: "(uint16 period, uint256 amount, uint64 users)"
      VariableDeclaration "period"
         Type: uint16
         Source: "uint16 period"
        ElementaryTypeName uint16
           Source: "uint16"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "users"
         Type: uint64
         Source: "uint64 users"
        ElementaryTypeName uint64
           Source: "uint64"
  EventDefinition "Donation"
     Gas costs: 0
     Source: "event Donation(address indexed from, uint256 amount);"
    ParameterList
       Source: "(address indexed from, uint256 amount)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Withdrawal"
     Gas costs: 0
     Source: "event Withdrawal(address indexed to, uint16 indexed period, uint256 amount);"
    ParameterList
       Source: "(address indexed to, uint16 indexed period, uint256 amount)"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "period"
         Type: uint16
         Source: "uint16 indexed period"
        ElementaryTypeName uint16
           Source: "uint16"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "NewUser"
     Gas costs: 0
     Source: "event NewUser(address addr, bytes20 username, uint64 endowment);"
    ParameterList
       Source: "(address addr, bytes20 username, uint64 endowment)"
      VariableDeclaration "addr"
         Type: address
         Source: "address addr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "username"
         Type: bytes20
         Source: "bytes20 username"
        ElementaryTypeName bytes20
           Source: "bytes20"
      VariableDeclaration "endowment"
         Type: uint64
         Source: "uint64 endowment"
        ElementaryTypeName uint64
           Source: "uint64"
  ModifierDefinition "onlyMod"
     Source: "modifier onlyMod() {\r\n    require(msg.sender == moderator);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(msg.sender == moderator);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 846
         Source: "require(msg.sender == moderator)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == moderator)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == moderator"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier moderator
               Type: address
               Source: "moderator"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "Karma" - public
     Source: "function Karma(uint256 _startEpoch) public {\r\n    epoch = _startEpoch;\r\n    moderator = msg.sender;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _startEpoch)"
      VariableDeclaration "_startEpoch"
         Type: uint256
         Source: "uint256 _startEpoch"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    epoch = _startEpoch;\r\n    moderator = msg.sender;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "epoch = _startEpoch"
        Assignment using operator =
           Type: uint256
           Source: "epoch = _startEpoch"
          Identifier epoch
             Type: uint256
             Source: "epoch"
          Identifier _startEpoch
             Type: uint256
             Source: "_startEpoch"
      ExpressionStatement
         Gas costs: 0
         Source: "moderator = msg.sender"
        Assignment using operator =
           Type: address
           Source: "moderator = msg.sender"
          Identifier moderator
             Type: address
             Source: "moderator"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "" - public
     Source: "function() payable public {\r\n    Donation(msg.sender, msg.value);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    Donation(msg.sender, msg.value);\r\n  }"
      ExpressionStatement
         Gas costs: [???]
         Source: "Donation(msg.sender, msg.value)"
        FunctionCall
           Type: tuple()
           Source: "Donation(msg.sender, msg.value)"
          Identifier Donation
             Type: function (address,uint256)
             Source: "Donation"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "setMod" - public
     Source: "function setMod(address _newMod) public onlyOwner {\r\n    moderator = _newMod;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _newMod)"
      VariableDeclaration "_newMod"
         Type: address
         Source: "address _newMod"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    moderator = _newMod;\r\n  }"
      ExpressionStatement
         Gas costs: 20267
         Source: "moderator = _newMod"
        Assignment using operator =
           Type: address
           Source: "moderator = _newMod"
          Identifier moderator
             Type: address
             Source: "moderator"
          Identifier _newMod
             Type: address
             Source: "_newMod"
  FunctionDefinition "newPeriod" - public
     Source: "function newPeriod() public onlyOwner {\r\n    require(now >= epoch + 28 days);\r\n\r\n    // Calculate dividend.\r\n    uint64 existingUsers = numUsers;\r\n    if (existingUsers == 0) {\r\n      dividend = 0;\r\n    } else {\r\n      dividend = this.balance / existingUsers;\r\n    }\r\n\r\n    numUsers = numUsers.add(newUsers);\r\n    newUsers = 0;\r\n    currentPeriod++;\r\n    epoch = now;\r\n\r\n    PeriodEnd(currentPeriod-1, this.balance, existingUsers);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(now >= epoch + 28 days);\r\n\r\n    // Calculate dividend.\r\n    uint64 existingUsers = numUsers;\r\n    if (existingUsers == 0) {\r\n      dividend = 0;\r\n    } else {\r\n      dividend = this.balance / existingUsers;\r\n    }\r\n\r\n    numUsers = numUsers.add(newUsers);\r\n    newUsers = 0;\r\n    currentPeriod++;\r\n    epoch = now;\r\n\r\n    PeriodEnd(currentPeriod-1, this.balance, existingUsers);\r\n  }"
      ExpressionStatement
         Gas costs: 243
         Source: "require(now >= epoch + 28 days)"
        FunctionCall
           Type: tuple()
           Source: "require(now >= epoch + 28 days)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "now >= epoch + 28 days"
            Identifier now
               Type: uint256
               Source: "now"
            BinaryOperation using operator +
               Type: uint256
               Source: "epoch + 28 days"
              Identifier epoch
                 Type: uint256
                 Source: "epoch"
              Literal, token: [no token] value: 28
                 Type: int_const 2419200
                 Source: "28 days"
      VariableDeclarationStatement
         Gas costs: 247
         Source: "uint64 existingUsers = numUsers"
        VariableDeclaration "existingUsers"
           Type: uint64
           Source: "uint64 existingUsers"
          ElementaryTypeName uint64
             Source: "uint64"
        Identifier numUsers
           Type: uint64
           Source: "numUsers"
      IfStatement
         Source: "if (existingUsers == 0) {\r\n      dividend = 0;\r\n    } else {\r\n      dividend = this.balance / existingUsers;\r\n    }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 15
           Source: "existingUsers == 0"
          Identifier existingUsers
             Type: uint64
             Source: "existingUsers"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n      dividend = 0;\r\n    }"
          ExpressionStatement
             Gas costs: 5014
             Source: "dividend = 0"
            Assignment using operator =
               Type: uint256
               Source: "dividend = 0"
              Identifier dividend
                 Type: uint256
                 Source: "dividend"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\r\n      dividend = this.balance / existingUsers;\r\n    }"
          ExpressionStatement
             Gas costs: 20456
             Source: "dividend = this.balance / existingUsers"
            Assignment using operator =
               Type: uint256
               Source: "dividend = this.balance / existingUsers"
              Identifier dividend
                 Type: uint256
                 Source: "dividend"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "this.balance / existingUsers"
                MemberAccess to member balance
                   Type: uint256
                   Source: "this.balance"
                  Identifier this
                     Type: contract Karma
                     Source: "this"
                Identifier existingUsers
                   Type: uint64
                   Source: "existingUsers"
      ExpressionStatement
         Gas costs: 20828
         Source: "numUsers = numUsers.add(newUsers)"
        Assignment using operator =
           Type: uint64
           Source: "numUsers = numUsers.add(newUsers)"
          Identifier numUsers
             Type: uint64
             Source: "numUsers"
          FunctionCall
             Type: uint64
             Source: "numUsers.add(newUsers)"
            MemberAccess to member add
               Type: function (uint64,uint64) pure returns (uint64)
               Source: "numUsers.add"
              Identifier numUsers
                 Type: uint64
                 Source: "numUsers"
            Identifier newUsers
               Type: uint64
               Source: "newUsers"
      ExpressionStatement
         Gas costs: 20317
         Source: "newUsers = 0"
        Assignment using operator =
           Type: uint64
           Source: "newUsers = 0"
          Identifier newUsers
             Type: uint64
             Source: "newUsers"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 20629
         Source: "currentPeriod++"
        UnaryOperation (postfix) ++
           Type: uint16
           Source: "currentPeriod++"
          Identifier currentPeriod
             Type: uint16
             Source: "currentPeriod"
      ExpressionStatement
         Gas costs: 20013
         Source: "epoch = now"
        Assignment using operator =
           Type: uint256
           Source: "epoch = now"
          Identifier epoch
             Type: uint256
             Source: "epoch"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: [???]
         Source: "PeriodEnd(currentPeriod-1, this.balance, existingUsers)"
        FunctionCall
           Type: tuple()
           Source: "PeriodEnd(currentPeriod-1, this.balance, existingUsers)"
          Identifier PeriodEnd
             Type: function (uint16,uint256,uint64)
             Source: "PeriodEnd"
          BinaryOperation using operator -
             Type: uint16
             Source: "currentPeriod-1"
            Identifier currentPeriod
               Type: uint16
               Source: "currentPeriod"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract Karma
               Source: "this"
          Identifier existingUsers
             Type: uint64
             Source: "existingUsers"
  FunctionDefinition "createUser" - public
     Source: "function createUser(address _addr, bytes20 _username, uint64 _amount) public onlyMod {\r\n    newUser(_addr, _username, _amount);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _addr, bytes20 _username, uint64 _amount)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_username"
         Type: bytes20
         Source: "bytes20 _username"
        ElementaryTypeName bytes20
           Source: "bytes20"
      VariableDeclaration "_amount"
         Type: uint64
         Source: "uint64 _amount"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyMod"
       Gas costs: 0
       Source: "onlyMod"
      Identifier onlyMod
         Type: modifier ()
         Source: "onlyMod"
    Block
       Source: "{\r\n    newUser(_addr, _username, _amount);\r\n  }"
      ExpressionStatement
         Gas costs: 13
         Source: "newUser(_addr, _username, _amount)"
        FunctionCall
           Type: tuple()
           Source: "newUser(_addr, _username, _amount)"
          Identifier newUser
             Type: function (address,bytes20,uint64)
             Source: "newUser"
          Identifier _addr
             Type: address
             Source: "_addr"
          Identifier _username
             Type: bytes20
             Source: "_username"
          Identifier _amount
             Type: uint64
             Source: "_amount"
  FunctionDefinition "mint" - public
     Source: "function mint(address _addr, uint64 _amount) public onlyMod {\r\n    require(users[_addr].canWithdrawPeriod != 0);\r\n\r\n    users[_addr].karma = users[_addr].karma.add(_amount);\r\n    totalSupply = totalSupply.add(_amount);\r\n    Mint(_addr, _amount);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _addr, uint64 _amount)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint64
         Source: "uint64 _amount"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyMod"
       Gas costs: 0
       Source: "onlyMod"
      Identifier onlyMod
         Type: modifier ()
         Source: "onlyMod"
    Block
       Source: "{\r\n    require(users[_addr].canWithdrawPeriod != 0);\r\n\r\n    users[_addr].karma = users[_addr].karma.add(_amount);\r\n    totalSupply = totalSupply.add(_amount);\r\n    Mint(_addr, _amount);\r\n  }"
      ExpressionStatement
         Gas costs: 432
         Source: "require(users[_addr].canWithdrawPeriod != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(users[_addr].canWithdrawPeriod != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "users[_addr].canWithdrawPeriod != 0"
            MemberAccess to member canWithdrawPeriod
               Type: uint16
               Source: "users[_addr].canWithdrawPeriod"
              IndexAccess
                 Type: struct Karma.User storage ref
                 Source: "users[_addr]"
                Identifier users
                   Type: mapping(address => struct Karma.User storage ref)
                   Source: "users"
                Identifier _addr
                   Type: address
                   Source: "_addr"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20846
         Source: "users[_addr].karma = users[_addr].karma.add(_amount)"
        Assignment using operator =
           Type: uint64
           Source: "users[_addr].karma = users[_addr].karma.add(_amount)"
          MemberAccess to member karma
             Type: uint64
             Source: "users[_addr].karma"
            IndexAccess
               Type: struct Karma.User storage ref
               Source: "users[_addr]"
              Identifier users
                 Type: mapping(address => struct Karma.User storage ref)
                 Source: "users"
              Identifier _addr
                 Type: address
                 Source: "_addr"
          FunctionCall
             Type: uint64
             Source: "users[_addr].karma.add(_amount)"
            MemberAccess to member add
               Type: function (uint64,uint64) pure returns (uint64)
               Source: "users[_addr].karma.add"
              MemberAccess to member karma
                 Type: uint64
                 Source: "users[_addr].karma"
                IndexAccess
                   Type: struct Karma.User storage ref
                   Source: "users[_addr]"
                  Identifier users
                     Type: mapping(address => struct Karma.User storage ref)
                     Source: "users"
                  Identifier _addr
                     Type: address
                     Source: "_addr"
            Identifier _amount
               Type: uint64
               Source: "_amount"
      ExpressionStatement
         Gas costs: 20253
         Source: "totalSupply = totalSupply.add(_amount)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = totalSupply.add(_amount)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "totalSupply.add(_amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "totalSupply.add"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
            Identifier _amount
               Type: uint64
               Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Mint(_addr, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Mint(_addr, _amount)"
          Identifier Mint
             Type: function (address,uint256)
             Source: "Mint"
          Identifier _addr
             Type: address
             Source: "_addr"
          Identifier _amount
             Type: uint64
             Source: "_amount"
  FunctionDefinition "timeout" - public
     Source: "function timeout(address _addr) public onlyMod {\r\n    require(users[_addr].canWithdrawPeriod != 0);\r\n\r\n    users[_addr].canWithdrawPeriod = currentPeriod + 1;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _addr)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyMod"
       Gas costs: 0
       Source: "onlyMod"
      Identifier onlyMod
         Type: modifier ()
         Source: "onlyMod"
    Block
       Source: "{\r\n    require(users[_addr].canWithdrawPeriod != 0);\r\n\r\n    users[_addr].canWithdrawPeriod = currentPeriod + 1;\r\n  }"
      ExpressionStatement
         Gas costs: 432
         Source: "require(users[_addr].canWithdrawPeriod != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(users[_addr].canWithdrawPeriod != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "users[_addr].canWithdrawPeriod != 0"
            MemberAccess to member canWithdrawPeriod
               Type: uint16
               Source: "users[_addr].canWithdrawPeriod"
              IndexAccess
                 Type: struct Karma.User storage ref
                 Source: "users[_addr]"
                Identifier users
                   Type: mapping(address => struct Karma.User storage ref)
                   Source: "users"
                Identifier _addr
                   Type: address
                   Source: "_addr"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20711
         Source: "users[_addr].canWithdrawPeriod = currentPeriod + 1"
        Assignment using operator =
           Type: uint16
           Source: "users[_addr].canWithdrawPeriod = currentPeriod + 1"
          MemberAccess to member canWithdrawPeriod
             Type: uint16
             Source: "users[_addr].canWithdrawPeriod"
            IndexAccess
               Type: struct Karma.User storage ref
               Source: "users[_addr]"
              Identifier users
                 Type: mapping(address => struct Karma.User storage ref)
                 Source: "users"
              Identifier _addr
                 Type: address
                 Source: "_addr"
          BinaryOperation using operator +
             Type: uint16
             Source: "currentPeriod + 1"
            Identifier currentPeriod
               Type: uint16
               Source: "currentPeriod"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
  FunctionDefinition "register" - public
     Source: "function register(bytes20 _username, uint64 _endowment, bytes _sig) public {\r\n    require(recover(keccak256(msg.sender, _username, _endowment), _sig) == owner);\r\n    newUser(msg.sender, _username, _endowment);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes20 _username, uint64 _endowment, bytes _sig)"
      VariableDeclaration "_username"
         Type: bytes20
         Source: "bytes20 _username"
        ElementaryTypeName bytes20
           Source: "bytes20"
      VariableDeclaration "_endowment"
         Type: uint64
         Source: "uint64 _endowment"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_sig"
         Type: bytes memory
         Source: "bytes _sig"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    require(recover(keccak256(msg.sender, _username, _endowment), _sig) == owner);\r\n    newUser(msg.sender, _username, _endowment);\r\n  }"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(recover(keccak256(msg.sender, _username, _endowment), _sig) == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(recover(keccak256(msg.sender, _username, _endowment), _sig) == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "recover(keccak256(msg.sender, _username, _endowment), _sig) == owner"
            FunctionCall
               Type: address
               Source: "recover(keccak256(msg.sender, _username, _endowment), _sig)"
              Identifier recover
                 Type: function (bytes32,bytes memory) pure returns (address)
                 Source: "recover"
              FunctionCall
                 Type: bytes32
                 Source: "keccak256(msg.sender, _username, _endowment)"
                Identifier keccak256
                   Type: function () pure returns (bytes32)
                   Source: "keccak256"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Identifier _username
                   Type: bytes20
                   Source: "_username"
                Identifier _endowment
                   Type: uint64
                   Source: "_endowment"
              Identifier _sig
                 Type: bytes memory
                 Source: "_sig"
            Identifier owner
               Type: address
               Source: "owner"
      ExpressionStatement
         Gas costs: 23
         Source: "newUser(msg.sender, _username, _endowment)"
        FunctionCall
           Type: tuple()
           Source: "newUser(msg.sender, _username, _endowment)"
          Identifier newUser
             Type: function (address,bytes20,uint64)
             Source: "newUser"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _username
             Type: bytes20
             Source: "_username"
          Identifier _endowment
             Type: uint64
             Source: "_endowment"
  FunctionDefinition "withdraw" - public
     Source: "function withdraw() public {\r\n    require(users[msg.sender].canWithdrawPeriod != 0);\r\n    require(users[msg.sender].canWithdrawPeriod < currentPeriod);\r\n\r\n    users[msg.sender].canWithdrawPeriod = currentPeriod;\r\n    msg.sender.transfer(dividend);\r\n    Withdrawal(msg.sender, currentPeriod-1, dividend);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    require(users[msg.sender].canWithdrawPeriod != 0);\r\n    require(users[msg.sender].canWithdrawPeriod < currentPeriod);\r\n\r\n    users[msg.sender].canWithdrawPeriod = currentPeriod;\r\n    msg.sender.transfer(dividend);\r\n    Withdrawal(msg.sender, currentPeriod-1, dividend);\r\n  }"
      ExpressionStatement
         Gas costs: 431
         Source: "require(users[msg.sender].canWithdrawPeriod != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(users[msg.sender].canWithdrawPeriod != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "users[msg.sender].canWithdrawPeriod != 0"
            MemberAccess to member canWithdrawPeriod
               Type: uint16
               Source: "users[msg.sender].canWithdrawPeriod"
              IndexAccess
                 Type: struct Karma.User storage ref
                 Source: "users[msg.sender]"
                Identifier users
                   Type: mapping(address => struct Karma.User storage ref)
                   Source: "users"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 720
         Source: "require(users[msg.sender].canWithdrawPeriod < currentPeriod)"
        FunctionCall
           Type: tuple()
           Source: "require(users[msg.sender].canWithdrawPeriod < currentPeriod)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "users[msg.sender].canWithdrawPeriod < currentPeriod"
            MemberAccess to member canWithdrawPeriod
               Type: uint16
               Source: "users[msg.sender].canWithdrawPeriod"
              IndexAccess
                 Type: struct Karma.User storage ref
                 Source: "users[msg.sender]"
                Identifier users
                   Type: mapping(address => struct Karma.User storage ref)
                   Source: "users"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier currentPeriod
               Type: uint16
               Source: "currentPeriod"
      ExpressionStatement
         Gas costs: 20704
         Source: "users[msg.sender].canWithdrawPeriod = currentPeriod"
        Assignment using operator =
           Type: uint16
           Source: "users[msg.sender].canWithdrawPeriod = currentPeriod"
          MemberAccess to member canWithdrawPeriod
             Type: uint16
             Source: "users[msg.sender].canWithdrawPeriod"
            IndexAccess
               Type: struct Karma.User storage ref
               Source: "users[msg.sender]"
              Identifier users
                 Type: mapping(address => struct Karma.User storage ref)
                 Source: "users"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          Identifier currentPeriod
             Type: uint16
             Source: "currentPeriod"
      ExpressionStatement
         Gas costs: [???]
         Source: "msg.sender.transfer(dividend)"
        FunctionCall
           Type: tuple()
           Source: "msg.sender.transfer(dividend)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "msg.sender.transfer"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier dividend
             Type: uint256
             Source: "dividend"
      ExpressionStatement
         Gas costs: [???]
         Source: "Withdrawal(msg.sender, currentPeriod-1, dividend)"
        FunctionCall
           Type: tuple()
           Source: "Withdrawal(msg.sender, currentPeriod-1, dividend)"
          Identifier Withdrawal
             Type: function (address,uint16,uint256)
             Source: "Withdrawal"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          BinaryOperation using operator -
             Type: uint16
             Source: "currentPeriod-1"
            Identifier currentPeriod
               Type: uint16
               Source: "currentPeriod"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Identifier dividend
             Type: uint256
             Source: "dividend"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return users[_owner].karma;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return users[_owner].karma;\r\n  }"
      Return
         Gas costs: 402
         Source: "return users[_owner].karma"
        MemberAccess to member karma
           Type: uint64
           Source: "users[_owner].karma"
          IndexAccess
             Type: struct Karma.User storage ref
             Source: "users[_owner]"
            Identifier users
               Type: mapping(address => struct Karma.User storage ref)
               Source: "users"
            Identifier _owner
               Type: address
               Source: "_owner"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(users[_to].canWithdrawPeriod != 0);\r\n    require(_value <= users[msg.sender].karma);\r\n\r\n    // Type assertion to uint64 is safe because we require that _value is < uint64 above.\r\n    users[msg.sender].karma = users[msg.sender].karma.sub(uint64(_value));\r\n    users[_to].karma = users[_to].karma.add(uint64(_value));\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(users[_to].canWithdrawPeriod != 0);\r\n    require(_value <= users[msg.sender].karma);\r\n\r\n    // Type assertion to uint64 is safe because we require that _value is < uint64 above.\r\n    users[msg.sender].karma = users[msg.sender].karma.sub(uint64(_value));\r\n    users[_to].karma = users[_to].karma.add(uint64(_value));\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 432
         Source: "require(users[_to].canWithdrawPeriod != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(users[_to].canWithdrawPeriod != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "users[_to].canWithdrawPeriod != 0"
            MemberAccess to member canWithdrawPeriod
               Type: uint16
               Source: "users[_to].canWithdrawPeriod"
              IndexAccess
                 Type: struct Karma.User storage ref
                 Source: "users[_to]"
                Identifier users
                   Type: mapping(address => struct Karma.User storage ref)
                   Source: "users"
                Identifier _to
                   Type: address
                   Source: "_to"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 431
         Source: "require(_value <= users[msg.sender].karma)"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= users[msg.sender].karma)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= users[msg.sender].karma"
            Identifier _value
               Type: uint256
               Source: "_value"
            MemberAccess to member karma
               Type: uint64
               Source: "users[msg.sender].karma"
              IndexAccess
                 Type: struct Karma.User storage ref
                 Source: "users[msg.sender]"
                Identifier users
                   Type: mapping(address => struct Karma.User storage ref)
                   Source: "users"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
      ExpressionStatement
         Gas costs: 20844
         Source: "users[msg.sender].karma = users[msg.sender].karma.sub(uint64(_value))"
        Assignment using operator =
           Type: uint64
           Source: "users[msg.sender].karma = users[msg.sender].karma.sub(uint64(_value))"
          MemberAccess to member karma
             Type: uint64
             Source: "users[msg.sender].karma"
            IndexAccess
               Type: struct Karma.User storage ref
               Source: "users[msg.sender]"
              Identifier users
                 Type: mapping(address => struct Karma.User storage ref)
                 Source: "users"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          FunctionCall
             Type: uint64
             Source: "users[msg.sender].karma.sub(uint64(_value))"
            MemberAccess to member sub
               Type: function (uint64,uint64) pure returns (uint64)
               Source: "users[msg.sender].karma.sub"
              MemberAccess to member karma
                 Type: uint64
                 Source: "users[msg.sender].karma"
                IndexAccess
                   Type: struct Karma.User storage ref
                   Source: "users[msg.sender]"
                  Identifier users
                     Type: mapping(address => struct Karma.User storage ref)
                     Source: "users"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
            FunctionCall
               Type: uint64
               Source: "uint64(_value)"
              ElementaryTypeNameExpression uint64
                 Type: type(uint64)
                 Source: "uint64"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      ExpressionStatement
         Gas costs: 20840
         Source: "users[_to].karma = users[_to].karma.add(uint64(_value))"
        Assignment using operator =
           Type: uint64
           Source: "users[_to].karma = users[_to].karma.add(uint64(_value))"
          MemberAccess to member karma
             Type: uint64
             Source: "users[_to].karma"
            IndexAccess
               Type: struct Karma.User storage ref
               Source: "users[_to]"
              Identifier users
                 Type: mapping(address => struct Karma.User storage ref)
                 Source: "users"
              Identifier _to
                 Type: address
                 Source: "_to"
          FunctionCall
             Type: uint64
             Source: "users[_to].karma.add(uint64(_value))"
            MemberAccess to member add
               Type: function (uint64,uint64) pure returns (uint64)
               Source: "users[_to].karma.add"
              MemberAccess to member karma
                 Type: uint64
                 Source: "users[_to].karma"
                IndexAccess
                   Type: struct Karma.User storage ref
                   Source: "users[_to]"
                  Identifier users
                     Type: mapping(address => struct Karma.User storage ref)
                     Source: "users"
                  Identifier _to
                     Type: address
                     Source: "_to"
            FunctionCall
               Type: uint64
               Source: "uint64(_value)"
              ElementaryTypeNameExpression uint64
                 Type: type(uint64)
                 Source: "uint64"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return allowed[_owner][_spender];\r\n  }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "increaseApproval" - public
     Source: "function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _addedValue)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_addedValue"
         Type: uint256
         Source: "uint _addedValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 20617
         Source: "allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          FunctionCall
             Type: uint256
             Source: "allowed[msg.sender][_spender].add(_addedValue)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "allowed[msg.sender][_spender].add"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
            Identifier _addedValue
               Type: uint256
               Source: "_addedValue"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "decreaseApproval" - public
     Source: "function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _subtractedValue)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_subtractedValue"
         Type: uint256
         Source: "uint _subtractedValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 396
         Source: "uint oldValue = allowed[msg.sender][_spender]"
        VariableDeclaration "oldValue"
           Type: uint256
           Source: "uint oldValue"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "allowed[msg.sender][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[msg.sender]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
      IfStatement
         Source: "if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "_subtractedValue > oldValue"
          Identifier _subtractedValue
             Type: uint256
             Source: "_subtractedValue"
          Identifier oldValue
             Type: uint256
             Source: "oldValue"
        Block
           Source: "{\r\n      allowed[msg.sender][_spender] = 0;\r\n    }"
          ExpressionStatement
             Gas costs: 5199
             Source: "allowed[msg.sender][_spender] = 0"
            Assignment using operator =
               Type: uint256
               Source: "allowed[msg.sender][_spender] = 0"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }"
          ExpressionStatement
             Gas costs: 20232
             Source: "allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)"
            Assignment using operator =
               Type: uint256
               Source: "allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
              FunctionCall
                 Type: uint256
                 Source: "oldValue.sub(_subtractedValue)"
                MemberAccess to member sub
                   Type: function (uint256,uint256) pure returns (uint256)
                   Source: "oldValue.sub"
                  Identifier oldValue
                     Type: uint256
                     Source: "oldValue"
                Identifier _subtractedValue
                   Type: uint256
                   Source: "_subtractedValue"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(users[_to].canWithdrawPeriod != 0);\r\n    require(_value <= users[_from].karma);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    users[_from].karma = users[_from].karma.sub(uint64(_value));\r\n    users[_to].karma = users[_to].karma.add(uint64(_value));\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(users[_to].canWithdrawPeriod != 0);\r\n    require(_value <= users[_from].karma);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    users[_from].karma = users[_from].karma.sub(uint64(_value));\r\n    users[_to].karma = users[_to].karma.add(uint64(_value));\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 432
         Source: "require(users[_to].canWithdrawPeriod != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(users[_to].canWithdrawPeriod != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "users[_to].canWithdrawPeriod != 0"
            MemberAccess to member canWithdrawPeriod
               Type: uint16
               Source: "users[_to].canWithdrawPeriod"
              IndexAccess
                 Type: struct Karma.User storage ref
                 Source: "users[_to]"
                Identifier users
                   Type: mapping(address => struct Karma.User storage ref)
                   Source: "users"
                Identifier _to
                   Type: address
                   Source: "_to"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 432
         Source: "require(_value <= users[_from].karma)"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= users[_from].karma)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= users[_from].karma"
            Identifier _value
               Type: uint256
               Source: "_value"
            MemberAccess to member karma
               Type: uint64
               Source: "users[_from].karma"
              IndexAccess
                 Type: struct Karma.User storage ref
                 Source: "users[_from]"
                Identifier users
                   Type: mapping(address => struct Karma.User storage ref)
                   Source: "users"
                Identifier _from
                   Type: address
                   Source: "_from"
      ExpressionStatement
         Gas costs: 423
         Source: "require(_value <= allowed[_from][msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= allowed[_from][msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= allowed[_from][msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "allowed[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[_from]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 20846
         Source: "users[_from].karma = users[_from].karma.sub(uint64(_value))"
        Assignment using operator =
           Type: uint64
           Source: "users[_from].karma = users[_from].karma.sub(uint64(_value))"
          MemberAccess to member karma
             Type: uint64
             Source: "users[_from].karma"
            IndexAccess
               Type: struct Karma.User storage ref
               Source: "users[_from]"
              Identifier users
                 Type: mapping(address => struct Karma.User storage ref)
                 Source: "users"
              Identifier _from
                 Type: address
                 Source: "_from"
          FunctionCall
             Type: uint64
             Source: "users[_from].karma.sub(uint64(_value))"
            MemberAccess to member sub
               Type: function (uint64,uint64) pure returns (uint64)
               Source: "users[_from].karma.sub"
              MemberAccess to member karma
                 Type: uint64
                 Source: "users[_from].karma"
                IndexAccess
                   Type: struct Karma.User storage ref
                   Source: "users[_from]"
                  Identifier users
                     Type: mapping(address => struct Karma.User storage ref)
                     Source: "users"
                  Identifier _from
                     Type: address
                     Source: "_from"
            FunctionCall
               Type: uint64
               Source: "uint64(_value)"
              ElementaryTypeNameExpression uint64
                 Type: type(uint64)
                 Source: "uint64"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      ExpressionStatement
         Gas costs: 20840
         Source: "users[_to].karma = users[_to].karma.add(uint64(_value))"
        Assignment using operator =
           Type: uint64
           Source: "users[_to].karma = users[_to].karma.add(uint64(_value))"
          MemberAccess to member karma
             Type: uint64
             Source: "users[_to].karma"
            IndexAccess
               Type: struct Karma.User storage ref
               Source: "users[_to]"
              Identifier users
                 Type: mapping(address => struct Karma.User storage ref)
                 Source: "users"
              Identifier _to
                 Type: address
                 Source: "_to"
          FunctionCall
             Type: uint64
             Source: "users[_to].karma.add(uint64(_value))"
            MemberAccess to member add
               Type: function (uint64,uint64) pure returns (uint64)
               Source: "users[_to].karma.add"
              MemberAccess to member karma
                 Type: uint64
                 Source: "users[_to].karma"
                IndexAccess
                   Type: struct Karma.User storage ref
                   Source: "users[_to]"
                  Identifier users
                     Type: mapping(address => struct Karma.User storage ref)
                     Source: "users"
                  Identifier _to
                     Type: address
                     Source: "_to"
            FunctionCall
               Type: uint64
               Source: "uint64(_value)"
              ElementaryTypeNameExpression uint64
                 Type: type(uint64)
                 Source: "uint64"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      ExpressionStatement
         Gas costs: 20611
         Source: "allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "allowed[_from][msg.sender].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "allowed[_from][msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "recover"
     Source: "function recover(bytes32 hash, bytes sig) internal pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 hash, bytes sig)"
      VariableDeclaration "hash"
         Type: bytes32
         Source: "bytes32 hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "sig"
         Type: bytes memory
         Source: "bytes sig"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "bytes32 r"
        VariableDeclaration "r"
           Type: bytes32
           Source: "bytes32 r"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "bytes32 s"
        VariableDeclaration "s"
           Type: bytes32
           Source: "bytes32 s"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint8 v"
        VariableDeclaration "v"
           Type: uint8
           Source: "uint8 v"
          ElementaryTypeName uint8
             Source: "uint8"
      IfStatement
         Source: "if (sig.length != 65) {\r\n      return (address(0));\r\n    }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: [???]
           Source: "sig.length != 65"
          MemberAccess to member length
             Type: uint256
             Source: "sig.length"
            Identifier sig
               Type: bytes memory
               Source: "sig"
          Literal, token: [no token] value: 65
             Type: int_const 65
             Source: "65"
        Block
           Source: "{\r\n      return (address(0));\r\n    }"
          Return
             Gas costs: 19
             Source: "return (address(0))"
            TupleExpression
               Type: address
               Source: "(address(0))"
              FunctionCall
                 Type: address
                 Source: "address(0)"
                ElementaryTypeNameExpression address
                   Type: type(address)
                   Source: "address"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if"
      IfStatement
         Source: "if (v < 27) {\r\n      v += 27;\r\n    }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 15
           Source: "v < 27"
          Identifier v
             Type: uint8
             Source: "v"
          Literal, token: [no token] value: 27
             Type: int_const 27
             Source: "27"
        Block
           Source: "{\r\n      v += 27;\r\n    }"
          ExpressionStatement
             Gas costs: 14
             Source: "v += 27"
            Assignment using operator +=
               Type: uint8
               Source: "v += 27"
              Identifier v
                 Type: uint8
                 Source: "v"
              Literal, token: [no token] value: 27
                 Type: int_const 27
                 Source: "27"
      IfStatement
         Source: "if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 58
           Source: "v != 27 && v != 28"
          BinaryOperation using operator !=
             Type: bool
             Source: "v != 27"
            Identifier v
               Type: uint8
               Source: "v"
            Literal, token: [no token] value: 27
               Type: int_const 27
               Source: "27"
          BinaryOperation using operator !=
             Type: bool
             Source: "v != 28"
            Identifier v
               Type: uint8
               Source: "v"
            Literal, token: [no token] value: 28
               Type: int_const 28
               Source: "28"
        Block
           Source: "{\r\n      return (address(0));\r\n    }"
          Return
             Gas costs: 19
             Source: "return (address(0))"
            TupleExpression
               Type: address
               Source: "(address(0))"
              FunctionCall
                 Type: address
                 Source: "address(0)"
                ElementaryTypeNameExpression address
                   Type: type(address)
                   Source: "address"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
        Block
           Source: "{\r\n      return ecrecover(hash, v, r, s);\r\n    }"
          Return
             Gas costs: [???]
             Source: "return ecrecover(hash, v, r, s)"
            FunctionCall
               Type: address
               Source: "ecrecover(hash, v, r, s)"
              Identifier ecrecover
                 Type: function (bytes32,uint8,bytes32,bytes32) pure returns (address)
                 Source: "ecrecover"
              Identifier hash
                 Type: bytes32
                 Source: "hash"
              Identifier v
                 Type: uint8
                 Source: "v"
              Identifier r
                 Type: bytes32
                 Source: "r"
              Identifier s
                 Type: bytes32
                 Source: "s"
  FunctionDefinition "newUser"
     Source: "function newUser(address _addr, bytes20 _username, uint64 _endowment) private {\r\n    require(usernames[_username] == address(0));\r\n    require(users[_addr].canWithdrawPeriod == 0);\r\n\r\n    users[_addr].canWithdrawPeriod = currentPeriod + 1;\r\n    users[_addr].birthPeriod = currentPeriod;\r\n    users[_addr].karma = _endowment;\r\n    users[_addr].username = _username;\r\n    usernames[_username] = _addr;\r\n\r\n    newUsers = newUsers.add(1);\r\n    totalSupply = totalSupply.add(_endowment);\r\n    NewUser(_addr, _username, _endowment);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _addr, bytes20 _username, uint64 _endowment)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_username"
         Type: bytes20
         Source: "bytes20 _username"
        ElementaryTypeName bytes20
           Source: "bytes20"
      VariableDeclaration "_endowment"
         Type: uint64
         Source: "uint64 _endowment"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    require(usernames[_username] == address(0));\r\n    require(users[_addr].canWithdrawPeriod == 0);\r\n\r\n    users[_addr].canWithdrawPeriod = currentPeriod + 1;\r\n    users[_addr].birthPeriod = currentPeriod;\r\n    users[_addr].karma = _endowment;\r\n    users[_addr].username = _username;\r\n    usernames[_username] = _addr;\r\n\r\n    newUsers = newUsers.add(1);\r\n    totalSupply = totalSupply.add(_endowment);\r\n    NewUser(_addr, _username, _endowment);\r\n  }"
      ExpressionStatement
         Gas costs: 385
         Source: "require(usernames[_username] == address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(usernames[_username] == address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "usernames[_username] == address(0)"
            IndexAccess
               Type: address
               Source: "usernames[_username]"
              Identifier usernames
                 Type: mapping(bytes20 => address)
                 Source: "usernames"
              Identifier _username
                 Type: bytes20
                 Source: "_username"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 429
         Source: "require(users[_addr].canWithdrawPeriod == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(users[_addr].canWithdrawPeriod == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "users[_addr].canWithdrawPeriod == 0"
            MemberAccess to member canWithdrawPeriod
               Type: uint16
               Source: "users[_addr].canWithdrawPeriod"
              IndexAccess
                 Type: struct Karma.User storage ref
                 Source: "users[_addr]"
                Identifier users
                   Type: mapping(address => struct Karma.User storage ref)
                   Source: "users"
                Identifier _addr
                   Type: address
                   Source: "_addr"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20711
         Source: "users[_addr].canWithdrawPeriod = currentPeriod + 1"
        Assignment using operator =
           Type: uint16
           Source: "users[_addr].canWithdrawPeriod = currentPeriod + 1"
          MemberAccess to member canWithdrawPeriod
             Type: uint16
             Source: "users[_addr].canWithdrawPeriod"
            IndexAccess
               Type: struct Karma.User storage ref
               Source: "users[_addr]"
              Identifier users
                 Type: mapping(address => struct Karma.User storage ref)
                 Source: "users"
              Identifier _addr
                 Type: address
                 Source: "_addr"
          BinaryOperation using operator +
             Type: uint16
             Source: "currentPeriod + 1"
            Identifier currentPeriod
               Type: uint16
               Source: "currentPeriod"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: 20699
         Source: "users[_addr].birthPeriod = currentPeriod"
        Assignment using operator =
           Type: uint16
           Source: "users[_addr].birthPeriod = currentPeriod"
          MemberAccess to member birthPeriod
             Type: uint16
             Source: "users[_addr].birthPeriod"
            IndexAccess
               Type: struct Karma.User storage ref
               Source: "users[_addr]"
              Identifier users
                 Type: mapping(address => struct Karma.User storage ref)
                 Source: "users"
              Identifier _addr
                 Type: address
                 Source: "_addr"
          Identifier currentPeriod
             Type: uint16
             Source: "currentPeriod"
      ExpressionStatement
         Gas costs: 20413
         Source: "users[_addr].karma = _endowment"
        Assignment using operator =
           Type: uint64
           Source: "users[_addr].karma = _endowment"
          MemberAccess to member karma
             Type: uint64
             Source: "users[_addr].karma"
            IndexAccess
               Type: struct Karma.User storage ref
               Source: "users[_addr]"
              Identifier users
                 Type: mapping(address => struct Karma.User storage ref)
                 Source: "users"
              Identifier _addr
                 Type: address
                 Source: "_addr"
          Identifier _endowment
             Type: uint64
             Source: "_endowment"
      ExpressionStatement
         Gas costs: 20368
         Source: "users[_addr].username = _username"
        Assignment using operator =
           Type: bytes20
           Source: "users[_addr].username = _username"
          MemberAccess to member username
             Type: bytes20
             Source: "users[_addr].username"
            IndexAccess
               Type: struct Karma.User storage ref
               Source: "users[_addr]"
              Identifier users
                 Type: mapping(address => struct Karma.User storage ref)
                 Source: "users"
              Identifier _addr
                 Type: address
                 Source: "_addr"
          Identifier _username
             Type: bytes20
             Source: "_username"
      ExpressionStatement
         Gas costs: 20363
         Source: "usernames[_username] = _addr"
        Assignment using operator =
           Type: address
           Source: "usernames[_username] = _addr"
          IndexAccess
             Type: address
             Source: "usernames[_username]"
            Identifier usernames
               Type: mapping(bytes20 => address)
               Source: "usernames"
            Identifier _username
               Type: bytes20
               Source: "_username"
          Identifier _addr
             Type: address
             Source: "_addr"
      ExpressionStatement
         Gas costs: 20642
         Source: "newUsers = newUsers.add(1)"
        Assignment using operator =
           Type: uint64
           Source: "newUsers = newUsers.add(1)"
          Identifier newUsers
             Type: uint64
             Source: "newUsers"
          FunctionCall
             Type: uint64
             Source: "newUsers.add(1)"
            MemberAccess to member add
               Type: function (uint64,uint64) pure returns (uint64)
               Source: "newUsers.add"
              Identifier newUsers
                 Type: uint64
                 Source: "newUsers"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: 20253
         Source: "totalSupply = totalSupply.add(_endowment)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = totalSupply.add(_endowment)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "totalSupply.add(_endowment)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "totalSupply.add"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
            Identifier _endowment
               Type: uint64
               Source: "_endowment"
      ExpressionStatement
         Gas costs: [???]
         Source: "NewUser(_addr, _username, _endowment)"
        FunctionCall
           Type: tuple()
           Source: "NewUser(_addr, _username, _endowment)"
          Identifier NewUser
             Type: function (address,bytes20,uint64)
             Source: "NewUser"
          Identifier _addr
             Type: address
             Source: "_addr"
          Identifier _username
             Type: bytes20
             Source: "_username"
          Identifier _endowment
             Type: uint64
             Source: "_endowment"
