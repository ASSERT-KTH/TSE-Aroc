Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x00f90986cdd79744409f8a3c7747064afa4473b5.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.13;"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "sub"
     Source: "function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add"
     Source: "function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "ERC20Basic"
   Gas costs: [???]
   Source: "contract ERC20Basic {\r\n  uint public totalSupply;\r\n  address public owner; //owner\r\n  address public animator; //animator\r\n  function balanceOf(address who) constant returns (uint);\r\n  function transfer(address to, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  function commitDividend(address who) internal; // pays remaining dividend\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint public totalSupply"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "owner"
     Type: address
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "animator"
     Type: address
     Source: "address public animator"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) constant returns (uint);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint value);"
    ParameterList
       Source: "(address to, uint value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "commitDividend"
     Source: "function commitDividend(address who) internal;"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: ""
ContractDefinition "ERC20"
   Gas costs: 0
   Source: "contract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n  function transferFrom(address from, address to, uint value);\r\n  function approve(address spender, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}"
  InheritanceSpecifier
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) constant returns (uint);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint value);"
    ParameterList
       Source: "(address from, address to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint value);"
    ParameterList
       Source: "(address spender, uint value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "BasicToken"
   Source: "contract BasicToken is ERC20Basic {\r\n  using SafeMath for uint;\r\n  mapping(address => uint) balances;\r\n\r\n  modifier onlyPayloadSize(uint size) {\r\n     assert(msg.data.length >= size + 4);\r\n     _;\r\n  }\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\r\n    commitDividend(msg.sender);\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    if(_to == address(this)) {\r\n        commitDividend(owner);\r\n        balances[owner] = balances[owner].add(_value);\r\n        Transfer(msg.sender, owner, _value);\r\n    }\r\n    else {\r\n        commitDividend(_to);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n    }\r\n  }\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint) balances"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  ModifierDefinition "onlyPayloadSize"
     Source: "modifier onlyPayloadSize(uint size) {\r\n     assert(msg.data.length >= size + 4);\r\n     _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint size)"
      VariableDeclaration "size"
         Type: uint256
         Source: "uint size"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n     assert(msg.data.length >= size + 4);\r\n     _;\r\n  }"
      ExpressionStatement
         Gas costs: 90
         Source: "assert(msg.data.length >= size + 4)"
        FunctionCall
           Type: tuple()
           Source: "assert(msg.data.length >= size + 4)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.data.length >= size + 4"
            MemberAccess to member length
               Type: uint256
               Source: "msg.data.length"
              MemberAccess to member data
                 Type: bytes calldata
                 Source: "msg.data"
                Identifier msg
                   Type: msg
                   Source: "msg"
            BinaryOperation using operator +
               Type: uint256
               Source: "size + 4"
              Identifier size
                 Type: uint256
                 Source: "size"
              Literal, token: [no token] value: 4
                 Type: int_const 4
                 Source: "4"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\r\n    commitDividend(msg.sender);\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    if(_to == address(this)) {\r\n        commitDividend(owner);\r\n        balances[owner] = balances[owner].add(_value);\r\n        Transfer(msg.sender, owner, _value);\r\n    }\r\n    else {\r\n        commitDividend(_to);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 3
       Source: "onlyPayloadSize(2 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 64
         Source: "2 * 32"
        Literal, token: [no token] value: 2
           Type: int_const 2
           Source: "2"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n    commitDividend(msg.sender);\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    if(_to == address(this)) {\r\n        commitDividend(owner);\r\n        balances[owner] = balances[owner].add(_value);\r\n        Transfer(msg.sender, owner, _value);\r\n    }\r\n    else {\r\n        commitDividend(_to);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n    }\r\n  }"
      ExpressionStatement
         Gas costs: 17
         Source: "commitDividend(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "commitDividend(msg.sender)"
          Identifier commitDividend
             Type: function (address)
             Source: "commitDividend"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20437
         Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "balances[msg.sender].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) returns (uint256)
               Source: "balances[msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      IfStatement
         Source: "if(_to == address(this)) {\r\n        commitDividend(owner);\r\n        balances[owner] = balances[owner].add(_value);\r\n        Transfer(msg.sender, owner, _value);\r\n    }\r\n    else {\r\n        commitDividend(_to);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n    }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 20
           Source: "_to == address(this)"
          Identifier _to
             Type: address
             Source: "_to"
          FunctionCall
             Type: address
             Source: "address(this)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier this
               Type: contract BasicToken
               Source: "this"
        Block
           Source: "{\r\n        commitDividend(owner);\r\n        balances[owner] = balances[owner].add(_value);\r\n        Transfer(msg.sender, owner, _value);\r\n    }"
          ExpressionStatement
             Gas costs: 254
             Source: "commitDividend(owner)"
            FunctionCall
               Type: tuple()
               Source: "commitDividend(owner)"
              Identifier commitDividend
                 Type: function (address)
                 Source: "commitDividend"
              Identifier owner
                 Type: address
                 Source: "owner"
          ExpressionStatement
             Gas costs: 20911
             Source: "balances[owner] = balances[owner].add(_value)"
            Assignment using operator =
               Type: uint256
               Source: "balances[owner] = balances[owner].add(_value)"
              IndexAccess
                 Type: uint256
                 Source: "balances[owner]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier owner
                   Type: address
                   Source: "owner"
              FunctionCall
                 Type: uint256
                 Source: "balances[owner].add(_value)"
                MemberAccess to member add
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "balances[owner].add"
                  IndexAccess
                     Type: uint256
                     Source: "balances[owner]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    Identifier owner
                       Type: address
                       Source: "owner"
                Identifier _value
                   Type: uint256
                   Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(msg.sender, owner, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(msg.sender, owner, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier owner
                 Type: address
                 Source: "owner"
              Identifier _value
                 Type: uint256
                 Source: "_value"
        Block
           Source: "{\r\n        commitDividend(_to);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n    }"
          ExpressionStatement
             Gas costs: 18
             Source: "commitDividend(_to)"
            FunctionCall
               Type: tuple()
               Source: "commitDividend(_to)"
              Identifier commitDividend
                 Type: function (address)
                 Source: "commitDividend"
              Identifier _to
                 Type: address
                 Source: "_to"
          ExpressionStatement
             Gas costs: 20439
             Source: "balances[_to] = balances[_to].add(_value)"
            Assignment using operator =
               Type: uint256
               Source: "balances[_to] = balances[_to].add(_value)"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              FunctionCall
                 Type: uint256
                 Source: "balances[_to].add(_value)"
                MemberAccess to member add
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "balances[_to].add"
                  IndexAccess
                     Type: uint256
                     Source: "balances[_to]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    Identifier _to
                       Type: address
                       Source: "_to"
                Identifier _value
                   Type: uint256
                   Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(msg.sender, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(msg.sender, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint balance"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return balances[_owner];\r\n  }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is BasicToken, ERC20 {\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint the amout of tokens to be transfered\r\n   */\r\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n    commitDividend(_from);\r\n    commitDividend(_to);\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n  /**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint _value) {\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n  /**\r\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint specifing the amount of tokens still avaible for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "BasicToken"
    UserDefinedTypeName "BasicToken"
       Source: "BasicToken"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n    commitDividend(_from);\r\n    commitDividend(_to);\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 3
       Source: "onlyPayloadSize(3 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 96
         Source: "3 * 32"
        Literal, token: [no token] value: 3
           Type: int_const 3
           Source: "3"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n    var _allowance = allowed[_from][msg.sender];\r\n    commitDividend(_from);\r\n    commitDividend(_to);\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }"
      VariableDeclarationStatement
         Gas costs: 396
         Source: "var _allowance = allowed[_from][msg.sender]"
        VariableDeclaration "_allowance"
           Type: uint256
           Source: "var _allowance"
        IndexAccess
           Type: uint256
           Source: "allowed[_from][msg.sender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_from]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _from
               Type: address
               Source: "_from"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 7
         Source: "commitDividend(_from)"
        FunctionCall
           Type: tuple()
           Source: "commitDividend(_from)"
          Identifier commitDividend
             Type: function (address)
             Source: "commitDividend"
          Identifier _from
             Type: address
             Source: "_from"
      ExpressionStatement
         Gas costs: 18
         Source: "commitDividend(_to)"
        FunctionCall
           Type: tuple()
           Source: "commitDividend(_to)"
          Identifier commitDividend
             Type: function (address)
             Source: "commitDividend"
          Identifier _to
             Type: address
             Source: "_to"
      ExpressionStatement
         Gas costs: 20439
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20433
         Source: "balances[_from] = balances[_from].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_from] = balances[_from].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "balances[_from].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) returns (uint256)
               Source: "balances[_from].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20232
         Source: "allowed[_from][msg.sender] = _allowance.sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[_from][msg.sender] = _allowance.sub(_value)"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "_allowance.sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) returns (uint256)
               Source: "_allowance.sub"
              Identifier _allowance
                 Type: uint256
                 Source: "_allowance"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint _value) {\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }"
      ExpressionStatement
         Gas costs: 454
         Source: "assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)))"
        FunctionCall
           Type: tuple()
           Source: "assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!((_value != 0) && (allowed[msg.sender][_spender] != 0))"
            TupleExpression
               Type: bool
               Source: "((_value != 0) && (allowed[msg.sender][_spender] != 0))"
              BinaryOperation using operator &&
                 Type: bool
                 Source: "(_value != 0) && (allowed[msg.sender][_spender] != 0)"
                TupleExpression
                   Type: bool
                   Source: "(_value != 0)"
                  BinaryOperation using operator !=
                     Type: bool
                     Source: "_value != 0"
                    Identifier _value
                       Type: uint256
                       Source: "_value"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                TupleExpression
                   Type: bool
                   Source: "(allowed[msg.sender][_spender] != 0)"
                  BinaryOperation using operator !=
                     Type: bool
                     Source: "allowed[msg.sender][_spender] != 0"
                    IndexAccess
                       Type: uint256
                       Source: "allowed[msg.sender][_spender]"
                      IndexAccess
                         Type: mapping(address => uint256)
                         Source: "allowed[msg.sender]"
                        Identifier allowed
                           Type: mapping(address => mapping(address => uint256))
                           Source: "allowed"
                        MemberAccess to member sender
                           Type: address
                           Source: "msg.sender"
                          Identifier msg
                             Type: msg
                             Source: "msg"
                      Identifier _spender
                         Type: address
                         Source: "_spender"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint remaining"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return allowed[_owner][_spender];\r\n  }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
ContractDefinition "SmartBillions"
   Source: "contract SmartBillions is StandardToken {\r\n\r\n    // metadata\r\n    string public constant name = \"SmartBillions Token\";\r\n    string public constant symbol = \"PLAY\";\r\n    uint public constant decimals = 0;\r\n\r\n    // contract state\r\n    struct Wallet {\r\n        uint208 balance; // current balance of user\r\n    \tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\r\n    \tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\r\n    }\r\n    mapping (address => Wallet) wallets;\r\n    struct Bet {\r\n        uint192 value; // bet size\r\n        uint32 betHash; // selected numbers\r\n        uint32 blockNum; // blocknumber when lottery runs\r\n    }\r\n    mapping (address => Bet) bets;\r\n\r\n    uint public walletBalance = 0; // sum of funds in wallets\r\n\r\n    // investment parameters\r\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\r\n    uint public investBalance = 0; // funding from investors\r\n    uint public investBalanceMax = 200000 ether; // maximum funding\r\n    uint public dividendPeriod = 1;\r\n    uint[] public dividends; // dividens collected per period, growing array\r\n\r\n    // betting parameters\r\n    uint public maxWin = 0; // maximum prize won\r\n    uint public hashFirst = 0; // start time of building hashes database\r\n    uint public hashLast = 0; // last saved block of hashes\r\n    uint public hashNext = 0; // next available bet block.number\r\n    uint public hashBetSum = 0; // used bet volume of next block\r\n    uint public hashBetMax = 5 ether; // maximum bet size per block\r\n    uint[] public hashes; // space for storing lottery results\r\n\r\n    // constants\r\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\r\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\r\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\r\n\r\n    // events\r\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\r\n    event LogLoss(address indexed player, uint bethash, uint hash);\r\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\r\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\r\n    event LogRecordWin(address indexed player, uint amount);\r\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\r\n    //event LogWithdraw(address indexed who, uint amount);\r\n\r\n    modifier onlyOwner() {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAnimator() {\r\n        assert(msg.sender == animator);\r\n        _;\r\n    }\r\n\r\n    // constructor\r\n    function SmartBillions() {\r\n        owner = msg.sender;\r\n        animator = msg.sender;\r\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\r\n        //wallets[animator].lastDividendPeriod = uint16(dividendPeriod);\r\n        dividends.push(0); // not used\r\n        dividends.push(0); // current dividend\r\n    }\r\n\r\n/* getters */\r\n    \r\n    /**\r\n     * @dev Show length of allocated swap space\r\n     */\r\n    function hashesLength() constant external returns (uint) {\r\n        return uint(hashes.length);\r\n    }\r\n    \r\n    /**\r\n     * @dev Show balance of wallet\r\n     * @param _owner The address of the account.\r\n     */\r\n    function walletBalanceOf(address _owner) constant external returns (uint) {\r\n        return uint(wallets[_owner].balance);\r\n    }\r\n    \r\n    /**\r\n     * @dev Show last dividend period processed\r\n     * @param _owner The address of the account.\r\n     */\r\n    function walletPeriodOf(address _owner) constant external returns (uint) {\r\n        return uint(wallets[_owner].lastDividendPeriod);\r\n    }\r\n    \r\n    /**\r\n     * @dev Show block number when withdraw can continue\r\n     * @param _owner The address of the account.\r\n     */\r\n    function walletBlockOf(address _owner) constant external returns (uint) {\r\n        return uint(wallets[_owner].nextWithdrawBlock);\r\n    }\r\n    \r\n    /**\r\n     * @dev Show bet size.\r\n     * @param _owner The address of the player.\r\n     */\r\n    function betValueOf(address _owner) constant external returns (uint) {\r\n        return uint(bets[_owner].value);\r\n    }\r\n    \r\n    /**\r\n     * @dev Show block number of lottery run for the bet.\r\n     * @param _owner The address of the player.\r\n     */\r\n    function betHashOf(address _owner) constant external returns (uint) {\r\n        return uint(bets[_owner].betHash);\r\n    }\r\n    \r\n    /**\r\n     * @dev Show block number of lottery run for the bet.\r\n     * @param _owner The address of the player.\r\n     */\r\n    function betBlockNumberOf(address _owner) constant external returns (uint) {\r\n        return uint(bets[_owner].blockNum);\r\n    }\r\n    \r\n    /**\r\n     * @dev Print number of block till next expected dividend payment\r\n     */\r\n    function dividendsBlocks() constant external returns (uint) {\r\n        if(investStart > 0) {\r\n            return(0);\r\n        }\r\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\r\n        if(period > dividendPeriod) {\r\n            return(0);\r\n        }\r\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\r\n    }\r\n\r\n/* administrative functions */\r\n\r\n    /**\r\n     * @dev Change owner.\r\n     * @param _who The address of new owner.\r\n     */\r\n    function changeOwner(address _who) external onlyOwner {\r\n        assert(_who != address(0));\r\n        commitDividend(msg.sender);\r\n        commitDividend(_who);\r\n        owner = _who;\r\n    }\r\n\r\n    /**\r\n     * @dev Change animator.\r\n     * @param _who The address of new animator.\r\n     */\r\n    function changeAnimator(address _who) external onlyAnimator {\r\n        assert(_who != address(0));\r\n        commitDividend(msg.sender);\r\n        commitDividend(_who);\r\n        animator = _who;\r\n    }\r\n\r\n    /**\r\n     * @dev Set ICO Start block.\r\n     * @param _when The block number of the ICO.\r\n     */\r\n    function setInvestStart(uint _when) external onlyOwner {\r\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\r\n        investStart = _when;\r\n    }\r\n\r\n    /**\r\n     * @dev Set maximum bet size per block\r\n     * @param _maxsum The maximum bet size in wei.\r\n     */\r\n    function setBetMax(uint _maxsum) external onlyOwner {\r\n        hashBetMax = _maxsum;\r\n    }\r\n\r\n    /**\r\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\r\n     */\r\n    function resetBet() external onlyOwner {\r\n        hashNext = block.number + 3;\r\n        hashBetSum = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Move funds to cold storage\r\n     * @dev investBalance and walletBalance is protected from withdraw by owner\r\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\r\n     * @param _amount The amount of wei to move to cold storage\r\n     */\r\n    function coldStore(uint _amount) external onlyOwner {\r\n        houseKeeping();\r\n        require(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount);\r\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\r\n            require((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\r\n        }\r\n        msg.sender.transfer(_amount);\r\n        coldStoreLast = block.number;\r\n    }\r\n\r\n    /**\r\n     * @dev Move funds to contract\r\n     */\r\n    function hotStore() payable external { // not needed because jackpot is protected\r\n        houseKeeping();\r\n    }\r\n\r\n/* housekeeping functions */\r\n\r\n    /**\r\n     * @dev Update accounting\r\n     */\r\n    function houseKeeping() public {\r\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\r\n            investStart = 0; // start dividend payments\r\n        }\r\n        else {\r\n            if(hashFirst > 0){\r\n\t\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\r\n                if(period > dividends.length - 2) {\r\n                    dividends.push(0);\r\n                }\r\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\r\n                    dividendPeriod++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n/* payments */\r\n\r\n    /**\r\n     * @dev Pay balance from wallet\r\n     */\r\n    function payWallet() public {\r\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\r\n            uint balance = wallets[msg.sender].balance;\r\n            wallets[msg.sender].balance = 0;\r\n            walletBalance -= balance;\r\n            pay(balance);\r\n            //LogWithdraw(msg.sender,balance);\r\n        }\r\n    }\r\n\r\n    function pay(uint _amount) private {\r\n        uint maxpay = this.balance / 2;\r\n        if(maxpay >= _amount) {\r\n            msg.sender.transfer(_amount);\r\n            if(_amount > 1 finney) {\r\n                houseKeeping();\r\n            }\r\n        }\r\n        else {\r\n            uint keepbalance = _amount - maxpay;\r\n            walletBalance += keepbalance;\r\n            wallets[msg.sender].balance += uint208(keepbalance);\r\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\r\n            msg.sender.transfer(maxpay);\r\n        }\r\n    }\r\n\r\n/* investment functions */\r\n\r\n    /**\r\n     * @dev Buy tokens\r\n     */\r\n    function investDirect() payable external {\r\n        invest(owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Buy tokens with affiliate partner\r\n     * @param _partner Affiliate partner\r\n     */\r\n    function invest(address _partner) payable public {\r\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\r\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\r\n        uint investing = msg.value;\r\n        if(investing > investBalanceMax - investBalance) {\r\n            investing = investBalanceMax - investBalance;\r\n            investBalance = investBalanceMax;\r\n            investStart = 0; // close investment round\r\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\r\n        }\r\n        else{\r\n            investBalance += investing;\r\n        }\r\n        if(_partner == address(0) || _partner == owner){\r\n            walletBalance += investing / 10;\r\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\r\n        else{\r\n            walletBalance += (investing * 5 / 100) * 2;\r\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\r\n            //wallets[_partner].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\r\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\r\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\r\n        uint senderBalance = investing / 10**15;\r\n        uint ownerBalance = investing * 16 / 10**17  ;\r\n        uint animatorBalance = investing * 10 / 10**17  ;\r\n        balances[msg.sender] += senderBalance;\r\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\r\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\r\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\r\n        Transfer(address(0),msg.sender,senderBalance); // for etherscan\r\n        Transfer(address(0),owner,ownerBalance); // for etherscan\r\n        Transfer(address(0),animator,animatorBalance); // for etherscan\r\n        LogInvestment(msg.sender,_partner,investing);\r\n    }\r\n\r\n    /**\r\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\r\n     */\r\n    function disinvest() external {\r\n        require(investStart == 0);\r\n        commitDividend(msg.sender);\r\n        uint initialInvestment = balances[msg.sender] * 10**15;\r\n        Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\r\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\r\n        investBalance -= initialInvestment;\r\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\r\n        payWallet();\r\n    }\r\n\r\n    /**\r\n     * @dev Pay unpaid dividends\r\n     */\r\n    function payDividends() external {\r\n        require(investStart == 0);\r\n        commitDividend(msg.sender);\r\n        payWallet();\r\n    }\r\n\r\n    /**\r\n     * @dev Commit remaining dividends before transfer of tokens\r\n     */\r\n    function commitDividend(address _who) internal {\r\n        uint last = wallets[_who].lastDividendPeriod;\r\n        if((balances[_who]==0) || (last==0)){\r\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\r\n            return;\r\n        }\r\n        if(last==dividendPeriod) {\r\n            return;\r\n        }\r\n        uint share = balances[_who] * 0xffffffff / totalSupply;\r\n        uint balance = 0;\r\n        for(;last<dividendPeriod;last++) {\r\n            balance += share * dividends[last];\r\n        }\r\n        balance = (balance / 0xffffffff);\r\n        walletBalance += balance;\r\n        wallets[_who].balance += uint208(balance);\r\n        wallets[_who].lastDividendPeriod = uint16(last);\r\n    }\r\n\r\n/* lottery functions */\r\n\r\n    function betPrize(Bet _player, uint24 _hash) constant private returns (uint) { // house fee 13.85%\r\n        uint24 bethash = uint24(_player.betHash);\r\n        uint24 hit = bethash ^ _hash;\r\n        uint24 matches =\r\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\r\n        if(matches == 6){\r\n            return(uint(_player.value) * 7000000);\r\n        }\r\n        if(matches == 5){\r\n            return(uint(_player.value) * 20000);\r\n        }\r\n        if(matches == 4){\r\n            return(uint(_player.value) * 500);\r\n        }\r\n        if(matches == 3){\r\n            return(uint(_player.value) * 25);\r\n        }\r\n        if(matches == 2){\r\n            return(uint(_player.value) * 3);\r\n        }\r\n        return(0);\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if won in lottery\r\n     */\r\n    function betOf(address _who) constant external returns (uint)  {\r\n        Bet memory player = bets[_who];\r\n        if( (player.value==0) ||\r\n            (player.blockNum<=1) ||\r\n            (block.number<player.blockNum) ||\r\n            (block.number>=player.blockNum + (10 * hashesSize))){\r\n            return(0);\r\n        }\r\n        if(block.number<player.blockNum+256){\r\n            return(betPrize(player,uint24(block.blockhash(player.blockNum))));\r\n        }\r\n        if(hashFirst>0){\r\n            uint32 hash = getHash(player.blockNum);\r\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                return(uint(player.value));\r\n            }\r\n            else{\r\n                return(betPrize(player,uint24(hash)));\r\n            }\r\n\t}\r\n        return(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if won in lottery\r\n     */\r\n    function won() public {\r\n        Bet memory player = bets[msg.sender];\r\n        if(player.blockNum==0){ // create a new player\r\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n            return;\r\n        }\r\n        if((player.value==0) || (player.blockNum==1)){\r\n            payWallet();\r\n            return;\r\n        }\r\n        require(block.number>player.blockNum); // if there is an active bet, throw()\r\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\r\n            LogLate(msg.sender,player.blockNum,block.number);\r\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n            return;\r\n        }\r\n        uint prize = 0;\r\n        uint32 hash = 0;\r\n        if(block.number<player.blockNum+256){\r\n            hash = uint24(block.blockhash(player.blockNum));\r\n            prize = betPrize(player,uint24(hash));\r\n        }\r\n        else {\r\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\r\n                hash = getHash(player.blockNum);\r\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                    prize = uint(player.value);\r\n                }\r\n                else{\r\n                    prize = betPrize(player,uint24(hash));\r\n                }\r\n\t    }\r\n            else{\r\n                LogLate(msg.sender,player.blockNum,block.number);\r\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n                return();\r\n            }\r\n        }\r\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n        if(prize>0) {\r\n            LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\r\n            if(prize > maxWin){\r\n                maxWin = prize;\r\n                LogRecordWin(msg.sender,prize);\r\n            }\r\n            pay(prize);\r\n        }\r\n        else{\r\n            LogLoss(msg.sender,uint(player.betHash),uint(hash));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Send less than 1 ether to contract to play or send 0 to retrieve funds\r\n     */\r\n    function () payable external {\r\n        if(msg.value > 0){\r\n            play();\r\n            return;\r\n        }\r\n        //check for dividends and other assets\r\n        if(investStart == 0 && balances[msg.sender]>0){\r\n            commitDividend(msg.sender);}\r\n        won(); // will run payWallet() if nothing else available\r\n    }\r\n\r\n    /**\r\n     * @dev Play in lottery\r\n     */\r\n    function play() payable public returns (uint) {\r\n        return playSystem(uint(sha3(msg.sender,block.number)), address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Play in lottery with random numbers\r\n     * @param _partner Affiliate partner\r\n     */\r\n    function playRandom(address _partner) payable public returns (uint) {\r\n        return playSystem(uint(sha3(msg.sender,block.number)), _partner);\r\n    }\r\n\r\n    //function playSystem(uint8 num1, uint8 num2, uint8 num3, address _partner) payable public returns (uint) {\r\n    //    return playHash(uint24(num1)|(uint24(num2)<<8)|(uint24(num3)<<16), _partner);\r\n    //}\r\n    \r\n    /**\r\n     * @dev Play in lottery with own numbers\r\n     * @param _partner Affiliate partner\r\n     */\r\n    function playSystem(uint _hash, address _partner) payable public returns (uint) {\r\n        won(); // check if player did not win \r\n        uint24 bethash = uint24(_hash);\r\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\r\n        if(msg.value > 0){\r\n            if(investStart==0) { // dividends only after investment finished\r\n                dividends[dividendPeriod] += msg.value / 34; // 3% dividend\r\n            }\r\n            if(_partner != address(0)) {\r\n                uint fee = msg.value / 100;\r\n                walletBalance += fee;\r\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\r\n            }\r\n            if(hashNext < block.number + 3) {\r\n                hashNext = block.number + 3;\r\n                hashBetSum = msg.value;\r\n            }\r\n            else{\r\n                if(hashBetSum > hashBetMax) {\r\n                    hashNext++;\r\n                    hashBetSum = msg.value;\r\n                }\r\n                else{\r\n                    hashBetSum += msg.value;\r\n                }\r\n            }\r\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\r\n            LogBet(msg.sender,uint(bethash),hashNext,msg.value);\r\n        }\r\n        putHash(); // players help collecing data\r\n        return(hashNext);\r\n    }\r\n\r\n/* database functions */\r\n\r\n    /**\r\n     * @dev Create hash data swap space\r\n     * @param _sadd Number of hashes to add (<=256)\r\n     */\r\n    function addHashes(uint _sadd) public returns (uint) {\r\n        require(hashes.length + _sadd<=hashesSize);\r\n        uint n = hashes.length;\r\n        hashes.length += _sadd;\r\n        for(;n<hashes.length;n++){ // make sure to burn gas\r\n            hashes[n] = 1;\r\n        }\r\n        if(hashes.length>=hashesSize) { // assume block.number > 10\r\n            hashFirst = block.number - ( block.number % 10);\r\n            hashLast = hashFirst;\r\n        }\r\n        return(hashes.length);\r\n    }\r\n\r\n    /**\r\n     * @dev Create hash data swap space, add 128 hashes\r\n     */\r\n    function addHashes128() external returns (uint) {\r\n        return(addHashes(128));\r\n    }\r\n\r\n    function calcHashes(uint32 _lastb, uint32 _delta) constant private returns (uint) {\r\n        return( ( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\r\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\r\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\r\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\r\n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\r\n            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\r\n            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\r\n            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\r\n            | ( ( uint(_delta) / hashesSize) << 240)); \r\n    }\r\n\r\n    function getHash(uint _block) constant private returns (uint32) {\r\n        uint delta = (_block - hashFirst) / 10;\r\n        uint hash = hashes[delta % hashesSize];\r\n        if(delta / hashesSize != hash >> 240) {\r\n            return(0x1000000); // load failed, incorrect data in hashes\r\n        }\r\n        uint slotp = (_block - hashFirst) % 10; \r\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\r\n    }\r\n    \r\n    /**\r\n     * @dev Fill hash data\r\n     */\r\n    function putHash() public returns (bool) {\r\n        uint lastb = hashLast;\r\n        if(lastb == 0 || block.number <= lastb + 10) {\r\n            return(false);\r\n        }\r\n        uint blockn256;\r\n        if(block.number<256) { // useless test for testnet :-(\r\n            blockn256 = 0;\r\n        }\r\n        else{\r\n            blockn256 = block.number - 256;\r\n        }\r\n        if(lastb < blockn256) {\r\n            uint num = blockn256;\r\n            num += num % 10;\r\n            lastb = num; \r\n        }\r\n        uint delta = (lastb - hashFirst) / 10;\r\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\r\n        hashLast = lastb + 10;\r\n        return(true);\r\n    }\r\n\r\n    /**\r\n     * @dev Fill hash data many times\r\n     * @param _num Number of iterations\r\n     */\r\n    function putHashes(uint _num) external {\r\n        uint n=0;\r\n        for(;n<_num;n++){\r\n            if(!putHash()){\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    \r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  VariableDeclaration "name"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant name = \"SmartBillions Token\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: SmartBillions Token
       Type: literal_string "SmartBillions Token"
       Source: "\"SmartBillions Token\""
  VariableDeclaration "symbol"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant symbol = \"PLAY\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: PLAY
       Type: literal_string "PLAY"
       Source: "\"PLAY\""
  VariableDeclaration "decimals"
     Type: uint256
     Gas costs: [???]
     Source: "uint public constant decimals = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  StructDefinition "Wallet"
     Gas costs: 0
     Source: "struct Wallet {\r\n        uint208 balance; // current balance of user\r\n    \tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\r\n    \tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\r\n    }"
    VariableDeclaration "balance"
       Type: uint208
       Source: "uint208 balance"
      ElementaryTypeName uint208
         Source: "uint208"
    VariableDeclaration "lastDividendPeriod"
       Type: uint16
       Source: "uint16 lastDividendPeriod"
      ElementaryTypeName uint16
         Source: "uint16"
    VariableDeclaration "nextWithdrawBlock"
       Type: uint32
       Source: "uint32 nextWithdrawBlock"
      ElementaryTypeName uint32
         Source: "uint32"
  VariableDeclaration "wallets"
     Type: mapping(address => struct SmartBillions.Wallet storage ref)
     Gas costs: 0
     Source: "mapping (address => Wallet) wallets"
    Mapping
       Source: "mapping (address => Wallet)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "Wallet"
         Source: "Wallet"
  StructDefinition "Bet"
     Gas costs: 0
     Source: "struct Bet {\r\n        uint192 value; // bet size\r\n        uint32 betHash; // selected numbers\r\n        uint32 blockNum; // blocknumber when lottery runs\r\n    }"
    VariableDeclaration "value"
       Type: uint192
       Source: "uint192 value"
      ElementaryTypeName uint192
         Source: "uint192"
    VariableDeclaration "betHash"
       Type: uint32
       Source: "uint32 betHash"
      ElementaryTypeName uint32
         Source: "uint32"
    VariableDeclaration "blockNum"
       Type: uint32
       Source: "uint32 blockNum"
      ElementaryTypeName uint32
         Source: "uint32"
  VariableDeclaration "bets"
     Type: mapping(address => struct SmartBillions.Bet storage ref)
     Gas costs: 0
     Source: "mapping (address => Bet) bets"
    Mapping
       Source: "mapping (address => Bet)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "Bet"
         Source: "Bet"
  VariableDeclaration "walletBalance"
     Type: uint256
     Gas costs: [???]
     Source: "uint public walletBalance = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "investStart"
     Type: uint256
     Gas costs: [???]
     Source: "uint public investStart = 1"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1
       Type: int_const 1
       Source: "1"
  VariableDeclaration "investBalance"
     Type: uint256
     Gas costs: [???]
     Source: "uint public investBalance = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "investBalanceMax"
     Type: uint256
     Gas costs: [???]
     Source: "uint public investBalanceMax = 200000 ether"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 200000
       Type: int_const 200000000000000000000000
       Source: "200000 ether"
  VariableDeclaration "dividendPeriod"
     Type: uint256
     Gas costs: [???]
     Source: "uint public dividendPeriod = 1"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1
       Type: int_const 1
       Source: "1"
  VariableDeclaration "dividends"
     Type: uint256[] storage ref
     Gas costs: [???]
     Source: "uint[] public dividends"
    ArrayTypeName
       Source: "uint[]"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "maxWin"
     Type: uint256
     Gas costs: [???]
     Source: "uint public maxWin = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "hashFirst"
     Type: uint256
     Gas costs: [???]
     Source: "uint public hashFirst = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "hashLast"
     Type: uint256
     Gas costs: [???]
     Source: "uint public hashLast = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "hashNext"
     Type: uint256
     Gas costs: [???]
     Source: "uint public hashNext = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "hashBetSum"
     Type: uint256
     Gas costs: [???]
     Source: "uint public hashBetSum = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "hashBetMax"
     Type: uint256
     Gas costs: [???]
     Source: "uint public hashBetMax = 5 ether"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 5
       Type: int_const 5000000000000000000
       Source: "5 ether"
  VariableDeclaration "hashes"
     Type: uint256[] storage ref
     Gas costs: [???]
     Source: "uint[] public hashes"
    ArrayTypeName
       Source: "uint[]"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "hashesSize"
     Type: uint256
     Gas costs: [???]
     Source: "uint public constant hashesSize = 16384"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 16384
       Type: int_const 16384
       Source: "16384"
  VariableDeclaration "coldStoreLast"
     Type: uint256
     Gas costs: [???]
     Source: "uint public coldStoreLast = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  EventDefinition "LogBet"
     Gas costs: 0
     Source: "event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);"
    ParameterList
       Source: "(address indexed player, uint bethash, uint blocknumber, uint betsize)"
      VariableDeclaration "player"
         Type: address
         Source: "address indexed player"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "bethash"
         Type: uint256
         Source: "uint bethash"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "blocknumber"
         Type: uint256
         Source: "uint blocknumber"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "betsize"
         Type: uint256
         Source: "uint betsize"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LogLoss"
     Gas costs: 0
     Source: "event LogLoss(address indexed player, uint bethash, uint hash);"
    ParameterList
       Source: "(address indexed player, uint bethash, uint hash)"
      VariableDeclaration "player"
         Type: address
         Source: "address indexed player"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "bethash"
         Type: uint256
         Source: "uint bethash"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "hash"
         Type: uint256
         Source: "uint hash"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LogWin"
     Gas costs: 0
     Source: "event LogWin(address indexed player, uint bethash, uint hash, uint prize);"
    ParameterList
       Source: "(address indexed player, uint bethash, uint hash, uint prize)"
      VariableDeclaration "player"
         Type: address
         Source: "address indexed player"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "bethash"
         Type: uint256
         Source: "uint bethash"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "hash"
         Type: uint256
         Source: "uint hash"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "prize"
         Type: uint256
         Source: "uint prize"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LogInvestment"
     Gas costs: 0
     Source: "event LogInvestment(address indexed investor, address indexed partner, uint amount);"
    ParameterList
       Source: "(address indexed investor, address indexed partner, uint amount)"
      VariableDeclaration "investor"
         Type: address
         Source: "address indexed investor"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "partner"
         Type: address
         Source: "address indexed partner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LogRecordWin"
     Gas costs: 0
     Source: "event LogRecordWin(address indexed player, uint amount);"
    ParameterList
       Source: "(address indexed player, uint amount)"
      VariableDeclaration "player"
         Type: address
         Source: "address indexed player"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LogLate"
     Gas costs: 0
     Source: "event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);"
    ParameterList
       Source: "(address indexed player,uint playerBlockNumber,uint currentBlockNumber)"
      VariableDeclaration "player"
         Type: address
         Source: "address indexed player"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "playerBlockNumber"
         Type: uint256
         Source: "uint playerBlockNumber"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "currentBlockNumber"
         Type: uint256
         Source: "uint currentBlockNumber"
        ElementaryTypeName uint
           Source: "uint"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 1380
         Source: "assert(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "assert(msg.sender == owner)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyAnimator"
     Source: "modifier onlyAnimator() {\r\n        assert(msg.sender == animator);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        assert(msg.sender == animator);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 276
         Source: "assert(msg.sender == animator)"
        FunctionCall
           Type: tuple()
           Source: "assert(msg.sender == animator)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == animator"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier animator
               Type: address
               Source: "animator"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "SmartBillions" - public
     Source: "function SmartBillions() {\r\n        owner = msg.sender;\r\n        animator = msg.sender;\r\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\r\n        //wallets[animator].lastDividendPeriod = uint16(dividendPeriod);\r\n        dividends.push(0); // not used\r\n        dividends.push(0); // current dividend\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = msg.sender;\r\n        animator = msg.sender;\r\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\r\n        //wallets[animator].lastDividendPeriod = uint16(dividendPeriod);\r\n        dividends.push(0); // not used\r\n        dividends.push(0); // current dividend\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "animator = msg.sender"
        Assignment using operator =
           Type: address
           Source: "animator = msg.sender"
          Identifier animator
             Type: address
             Source: "animator"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "wallets[owner].lastDividendPeriod = uint16(dividendPeriod)"
        Assignment using operator =
           Type: uint16
           Source: "wallets[owner].lastDividendPeriod = uint16(dividendPeriod)"
          MemberAccess to member lastDividendPeriod
             Type: uint16
             Source: "wallets[owner].lastDividendPeriod"
            IndexAccess
               Type: struct SmartBillions.Wallet storage ref
               Source: "wallets[owner]"
              Identifier wallets
                 Type: mapping(address => struct SmartBillions.Wallet storage ref)
                 Source: "wallets"
              Identifier owner
                 Type: address
                 Source: "owner"
          FunctionCall
             Type: uint16
             Source: "uint16(dividendPeriod)"
            ElementaryTypeNameExpression uint16
               Type: type(uint16)
               Source: "uint16"
            Identifier dividendPeriod
               Type: uint256
               Source: "dividendPeriod"
      ExpressionStatement
         Gas costs: 0
         Source: "dividends.push(0)"
        FunctionCall
           Type: uint256
           Source: "dividends.push(0)"
          MemberAccess to member push
             Type: function (uint256) returns (uint256)
             Source: "dividends.push"
            Identifier dividends
               Type: uint256[] storage ref
               Source: "dividends"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "dividends.push(0)"
        FunctionCall
           Type: uint256
           Source: "dividends.push(0)"
          MemberAccess to member push
             Type: function (uint256) returns (uint256)
             Source: "dividends.push"
            Identifier dividends
               Type: uint256[] storage ref
               Source: "dividends"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "hashesLength" - public - const
     Source: "function hashesLength() constant external returns (uint) {\r\n        return uint(hashes.length);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return uint(hashes.length);\r\n    }"
      Return
         Gas costs: 216
         Source: "return uint(hashes.length)"
        FunctionCall
           Type: uint256
           Source: "uint(hashes.length)"
          ElementaryTypeNameExpression uint
             Type: type(uint256)
             Source: "uint"
          MemberAccess to member length
             Type: uint256
             Source: "hashes.length"
            Identifier hashes
               Type: uint256[] storage ref
               Source: "hashes"
  FunctionDefinition "walletBalanceOf" - public - const
     Source: "function walletBalanceOf(address _owner) constant external returns (uint) {\r\n        return uint(wallets[_owner].balance);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return uint(wallets[_owner].balance);\r\n    }"
      Return
         Gas costs: 352
         Source: "return uint(wallets[_owner].balance)"
        FunctionCall
           Type: uint256
           Source: "uint(wallets[_owner].balance)"
          ElementaryTypeNameExpression uint
             Type: type(uint256)
             Source: "uint"
          MemberAccess to member balance
             Type: uint208
             Source: "wallets[_owner].balance"
            IndexAccess
               Type: struct SmartBillions.Wallet storage ref
               Source: "wallets[_owner]"
              Identifier wallets
                 Type: mapping(address => struct SmartBillions.Wallet storage ref)
                 Source: "wallets"
              Identifier _owner
                 Type: address
                 Source: "_owner"
  FunctionDefinition "walletPeriodOf" - public - const
     Source: "function walletPeriodOf(address _owner) constant external returns (uint) {\r\n        return uint(wallets[_owner].lastDividendPeriod);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return uint(wallets[_owner].lastDividendPeriod);\r\n    }"
      Return
         Gas costs: 402
         Source: "return uint(wallets[_owner].lastDividendPeriod)"
        FunctionCall
           Type: uint256
           Source: "uint(wallets[_owner].lastDividendPeriod)"
          ElementaryTypeNameExpression uint
             Type: type(uint256)
             Source: "uint"
          MemberAccess to member lastDividendPeriod
             Type: uint16
             Source: "wallets[_owner].lastDividendPeriod"
            IndexAccess
               Type: struct SmartBillions.Wallet storage ref
               Source: "wallets[_owner]"
              Identifier wallets
                 Type: mapping(address => struct SmartBillions.Wallet storage ref)
                 Source: "wallets"
              Identifier _owner
                 Type: address
                 Source: "_owner"
  FunctionDefinition "walletBlockOf" - public - const
     Source: "function walletBlockOf(address _owner) constant external returns (uint) {\r\n        return uint(wallets[_owner].nextWithdrawBlock);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return uint(wallets[_owner].nextWithdrawBlock);\r\n    }"
      Return
         Gas costs: 402
         Source: "return uint(wallets[_owner].nextWithdrawBlock)"
        FunctionCall
           Type: uint256
           Source: "uint(wallets[_owner].nextWithdrawBlock)"
          ElementaryTypeNameExpression uint
             Type: type(uint256)
             Source: "uint"
          MemberAccess to member nextWithdrawBlock
             Type: uint32
             Source: "wallets[_owner].nextWithdrawBlock"
            IndexAccess
               Type: struct SmartBillions.Wallet storage ref
               Source: "wallets[_owner]"
              Identifier wallets
                 Type: mapping(address => struct SmartBillions.Wallet storage ref)
                 Source: "wallets"
              Identifier _owner
                 Type: address
                 Source: "_owner"
  FunctionDefinition "betValueOf" - public - const
     Source: "function betValueOf(address _owner) constant external returns (uint) {\r\n        return uint(bets[_owner].value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return uint(bets[_owner].value);\r\n    }"
      Return
         Gas costs: 352
         Source: "return uint(bets[_owner].value)"
        FunctionCall
           Type: uint256
           Source: "uint(bets[_owner].value)"
          ElementaryTypeNameExpression uint
             Type: type(uint256)
             Source: "uint"
          MemberAccess to member value
             Type: uint192
             Source: "bets[_owner].value"
            IndexAccess
               Type: struct SmartBillions.Bet storage ref
               Source: "bets[_owner]"
              Identifier bets
                 Type: mapping(address => struct SmartBillions.Bet storage ref)
                 Source: "bets"
              Identifier _owner
                 Type: address
                 Source: "_owner"
  FunctionDefinition "betHashOf" - public - const
     Source: "function betHashOf(address _owner) constant external returns (uint) {\r\n        return uint(bets[_owner].betHash);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return uint(bets[_owner].betHash);\r\n    }"
      Return
         Gas costs: 402
         Source: "return uint(bets[_owner].betHash)"
        FunctionCall
           Type: uint256
           Source: "uint(bets[_owner].betHash)"
          ElementaryTypeNameExpression uint
             Type: type(uint256)
             Source: "uint"
          MemberAccess to member betHash
             Type: uint32
             Source: "bets[_owner].betHash"
            IndexAccess
               Type: struct SmartBillions.Bet storage ref
               Source: "bets[_owner]"
              Identifier bets
                 Type: mapping(address => struct SmartBillions.Bet storage ref)
                 Source: "bets"
              Identifier _owner
                 Type: address
                 Source: "_owner"
  FunctionDefinition "betBlockNumberOf" - public - const
     Source: "function betBlockNumberOf(address _owner) constant external returns (uint) {\r\n        return uint(bets[_owner].blockNum);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return uint(bets[_owner].blockNum);\r\n    }"
      Return
         Gas costs: 402
         Source: "return uint(bets[_owner].blockNum)"
        FunctionCall
           Type: uint256
           Source: "uint(bets[_owner].blockNum)"
          ElementaryTypeNameExpression uint
             Type: type(uint256)
             Source: "uint"
          MemberAccess to member blockNum
             Type: uint32
             Source: "bets[_owner].blockNum"
            IndexAccess
               Type: struct SmartBillions.Bet storage ref
               Source: "bets[_owner]"
              Identifier bets
                 Type: mapping(address => struct SmartBillions.Bet storage ref)
                 Source: "bets"
              Identifier _owner
                 Type: address
                 Source: "_owner"
  FunctionDefinition "dividendsBlocks" - public - const
     Source: "function dividendsBlocks() constant external returns (uint) {\r\n        if(investStart > 0) {\r\n            return(0);\r\n        }\r\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\r\n        if(period > dividendPeriod) {\r\n            return(0);\r\n        }\r\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if(investStart > 0) {\r\n            return(0);\r\n        }\r\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\r\n        if(period > dividendPeriod) {\r\n            return(0);\r\n        }\r\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\r\n    }"
      IfStatement
         Source: "if(investStart > 0) {\r\n            return(0);\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "investStart > 0"
          Identifier investStart
             Type: uint256
             Source: "investStart"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            return(0);\r\n        }"
          Return
             Gas costs: 19
             Source: "return(0)"
            TupleExpression
               Type: int_const 0
               Source: "(0)"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      VariableDeclarationStatement
         Gas costs: 252
         Source: "uint period = (block.number - hashFirst) / (10 * hashesSize)"
        VariableDeclaration "period"
           Type: uint256
           Source: "uint period"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "(block.number - hashFirst) / (10 * hashesSize)"
          TupleExpression
             Type: uint256
             Source: "(block.number - hashFirst)"
            BinaryOperation using operator -
               Type: uint256
               Source: "block.number - hashFirst"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              Identifier hashFirst
                 Type: uint256
                 Source: "hashFirst"
          TupleExpression
             Type: uint256
             Source: "(10 * hashesSize)"
            BinaryOperation using operator *
               Type: uint256
               Source: "10 * hashesSize"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Identifier hashesSize
                 Type: uint256
                 Source: "hashesSize"
      IfStatement
         Source: "if(period > dividendPeriod) {\r\n            return(0);\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "period > dividendPeriod"
          Identifier period
             Type: uint256
             Source: "period"
          Identifier dividendPeriod
             Type: uint256
             Source: "dividendPeriod"
        Block
           Source: "{\r\n            return(0);\r\n        }"
          Return
             Gas costs: 19
             Source: "return(0)"
            TupleExpression
               Type: int_const 0
               Source: "(0)"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      Return
         Gas costs: 260
         Source: "return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)))"
        TupleExpression
           Type: uint256
           Source: "((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)))"
          BinaryOperation using operator -
             Type: uint256
             Source: "(10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize))"
            TupleExpression
               Type: uint256
               Source: "(10 * hashesSize)"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "10 * hashesSize"
                Literal, token: [no token] value: 10
                   Type: int_const 10
                   Source: "10"
                Identifier hashesSize
                   Type: uint256
                   Source: "hashesSize"
            TupleExpression
               Type: uint256
               Source: "((block.number - hashFirst) % (10 * hashesSize))"
              BinaryOperation using operator %
                 Type: uint256
                 Source: "(block.number - hashFirst) % (10 * hashesSize)"
                TupleExpression
                   Type: uint256
                   Source: "(block.number - hashFirst)"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "block.number - hashFirst"
                    MemberAccess to member number
                       Type: uint256
                       Source: "block.number"
                      Identifier block
                         Type: block
                         Source: "block"
                    Identifier hashFirst
                       Type: uint256
                       Source: "hashFirst"
                TupleExpression
                   Type: uint256
                   Source: "(10 * hashesSize)"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "10 * hashesSize"
                    Literal, token: [no token] value: 10
                       Type: int_const 10
                       Source: "10"
                    Identifier hashesSize
                       Type: uint256
                       Source: "hashesSize"
  FunctionDefinition "changeOwner" - public
     Source: "function changeOwner(address _who) external onlyOwner {\r\n        assert(_who != address(0));\r\n        commitDividend(msg.sender);\r\n        commitDividend(_who);\r\n        owner = _who;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _who)"
      VariableDeclaration "_who"
         Type: address
         Source: "address _who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        assert(_who != address(0));\r\n        commitDividend(msg.sender);\r\n        commitDividend(_who);\r\n        owner = _who;\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "assert(_who != address(0))"
        FunctionCall
           Type: tuple()
           Source: "assert(_who != address(0))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator !=
             Type: bool
             Source: "_who != address(0)"
            Identifier _who
               Type: address
               Source: "_who"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 17
         Source: "commitDividend(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "commitDividend(msg.sender)"
          Identifier commitDividend
             Type: function (address)
             Source: "commitDividend"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 18
         Source: "commitDividend(_who)"
        FunctionCall
           Type: tuple()
           Source: "commitDividend(_who)"
          Identifier commitDividend
             Type: function (address)
             Source: "commitDividend"
          Identifier _who
             Type: address
             Source: "_who"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = _who"
        Assignment using operator =
           Type: address
           Source: "owner = _who"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier _who
             Type: address
             Source: "_who"
  FunctionDefinition "changeAnimator" - public
     Source: "function changeAnimator(address _who) external onlyAnimator {\r\n        assert(_who != address(0));\r\n        commitDividend(msg.sender);\r\n        commitDividend(_who);\r\n        animator = _who;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _who)"
      VariableDeclaration "_who"
         Type: address
         Source: "address _who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAnimator"
       Gas costs: 0
       Source: "onlyAnimator"
      Identifier onlyAnimator
         Type: modifier ()
         Source: "onlyAnimator"
    Block
       Source: "{\r\n        assert(_who != address(0));\r\n        commitDividend(msg.sender);\r\n        commitDividend(_who);\r\n        animator = _who;\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "assert(_who != address(0))"
        FunctionCall
           Type: tuple()
           Source: "assert(_who != address(0))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator !=
             Type: bool
             Source: "_who != address(0)"
            Identifier _who
               Type: address
               Source: "_who"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 17
         Source: "commitDividend(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "commitDividend(msg.sender)"
          Identifier commitDividend
             Type: function (address)
             Source: "commitDividend"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 18
         Source: "commitDividend(_who)"
        FunctionCall
           Type: tuple()
           Source: "commitDividend(_who)"
          Identifier commitDividend
             Type: function (address)
             Source: "commitDividend"
          Identifier _who
             Type: address
             Source: "_who"
      ExpressionStatement
         Gas costs: 20267
         Source: "animator = _who"
        Assignment using operator =
           Type: address
           Source: "animator = _who"
          Identifier animator
             Type: address
             Source: "animator"
          Identifier _who
             Type: address
             Source: "_who"
  FunctionDefinition "setInvestStart" - public
     Source: "function setInvestStart(uint _when) external onlyOwner {\r\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\r\n        investStart = _when;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _when)"
      VariableDeclaration "_when"
         Type: uint256
         Source: "uint _when"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\r\n        investStart = _when;\r\n    }"
      ExpressionStatement
         Gas costs: 496
         Source: "require(investStart == 1 && hashFirst > 0 && block.number < _when)"
        FunctionCall
           Type: tuple()
           Source: "require(investStart == 1 && hashFirst > 0 && block.number < _when)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "investStart == 1 && hashFirst > 0 && block.number < _when"
            BinaryOperation using operator &&
               Type: bool
               Source: "investStart == 1 && hashFirst > 0"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "investStart == 1"
                Identifier investStart
                   Type: uint256
                   Source: "investStart"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              BinaryOperation using operator >
                 Type: bool
                 Source: "hashFirst > 0"
                Identifier hashFirst
                   Type: uint256
                   Source: "hashFirst"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            BinaryOperation using operator <
               Type: bool
               Source: "block.number < _when"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              Identifier _when
                 Type: uint256
                 Source: "_when"
      ExpressionStatement
         Gas costs: 20014
         Source: "investStart = _when"
        Assignment using operator =
           Type: uint256
           Source: "investStart = _when"
          Identifier investStart
             Type: uint256
             Source: "investStart"
          Identifier _when
             Type: uint256
             Source: "_when"
  FunctionDefinition "setBetMax" - public
     Source: "function setBetMax(uint _maxsum) external onlyOwner {\r\n        hashBetMax = _maxsum;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _maxsum)"
      VariableDeclaration "_maxsum"
         Type: uint256
         Source: "uint _maxsum"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        hashBetMax = _maxsum;\r\n    }"
      ExpressionStatement
         Gas costs: 20014
         Source: "hashBetMax = _maxsum"
        Assignment using operator =
           Type: uint256
           Source: "hashBetMax = _maxsum"
          Identifier hashBetMax
             Type: uint256
             Source: "hashBetMax"
          Identifier _maxsum
             Type: uint256
             Source: "_maxsum"
  FunctionDefinition "resetBet" - public
     Source: "function resetBet() external onlyOwner {\r\n        hashNext = block.number + 3;\r\n        hashBetSum = 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        hashNext = block.number + 3;\r\n        hashBetSum = 0;\r\n    }"
      ExpressionStatement
         Gas costs: 20019
         Source: "hashNext = block.number + 3"
        Assignment using operator =
           Type: uint256
           Source: "hashNext = block.number + 3"
          Identifier hashNext
             Type: uint256
             Source: "hashNext"
          BinaryOperation using operator +
             Type: uint256
             Source: "block.number + 3"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Literal, token: [no token] value: 3
               Type: int_const 3
               Source: "3"
      ExpressionStatement
         Gas costs: 5014
         Source: "hashBetSum = 0"
        Assignment using operator =
           Type: uint256
           Source: "hashBetSum = 0"
          Identifier hashBetSum
             Type: uint256
             Source: "hashBetSum"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "coldStore" - public
     Source: "function coldStore(uint _amount) external onlyOwner {\r\n        houseKeeping();\r\n        require(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount);\r\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\r\n            require((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\r\n        }\r\n        msg.sender.transfer(_amount);\r\n        coldStoreLast = block.number;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _amount)"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        houseKeeping();\r\n        require(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount);\r\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\r\n            require((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\r\n        }\r\n        msg.sender.transfer(_amount);\r\n        coldStoreLast = block.number;\r\n    }"
      ExpressionStatement
         Gas costs: 15
         Source: "houseKeeping()"
        FunctionCall
           Type: tuple()
           Source: "houseKeeping()"
          Identifier houseKeeping
             Type: function ()
             Source: "houseKeeping"
      ExpressionStatement
         Gas costs: 925
         Source: "require(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount)"
        FunctionCall
           Type: tuple()
           Source: "require(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount"
            BinaryOperation using operator >
               Type: bool
               Source: "_amount > 0"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator >=
               Type: bool
               Source: "this.balance >= (investBalance * 9 / 10) + walletBalance + _amount"
              MemberAccess to member balance
                 Type: uint256
                 Source: "this.balance"
                Identifier this
                   Type: contract SmartBillions
                   Source: "this"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "(investBalance * 9 / 10) + walletBalance + _amount"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "(investBalance * 9 / 10) + walletBalance"
                  TupleExpression
                     Type: uint256
                     Source: "(investBalance * 9 / 10)"
                    BinaryOperation using operator /
                       Type: uint256
                       Source: "investBalance * 9 / 10"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "investBalance * 9"
                        Identifier investBalance
                           Type: uint256
                           Source: "investBalance"
                        Literal, token: [no token] value: 9
                           Type: int_const 9
                           Source: "9"
                      Literal, token: [no token] value: 10
                         Type: int_const 10
                         Source: "10"
                  Identifier walletBalance
                     Type: uint256
                     Source: "walletBalance"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
      IfStatement
         Source: "if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\r\n            require((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 443
           Source: "investBalance >= investBalanceMax / 2"
          Identifier investBalance
             Type: uint256
             Source: "investBalance"
          BinaryOperation using operator /
             Type: uint256
             Source: "investBalanceMax / 2"
            Identifier investBalanceMax
               Type: uint256
               Source: "investBalanceMax"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
        Block
           Source: "{ // additional jackpot protection\r\n            require((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\r\n        }"
          ExpressionStatement
             Gas costs: 713
             Source: "require((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number)"
            FunctionCall
               Type: tuple()
               Source: "require((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator &&
                 Type: bool
                 Source: "(_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number"
                TupleExpression
                   Type: bool
                   Source: "(_amount <= this.balance / 400)"
                  BinaryOperation using operator <=
                     Type: bool
                     Source: "_amount <= this.balance / 400"
                    Identifier _amount
                       Type: uint256
                       Source: "_amount"
                    BinaryOperation using operator /
                       Type: uint256
                       Source: "this.balance / 400"
                      MemberAccess to member balance
                         Type: uint256
                         Source: "this.balance"
                        Identifier this
                           Type: contract SmartBillions
                           Source: "this"
                      Literal, token: [no token] value: 400
                         Type: int_const 400
                         Source: "400"
                BinaryOperation using operator <=
                   Type: bool
                   Source: "coldStoreLast + 4 * 60 * 24 * 7 <= block.number"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "coldStoreLast + 4 * 60 * 24 * 7"
                    Identifier coldStoreLast
                       Type: uint256
                       Source: "coldStoreLast"
                    BinaryOperation using operator *
                       Type: int_const 40320
                       Source: "4 * 60 * 24 * 7"
                      BinaryOperation using operator *
                         Type: int_const 5760
                         Source: "4 * 60 * 24"
                        BinaryOperation using operator *
                           Type: int_const 240
                           Source: "4 * 60"
                          Literal, token: [no token] value: 4
                             Type: int_const 4
                             Source: "4"
                          Literal, token: [no token] value: 60
                             Type: int_const 60
                             Source: "60"
                        Literal, token: [no token] value: 24
                           Type: int_const 24
                           Source: "24"
                      Literal, token: [no token] value: 7
                         Type: int_const 7
                         Source: "7"
                  MemberAccess to member number
                     Type: uint256
                     Source: "block.number"
                    Identifier block
                       Type: block
                       Source: "block"
      ExpressionStatement
         Gas costs: [???]
         Source: "msg.sender.transfer(_amount)"
        FunctionCall
           Type: tuple()
           Source: "msg.sender.transfer(_amount)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "msg.sender.transfer"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: 20013
         Source: "coldStoreLast = block.number"
        Assignment using operator =
           Type: uint256
           Source: "coldStoreLast = block.number"
          Identifier coldStoreLast
             Type: uint256
             Source: "coldStoreLast"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
  FunctionDefinition "hotStore" - public
     Source: "function hotStore() payable external { // not needed because jackpot is protected\r\n        houseKeeping();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ // not needed because jackpot is protected\r\n        houseKeeping();\r\n    }"
      ExpressionStatement
         Gas costs: 4
         Source: "houseKeeping()"
        FunctionCall
           Type: tuple()
           Source: "houseKeeping()"
          Identifier houseKeeping
             Type: function ()
             Source: "houseKeeping"
  FunctionDefinition "houseKeeping" - public
     Source: "function houseKeeping() public {\r\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\r\n            investStart = 0; // start dividend payments\r\n        }\r\n        else {\r\n            if(hashFirst > 0){\r\n\t\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\r\n                if(period > dividends.length - 2) {\r\n                    dividends.push(0);\r\n                }\r\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\r\n                    dividendPeriod++;\r\n                }\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\r\n            investStart = 0; // start dividend payments\r\n        }\r\n        else {\r\n            if(hashFirst > 0){\r\n\t\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\r\n                if(period > dividends.length - 2) {\r\n                    dividends.push(0);\r\n                }\r\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\r\n                    dividendPeriod++;\r\n                }\r\n            }\r\n        }\r\n    }"
      IfStatement
         Source: "if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\r\n            investStart = 0; // start dividend payments\r\n        }\r\n        else {\r\n            if(hashFirst > 0){\r\n\t\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\r\n                if(period > dividends.length - 2) {\r\n                    dividends.push(0);\r\n                }\r\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\r\n                    dividendPeriod++;\r\n                }\r\n            }\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 453
           Source: "investStart > 1 && block.number >= investStart + (hashesSize * 5)"
          BinaryOperation using operator >
             Type: bool
             Source: "investStart > 1"
            Identifier investStart
               Type: uint256
               Source: "investStart"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          BinaryOperation using operator >=
             Type: bool
             Source: "block.number >= investStart + (hashesSize * 5)"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            BinaryOperation using operator +
               Type: uint256
               Source: "investStart + (hashesSize * 5)"
              Identifier investStart
                 Type: uint256
                 Source: "investStart"
              TupleExpression
                 Type: uint256
                 Source: "(hashesSize * 5)"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "hashesSize * 5"
                  Identifier hashesSize
                     Type: uint256
                     Source: "hashesSize"
                  Literal, token: [no token] value: 5
                     Type: int_const 5
                     Source: "5"
        Block
           Source: "{ // ca. 14 days\r\n            investStart = 0; // start dividend payments\r\n        }"
          ExpressionStatement
             Gas costs: 5014
             Source: "investStart = 0"
            Assignment using operator =
               Type: uint256
               Source: "investStart = 0"
              Identifier investStart
                 Type: uint256
                 Source: "investStart"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\r\n            if(hashFirst > 0){\r\n\t\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\r\n                if(period > dividends.length - 2) {\r\n                    dividends.push(0);\r\n                }\r\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\r\n                    dividendPeriod++;\r\n                }\r\n            }\r\n        }"
          IfStatement
             Source: "if(hashFirst > 0){\r\n\t\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\r\n                if(period > dividends.length - 2) {\r\n                    dividends.push(0);\r\n                }\r\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\r\n                    dividendPeriod++;\r\n                }\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 209
               Source: "hashFirst > 0"
              Identifier hashFirst
                 Type: uint256
                 Source: "hashFirst"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{\r\n\t\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\r\n                if(period > dividends.length - 2) {\r\n                    dividends.push(0);\r\n                }\r\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\r\n                    dividendPeriod++;\r\n                }\r\n            }"
              VariableDeclarationStatement
                 Gas costs: 252
                 Source: "uint period = (block.number - hashFirst) / (10 * hashesSize )"
                VariableDeclaration "period"
                   Type: uint256
                   Source: "uint period"
                  ElementaryTypeName uint
                     Source: "uint"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "(block.number - hashFirst) / (10 * hashesSize )"
                  TupleExpression
                     Type: uint256
                     Source: "(block.number - hashFirst)"
                    BinaryOperation using operator -
                       Type: uint256
                       Source: "block.number - hashFirst"
                      MemberAccess to member number
                         Type: uint256
                         Source: "block.number"
                        Identifier block
                           Type: block
                           Source: "block"
                      Identifier hashFirst
                         Type: uint256
                         Source: "hashFirst"
                  TupleExpression
                     Type: uint256
                     Source: "(10 * hashesSize )"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "10 * hashesSize"
                      Literal, token: [no token] value: 10
                         Type: int_const 10
                         Source: "10"
                      Identifier hashesSize
                         Type: uint256
                         Source: "hashesSize"
              IfStatement
                 Source: "if(period > dividends.length - 2) {\r\n                    dividends.push(0);\r\n                }"
                BinaryOperation using operator >
                   Type: bool
                   Gas costs: 223
                   Source: "period > dividends.length - 2"
                  Identifier period
                     Type: uint256
                     Source: "period"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "dividends.length - 2"
                    MemberAccess to member length
                       Type: uint256
                       Source: "dividends.length"
                      Identifier dividends
                         Type: uint256[] storage ref
                         Source: "dividends"
                    Literal, token: [no token] value: 2
                       Type: int_const 2
                       Source: "2"
                Block
                   Source: "{\r\n                    dividends.push(0);\r\n                }"
                  ExpressionStatement
                     Gas costs: 5109
                     Source: "dividends.push(0)"
                    FunctionCall
                       Type: uint256
                       Source: "dividends.push(0)"
                      MemberAccess to member push
                         Type: function (uint256) returns (uint256)
                         Source: "dividends.push"
                        Identifier dividends
                           Type: uint256[] storage ref
                           Source: "dividends"
                      Literal, token: [no token] value: 0
                         Type: int_const 0
                         Source: "0"
              IfStatement
                 Source: "if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\r\n                    dividendPeriod++;\r\n                }"
                BinaryOperation using operator &&
                   Type: bool
                   Gas costs: 885
                   Source: "period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1"
                  BinaryOperation using operator &&
                     Type: bool
                     Source: "period > dividendPeriod && investStart == 0"
                    BinaryOperation using operator >
                       Type: bool
                       Source: "period > dividendPeriod"
                      Identifier period
                         Type: uint256
                         Source: "period"
                      Identifier dividendPeriod
                         Type: uint256
                         Source: "dividendPeriod"
                    BinaryOperation using operator ==
                       Type: bool
                       Source: "investStart == 0"
                      Identifier investStart
                         Type: uint256
                         Source: "investStart"
                      Literal, token: [no token] value: 0
                         Type: int_const 0
                         Source: "0"
                  BinaryOperation using operator <
                     Type: bool
                     Source: "dividendPeriod < dividends.length - 1"
                    Identifier dividendPeriod
                       Type: uint256
                       Source: "dividendPeriod"
                    BinaryOperation using operator -
                       Type: uint256
                       Source: "dividends.length - 1"
                      MemberAccess to member length
                         Type: uint256
                         Source: "dividends.length"
                        Identifier dividends
                           Type: uint256[] storage ref
                           Source: "dividends"
                      Literal, token: [no token] value: 1
                         Type: int_const 1
                         Source: "1"
                Block
                   Source: "{\r\n                    dividendPeriod++;\r\n                }"
                  ExpressionStatement
                     Gas costs: 20237
                     Source: "dividendPeriod++"
                    UnaryOperation (postfix) ++
                       Type: uint256
                       Source: "dividendPeriod++"
                      Identifier dividendPeriod
                         Type: uint256
                         Source: "dividendPeriod"
  FunctionDefinition "payWallet" - public
     Source: "function payWallet() public {\r\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\r\n            uint balance = wallets[msg.sender].balance;\r\n            wallets[msg.sender].balance = 0;\r\n            walletBalance -= balance;\r\n            pay(balance);\r\n            //LogWithdraw(msg.sender,balance);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\r\n            uint balance = wallets[msg.sender].balance;\r\n            wallets[msg.sender].balance = 0;\r\n            walletBalance -= balance;\r\n            pay(balance);\r\n            //LogWithdraw(msg.sender,balance);\r\n        }\r\n    }"
      IfStatement
         Source: "if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\r\n            uint balance = wallets[msg.sender].balance;\r\n            wallets[msg.sender].balance = 0;\r\n            walletBalance -= balance;\r\n            pay(balance);\r\n            //LogWithdraw(msg.sender,balance);\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 778
           Source: "wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number"
          BinaryOperation using operator >
             Type: bool
             Source: "wallets[msg.sender].balance > 0"
            MemberAccess to member balance
               Type: uint208
               Source: "wallets[msg.sender].balance"
              IndexAccess
                 Type: struct SmartBillions.Wallet storage ref
                 Source: "wallets[msg.sender]"
                Identifier wallets
                   Type: mapping(address => struct SmartBillions.Wallet storage ref)
                   Source: "wallets"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator <=
             Type: bool
             Source: "wallets[msg.sender].nextWithdrawBlock <= block.number"
            MemberAccess to member nextWithdrawBlock
               Type: uint32
               Source: "wallets[msg.sender].nextWithdrawBlock"
              IndexAccess
                 Type: struct SmartBillions.Wallet storage ref
                 Source: "wallets[msg.sender]"
                Identifier wallets
                   Type: mapping(address => struct SmartBillions.Wallet storage ref)
                   Source: "wallets"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
        Block
           Source: "{\r\n            uint balance = wallets[msg.sender].balance;\r\n            wallets[msg.sender].balance = 0;\r\n            walletBalance -= balance;\r\n            pay(balance);\r\n            //LogWithdraw(msg.sender,balance);\r\n        }"
          VariableDeclarationStatement
             Gas costs: 354
             Source: "uint balance = wallets[msg.sender].balance"
            VariableDeclaration "balance"
               Type: uint256
               Source: "uint balance"
              ElementaryTypeName uint
                 Source: "uint"
            MemberAccess to member balance
               Type: uint208
               Source: "wallets[msg.sender].balance"
              IndexAccess
                 Type: struct SmartBillions.Wallet storage ref
                 Source: "wallets[msg.sender]"
                Identifier wallets
                   Type: mapping(address => struct SmartBillions.Wallet storage ref)
                   Source: "wallets"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
          ExpressionStatement
             Gas costs: 20362
             Source: "wallets[msg.sender].balance = 0"
            Assignment using operator =
               Type: uint208
               Source: "wallets[msg.sender].balance = 0"
              MemberAccess to member balance
                 Type: uint208
                 Source: "wallets[msg.sender].balance"
                IndexAccess
                   Type: struct SmartBillions.Wallet storage ref
                   Source: "wallets[msg.sender]"
                  Identifier wallets
                     Type: mapping(address => struct SmartBillions.Wallet storage ref)
                     Source: "wallets"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          ExpressionStatement
             Gas costs: 20233
             Source: "walletBalance -= balance"
            Assignment using operator -=
               Type: uint256
               Source: "walletBalance -= balance"
              Identifier walletBalance
                 Type: uint256
                 Source: "walletBalance"
              Identifier balance
                 Type: uint256
                 Source: "balance"
          ExpressionStatement
             Gas costs: 18
             Source: "pay(balance)"
            FunctionCall
               Type: tuple()
               Source: "pay(balance)"
              Identifier pay
                 Type: function (uint256)
                 Source: "pay"
              Identifier balance
                 Type: uint256
                 Source: "balance"
  FunctionDefinition "pay"
     Source: "function pay(uint _amount) private {\r\n        uint maxpay = this.balance / 2;\r\n        if(maxpay >= _amount) {\r\n            msg.sender.transfer(_amount);\r\n            if(_amount > 1 finney) {\r\n                houseKeeping();\r\n            }\r\n        }\r\n        else {\r\n            uint keepbalance = _amount - maxpay;\r\n            walletBalance += keepbalance;\r\n            wallets[msg.sender].balance += uint208(keepbalance);\r\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\r\n            msg.sender.transfer(maxpay);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _amount)"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint maxpay = this.balance / 2;\r\n        if(maxpay >= _amount) {\r\n            msg.sender.transfer(_amount);\r\n            if(_amount > 1 finney) {\r\n                houseKeeping();\r\n            }\r\n        }\r\n        else {\r\n            uint keepbalance = _amount - maxpay;\r\n            walletBalance += keepbalance;\r\n            wallets[msg.sender].balance += uint208(keepbalance);\r\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\r\n            msg.sender.transfer(maxpay);\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 447
         Source: "uint maxpay = this.balance / 2"
        VariableDeclaration "maxpay"
           Type: uint256
           Source: "uint maxpay"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "this.balance / 2"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract SmartBillions
               Source: "this"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
      IfStatement
         Source: "if(maxpay >= _amount) {\r\n            msg.sender.transfer(_amount);\r\n            if(_amount > 1 finney) {\r\n                houseKeeping();\r\n            }\r\n        }\r\n        else {\r\n            uint keepbalance = _amount - maxpay;\r\n            walletBalance += keepbalance;\r\n            wallets[msg.sender].balance += uint208(keepbalance);\r\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\r\n            msg.sender.transfer(maxpay);\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 12
           Source: "maxpay >= _amount"
          Identifier maxpay
             Type: uint256
             Source: "maxpay"
          Identifier _amount
             Type: uint256
             Source: "_amount"
        Block
           Source: "{\r\n            msg.sender.transfer(_amount);\r\n            if(_amount > 1 finney) {\r\n                houseKeeping();\r\n            }\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.transfer(_amount)"
            FunctionCall
               Type: tuple()
               Source: "msg.sender.transfer(_amount)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "msg.sender.transfer"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
          IfStatement
             Source: "if(_amount > 1 finney) {\r\n                houseKeeping();\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 9
               Source: "_amount > 1 finney"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
              Literal, token: [no token] value: 1
                 Type: int_const 1000000000000000
                 Source: "1 finney"
            Block
               Source: "{\r\n                houseKeeping();\r\n            }"
              ExpressionStatement
                 Gas costs: 15
                 Source: "houseKeeping()"
                FunctionCall
                   Type: tuple()
                   Source: "houseKeeping()"
                  Identifier houseKeeping
                     Type: function ()
                     Source: "houseKeeping"
        Block
           Source: "{\r\n            uint keepbalance = _amount - maxpay;\r\n            walletBalance += keepbalance;\r\n            wallets[msg.sender].balance += uint208(keepbalance);\r\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\r\n            msg.sender.transfer(maxpay);\r\n        }"
          VariableDeclarationStatement
             Gas costs: 17
             Source: "uint keepbalance = _amount - maxpay"
            VariableDeclaration "keepbalance"
               Type: uint256
               Source: "uint keepbalance"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator -
               Type: uint256
               Source: "_amount - maxpay"
              Identifier _amount
                 Type: uint256
                 Source: "_amount"
              Identifier maxpay
                 Type: uint256
                 Source: "maxpay"
          ExpressionStatement
             Gas costs: 20233
             Source: "walletBalance += keepbalance"
            Assignment using operator +=
               Type: uint256
               Source: "walletBalance += keepbalance"
              Identifier walletBalance
                 Type: uint256
                 Source: "walletBalance"
              Identifier keepbalance
                 Type: uint256
                 Source: "keepbalance"
          ExpressionStatement
             Gas costs: 20618
             Source: "wallets[msg.sender].balance += uint208(keepbalance)"
            Assignment using operator +=
               Type: uint208
               Source: "wallets[msg.sender].balance += uint208(keepbalance)"
              MemberAccess to member balance
                 Type: uint208
                 Source: "wallets[msg.sender].balance"
                IndexAccess
                   Type: struct SmartBillions.Wallet storage ref
                   Source: "wallets[msg.sender]"
                  Identifier wallets
                     Type: mapping(address => struct SmartBillions.Wallet storage ref)
                     Source: "wallets"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
              FunctionCall
                 Type: uint208
                 Source: "uint208(keepbalance)"
                ElementaryTypeNameExpression uint208
                   Type: type(uint208)
                   Source: "uint208"
                Identifier keepbalance
                   Type: uint256
                   Source: "keepbalance"
          ExpressionStatement
             Gas costs: 20417
             Source: "wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30)"
            Assignment using operator =
               Type: uint32
               Source: "wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30)"
              MemberAccess to member nextWithdrawBlock
                 Type: uint32
                 Source: "wallets[msg.sender].nextWithdrawBlock"
                IndexAccess
                   Type: struct SmartBillions.Wallet storage ref
                   Source: "wallets[msg.sender]"
                  Identifier wallets
                     Type: mapping(address => struct SmartBillions.Wallet storage ref)
                     Source: "wallets"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
              FunctionCall
                 Type: uint32
                 Source: "uint32(block.number + 4 * 60 * 24 * 30)"
                ElementaryTypeNameExpression uint32
                   Type: type(uint32)
                   Source: "uint32"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "block.number + 4 * 60 * 24 * 30"
                  MemberAccess to member number
                     Type: uint256
                     Source: "block.number"
                    Identifier block
                       Type: block
                       Source: "block"
                  BinaryOperation using operator *
                     Type: int_const 172800
                     Source: "4 * 60 * 24 * 30"
                    BinaryOperation using operator *
                       Type: int_const 5760
                       Source: "4 * 60 * 24"
                      BinaryOperation using operator *
                         Type: int_const 240
                         Source: "4 * 60"
                        Literal, token: [no token] value: 4
                           Type: int_const 4
                           Source: "4"
                        Literal, token: [no token] value: 60
                           Type: int_const 60
                           Source: "60"
                      Literal, token: [no token] value: 24
                         Type: int_const 24
                         Source: "24"
                    Literal, token: [no token] value: 30
                       Type: int_const 30
                       Source: "30"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.transfer(maxpay)"
            FunctionCall
               Type: tuple()
               Source: "msg.sender.transfer(maxpay)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "msg.sender.transfer"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier maxpay
                 Type: uint256
                 Source: "maxpay"
  FunctionDefinition "investDirect" - public
     Source: "function investDirect() payable external {\r\n        invest(owner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        invest(owner);\r\n    }"
      ExpressionStatement
         Gas costs: 254
         Source: "invest(owner)"
        FunctionCall
           Type: tuple()
           Source: "invest(owner)"
          Identifier invest
             Type: function (address)
             Source: "invest"
          Identifier owner
             Type: address
             Source: "owner"
  FunctionDefinition "invest" - public
     Source: "function invest(address _partner) payable public {\r\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\r\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\r\n        uint investing = msg.value;\r\n        if(investing > investBalanceMax - investBalance) {\r\n            investing = investBalanceMax - investBalance;\r\n            investBalance = investBalanceMax;\r\n            investStart = 0; // close investment round\r\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\r\n        }\r\n        else{\r\n            investBalance += investing;\r\n        }\r\n        if(_partner == address(0) || _partner == owner){\r\n            walletBalance += investing / 10;\r\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\r\n        else{\r\n            walletBalance += (investing * 5 / 100) * 2;\r\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\r\n            //wallets[_partner].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\r\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\r\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\r\n        uint senderBalance = investing / 10**15;\r\n        uint ownerBalance = investing * 16 / 10**17  ;\r\n        uint animatorBalance = investing * 10 / 10**17  ;\r\n        balances[msg.sender] += senderBalance;\r\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\r\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\r\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\r\n        Transfer(address(0),msg.sender,senderBalance); // for etherscan\r\n        Transfer(address(0),owner,ownerBalance); // for etherscan\r\n        Transfer(address(0),animator,animatorBalance); // for etherscan\r\n        LogInvestment(msg.sender,_partner,investing);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _partner)"
      VariableDeclaration "_partner"
         Type: address
         Source: "address _partner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\r\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\r\n        uint investing = msg.value;\r\n        if(investing > investBalanceMax - investBalance) {\r\n            investing = investBalanceMax - investBalance;\r\n            investBalance = investBalanceMax;\r\n            investStart = 0; // close investment round\r\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\r\n        }\r\n        else{\r\n            investBalance += investing;\r\n        }\r\n        if(_partner == address(0) || _partner == owner){\r\n            walletBalance += investing / 10;\r\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\r\n        else{\r\n            walletBalance += (investing * 5 / 100) * 2;\r\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\r\n            //wallets[_partner].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\r\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\r\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\r\n        uint senderBalance = investing / 10**15;\r\n        uint ownerBalance = investing * 16 / 10**17  ;\r\n        uint animatorBalance = investing * 10 / 10**17  ;\r\n        balances[msg.sender] += senderBalance;\r\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\r\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\r\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\r\n        Transfer(address(0),msg.sender,senderBalance); // for etherscan\r\n        Transfer(address(0),owner,ownerBalance); // for etherscan\r\n        Transfer(address(0),animator,animatorBalance); // for etherscan\r\n        LogInvestment(msg.sender,_partner,investing);\r\n    }"
      ExpressionStatement
         Gas costs: 907
         Source: "require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax)"
        FunctionCall
           Type: tuple()
           Source: "require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax"
            BinaryOperation using operator &&
               Type: bool
               Source: "investStart > 1 && block.number < investStart + (hashesSize * 5)"
              BinaryOperation using operator >
                 Type: bool
                 Source: "investStart > 1"
                Identifier investStart
                   Type: uint256
                   Source: "investStart"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              BinaryOperation using operator <
                 Type: bool
                 Source: "block.number < investStart + (hashesSize * 5)"
                MemberAccess to member number
                   Type: uint256
                   Source: "block.number"
                  Identifier block
                     Type: block
                     Source: "block"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "investStart + (hashesSize * 5)"
                  Identifier investStart
                     Type: uint256
                     Source: "investStart"
                  TupleExpression
                     Type: uint256
                     Source: "(hashesSize * 5)"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "hashesSize * 5"
                      Identifier hashesSize
                         Type: uint256
                         Source: "hashesSize"
                      Literal, token: [no token] value: 5
                         Type: int_const 5
                         Source: "5"
            BinaryOperation using operator <
               Type: bool
               Source: "investBalance < investBalanceMax"
              Identifier investBalance
                 Type: uint256
                 Source: "investBalance"
              Identifier investBalanceMax
                 Type: uint256
                 Source: "investBalanceMax"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint investing = msg.value"
        VariableDeclaration "investing"
           Type: uint256
           Source: "uint investing"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member value
           Type: uint256
           Source: "msg.value"
          Identifier msg
             Type: msg
             Source: "msg"
      IfStatement
         Source: "if(investing > investBalanceMax - investBalance) {\r\n            investing = investBalanceMax - investBalance;\r\n            investBalance = investBalanceMax;\r\n            investStart = 0; // close investment round\r\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\r\n        }\r\n        else{\r\n            investBalance += investing;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 415
           Source: "investing > investBalanceMax - investBalance"
          Identifier investing
             Type: uint256
             Source: "investing"
          BinaryOperation using operator -
             Type: uint256
             Source: "investBalanceMax - investBalance"
            Identifier investBalanceMax
               Type: uint256
               Source: "investBalanceMax"
            Identifier investBalance
               Type: uint256
               Source: "investBalance"
        Block
           Source: "{\r\n            investing = investBalanceMax - investBalance;\r\n            investBalance = investBalanceMax;\r\n            investStart = 0; // close investment round\r\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\r\n        }"
          ExpressionStatement
             Gas costs: 414
             Source: "investing = investBalanceMax - investBalance"
            Assignment using operator =
               Type: uint256
               Source: "investing = investBalanceMax - investBalance"
              Identifier investing
                 Type: uint256
                 Source: "investing"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "investBalanceMax - investBalance"
                Identifier investBalanceMax
                   Type: uint256
                   Source: "investBalanceMax"
                Identifier investBalance
                   Type: uint256
                   Source: "investBalance"
          ExpressionStatement
             Gas costs: 20214
             Source: "investBalance = investBalanceMax"
            Assignment using operator =
               Type: uint256
               Source: "investBalance = investBalanceMax"
              Identifier investBalance
                 Type: uint256
                 Source: "investBalance"
              Identifier investBalanceMax
                 Type: uint256
                 Source: "investBalanceMax"
          ExpressionStatement
             Gas costs: 5014
             Source: "investStart = 0"
            Assignment using operator =
               Type: uint256
               Source: "investStart = 0"
              Identifier investStart
                 Type: uint256
                 Source: "investStart"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.transfer(msg.value.sub(investing))"
            FunctionCall
               Type: tuple()
               Source: "msg.sender.transfer(msg.value.sub(investing))"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "msg.sender.transfer"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              FunctionCall
                 Type: uint256
                 Source: "msg.value.sub(investing)"
                MemberAccess to member sub
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "msg.value.sub"
                  MemberAccess to member value
                     Type: uint256
                     Source: "msg.value"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier investing
                   Type: uint256
                   Source: "investing"
        Block
           Source: "{\r\n            investBalance += investing;\r\n        }"
          ExpressionStatement
             Gas costs: 20233
             Source: "investBalance += investing"
            Assignment using operator +=
               Type: uint256
               Source: "investBalance += investing"
              Identifier investBalance
                 Type: uint256
                 Source: "investBalance"
              Identifier investing
                 Type: uint256
                 Source: "investing"
      IfStatement
         Source: "if(_partner == address(0) || _partner == owner){\r\n            walletBalance += investing / 10;\r\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\r\n        else{\r\n            walletBalance += (investing * 5 / 100) * 2;\r\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\r\n            //wallets[_partner].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\r\n            wallets[_partner].balance += uint208(investing * 5 / 100);}"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 297
           Source: "_partner == address(0) || _partner == owner"
          BinaryOperation using operator ==
             Type: bool
             Source: "_partner == address(0)"
            Identifier _partner
               Type: address
               Source: "_partner"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          BinaryOperation using operator ==
             Type: bool
             Source: "_partner == owner"
            Identifier _partner
               Type: address
               Source: "_partner"
            Identifier owner
               Type: address
               Source: "owner"
        Block
           Source: "{\r\n            walletBalance += investing / 10;\r\n            wallets[owner].balance += uint208(investing / 10);}"
          ExpressionStatement
             Gas costs: 20264
             Source: "walletBalance += investing / 10"
            Assignment using operator +=
               Type: uint256
               Source: "walletBalance += investing / 10"
              Identifier walletBalance
                 Type: uint256
                 Source: "walletBalance"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "investing / 10"
                Identifier investing
                   Type: uint256
                   Source: "investing"
                Literal, token: [no token] value: 10
                   Type: int_const 10
                   Source: "10"
          ExpressionStatement
             Gas costs: 20886
             Source: "wallets[owner].balance += uint208(investing / 10)"
            Assignment using operator +=
               Type: uint208
               Source: "wallets[owner].balance += uint208(investing / 10)"
              MemberAccess to member balance
                 Type: uint208
                 Source: "wallets[owner].balance"
                IndexAccess
                   Type: struct SmartBillions.Wallet storage ref
                   Source: "wallets[owner]"
                  Identifier wallets
                     Type: mapping(address => struct SmartBillions.Wallet storage ref)
                     Source: "wallets"
                  Identifier owner
                     Type: address
                     Source: "owner"
              FunctionCall
                 Type: uint208
                 Source: "uint208(investing / 10)"
                ElementaryTypeNameExpression uint208
                   Type: type(uint208)
                   Source: "uint208"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "investing / 10"
                  Identifier investing
                     Type: uint256
                     Source: "investing"
                  Literal, token: [no token] value: 10
                     Type: int_const 10
                     Source: "10"
        Block
           Source: "{\r\n            walletBalance += (investing * 5 / 100) * 2;\r\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\r\n            //wallets[_partner].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\r\n            wallets[_partner].balance += uint208(investing * 5 / 100);}"
          ExpressionStatement
             Gas costs: 20280
             Source: "walletBalance += (investing * 5 / 100) * 2"
            Assignment using operator +=
               Type: uint256
               Source: "walletBalance += (investing * 5 / 100) * 2"
              Identifier walletBalance
                 Type: uint256
                 Source: "walletBalance"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "(investing * 5 / 100) * 2"
                TupleExpression
                   Type: uint256
                   Source: "(investing * 5 / 100)"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "investing * 5 / 100"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "investing * 5"
                      Identifier investing
                         Type: uint256
                         Source: "investing"
                      Literal, token: [no token] value: 5
                         Type: int_const 5
                         Source: "5"
                    Literal, token: [no token] value: 100
                       Type: int_const 100
                       Source: "100"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
          ExpressionStatement
             Gas costs: 20894
             Source: "wallets[owner].balance += uint208(investing * 5 / 100)"
            Assignment using operator +=
               Type: uint208
               Source: "wallets[owner].balance += uint208(investing * 5 / 100)"
              MemberAccess to member balance
                 Type: uint208
                 Source: "wallets[owner].balance"
                IndexAccess
                   Type: struct SmartBillions.Wallet storage ref
                   Source: "wallets[owner]"
                  Identifier wallets
                     Type: mapping(address => struct SmartBillions.Wallet storage ref)
                     Source: "wallets"
                  Identifier owner
                     Type: address
                     Source: "owner"
              FunctionCall
                 Type: uint208
                 Source: "uint208(investing * 5 / 100)"
                ElementaryTypeNameExpression uint208
                   Type: type(uint208)
                   Source: "uint208"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "investing * 5 / 100"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "investing * 5"
                    Identifier investing
                       Type: uint256
                       Source: "investing"
                    Literal, token: [no token] value: 5
                       Type: int_const 5
                       Source: "5"
                  Literal, token: [no token] value: 100
                     Type: int_const 100
                     Source: "100"
          ExpressionStatement
             Gas costs: 20658
             Source: "wallets[_partner].balance += uint208(investing * 5 / 100)"
            Assignment using operator +=
               Type: uint208
               Source: "wallets[_partner].balance += uint208(investing * 5 / 100)"
              MemberAccess to member balance
                 Type: uint208
                 Source: "wallets[_partner].balance"
                IndexAccess
                   Type: struct SmartBillions.Wallet storage ref
                   Source: "wallets[_partner]"
                  Identifier wallets
                     Type: mapping(address => struct SmartBillions.Wallet storage ref)
                     Source: "wallets"
                  Identifier _partner
                     Type: address
                     Source: "_partner"
              FunctionCall
                 Type: uint208
                 Source: "uint208(investing * 5 / 100)"
                ElementaryTypeNameExpression uint208
                   Type: type(uint208)
                   Source: "uint208"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "investing * 5 / 100"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "investing * 5"
                    Identifier investing
                       Type: uint256
                       Source: "investing"
                    Literal, token: [no token] value: 5
                       Type: int_const 5
                       Source: "5"
                  Literal, token: [no token] value: 100
                     Type: int_const 100
                     Source: "100"
      ExpressionStatement
         Gas costs: 20618
         Source: "wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod)"
        Assignment using operator =
           Type: uint16
           Source: "wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod)"
          MemberAccess to member lastDividendPeriod
             Type: uint16
             Source: "wallets[msg.sender].lastDividendPeriod"
            IndexAccess
               Type: struct SmartBillions.Wallet storage ref
               Source: "wallets[msg.sender]"
              Identifier wallets
                 Type: mapping(address => struct SmartBillions.Wallet storage ref)
                 Source: "wallets"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          FunctionCall
             Type: uint16
             Source: "uint16(dividendPeriod)"
            ElementaryTypeNameExpression uint16
               Type: type(uint16)
               Source: "uint16"
            Identifier dividendPeriod
               Type: uint256
               Source: "dividendPeriod"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint senderBalance = investing / 10**15"
        VariableDeclaration "senderBalance"
           Type: uint256
           Source: "uint senderBalance"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "investing / 10**15"
          Identifier investing
             Type: uint256
             Source: "investing"
          BinaryOperation using operator **
             Type: int_const 1000000000000000
             Source: "10**15"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
            Literal, token: [no token] value: 15
               Type: int_const 15
               Source: "15"
      VariableDeclarationStatement
         Gas costs: 50
         Source: "uint ownerBalance = investing * 16 / 10**17"
        VariableDeclaration "ownerBalance"
           Type: uint256
           Source: "uint ownerBalance"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "investing * 16 / 10**17"
          BinaryOperation using operator *
             Type: uint256
             Source: "investing * 16"
            Identifier investing
               Type: uint256
               Source: "investing"
            Literal, token: [no token] value: 16
               Type: int_const 16
               Source: "16"
          BinaryOperation using operator **
             Type: int_const 100000000000000000
             Source: "10**17"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
            Literal, token: [no token] value: 17
               Type: int_const 17
               Source: "17"
      VariableDeclarationStatement
         Gas costs: 50
         Source: "uint animatorBalance = investing * 10 / 10**17"
        VariableDeclaration "animatorBalance"
           Type: uint256
           Source: "uint animatorBalance"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "investing * 10 / 10**17"
          BinaryOperation using operator *
             Type: uint256
             Source: "investing * 10"
            Identifier investing
               Type: uint256
               Source: "investing"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
          BinaryOperation using operator **
             Type: int_const 100000000000000000
             Source: "10**17"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
            Literal, token: [no token] value: 17
               Type: int_const 17
               Source: "17"
      ExpressionStatement
         Gas costs: 20328
         Source: "balances[msg.sender] += senderBalance"
        Assignment using operator +=
           Type: uint256
           Source: "balances[msg.sender] += senderBalance"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier senderBalance
             Type: uint256
             Source: "senderBalance"
      ExpressionStatement
         Gas costs: 20559
         Source: "balances[owner] += ownerBalance"
        Assignment using operator +=
           Type: uint256
           Source: "balances[owner] += ownerBalance"
          IndexAccess
             Type: uint256
             Source: "balances[owner]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier owner
               Type: address
               Source: "owner"
          Identifier ownerBalance
             Type: uint256
             Source: "ownerBalance"
      ExpressionStatement
         Gas costs: 20559
         Source: "balances[animator] += animatorBalance"
        Assignment using operator +=
           Type: uint256
           Source: "balances[animator] += animatorBalance"
          IndexAccess
             Type: uint256
             Source: "balances[animator]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier animator
               Type: address
               Source: "animator"
          Identifier animatorBalance
             Type: uint256
             Source: "animatorBalance"
      ExpressionStatement
         Gas costs: 20245
         Source: "totalSupply += senderBalance + ownerBalance + animatorBalance"
        Assignment using operator +=
           Type: uint256
           Source: "totalSupply += senderBalance + ownerBalance + animatorBalance"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          BinaryOperation using operator +
             Type: uint256
             Source: "senderBalance + ownerBalance + animatorBalance"
            BinaryOperation using operator +
               Type: uint256
               Source: "senderBalance + ownerBalance"
              Identifier senderBalance
                 Type: uint256
                 Source: "senderBalance"
              Identifier ownerBalance
                 Type: uint256
                 Source: "ownerBalance"
            Identifier animatorBalance
               Type: uint256
               Source: "animatorBalance"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(address(0),msg.sender,senderBalance)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(address(0),msg.sender,senderBalance)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier senderBalance
             Type: uint256
             Source: "senderBalance"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(address(0),owner,ownerBalance)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(address(0),owner,ownerBalance)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier ownerBalance
             Type: uint256
             Source: "ownerBalance"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(address(0),animator,animatorBalance)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(address(0),animator,animatorBalance)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Identifier animator
             Type: address
             Source: "animator"
          Identifier animatorBalance
             Type: uint256
             Source: "animatorBalance"
      ExpressionStatement
         Gas costs: [???]
         Source: "LogInvestment(msg.sender,_partner,investing)"
        FunctionCall
           Type: tuple()
           Source: "LogInvestment(msg.sender,_partner,investing)"
          Identifier LogInvestment
             Type: function (address,address,uint256)
             Source: "LogInvestment"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _partner
             Type: address
             Source: "_partner"
          Identifier investing
             Type: uint256
             Source: "investing"
  FunctionDefinition "disinvest" - public
     Source: "function disinvest() external {\r\n        require(investStart == 0);\r\n        commitDividend(msg.sender);\r\n        uint initialInvestment = balances[msg.sender] * 10**15;\r\n        Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\r\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\r\n        investBalance -= initialInvestment;\r\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\r\n        payWallet();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(investStart == 0);\r\n        commitDividend(msg.sender);\r\n        uint initialInvestment = balances[msg.sender] * 10**15;\r\n        Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\r\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\r\n        investBalance -= initialInvestment;\r\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\r\n        payWallet();\r\n    }"
      ExpressionStatement
         Gas costs: 235
         Source: "require(investStart == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(investStart == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "investStart == 0"
            Identifier investStart
               Type: uint256
               Source: "investStart"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 17
         Source: "commitDividend(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "commitDividend(msg.sender)"
          Identifier commitDividend
             Type: function (address)
             Source: "commitDividend"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      VariableDeclarationStatement
         Gas costs: 314
         Source: "uint initialInvestment = balances[msg.sender] * 10**15"
        VariableDeclaration "initialInvestment"
           Type: uint256
           Source: "uint initialInvestment"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "balances[msg.sender] * 10**15"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          BinaryOperation using operator **
             Type: int_const 1000000000000000
             Source: "10**15"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
            Literal, token: [no token] value: 15
               Type: int_const 15
               Source: "15"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender,address(0),balances[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender,address(0),balances[msg.sender])"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 5098
         Source: "delete balances[msg.sender]"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete balances[msg.sender]"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 20233
         Source: "investBalance -= initialInvestment"
        Assignment using operator -=
           Type: uint256
           Source: "investBalance -= initialInvestment"
          Identifier investBalance
             Type: uint256
             Source: "investBalance"
          Identifier initialInvestment
             Type: uint256
             Source: "initialInvestment"
      ExpressionStatement
         Gas costs: 20657
         Source: "wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10)"
        Assignment using operator +=
           Type: uint208
           Source: "wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10)"
          MemberAccess to member balance
             Type: uint208
             Source: "wallets[msg.sender].balance"
            IndexAccess
               Type: struct SmartBillions.Wallet storage ref
               Source: "wallets[msg.sender]"
              Identifier wallets
                 Type: mapping(address => struct SmartBillions.Wallet storage ref)
                 Source: "wallets"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          FunctionCall
             Type: uint208
             Source: "uint208(initialInvestment * 9 / 10)"
            ElementaryTypeNameExpression uint208
               Type: type(uint208)
               Source: "uint208"
            BinaryOperation using operator /
               Type: uint256
               Source: "initialInvestment * 9 / 10"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "initialInvestment * 9"
                Identifier initialInvestment
                   Type: uint256
                   Source: "initialInvestment"
                Literal, token: [no token] value: 9
                   Type: int_const 9
                   Source: "9"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
      ExpressionStatement
         Gas costs: 15
         Source: "payWallet()"
        FunctionCall
           Type: tuple()
           Source: "payWallet()"
          Identifier payWallet
             Type: function ()
             Source: "payWallet"
  FunctionDefinition "payDividends" - public
     Source: "function payDividends() external {\r\n        require(investStart == 0);\r\n        commitDividend(msg.sender);\r\n        payWallet();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(investStart == 0);\r\n        commitDividend(msg.sender);\r\n        payWallet();\r\n    }"
      ExpressionStatement
         Gas costs: 235
         Source: "require(investStart == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(investStart == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "investStart == 0"
            Identifier investStart
               Type: uint256
               Source: "investStart"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 17
         Source: "commitDividend(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "commitDividend(msg.sender)"
          Identifier commitDividend
             Type: function (address)
             Source: "commitDividend"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 15
         Source: "payWallet()"
        FunctionCall
           Type: tuple()
           Source: "payWallet()"
          Identifier payWallet
             Type: function ()
             Source: "payWallet"
  FunctionDefinition "commitDividend"
     Source: "function commitDividend(address _who) internal {\r\n        uint last = wallets[_who].lastDividendPeriod;\r\n        if((balances[_who]==0) || (last==0)){\r\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\r\n            return;\r\n        }\r\n        if(last==dividendPeriod) {\r\n            return;\r\n        }\r\n        uint share = balances[_who] * 0xffffffff / totalSupply;\r\n        uint balance = 0;\r\n        for(;last<dividendPeriod;last++) {\r\n            balance += share * dividends[last];\r\n        }\r\n        balance = (balance / 0xffffffff);\r\n        walletBalance += balance;\r\n        wallets[_who].balance += uint208(balance);\r\n        wallets[_who].lastDividendPeriod = uint16(last);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _who)"
      VariableDeclaration "_who"
         Type: address
         Source: "address _who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint last = wallets[_who].lastDividendPeriod;\r\n        if((balances[_who]==0) || (last==0)){\r\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\r\n            return;\r\n        }\r\n        if(last==dividendPeriod) {\r\n            return;\r\n        }\r\n        uint share = balances[_who] * 0xffffffff / totalSupply;\r\n        uint balance = 0;\r\n        for(;last<dividendPeriod;last++) {\r\n            balance += share * dividends[last];\r\n        }\r\n        balance = (balance / 0xffffffff);\r\n        walletBalance += balance;\r\n        wallets[_who].balance += uint208(balance);\r\n        wallets[_who].lastDividendPeriod = uint16(last);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 405
         Source: "uint last = wallets[_who].lastDividendPeriod"
        VariableDeclaration "last"
           Type: uint256
           Source: "uint last"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member lastDividendPeriod
           Type: uint16
           Source: "wallets[_who].lastDividendPeriod"
          IndexAccess
             Type: struct SmartBillions.Wallet storage ref
             Source: "wallets[_who]"
            Identifier wallets
               Type: mapping(address => struct SmartBillions.Wallet storage ref)
               Source: "wallets"
            Identifier _who
               Type: address
               Source: "_who"
      IfStatement
         Source: "if((balances[_who]==0) || (last==0)){\r\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\r\n            return;\r\n        }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 327
           Source: "(balances[_who]==0) || (last==0)"
          TupleExpression
             Type: bool
             Source: "(balances[_who]==0)"
            BinaryOperation using operator ==
               Type: bool
               Source: "balances[_who]==0"
              IndexAccess
                 Type: uint256
                 Source: "balances[_who]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _who
                   Type: address
                   Source: "_who"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          TupleExpression
             Type: bool
             Source: "(last==0)"
            BinaryOperation using operator ==
               Type: bool
               Source: "last==0"
              Identifier last
                 Type: uint256
                 Source: "last"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\r\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\r\n            return;\r\n        }"
          ExpressionStatement
             Gas costs: 20619
             Source: "wallets[_who].lastDividendPeriod=uint16(dividendPeriod)"
            Assignment using operator =
               Type: uint16
               Source: "wallets[_who].lastDividendPeriod=uint16(dividendPeriod)"
              MemberAccess to member lastDividendPeriod
                 Type: uint16
                 Source: "wallets[_who].lastDividendPeriod"
                IndexAccess
                   Type: struct SmartBillions.Wallet storage ref
                   Source: "wallets[_who]"
                  Identifier wallets
                     Type: mapping(address => struct SmartBillions.Wallet storage ref)
                     Source: "wallets"
                  Identifier _who
                     Type: address
                     Source: "_who"
              FunctionCall
                 Type: uint16
                 Source: "uint16(dividendPeriod)"
                ElementaryTypeNameExpression uint16
                   Type: type(uint16)
                   Source: "uint16"
                Identifier dividendPeriod
                   Type: uint256
                   Source: "dividendPeriod"
          Return
             Gas costs: 11
             Source: "return;"
      IfStatement
         Source: "if(last==dividendPeriod) {\r\n            return;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 209
           Source: "last==dividendPeriod"
          Identifier last
             Type: uint256
             Source: "last"
          Identifier dividendPeriod
             Type: uint256
             Source: "dividendPeriod"
        Block
           Source: "{\r\n            return;\r\n        }"
          Return
             Gas costs: 11
             Source: "return;"
      VariableDeclarationStatement
         Gas costs: 546
         Source: "uint share = balances[_who] * 0xffffffff / totalSupply"
        VariableDeclaration "share"
           Type: uint256
           Source: "uint share"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "balances[_who] * 0xffffffff / totalSupply"
          BinaryOperation using operator *
             Type: uint256
             Source: "balances[_who] * 0xffffffff"
            IndexAccess
               Type: uint256
               Source: "balances[_who]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _who
                 Type: address
                 Source: "_who"
            Literal, token: [no token] value: 0xffffffff
               Type: int_const 4294967295
               Source: "0xffffffff"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint balance = 0"
        VariableDeclaration "balance"
           Type: uint256
           Source: "uint balance"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for(;last<dividendPeriod;last++) {\r\n            balance += share * dividends[last];\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 209
           Source: "last<dividendPeriod"
          Identifier last
             Type: uint256
             Source: "last"
          Identifier dividendPeriod
             Type: uint256
             Source: "dividendPeriod"
        ExpressionStatement
           Gas costs: 19
           Source: "last++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "last++"
            Identifier last
               Type: uint256
               Source: "last"
        Block
           Source: "{\r\n            balance += share * dividends[last];\r\n        }"
          ExpressionStatement
             Gas costs: 511
             Source: "balance += share * dividends[last]"
            Assignment using operator +=
               Type: uint256
               Source: "balance += share * dividends[last]"
              Identifier balance
                 Type: uint256
                 Source: "balance"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "share * dividends[last]"
                Identifier share
                   Type: uint256
                   Source: "share"
                IndexAccess
                   Type: uint256
                   Source: "dividends[last]"
                  Identifier dividends
                     Type: uint256[] storage ref
                     Source: "dividends"
                  Identifier last
                     Type: uint256
                     Source: "last"
      ExpressionStatement
         Gas costs: 39
         Source: "balance = (balance / 0xffffffff)"
        Assignment using operator =
           Type: uint256
           Source: "balance = (balance / 0xffffffff)"
          Identifier balance
             Type: uint256
             Source: "balance"
          TupleExpression
             Type: uint256
             Source: "(balance / 0xffffffff)"
            BinaryOperation using operator /
               Type: uint256
               Source: "balance / 0xffffffff"
              Identifier balance
                 Type: uint256
                 Source: "balance"
              Literal, token: [no token] value: 0xffffffff
                 Type: int_const 4294967295
                 Source: "0xffffffff"
      ExpressionStatement
         Gas costs: 20233
         Source: "walletBalance += balance"
        Assignment using operator +=
           Type: uint256
           Source: "walletBalance += balance"
          Identifier walletBalance
             Type: uint256
             Source: "walletBalance"
          Identifier balance
             Type: uint256
             Source: "balance"
      ExpressionStatement
         Gas costs: 20619
         Source: "wallets[_who].balance += uint208(balance)"
        Assignment using operator +=
           Type: uint208
           Source: "wallets[_who].balance += uint208(balance)"
          MemberAccess to member balance
             Type: uint208
             Source: "wallets[_who].balance"
            IndexAccess
               Type: struct SmartBillions.Wallet storage ref
               Source: "wallets[_who]"
              Identifier wallets
                 Type: mapping(address => struct SmartBillions.Wallet storage ref)
                 Source: "wallets"
              Identifier _who
                 Type: address
                 Source: "_who"
          FunctionCall
             Type: uint208
             Source: "uint208(balance)"
            ElementaryTypeNameExpression uint208
               Type: type(uint208)
               Source: "uint208"
            Identifier balance
               Type: uint256
               Source: "balance"
      ExpressionStatement
         Gas costs: 20413
         Source: "wallets[_who].lastDividendPeriod = uint16(last)"
        Assignment using operator =
           Type: uint16
           Source: "wallets[_who].lastDividendPeriod = uint16(last)"
          MemberAccess to member lastDividendPeriod
             Type: uint16
             Source: "wallets[_who].lastDividendPeriod"
            IndexAccess
               Type: struct SmartBillions.Wallet storage ref
               Source: "wallets[_who]"
              Identifier wallets
                 Type: mapping(address => struct SmartBillions.Wallet storage ref)
                 Source: "wallets"
              Identifier _who
                 Type: address
                 Source: "_who"
          FunctionCall
             Type: uint16
             Source: "uint16(last)"
            ElementaryTypeNameExpression uint16
               Type: type(uint16)
               Source: "uint16"
            Identifier last
               Type: uint256
               Source: "last"
  FunctionDefinition "betPrize" - const
     Source: "function betPrize(Bet _player, uint24 _hash) constant private returns (uint) { // house fee 13.85%\r\n        uint24 bethash = uint24(_player.betHash);\r\n        uint24 hit = bethash ^ _hash;\r\n        uint24 matches =\r\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\r\n        if(matches == 6){\r\n            return(uint(_player.value) * 7000000);\r\n        }\r\n        if(matches == 5){\r\n            return(uint(_player.value) * 20000);\r\n        }\r\n        if(matches == 4){\r\n            return(uint(_player.value) * 500);\r\n        }\r\n        if(matches == 3){\r\n            return(uint(_player.value) * 25);\r\n        }\r\n        if(matches == 2){\r\n            return(uint(_player.value) * 3);\r\n        }\r\n        return(0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Bet _player, uint24 _hash)"
      VariableDeclaration "_player"
         Type: struct SmartBillions.Bet memory
         Source: "Bet _player"
        UserDefinedTypeName "Bet"
           Source: "Bet"
      VariableDeclaration "_hash"
         Type: uint24
         Source: "uint24 _hash"
        ElementaryTypeName uint24
           Source: "uint24"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{ // house fee 13.85%\r\n        uint24 bethash = uint24(_player.betHash);\r\n        uint24 hit = bethash ^ _hash;\r\n        uint24 matches =\r\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\r\n        if(matches == 6){\r\n            return(uint(_player.value) * 7000000);\r\n        }\r\n        if(matches == 5){\r\n            return(uint(_player.value) * 20000);\r\n        }\r\n        if(matches == 4){\r\n            return(uint(_player.value) * 500);\r\n        }\r\n        if(matches == 3){\r\n            return(uint(_player.value) * 25);\r\n        }\r\n        if(matches == 2){\r\n            return(uint(_player.value) * 3);\r\n        }\r\n        return(0);\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint24 bethash = uint24(_player.betHash)"
        VariableDeclaration "bethash"
           Type: uint24
           Source: "uint24 bethash"
          ElementaryTypeName uint24
             Source: "uint24"
        FunctionCall
           Type: uint24
           Source: "uint24(_player.betHash)"
          ElementaryTypeNameExpression uint24
             Type: type(uint24)
             Source: "uint24"
          MemberAccess to member betHash
             Type: uint32
             Source: "_player.betHash"
            Identifier _player
               Type: struct SmartBillions.Bet memory
               Source: "_player"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint24 hit = bethash ^ _hash"
        VariableDeclaration "hit"
           Type: uint24
           Source: "uint24 hit"
          ElementaryTypeName uint24
             Source: "uint24"
        BinaryOperation using operator ^
           Type: uint24
           Source: "bethash ^ _hash"
          Identifier bethash
             Type: uint24
             Source: "bethash"
          Identifier _hash
             Type: uint24
             Source: "_hash"
      VariableDeclarationStatement
         Gas costs: 347
         Source: "uint24 matches =\r\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00000) == 0 ? 1 : 0 )"
        VariableDeclaration "matches"
           Type: uint24
           Source: "uint24 matches"
          ElementaryTypeName uint24
             Source: "uint24"
        BinaryOperation using operator +
           Type: uint8
           Source: "((hit & 0xF) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00000) == 0 ? 1 : 0 )"
          BinaryOperation using operator +
             Type: uint8
             Source: "((hit & 0xF) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0000) == 0 ? 1 : 0 )"
            BinaryOperation using operator +
               Type: uint8
               Source: "((hit & 0xF) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF000) == 0 ? 1 : 0 )"
              BinaryOperation using operator +
                 Type: uint8
                 Source: "((hit & 0xF) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00) == 0 ? 1 : 0 )"
                BinaryOperation using operator +
                   Type: uint8
                   Source: "((hit & 0xF) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0) == 0 ? 1 : 0 )"
                  TupleExpression
                     Type: uint8
                     Source: "((hit & 0xF) == 0 ? 1 : 0 )"
                    Conditional
                       Type: uint8
                       Source: "(hit & 0xF) == 0 ? 1 : 0"
                      BinaryOperation using operator ==
                         Type: bool
                         Source: "(hit & 0xF) == 0"
                        TupleExpression
                           Type: uint24
                           Source: "(hit & 0xF)"
                          BinaryOperation using operator &
                             Type: uint24
                             Source: "hit & 0xF"
                            Identifier hit
                               Type: uint24
                               Source: "hit"
                            Literal, token: [no token] value: 0xF
                               Type: int_const 15
                               Source: "0xF"
                        Literal, token: [no token] value: 0
                           Type: int_const 0
                           Source: "0"
                      Literal, token: [no token] value: 1
                         Type: int_const 1
                         Source: "1"
                      Literal, token: [no token] value: 0
                         Type: int_const 0
                         Source: "0"
                  TupleExpression
                     Type: uint8
                     Source: "((hit & 0xF0) == 0 ? 1 : 0 )"
                    Conditional
                       Type: uint8
                       Source: "(hit & 0xF0) == 0 ? 1 : 0"
                      BinaryOperation using operator ==
                         Type: bool
                         Source: "(hit & 0xF0) == 0"
                        TupleExpression
                           Type: uint24
                           Source: "(hit & 0xF0)"
                          BinaryOperation using operator &
                             Type: uint24
                             Source: "hit & 0xF0"
                            Identifier hit
                               Type: uint24
                               Source: "hit"
                            Literal, token: [no token] value: 0xF0
                               Type: int_const 240
                               Source: "0xF0"
                        Literal, token: [no token] value: 0
                           Type: int_const 0
                           Source: "0"
                      Literal, token: [no token] value: 1
                         Type: int_const 1
                         Source: "1"
                      Literal, token: [no token] value: 0
                         Type: int_const 0
                         Source: "0"
                TupleExpression
                   Type: uint8
                   Source: "((hit & 0xF00) == 0 ? 1 : 0 )"
                  Conditional
                     Type: uint8
                     Source: "(hit & 0xF00) == 0 ? 1 : 0"
                    BinaryOperation using operator ==
                       Type: bool
                       Source: "(hit & 0xF00) == 0"
                      TupleExpression
                         Type: uint24
                         Source: "(hit & 0xF00)"
                        BinaryOperation using operator &
                           Type: uint24
                           Source: "hit & 0xF00"
                          Identifier hit
                             Type: uint24
                             Source: "hit"
                          Literal, token: [no token] value: 0xF00
                             Type: int_const 3840
                             Source: "0xF00"
                      Literal, token: [no token] value: 0
                         Type: int_const 0
                         Source: "0"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
              TupleExpression
                 Type: uint8
                 Source: "((hit & 0xF000) == 0 ? 1 : 0 )"
                Conditional
                   Type: uint8
                   Source: "(hit & 0xF000) == 0 ? 1 : 0"
                  BinaryOperation using operator ==
                     Type: bool
                     Source: "(hit & 0xF000) == 0"
                    TupleExpression
                       Type: uint24
                       Source: "(hit & 0xF000)"
                      BinaryOperation using operator &
                         Type: uint24
                         Source: "hit & 0xF000"
                        Identifier hit
                           Type: uint24
                           Source: "hit"
                        Literal, token: [no token] value: 0xF000
                           Type: int_const 61440
                           Source: "0xF000"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
            TupleExpression
               Type: uint8
               Source: "((hit & 0xF0000) == 0 ? 1 : 0 )"
              Conditional
                 Type: uint8
                 Source: "(hit & 0xF0000) == 0 ? 1 : 0"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "(hit & 0xF0000) == 0"
                  TupleExpression
                     Type: uint24
                     Source: "(hit & 0xF0000)"
                    BinaryOperation using operator &
                       Type: uint24
                       Source: "hit & 0xF0000"
                      Identifier hit
                         Type: uint24
                         Source: "hit"
                      Literal, token: [no token] value: 0xF0000
                         Type: int_const 983040
                         Source: "0xF0000"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
          TupleExpression
             Type: uint8
             Source: "((hit & 0xF00000) == 0 ? 1 : 0 )"
            Conditional
               Type: uint8
               Source: "(hit & 0xF00000) == 0 ? 1 : 0"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "(hit & 0xF00000) == 0"
                TupleExpression
                   Type: uint24
                   Source: "(hit & 0xF00000)"
                  BinaryOperation using operator &
                     Type: uint24
                     Source: "hit & 0xF00000"
                    Identifier hit
                       Type: uint24
                       Source: "hit"
                    Literal, token: [no token] value: 0xF00000
                       Type: int_const 15728640
                       Source: "0xF00000"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      IfStatement
         Source: "if(matches == 6){\r\n            return(uint(_player.value) * 7000000);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 15
           Source: "matches == 6"
          Identifier matches
             Type: uint24
             Source: "matches"
          Literal, token: [no token] value: 6
             Type: int_const 6
             Source: "6"
        Block
           Source: "{\r\n            return(uint(_player.value) * 7000000);\r\n        }"
          Return
             Gas costs: [???]
             Source: "return(uint(_player.value) * 7000000)"
            TupleExpression
               Type: uint256
               Source: "(uint(_player.value) * 7000000)"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "uint(_player.value) * 7000000"
                FunctionCall
                   Type: uint256
                   Source: "uint(_player.value)"
                  ElementaryTypeNameExpression uint
                     Type: type(uint256)
                     Source: "uint"
                  MemberAccess to member value
                     Type: uint192
                     Source: "_player.value"
                    Identifier _player
                       Type: struct SmartBillions.Bet memory
                       Source: "_player"
                Literal, token: [no token] value: 7000000
                   Type: int_const 7000000
                   Source: "7000000"
      IfStatement
         Source: "if(matches == 5){\r\n            return(uint(_player.value) * 20000);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 15
           Source: "matches == 5"
          Identifier matches
             Type: uint24
             Source: "matches"
          Literal, token: [no token] value: 5
             Type: int_const 5
             Source: "5"
        Block
           Source: "{\r\n            return(uint(_player.value) * 20000);\r\n        }"
          Return
             Gas costs: [???]
             Source: "return(uint(_player.value) * 20000)"
            TupleExpression
               Type: uint256
               Source: "(uint(_player.value) * 20000)"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "uint(_player.value) * 20000"
                FunctionCall
                   Type: uint256
                   Source: "uint(_player.value)"
                  ElementaryTypeNameExpression uint
                     Type: type(uint256)
                     Source: "uint"
                  MemberAccess to member value
                     Type: uint192
                     Source: "_player.value"
                    Identifier _player
                       Type: struct SmartBillions.Bet memory
                       Source: "_player"
                Literal, token: [no token] value: 20000
                   Type: int_const 20000
                   Source: "20000"
      IfStatement
         Source: "if(matches == 4){\r\n            return(uint(_player.value) * 500);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 15
           Source: "matches == 4"
          Identifier matches
             Type: uint24
             Source: "matches"
          Literal, token: [no token] value: 4
             Type: int_const 4
             Source: "4"
        Block
           Source: "{\r\n            return(uint(_player.value) * 500);\r\n        }"
          Return
             Gas costs: [???]
             Source: "return(uint(_player.value) * 500)"
            TupleExpression
               Type: uint256
               Source: "(uint(_player.value) * 500)"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "uint(_player.value) * 500"
                FunctionCall
                   Type: uint256
                   Source: "uint(_player.value)"
                  ElementaryTypeNameExpression uint
                     Type: type(uint256)
                     Source: "uint"
                  MemberAccess to member value
                     Type: uint192
                     Source: "_player.value"
                    Identifier _player
                       Type: struct SmartBillions.Bet memory
                       Source: "_player"
                Literal, token: [no token] value: 500
                   Type: int_const 500
                   Source: "500"
      IfStatement
         Source: "if(matches == 3){\r\n            return(uint(_player.value) * 25);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 15
           Source: "matches == 3"
          Identifier matches
             Type: uint24
             Source: "matches"
          Literal, token: [no token] value: 3
             Type: int_const 3
             Source: "3"
        Block
           Source: "{\r\n            return(uint(_player.value) * 25);\r\n        }"
          Return
             Gas costs: [???]
             Source: "return(uint(_player.value) * 25)"
            TupleExpression
               Type: uint256
               Source: "(uint(_player.value) * 25)"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "uint(_player.value) * 25"
                FunctionCall
                   Type: uint256
                   Source: "uint(_player.value)"
                  ElementaryTypeNameExpression uint
                     Type: type(uint256)
                     Source: "uint"
                  MemberAccess to member value
                     Type: uint192
                     Source: "_player.value"
                    Identifier _player
                       Type: struct SmartBillions.Bet memory
                       Source: "_player"
                Literal, token: [no token] value: 25
                   Type: int_const 25
                   Source: "25"
      IfStatement
         Source: "if(matches == 2){\r\n            return(uint(_player.value) * 3);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 15
           Source: "matches == 2"
          Identifier matches
             Type: uint24
             Source: "matches"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
        Block
           Source: "{\r\n            return(uint(_player.value) * 3);\r\n        }"
          Return
             Gas costs: [???]
             Source: "return(uint(_player.value) * 3)"
            TupleExpression
               Type: uint256
               Source: "(uint(_player.value) * 3)"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "uint(_player.value) * 3"
                FunctionCall
                   Type: uint256
                   Source: "uint(_player.value)"
                  ElementaryTypeNameExpression uint
                     Type: type(uint256)
                     Source: "uint"
                  MemberAccess to member value
                     Type: uint192
                     Source: "_player.value"
                    Identifier _player
                       Type: struct SmartBillions.Bet memory
                       Source: "_player"
                Literal, token: [no token] value: 3
                   Type: int_const 3
                   Source: "3"
      Return
         Gas costs: 8
         Source: "return(0)"
        TupleExpression
           Type: int_const 0
           Source: "(0)"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "betOf" - public - const
     Source: "function betOf(address _who) constant external returns (uint)  {\r\n        Bet memory player = bets[_who];\r\n        if( (player.value==0) ||\r\n            (player.blockNum<=1) ||\r\n            (block.number<player.blockNum) ||\r\n            (block.number>=player.blockNum + (10 * hashesSize))){\r\n            return(0);\r\n        }\r\n        if(block.number<player.blockNum+256){\r\n            return(betPrize(player,uint24(block.blockhash(player.blockNum))));\r\n        }\r\n        if(hashFirst>0){\r\n            uint32 hash = getHash(player.blockNum);\r\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                return(uint(player.value));\r\n            }\r\n            else{\r\n                return(betPrize(player,uint24(hash)));\r\n            }\r\n\t}\r\n        return(0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _who)"
      VariableDeclaration "_who"
         Type: address
         Source: "address _who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        Bet memory player = bets[_who];\r\n        if( (player.value==0) ||\r\n            (player.blockNum<=1) ||\r\n            (block.number<player.blockNum) ||\r\n            (block.number>=player.blockNum + (10 * hashesSize))){\r\n            return(0);\r\n        }\r\n        if(block.number<player.blockNum+256){\r\n            return(betPrize(player,uint24(block.blockhash(player.blockNum))));\r\n        }\r\n        if(hashFirst>0){\r\n            uint32 hash = getHash(player.blockNum);\r\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                return(uint(player.value));\r\n            }\r\n            else{\r\n                return(betPrize(player,uint24(hash)));\r\n            }\r\n\t}\r\n        return(0);\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "Bet memory player = bets[_who]"
        VariableDeclaration "player"
           Type: struct SmartBillions.Bet memory
           Source: "Bet memory player"
          UserDefinedTypeName "Bet"
             Source: "Bet"
        IndexAccess
           Type: struct SmartBillions.Bet storage ref
           Source: "bets[_who]"
          Identifier bets
             Type: mapping(address => struct SmartBillions.Bet storage ref)
             Source: "bets"
          Identifier _who
             Type: address
             Source: "_who"
      IfStatement
         Source: "if( (player.value==0) ||\r\n            (player.blockNum<=1) ||\r\n            (block.number<player.blockNum) ||\r\n            (block.number>=player.blockNum + (10 * hashesSize))){\r\n            return(0);\r\n        }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: [???]
           Source: "(player.value==0) ||\r\n            (player.blockNum<=1) ||\r\n            (block.number<player.blockNum) ||\r\n            (block.number>=player.blockNum + (10 * hashesSize))"
          BinaryOperation using operator ||
             Type: bool
             Source: "(player.value==0) ||\r\n            (player.blockNum<=1) ||\r\n            (block.number<player.blockNum)"
            BinaryOperation using operator ||
               Type: bool
               Source: "(player.value==0) ||\r\n            (player.blockNum<=1)"
              TupleExpression
                 Type: bool
                 Source: "(player.value==0)"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "player.value==0"
                  MemberAccess to member value
                     Type: uint192
                     Source: "player.value"
                    Identifier player
                       Type: struct SmartBillions.Bet memory
                       Source: "player"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              TupleExpression
                 Type: bool
                 Source: "(player.blockNum<=1)"
                BinaryOperation using operator <=
                   Type: bool
                   Source: "player.blockNum<=1"
                  MemberAccess to member blockNum
                     Type: uint32
                     Source: "player.blockNum"
                    Identifier player
                       Type: struct SmartBillions.Bet memory
                       Source: "player"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
            TupleExpression
               Type: bool
               Source: "(block.number<player.blockNum)"
              BinaryOperation using operator <
                 Type: bool
                 Source: "block.number<player.blockNum"
                MemberAccess to member number
                   Type: uint256
                   Source: "block.number"
                  Identifier block
                     Type: block
                     Source: "block"
                MemberAccess to member blockNum
                   Type: uint32
                   Source: "player.blockNum"
                  Identifier player
                     Type: struct SmartBillions.Bet memory
                     Source: "player"
          TupleExpression
             Type: bool
             Source: "(block.number>=player.blockNum + (10 * hashesSize))"
            BinaryOperation using operator >=
               Type: bool
               Source: "block.number>=player.blockNum + (10 * hashesSize)"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "player.blockNum + (10 * hashesSize)"
                MemberAccess to member blockNum
                   Type: uint32
                   Source: "player.blockNum"
                  Identifier player
                     Type: struct SmartBillions.Bet memory
                     Source: "player"
                TupleExpression
                   Type: uint256
                   Source: "(10 * hashesSize)"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "10 * hashesSize"
                    Literal, token: [no token] value: 10
                       Type: int_const 10
                       Source: "10"
                    Identifier hashesSize
                       Type: uint256
                       Source: "hashesSize"
        Block
           Source: "{\r\n            return(0);\r\n        }"
          Return
             Gas costs: 19
             Source: "return(0)"
            TupleExpression
               Type: int_const 0
               Source: "(0)"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      IfStatement
         Source: "if(block.number<player.blockNum+256){\r\n            return(betPrize(player,uint24(block.blockhash(player.blockNum))));\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "block.number<player.blockNum+256"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          BinaryOperation using operator +
             Type: uint32
             Source: "player.blockNum+256"
            MemberAccess to member blockNum
               Type: uint32
               Source: "player.blockNum"
              Identifier player
                 Type: struct SmartBillions.Bet memory
                 Source: "player"
            Literal, token: [no token] value: 256
               Type: int_const 256
               Source: "256"
        Block
           Source: "{\r\n            return(betPrize(player,uint24(block.blockhash(player.blockNum))));\r\n        }"
          Return
             Gas costs: [???]
             Source: "return(betPrize(player,uint24(block.blockhash(player.blockNum))))"
            TupleExpression
               Type: uint256
               Source: "(betPrize(player,uint24(block.blockhash(player.blockNum))))"
              FunctionCall
                 Type: uint256
                 Source: "betPrize(player,uint24(block.blockhash(player.blockNum)))"
                Identifier betPrize
                   Type: function (struct SmartBillions.Bet memory,uint24) view returns (uint256)
                   Source: "betPrize"
                Identifier player
                   Type: struct SmartBillions.Bet memory
                   Source: "player"
                FunctionCall
                   Type: uint24
                   Source: "uint24(block.blockhash(player.blockNum))"
                  ElementaryTypeNameExpression uint24
                     Type: type(uint24)
                     Source: "uint24"
                  FunctionCall
                     Type: bytes32
                     Source: "block.blockhash(player.blockNum)"
                    MemberAccess to member blockhash
                       Type: function (uint256) view returns (bytes32)
                       Source: "block.blockhash"
                      Identifier block
                         Type: block
                         Source: "block"
                    MemberAccess to member blockNum
                       Type: uint32
                       Source: "player.blockNum"
                      Identifier player
                         Type: struct SmartBillions.Bet memory
                         Source: "player"
      IfStatement
         Source: "if(hashFirst>0){\r\n            uint32 hash = getHash(player.blockNum);\r\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                return(uint(player.value));\r\n            }\r\n            else{\r\n                return(betPrize(player,uint24(hash)));\r\n            }\r\n\t}"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "hashFirst>0"
          Identifier hashFirst
             Type: uint256
             Source: "hashFirst"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            uint32 hash = getHash(player.blockNum);\r\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                return(uint(player.value));\r\n            }\r\n            else{\r\n                return(betPrize(player,uint24(hash)));\r\n            }\r\n\t}"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "uint32 hash = getHash(player.blockNum)"
            VariableDeclaration "hash"
               Type: uint32
               Source: "uint32 hash"
              ElementaryTypeName uint32
                 Source: "uint32"
            FunctionCall
               Type: uint32
               Source: "getHash(player.blockNum)"
              Identifier getHash
                 Type: function (uint256) view returns (uint32)
                 Source: "getHash"
              MemberAccess to member blockNum
                 Type: uint32
                 Source: "player.blockNum"
                Identifier player
                   Type: struct SmartBillions.Bet memory
                   Source: "player"
          IfStatement
             Source: "if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                return(uint(player.value));\r\n            }\r\n            else{\r\n                return(betPrize(player,uint24(hash)));\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 15
               Source: "hash == 0x1000000"
              Identifier hash
                 Type: uint32
                 Source: "hash"
              Literal, token: [no token] value: 0x1000000
                 Type: int_const 16777216
                 Source: "0x1000000"
            Block
               Source: "{ // load hash failed :-(, return funds\r\n                return(uint(player.value));\r\n            }"
              Return
                 Gas costs: [???]
                 Source: "return(uint(player.value))"
                TupleExpression
                   Type: uint256
                   Source: "(uint(player.value))"
                  FunctionCall
                     Type: uint256
                     Source: "uint(player.value)"
                    ElementaryTypeNameExpression uint
                       Type: type(uint256)
                       Source: "uint"
                    MemberAccess to member value
                       Type: uint192
                       Source: "player.value"
                      Identifier player
                         Type: struct SmartBillions.Bet memory
                         Source: "player"
            Block
               Source: "{\r\n                return(betPrize(player,uint24(hash)));\r\n            }"
              Return
                 Gas costs: 37
                 Source: "return(betPrize(player,uint24(hash)))"
                TupleExpression
                   Type: uint256
                   Source: "(betPrize(player,uint24(hash)))"
                  FunctionCall
                     Type: uint256
                     Source: "betPrize(player,uint24(hash))"
                    Identifier betPrize
                       Type: function (struct SmartBillions.Bet memory,uint24) view returns (uint256)
                       Source: "betPrize"
                    Identifier player
                       Type: struct SmartBillions.Bet memory
                       Source: "player"
                    FunctionCall
                       Type: uint24
                       Source: "uint24(hash)"
                      ElementaryTypeNameExpression uint24
                         Type: type(uint24)
                         Source: "uint24"
                      Identifier hash
                         Type: uint32
                         Source: "hash"
      Return
         Gas costs: 8
         Source: "return(0)"
        TupleExpression
           Type: int_const 0
           Source: "(0)"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "won" - public
     Source: "function won() public {\r\n        Bet memory player = bets[msg.sender];\r\n        if(player.blockNum==0){ // create a new player\r\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n            return;\r\n        }\r\n        if((player.value==0) || (player.blockNum==1)){\r\n            payWallet();\r\n            return;\r\n        }\r\n        require(block.number>player.blockNum); // if there is an active bet, throw()\r\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\r\n            LogLate(msg.sender,player.blockNum,block.number);\r\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n            return;\r\n        }\r\n        uint prize = 0;\r\n        uint32 hash = 0;\r\n        if(block.number<player.blockNum+256){\r\n            hash = uint24(block.blockhash(player.blockNum));\r\n            prize = betPrize(player,uint24(hash));\r\n        }\r\n        else {\r\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\r\n                hash = getHash(player.blockNum);\r\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                    prize = uint(player.value);\r\n                }\r\n                else{\r\n                    prize = betPrize(player,uint24(hash));\r\n                }\r\n\t    }\r\n            else{\r\n                LogLate(msg.sender,player.blockNum,block.number);\r\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n                return();\r\n            }\r\n        }\r\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n        if(prize>0) {\r\n            LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\r\n            if(prize > maxWin){\r\n                maxWin = prize;\r\n                LogRecordWin(msg.sender,prize);\r\n            }\r\n            pay(prize);\r\n        }\r\n        else{\r\n            LogLoss(msg.sender,uint(player.betHash),uint(hash));\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        Bet memory player = bets[msg.sender];\r\n        if(player.blockNum==0){ // create a new player\r\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n            return;\r\n        }\r\n        if((player.value==0) || (player.blockNum==1)){\r\n            payWallet();\r\n            return;\r\n        }\r\n        require(block.number>player.blockNum); // if there is an active bet, throw()\r\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\r\n            LogLate(msg.sender,player.blockNum,block.number);\r\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n            return;\r\n        }\r\n        uint prize = 0;\r\n        uint32 hash = 0;\r\n        if(block.number<player.blockNum+256){\r\n            hash = uint24(block.blockhash(player.blockNum));\r\n            prize = betPrize(player,uint24(hash));\r\n        }\r\n        else {\r\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\r\n                hash = getHash(player.blockNum);\r\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                    prize = uint(player.value);\r\n                }\r\n                else{\r\n                    prize = betPrize(player,uint24(hash));\r\n                }\r\n\t    }\r\n            else{\r\n                LogLate(msg.sender,player.blockNum,block.number);\r\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n                return();\r\n            }\r\n        }\r\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n        if(prize>0) {\r\n            LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\r\n            if(prize > maxWin){\r\n                maxWin = prize;\r\n                LogRecordWin(msg.sender,prize);\r\n            }\r\n            pay(prize);\r\n        }\r\n        else{\r\n            LogLoss(msg.sender,uint(player.betHash),uint(hash));\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "Bet memory player = bets[msg.sender]"
        VariableDeclaration "player"
           Type: struct SmartBillions.Bet memory
           Source: "Bet memory player"
          UserDefinedTypeName "Bet"
             Source: "Bet"
        IndexAccess
           Type: struct SmartBillions.Bet storage ref
           Source: "bets[msg.sender]"
          Identifier bets
             Type: mapping(address => struct SmartBillions.Bet storage ref)
             Source: "bets"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if(player.blockNum==0){ // create a new player\r\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n            return;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: [???]
           Source: "player.blockNum==0"
          MemberAccess to member blockNum
             Type: uint32
             Source: "player.blockNum"
            Identifier player
               Type: struct SmartBillions.Bet memory
               Source: "player"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{ // create a new player\r\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n            return;\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1})"
            Assignment using operator =
               Type: struct SmartBillions.Bet storage ref
               Source: "bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1})"
              IndexAccess
                 Type: struct SmartBillions.Bet storage ref
                 Source: "bets[msg.sender]"
                Identifier bets
                   Type: mapping(address => struct SmartBillions.Bet storage ref)
                   Source: "bets"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              FunctionCall
                 Type: struct SmartBillions.Bet memory
                 Source: "Bet({value: 0, betHash: 0, blockNum: 1})"
                Identifier Bet
                   Type: type(struct SmartBillions.Bet storage pointer)
                   Source: "Bet"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
          Return
             Gas costs: 11
             Source: "return;"
      IfStatement
         Source: "if((player.value==0) || (player.blockNum==1)){\r\n            payWallet();\r\n            return;\r\n        }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: [???]
           Source: "(player.value==0) || (player.blockNum==1)"
          TupleExpression
             Type: bool
             Source: "(player.value==0)"
            BinaryOperation using operator ==
               Type: bool
               Source: "player.value==0"
              MemberAccess to member value
                 Type: uint192
                 Source: "player.value"
                Identifier player
                   Type: struct SmartBillions.Bet memory
                   Source: "player"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          TupleExpression
             Type: bool
             Source: "(player.blockNum==1)"
            BinaryOperation using operator ==
               Type: bool
               Source: "player.blockNum==1"
              MemberAccess to member blockNum
                 Type: uint32
                 Source: "player.blockNum"
                Identifier player
                   Type: struct SmartBillions.Bet memory
                   Source: "player"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
        Block
           Source: "{\r\n            payWallet();\r\n            return;\r\n        }"
          ExpressionStatement
             Gas costs: 15
             Source: "payWallet()"
            FunctionCall
               Type: tuple()
               Source: "payWallet()"
              Identifier payWallet
                 Type: function ()
                 Source: "payWallet"
          Return
             Gas costs: 11
             Source: "return;"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(block.number>player.blockNum)"
        FunctionCall
           Type: tuple()
           Source: "require(block.number>player.blockNum)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "block.number>player.blockNum"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            MemberAccess to member blockNum
               Type: uint32
               Source: "player.blockNum"
              Identifier player
                 Type: struct SmartBillions.Bet memory
                 Source: "player"
      IfStatement
         Source: "if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\r\n            LogLate(msg.sender,player.blockNum,block.number);\r\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n            return;\r\n        }"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: [???]
           Source: "player.blockNum + (10 * hashesSize) <= block.number"
          BinaryOperation using operator +
             Type: uint256
             Source: "player.blockNum + (10 * hashesSize)"
            MemberAccess to member blockNum
               Type: uint32
               Source: "player.blockNum"
              Identifier player
                 Type: struct SmartBillions.Bet memory
                 Source: "player"
            TupleExpression
               Type: uint256
               Source: "(10 * hashesSize)"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "10 * hashesSize"
                Literal, token: [no token] value: 10
                   Type: int_const 10
                   Source: "10"
                Identifier hashesSize
                   Type: uint256
                   Source: "hashesSize"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
        Block
           Source: "{ // last bet too long ago, lost !\r\n            LogLate(msg.sender,player.blockNum,block.number);\r\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n            return;\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "LogLate(msg.sender,player.blockNum,block.number)"
            FunctionCall
               Type: tuple()
               Source: "LogLate(msg.sender,player.blockNum,block.number)"
              Identifier LogLate
                 Type: function (address,uint256,uint256)
                 Source: "LogLate"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              MemberAccess to member blockNum
                 Type: uint32
                 Source: "player.blockNum"
                Identifier player
                   Type: struct SmartBillions.Bet memory
                   Source: "player"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
          ExpressionStatement
             Gas costs: [???]
             Source: "bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1})"
            Assignment using operator =
               Type: struct SmartBillions.Bet storage ref
               Source: "bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1})"
              IndexAccess
                 Type: struct SmartBillions.Bet storage ref
                 Source: "bets[msg.sender]"
                Identifier bets
                   Type: mapping(address => struct SmartBillions.Bet storage ref)
                   Source: "bets"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              FunctionCall
                 Type: struct SmartBillions.Bet memory
                 Source: "Bet({value: 0, betHash: 0, blockNum: 1})"
                Identifier Bet
                   Type: type(struct SmartBillions.Bet storage pointer)
                   Source: "Bet"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
          Return
             Gas costs: 11
             Source: "return;"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint prize = 0"
        VariableDeclaration "prize"
           Type: uint256
           Source: "uint prize"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint32 hash = 0"
        VariableDeclaration "hash"
           Type: uint32
           Source: "uint32 hash"
          ElementaryTypeName uint32
             Source: "uint32"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      IfStatement
         Source: "if(block.number<player.blockNum+256){\r\n            hash = uint24(block.blockhash(player.blockNum));\r\n            prize = betPrize(player,uint24(hash));\r\n        }\r\n        else {\r\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\r\n                hash = getHash(player.blockNum);\r\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                    prize = uint(player.value);\r\n                }\r\n                else{\r\n                    prize = betPrize(player,uint24(hash));\r\n                }\r\n\t    }\r\n            else{\r\n                LogLate(msg.sender,player.blockNum,block.number);\r\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n                return();\r\n            }\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "block.number<player.blockNum+256"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          BinaryOperation using operator +
             Type: uint32
             Source: "player.blockNum+256"
            MemberAccess to member blockNum
               Type: uint32
               Source: "player.blockNum"
              Identifier player
                 Type: struct SmartBillions.Bet memory
                 Source: "player"
            Literal, token: [no token] value: 256
               Type: int_const 256
               Source: "256"
        Block
           Source: "{\r\n            hash = uint24(block.blockhash(player.blockNum));\r\n            prize = betPrize(player,uint24(hash));\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "hash = uint24(block.blockhash(player.blockNum))"
            Assignment using operator =
               Type: uint32
               Source: "hash = uint24(block.blockhash(player.blockNum))"
              Identifier hash
                 Type: uint32
                 Source: "hash"
              FunctionCall
                 Type: uint24
                 Source: "uint24(block.blockhash(player.blockNum))"
                ElementaryTypeNameExpression uint24
                   Type: type(uint24)
                   Source: "uint24"
                FunctionCall
                   Type: bytes32
                   Source: "block.blockhash(player.blockNum)"
                  MemberAccess to member blockhash
                     Type: function (uint256) view returns (bytes32)
                     Source: "block.blockhash"
                    Identifier block
                       Type: block
                       Source: "block"
                  MemberAccess to member blockNum
                     Type: uint32
                     Source: "player.blockNum"
                    Identifier player
                       Type: struct SmartBillions.Bet memory
                       Source: "player"
          ExpressionStatement
             Gas costs: 26
             Source: "prize = betPrize(player,uint24(hash))"
            Assignment using operator =
               Type: uint256
               Source: "prize = betPrize(player,uint24(hash))"
              Identifier prize
                 Type: uint256
                 Source: "prize"
              FunctionCall
                 Type: uint256
                 Source: "betPrize(player,uint24(hash))"
                Identifier betPrize
                   Type: function (struct SmartBillions.Bet memory,uint24) view returns (uint256)
                   Source: "betPrize"
                Identifier player
                   Type: struct SmartBillions.Bet memory
                   Source: "player"
                FunctionCall
                   Type: uint24
                   Source: "uint24(hash)"
                  ElementaryTypeNameExpression uint24
                     Type: type(uint24)
                     Source: "uint24"
                  Identifier hash
                     Type: uint32
                     Source: "hash"
        Block
           Source: "{\r\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\r\n                hash = getHash(player.blockNum);\r\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                    prize = uint(player.value);\r\n                }\r\n                else{\r\n                    prize = betPrize(player,uint24(hash));\r\n                }\r\n\t    }\r\n            else{\r\n                LogLate(msg.sender,player.blockNum,block.number);\r\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n                return();\r\n            }\r\n        }"
          IfStatement
             Source: "if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\r\n                hash = getHash(player.blockNum);\r\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                    prize = uint(player.value);\r\n                }\r\n                else{\r\n                    prize = betPrize(player,uint24(hash));\r\n                }\r\n\t    }\r\n            else{\r\n                LogLate(msg.sender,player.blockNum,block.number);\r\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n                return();\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 209
               Source: "hashFirst>0"
              Identifier hashFirst
                 Type: uint256
                 Source: "hashFirst"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\r\n                hash = getHash(player.blockNum);\r\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                    prize = uint(player.value);\r\n                }\r\n                else{\r\n                    prize = betPrize(player,uint24(hash));\r\n                }\r\n\t    }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "hash = getHash(player.blockNum)"
                Assignment using operator =
                   Type: uint32
                   Source: "hash = getHash(player.blockNum)"
                  Identifier hash
                     Type: uint32
                     Source: "hash"
                  FunctionCall
                     Type: uint32
                     Source: "getHash(player.blockNum)"
                    Identifier getHash
                       Type: function (uint256) view returns (uint32)
                       Source: "getHash"
                    MemberAccess to member blockNum
                       Type: uint32
                       Source: "player.blockNum"
                      Identifier player
                         Type: struct SmartBillions.Bet memory
                         Source: "player"
              IfStatement
                 Source: "if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                    prize = uint(player.value);\r\n                }\r\n                else{\r\n                    prize = betPrize(player,uint24(hash));\r\n                }"
                BinaryOperation using operator ==
                   Type: bool
                   Gas costs: 15
                   Source: "hash == 0x1000000"
                  Identifier hash
                     Type: uint32
                     Source: "hash"
                  Literal, token: [no token] value: 0x1000000
                     Type: int_const 16777216
                     Source: "0x1000000"
                Block
                   Source: "{ // load hash failed :-(, return funds\r\n                    prize = uint(player.value);\r\n                }"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "prize = uint(player.value)"
                    Assignment using operator =
                       Type: uint256
                       Source: "prize = uint(player.value)"
                      Identifier prize
                         Type: uint256
                         Source: "prize"
                      FunctionCall
                         Type: uint256
                         Source: "uint(player.value)"
                        ElementaryTypeNameExpression uint
                           Type: type(uint256)
                           Source: "uint"
                        MemberAccess to member value
                           Type: uint192
                           Source: "player.value"
                          Identifier player
                             Type: struct SmartBillions.Bet memory
                             Source: "player"
                Block
                   Source: "{\r\n                    prize = betPrize(player,uint24(hash));\r\n                }"
                  ExpressionStatement
                     Gas costs: 15
                     Source: "prize = betPrize(player,uint24(hash))"
                    Assignment using operator =
                       Type: uint256
                       Source: "prize = betPrize(player,uint24(hash))"
                      Identifier prize
                         Type: uint256
                         Source: "prize"
                      FunctionCall
                         Type: uint256
                         Source: "betPrize(player,uint24(hash))"
                        Identifier betPrize
                           Type: function (struct SmartBillions.Bet memory,uint24) view returns (uint256)
                           Source: "betPrize"
                        Identifier player
                           Type: struct SmartBillions.Bet memory
                           Source: "player"
                        FunctionCall
                           Type: uint24
                           Source: "uint24(hash)"
                          ElementaryTypeNameExpression uint24
                             Type: type(uint24)
                             Source: "uint24"
                          Identifier hash
                             Type: uint32
                             Source: "hash"
            Block
               Source: "{\r\n                LogLate(msg.sender,player.blockNum,block.number);\r\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n                return();\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "LogLate(msg.sender,player.blockNum,block.number)"
                FunctionCall
                   Type: tuple()
                   Source: "LogLate(msg.sender,player.blockNum,block.number)"
                  Identifier LogLate
                     Type: function (address,uint256,uint256)
                     Source: "LogLate"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  MemberAccess to member blockNum
                     Type: uint32
                     Source: "player.blockNum"
                    Identifier player
                       Type: struct SmartBillions.Bet memory
                       Source: "player"
                  MemberAccess to member number
                     Type: uint256
                     Source: "block.number"
                    Identifier block
                       Type: block
                       Source: "block"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1})"
                Assignment using operator =
                   Type: struct SmartBillions.Bet storage ref
                   Source: "bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1})"
                  IndexAccess
                     Type: struct SmartBillions.Bet storage ref
                     Source: "bets[msg.sender]"
                    Identifier bets
                       Type: mapping(address => struct SmartBillions.Bet storage ref)
                       Source: "bets"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                  FunctionCall
                     Type: struct SmartBillions.Bet memory
                     Source: "Bet({value: 0, betHash: 0, blockNum: 1})"
                    Identifier Bet
                       Type: type(struct SmartBillions.Bet storage pointer)
                       Source: "Bet"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
              Return
                 Gas costs: 11
                 Source: "return()"
                TupleExpression
                   Type: tuple()
                   Source: "()"
      ExpressionStatement
         Gas costs: [???]
         Source: "bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1})"
        Assignment using operator =
           Type: struct SmartBillions.Bet storage ref
           Source: "bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1})"
          IndexAccess
             Type: struct SmartBillions.Bet storage ref
             Source: "bets[msg.sender]"
            Identifier bets
               Type: mapping(address => struct SmartBillions.Bet storage ref)
               Source: "bets"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: struct SmartBillions.Bet memory
             Source: "Bet({value: 0, betHash: 0, blockNum: 1})"
            Identifier Bet
               Type: type(struct SmartBillions.Bet storage pointer)
               Source: "Bet"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      IfStatement
         Source: "if(prize>0) {\r\n            LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\r\n            if(prize > maxWin){\r\n                maxWin = prize;\r\n                LogRecordWin(msg.sender,prize);\r\n            }\r\n            pay(prize);\r\n        }\r\n        else{\r\n            LogLoss(msg.sender,uint(player.betHash),uint(hash));\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "prize>0"
          Identifier prize
             Type: uint256
             Source: "prize"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\r\n            if(prize > maxWin){\r\n                maxWin = prize;\r\n                LogRecordWin(msg.sender,prize);\r\n            }\r\n            pay(prize);\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "LogWin(msg.sender,uint(player.betHash),uint(hash),prize)"
            FunctionCall
               Type: tuple()
               Source: "LogWin(msg.sender,uint(player.betHash),uint(hash),prize)"
              Identifier LogWin
                 Type: function (address,uint256,uint256,uint256)
                 Source: "LogWin"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              FunctionCall
                 Type: uint256
                 Source: "uint(player.betHash)"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                MemberAccess to member betHash
                   Type: uint32
                   Source: "player.betHash"
                  Identifier player
                     Type: struct SmartBillions.Bet memory
                     Source: "player"
              FunctionCall
                 Type: uint256
                 Source: "uint(hash)"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                Identifier hash
                   Type: uint32
                   Source: "hash"
              Identifier prize
                 Type: uint256
                 Source: "prize"
          IfStatement
             Source: "if(prize > maxWin){\r\n                maxWin = prize;\r\n                LogRecordWin(msg.sender,prize);\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 209
               Source: "prize > maxWin"
              Identifier prize
                 Type: uint256
                 Source: "prize"
              Identifier maxWin
                 Type: uint256
                 Source: "maxWin"
            Block
               Source: "{\r\n                maxWin = prize;\r\n                LogRecordWin(msg.sender,prize);\r\n            }"
              ExpressionStatement
                 Gas costs: 20014
                 Source: "maxWin = prize"
                Assignment using operator =
                   Type: uint256
                   Source: "maxWin = prize"
                  Identifier maxWin
                     Type: uint256
                     Source: "maxWin"
                  Identifier prize
                     Type: uint256
                     Source: "prize"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "LogRecordWin(msg.sender,prize)"
                FunctionCall
                   Type: tuple()
                   Source: "LogRecordWin(msg.sender,prize)"
                  Identifier LogRecordWin
                     Type: function (address,uint256)
                     Source: "LogRecordWin"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier prize
                     Type: uint256
                     Source: "prize"
          ExpressionStatement
             Gas costs: 7
             Source: "pay(prize)"
            FunctionCall
               Type: tuple()
               Source: "pay(prize)"
              Identifier pay
                 Type: function (uint256)
                 Source: "pay"
              Identifier prize
                 Type: uint256
                 Source: "prize"
        Block
           Source: "{\r\n            LogLoss(msg.sender,uint(player.betHash),uint(hash));\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "LogLoss(msg.sender,uint(player.betHash),uint(hash))"
            FunctionCall
               Type: tuple()
               Source: "LogLoss(msg.sender,uint(player.betHash),uint(hash))"
              Identifier LogLoss
                 Type: function (address,uint256,uint256)
                 Source: "LogLoss"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              FunctionCall
                 Type: uint256
                 Source: "uint(player.betHash)"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                MemberAccess to member betHash
                   Type: uint32
                   Source: "player.betHash"
                  Identifier player
                     Type: struct SmartBillions.Bet memory
                     Source: "player"
              FunctionCall
                 Type: uint256
                 Source: "uint(hash)"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                Identifier hash
                   Type: uint32
                   Source: "hash"
  FunctionDefinition "" - public
     Source: "function () payable external {\r\n        if(msg.value > 0){\r\n            play();\r\n            return;\r\n        }\r\n        //check for dividends and other assets\r\n        if(investStart == 0 && balances[msg.sender]>0){\r\n            commitDividend(msg.sender);}\r\n        won(); // will run payWallet() if nothing else available\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if(msg.value > 0){\r\n            play();\r\n            return;\r\n        }\r\n        //check for dividends and other assets\r\n        if(investStart == 0 && balances[msg.sender]>0){\r\n            commitDividend(msg.sender);}\r\n        won(); // will run payWallet() if nothing else available\r\n    }"
      IfStatement
         Source: "if(msg.value > 0){\r\n            play();\r\n            return;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 8
           Source: "msg.value > 0"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            play();\r\n            return;\r\n        }"
          ExpressionStatement
             Gas costs: 17
             Source: "play()"
            FunctionCall
               Type: uint256
               Source: "play()"
              Identifier play
                 Type: function () returns (uint256)
                 Source: "play"
          Return
             Gas costs: 11
             Source: "return;"
      IfStatement
         Source: "if(investStart == 0 && balances[msg.sender]>0){\r\n            commitDividend(msg.sender);}"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 535
           Source: "investStart == 0 && balances[msg.sender]>0"
          BinaryOperation using operator ==
             Type: bool
             Source: "investStart == 0"
            Identifier investStart
               Type: uint256
               Source: "investStart"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator >
             Type: bool
             Source: "balances[msg.sender]>0"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            commitDividend(msg.sender);}"
          ExpressionStatement
             Gas costs: 17
             Source: "commitDividend(msg.sender)"
            FunctionCall
               Type: tuple()
               Source: "commitDividend(msg.sender)"
              Identifier commitDividend
                 Type: function (address)
                 Source: "commitDividend"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 4
         Source: "won()"
        FunctionCall
           Type: tuple()
           Source: "won()"
          Identifier won
             Type: function ()
             Source: "won"
  FunctionDefinition "play" - public
     Source: "function play() payable public returns (uint) {\r\n        return playSystem(uint(sha3(msg.sender,block.number)), address(0));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return playSystem(uint(sha3(msg.sender,block.number)), address(0));\r\n    }"
      Return
         Gas costs: [???]
         Source: "return playSystem(uint(sha3(msg.sender,block.number)), address(0))"
        FunctionCall
           Type: uint256
           Source: "playSystem(uint(sha3(msg.sender,block.number)), address(0))"
          Identifier playSystem
             Type: function (uint256,address) returns (uint256)
             Source: "playSystem"
          FunctionCall
             Type: uint256
             Source: "uint(sha3(msg.sender,block.number))"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            FunctionCall
               Type: bytes32
               Source: "sha3(msg.sender,block.number)"
              Identifier sha3
                 Type: function () pure returns (bytes32)
                 Source: "sha3"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "playRandom" - public
     Source: "function playRandom(address _partner) payable public returns (uint) {\r\n        return playSystem(uint(sha3(msg.sender,block.number)), _partner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _partner)"
      VariableDeclaration "_partner"
         Type: address
         Source: "address _partner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return playSystem(uint(sha3(msg.sender,block.number)), _partner);\r\n    }"
      Return
         Gas costs: [???]
         Source: "return playSystem(uint(sha3(msg.sender,block.number)), _partner)"
        FunctionCall
           Type: uint256
           Source: "playSystem(uint(sha3(msg.sender,block.number)), _partner)"
          Identifier playSystem
             Type: function (uint256,address) returns (uint256)
             Source: "playSystem"
          FunctionCall
             Type: uint256
             Source: "uint(sha3(msg.sender,block.number))"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            FunctionCall
               Type: bytes32
               Source: "sha3(msg.sender,block.number)"
              Identifier sha3
                 Type: function () pure returns (bytes32)
                 Source: "sha3"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
          Identifier _partner
             Type: address
             Source: "_partner"
  FunctionDefinition "playSystem" - public
     Source: "function playSystem(uint _hash, address _partner) payable public returns (uint) {\r\n        won(); // check if player did not win \r\n        uint24 bethash = uint24(_hash);\r\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\r\n        if(msg.value > 0){\r\n            if(investStart==0) { // dividends only after investment finished\r\n                dividends[dividendPeriod] += msg.value / 34; // 3% dividend\r\n            }\r\n            if(_partner != address(0)) {\r\n                uint fee = msg.value / 100;\r\n                walletBalance += fee;\r\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\r\n            }\r\n            if(hashNext < block.number + 3) {\r\n                hashNext = block.number + 3;\r\n                hashBetSum = msg.value;\r\n            }\r\n            else{\r\n                if(hashBetSum > hashBetMax) {\r\n                    hashNext++;\r\n                    hashBetSum = msg.value;\r\n                }\r\n                else{\r\n                    hashBetSum += msg.value;\r\n                }\r\n            }\r\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\r\n            LogBet(msg.sender,uint(bethash),hashNext,msg.value);\r\n        }\r\n        putHash(); // players help collecing data\r\n        return(hashNext);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _hash, address _partner)"
      VariableDeclaration "_hash"
         Type: uint256
         Source: "uint _hash"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_partner"
         Type: address
         Source: "address _partner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        won(); // check if player did not win \r\n        uint24 bethash = uint24(_hash);\r\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\r\n        if(msg.value > 0){\r\n            if(investStart==0) { // dividends only after investment finished\r\n                dividends[dividendPeriod] += msg.value / 34; // 3% dividend\r\n            }\r\n            if(_partner != address(0)) {\r\n                uint fee = msg.value / 100;\r\n                walletBalance += fee;\r\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\r\n            }\r\n            if(hashNext < block.number + 3) {\r\n                hashNext = block.number + 3;\r\n                hashBetSum = msg.value;\r\n            }\r\n            else{\r\n                if(hashBetSum > hashBetMax) {\r\n                    hashNext++;\r\n                    hashBetSum = msg.value;\r\n                }\r\n                else{\r\n                    hashBetSum += msg.value;\r\n                }\r\n            }\r\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\r\n            LogBet(msg.sender,uint(bethash),hashNext,msg.value);\r\n        }\r\n        putHash(); // players help collecing data\r\n        return(hashNext);\r\n    }"
      ExpressionStatement
         Gas costs: 15
         Source: "won()"
        FunctionCall
           Type: tuple()
           Source: "won()"
          Identifier won
             Type: function ()
             Source: "won"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint24 bethash = uint24(_hash)"
        VariableDeclaration "bethash"
           Type: uint24
           Source: "uint24 bethash"
          ElementaryTypeName uint24
             Source: "uint24"
        FunctionCall
           Type: uint24
           Source: "uint24(_hash)"
          ElementaryTypeNameExpression uint24
             Type: type(uint24)
             Source: "uint24"
          Identifier _hash
             Type: uint256
             Source: "_hash"
      ExpressionStatement
         Gas costs: 267
         Source: "require(msg.value <= 1 ether && msg.value < hashBetMax)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value <= 1 ether && msg.value < hashBetMax)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "msg.value <= 1 ether && msg.value < hashBetMax"
            BinaryOperation using operator <=
               Type: bool
               Source: "msg.value <= 1 ether"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Literal, token: [no token] value: 1
                 Type: int_const 1000000000000000000
                 Source: "1 ether"
            BinaryOperation using operator <
               Type: bool
               Source: "msg.value < hashBetMax"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier hashBetMax
                 Type: uint256
                 Source: "hashBetMax"
      IfStatement
         Source: "if(msg.value > 0){\r\n            if(investStart==0) { // dividends only after investment finished\r\n                dividends[dividendPeriod] += msg.value / 34; // 3% dividend\r\n            }\r\n            if(_partner != address(0)) {\r\n                uint fee = msg.value / 100;\r\n                walletBalance += fee;\r\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\r\n            }\r\n            if(hashNext < block.number + 3) {\r\n                hashNext = block.number + 3;\r\n                hashBetSum = msg.value;\r\n            }\r\n            else{\r\n                if(hashBetSum > hashBetMax) {\r\n                    hashNext++;\r\n                    hashBetSum = msg.value;\r\n                }\r\n                else{\r\n                    hashBetSum += msg.value;\r\n                }\r\n            }\r\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\r\n            LogBet(msg.sender,uint(bethash),hashNext,msg.value);\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 8
           Source: "msg.value > 0"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            if(investStart==0) { // dividends only after investment finished\r\n                dividends[dividendPeriod] += msg.value / 34; // 3% dividend\r\n            }\r\n            if(_partner != address(0)) {\r\n                uint fee = msg.value / 100;\r\n                walletBalance += fee;\r\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\r\n            }\r\n            if(hashNext < block.number + 3) {\r\n                hashNext = block.number + 3;\r\n                hashBetSum = msg.value;\r\n            }\r\n            else{\r\n                if(hashBetSum > hashBetMax) {\r\n                    hashNext++;\r\n                    hashBetSum = msg.value;\r\n                }\r\n                else{\r\n                    hashBetSum += msg.value;\r\n                }\r\n            }\r\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\r\n            LogBet(msg.sender,uint(bethash),hashNext,msg.value);\r\n        }"
          IfStatement
             Source: "if(investStart==0) { // dividends only after investment finished\r\n                dividends[dividendPeriod] += msg.value / 34; // 3% dividend\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 209
               Source: "investStart==0"
              Identifier investStart
                 Type: uint256
                 Source: "investStart"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{ // dividends only after investment finished\r\n                dividends[dividendPeriod] += msg.value / 34; // 3% dividend\r\n            }"
              ExpressionStatement
                 Gas costs: 20752
                 Source: "dividends[dividendPeriod] += msg.value / 34"
                Assignment using operator +=
                   Type: uint256
                   Source: "dividends[dividendPeriod] += msg.value / 34"
                  IndexAccess
                     Type: uint256
                     Source: "dividends[dividendPeriod]"
                    Identifier dividends
                       Type: uint256[] storage ref
                       Source: "dividends"
                    Identifier dividendPeriod
                       Type: uint256
                       Source: "dividendPeriod"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "msg.value / 34"
                    MemberAccess to member value
                       Type: uint256
                       Source: "msg.value"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                    Literal, token: [no token] value: 34
                       Type: int_const 34
                       Source: "34"
          IfStatement
             Source: "if(_partner != address(0)) {\r\n                uint fee = msg.value / 100;\r\n                walletBalance += fee;\r\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\r\n            }"
            BinaryOperation using operator !=
               Type: bool
               Gas costs: 24
               Source: "_partner != address(0)"
              Identifier _partner
                 Type: address
                 Source: "_partner"
              FunctionCall
                 Type: address
                 Source: "address(0)"
                ElementaryTypeNameExpression address
                   Type: type(address)
                   Source: "address"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            Block
               Source: "{\r\n                uint fee = msg.value / 100;\r\n                walletBalance += fee;\r\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\r\n            }"
              VariableDeclarationStatement
                 Gas costs: 41
                 Source: "uint fee = msg.value / 100"
                VariableDeclaration "fee"
                   Type: uint256
                   Source: "uint fee"
                  ElementaryTypeName uint
                     Source: "uint"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "msg.value / 100"
                  MemberAccess to member value
                     Type: uint256
                     Source: "msg.value"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Literal, token: [no token] value: 100
                     Type: int_const 100
                     Source: "100"
              ExpressionStatement
                 Gas costs: 20233
                 Source: "walletBalance += fee"
                Assignment using operator +=
                   Type: uint256
                   Source: "walletBalance += fee"
                  Identifier walletBalance
                     Type: uint256
                     Source: "walletBalance"
                  Identifier fee
                     Type: uint256
                     Source: "fee"
              ExpressionStatement
                 Gas costs: 20619
                 Source: "wallets[_partner].balance += uint208(fee)"
                Assignment using operator +=
                   Type: uint208
                   Source: "wallets[_partner].balance += uint208(fee)"
                  MemberAccess to member balance
                     Type: uint208
                     Source: "wallets[_partner].balance"
                    IndexAccess
                       Type: struct SmartBillions.Wallet storage ref
                       Source: "wallets[_partner]"
                      Identifier wallets
                         Type: mapping(address => struct SmartBillions.Wallet storage ref)
                         Source: "wallets"
                      Identifier _partner
                         Type: address
                         Source: "_partner"
                  FunctionCall
                     Type: uint208
                     Source: "uint208(fee)"
                    ElementaryTypeNameExpression uint208
                       Type: type(uint208)
                       Source: "uint208"
                    Identifier fee
                       Type: uint256
                       Source: "fee"
          IfStatement
             Source: "if(hashNext < block.number + 3) {\r\n                hashNext = block.number + 3;\r\n                hashBetSum = msg.value;\r\n            }\r\n            else{\r\n                if(hashBetSum > hashBetMax) {\r\n                    hashNext++;\r\n                    hashBetSum = msg.value;\r\n                }\r\n                else{\r\n                    hashBetSum += msg.value;\r\n                }\r\n            }"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 214
               Source: "hashNext < block.number + 3"
              Identifier hashNext
                 Type: uint256
                 Source: "hashNext"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "block.number + 3"
                MemberAccess to member number
                   Type: uint256
                   Source: "block.number"
                  Identifier block
                     Type: block
                     Source: "block"
                Literal, token: [no token] value: 3
                   Type: int_const 3
                   Source: "3"
            Block
               Source: "{\r\n                hashNext = block.number + 3;\r\n                hashBetSum = msg.value;\r\n            }"
              ExpressionStatement
                 Gas costs: 20019
                 Source: "hashNext = block.number + 3"
                Assignment using operator =
                   Type: uint256
                   Source: "hashNext = block.number + 3"
                  Identifier hashNext
                     Type: uint256
                     Source: "hashNext"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "block.number + 3"
                    MemberAccess to member number
                       Type: uint256
                       Source: "block.number"
                      Identifier block
                         Type: block
                         Source: "block"
                    Literal, token: [no token] value: 3
                       Type: int_const 3
                       Source: "3"
              ExpressionStatement
                 Gas costs: 20013
                 Source: "hashBetSum = msg.value"
                Assignment using operator =
                   Type: uint256
                   Source: "hashBetSum = msg.value"
                  Identifier hashBetSum
                     Type: uint256
                     Source: "hashBetSum"
                  MemberAccess to member value
                     Type: uint256
                     Source: "msg.value"
                    Identifier msg
                       Type: msg
                       Source: "msg"
            Block
               Source: "{\r\n                if(hashBetSum > hashBetMax) {\r\n                    hashNext++;\r\n                    hashBetSum = msg.value;\r\n                }\r\n                else{\r\n                    hashBetSum += msg.value;\r\n                }\r\n            }"
              IfStatement
                 Source: "if(hashBetSum > hashBetMax) {\r\n                    hashNext++;\r\n                    hashBetSum = msg.value;\r\n                }\r\n                else{\r\n                    hashBetSum += msg.value;\r\n                }"
                BinaryOperation using operator >
                   Type: bool
                   Gas costs: 409
                   Source: "hashBetSum > hashBetMax"
                  Identifier hashBetSum
                     Type: uint256
                     Source: "hashBetSum"
                  Identifier hashBetMax
                     Type: uint256
                     Source: "hashBetMax"
                Block
                   Source: "{\r\n                    hashNext++;\r\n                    hashBetSum = msg.value;\r\n                }"
                  ExpressionStatement
                     Gas costs: 20237
                     Source: "hashNext++"
                    UnaryOperation (postfix) ++
                       Type: uint256
                       Source: "hashNext++"
                      Identifier hashNext
                         Type: uint256
                         Source: "hashNext"
                  ExpressionStatement
                     Gas costs: 20013
                     Source: "hashBetSum = msg.value"
                    Assignment using operator =
                       Type: uint256
                       Source: "hashBetSum = msg.value"
                      Identifier hashBetSum
                         Type: uint256
                         Source: "hashBetSum"
                      MemberAccess to member value
                         Type: uint256
                         Source: "msg.value"
                        Identifier msg
                           Type: msg
                           Source: "msg"
                Block
                   Source: "{\r\n                    hashBetSum += msg.value;\r\n                }"
                  ExpressionStatement
                     Gas costs: 20232
                     Source: "hashBetSum += msg.value"
                    Assignment using operator +=
                       Type: uint256
                       Source: "hashBetSum += msg.value"
                      Identifier hashBetSum
                         Type: uint256
                         Source: "hashBetSum"
                      MemberAccess to member value
                         Type: uint256
                         Source: "msg.value"
                        Identifier msg
                           Type: msg
                           Source: "msg"
          ExpressionStatement
             Gas costs: [???]
             Source: "bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)})"
            Assignment using operator =
               Type: struct SmartBillions.Bet storage ref
               Source: "bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)})"
              IndexAccess
                 Type: struct SmartBillions.Bet storage ref
                 Source: "bets[msg.sender]"
                Identifier bets
                   Type: mapping(address => struct SmartBillions.Bet storage ref)
                   Source: "bets"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              FunctionCall
                 Type: struct SmartBillions.Bet memory
                 Source: "Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)})"
                Identifier Bet
                   Type: type(struct SmartBillions.Bet storage pointer)
                   Source: "Bet"
                FunctionCall
                   Type: uint192
                   Source: "uint192(msg.value)"
                  ElementaryTypeNameExpression uint192
                     Type: type(uint192)
                     Source: "uint192"
                  MemberAccess to member value
                     Type: uint256
                     Source: "msg.value"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                FunctionCall
                   Type: uint32
                   Source: "uint32(bethash)"
                  ElementaryTypeNameExpression uint32
                     Type: type(uint32)
                     Source: "uint32"
                  Identifier bethash
                     Type: uint24
                     Source: "bethash"
                FunctionCall
                   Type: uint32
                   Source: "uint32(hashNext)"
                  ElementaryTypeNameExpression uint32
                     Type: type(uint32)
                     Source: "uint32"
                  Identifier hashNext
                     Type: uint256
                     Source: "hashNext"
          ExpressionStatement
             Gas costs: [???]
             Source: "LogBet(msg.sender,uint(bethash),hashNext,msg.value)"
            FunctionCall
               Type: tuple()
               Source: "LogBet(msg.sender,uint(bethash),hashNext,msg.value)"
              Identifier LogBet
                 Type: function (address,uint256,uint256,uint256)
                 Source: "LogBet"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              FunctionCall
                 Type: uint256
                 Source: "uint(bethash)"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                Identifier bethash
                   Type: uint24
                   Source: "bethash"
              Identifier hashNext
                 Type: uint256
                 Source: "hashNext"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 17
         Source: "putHash()"
        FunctionCall
           Type: bool
           Source: "putHash()"
          Identifier putHash
             Type: function () returns (bool)
             Source: "putHash"
      Return
         Gas costs: 208
         Source: "return(hashNext)"
        TupleExpression
           Type: uint256
           Source: "(hashNext)"
          Identifier hashNext
             Type: uint256
             Source: "hashNext"
  FunctionDefinition "addHashes" - public
     Source: "function addHashes(uint _sadd) public returns (uint) {\r\n        require(hashes.length + _sadd<=hashesSize);\r\n        uint n = hashes.length;\r\n        hashes.length += _sadd;\r\n        for(;n<hashes.length;n++){ // make sure to burn gas\r\n            hashes[n] = 1;\r\n        }\r\n        if(hashes.length>=hashesSize) { // assume block.number > 10\r\n            hashFirst = block.number - ( block.number % 10);\r\n            hashLast = hashFirst;\r\n        }\r\n        return(hashes.length);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _sadd)"
      VariableDeclaration "_sadd"
         Type: uint256
         Source: "uint _sadd"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(hashes.length + _sadd<=hashesSize);\r\n        uint n = hashes.length;\r\n        hashes.length += _sadd;\r\n        for(;n<hashes.length;n++){ // make sure to burn gas\r\n            hashes[n] = 1;\r\n        }\r\n        if(hashes.length>=hashesSize) { // assume block.number > 10\r\n            hashFirst = block.number - ( block.number % 10);\r\n            hashLast = hashFirst;\r\n        }\r\n        return(hashes.length);\r\n    }"
      ExpressionStatement
         Gas costs: 249
         Source: "require(hashes.length + _sadd<=hashesSize)"
        FunctionCall
           Type: tuple()
           Source: "require(hashes.length + _sadd<=hashesSize)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "hashes.length + _sadd<=hashesSize"
            BinaryOperation using operator +
               Type: uint256
               Source: "hashes.length + _sadd"
              MemberAccess to member length
                 Type: uint256
                 Source: "hashes.length"
                Identifier hashes
                   Type: uint256[] storage ref
                   Source: "hashes"
              Identifier _sadd
                 Type: uint256
                 Source: "_sadd"
            Identifier hashesSize
               Type: uint256
               Source: "hashesSize"
      VariableDeclarationStatement
         Gas costs: 219
         Source: "uint n = hashes.length"
        VariableDeclaration "n"
           Type: uint256
           Source: "uint n"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "hashes.length"
          Identifier hashes
             Type: uint256[] storage ref
             Source: "hashes"
      ExpressionStatement
         Gas costs: 243
         Source: "hashes.length += _sadd"
        Assignment using operator +=
           Type: uint256
           Source: "hashes.length += _sadd"
          MemberAccess to member length
             Type: uint256
             Source: "hashes.length"
            Identifier hashes
               Type: uint256[] storage ref
               Source: "hashes"
          Identifier _sadd
             Type: uint256
             Source: "_sadd"
      ForStatement
         Source: "for(;n<hashes.length;n++){ // make sure to burn gas\r\n            hashes[n] = 1;\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 217
           Source: "n<hashes.length"
          Identifier n
             Type: uint256
             Source: "n"
          MemberAccess to member length
             Type: uint256
             Source: "hashes.length"
            Identifier hashes
               Type: uint256[] storage ref
               Source: "hashes"
        ExpressionStatement
           Gas costs: 19
           Source: "n++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "n++"
            Identifier n
               Type: uint256
               Source: "n"
        Block
           Source: "{ // make sure to burn gas\r\n            hashes[n] = 1;\r\n        }"
          ExpressionStatement
             Gas costs: 20303
             Source: "hashes[n] = 1"
            Assignment using operator =
               Type: uint256
               Source: "hashes[n] = 1"
              IndexAccess
                 Type: uint256
                 Source: "hashes[n]"
                Identifier hashes
                   Type: uint256[] storage ref
                   Source: "hashes"
                Identifier n
                   Type: uint256
                   Source: "n"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      IfStatement
         Source: "if(hashes.length>=hashesSize) { // assume block.number > 10\r\n            hashFirst = block.number - ( block.number % 10);\r\n            hashLast = hashFirst;\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 217
           Source: "hashes.length>=hashesSize"
          MemberAccess to member length
             Type: uint256
             Source: "hashes.length"
            Identifier hashes
               Type: uint256[] storage ref
               Source: "hashes"
          Identifier hashesSize
             Type: uint256
             Source: "hashesSize"
        Block
           Source: "{ // assume block.number > 10\r\n            hashFirst = block.number - ( block.number % 10);\r\n            hashLast = hashFirst;\r\n        }"
          ExpressionStatement
             Gas costs: 20049
             Source: "hashFirst = block.number - ( block.number % 10)"
            Assignment using operator =
               Type: uint256
               Source: "hashFirst = block.number - ( block.number % 10)"
              Identifier hashFirst
                 Type: uint256
                 Source: "hashFirst"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "block.number - ( block.number % 10)"
                MemberAccess to member number
                   Type: uint256
                   Source: "block.number"
                  Identifier block
                     Type: block
                     Source: "block"
                TupleExpression
                   Type: uint256
                   Source: "( block.number % 10)"
                  BinaryOperation using operator %
                     Type: uint256
                     Source: "block.number % 10"
                    MemberAccess to member number
                       Type: uint256
                       Source: "block.number"
                      Identifier block
                         Type: block
                         Source: "block"
                    Literal, token: [no token] value: 10
                       Type: int_const 10
                       Source: "10"
          ExpressionStatement
             Gas costs: 20214
             Source: "hashLast = hashFirst"
            Assignment using operator =
               Type: uint256
               Source: "hashLast = hashFirst"
              Identifier hashLast
                 Type: uint256
                 Source: "hashLast"
              Identifier hashFirst
                 Type: uint256
                 Source: "hashFirst"
      Return
         Gas costs: 216
         Source: "return(hashes.length)"
        TupleExpression
           Type: uint256
           Source: "(hashes.length)"
          MemberAccess to member length
             Type: uint256
             Source: "hashes.length"
            Identifier hashes
               Type: uint256[] storage ref
               Source: "hashes"
  FunctionDefinition "addHashes128" - public
     Source: "function addHashes128() external returns (uint) {\r\n        return(addHashes(128));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return(addHashes(128));\r\n    }"
      Return
         Gas costs: 23
         Source: "return(addHashes(128))"
        TupleExpression
           Type: uint256
           Source: "(addHashes(128))"
          FunctionCall
             Type: uint256
             Source: "addHashes(128)"
            Identifier addHashes
               Type: function (uint256) returns (uint256)
               Source: "addHashes"
            Literal, token: [no token] value: 128
               Type: int_const 128
               Source: "128"
  FunctionDefinition "calcHashes" - const
     Source: "function calcHashes(uint32 _lastb, uint32 _delta) constant private returns (uint) {\r\n        return( ( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\r\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\r\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\r\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\r\n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\r\n            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\r\n            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\r\n            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\r\n            | ( ( uint(_delta) / hashesSize) << 240)); \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint32 _lastb, uint32 _delta)"
      VariableDeclaration "_lastb"
         Type: uint32
         Source: "uint32 _lastb"
        ElementaryTypeName uint32
           Source: "uint32"
      VariableDeclaration "_delta"
         Type: uint32
         Source: "uint32 _delta"
        ElementaryTypeName uint32
           Source: "uint32"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return( ( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\r\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\r\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\r\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\r\n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\r\n            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\r\n            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\r\n            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\r\n            | ( ( uint(_delta) / hashesSize) << 240)); \r\n    }"
      Return
         Gas costs: 2876
         Source: "return( ( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\r\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\r\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\r\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\r\n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\r\n            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\r\n            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\r\n            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\r\n            | ( ( uint(_delta) / hashesSize) << 240))"
        TupleExpression
           Type: uint256
           Source: "( ( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\r\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\r\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\r\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\r\n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\r\n            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\r\n            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\r\n            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\r\n            | ( ( uint(_delta) / hashesSize) << 240))"
          BinaryOperation using operator |
             Type: uint256
             Source: "( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\r\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\r\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\r\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\r\n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\r\n            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\r\n            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\r\n            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\r\n            | ( ( uint(_delta) / hashesSize) << 240)"
            BinaryOperation using operator |
               Type: uint256
               Source: "( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\r\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\r\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\r\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\r\n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\r\n            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\r\n            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\r\n            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )"
              BinaryOperation using operator |
                 Type: uint256
                 Source: "( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\r\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\r\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\r\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\r\n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\r\n            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\r\n            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )"
                BinaryOperation using operator |
                   Type: uint256
                   Source: "( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\r\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\r\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\r\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\r\n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\r\n            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )"
                  BinaryOperation using operator |
                     Type: uint256
                     Source: "( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\r\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\r\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\r\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\r\n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )"
                    BinaryOperation using operator |
                       Type: uint256
                       Source: "( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\r\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\r\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\r\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )"
                      BinaryOperation using operator |
                         Type: uint256
                         Source: "( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\r\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\r\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )"
                        BinaryOperation using operator |
                           Type: uint256
                           Source: "( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\r\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )"
                          BinaryOperation using operator |
                             Type: uint256
                             Source: "( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )"
                            BinaryOperation using operator |
                               Type: uint256
                               Source: "( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )"
                              TupleExpression
                                 Type: uint256
                                 Source: "( uint(block.blockhash(_lastb  )) & 0xFFFFFF )"
                                BinaryOperation using operator &
                                   Type: uint256
                                   Source: "uint(block.blockhash(_lastb  )) & 0xFFFFFF"
                                  FunctionCall
                                     Type: uint256
                                     Source: "uint(block.blockhash(_lastb  ))"
                                    ElementaryTypeNameExpression uint
                                       Type: type(uint256)
                                       Source: "uint"
                                    FunctionCall
                                       Type: bytes32
                                       Source: "block.blockhash(_lastb  )"
                                      MemberAccess to member blockhash
                                         Type: function (uint256) view returns (bytes32)
                                         Source: "block.blockhash"
                                        Identifier block
                                           Type: block
                                           Source: "block"
                                      Identifier _lastb
                                         Type: uint32
                                         Source: "_lastb"
                                  Literal, token: [no token] value: 0xFFFFFF
                                     Type: int_const 16777215
                                     Source: "0xFFFFFF"
                              TupleExpression
                                 Type: uint256
                                 Source: "( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )"
                                BinaryOperation using operator <<
                                   Type: uint256
                                   Source: "( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24"
                                  TupleExpression
                                     Type: uint256
                                     Source: "( uint(block.blockhash(_lastb+1)) & 0xFFFFFF )"
                                    BinaryOperation using operator &
                                       Type: uint256
                                       Source: "uint(block.blockhash(_lastb+1)) & 0xFFFFFF"
                                      FunctionCall
                                         Type: uint256
                                         Source: "uint(block.blockhash(_lastb+1))"
                                        ElementaryTypeNameExpression uint
                                           Type: type(uint256)
                                           Source: "uint"
                                        FunctionCall
                                           Type: bytes32
                                           Source: "block.blockhash(_lastb+1)"
                                          MemberAccess to member blockhash
                                             Type: function (uint256) view returns (bytes32)
                                             Source: "block.blockhash"
                                            Identifier block
                                               Type: block
                                               Source: "block"
                                          BinaryOperation using operator +
                                             Type: uint32
                                             Source: "_lastb+1"
                                            Identifier _lastb
                                               Type: uint32
                                               Source: "_lastb"
                                            Literal, token: [no token] value: 1
                                               Type: int_const 1
                                               Source: "1"
                                      Literal, token: [no token] value: 0xFFFFFF
                                         Type: int_const 16777215
                                         Source: "0xFFFFFF"
                                  Literal, token: [no token] value: 24
                                     Type: int_const 24
                                     Source: "24"
                            TupleExpression
                               Type: uint256
                               Source: "( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )"
                              BinaryOperation using operator <<
                                 Type: uint256
                                 Source: "( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48"
                                TupleExpression
                                   Type: uint256
                                   Source: "( uint(block.blockhash(_lastb+2)) & 0xFFFFFF )"
                                  BinaryOperation using operator &
                                     Type: uint256
                                     Source: "uint(block.blockhash(_lastb+2)) & 0xFFFFFF"
                                    FunctionCall
                                       Type: uint256
                                       Source: "uint(block.blockhash(_lastb+2))"
                                      ElementaryTypeNameExpression uint
                                         Type: type(uint256)
                                         Source: "uint"
                                      FunctionCall
                                         Type: bytes32
                                         Source: "block.blockhash(_lastb+2)"
                                        MemberAccess to member blockhash
                                           Type: function (uint256) view returns (bytes32)
                                           Source: "block.blockhash"
                                          Identifier block
                                             Type: block
                                             Source: "block"
                                        BinaryOperation using operator +
                                           Type: uint32
                                           Source: "_lastb+2"
                                          Identifier _lastb
                                             Type: uint32
                                             Source: "_lastb"
                                          Literal, token: [no token] value: 2
                                             Type: int_const 2
                                             Source: "2"
                                    Literal, token: [no token] value: 0xFFFFFF
                                       Type: int_const 16777215
                                       Source: "0xFFFFFF"
                                Literal, token: [no token] value: 48
                                   Type: int_const 48
                                   Source: "48"
                          TupleExpression
                             Type: uint256
                             Source: "( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )"
                            BinaryOperation using operator <<
                               Type: uint256
                               Source: "( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72"
                              TupleExpression
                                 Type: uint256
                                 Source: "( uint(block.blockhash(_lastb+3)) & 0xFFFFFF )"
                                BinaryOperation using operator &
                                   Type: uint256
                                   Source: "uint(block.blockhash(_lastb+3)) & 0xFFFFFF"
                                  FunctionCall
                                     Type: uint256
                                     Source: "uint(block.blockhash(_lastb+3))"
                                    ElementaryTypeNameExpression uint
                                       Type: type(uint256)
                                       Source: "uint"
                                    FunctionCall
                                       Type: bytes32
                                       Source: "block.blockhash(_lastb+3)"
                                      MemberAccess to member blockhash
                                         Type: function (uint256) view returns (bytes32)
                                         Source: "block.blockhash"
                                        Identifier block
                                           Type: block
                                           Source: "block"
                                      BinaryOperation using operator +
                                         Type: uint32
                                         Source: "_lastb+3"
                                        Identifier _lastb
                                           Type: uint32
                                           Source: "_lastb"
                                        Literal, token: [no token] value: 3
                                           Type: int_const 3
                                           Source: "3"
                                  Literal, token: [no token] value: 0xFFFFFF
                                     Type: int_const 16777215
                                     Source: "0xFFFFFF"
                              Literal, token: [no token] value: 72
                                 Type: int_const 72
                                 Source: "72"
                        TupleExpression
                           Type: uint256
                           Source: "( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )"
                          BinaryOperation using operator <<
                             Type: uint256
                             Source: "( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96"
                            TupleExpression
                               Type: uint256
                               Source: "( uint(block.blockhash(_lastb+4)) & 0xFFFFFF )"
                              BinaryOperation using operator &
                                 Type: uint256
                                 Source: "uint(block.blockhash(_lastb+4)) & 0xFFFFFF"
                                FunctionCall
                                   Type: uint256
                                   Source: "uint(block.blockhash(_lastb+4))"
                                  ElementaryTypeNameExpression uint
                                     Type: type(uint256)
                                     Source: "uint"
                                  FunctionCall
                                     Type: bytes32
                                     Source: "block.blockhash(_lastb+4)"
                                    MemberAccess to member blockhash
                                       Type: function (uint256) view returns (bytes32)
                                       Source: "block.blockhash"
                                      Identifier block
                                         Type: block
                                         Source: "block"
                                    BinaryOperation using operator +
                                       Type: uint32
                                       Source: "_lastb+4"
                                      Identifier _lastb
                                         Type: uint32
                                         Source: "_lastb"
                                      Literal, token: [no token] value: 4
                                         Type: int_const 4
                                         Source: "4"
                                Literal, token: [no token] value: 0xFFFFFF
                                   Type: int_const 16777215
                                   Source: "0xFFFFFF"
                            Literal, token: [no token] value: 96
                               Type: int_const 96
                               Source: "96"
                      TupleExpression
                         Type: uint256
                         Source: "( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )"
                        BinaryOperation using operator <<
                           Type: uint256
                           Source: "( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120"
                          TupleExpression
                             Type: uint256
                             Source: "( uint(block.blockhash(_lastb+5)) & 0xFFFFFF )"
                            BinaryOperation using operator &
                               Type: uint256
                               Source: "uint(block.blockhash(_lastb+5)) & 0xFFFFFF"
                              FunctionCall
                                 Type: uint256
                                 Source: "uint(block.blockhash(_lastb+5))"
                                ElementaryTypeNameExpression uint
                                   Type: type(uint256)
                                   Source: "uint"
                                FunctionCall
                                   Type: bytes32
                                   Source: "block.blockhash(_lastb+5)"
                                  MemberAccess to member blockhash
                                     Type: function (uint256) view returns (bytes32)
                                     Source: "block.blockhash"
                                    Identifier block
                                       Type: block
                                       Source: "block"
                                  BinaryOperation using operator +
                                     Type: uint32
                                     Source: "_lastb+5"
                                    Identifier _lastb
                                       Type: uint32
                                       Source: "_lastb"
                                    Literal, token: [no token] value: 5
                                       Type: int_const 5
                                       Source: "5"
                              Literal, token: [no token] value: 0xFFFFFF
                                 Type: int_const 16777215
                                 Source: "0xFFFFFF"
                          Literal, token: [no token] value: 120
                             Type: int_const 120
                             Source: "120"
                    TupleExpression
                       Type: uint256
                       Source: "( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )"
                      BinaryOperation using operator <<
                         Type: uint256
                         Source: "( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144"
                        TupleExpression
                           Type: uint256
                           Source: "( uint(block.blockhash(_lastb+6)) & 0xFFFFFF )"
                          BinaryOperation using operator &
                             Type: uint256
                             Source: "uint(block.blockhash(_lastb+6)) & 0xFFFFFF"
                            FunctionCall
                               Type: uint256
                               Source: "uint(block.blockhash(_lastb+6))"
                              ElementaryTypeNameExpression uint
                                 Type: type(uint256)
                                 Source: "uint"
                              FunctionCall
                                 Type: bytes32
                                 Source: "block.blockhash(_lastb+6)"
                                MemberAccess to member blockhash
                                   Type: function (uint256) view returns (bytes32)
                                   Source: "block.blockhash"
                                  Identifier block
                                     Type: block
                                     Source: "block"
                                BinaryOperation using operator +
                                   Type: uint32
                                   Source: "_lastb+6"
                                  Identifier _lastb
                                     Type: uint32
                                     Source: "_lastb"
                                  Literal, token: [no token] value: 6
                                     Type: int_const 6
                                     Source: "6"
                            Literal, token: [no token] value: 0xFFFFFF
                               Type: int_const 16777215
                               Source: "0xFFFFFF"
                        Literal, token: [no token] value: 144
                           Type: int_const 144
                           Source: "144"
                  TupleExpression
                     Type: uint256
                     Source: "( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )"
                    BinaryOperation using operator <<
                       Type: uint256
                       Source: "( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168"
                      TupleExpression
                         Type: uint256
                         Source: "( uint(block.blockhash(_lastb+7)) & 0xFFFFFF )"
                        BinaryOperation using operator &
                           Type: uint256
                           Source: "uint(block.blockhash(_lastb+7)) & 0xFFFFFF"
                          FunctionCall
                             Type: uint256
                             Source: "uint(block.blockhash(_lastb+7))"
                            ElementaryTypeNameExpression uint
                               Type: type(uint256)
                               Source: "uint"
                            FunctionCall
                               Type: bytes32
                               Source: "block.blockhash(_lastb+7)"
                              MemberAccess to member blockhash
                                 Type: function (uint256) view returns (bytes32)
                                 Source: "block.blockhash"
                                Identifier block
                                   Type: block
                                   Source: "block"
                              BinaryOperation using operator +
                                 Type: uint32
                                 Source: "_lastb+7"
                                Identifier _lastb
                                   Type: uint32
                                   Source: "_lastb"
                                Literal, token: [no token] value: 7
                                   Type: int_const 7
                                   Source: "7"
                          Literal, token: [no token] value: 0xFFFFFF
                             Type: int_const 16777215
                             Source: "0xFFFFFF"
                      Literal, token: [no token] value: 168
                         Type: int_const 168
                         Source: "168"
                TupleExpression
                   Type: uint256
                   Source: "( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )"
                  BinaryOperation using operator <<
                     Type: uint256
                     Source: "( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192"
                    TupleExpression
                       Type: uint256
                       Source: "( uint(block.blockhash(_lastb+8)) & 0xFFFFFF )"
                      BinaryOperation using operator &
                         Type: uint256
                         Source: "uint(block.blockhash(_lastb+8)) & 0xFFFFFF"
                        FunctionCall
                           Type: uint256
                           Source: "uint(block.blockhash(_lastb+8))"
                          ElementaryTypeNameExpression uint
                             Type: type(uint256)
                             Source: "uint"
                          FunctionCall
                             Type: bytes32
                             Source: "block.blockhash(_lastb+8)"
                            MemberAccess to member blockhash
                               Type: function (uint256) view returns (bytes32)
                               Source: "block.blockhash"
                              Identifier block
                                 Type: block
                                 Source: "block"
                            BinaryOperation using operator +
                               Type: uint32
                               Source: "_lastb+8"
                              Identifier _lastb
                                 Type: uint32
                                 Source: "_lastb"
                              Literal, token: [no token] value: 8
                                 Type: int_const 8
                                 Source: "8"
                        Literal, token: [no token] value: 0xFFFFFF
                           Type: int_const 16777215
                           Source: "0xFFFFFF"
                    Literal, token: [no token] value: 192
                       Type: int_const 192
                       Source: "192"
              TupleExpression
                 Type: uint256
                 Source: "( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )"
                BinaryOperation using operator <<
                   Type: uint256
                   Source: "( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216"
                  TupleExpression
                     Type: uint256
                     Source: "( uint(block.blockhash(_lastb+9)) & 0xFFFFFF )"
                    BinaryOperation using operator &
                       Type: uint256
                       Source: "uint(block.blockhash(_lastb+9)) & 0xFFFFFF"
                      FunctionCall
                         Type: uint256
                         Source: "uint(block.blockhash(_lastb+9))"
                        ElementaryTypeNameExpression uint
                           Type: type(uint256)
                           Source: "uint"
                        FunctionCall
                           Type: bytes32
                           Source: "block.blockhash(_lastb+9)"
                          MemberAccess to member blockhash
                             Type: function (uint256) view returns (bytes32)
                             Source: "block.blockhash"
                            Identifier block
                               Type: block
                               Source: "block"
                          BinaryOperation using operator +
                             Type: uint32
                             Source: "_lastb+9"
                            Identifier _lastb
                               Type: uint32
                               Source: "_lastb"
                            Literal, token: [no token] value: 9
                               Type: int_const 9
                               Source: "9"
                      Literal, token: [no token] value: 0xFFFFFF
                         Type: int_const 16777215
                         Source: "0xFFFFFF"
                  Literal, token: [no token] value: 216
                     Type: int_const 216
                     Source: "216"
            TupleExpression
               Type: uint256
               Source: "( ( uint(_delta) / hashesSize) << 240)"
              BinaryOperation using operator <<
                 Type: uint256
                 Source: "( uint(_delta) / hashesSize) << 240"
                TupleExpression
                   Type: uint256
                   Source: "( uint(_delta) / hashesSize)"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "uint(_delta) / hashesSize"
                    FunctionCall
                       Type: uint256
                       Source: "uint(_delta)"
                      ElementaryTypeNameExpression uint
                         Type: type(uint256)
                         Source: "uint"
                      Identifier _delta
                         Type: uint32
                         Source: "_delta"
                    Identifier hashesSize
                       Type: uint256
                       Source: "hashesSize"
                Literal, token: [no token] value: 240
                   Type: int_const 240
                   Source: "240"
  FunctionDefinition "getHash" - const
     Source: "function getHash(uint _block) constant private returns (uint32) {\r\n        uint delta = (_block - hashFirst) / 10;\r\n        uint hash = hashes[delta % hashesSize];\r\n        if(delta / hashesSize != hash >> 240) {\r\n            return(0x1000000); // load failed, incorrect data in hashes\r\n        }\r\n        uint slotp = (_block - hashFirst) % 10; \r\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _block)"
      VariableDeclaration "_block"
         Type: uint256
         Source: "uint _block"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint32)"
      VariableDeclaration ""
         Type: uint32
         Source: "uint32"
        ElementaryTypeName uint32
           Source: "uint32"
    Block
       Source: "{\r\n        uint delta = (_block - hashFirst) / 10;\r\n        uint hash = hashes[delta % hashesSize];\r\n        if(delta / hashesSize != hash >> 240) {\r\n            return(0x1000000); // load failed, incorrect data in hashes\r\n        }\r\n        uint slotp = (_block - hashFirst) % 10; \r\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\r\n    }"
      VariableDeclarationStatement
         Gas costs: 248
         Source: "uint delta = (_block - hashFirst) / 10"
        VariableDeclaration "delta"
           Type: uint256
           Source: "uint delta"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "(_block - hashFirst) / 10"
          TupleExpression
             Type: uint256
             Source: "(_block - hashFirst)"
            BinaryOperation using operator -
               Type: uint256
               Source: "_block - hashFirst"
              Identifier _block
                 Type: uint256
                 Source: "_block"
              Identifier hashFirst
                 Type: uint256
                 Source: "hashFirst"
          Literal, token: [no token] value: 10
             Type: int_const 10
             Source: "10"
      VariableDeclarationStatement
         Gas costs: 528
         Source: "uint hash = hashes[delta % hashesSize]"
        VariableDeclaration "hash"
           Type: uint256
           Source: "uint hash"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "hashes[delta % hashesSize]"
          Identifier hashes
             Type: uint256[] storage ref
             Source: "hashes"
          BinaryOperation using operator %
             Type: uint256
             Source: "delta % hashesSize"
            Identifier delta
               Type: uint256
               Source: "delta"
            Identifier hashesSize
               Type: uint256
               Source: "hashesSize"
      IfStatement
         Source: "if(delta / hashesSize != hash >> 240) {\r\n            return(0x1000000); // load failed, incorrect data in hashes\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 117
           Source: "delta / hashesSize != hash >> 240"
          BinaryOperation using operator /
             Type: uint256
             Source: "delta / hashesSize"
            Identifier delta
               Type: uint256
               Source: "delta"
            Identifier hashesSize
               Type: uint256
               Source: "hashesSize"
          BinaryOperation using operator >>
             Type: uint256
             Source: "hash >> 240"
            Identifier hash
               Type: uint256
               Source: "hash"
            Literal, token: [no token] value: 240
               Type: int_const 240
               Source: "240"
        Block
           Source: "{\r\n            return(0x1000000); // load failed, incorrect data in hashes\r\n        }"
          Return
             Gas costs: 19
             Source: "return(0x1000000)"
            TupleExpression
               Type: int_const 16777216
               Source: "(0x1000000)"
              Literal, token: [no token] value: 0x1000000
                 Type: int_const 16777216
                 Source: "0x1000000"
      VariableDeclarationStatement
         Gas costs: 248
         Source: "uint slotp = (_block - hashFirst) % 10"
        VariableDeclaration "slotp"
           Type: uint256
           Source: "uint slotp"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator %
           Type: uint256
           Source: "(_block - hashFirst) % 10"
          TupleExpression
             Type: uint256
             Source: "(_block - hashFirst)"
            BinaryOperation using operator -
               Type: uint256
               Source: "_block - hashFirst"
              Identifier _block
                 Type: uint256
                 Source: "_block"
              Identifier hashFirst
                 Type: uint256
                 Source: "hashFirst"
          Literal, token: [no token] value: 10
             Type: int_const 10
             Source: "10"
      Return
         Gas costs: 1649
         Source: "return(uint32((hash >> (24 * slotp)) & 0xFFFFFF))"
        TupleExpression
           Type: uint32
           Source: "(uint32((hash >> (24 * slotp)) & 0xFFFFFF))"
          FunctionCall
             Type: uint32
             Source: "uint32((hash >> (24 * slotp)) & 0xFFFFFF)"
            ElementaryTypeNameExpression uint32
               Type: type(uint32)
               Source: "uint32"
            BinaryOperation using operator &
               Type: uint256
               Source: "(hash >> (24 * slotp)) & 0xFFFFFF"
              TupleExpression
                 Type: uint256
                 Source: "(hash >> (24 * slotp))"
                BinaryOperation using operator >>
                   Type: uint256
                   Source: "hash >> (24 * slotp)"
                  Identifier hash
                     Type: uint256
                     Source: "hash"
                  TupleExpression
                     Type: uint256
                     Source: "(24 * slotp)"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "24 * slotp"
                      Literal, token: [no token] value: 24
                         Type: int_const 24
                         Source: "24"
                      Identifier slotp
                         Type: uint256
                         Source: "slotp"
              Literal, token: [no token] value: 0xFFFFFF
                 Type: int_const 16777215
                 Source: "0xFFFFFF"
  FunctionDefinition "putHash" - public
     Source: "function putHash() public returns (bool) {\r\n        uint lastb = hashLast;\r\n        if(lastb == 0 || block.number <= lastb + 10) {\r\n            return(false);\r\n        }\r\n        uint blockn256;\r\n        if(block.number<256) { // useless test for testnet :-(\r\n            blockn256 = 0;\r\n        }\r\n        else{\r\n            blockn256 = block.number - 256;\r\n        }\r\n        if(lastb < blockn256) {\r\n            uint num = blockn256;\r\n            num += num % 10;\r\n            lastb = num; \r\n        }\r\n        uint delta = (lastb - hashFirst) / 10;\r\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\r\n        hashLast = lastb + 10;\r\n        return(true);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        uint lastb = hashLast;\r\n        if(lastb == 0 || block.number <= lastb + 10) {\r\n            return(false);\r\n        }\r\n        uint blockn256;\r\n        if(block.number<256) { // useless test for testnet :-(\r\n            blockn256 = 0;\r\n        }\r\n        else{\r\n            blockn256 = block.number - 256;\r\n        }\r\n        if(lastb < blockn256) {\r\n            uint num = blockn256;\r\n            num += num % 10;\r\n            lastb = num; \r\n        }\r\n        uint delta = (lastb - hashFirst) / 10;\r\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\r\n        hashLast = lastb + 10;\r\n        return(true);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 211
         Source: "uint lastb = hashLast"
        VariableDeclaration "lastb"
           Type: uint256
           Source: "uint lastb"
          ElementaryTypeName uint
             Source: "uint"
        Identifier hashLast
           Type: uint256
           Source: "hashLast"
      IfStatement
         Source: "if(lastb == 0 || block.number <= lastb + 10) {\r\n            return(false);\r\n        }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 45
           Source: "lastb == 0 || block.number <= lastb + 10"
          BinaryOperation using operator ==
             Type: bool
             Source: "lastb == 0"
            Identifier lastb
               Type: uint256
               Source: "lastb"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator <=
             Type: bool
             Source: "block.number <= lastb + 10"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            BinaryOperation using operator +
               Type: uint256
               Source: "lastb + 10"
              Identifier lastb
                 Type: uint256
                 Source: "lastb"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
        Block
           Source: "{\r\n            return(false);\r\n        }"
          Return
             Gas costs: 19
             Source: "return(false)"
            TupleExpression
               Type: bool
               Source: "(false)"
              Literal, token: false value: false
                 Type: bool
                 Source: "false"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint blockn256"
        VariableDeclaration "blockn256"
           Type: uint256
           Source: "uint blockn256"
          ElementaryTypeName uint
             Source: "uint"
      IfStatement
         Source: "if(block.number<256) { // useless test for testnet :-(\r\n            blockn256 = 0;\r\n        }\r\n        else{\r\n            blockn256 = block.number - 256;\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 8
           Source: "block.number<256"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          Literal, token: [no token] value: 256
             Type: int_const 256
             Source: "256"
        Block
           Source: "{ // useless test for testnet :-(\r\n            blockn256 = 0;\r\n        }"
          ExpressionStatement
             Gas costs: 8
             Source: "blockn256 = 0"
            Assignment using operator =
               Type: uint256
               Source: "blockn256 = 0"
              Identifier blockn256
                 Type: uint256
                 Source: "blockn256"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\r\n            blockn256 = block.number - 256;\r\n        }"
          ExpressionStatement
             Gas costs: 13
             Source: "blockn256 = block.number - 256"
            Assignment using operator =
               Type: uint256
               Source: "blockn256 = block.number - 256"
              Identifier blockn256
                 Type: uint256
                 Source: "blockn256"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "block.number - 256"
                MemberAccess to member number
                   Type: uint256
                   Source: "block.number"
                  Identifier block
                     Type: block
                     Source: "block"
                Literal, token: [no token] value: 256
                   Type: int_const 256
                   Source: "256"
      IfStatement
         Source: "if(lastb < blockn256) {\r\n            uint num = blockn256;\r\n            num += num % 10;\r\n            lastb = num; \r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "lastb < blockn256"
          Identifier lastb
             Type: uint256
             Source: "lastb"
          Identifier blockn256
             Type: uint256
             Source: "blockn256"
        Block
           Source: "{\r\n            uint num = blockn256;\r\n            num += num % 10;\r\n            lastb = num; \r\n        }"
          VariableDeclarationStatement
             Gas costs: 11
             Source: "uint num = blockn256"
            VariableDeclaration "num"
               Type: uint256
               Source: "uint num"
              ElementaryTypeName uint
                 Source: "uint"
            Identifier blockn256
               Type: uint256
               Source: "blockn256"
          ExpressionStatement
             Gas costs: 45
             Source: "num += num % 10"
            Assignment using operator +=
               Type: uint256
               Source: "num += num % 10"
              Identifier num
                 Type: uint256
                 Source: "num"
              BinaryOperation using operator %
                 Type: uint256
                 Source: "num % 10"
                Identifier num
                   Type: uint256
                   Source: "num"
                Literal, token: [no token] value: 10
                   Type: int_const 10
                   Source: "10"
          ExpressionStatement
             Gas costs: 8
             Source: "lastb = num"
            Assignment using operator =
               Type: uint256
               Source: "lastb = num"
              Identifier lastb
                 Type: uint256
                 Source: "lastb"
              Identifier num
                 Type: uint256
                 Source: "num"
      VariableDeclarationStatement
         Gas costs: 248
         Source: "uint delta = (lastb - hashFirst) / 10"
        VariableDeclaration "delta"
           Type: uint256
           Source: "uint delta"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "(lastb - hashFirst) / 10"
          TupleExpression
             Type: uint256
             Source: "(lastb - hashFirst)"
            BinaryOperation using operator -
               Type: uint256
               Source: "lastb - hashFirst"
              Identifier lastb
                 Type: uint256
                 Source: "lastb"
              Identifier hashFirst
                 Type: uint256
                 Source: "hashFirst"
          Literal, token: [no token] value: 10
             Type: int_const 10
             Source: "10"
      ExpressionStatement
         Gas costs: 20338
         Source: "hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta))"
        Assignment using operator =
           Type: uint256
           Source: "hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta))"
          IndexAccess
             Type: uint256
             Source: "hashes[delta % hashesSize]"
            Identifier hashes
               Type: uint256[] storage ref
               Source: "hashes"
            BinaryOperation using operator %
               Type: uint256
               Source: "delta % hashesSize"
              Identifier delta
                 Type: uint256
                 Source: "delta"
              Identifier hashesSize
                 Type: uint256
                 Source: "hashesSize"
          FunctionCall
             Type: uint256
             Source: "calcHashes(uint32(lastb),uint32(delta))"
            Identifier calcHashes
               Type: function (uint32,uint32) view returns (uint256)
               Source: "calcHashes"
            FunctionCall
               Type: uint32
               Source: "uint32(lastb)"
              ElementaryTypeNameExpression uint32
                 Type: type(uint32)
                 Source: "uint32"
              Identifier lastb
                 Type: uint256
                 Source: "lastb"
            FunctionCall
               Type: uint32
               Source: "uint32(delta)"
              ElementaryTypeNameExpression uint32
                 Type: type(uint32)
                 Source: "uint32"
              Identifier delta
                 Type: uint256
                 Source: "delta"
      ExpressionStatement
         Gas costs: 20020
         Source: "hashLast = lastb + 10"
        Assignment using operator =
           Type: uint256
           Source: "hashLast = lastb + 10"
          Identifier hashLast
             Type: uint256
             Source: "hashLast"
          BinaryOperation using operator +
             Type: uint256
             Source: "lastb + 10"
            Identifier lastb
               Type: uint256
               Source: "lastb"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
      Return
         Gas costs: 8
         Source: "return(true)"
        TupleExpression
           Type: bool
           Source: "(true)"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "putHashes" - public
     Source: "function putHashes(uint _num) external {\r\n        uint n=0;\r\n        for(;n<_num;n++){\r\n            if(!putHash()){\r\n                return;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _num)"
      VariableDeclaration "_num"
         Type: uint256
         Source: "uint _num"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint n=0;\r\n        for(;n<_num;n++){\r\n            if(!putHash()){\r\n                return;\r\n            }\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint n=0"
        VariableDeclaration "n"
           Type: uint256
           Source: "uint n"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for(;n<_num;n++){\r\n            if(!putHash()){\r\n                return;\r\n            }\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "n<_num"
          Identifier n
             Type: uint256
             Source: "n"
          Identifier _num
             Type: uint256
             Source: "_num"
        ExpressionStatement
           Gas costs: 19
           Source: "n++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "n++"
            Identifier n
               Type: uint256
               Source: "n"
        Block
           Source: "{\r\n            if(!putHash()){\r\n                return;\r\n            }\r\n        }"
          IfStatement
             Source: "if(!putHash()){\r\n                return;\r\n            }"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: 18
               Source: "!putHash()"
              FunctionCall
                 Type: bool
                 Source: "putHash()"
                Identifier putHash
                   Type: function () returns (bool)
                   Source: "putHash"
            Block
               Source: "{\r\n                return;\r\n            }"
              Return
                 Gas costs: 11
                 Source: "return;"
