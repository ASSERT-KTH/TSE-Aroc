Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xb8cfc6bffd8fceb2dba36f1184020616d81880d3.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.15;"
ContractDefinition "ERC20"
   Gas costs: [???]
   Source: "contract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint public totalSupply"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) constant returns (uint);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) constant returns (uint);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint value) returns (bool ok);"
    ParameterList
       Source: "(address to, uint value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint value) returns (bool ok);"
    ParameterList
       Source: "(address from, address to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint value) returns (bool ok);"
    ParameterList
       Source: "(address spender, uint value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "SafeMath"
   Source: "contract SafeMath {\r\n    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n}"
  FunctionDefinition "add" - const
     Source: "function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x + y) >= x);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 z)"
      VariableDeclaration "z"
         Type: uint256
         Source: "uint256 z"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        assert((z = x + y) >= x);\r\n    }"
      ExpressionStatement
         Gas costs: 46
         Source: "assert((z = x + y) >= x)"
        FunctionCall
           Type: tuple()
           Source: "assert((z = x + y) >= x)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "(z = x + y) >= x"
            TupleExpression
               Type: uint256
               Source: "(z = x + y)"
              Assignment using operator =
                 Type: uint256
                 Source: "z = x + y"
                Identifier z
                   Type: uint256
                   Source: "z"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "x + y"
                  Identifier x
                     Type: uint256
                     Source: "x"
                  Identifier y
                     Type: uint256
                     Source: "y"
            Identifier x
               Type: uint256
               Source: "x"
  FunctionDefinition "sub" - const
     Source: "function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x - y) <= x);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256 z)"
      VariableDeclaration "z"
         Type: uint256
         Source: "uint256 z"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        assert((z = x - y) <= x);\r\n    }"
      ExpressionStatement
         Gas costs: 46
         Source: "assert((z = x - y) <= x)"
        FunctionCall
           Type: tuple()
           Source: "assert((z = x - y) <= x)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "(z = x - y) <= x"
            TupleExpression
               Type: uint256
               Source: "(z = x - y)"
              Assignment using operator =
                 Type: uint256
                 Source: "z = x - y"
                Identifier z
                   Type: uint256
                   Source: "z"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "x - y"
                  Identifier x
                     Type: uint256
                     Source: "x"
                  Identifier y
                     Type: uint256
                     Source: "y"
            Identifier x
               Type: uint256
               Source: "x"
  FunctionDefinition "mul" - const
     Source: "function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x * y) >= x);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256 z)"
      VariableDeclaration "z"
         Type: uint256
         Source: "uint256 z"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        assert((z = x * y) >= x);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert((z = x * y) >= x)"
        FunctionCall
           Type: tuple()
           Source: "assert((z = x * y) >= x)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "(z = x * y) >= x"
            TupleExpression
               Type: uint256
               Source: "(z = x * y)"
              Assignment using operator =
                 Type: uint256
                 Source: "z = x * y"
                Identifier z
                   Type: uint256
                   Source: "z"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "x * y"
                  Identifier x
                     Type: uint256
                     Source: "x"
                  Identifier y
                     Type: uint256
                     Source: "y"
            Identifier x
               Type: uint256
               Source: "x"
  FunctionDefinition "div" - const
     Source: "function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = x / y;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256 z)"
      VariableDeclaration "z"
         Type: uint256
         Source: "uint256 z"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        z = x / y;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "z = x / y"
        Assignment using operator =
           Type: uint256
           Source: "z = x / y"
          Identifier z
             Type: uint256
             Source: "z"
          BinaryOperation using operator /
             Type: uint256
             Source: "x / y"
            Identifier x
               Type: uint256
               Source: "x"
            Identifier y
               Type: uint256
               Source: "y"
  FunctionDefinition "min" - const
     Source: "function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256 z)"
      VariableDeclaration "z"
         Type: uint256
         Source: "uint256 z"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return x <= y ? x : y;\r\n    }"
      Return
         Gas costs: 0
         Source: "return x <= y ? x : y"
        Conditional
           Type: uint256
           Source: "x <= y ? x : y"
          BinaryOperation using operator <=
             Type: bool
             Source: "x <= y"
            Identifier x
               Type: uint256
               Source: "x"
            Identifier y
               Type: uint256
               Source: "y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
  FunctionDefinition "max" - const
     Source: "function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256 z)"
      VariableDeclaration "z"
         Type: uint256
         Source: "uint256 z"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return x >= y ? x : y;\r\n    }"
      Return
         Gas costs: 0
         Source: "return x >= y ? x : y"
        Conditional
           Type: uint256
           Source: "x >= y ? x : y"
          BinaryOperation using operator >=
             Type: bool
             Source: "x >= y"
            Identifier x
               Type: uint256
               Source: "x"
            Identifier y
               Type: uint256
               Source: "y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
ContractDefinition "DateTime"
   Source: "contract DateTime {\r\n        /*\r\n         *  Date and Time utilities for ethereum contracts\r\n         *\r\n         */\r\n        struct DateTime {\r\n                uint16 year;\r\n                uint8 month;\r\n                uint8 day;\r\n                uint8 hour;\r\n                uint8 minute;\r\n                uint8 second;\r\n                uint8 weekday;\r\n        }\r\n\r\n        uint constant DAY_IN_SECONDS = 86400;\r\n        uint constant YEAR_IN_SECONDS = 31536000;\r\n        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n        uint constant HOUR_IN_SECONDS = 3600;\r\n        uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n        uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n        function isLeapYear(uint16 year) constant returns (bool) {\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }\r\n\r\n        function leapYearsBefore(uint year) constant returns (uint) {\r\n                year -= 1;\r\n                return year / 4 - year / 100 + year / 400;\r\n        }\r\n\r\n        function getDaysInMonth(uint8 month, uint16 year) constant returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\r\n\r\n        function parseTimestamp(uint timestamp) internal returns (DateTime dt) {\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                // Year\r\n                dt.year = getYear(timestamp);\r\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n                // Month\r\n                uint secondsInMonth;\r\n                for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n                // Day\r\n                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }\r\n\r\n                // Hour\r\n                dt.hour = getHour(timestamp);\r\n        }\r\n\r\n        function getYear(uint timestamp) constant returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                // Year\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\r\n\r\n        function getMonth(uint timestamp) constant returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\r\n\r\n        function getDay(uint timestamp) constant returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\r\n\r\n        function getHour(uint timestamp) constant returns (uint8) {\r\n                return uint8((timestamp / 60 / 60) % 24);\r\n        }\r\n}"
  StructDefinition "DateTime"
     Gas costs: 0
     Source: "struct DateTime {\r\n                uint16 year;\r\n                uint8 month;\r\n                uint8 day;\r\n                uint8 hour;\r\n                uint8 minute;\r\n                uint8 second;\r\n                uint8 weekday;\r\n        }"
    VariableDeclaration "year"
       Type: uint16
       Source: "uint16 year"
      ElementaryTypeName uint16
         Source: "uint16"
    VariableDeclaration "month"
       Type: uint8
       Source: "uint8 month"
      ElementaryTypeName uint8
         Source: "uint8"
    VariableDeclaration "day"
       Type: uint8
       Source: "uint8 day"
      ElementaryTypeName uint8
         Source: "uint8"
    VariableDeclaration "hour"
       Type: uint8
       Source: "uint8 hour"
      ElementaryTypeName uint8
         Source: "uint8"
    VariableDeclaration "minute"
       Type: uint8
       Source: "uint8 minute"
      ElementaryTypeName uint8
         Source: "uint8"
    VariableDeclaration "second"
       Type: uint8
       Source: "uint8 second"
      ElementaryTypeName uint8
         Source: "uint8"
    VariableDeclaration "weekday"
       Type: uint8
       Source: "uint8 weekday"
      ElementaryTypeName uint8
         Source: "uint8"
  VariableDeclaration "DAY_IN_SECONDS"
     Type: uint256
     Gas costs: 0
     Source: "uint constant DAY_IN_SECONDS = 86400"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 86400
       Type: int_const 86400
       Source: "86400"
  VariableDeclaration "YEAR_IN_SECONDS"
     Type: uint256
     Gas costs: 0
     Source: "uint constant YEAR_IN_SECONDS = 31536000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 31536000
       Type: int_const 31536000
       Source: "31536000"
  VariableDeclaration "LEAP_YEAR_IN_SECONDS"
     Type: uint256
     Gas costs: 0
     Source: "uint constant LEAP_YEAR_IN_SECONDS = 31622400"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 31622400
       Type: int_const 31622400
       Source: "31622400"
  VariableDeclaration "HOUR_IN_SECONDS"
     Type: uint256
     Gas costs: 0
     Source: "uint constant HOUR_IN_SECONDS = 3600"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 3600
       Type: int_const 3600
       Source: "3600"
  VariableDeclaration "MINUTE_IN_SECONDS"
     Type: uint256
     Gas costs: 0
     Source: "uint constant MINUTE_IN_SECONDS = 60"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 60
       Type: int_const 60
       Source: "60"
  VariableDeclaration "ORIGIN_YEAR"
     Type: uint16
     Gas costs: 0
     Source: "uint16 constant ORIGIN_YEAR = 1970"
    ElementaryTypeName uint16
       Source: "uint16"
    Literal, token: [no token] value: 1970
       Type: int_const 1970
       Source: "1970"
  FunctionDefinition "isLeapYear" - public - const
     Source: "function isLeapYear(uint16 year) constant returns (bool) {\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }"
    ParameterList
       Gas costs: 0
       Source: "(uint16 year)"
      VariableDeclaration "year"
         Type: uint16
         Source: "uint16 year"
        ElementaryTypeName uint16
           Source: "uint16"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }"
      IfStatement
         Source: "if (year % 4 != 0) {\r\n                        return false;\r\n                }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "year % 4 != 0"
          BinaryOperation using operator %
             Type: uint16
             Source: "year % 4"
            Identifier year
               Type: uint16
               Source: "year"
            Literal, token: [no token] value: 4
               Type: int_const 4
               Source: "4"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n                        return false;\r\n                }"
          Return
             Gas costs: 0
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      IfStatement
         Source: "if (year % 100 != 0) {\r\n                        return true;\r\n                }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "year % 100 != 0"
          BinaryOperation using operator %
             Type: uint16
             Source: "year % 100"
            Identifier year
               Type: uint16
               Source: "year"
            Literal, token: [no token] value: 100
               Type: int_const 100
               Source: "100"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n                        return true;\r\n                }"
          Return
             Gas costs: 0
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      IfStatement
         Source: "if (year % 400 != 0) {\r\n                        return false;\r\n                }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "year % 400 != 0"
          BinaryOperation using operator %
             Type: uint16
             Source: "year % 400"
            Identifier year
               Type: uint16
               Source: "year"
            Literal, token: [no token] value: 400
               Type: int_const 400
               Source: "400"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n                        return false;\r\n                }"
          Return
             Gas costs: 0
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "leapYearsBefore" - public - const
     Source: "function leapYearsBefore(uint year) constant returns (uint) {\r\n                year -= 1;\r\n                return year / 4 - year / 100 + year / 400;\r\n        }"
    ParameterList
       Gas costs: 0
       Source: "(uint year)"
      VariableDeclaration "year"
         Type: uint256
         Source: "uint year"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n                year -= 1;\r\n                return year / 4 - year / 100 + year / 400;\r\n        }"
      ExpressionStatement
         Gas costs: 0
         Source: "year -= 1"
        Assignment using operator -=
           Type: uint256
           Source: "year -= 1"
          Identifier year
             Type: uint256
             Source: "year"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      Return
         Gas costs: 0
         Source: "return year / 4 - year / 100 + year / 400"
        BinaryOperation using operator +
           Type: uint256
           Source: "year / 4 - year / 100 + year / 400"
          BinaryOperation using operator -
             Type: uint256
             Source: "year / 4 - year / 100"
            BinaryOperation using operator /
               Type: uint256
               Source: "year / 4"
              Identifier year
                 Type: uint256
                 Source: "year"
              Literal, token: [no token] value: 4
                 Type: int_const 4
                 Source: "4"
            BinaryOperation using operator /
               Type: uint256
               Source: "year / 100"
              Identifier year
                 Type: uint256
                 Source: "year"
              Literal, token: [no token] value: 100
                 Type: int_const 100
                 Source: "100"
          BinaryOperation using operator /
             Type: uint256
             Source: "year / 400"
            Identifier year
               Type: uint256
               Source: "year"
            Literal, token: [no token] value: 400
               Type: int_const 400
               Source: "400"
  FunctionDefinition "getDaysInMonth" - public - const
     Source: "function getDaysInMonth(uint8 month, uint16 year) constant returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }"
    ParameterList
       Gas costs: 0
       Source: "(uint8 month, uint16 year)"
      VariableDeclaration "month"
         Type: uint8
         Source: "uint8 month"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "year"
         Type: uint16
         Source: "uint16 year"
        ElementaryTypeName uint16
           Source: "uint16"
    ParameterList
       Gas costs: 0
       Source: "(uint8)"
      VariableDeclaration ""
         Type: uint8
         Source: "uint8"
        ElementaryTypeName uint8
           Source: "uint8"
    Block
       Source: "{\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }"
      IfStatement
         Source: "if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 0
           Source: "month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12"
          BinaryOperation using operator ||
             Type: bool
             Source: "month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10"
            BinaryOperation using operator ||
               Type: bool
               Source: "month == 1 || month == 3 || month == 5 || month == 7 || month == 8"
              BinaryOperation using operator ||
                 Type: bool
                 Source: "month == 1 || month == 3 || month == 5 || month == 7"
                BinaryOperation using operator ||
                   Type: bool
                   Source: "month == 1 || month == 3 || month == 5"
                  BinaryOperation using operator ||
                     Type: bool
                     Source: "month == 1 || month == 3"
                    BinaryOperation using operator ==
                       Type: bool
                       Source: "month == 1"
                      Identifier month
                         Type: uint8
                         Source: "month"
                      Literal, token: [no token] value: 1
                         Type: int_const 1
                         Source: "1"
                    BinaryOperation using operator ==
                       Type: bool
                       Source: "month == 3"
                      Identifier month
                         Type: uint8
                         Source: "month"
                      Literal, token: [no token] value: 3
                         Type: int_const 3
                         Source: "3"
                  BinaryOperation using operator ==
                     Type: bool
                     Source: "month == 5"
                    Identifier month
                       Type: uint8
                       Source: "month"
                    Literal, token: [no token] value: 5
                       Type: int_const 5
                       Source: "5"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "month == 7"
                  Identifier month
                     Type: uint8
                     Source: "month"
                  Literal, token: [no token] value: 7
                     Type: int_const 7
                     Source: "7"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "month == 8"
                Identifier month
                   Type: uint8
                   Source: "month"
                Literal, token: [no token] value: 8
                   Type: int_const 8
                   Source: "8"
            BinaryOperation using operator ==
               Type: bool
               Source: "month == 10"
              Identifier month
                 Type: uint8
                 Source: "month"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
          BinaryOperation using operator ==
             Type: bool
             Source: "month == 12"
            Identifier month
               Type: uint8
               Source: "month"
            Literal, token: [no token] value: 12
               Type: int_const 12
               Source: "12"
        Block
           Source: "{\r\n                        return 31;\r\n                }"
          Return
             Gas costs: 0
             Source: "return 31"
            Literal, token: [no token] value: 31
               Type: int_const 31
               Source: "31"
        IfStatement
           Source: "if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }"
          BinaryOperation using operator ||
             Type: bool
             Gas costs: 0
             Source: "month == 4 || month == 6 || month == 9 || month == 11"
            BinaryOperation using operator ||
               Type: bool
               Source: "month == 4 || month == 6 || month == 9"
              BinaryOperation using operator ||
                 Type: bool
                 Source: "month == 4 || month == 6"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "month == 4"
                  Identifier month
                     Type: uint8
                     Source: "month"
                  Literal, token: [no token] value: 4
                     Type: int_const 4
                     Source: "4"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "month == 6"
                  Identifier month
                     Type: uint8
                     Source: "month"
                  Literal, token: [no token] value: 6
                     Type: int_const 6
                     Source: "6"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "month == 9"
                Identifier month
                   Type: uint8
                   Source: "month"
                Literal, token: [no token] value: 9
                   Type: int_const 9
                   Source: "9"
            BinaryOperation using operator ==
               Type: bool
               Source: "month == 11"
              Identifier month
                 Type: uint8
                 Source: "month"
              Literal, token: [no token] value: 11
                 Type: int_const 11
                 Source: "11"
          Block
             Source: "{\r\n                        return 30;\r\n                }"
            Return
               Gas costs: 0
               Source: "return 30"
              Literal, token: [no token] value: 30
                 Type: int_const 30
                 Source: "30"
          IfStatement
             Source: "if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }"
            FunctionCall
               Type: bool
               Gas costs: 0
               Source: "isLeapYear(year)"
              Identifier isLeapYear
                 Type: function (uint16) view returns (bool)
                 Source: "isLeapYear"
              Identifier year
                 Type: uint16
                 Source: "year"
            Block
               Source: "{\r\n                        return 29;\r\n                }"
              Return
                 Gas costs: 0
                 Source: "return 29"
                Literal, token: [no token] value: 29
                   Type: int_const 29
                   Source: "29"
            Block
               Source: "{\r\n                        return 28;\r\n                }"
              Return
                 Gas costs: 0
                 Source: "return 28"
                Literal, token: [no token] value: 28
                   Type: int_const 28
                   Source: "28"
  FunctionDefinition "parseTimestamp"
     Source: "function parseTimestamp(uint timestamp) internal returns (DateTime dt) {\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                // Year\r\n                dt.year = getYear(timestamp);\r\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n                // Month\r\n                uint secondsInMonth;\r\n                for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n                // Day\r\n                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }\r\n\r\n                // Hour\r\n                dt.hour = getHour(timestamp);\r\n        }"
    ParameterList
       Gas costs: 0
       Source: "(uint timestamp)"
      VariableDeclaration "timestamp"
         Type: uint256
         Source: "uint timestamp"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(DateTime dt)"
      VariableDeclaration "dt"
         Type: struct DateTime.DateTime memory
         Source: "DateTime dt"
        UserDefinedTypeName "DateTime"
           Source: "DateTime"
    Block
       Source: "{\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                // Year\r\n                dt.year = getYear(timestamp);\r\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n                // Month\r\n                uint secondsInMonth;\r\n                for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n                // Day\r\n                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }\r\n\r\n                // Hour\r\n                dt.hour = getHour(timestamp);\r\n        }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint secondsAccountedFor = 0"
        VariableDeclaration "secondsAccountedFor"
           Type: uint256
           Source: "uint secondsAccountedFor"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint buf"
        VariableDeclaration "buf"
           Type: uint256
           Source: "uint buf"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint8 i"
        VariableDeclaration "i"
           Type: uint8
           Source: "uint8 i"
          ElementaryTypeName uint8
             Source: "uint8"
      ExpressionStatement
         Gas costs: 0
         Source: "dt.year = getYear(timestamp)"
        Assignment using operator =
           Type: uint16
           Source: "dt.year = getYear(timestamp)"
          MemberAccess to member year
             Type: uint16
             Source: "dt.year"
            Identifier dt
               Type: struct DateTime.DateTime memory
               Source: "dt"
          FunctionCall
             Type: uint16
             Source: "getYear(timestamp)"
            Identifier getYear
               Type: function (uint256) view returns (uint16)
               Source: "getYear"
            Identifier timestamp
               Type: uint256
               Source: "timestamp"
      ExpressionStatement
         Gas costs: 0
         Source: "buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR)"
        Assignment using operator =
           Type: uint256
           Source: "buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR)"
          Identifier buf
             Type: uint256
             Source: "buf"
          BinaryOperation using operator -
             Type: uint256
             Source: "leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR)"
            FunctionCall
               Type: uint256
               Source: "leapYearsBefore(dt.year)"
              Identifier leapYearsBefore
                 Type: function (uint256) view returns (uint256)
                 Source: "leapYearsBefore"
              MemberAccess to member year
                 Type: uint16
                 Source: "dt.year"
                Identifier dt
                   Type: struct DateTime.DateTime memory
                   Source: "dt"
            FunctionCall
               Type: uint256
               Source: "leapYearsBefore(ORIGIN_YEAR)"
              Identifier leapYearsBefore
                 Type: function (uint256) view returns (uint256)
                 Source: "leapYearsBefore"
              Identifier ORIGIN_YEAR
                 Type: uint16
                 Source: "ORIGIN_YEAR"
      ExpressionStatement
         Gas costs: 0
         Source: "secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf"
        Assignment using operator +=
           Type: uint256
           Source: "secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf"
          Identifier secondsAccountedFor
             Type: uint256
             Source: "secondsAccountedFor"
          BinaryOperation using operator *
             Type: uint256
             Source: "LEAP_YEAR_IN_SECONDS * buf"
            Identifier LEAP_YEAR_IN_SECONDS
               Type: uint256
               Source: "LEAP_YEAR_IN_SECONDS"
            Identifier buf
               Type: uint256
               Source: "buf"
      ExpressionStatement
         Gas costs: 0
         Source: "secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf)"
        Assignment using operator +=
           Type: uint256
           Source: "secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf)"
          Identifier secondsAccountedFor
             Type: uint256
             Source: "secondsAccountedFor"
          BinaryOperation using operator *
             Type: uint256
             Source: "YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf)"
            Identifier YEAR_IN_SECONDS
               Type: uint256
               Source: "YEAR_IN_SECONDS"
            TupleExpression
               Type: uint256
               Source: "(dt.year - ORIGIN_YEAR - buf)"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "dt.year - ORIGIN_YEAR - buf"
                BinaryOperation using operator -
                   Type: uint16
                   Source: "dt.year - ORIGIN_YEAR"
                  MemberAccess to member year
                     Type: uint16
                     Source: "dt.year"
                    Identifier dt
                       Type: struct DateTime.DateTime memory
                       Source: "dt"
                  Identifier ORIGIN_YEAR
                     Type: uint16
                     Source: "ORIGIN_YEAR"
                Identifier buf
                   Type: uint256
                   Source: "buf"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint secondsInMonth"
        VariableDeclaration "secondsInMonth"
           Type: uint256
           Source: "uint secondsInMonth"
          ElementaryTypeName uint
             Source: "uint"
      ForStatement
         Source: "for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }"
        ExpressionStatement
           Gas costs: 0
           Source: "i = 1"
          Assignment using operator =
             Type: uint8
             Source: "i = 1"
            Identifier i
               Type: uint8
               Source: "i"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 0
           Source: "i <= 12"
          Identifier i
             Type: uint8
             Source: "i"
          Literal, token: [no token] value: 12
             Type: int_const 12
             Source: "12"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint8
             Source: "i++"
            Identifier i
               Type: uint8
               Source: "i"
        Block
           Source: "{\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }"
          ExpressionStatement
             Gas costs: 0
             Source: "secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year)"
            Assignment using operator =
               Type: uint256
               Source: "secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year)"
              Identifier secondsInMonth
                 Type: uint256
                 Source: "secondsInMonth"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "DAY_IN_SECONDS * getDaysInMonth(i, dt.year)"
                Identifier DAY_IN_SECONDS
                   Type: uint256
                   Source: "DAY_IN_SECONDS"
                FunctionCall
                   Type: uint8
                   Source: "getDaysInMonth(i, dt.year)"
                  Identifier getDaysInMonth
                     Type: function (uint8,uint16) view returns (uint8)
                     Source: "getDaysInMonth"
                  Identifier i
                     Type: uint8
                     Source: "i"
                  MemberAccess to member year
                     Type: uint16
                     Source: "dt.year"
                    Identifier dt
                       Type: struct DateTime.DateTime memory
                       Source: "dt"
          IfStatement
             Source: "if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 0
               Source: "secondsInMonth + secondsAccountedFor > timestamp"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "secondsInMonth + secondsAccountedFor"
                Identifier secondsInMonth
                   Type: uint256
                   Source: "secondsInMonth"
                Identifier secondsAccountedFor
                   Type: uint256
                   Source: "secondsAccountedFor"
              Identifier timestamp
                 Type: uint256
                 Source: "timestamp"
            Block
               Source: "{\r\n                                dt.month = i;\r\n                                break;\r\n                        }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "dt.month = i"
                Assignment using operator =
                   Type: uint8
                   Source: "dt.month = i"
                  MemberAccess to member month
                     Type: uint8
                     Source: "dt.month"
                    Identifier dt
                       Type: struct DateTime.DateTime memory
                       Source: "dt"
                  Identifier i
                     Type: uint8
                     Source: "i"
              Break
                 Gas costs: 0
                 Source: "break"
          ExpressionStatement
             Gas costs: 0
             Source: "secondsAccountedFor += secondsInMonth"
            Assignment using operator +=
               Type: uint256
               Source: "secondsAccountedFor += secondsInMonth"
              Identifier secondsAccountedFor
                 Type: uint256
                 Source: "secondsAccountedFor"
              Identifier secondsInMonth
                 Type: uint256
                 Source: "secondsInMonth"
      ForStatement
         Source: "for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }"
        ExpressionStatement
           Gas costs: 0
           Source: "i = 1"
          Assignment using operator =
             Type: uint8
             Source: "i = 1"
            Identifier i
               Type: uint8
               Source: "i"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 0
           Source: "i <= getDaysInMonth(dt.month, dt.year)"
          Identifier i
             Type: uint8
             Source: "i"
          FunctionCall
             Type: uint8
             Source: "getDaysInMonth(dt.month, dt.year)"
            Identifier getDaysInMonth
               Type: function (uint8,uint16) view returns (uint8)
               Source: "getDaysInMonth"
            MemberAccess to member month
               Type: uint8
               Source: "dt.month"
              Identifier dt
                 Type: struct DateTime.DateTime memory
                 Source: "dt"
            MemberAccess to member year
               Type: uint16
               Source: "dt.year"
              Identifier dt
                 Type: struct DateTime.DateTime memory
                 Source: "dt"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint8
             Source: "i++"
            Identifier i
               Type: uint8
               Source: "i"
        Block
           Source: "{\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }"
          IfStatement
             Source: "if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 0
               Source: "DAY_IN_SECONDS + secondsAccountedFor > timestamp"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "DAY_IN_SECONDS + secondsAccountedFor"
                Identifier DAY_IN_SECONDS
                   Type: uint256
                   Source: "DAY_IN_SECONDS"
                Identifier secondsAccountedFor
                   Type: uint256
                   Source: "secondsAccountedFor"
              Identifier timestamp
                 Type: uint256
                 Source: "timestamp"
            Block
               Source: "{\r\n                                dt.day = i;\r\n                                break;\r\n                        }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "dt.day = i"
                Assignment using operator =
                   Type: uint8
                   Source: "dt.day = i"
                  MemberAccess to member day
                     Type: uint8
                     Source: "dt.day"
                    Identifier dt
                       Type: struct DateTime.DateTime memory
                       Source: "dt"
                  Identifier i
                     Type: uint8
                     Source: "i"
              Break
                 Gas costs: 0
                 Source: "break"
          ExpressionStatement
             Gas costs: 0
             Source: "secondsAccountedFor += DAY_IN_SECONDS"
            Assignment using operator +=
               Type: uint256
               Source: "secondsAccountedFor += DAY_IN_SECONDS"
              Identifier secondsAccountedFor
                 Type: uint256
                 Source: "secondsAccountedFor"
              Identifier DAY_IN_SECONDS
                 Type: uint256
                 Source: "DAY_IN_SECONDS"
      ExpressionStatement
         Gas costs: 0
         Source: "dt.hour = getHour(timestamp)"
        Assignment using operator =
           Type: uint8
           Source: "dt.hour = getHour(timestamp)"
          MemberAccess to member hour
             Type: uint8
             Source: "dt.hour"
            Identifier dt
               Type: struct DateTime.DateTime memory
               Source: "dt"
          FunctionCall
             Type: uint8
             Source: "getHour(timestamp)"
            Identifier getHour
               Type: function (uint256) view returns (uint8)
               Source: "getHour"
            Identifier timestamp
               Type: uint256
               Source: "timestamp"
  FunctionDefinition "getYear" - public - const
     Source: "function getYear(uint timestamp) constant returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                // Year\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }"
    ParameterList
       Gas costs: 0
       Source: "(uint timestamp)"
      VariableDeclaration "timestamp"
         Type: uint256
         Source: "uint timestamp"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint16)"
      VariableDeclaration ""
         Type: uint16
         Source: "uint16"
        ElementaryTypeName uint16
           Source: "uint16"
    Block
       Source: "{\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                // Year\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint secondsAccountedFor = 0"
        VariableDeclaration "secondsAccountedFor"
           Type: uint256
           Source: "uint secondsAccountedFor"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint16 year"
        VariableDeclaration "year"
           Type: uint16
           Source: "uint16 year"
          ElementaryTypeName uint16
             Source: "uint16"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint numLeapYears"
        VariableDeclaration "numLeapYears"
           Type: uint256
           Source: "uint numLeapYears"
          ElementaryTypeName uint
             Source: "uint"
      ExpressionStatement
         Gas costs: 0
         Source: "year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS)"
        Assignment using operator =
           Type: uint16
           Source: "year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS)"
          Identifier year
             Type: uint16
             Source: "year"
          FunctionCall
             Type: uint16
             Source: "uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS)"
            ElementaryTypeNameExpression uint16
               Type: type(uint16)
               Source: "uint16"
            BinaryOperation using operator +
               Type: uint256
               Source: "ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS"
              Identifier ORIGIN_YEAR
                 Type: uint16
                 Source: "ORIGIN_YEAR"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "timestamp / YEAR_IN_SECONDS"
                Identifier timestamp
                   Type: uint256
                   Source: "timestamp"
                Identifier YEAR_IN_SECONDS
                   Type: uint256
                   Source: "YEAR_IN_SECONDS"
      ExpressionStatement
         Gas costs: 0
         Source: "numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR)"
        Assignment using operator =
           Type: uint256
           Source: "numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR)"
          Identifier numLeapYears
             Type: uint256
             Source: "numLeapYears"
          BinaryOperation using operator -
             Type: uint256
             Source: "leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR)"
            FunctionCall
               Type: uint256
               Source: "leapYearsBefore(year)"
              Identifier leapYearsBefore
                 Type: function (uint256) view returns (uint256)
                 Source: "leapYearsBefore"
              Identifier year
                 Type: uint16
                 Source: "year"
            FunctionCall
               Type: uint256
               Source: "leapYearsBefore(ORIGIN_YEAR)"
              Identifier leapYearsBefore
                 Type: function (uint256) view returns (uint256)
                 Source: "leapYearsBefore"
              Identifier ORIGIN_YEAR
                 Type: uint16
                 Source: "ORIGIN_YEAR"
      ExpressionStatement
         Gas costs: 0
         Source: "secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears"
        Assignment using operator +=
           Type: uint256
           Source: "secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears"
          Identifier secondsAccountedFor
             Type: uint256
             Source: "secondsAccountedFor"
          BinaryOperation using operator *
             Type: uint256
             Source: "LEAP_YEAR_IN_SECONDS * numLeapYears"
            Identifier LEAP_YEAR_IN_SECONDS
               Type: uint256
               Source: "LEAP_YEAR_IN_SECONDS"
            Identifier numLeapYears
               Type: uint256
               Source: "numLeapYears"
      ExpressionStatement
         Gas costs: 0
         Source: "secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears)"
        Assignment using operator +=
           Type: uint256
           Source: "secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears)"
          Identifier secondsAccountedFor
             Type: uint256
             Source: "secondsAccountedFor"
          BinaryOperation using operator *
             Type: uint256
             Source: "YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears)"
            Identifier YEAR_IN_SECONDS
               Type: uint256
               Source: "YEAR_IN_SECONDS"
            TupleExpression
               Type: uint256
               Source: "(year - ORIGIN_YEAR - numLeapYears)"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "year - ORIGIN_YEAR - numLeapYears"
                BinaryOperation using operator -
                   Type: uint16
                   Source: "year - ORIGIN_YEAR"
                  Identifier year
                     Type: uint16
                     Source: "year"
                  Identifier ORIGIN_YEAR
                     Type: uint16
                     Source: "ORIGIN_YEAR"
                Identifier numLeapYears
                   Type: uint256
                   Source: "numLeapYears"
      WhileStatement
         Source: "while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "secondsAccountedFor > timestamp"
          Identifier secondsAccountedFor
             Type: uint256
             Source: "secondsAccountedFor"
          Identifier timestamp
             Type: uint256
             Source: "timestamp"
        Block
           Source: "{\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }"
          IfStatement
             Source: "if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }"
            FunctionCall
               Type: bool
               Gas costs: 0
               Source: "isLeapYear(uint16(year - 1))"
              Identifier isLeapYear
                 Type: function (uint16) view returns (bool)
                 Source: "isLeapYear"
              FunctionCall
                 Type: uint16
                 Source: "uint16(year - 1)"
                ElementaryTypeNameExpression uint16
                   Type: type(uint16)
                   Source: "uint16"
                BinaryOperation using operator -
                   Type: uint16
                   Source: "year - 1"
                  Identifier year
                     Type: uint16
                     Source: "year"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
            Block
               Source: "{\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "secondsAccountedFor -= LEAP_YEAR_IN_SECONDS"
                Assignment using operator -=
                   Type: uint256
                   Source: "secondsAccountedFor -= LEAP_YEAR_IN_SECONDS"
                  Identifier secondsAccountedFor
                     Type: uint256
                     Source: "secondsAccountedFor"
                  Identifier LEAP_YEAR_IN_SECONDS
                     Type: uint256
                     Source: "LEAP_YEAR_IN_SECONDS"
            Block
               Source: "{\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "secondsAccountedFor -= YEAR_IN_SECONDS"
                Assignment using operator -=
                   Type: uint256
                   Source: "secondsAccountedFor -= YEAR_IN_SECONDS"
                  Identifier secondsAccountedFor
                     Type: uint256
                     Source: "secondsAccountedFor"
                  Identifier YEAR_IN_SECONDS
                     Type: uint256
                     Source: "YEAR_IN_SECONDS"
          ExpressionStatement
             Gas costs: 0
             Source: "year -= 1"
            Assignment using operator -=
               Type: uint16
               Source: "year -= 1"
              Identifier year
                 Type: uint16
                 Source: "year"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      Return
         Gas costs: 0
         Source: "return year"
        Identifier year
           Type: uint16
           Source: "year"
  FunctionDefinition "getMonth" - public - const
     Source: "function getMonth(uint timestamp) constant returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }"
    ParameterList
       Gas costs: 0
       Source: "(uint timestamp)"
      VariableDeclaration "timestamp"
         Type: uint256
         Source: "uint timestamp"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint8)"
      VariableDeclaration ""
         Type: uint8
         Source: "uint8"
        ElementaryTypeName uint8
           Source: "uint8"
    Block
       Source: "{\r\n                return parseTimestamp(timestamp).month;\r\n        }"
      Return
         Gas costs: 0
         Source: "return parseTimestamp(timestamp).month"
        MemberAccess to member month
           Type: uint8
           Source: "parseTimestamp(timestamp).month"
          FunctionCall
             Type: struct DateTime.DateTime memory
             Source: "parseTimestamp(timestamp)"
            Identifier parseTimestamp
               Type: function (uint256) returns (struct DateTime.DateTime memory)
               Source: "parseTimestamp"
            Identifier timestamp
               Type: uint256
               Source: "timestamp"
  FunctionDefinition "getDay" - public - const
     Source: "function getDay(uint timestamp) constant returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }"
    ParameterList
       Gas costs: 0
       Source: "(uint timestamp)"
      VariableDeclaration "timestamp"
         Type: uint256
         Source: "uint timestamp"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint8)"
      VariableDeclaration ""
         Type: uint8
         Source: "uint8"
        ElementaryTypeName uint8
           Source: "uint8"
    Block
       Source: "{\r\n                return parseTimestamp(timestamp).day;\r\n        }"
      Return
         Gas costs: 0
         Source: "return parseTimestamp(timestamp).day"
        MemberAccess to member day
           Type: uint8
           Source: "parseTimestamp(timestamp).day"
          FunctionCall
             Type: struct DateTime.DateTime memory
             Source: "parseTimestamp(timestamp)"
            Identifier parseTimestamp
               Type: function (uint256) returns (struct DateTime.DateTime memory)
               Source: "parseTimestamp"
            Identifier timestamp
               Type: uint256
               Source: "timestamp"
  FunctionDefinition "getHour" - public - const
     Source: "function getHour(uint timestamp) constant returns (uint8) {\r\n                return uint8((timestamp / 60 / 60) % 24);\r\n        }"
    ParameterList
       Gas costs: 0
       Source: "(uint timestamp)"
      VariableDeclaration "timestamp"
         Type: uint256
         Source: "uint timestamp"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint8)"
      VariableDeclaration ""
         Type: uint8
         Source: "uint8"
        ElementaryTypeName uint8
           Source: "uint8"
    Block
       Source: "{\r\n                return uint8((timestamp / 60 / 60) % 24);\r\n        }"
      Return
         Gas costs: 0
         Source: "return uint8((timestamp / 60 / 60) % 24)"
        FunctionCall
           Type: uint8
           Source: "uint8((timestamp / 60 / 60) % 24)"
          ElementaryTypeNameExpression uint8
             Type: type(uint8)
             Source: "uint8"
          BinaryOperation using operator %
             Type: uint256
             Source: "(timestamp / 60 / 60) % 24"
            TupleExpression
               Type: uint256
               Source: "(timestamp / 60 / 60)"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "timestamp / 60 / 60"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "timestamp / 60"
                  Identifier timestamp
                     Type: uint256
                     Source: "timestamp"
                  Literal, token: [no token] value: 60
                     Type: int_const 60
                     Source: "60"
                Literal, token: [no token] value: 60
                   Type: int_const 60
                   Source: "60"
            Literal, token: [no token] value: 24
               Type: int_const 24
               Source: "24"
ContractDefinition "ITGTokenBase"
   Source: "contract ITGTokenBase is ERC20, SafeMath {\r\n\r\n  /* Actual balances of token holders */\r\n  mapping(address => uint) balances;\r\n\r\n  /* approve() allowances */\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  \r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint) balances"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint balance"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return balances[_owner];\r\n  }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
      IfStatement
         Source: "if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 431
           Source: "(_value != 0) && (allowed[msg.sender][_spender] != 0)"
          TupleExpression
             Type: bool
             Source: "(_value != 0)"
            BinaryOperation using operator !=
               Type: bool
               Source: "_value != 0"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          TupleExpression
             Type: bool
             Source: "(allowed[msg.sender][_spender] != 0)"
            BinaryOperation using operator !=
               Type: bool
               Source: "allowed[msg.sender][_spender] != 0"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint remaining"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return allowed[_owner][_spender];\r\n  }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
ContractDefinition "Authable"
   Source: "contract Authable {\r\n    address public owner;\r\n    address public executor;\r\n\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n   \r\n    modifier onlyAuth(){\r\n        require(msg.sender == owner || msg.sender == executor);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _owner){\r\n        require(owner == 0x0 || owner == msg.sender);\r\n        owner = _owner;\r\n    }\r\n\r\n    function setExecutor(address exec) {\r\n        require(executor == 0x0 || owner == msg.sender || executor == msg.sender);\r\n        executor = exec;\r\n    }\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "executor"
     Type: address
     Gas costs: [???]
     Source: "address public executor"
    ElementaryTypeName address
       Source: "address"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 846
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyAuth"
     Source: "modifier onlyAuth(){\r\n        require(msg.sender == owner || msg.sender == executor);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(msg.sender == owner || msg.sender == executor);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 2785
         Source: "require(msg.sender == owner || msg.sender == executor)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner || msg.sender == executor)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "msg.sender == owner || msg.sender == executor"
            BinaryOperation using operator ==
               Type: bool
               Source: "msg.sender == owner"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier owner
                 Type: address
                 Source: "owner"
            BinaryOperation using operator ==
               Type: bool
               Source: "msg.sender == executor"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier executor
                 Type: address
                 Source: "executor"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "setOwner" - public
     Source: "function setOwner(address _owner){\r\n        require(owner == 0x0 || owner == msg.sender);\r\n        owner = _owner;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(owner == 0x0 || owner == msg.sender);\r\n        owner = _owner;\r\n    }"
      ExpressionStatement
         Gas costs: 552
         Source: "require(owner == 0x0 || owner == msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "require(owner == 0x0 || owner == msg.sender)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "owner == 0x0 || owner == msg.sender"
            BinaryOperation using operator ==
               Type: bool
               Source: "owner == 0x0"
              Identifier owner
                 Type: address
                 Source: "owner"
              Literal, token: [no token] value: 0x0
                 Type: int_const 0
                 Source: "0x0"
            BinaryOperation using operator ==
               Type: bool
               Source: "owner == msg.sender"
              Identifier owner
                 Type: address
                 Source: "owner"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = _owner"
        Assignment using operator =
           Type: address
           Source: "owner = _owner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "setExecutor" - public
     Source: "function setExecutor(address exec) {\r\n        require(executor == 0x0 || owner == msg.sender || executor == msg.sender);\r\n        executor = exec;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address exec)"
      VariableDeclaration "exec"
         Type: address
         Source: "address exec"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(executor == 0x0 || owner == msg.sender || executor == msg.sender);\r\n        executor = exec;\r\n    }"
      ExpressionStatement
         Gas costs: 827
         Source: "require(executor == 0x0 || owner == msg.sender || executor == msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "require(executor == 0x0 || owner == msg.sender || executor == msg.sender)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "executor == 0x0 || owner == msg.sender || executor == msg.sender"
            BinaryOperation using operator ||
               Type: bool
               Source: "executor == 0x0 || owner == msg.sender"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "executor == 0x0"
                Identifier executor
                   Type: address
                   Source: "executor"
                Literal, token: [no token] value: 0x0
                   Type: int_const 0
                   Source: "0x0"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "owner == msg.sender"
                Identifier owner
                   Type: address
                   Source: "owner"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            BinaryOperation using operator ==
               Type: bool
               Source: "executor == msg.sender"
              Identifier executor
                 Type: address
                 Source: "executor"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 20267
         Source: "executor = exec"
        Assignment using operator =
           Type: address
           Source: "executor = exec"
          Identifier executor
             Type: address
             Source: "executor"
          Identifier exec
             Type: address
             Source: "exec"
ContractDefinition "CrowdSale"
   Source: "contract CrowdSale is SafeMath, Authable {\r\n\r\n    struct SaleAttr{\r\n        uint amountRaisedTotal;  // Total funding\r\n\r\n        uint saleSupplyPre; // Supply for Pre crowdSale\r\n        uint saleSupply1; // Supply for 1st crowdSale\r\n        uint saleSupply2; // Supply for 2nd crowdSale\r\n        uint saleSupply3; // Supply for 3rd crowdSale\r\n        uint saleSupply4; // Supply for 4th crowdSale\r\n        \r\n        uint amountRaisedPre;   // Only count Pre crowdSale funding for distribute\r\n        uint amountRaised1;     // Only count 1st crowdSale funding for distribute\r\n        uint amountRaised2;     // Only count 2nd crowdSale funding for just record\r\n        uint amountRaised3;     // Only count 3rd crowdSale funding for distribute\r\n        uint amountRaised4;     // Only count 4th crowdSale funding for just record\r\n\r\n        uint soldSupply2;\r\n        uint soldSupply4;\r\n    }\r\n    SaleAttr public s;\r\n    mapping(address => uint) public participantsForPreSale;    // Pre crowdSale participants\r\n    mapping(address => uint) public participantsFor1stSale;    // 1st crowdSale participants\r\n    mapping(address => uint) public participantsFor3rdSale;    // 3rd crowdSale participants\r\n\r\n    event LogCustomSale(uint startTime, uint endTime, uint tokPerEth, uint supply);\r\n\r\n    struct SaleTimeAttr{\r\n        uint pstart;\r\n        uint pdeadline;\r\n\r\n        // 1st, 3rd sale is time based share\r\n        // 2nd, 4th sale is price sale\r\n        uint start;         // When 1st crowdSale starts\r\n        uint deadline1;     // When 1st crowdSale ends and 2nd crowdSale starts\r\n        uint deadline2;     // When 2nd crowdSale ends\r\n        uint deadline3;     // When 3rd crowdSale ends\r\n        uint deadline4;     // When 4th crowdSale ends\r\n    }\r\n    SaleTimeAttr public t;\r\n\r\n    struct CustomSaleAttr{\r\n        uint start;\r\n        uint end;\r\n        uint tokenPerEth;   // 0 means period sale\r\n        uint saleSupply;\r\n        uint soldSupply;\r\n        uint amountRaised;\r\n    }\r\n    CustomSaleAttr public cs;\r\n    mapping(uint => mapping(address => uint)) public participantsForCustomSale;\r\n\r\n    function setAttrs(uint supplyPre, uint supply1, uint supply2, uint supply3, uint supply4\r\n            , uint preStart, uint preEnd, uint start, uint end1, uint end2, uint end3, uint end4\r\n        ) onlyAuth {\r\n        s.saleSupplyPre = supplyPre; // totalSupply * 10 / 100\r\n        //start, deadline1~4 should be set before start\r\n        s.saleSupply1 = supply1;    //totalSupply * 10 / 100;     // 10% of totalSupply. Total 40% to CrowdSale, 5% to dev team, 55% will be used for game and vote\r\n        s.saleSupply2 = supply2;    //totalSupply *  5 / 100;\r\n        s.saleSupply3 = supply3;    //totalSupply * 10 / 100;\r\n        s.saleSupply4 = supply4;    //totalSupply *  5 / 100;\r\n\r\n        t.pstart = preStart;\r\n        t.pdeadline = preEnd;\r\n        t.start = start;\r\n        t.deadline1 = end1;\r\n        t.deadline2 = end2;\r\n        t.deadline3 = end3;\r\n        t.deadline4 = end4;\r\n    }\r\n\r\n    function setAttrCustom(uint startTime, uint endTime, uint tokPerEth, uint supply) onlyAuth {\r\n        cs.start = startTime;\r\n        cs.end = endTime;\r\n        cs.tokenPerEth = tokPerEth;\r\n        cs.saleSupply = supply;\r\n        cs.soldSupply = 0;\r\n        cs.amountRaised = 0;\r\n        LogCustomSale(startTime, endTime, tokPerEth, supply);\r\n    }\r\n\r\n    function process(address sender, uint sendValue) onlyOwner returns (uint tokenAmount) {\r\n        if(now > t.pstart && now <= t.pdeadline){\r\n            participantsForPreSale[sender] = add(participantsForPreSale[sender],sendValue);\r\n            s.amountRaisedPre = add(s.amountRaisedPre, sendValue);\r\n        }else if(now > t.start && now <= t.deadline1){\r\n            participantsFor1stSale[sender] = add(participantsFor1stSale[sender],sendValue);\r\n            s.amountRaised1 = add(s.amountRaised1, sendValue);\r\n        }else if(now > t.deadline1 && now <= t.deadline2 && s.soldSupply2 < s.saleSupply2){\r\n            tokenAmount = sendValue / (s.amountRaised1 / s.saleSupply1 * 120 / 100);    //Token Price = s.amountRaised1 / s.saleSupply1. Price is going up 20%\r\n            s.soldSupply2 = add(s.soldSupply2, tokenAmount);\r\n            s.amountRaised2 = add(s.amountRaised2, sendValue);\r\n\r\n            require(s.soldSupply2 < s.saleSupply2 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > t.deadline2 && now <= t.deadline3){\r\n            participantsFor3rdSale[sender] = add(participantsFor3rdSale[sender],sendValue);\r\n            s.amountRaised3 = add(s.amountRaised3, sendValue);\r\n        }else if(now > t.deadline3 && now <= t.deadline4 && s.soldSupply4 < s.saleSupply4){\r\n            tokenAmount = sendValue / (s.amountRaised3 / s.saleSupply3 * 120 / 100);     //Token Price = s.amountRaised3 / s.saleSupply3. Price is going up 20%\r\n            s.soldSupply4 = add(s.soldSupply4, tokenAmount);\r\n            s.amountRaised4 = add(s.amountRaised4, sendValue);\r\n\r\n            require(s.soldSupply4 < s.saleSupply4 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > cs.start && now <= cs.end && cs.soldSupply < cs.saleSupply){\r\n            if(cs.tokenPerEth > 0){\r\n                tokenAmount = sendValue * cs.tokenPerEth;\r\n                cs.soldSupply = add(cs.soldSupply, tokenAmount);\r\n\r\n                require(cs.soldSupply < cs.saleSupply * 105 / 100); // A little bit more sale is granted for the price sale.\r\n            }else{\r\n                participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue);\r\n                cs.amountRaised = add(cs.amountRaised, sendValue);\r\n            }\r\n        }else{\r\n            throw;\r\n        }\r\n        s.amountRaisedTotal = add(s.amountRaisedTotal, sendValue);\r\n    }\r\n\r\n    function getToken(address sender) onlyOwner returns (uint tokenAmount){\r\n        if(now > t.pdeadline && participantsForPreSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsForPreSale[sender] * s.saleSupplyPre / s.amountRaisedPre);  //Token Amount Per Eth = s.saleSupplyPre / s.amountRaisedPre\r\n            participantsForPreSale[sender] = 0;\r\n        }\r\n        if(now > t.deadline1 && participantsFor1stSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsFor1stSale[sender] * s.saleSupply1 / s.amountRaised1);  //Token Amount Per Eth = s.saleSupply1 / s.amountRaised1\r\n            participantsFor1stSale[sender] = 0;\r\n        }\r\n        if(now > t.deadline3 && participantsFor3rdSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsFor3rdSale[sender] * s.saleSupply3 / s.amountRaised3);  //Token Amount Per Eth = s.saleSupply3 / s.amountRaised3\r\n            participantsFor3rdSale[sender] = 0;\r\n        }\r\n        if(now > cs.end && participantsForCustomSale[cs.start][sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsForCustomSale[cs.start][sender] * cs.saleSupply / cs.amountRaised);  //Token Amount Per Eth = cs.saleSupply / cs.amountRaised\r\n            participantsForCustomSale[cs.start][sender] = 0;\r\n        }\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Authable"
    UserDefinedTypeName "Authable"
       Source: "Authable"
  StructDefinition "SaleAttr"
     Gas costs: 0
     Source: "struct SaleAttr{\r\n        uint amountRaisedTotal;  // Total funding\r\n\r\n        uint saleSupplyPre; // Supply for Pre crowdSale\r\n        uint saleSupply1; // Supply for 1st crowdSale\r\n        uint saleSupply2; // Supply for 2nd crowdSale\r\n        uint saleSupply3; // Supply for 3rd crowdSale\r\n        uint saleSupply4; // Supply for 4th crowdSale\r\n        \r\n        uint amountRaisedPre;   // Only count Pre crowdSale funding for distribute\r\n        uint amountRaised1;     // Only count 1st crowdSale funding for distribute\r\n        uint amountRaised2;     // Only count 2nd crowdSale funding for just record\r\n        uint amountRaised3;     // Only count 3rd crowdSale funding for distribute\r\n        uint amountRaised4;     // Only count 4th crowdSale funding for just record\r\n\r\n        uint soldSupply2;\r\n        uint soldSupply4;\r\n    }"
    VariableDeclaration "amountRaisedTotal"
       Type: uint256
       Source: "uint amountRaisedTotal"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "saleSupplyPre"
       Type: uint256
       Source: "uint saleSupplyPre"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "saleSupply1"
       Type: uint256
       Source: "uint saleSupply1"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "saleSupply2"
       Type: uint256
       Source: "uint saleSupply2"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "saleSupply3"
       Type: uint256
       Source: "uint saleSupply3"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "saleSupply4"
       Type: uint256
       Source: "uint saleSupply4"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "amountRaisedPre"
       Type: uint256
       Source: "uint amountRaisedPre"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "amountRaised1"
       Type: uint256
       Source: "uint amountRaised1"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "amountRaised2"
       Type: uint256
       Source: "uint amountRaised2"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "amountRaised3"
       Type: uint256
       Source: "uint amountRaised3"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "amountRaised4"
       Type: uint256
       Source: "uint amountRaised4"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "soldSupply2"
       Type: uint256
       Source: "uint soldSupply2"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "soldSupply4"
       Type: uint256
       Source: "uint soldSupply4"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "s"
     Type: struct CrowdSale.SaleAttr storage ref
     Gas costs: 0
     Source: "SaleAttr public s"
    UserDefinedTypeName "SaleAttr"
       Source: "SaleAttr"
  VariableDeclaration "participantsForPreSale"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint) public participantsForPreSale"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "participantsFor1stSale"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint) public participantsFor1stSale"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "participantsFor3rdSale"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint) public participantsFor3rdSale"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  EventDefinition "LogCustomSale"
     Gas costs: 0
     Source: "event LogCustomSale(uint startTime, uint endTime, uint tokPerEth, uint supply);"
    ParameterList
       Source: "(uint startTime, uint endTime, uint tokPerEth, uint supply)"
      VariableDeclaration "startTime"
         Type: uint256
         Source: "uint startTime"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "endTime"
         Type: uint256
         Source: "uint endTime"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "tokPerEth"
         Type: uint256
         Source: "uint tokPerEth"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "supply"
         Type: uint256
         Source: "uint supply"
        ElementaryTypeName uint
           Source: "uint"
  StructDefinition "SaleTimeAttr"
     Gas costs: 0
     Source: "struct SaleTimeAttr{\r\n        uint pstart;\r\n        uint pdeadline;\r\n\r\n        // 1st, 3rd sale is time based share\r\n        // 2nd, 4th sale is price sale\r\n        uint start;         // When 1st crowdSale starts\r\n        uint deadline1;     // When 1st crowdSale ends and 2nd crowdSale starts\r\n        uint deadline2;     // When 2nd crowdSale ends\r\n        uint deadline3;     // When 3rd crowdSale ends\r\n        uint deadline4;     // When 4th crowdSale ends\r\n    }"
    VariableDeclaration "pstart"
       Type: uint256
       Source: "uint pstart"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "pdeadline"
       Type: uint256
       Source: "uint pdeadline"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "start"
       Type: uint256
       Source: "uint start"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "deadline1"
       Type: uint256
       Source: "uint deadline1"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "deadline2"
       Type: uint256
       Source: "uint deadline2"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "deadline3"
       Type: uint256
       Source: "uint deadline3"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "deadline4"
       Type: uint256
       Source: "uint deadline4"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "t"
     Type: struct CrowdSale.SaleTimeAttr storage ref
     Gas costs: 0
     Source: "SaleTimeAttr public t"
    UserDefinedTypeName "SaleTimeAttr"
       Source: "SaleTimeAttr"
  StructDefinition "CustomSaleAttr"
     Gas costs: 0
     Source: "struct CustomSaleAttr{\r\n        uint start;\r\n        uint end;\r\n        uint tokenPerEth;   // 0 means period sale\r\n        uint saleSupply;\r\n        uint soldSupply;\r\n        uint amountRaised;\r\n    }"
    VariableDeclaration "start"
       Type: uint256
       Source: "uint start"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "end"
       Type: uint256
       Source: "uint end"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "tokenPerEth"
       Type: uint256
       Source: "uint tokenPerEth"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "saleSupply"
       Type: uint256
       Source: "uint saleSupply"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "soldSupply"
       Type: uint256
       Source: "uint soldSupply"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "amountRaised"
       Type: uint256
       Source: "uint amountRaised"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "cs"
     Type: struct CrowdSale.CustomSaleAttr storage ref
     Gas costs: 0
     Source: "CustomSaleAttr public cs"
    UserDefinedTypeName "CustomSaleAttr"
       Source: "CustomSaleAttr"
  VariableDeclaration "participantsForCustomSale"
     Type: mapping(uint256 => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping(uint => mapping(address => uint)) public participantsForCustomSale"
    Mapping
       Source: "mapping(uint => mapping(address => uint))"
      ElementaryTypeName uint
         Source: "uint"
      Mapping
         Source: "mapping(address => uint)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "setAttrs" - public
     Source: "function setAttrs(uint supplyPre, uint supply1, uint supply2, uint supply3, uint supply4\r\n            , uint preStart, uint preEnd, uint start, uint end1, uint end2, uint end3, uint end4\r\n        ) onlyAuth {\r\n        s.saleSupplyPre = supplyPre; // totalSupply * 10 / 100\r\n        //start, deadline1~4 should be set before start\r\n        s.saleSupply1 = supply1;    //totalSupply * 10 / 100;     // 10% of totalSupply. Total 40% to CrowdSale, 5% to dev team, 55% will be used for game and vote\r\n        s.saleSupply2 = supply2;    //totalSupply *  5 / 100;\r\n        s.saleSupply3 = supply3;    //totalSupply * 10 / 100;\r\n        s.saleSupply4 = supply4;    //totalSupply *  5 / 100;\r\n\r\n        t.pstart = preStart;\r\n        t.pdeadline = preEnd;\r\n        t.start = start;\r\n        t.deadline1 = end1;\r\n        t.deadline2 = end2;\r\n        t.deadline3 = end3;\r\n        t.deadline4 = end4;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint supplyPre, uint supply1, uint supply2, uint supply3, uint supply4\r\n            , uint preStart, uint preEnd, uint start, uint end1, uint end2, uint end3, uint end4\r\n        )"
      VariableDeclaration "supplyPre"
         Type: uint256
         Source: "uint supplyPre"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "supply1"
         Type: uint256
         Source: "uint supply1"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "supply2"
         Type: uint256
         Source: "uint supply2"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "supply3"
         Type: uint256
         Source: "uint supply3"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "supply4"
         Type: uint256
         Source: "uint supply4"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "preStart"
         Type: uint256
         Source: "uint preStart"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "preEnd"
         Type: uint256
         Source: "uint preEnd"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "start"
         Type: uint256
         Source: "uint start"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "end1"
         Type: uint256
         Source: "uint end1"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "end2"
         Type: uint256
         Source: "uint end2"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "end3"
         Type: uint256
         Source: "uint end3"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "end4"
         Type: uint256
         Source: "uint end4"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAuth"
       Gas costs: 0
       Source: "onlyAuth"
      Identifier onlyAuth
         Type: modifier ()
         Source: "onlyAuth"
    Block
       Source: "{\r\n        s.saleSupplyPre = supplyPre; // totalSupply * 10 / 100\r\n        //start, deadline1~4 should be set before start\r\n        s.saleSupply1 = supply1;    //totalSupply * 10 / 100;     // 10% of totalSupply. Total 40% to CrowdSale, 5% to dev team, 55% will be used for game and vote\r\n        s.saleSupply2 = supply2;    //totalSupply *  5 / 100;\r\n        s.saleSupply3 = supply3;    //totalSupply * 10 / 100;\r\n        s.saleSupply4 = supply4;    //totalSupply *  5 / 100;\r\n\r\n        t.pstart = preStart;\r\n        t.pdeadline = preEnd;\r\n        t.start = start;\r\n        t.deadline1 = end1;\r\n        t.deadline2 = end2;\r\n        t.deadline3 = end3;\r\n        t.deadline4 = end4;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "s.saleSupplyPre = supplyPre"
        Assignment using operator =
           Type: uint256
           Source: "s.saleSupplyPre = supplyPre"
          MemberAccess to member saleSupplyPre
             Type: uint256
             Source: "s.saleSupplyPre"
            Identifier s
               Type: struct CrowdSale.SaleAttr storage ref
               Source: "s"
          Identifier supplyPre
             Type: uint256
             Source: "supplyPre"
      ExpressionStatement
         Gas costs: 0
         Source: "s.saleSupply1 = supply1"
        Assignment using operator =
           Type: uint256
           Source: "s.saleSupply1 = supply1"
          MemberAccess to member saleSupply1
             Type: uint256
             Source: "s.saleSupply1"
            Identifier s
               Type: struct CrowdSale.SaleAttr storage ref
               Source: "s"
          Identifier supply1
             Type: uint256
             Source: "supply1"
      ExpressionStatement
         Gas costs: 0
         Source: "s.saleSupply2 = supply2"
        Assignment using operator =
           Type: uint256
           Source: "s.saleSupply2 = supply2"
          MemberAccess to member saleSupply2
             Type: uint256
             Source: "s.saleSupply2"
            Identifier s
               Type: struct CrowdSale.SaleAttr storage ref
               Source: "s"
          Identifier supply2
             Type: uint256
             Source: "supply2"
      ExpressionStatement
         Gas costs: 0
         Source: "s.saleSupply3 = supply3"
        Assignment using operator =
           Type: uint256
           Source: "s.saleSupply3 = supply3"
          MemberAccess to member saleSupply3
             Type: uint256
             Source: "s.saleSupply3"
            Identifier s
               Type: struct CrowdSale.SaleAttr storage ref
               Source: "s"
          Identifier supply3
             Type: uint256
             Source: "supply3"
      ExpressionStatement
         Gas costs: 0
         Source: "s.saleSupply4 = supply4"
        Assignment using operator =
           Type: uint256
           Source: "s.saleSupply4 = supply4"
          MemberAccess to member saleSupply4
             Type: uint256
             Source: "s.saleSupply4"
            Identifier s
               Type: struct CrowdSale.SaleAttr storage ref
               Source: "s"
          Identifier supply4
             Type: uint256
             Source: "supply4"
      ExpressionStatement
         Gas costs: 0
         Source: "t.pstart = preStart"
        Assignment using operator =
           Type: uint256
           Source: "t.pstart = preStart"
          MemberAccess to member pstart
             Type: uint256
             Source: "t.pstart"
            Identifier t
               Type: struct CrowdSale.SaleTimeAttr storage ref
               Source: "t"
          Identifier preStart
             Type: uint256
             Source: "preStart"
      ExpressionStatement
         Gas costs: 0
         Source: "t.pdeadline = preEnd"
        Assignment using operator =
           Type: uint256
           Source: "t.pdeadline = preEnd"
          MemberAccess to member pdeadline
             Type: uint256
             Source: "t.pdeadline"
            Identifier t
               Type: struct CrowdSale.SaleTimeAttr storage ref
               Source: "t"
          Identifier preEnd
             Type: uint256
             Source: "preEnd"
      ExpressionStatement
         Gas costs: 0
         Source: "t.start = start"
        Assignment using operator =
           Type: uint256
           Source: "t.start = start"
          MemberAccess to member start
             Type: uint256
             Source: "t.start"
            Identifier t
               Type: struct CrowdSale.SaleTimeAttr storage ref
               Source: "t"
          Identifier start
             Type: uint256
             Source: "start"
      ExpressionStatement
         Gas costs: 0
         Source: "t.deadline1 = end1"
        Assignment using operator =
           Type: uint256
           Source: "t.deadline1 = end1"
          MemberAccess to member deadline1
             Type: uint256
             Source: "t.deadline1"
            Identifier t
               Type: struct CrowdSale.SaleTimeAttr storage ref
               Source: "t"
          Identifier end1
             Type: uint256
             Source: "end1"
      ExpressionStatement
         Gas costs: 0
         Source: "t.deadline2 = end2"
        Assignment using operator =
           Type: uint256
           Source: "t.deadline2 = end2"
          MemberAccess to member deadline2
             Type: uint256
             Source: "t.deadline2"
            Identifier t
               Type: struct CrowdSale.SaleTimeAttr storage ref
               Source: "t"
          Identifier end2
             Type: uint256
             Source: "end2"
      ExpressionStatement
         Gas costs: 0
         Source: "t.deadline3 = end3"
        Assignment using operator =
           Type: uint256
           Source: "t.deadline3 = end3"
          MemberAccess to member deadline3
             Type: uint256
             Source: "t.deadline3"
            Identifier t
               Type: struct CrowdSale.SaleTimeAttr storage ref
               Source: "t"
          Identifier end3
             Type: uint256
             Source: "end3"
      ExpressionStatement
         Gas costs: 0
         Source: "t.deadline4 = end4"
        Assignment using operator =
           Type: uint256
           Source: "t.deadline4 = end4"
          MemberAccess to member deadline4
             Type: uint256
             Source: "t.deadline4"
            Identifier t
               Type: struct CrowdSale.SaleTimeAttr storage ref
               Source: "t"
          Identifier end4
             Type: uint256
             Source: "end4"
  FunctionDefinition "setAttrCustom" - public
     Source: "function setAttrCustom(uint startTime, uint endTime, uint tokPerEth, uint supply) onlyAuth {\r\n        cs.start = startTime;\r\n        cs.end = endTime;\r\n        cs.tokenPerEth = tokPerEth;\r\n        cs.saleSupply = supply;\r\n        cs.soldSupply = 0;\r\n        cs.amountRaised = 0;\r\n        LogCustomSale(startTime, endTime, tokPerEth, supply);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint startTime, uint endTime, uint tokPerEth, uint supply)"
      VariableDeclaration "startTime"
         Type: uint256
         Source: "uint startTime"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "endTime"
         Type: uint256
         Source: "uint endTime"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "tokPerEth"
         Type: uint256
         Source: "uint tokPerEth"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "supply"
         Type: uint256
         Source: "uint supply"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAuth"
       Gas costs: 0
       Source: "onlyAuth"
      Identifier onlyAuth
         Type: modifier ()
         Source: "onlyAuth"
    Block
       Source: "{\r\n        cs.start = startTime;\r\n        cs.end = endTime;\r\n        cs.tokenPerEth = tokPerEth;\r\n        cs.saleSupply = supply;\r\n        cs.soldSupply = 0;\r\n        cs.amountRaised = 0;\r\n        LogCustomSale(startTime, endTime, tokPerEth, supply);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "cs.start = startTime"
        Assignment using operator =
           Type: uint256
           Source: "cs.start = startTime"
          MemberAccess to member start
             Type: uint256
             Source: "cs.start"
            Identifier cs
               Type: struct CrowdSale.CustomSaleAttr storage ref
               Source: "cs"
          Identifier startTime
             Type: uint256
             Source: "startTime"
      ExpressionStatement
         Gas costs: 0
         Source: "cs.end = endTime"
        Assignment using operator =
           Type: uint256
           Source: "cs.end = endTime"
          MemberAccess to member end
             Type: uint256
             Source: "cs.end"
            Identifier cs
               Type: struct CrowdSale.CustomSaleAttr storage ref
               Source: "cs"
          Identifier endTime
             Type: uint256
             Source: "endTime"
      ExpressionStatement
         Gas costs: 0
         Source: "cs.tokenPerEth = tokPerEth"
        Assignment using operator =
           Type: uint256
           Source: "cs.tokenPerEth = tokPerEth"
          MemberAccess to member tokenPerEth
             Type: uint256
             Source: "cs.tokenPerEth"
            Identifier cs
               Type: struct CrowdSale.CustomSaleAttr storage ref
               Source: "cs"
          Identifier tokPerEth
             Type: uint256
             Source: "tokPerEth"
      ExpressionStatement
         Gas costs: 0
         Source: "cs.saleSupply = supply"
        Assignment using operator =
           Type: uint256
           Source: "cs.saleSupply = supply"
          MemberAccess to member saleSupply
             Type: uint256
             Source: "cs.saleSupply"
            Identifier cs
               Type: struct CrowdSale.CustomSaleAttr storage ref
               Source: "cs"
          Identifier supply
             Type: uint256
             Source: "supply"
      ExpressionStatement
         Gas costs: 0
         Source: "cs.soldSupply = 0"
        Assignment using operator =
           Type: uint256
           Source: "cs.soldSupply = 0"
          MemberAccess to member soldSupply
             Type: uint256
             Source: "cs.soldSupply"
            Identifier cs
               Type: struct CrowdSale.CustomSaleAttr storage ref
               Source: "cs"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "cs.amountRaised = 0"
        Assignment using operator =
           Type: uint256
           Source: "cs.amountRaised = 0"
          MemberAccess to member amountRaised
             Type: uint256
             Source: "cs.amountRaised"
            Identifier cs
               Type: struct CrowdSale.CustomSaleAttr storage ref
               Source: "cs"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "LogCustomSale(startTime, endTime, tokPerEth, supply)"
        FunctionCall
           Type: tuple()
           Source: "LogCustomSale(startTime, endTime, tokPerEth, supply)"
          Identifier LogCustomSale
             Type: function (uint256,uint256,uint256,uint256)
             Source: "LogCustomSale"
          Identifier startTime
             Type: uint256
             Source: "startTime"
          Identifier endTime
             Type: uint256
             Source: "endTime"
          Identifier tokPerEth
             Type: uint256
             Source: "tokPerEth"
          Identifier supply
             Type: uint256
             Source: "supply"
  FunctionDefinition "process" - public
     Source: "function process(address sender, uint sendValue) onlyOwner returns (uint tokenAmount) {\r\n        if(now > t.pstart && now <= t.pdeadline){\r\n            participantsForPreSale[sender] = add(participantsForPreSale[sender],sendValue);\r\n            s.amountRaisedPre = add(s.amountRaisedPre, sendValue);\r\n        }else if(now > t.start && now <= t.deadline1){\r\n            participantsFor1stSale[sender] = add(participantsFor1stSale[sender],sendValue);\r\n            s.amountRaised1 = add(s.amountRaised1, sendValue);\r\n        }else if(now > t.deadline1 && now <= t.deadline2 && s.soldSupply2 < s.saleSupply2){\r\n            tokenAmount = sendValue / (s.amountRaised1 / s.saleSupply1 * 120 / 100);    //Token Price = s.amountRaised1 / s.saleSupply1. Price is going up 20%\r\n            s.soldSupply2 = add(s.soldSupply2, tokenAmount);\r\n            s.amountRaised2 = add(s.amountRaised2, sendValue);\r\n\r\n            require(s.soldSupply2 < s.saleSupply2 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > t.deadline2 && now <= t.deadline3){\r\n            participantsFor3rdSale[sender] = add(participantsFor3rdSale[sender],sendValue);\r\n            s.amountRaised3 = add(s.amountRaised3, sendValue);\r\n        }else if(now > t.deadline3 && now <= t.deadline4 && s.soldSupply4 < s.saleSupply4){\r\n            tokenAmount = sendValue / (s.amountRaised3 / s.saleSupply3 * 120 / 100);     //Token Price = s.amountRaised3 / s.saleSupply3. Price is going up 20%\r\n            s.soldSupply4 = add(s.soldSupply4, tokenAmount);\r\n            s.amountRaised4 = add(s.amountRaised4, sendValue);\r\n\r\n            require(s.soldSupply4 < s.saleSupply4 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > cs.start && now <= cs.end && cs.soldSupply < cs.saleSupply){\r\n            if(cs.tokenPerEth > 0){\r\n                tokenAmount = sendValue * cs.tokenPerEth;\r\n                cs.soldSupply = add(cs.soldSupply, tokenAmount);\r\n\r\n                require(cs.soldSupply < cs.saleSupply * 105 / 100); // A little bit more sale is granted for the price sale.\r\n            }else{\r\n                participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue);\r\n                cs.amountRaised = add(cs.amountRaised, sendValue);\r\n            }\r\n        }else{\r\n            throw;\r\n        }\r\n        s.amountRaisedTotal = add(s.amountRaisedTotal, sendValue);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address sender, uint sendValue)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "sendValue"
         Type: uint256
         Source: "uint sendValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint tokenAmount)"
      VariableDeclaration "tokenAmount"
         Type: uint256
         Source: "uint tokenAmount"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        if(now > t.pstart && now <= t.pdeadline){\r\n            participantsForPreSale[sender] = add(participantsForPreSale[sender],sendValue);\r\n            s.amountRaisedPre = add(s.amountRaisedPre, sendValue);\r\n        }else if(now > t.start && now <= t.deadline1){\r\n            participantsFor1stSale[sender] = add(participantsFor1stSale[sender],sendValue);\r\n            s.amountRaised1 = add(s.amountRaised1, sendValue);\r\n        }else if(now > t.deadline1 && now <= t.deadline2 && s.soldSupply2 < s.saleSupply2){\r\n            tokenAmount = sendValue / (s.amountRaised1 / s.saleSupply1 * 120 / 100);    //Token Price = s.amountRaised1 / s.saleSupply1. Price is going up 20%\r\n            s.soldSupply2 = add(s.soldSupply2, tokenAmount);\r\n            s.amountRaised2 = add(s.amountRaised2, sendValue);\r\n\r\n            require(s.soldSupply2 < s.saleSupply2 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > t.deadline2 && now <= t.deadline3){\r\n            participantsFor3rdSale[sender] = add(participantsFor3rdSale[sender],sendValue);\r\n            s.amountRaised3 = add(s.amountRaised3, sendValue);\r\n        }else if(now > t.deadline3 && now <= t.deadline4 && s.soldSupply4 < s.saleSupply4){\r\n            tokenAmount = sendValue / (s.amountRaised3 / s.saleSupply3 * 120 / 100);     //Token Price = s.amountRaised3 / s.saleSupply3. Price is going up 20%\r\n            s.soldSupply4 = add(s.soldSupply4, tokenAmount);\r\n            s.amountRaised4 = add(s.amountRaised4, sendValue);\r\n\r\n            require(s.soldSupply4 < s.saleSupply4 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > cs.start && now <= cs.end && cs.soldSupply < cs.saleSupply){\r\n            if(cs.tokenPerEth > 0){\r\n                tokenAmount = sendValue * cs.tokenPerEth;\r\n                cs.soldSupply = add(cs.soldSupply, tokenAmount);\r\n\r\n                require(cs.soldSupply < cs.saleSupply * 105 / 100); // A little bit more sale is granted for the price sale.\r\n            }else{\r\n                participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue);\r\n                cs.amountRaised = add(cs.amountRaised, sendValue);\r\n            }\r\n        }else{\r\n            throw;\r\n        }\r\n        s.amountRaisedTotal = add(s.amountRaisedTotal, sendValue);\r\n    }"
      IfStatement
         Source: "if(now > t.pstart && now <= t.pdeadline){\r\n            participantsForPreSale[sender] = add(participantsForPreSale[sender],sendValue);\r\n            s.amountRaisedPre = add(s.amountRaisedPre, sendValue);\r\n        }else if(now > t.start && now <= t.deadline1){\r\n            participantsFor1stSale[sender] = add(participantsFor1stSale[sender],sendValue);\r\n            s.amountRaised1 = add(s.amountRaised1, sendValue);\r\n        }else if(now > t.deadline1 && now <= t.deadline2 && s.soldSupply2 < s.saleSupply2){\r\n            tokenAmount = sendValue / (s.amountRaised1 / s.saleSupply1 * 120 / 100);    //Token Price = s.amountRaised1 / s.saleSupply1. Price is going up 20%\r\n            s.soldSupply2 = add(s.soldSupply2, tokenAmount);\r\n            s.amountRaised2 = add(s.amountRaised2, sendValue);\r\n\r\n            require(s.soldSupply2 < s.saleSupply2 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > t.deadline2 && now <= t.deadline3){\r\n            participantsFor3rdSale[sender] = add(participantsFor3rdSale[sender],sendValue);\r\n            s.amountRaised3 = add(s.amountRaised3, sendValue);\r\n        }else if(now > t.deadline3 && now <= t.deadline4 && s.soldSupply4 < s.saleSupply4){\r\n            tokenAmount = sendValue / (s.amountRaised3 / s.saleSupply3 * 120 / 100);     //Token Price = s.amountRaised3 / s.saleSupply3. Price is going up 20%\r\n            s.soldSupply4 = add(s.soldSupply4, tokenAmount);\r\n            s.amountRaised4 = add(s.amountRaised4, sendValue);\r\n\r\n            require(s.soldSupply4 < s.saleSupply4 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > cs.start && now <= cs.end && cs.soldSupply < cs.saleSupply){\r\n            if(cs.tokenPerEth > 0){\r\n                tokenAmount = sendValue * cs.tokenPerEth;\r\n                cs.soldSupply = add(cs.soldSupply, tokenAmount);\r\n\r\n                require(cs.soldSupply < cs.saleSupply * 105 / 100); // A little bit more sale is granted for the price sale.\r\n            }else{\r\n                participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue);\r\n                cs.amountRaised = add(cs.amountRaised, sendValue);\r\n            }\r\n        }else{\r\n            throw;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "now > t.pstart && now <= t.pdeadline"
          BinaryOperation using operator >
             Type: bool
             Source: "now > t.pstart"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member pstart
               Type: uint256
               Source: "t.pstart"
              Identifier t
                 Type: struct CrowdSale.SaleTimeAttr storage ref
                 Source: "t"
          BinaryOperation using operator <=
             Type: bool
             Source: "now <= t.pdeadline"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member pdeadline
               Type: uint256
               Source: "t.pdeadline"
              Identifier t
                 Type: struct CrowdSale.SaleTimeAttr storage ref
                 Source: "t"
        Block
           Source: "{\r\n            participantsForPreSale[sender] = add(participantsForPreSale[sender],sendValue);\r\n            s.amountRaisedPre = add(s.amountRaisedPre, sendValue);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "participantsForPreSale[sender] = add(participantsForPreSale[sender],sendValue)"
            Assignment using operator =
               Type: uint256
               Source: "participantsForPreSale[sender] = add(participantsForPreSale[sender],sendValue)"
              IndexAccess
                 Type: uint256
                 Source: "participantsForPreSale[sender]"
                Identifier participantsForPreSale
                   Type: mapping(address => uint256)
                   Source: "participantsForPreSale"
                Identifier sender
                   Type: address
                   Source: "sender"
              FunctionCall
                 Type: uint256
                 Source: "add(participantsForPreSale[sender],sendValue)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                IndexAccess
                   Type: uint256
                   Source: "participantsForPreSale[sender]"
                  Identifier participantsForPreSale
                     Type: mapping(address => uint256)
                     Source: "participantsForPreSale"
                  Identifier sender
                     Type: address
                     Source: "sender"
                Identifier sendValue
                   Type: uint256
                   Source: "sendValue"
          ExpressionStatement
             Gas costs: 0
             Source: "s.amountRaisedPre = add(s.amountRaisedPre, sendValue)"
            Assignment using operator =
               Type: uint256
               Source: "s.amountRaisedPre = add(s.amountRaisedPre, sendValue)"
              MemberAccess to member amountRaisedPre
                 Type: uint256
                 Source: "s.amountRaisedPre"
                Identifier s
                   Type: struct CrowdSale.SaleAttr storage ref
                   Source: "s"
              FunctionCall
                 Type: uint256
                 Source: "add(s.amountRaisedPre, sendValue)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                MemberAccess to member amountRaisedPre
                   Type: uint256
                   Source: "s.amountRaisedPre"
                  Identifier s
                     Type: struct CrowdSale.SaleAttr storage ref
                     Source: "s"
                Identifier sendValue
                   Type: uint256
                   Source: "sendValue"
        IfStatement
           Source: "if(now > t.start && now <= t.deadline1){\r\n            participantsFor1stSale[sender] = add(participantsFor1stSale[sender],sendValue);\r\n            s.amountRaised1 = add(s.amountRaised1, sendValue);\r\n        }else if(now > t.deadline1 && now <= t.deadline2 && s.soldSupply2 < s.saleSupply2){\r\n            tokenAmount = sendValue / (s.amountRaised1 / s.saleSupply1 * 120 / 100);    //Token Price = s.amountRaised1 / s.saleSupply1. Price is going up 20%\r\n            s.soldSupply2 = add(s.soldSupply2, tokenAmount);\r\n            s.amountRaised2 = add(s.amountRaised2, sendValue);\r\n\r\n            require(s.soldSupply2 < s.saleSupply2 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > t.deadline2 && now <= t.deadline3){\r\n            participantsFor3rdSale[sender] = add(participantsFor3rdSale[sender],sendValue);\r\n            s.amountRaised3 = add(s.amountRaised3, sendValue);\r\n        }else if(now > t.deadline3 && now <= t.deadline4 && s.soldSupply4 < s.saleSupply4){\r\n            tokenAmount = sendValue / (s.amountRaised3 / s.saleSupply3 * 120 / 100);     //Token Price = s.amountRaised3 / s.saleSupply3. Price is going up 20%\r\n            s.soldSupply4 = add(s.soldSupply4, tokenAmount);\r\n            s.amountRaised4 = add(s.amountRaised4, sendValue);\r\n\r\n            require(s.soldSupply4 < s.saleSupply4 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > cs.start && now <= cs.end && cs.soldSupply < cs.saleSupply){\r\n            if(cs.tokenPerEth > 0){\r\n                tokenAmount = sendValue * cs.tokenPerEth;\r\n                cs.soldSupply = add(cs.soldSupply, tokenAmount);\r\n\r\n                require(cs.soldSupply < cs.saleSupply * 105 / 100); // A little bit more sale is granted for the price sale.\r\n            }else{\r\n                participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue);\r\n                cs.amountRaised = add(cs.amountRaised, sendValue);\r\n            }\r\n        }else{\r\n            throw;\r\n        }"
          BinaryOperation using operator &&
             Type: bool
             Gas costs: 0
             Source: "now > t.start && now <= t.deadline1"
            BinaryOperation using operator >
               Type: bool
               Source: "now > t.start"
              Identifier now
                 Type: uint256
                 Source: "now"
              MemberAccess to member start
                 Type: uint256
                 Source: "t.start"
                Identifier t
                   Type: struct CrowdSale.SaleTimeAttr storage ref
                   Source: "t"
            BinaryOperation using operator <=
               Type: bool
               Source: "now <= t.deadline1"
              Identifier now
                 Type: uint256
                 Source: "now"
              MemberAccess to member deadline1
                 Type: uint256
                 Source: "t.deadline1"
                Identifier t
                   Type: struct CrowdSale.SaleTimeAttr storage ref
                   Source: "t"
          Block
             Source: "{\r\n            participantsFor1stSale[sender] = add(participantsFor1stSale[sender],sendValue);\r\n            s.amountRaised1 = add(s.amountRaised1, sendValue);\r\n        }"
            ExpressionStatement
               Gas costs: 0
               Source: "participantsFor1stSale[sender] = add(participantsFor1stSale[sender],sendValue)"
              Assignment using operator =
                 Type: uint256
                 Source: "participantsFor1stSale[sender] = add(participantsFor1stSale[sender],sendValue)"
                IndexAccess
                   Type: uint256
                   Source: "participantsFor1stSale[sender]"
                  Identifier participantsFor1stSale
                     Type: mapping(address => uint256)
                     Source: "participantsFor1stSale"
                  Identifier sender
                     Type: address
                     Source: "sender"
                FunctionCall
                   Type: uint256
                   Source: "add(participantsFor1stSale[sender],sendValue)"
                  Identifier add
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "add"
                  IndexAccess
                     Type: uint256
                     Source: "participantsFor1stSale[sender]"
                    Identifier participantsFor1stSale
                       Type: mapping(address => uint256)
                       Source: "participantsFor1stSale"
                    Identifier sender
                       Type: address
                       Source: "sender"
                  Identifier sendValue
                     Type: uint256
                     Source: "sendValue"
            ExpressionStatement
               Gas costs: 0
               Source: "s.amountRaised1 = add(s.amountRaised1, sendValue)"
              Assignment using operator =
                 Type: uint256
                 Source: "s.amountRaised1 = add(s.amountRaised1, sendValue)"
                MemberAccess to member amountRaised1
                   Type: uint256
                   Source: "s.amountRaised1"
                  Identifier s
                     Type: struct CrowdSale.SaleAttr storage ref
                     Source: "s"
                FunctionCall
                   Type: uint256
                   Source: "add(s.amountRaised1, sendValue)"
                  Identifier add
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "add"
                  MemberAccess to member amountRaised1
                     Type: uint256
                     Source: "s.amountRaised1"
                    Identifier s
                       Type: struct CrowdSale.SaleAttr storage ref
                       Source: "s"
                  Identifier sendValue
                     Type: uint256
                     Source: "sendValue"
          IfStatement
             Source: "if(now > t.deadline1 && now <= t.deadline2 && s.soldSupply2 < s.saleSupply2){\r\n            tokenAmount = sendValue / (s.amountRaised1 / s.saleSupply1 * 120 / 100);    //Token Price = s.amountRaised1 / s.saleSupply1. Price is going up 20%\r\n            s.soldSupply2 = add(s.soldSupply2, tokenAmount);\r\n            s.amountRaised2 = add(s.amountRaised2, sendValue);\r\n\r\n            require(s.soldSupply2 < s.saleSupply2 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > t.deadline2 && now <= t.deadline3){\r\n            participantsFor3rdSale[sender] = add(participantsFor3rdSale[sender],sendValue);\r\n            s.amountRaised3 = add(s.amountRaised3, sendValue);\r\n        }else if(now > t.deadline3 && now <= t.deadline4 && s.soldSupply4 < s.saleSupply4){\r\n            tokenAmount = sendValue / (s.amountRaised3 / s.saleSupply3 * 120 / 100);     //Token Price = s.amountRaised3 / s.saleSupply3. Price is going up 20%\r\n            s.soldSupply4 = add(s.soldSupply4, tokenAmount);\r\n            s.amountRaised4 = add(s.amountRaised4, sendValue);\r\n\r\n            require(s.soldSupply4 < s.saleSupply4 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > cs.start && now <= cs.end && cs.soldSupply < cs.saleSupply){\r\n            if(cs.tokenPerEth > 0){\r\n                tokenAmount = sendValue * cs.tokenPerEth;\r\n                cs.soldSupply = add(cs.soldSupply, tokenAmount);\r\n\r\n                require(cs.soldSupply < cs.saleSupply * 105 / 100); // A little bit more sale is granted for the price sale.\r\n            }else{\r\n                participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue);\r\n                cs.amountRaised = add(cs.amountRaised, sendValue);\r\n            }\r\n        }else{\r\n            throw;\r\n        }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 0
               Source: "now > t.deadline1 && now <= t.deadline2 && s.soldSupply2 < s.saleSupply2"
              BinaryOperation using operator &&
                 Type: bool
                 Source: "now > t.deadline1 && now <= t.deadline2"
                BinaryOperation using operator >
                   Type: bool
                   Source: "now > t.deadline1"
                  Identifier now
                     Type: uint256
                     Source: "now"
                  MemberAccess to member deadline1
                     Type: uint256
                     Source: "t.deadline1"
                    Identifier t
                       Type: struct CrowdSale.SaleTimeAttr storage ref
                       Source: "t"
                BinaryOperation using operator <=
                   Type: bool
                   Source: "now <= t.deadline2"
                  Identifier now
                     Type: uint256
                     Source: "now"
                  MemberAccess to member deadline2
                     Type: uint256
                     Source: "t.deadline2"
                    Identifier t
                       Type: struct CrowdSale.SaleTimeAttr storage ref
                       Source: "t"
              BinaryOperation using operator <
                 Type: bool
                 Source: "s.soldSupply2 < s.saleSupply2"
                MemberAccess to member soldSupply2
                   Type: uint256
                   Source: "s.soldSupply2"
                  Identifier s
                     Type: struct CrowdSale.SaleAttr storage ref
                     Source: "s"
                MemberAccess to member saleSupply2
                   Type: uint256
                   Source: "s.saleSupply2"
                  Identifier s
                     Type: struct CrowdSale.SaleAttr storage ref
                     Source: "s"
            Block
               Source: "{\r\n            tokenAmount = sendValue / (s.amountRaised1 / s.saleSupply1 * 120 / 100);    //Token Price = s.amountRaised1 / s.saleSupply1. Price is going up 20%\r\n            s.soldSupply2 = add(s.soldSupply2, tokenAmount);\r\n            s.amountRaised2 = add(s.amountRaised2, sendValue);\r\n\r\n            require(s.soldSupply2 < s.saleSupply2 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "tokenAmount = sendValue / (s.amountRaised1 / s.saleSupply1 * 120 / 100)"
                Assignment using operator =
                   Type: uint256
                   Source: "tokenAmount = sendValue / (s.amountRaised1 / s.saleSupply1 * 120 / 100)"
                  Identifier tokenAmount
                     Type: uint256
                     Source: "tokenAmount"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "sendValue / (s.amountRaised1 / s.saleSupply1 * 120 / 100)"
                    Identifier sendValue
                       Type: uint256
                       Source: "sendValue"
                    TupleExpression
                       Type: uint256
                       Source: "(s.amountRaised1 / s.saleSupply1 * 120 / 100)"
                      BinaryOperation using operator /
                         Type: uint256
                         Source: "s.amountRaised1 / s.saleSupply1 * 120 / 100"
                        BinaryOperation using operator *
                           Type: uint256
                           Source: "s.amountRaised1 / s.saleSupply1 * 120"
                          BinaryOperation using operator /
                             Type: uint256
                             Source: "s.amountRaised1 / s.saleSupply1"
                            MemberAccess to member amountRaised1
                               Type: uint256
                               Source: "s.amountRaised1"
                              Identifier s
                                 Type: struct CrowdSale.SaleAttr storage ref
                                 Source: "s"
                            MemberAccess to member saleSupply1
                               Type: uint256
                               Source: "s.saleSupply1"
                              Identifier s
                                 Type: struct CrowdSale.SaleAttr storage ref
                                 Source: "s"
                          Literal, token: [no token] value: 120
                             Type: int_const 120
                             Source: "120"
                        Literal, token: [no token] value: 100
                           Type: int_const 100
                           Source: "100"
              ExpressionStatement
                 Gas costs: 0
                 Source: "s.soldSupply2 = add(s.soldSupply2, tokenAmount)"
                Assignment using operator =
                   Type: uint256
                   Source: "s.soldSupply2 = add(s.soldSupply2, tokenAmount)"
                  MemberAccess to member soldSupply2
                     Type: uint256
                     Source: "s.soldSupply2"
                    Identifier s
                       Type: struct CrowdSale.SaleAttr storage ref
                       Source: "s"
                  FunctionCall
                     Type: uint256
                     Source: "add(s.soldSupply2, tokenAmount)"
                    Identifier add
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "add"
                    MemberAccess to member soldSupply2
                       Type: uint256
                       Source: "s.soldSupply2"
                      Identifier s
                         Type: struct CrowdSale.SaleAttr storage ref
                         Source: "s"
                    Identifier tokenAmount
                       Type: uint256
                       Source: "tokenAmount"
              ExpressionStatement
                 Gas costs: 0
                 Source: "s.amountRaised2 = add(s.amountRaised2, sendValue)"
                Assignment using operator =
                   Type: uint256
                   Source: "s.amountRaised2 = add(s.amountRaised2, sendValue)"
                  MemberAccess to member amountRaised2
                     Type: uint256
                     Source: "s.amountRaised2"
                    Identifier s
                       Type: struct CrowdSale.SaleAttr storage ref
                       Source: "s"
                  FunctionCall
                     Type: uint256
                     Source: "add(s.amountRaised2, sendValue)"
                    Identifier add
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "add"
                    MemberAccess to member amountRaised2
                       Type: uint256
                       Source: "s.amountRaised2"
                      Identifier s
                         Type: struct CrowdSale.SaleAttr storage ref
                         Source: "s"
                    Identifier sendValue
                       Type: uint256
                       Source: "sendValue"
              ExpressionStatement
                 Gas costs: 0
                 Source: "require(s.soldSupply2 < s.saleSupply2 * 105 / 100)"
                FunctionCall
                   Type: tuple()
                   Source: "require(s.soldSupply2 < s.saleSupply2 * 105 / 100)"
                  Identifier require
                     Type: function (bool) pure
                     Source: "require"
                  BinaryOperation using operator <
                     Type: bool
                     Source: "s.soldSupply2 < s.saleSupply2 * 105 / 100"
                    MemberAccess to member soldSupply2
                       Type: uint256
                       Source: "s.soldSupply2"
                      Identifier s
                         Type: struct CrowdSale.SaleAttr storage ref
                         Source: "s"
                    BinaryOperation using operator /
                       Type: uint256
                       Source: "s.saleSupply2 * 105 / 100"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "s.saleSupply2 * 105"
                        MemberAccess to member saleSupply2
                           Type: uint256
                           Source: "s.saleSupply2"
                          Identifier s
                             Type: struct CrowdSale.SaleAttr storage ref
                             Source: "s"
                        Literal, token: [no token] value: 105
                           Type: int_const 105
                           Source: "105"
                      Literal, token: [no token] value: 100
                         Type: int_const 100
                         Source: "100"
            IfStatement
               Source: "if(now > t.deadline2 && now <= t.deadline3){\r\n            participantsFor3rdSale[sender] = add(participantsFor3rdSale[sender],sendValue);\r\n            s.amountRaised3 = add(s.amountRaised3, sendValue);\r\n        }else if(now > t.deadline3 && now <= t.deadline4 && s.soldSupply4 < s.saleSupply4){\r\n            tokenAmount = sendValue / (s.amountRaised3 / s.saleSupply3 * 120 / 100);     //Token Price = s.amountRaised3 / s.saleSupply3. Price is going up 20%\r\n            s.soldSupply4 = add(s.soldSupply4, tokenAmount);\r\n            s.amountRaised4 = add(s.amountRaised4, sendValue);\r\n\r\n            require(s.soldSupply4 < s.saleSupply4 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > cs.start && now <= cs.end && cs.soldSupply < cs.saleSupply){\r\n            if(cs.tokenPerEth > 0){\r\n                tokenAmount = sendValue * cs.tokenPerEth;\r\n                cs.soldSupply = add(cs.soldSupply, tokenAmount);\r\n\r\n                require(cs.soldSupply < cs.saleSupply * 105 / 100); // A little bit more sale is granted for the price sale.\r\n            }else{\r\n                participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue);\r\n                cs.amountRaised = add(cs.amountRaised, sendValue);\r\n            }\r\n        }else{\r\n            throw;\r\n        }"
              BinaryOperation using operator &&
                 Type: bool
                 Gas costs: 0
                 Source: "now > t.deadline2 && now <= t.deadline3"
                BinaryOperation using operator >
                   Type: bool
                   Source: "now > t.deadline2"
                  Identifier now
                     Type: uint256
                     Source: "now"
                  MemberAccess to member deadline2
                     Type: uint256
                     Source: "t.deadline2"
                    Identifier t
                       Type: struct CrowdSale.SaleTimeAttr storage ref
                       Source: "t"
                BinaryOperation using operator <=
                   Type: bool
                   Source: "now <= t.deadline3"
                  Identifier now
                     Type: uint256
                     Source: "now"
                  MemberAccess to member deadline3
                     Type: uint256
                     Source: "t.deadline3"
                    Identifier t
                       Type: struct CrowdSale.SaleTimeAttr storage ref
                       Source: "t"
              Block
                 Source: "{\r\n            participantsFor3rdSale[sender] = add(participantsFor3rdSale[sender],sendValue);\r\n            s.amountRaised3 = add(s.amountRaised3, sendValue);\r\n        }"
                ExpressionStatement
                   Gas costs: 0
                   Source: "participantsFor3rdSale[sender] = add(participantsFor3rdSale[sender],sendValue)"
                  Assignment using operator =
                     Type: uint256
                     Source: "participantsFor3rdSale[sender] = add(participantsFor3rdSale[sender],sendValue)"
                    IndexAccess
                       Type: uint256
                       Source: "participantsFor3rdSale[sender]"
                      Identifier participantsFor3rdSale
                         Type: mapping(address => uint256)
                         Source: "participantsFor3rdSale"
                      Identifier sender
                         Type: address
                         Source: "sender"
                    FunctionCall
                       Type: uint256
                       Source: "add(participantsFor3rdSale[sender],sendValue)"
                      Identifier add
                         Type: function (uint256,uint256) view returns (uint256)
                         Source: "add"
                      IndexAccess
                         Type: uint256
                         Source: "participantsFor3rdSale[sender]"
                        Identifier participantsFor3rdSale
                           Type: mapping(address => uint256)
                           Source: "participantsFor3rdSale"
                        Identifier sender
                           Type: address
                           Source: "sender"
                      Identifier sendValue
                         Type: uint256
                         Source: "sendValue"
                ExpressionStatement
                   Gas costs: 0
                   Source: "s.amountRaised3 = add(s.amountRaised3, sendValue)"
                  Assignment using operator =
                     Type: uint256
                     Source: "s.amountRaised3 = add(s.amountRaised3, sendValue)"
                    MemberAccess to member amountRaised3
                       Type: uint256
                       Source: "s.amountRaised3"
                      Identifier s
                         Type: struct CrowdSale.SaleAttr storage ref
                         Source: "s"
                    FunctionCall
                       Type: uint256
                       Source: "add(s.amountRaised3, sendValue)"
                      Identifier add
                         Type: function (uint256,uint256) view returns (uint256)
                         Source: "add"
                      MemberAccess to member amountRaised3
                         Type: uint256
                         Source: "s.amountRaised3"
                        Identifier s
                           Type: struct CrowdSale.SaleAttr storage ref
                           Source: "s"
                      Identifier sendValue
                         Type: uint256
                         Source: "sendValue"
              IfStatement
                 Source: "if(now > t.deadline3 && now <= t.deadline4 && s.soldSupply4 < s.saleSupply4){\r\n            tokenAmount = sendValue / (s.amountRaised3 / s.saleSupply3 * 120 / 100);     //Token Price = s.amountRaised3 / s.saleSupply3. Price is going up 20%\r\n            s.soldSupply4 = add(s.soldSupply4, tokenAmount);\r\n            s.amountRaised4 = add(s.amountRaised4, sendValue);\r\n\r\n            require(s.soldSupply4 < s.saleSupply4 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > cs.start && now <= cs.end && cs.soldSupply < cs.saleSupply){\r\n            if(cs.tokenPerEth > 0){\r\n                tokenAmount = sendValue * cs.tokenPerEth;\r\n                cs.soldSupply = add(cs.soldSupply, tokenAmount);\r\n\r\n                require(cs.soldSupply < cs.saleSupply * 105 / 100); // A little bit more sale is granted for the price sale.\r\n            }else{\r\n                participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue);\r\n                cs.amountRaised = add(cs.amountRaised, sendValue);\r\n            }\r\n        }else{\r\n            throw;\r\n        }"
                BinaryOperation using operator &&
                   Type: bool
                   Gas costs: 0
                   Source: "now > t.deadline3 && now <= t.deadline4 && s.soldSupply4 < s.saleSupply4"
                  BinaryOperation using operator &&
                     Type: bool
                     Source: "now > t.deadline3 && now <= t.deadline4"
                    BinaryOperation using operator >
                       Type: bool
                       Source: "now > t.deadline3"
                      Identifier now
                         Type: uint256
                         Source: "now"
                      MemberAccess to member deadline3
                         Type: uint256
                         Source: "t.deadline3"
                        Identifier t
                           Type: struct CrowdSale.SaleTimeAttr storage ref
                           Source: "t"
                    BinaryOperation using operator <=
                       Type: bool
                       Source: "now <= t.deadline4"
                      Identifier now
                         Type: uint256
                         Source: "now"
                      MemberAccess to member deadline4
                         Type: uint256
                         Source: "t.deadline4"
                        Identifier t
                           Type: struct CrowdSale.SaleTimeAttr storage ref
                           Source: "t"
                  BinaryOperation using operator <
                     Type: bool
                     Source: "s.soldSupply4 < s.saleSupply4"
                    MemberAccess to member soldSupply4
                       Type: uint256
                       Source: "s.soldSupply4"
                      Identifier s
                         Type: struct CrowdSale.SaleAttr storage ref
                         Source: "s"
                    MemberAccess to member saleSupply4
                       Type: uint256
                       Source: "s.saleSupply4"
                      Identifier s
                         Type: struct CrowdSale.SaleAttr storage ref
                         Source: "s"
                Block
                   Source: "{\r\n            tokenAmount = sendValue / (s.amountRaised3 / s.saleSupply3 * 120 / 100);     //Token Price = s.amountRaised3 / s.saleSupply3. Price is going up 20%\r\n            s.soldSupply4 = add(s.soldSupply4, tokenAmount);\r\n            s.amountRaised4 = add(s.amountRaised4, sendValue);\r\n\r\n            require(s.soldSupply4 < s.saleSupply4 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "tokenAmount = sendValue / (s.amountRaised3 / s.saleSupply3 * 120 / 100)"
                    Assignment using operator =
                       Type: uint256
                       Source: "tokenAmount = sendValue / (s.amountRaised3 / s.saleSupply3 * 120 / 100)"
                      Identifier tokenAmount
                         Type: uint256
                         Source: "tokenAmount"
                      BinaryOperation using operator /
                         Type: uint256
                         Source: "sendValue / (s.amountRaised3 / s.saleSupply3 * 120 / 100)"
                        Identifier sendValue
                           Type: uint256
                           Source: "sendValue"
                        TupleExpression
                           Type: uint256
                           Source: "(s.amountRaised3 / s.saleSupply3 * 120 / 100)"
                          BinaryOperation using operator /
                             Type: uint256
                             Source: "s.amountRaised3 / s.saleSupply3 * 120 / 100"
                            BinaryOperation using operator *
                               Type: uint256
                               Source: "s.amountRaised3 / s.saleSupply3 * 120"
                              BinaryOperation using operator /
                                 Type: uint256
                                 Source: "s.amountRaised3 / s.saleSupply3"
                                MemberAccess to member amountRaised3
                                   Type: uint256
                                   Source: "s.amountRaised3"
                                  Identifier s
                                     Type: struct CrowdSale.SaleAttr storage ref
                                     Source: "s"
                                MemberAccess to member saleSupply3
                                   Type: uint256
                                   Source: "s.saleSupply3"
                                  Identifier s
                                     Type: struct CrowdSale.SaleAttr storage ref
                                     Source: "s"
                              Literal, token: [no token] value: 120
                                 Type: int_const 120
                                 Source: "120"
                            Literal, token: [no token] value: 100
                               Type: int_const 100
                               Source: "100"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "s.soldSupply4 = add(s.soldSupply4, tokenAmount)"
                    Assignment using operator =
                       Type: uint256
                       Source: "s.soldSupply4 = add(s.soldSupply4, tokenAmount)"
                      MemberAccess to member soldSupply4
                         Type: uint256
                         Source: "s.soldSupply4"
                        Identifier s
                           Type: struct CrowdSale.SaleAttr storage ref
                           Source: "s"
                      FunctionCall
                         Type: uint256
                         Source: "add(s.soldSupply4, tokenAmount)"
                        Identifier add
                           Type: function (uint256,uint256) view returns (uint256)
                           Source: "add"
                        MemberAccess to member soldSupply4
                           Type: uint256
                           Source: "s.soldSupply4"
                          Identifier s
                             Type: struct CrowdSale.SaleAttr storage ref
                             Source: "s"
                        Identifier tokenAmount
                           Type: uint256
                           Source: "tokenAmount"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "s.amountRaised4 = add(s.amountRaised4, sendValue)"
                    Assignment using operator =
                       Type: uint256
                       Source: "s.amountRaised4 = add(s.amountRaised4, sendValue)"
                      MemberAccess to member amountRaised4
                         Type: uint256
                         Source: "s.amountRaised4"
                        Identifier s
                           Type: struct CrowdSale.SaleAttr storage ref
                           Source: "s"
                      FunctionCall
                         Type: uint256
                         Source: "add(s.amountRaised4, sendValue)"
                        Identifier add
                           Type: function (uint256,uint256) view returns (uint256)
                           Source: "add"
                        MemberAccess to member amountRaised4
                           Type: uint256
                           Source: "s.amountRaised4"
                          Identifier s
                             Type: struct CrowdSale.SaleAttr storage ref
                             Source: "s"
                        Identifier sendValue
                           Type: uint256
                           Source: "sendValue"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "require(s.soldSupply4 < s.saleSupply4 * 105 / 100)"
                    FunctionCall
                       Type: tuple()
                       Source: "require(s.soldSupply4 < s.saleSupply4 * 105 / 100)"
                      Identifier require
                         Type: function (bool) pure
                         Source: "require"
                      BinaryOperation using operator <
                         Type: bool
                         Source: "s.soldSupply4 < s.saleSupply4 * 105 / 100"
                        MemberAccess to member soldSupply4
                           Type: uint256
                           Source: "s.soldSupply4"
                          Identifier s
                             Type: struct CrowdSale.SaleAttr storage ref
                             Source: "s"
                        BinaryOperation using operator /
                           Type: uint256
                           Source: "s.saleSupply4 * 105 / 100"
                          BinaryOperation using operator *
                             Type: uint256
                             Source: "s.saleSupply4 * 105"
                            MemberAccess to member saleSupply4
                               Type: uint256
                               Source: "s.saleSupply4"
                              Identifier s
                                 Type: struct CrowdSale.SaleAttr storage ref
                                 Source: "s"
                            Literal, token: [no token] value: 105
                               Type: int_const 105
                               Source: "105"
                          Literal, token: [no token] value: 100
                             Type: int_const 100
                             Source: "100"
                IfStatement
                   Source: "if(now > cs.start && now <= cs.end && cs.soldSupply < cs.saleSupply){\r\n            if(cs.tokenPerEth > 0){\r\n                tokenAmount = sendValue * cs.tokenPerEth;\r\n                cs.soldSupply = add(cs.soldSupply, tokenAmount);\r\n\r\n                require(cs.soldSupply < cs.saleSupply * 105 / 100); // A little bit more sale is granted for the price sale.\r\n            }else{\r\n                participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue);\r\n                cs.amountRaised = add(cs.amountRaised, sendValue);\r\n            }\r\n        }else{\r\n            throw;\r\n        }"
                  BinaryOperation using operator &&
                     Type: bool
                     Gas costs: 0
                     Source: "now > cs.start && now <= cs.end && cs.soldSupply < cs.saleSupply"
                    BinaryOperation using operator &&
                       Type: bool
                       Source: "now > cs.start && now <= cs.end"
                      BinaryOperation using operator >
                         Type: bool
                         Source: "now > cs.start"
                        Identifier now
                           Type: uint256
                           Source: "now"
                        MemberAccess to member start
                           Type: uint256
                           Source: "cs.start"
                          Identifier cs
                             Type: struct CrowdSale.CustomSaleAttr storage ref
                             Source: "cs"
                      BinaryOperation using operator <=
                         Type: bool
                         Source: "now <= cs.end"
                        Identifier now
                           Type: uint256
                           Source: "now"
                        MemberAccess to member end
                           Type: uint256
                           Source: "cs.end"
                          Identifier cs
                             Type: struct CrowdSale.CustomSaleAttr storage ref
                             Source: "cs"
                    BinaryOperation using operator <
                       Type: bool
                       Source: "cs.soldSupply < cs.saleSupply"
                      MemberAccess to member soldSupply
                         Type: uint256
                         Source: "cs.soldSupply"
                        Identifier cs
                           Type: struct CrowdSale.CustomSaleAttr storage ref
                           Source: "cs"
                      MemberAccess to member saleSupply
                         Type: uint256
                         Source: "cs.saleSupply"
                        Identifier cs
                           Type: struct CrowdSale.CustomSaleAttr storage ref
                           Source: "cs"
                  Block
                     Source: "{\r\n            if(cs.tokenPerEth > 0){\r\n                tokenAmount = sendValue * cs.tokenPerEth;\r\n                cs.soldSupply = add(cs.soldSupply, tokenAmount);\r\n\r\n                require(cs.soldSupply < cs.saleSupply * 105 / 100); // A little bit more sale is granted for the price sale.\r\n            }else{\r\n                participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue);\r\n                cs.amountRaised = add(cs.amountRaised, sendValue);\r\n            }\r\n        }"
                    IfStatement
                       Source: "if(cs.tokenPerEth > 0){\r\n                tokenAmount = sendValue * cs.tokenPerEth;\r\n                cs.soldSupply = add(cs.soldSupply, tokenAmount);\r\n\r\n                require(cs.soldSupply < cs.saleSupply * 105 / 100); // A little bit more sale is granted for the price sale.\r\n            }else{\r\n                participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue);\r\n                cs.amountRaised = add(cs.amountRaised, sendValue);\r\n            }"
                      BinaryOperation using operator >
                         Type: bool
                         Gas costs: 0
                         Source: "cs.tokenPerEth > 0"
                        MemberAccess to member tokenPerEth
                           Type: uint256
                           Source: "cs.tokenPerEth"
                          Identifier cs
                             Type: struct CrowdSale.CustomSaleAttr storage ref
                             Source: "cs"
                        Literal, token: [no token] value: 0
                           Type: int_const 0
                           Source: "0"
                      Block
                         Source: "{\r\n                tokenAmount = sendValue * cs.tokenPerEth;\r\n                cs.soldSupply = add(cs.soldSupply, tokenAmount);\r\n\r\n                require(cs.soldSupply < cs.saleSupply * 105 / 100); // A little bit more sale is granted for the price sale.\r\n            }"
                        ExpressionStatement
                           Gas costs: 0
                           Source: "tokenAmount = sendValue * cs.tokenPerEth"
                          Assignment using operator =
                             Type: uint256
                             Source: "tokenAmount = sendValue * cs.tokenPerEth"
                            Identifier tokenAmount
                               Type: uint256
                               Source: "tokenAmount"
                            BinaryOperation using operator *
                               Type: uint256
                               Source: "sendValue * cs.tokenPerEth"
                              Identifier sendValue
                                 Type: uint256
                                 Source: "sendValue"
                              MemberAccess to member tokenPerEth
                                 Type: uint256
                                 Source: "cs.tokenPerEth"
                                Identifier cs
                                   Type: struct CrowdSale.CustomSaleAttr storage ref
                                   Source: "cs"
                        ExpressionStatement
                           Gas costs: 0
                           Source: "cs.soldSupply = add(cs.soldSupply, tokenAmount)"
                          Assignment using operator =
                             Type: uint256
                             Source: "cs.soldSupply = add(cs.soldSupply, tokenAmount)"
                            MemberAccess to member soldSupply
                               Type: uint256
                               Source: "cs.soldSupply"
                              Identifier cs
                                 Type: struct CrowdSale.CustomSaleAttr storage ref
                                 Source: "cs"
                            FunctionCall
                               Type: uint256
                               Source: "add(cs.soldSupply, tokenAmount)"
                              Identifier add
                                 Type: function (uint256,uint256) view returns (uint256)
                                 Source: "add"
                              MemberAccess to member soldSupply
                                 Type: uint256
                                 Source: "cs.soldSupply"
                                Identifier cs
                                   Type: struct CrowdSale.CustomSaleAttr storage ref
                                   Source: "cs"
                              Identifier tokenAmount
                                 Type: uint256
                                 Source: "tokenAmount"
                        ExpressionStatement
                           Gas costs: 0
                           Source: "require(cs.soldSupply < cs.saleSupply * 105 / 100)"
                          FunctionCall
                             Type: tuple()
                             Source: "require(cs.soldSupply < cs.saleSupply * 105 / 100)"
                            Identifier require
                               Type: function (bool) pure
                               Source: "require"
                            BinaryOperation using operator <
                               Type: bool
                               Source: "cs.soldSupply < cs.saleSupply * 105 / 100"
                              MemberAccess to member soldSupply
                                 Type: uint256
                                 Source: "cs.soldSupply"
                                Identifier cs
                                   Type: struct CrowdSale.CustomSaleAttr storage ref
                                   Source: "cs"
                              BinaryOperation using operator /
                                 Type: uint256
                                 Source: "cs.saleSupply * 105 / 100"
                                BinaryOperation using operator *
                                   Type: uint256
                                   Source: "cs.saleSupply * 105"
                                  MemberAccess to member saleSupply
                                     Type: uint256
                                     Source: "cs.saleSupply"
                                    Identifier cs
                                       Type: struct CrowdSale.CustomSaleAttr storage ref
                                       Source: "cs"
                                  Literal, token: [no token] value: 105
                                     Type: int_const 105
                                     Source: "105"
                                Literal, token: [no token] value: 100
                                   Type: int_const 100
                                   Source: "100"
                      Block
                         Source: "{\r\n                participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue);\r\n                cs.amountRaised = add(cs.amountRaised, sendValue);\r\n            }"
                        ExpressionStatement
                           Gas costs: 0
                           Source: "participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue)"
                          Assignment using operator =
                             Type: uint256
                             Source: "participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue)"
                            IndexAccess
                               Type: uint256
                               Source: "participantsForCustomSale[cs.start][sender]"
                              IndexAccess
                                 Type: mapping(address => uint256)
                                 Source: "participantsForCustomSale[cs.start]"
                                Identifier participantsForCustomSale
                                   Type: mapping(uint256 => mapping(address => uint256))
                                   Source: "participantsForCustomSale"
                                MemberAccess to member start
                                   Type: uint256
                                   Source: "cs.start"
                                  Identifier cs
                                     Type: struct CrowdSale.CustomSaleAttr storage ref
                                     Source: "cs"
                              Identifier sender
                                 Type: address
                                 Source: "sender"
                            FunctionCall
                               Type: uint256
                               Source: "add(participantsForCustomSale[cs.start][sender],sendValue)"
                              Identifier add
                                 Type: function (uint256,uint256) view returns (uint256)
                                 Source: "add"
                              IndexAccess
                                 Type: uint256
                                 Source: "participantsForCustomSale[cs.start][sender]"
                                IndexAccess
                                   Type: mapping(address => uint256)
                                   Source: "participantsForCustomSale[cs.start]"
                                  Identifier participantsForCustomSale
                                     Type: mapping(uint256 => mapping(address => uint256))
                                     Source: "participantsForCustomSale"
                                  MemberAccess to member start
                                     Type: uint256
                                     Source: "cs.start"
                                    Identifier cs
                                       Type: struct CrowdSale.CustomSaleAttr storage ref
                                       Source: "cs"
                                Identifier sender
                                   Type: address
                                   Source: "sender"
                              Identifier sendValue
                                 Type: uint256
                                 Source: "sendValue"
                        ExpressionStatement
                           Gas costs: 0
                           Source: "cs.amountRaised = add(cs.amountRaised, sendValue)"
                          Assignment using operator =
                             Type: uint256
                             Source: "cs.amountRaised = add(cs.amountRaised, sendValue)"
                            MemberAccess to member amountRaised
                               Type: uint256
                               Source: "cs.amountRaised"
                              Identifier cs
                                 Type: struct CrowdSale.CustomSaleAttr storage ref
                                 Source: "cs"
                            FunctionCall
                               Type: uint256
                               Source: "add(cs.amountRaised, sendValue)"
                              Identifier add
                                 Type: function (uint256,uint256) view returns (uint256)
                                 Source: "add"
                              MemberAccess to member amountRaised
                                 Type: uint256
                                 Source: "cs.amountRaised"
                                Identifier cs
                                   Type: struct CrowdSale.CustomSaleAttr storage ref
                                   Source: "cs"
                              Identifier sendValue
                                 Type: uint256
                                 Source: "sendValue"
                  Block
                     Source: "{\r\n            throw;\r\n        }"
                    Throw
                       Gas costs: 0
                       Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "s.amountRaisedTotal = add(s.amountRaisedTotal, sendValue)"
        Assignment using operator =
           Type: uint256
           Source: "s.amountRaisedTotal = add(s.amountRaisedTotal, sendValue)"
          MemberAccess to member amountRaisedTotal
             Type: uint256
             Source: "s.amountRaisedTotal"
            Identifier s
               Type: struct CrowdSale.SaleAttr storage ref
               Source: "s"
          FunctionCall
             Type: uint256
             Source: "add(s.amountRaisedTotal, sendValue)"
            Identifier add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "add"
            MemberAccess to member amountRaisedTotal
               Type: uint256
               Source: "s.amountRaisedTotal"
              Identifier s
                 Type: struct CrowdSale.SaleAttr storage ref
                 Source: "s"
            Identifier sendValue
               Type: uint256
               Source: "sendValue"
  FunctionDefinition "getToken" - public
     Source: "function getToken(address sender) onlyOwner returns (uint tokenAmount){\r\n        if(now > t.pdeadline && participantsForPreSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsForPreSale[sender] * s.saleSupplyPre / s.amountRaisedPre);  //Token Amount Per Eth = s.saleSupplyPre / s.amountRaisedPre\r\n            participantsForPreSale[sender] = 0;\r\n        }\r\n        if(now > t.deadline1 && participantsFor1stSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsFor1stSale[sender] * s.saleSupply1 / s.amountRaised1);  //Token Amount Per Eth = s.saleSupply1 / s.amountRaised1\r\n            participantsFor1stSale[sender] = 0;\r\n        }\r\n        if(now > t.deadline3 && participantsFor3rdSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsFor3rdSale[sender] * s.saleSupply3 / s.amountRaised3);  //Token Amount Per Eth = s.saleSupply3 / s.amountRaised3\r\n            participantsFor3rdSale[sender] = 0;\r\n        }\r\n        if(now > cs.end && participantsForCustomSale[cs.start][sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsForCustomSale[cs.start][sender] * cs.saleSupply / cs.amountRaised);  //Token Amount Per Eth = cs.saleSupply / cs.amountRaised\r\n            participantsForCustomSale[cs.start][sender] = 0;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address sender)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint tokenAmount)"
      VariableDeclaration "tokenAmount"
         Type: uint256
         Source: "uint tokenAmount"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        if(now > t.pdeadline && participantsForPreSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsForPreSale[sender] * s.saleSupplyPre / s.amountRaisedPre);  //Token Amount Per Eth = s.saleSupplyPre / s.amountRaisedPre\r\n            participantsForPreSale[sender] = 0;\r\n        }\r\n        if(now > t.deadline1 && participantsFor1stSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsFor1stSale[sender] * s.saleSupply1 / s.amountRaised1);  //Token Amount Per Eth = s.saleSupply1 / s.amountRaised1\r\n            participantsFor1stSale[sender] = 0;\r\n        }\r\n        if(now > t.deadline3 && participantsFor3rdSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsFor3rdSale[sender] * s.saleSupply3 / s.amountRaised3);  //Token Amount Per Eth = s.saleSupply3 / s.amountRaised3\r\n            participantsFor3rdSale[sender] = 0;\r\n        }\r\n        if(now > cs.end && participantsForCustomSale[cs.start][sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsForCustomSale[cs.start][sender] * cs.saleSupply / cs.amountRaised);  //Token Amount Per Eth = cs.saleSupply / cs.amountRaised\r\n            participantsForCustomSale[cs.start][sender] = 0;\r\n        }\r\n    }"
      IfStatement
         Source: "if(now > t.pdeadline && participantsForPreSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsForPreSale[sender] * s.saleSupplyPre / s.amountRaisedPre);  //Token Amount Per Eth = s.saleSupplyPre / s.amountRaisedPre\r\n            participantsForPreSale[sender] = 0;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "now > t.pdeadline && participantsForPreSale[sender] != 0"
          BinaryOperation using operator >
             Type: bool
             Source: "now > t.pdeadline"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member pdeadline
               Type: uint256
               Source: "t.pdeadline"
              Identifier t
                 Type: struct CrowdSale.SaleTimeAttr storage ref
                 Source: "t"
          BinaryOperation using operator !=
             Type: bool
             Source: "participantsForPreSale[sender] != 0"
            IndexAccess
               Type: uint256
               Source: "participantsForPreSale[sender]"
              Identifier participantsForPreSale
                 Type: mapping(address => uint256)
                 Source: "participantsForPreSale"
              Identifier sender
                 Type: address
                 Source: "sender"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            tokenAmount = add(tokenAmount,participantsForPreSale[sender] * s.saleSupplyPre / s.amountRaisedPre);  //Token Amount Per Eth = s.saleSupplyPre / s.amountRaisedPre\r\n            participantsForPreSale[sender] = 0;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "tokenAmount = add(tokenAmount,participantsForPreSale[sender] * s.saleSupplyPre / s.amountRaisedPre)"
            Assignment using operator =
               Type: uint256
               Source: "tokenAmount = add(tokenAmount,participantsForPreSale[sender] * s.saleSupplyPre / s.amountRaisedPre)"
              Identifier tokenAmount
                 Type: uint256
                 Source: "tokenAmount"
              FunctionCall
                 Type: uint256
                 Source: "add(tokenAmount,participantsForPreSale[sender] * s.saleSupplyPre / s.amountRaisedPre)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                Identifier tokenAmount
                   Type: uint256
                   Source: "tokenAmount"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "participantsForPreSale[sender] * s.saleSupplyPre / s.amountRaisedPre"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "participantsForPreSale[sender] * s.saleSupplyPre"
                    IndexAccess
                       Type: uint256
                       Source: "participantsForPreSale[sender]"
                      Identifier participantsForPreSale
                         Type: mapping(address => uint256)
                         Source: "participantsForPreSale"
                      Identifier sender
                         Type: address
                         Source: "sender"
                    MemberAccess to member saleSupplyPre
                       Type: uint256
                       Source: "s.saleSupplyPre"
                      Identifier s
                         Type: struct CrowdSale.SaleAttr storage ref
                         Source: "s"
                  MemberAccess to member amountRaisedPre
                     Type: uint256
                     Source: "s.amountRaisedPre"
                    Identifier s
                       Type: struct CrowdSale.SaleAttr storage ref
                       Source: "s"
          ExpressionStatement
             Gas costs: 0
             Source: "participantsForPreSale[sender] = 0"
            Assignment using operator =
               Type: uint256
               Source: "participantsForPreSale[sender] = 0"
              IndexAccess
                 Type: uint256
                 Source: "participantsForPreSale[sender]"
                Identifier participantsForPreSale
                   Type: mapping(address => uint256)
                   Source: "participantsForPreSale"
                Identifier sender
                   Type: address
                   Source: "sender"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      IfStatement
         Source: "if(now > t.deadline1 && participantsFor1stSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsFor1stSale[sender] * s.saleSupply1 / s.amountRaised1);  //Token Amount Per Eth = s.saleSupply1 / s.amountRaised1\r\n            participantsFor1stSale[sender] = 0;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "now > t.deadline1 && participantsFor1stSale[sender] != 0"
          BinaryOperation using operator >
             Type: bool
             Source: "now > t.deadline1"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member deadline1
               Type: uint256
               Source: "t.deadline1"
              Identifier t
                 Type: struct CrowdSale.SaleTimeAttr storage ref
                 Source: "t"
          BinaryOperation using operator !=
             Type: bool
             Source: "participantsFor1stSale[sender] != 0"
            IndexAccess
               Type: uint256
               Source: "participantsFor1stSale[sender]"
              Identifier participantsFor1stSale
                 Type: mapping(address => uint256)
                 Source: "participantsFor1stSale"
              Identifier sender
                 Type: address
                 Source: "sender"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            tokenAmount = add(tokenAmount,participantsFor1stSale[sender] * s.saleSupply1 / s.amountRaised1);  //Token Amount Per Eth = s.saleSupply1 / s.amountRaised1\r\n            participantsFor1stSale[sender] = 0;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "tokenAmount = add(tokenAmount,participantsFor1stSale[sender] * s.saleSupply1 / s.amountRaised1)"
            Assignment using operator =
               Type: uint256
               Source: "tokenAmount = add(tokenAmount,participantsFor1stSale[sender] * s.saleSupply1 / s.amountRaised1)"
              Identifier tokenAmount
                 Type: uint256
                 Source: "tokenAmount"
              FunctionCall
                 Type: uint256
                 Source: "add(tokenAmount,participantsFor1stSale[sender] * s.saleSupply1 / s.amountRaised1)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                Identifier tokenAmount
                   Type: uint256
                   Source: "tokenAmount"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "participantsFor1stSale[sender] * s.saleSupply1 / s.amountRaised1"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "participantsFor1stSale[sender] * s.saleSupply1"
                    IndexAccess
                       Type: uint256
                       Source: "participantsFor1stSale[sender]"
                      Identifier participantsFor1stSale
                         Type: mapping(address => uint256)
                         Source: "participantsFor1stSale"
                      Identifier sender
                         Type: address
                         Source: "sender"
                    MemberAccess to member saleSupply1
                       Type: uint256
                       Source: "s.saleSupply1"
                      Identifier s
                         Type: struct CrowdSale.SaleAttr storage ref
                         Source: "s"
                  MemberAccess to member amountRaised1
                     Type: uint256
                     Source: "s.amountRaised1"
                    Identifier s
                       Type: struct CrowdSale.SaleAttr storage ref
                       Source: "s"
          ExpressionStatement
             Gas costs: 0
             Source: "participantsFor1stSale[sender] = 0"
            Assignment using operator =
               Type: uint256
               Source: "participantsFor1stSale[sender] = 0"
              IndexAccess
                 Type: uint256
                 Source: "participantsFor1stSale[sender]"
                Identifier participantsFor1stSale
                   Type: mapping(address => uint256)
                   Source: "participantsFor1stSale"
                Identifier sender
                   Type: address
                   Source: "sender"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      IfStatement
         Source: "if(now > t.deadline3 && participantsFor3rdSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsFor3rdSale[sender] * s.saleSupply3 / s.amountRaised3);  //Token Amount Per Eth = s.saleSupply3 / s.amountRaised3\r\n            participantsFor3rdSale[sender] = 0;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "now > t.deadline3 && participantsFor3rdSale[sender] != 0"
          BinaryOperation using operator >
             Type: bool
             Source: "now > t.deadline3"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member deadline3
               Type: uint256
               Source: "t.deadline3"
              Identifier t
                 Type: struct CrowdSale.SaleTimeAttr storage ref
                 Source: "t"
          BinaryOperation using operator !=
             Type: bool
             Source: "participantsFor3rdSale[sender] != 0"
            IndexAccess
               Type: uint256
               Source: "participantsFor3rdSale[sender]"
              Identifier participantsFor3rdSale
                 Type: mapping(address => uint256)
                 Source: "participantsFor3rdSale"
              Identifier sender
                 Type: address
                 Source: "sender"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            tokenAmount = add(tokenAmount,participantsFor3rdSale[sender] * s.saleSupply3 / s.amountRaised3);  //Token Amount Per Eth = s.saleSupply3 / s.amountRaised3\r\n            participantsFor3rdSale[sender] = 0;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "tokenAmount = add(tokenAmount,participantsFor3rdSale[sender] * s.saleSupply3 / s.amountRaised3)"
            Assignment using operator =
               Type: uint256
               Source: "tokenAmount = add(tokenAmount,participantsFor3rdSale[sender] * s.saleSupply3 / s.amountRaised3)"
              Identifier tokenAmount
                 Type: uint256
                 Source: "tokenAmount"
              FunctionCall
                 Type: uint256
                 Source: "add(tokenAmount,participantsFor3rdSale[sender] * s.saleSupply3 / s.amountRaised3)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                Identifier tokenAmount
                   Type: uint256
                   Source: "tokenAmount"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "participantsFor3rdSale[sender] * s.saleSupply3 / s.amountRaised3"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "participantsFor3rdSale[sender] * s.saleSupply3"
                    IndexAccess
                       Type: uint256
                       Source: "participantsFor3rdSale[sender]"
                      Identifier participantsFor3rdSale
                         Type: mapping(address => uint256)
                         Source: "participantsFor3rdSale"
                      Identifier sender
                         Type: address
                         Source: "sender"
                    MemberAccess to member saleSupply3
                       Type: uint256
                       Source: "s.saleSupply3"
                      Identifier s
                         Type: struct CrowdSale.SaleAttr storage ref
                         Source: "s"
                  MemberAccess to member amountRaised3
                     Type: uint256
                     Source: "s.amountRaised3"
                    Identifier s
                       Type: struct CrowdSale.SaleAttr storage ref
                       Source: "s"
          ExpressionStatement
             Gas costs: 0
             Source: "participantsFor3rdSale[sender] = 0"
            Assignment using operator =
               Type: uint256
               Source: "participantsFor3rdSale[sender] = 0"
              IndexAccess
                 Type: uint256
                 Source: "participantsFor3rdSale[sender]"
                Identifier participantsFor3rdSale
                   Type: mapping(address => uint256)
                   Source: "participantsFor3rdSale"
                Identifier sender
                   Type: address
                   Source: "sender"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      IfStatement
         Source: "if(now > cs.end && participantsForCustomSale[cs.start][sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsForCustomSale[cs.start][sender] * cs.saleSupply / cs.amountRaised);  //Token Amount Per Eth = cs.saleSupply / cs.amountRaised\r\n            participantsForCustomSale[cs.start][sender] = 0;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "now > cs.end && participantsForCustomSale[cs.start][sender] != 0"
          BinaryOperation using operator >
             Type: bool
             Source: "now > cs.end"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member end
               Type: uint256
               Source: "cs.end"
              Identifier cs
                 Type: struct CrowdSale.CustomSaleAttr storage ref
                 Source: "cs"
          BinaryOperation using operator !=
             Type: bool
             Source: "participantsForCustomSale[cs.start][sender] != 0"
            IndexAccess
               Type: uint256
               Source: "participantsForCustomSale[cs.start][sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "participantsForCustomSale[cs.start]"
                Identifier participantsForCustomSale
                   Type: mapping(uint256 => mapping(address => uint256))
                   Source: "participantsForCustomSale"
                MemberAccess to member start
                   Type: uint256
                   Source: "cs.start"
                  Identifier cs
                     Type: struct CrowdSale.CustomSaleAttr storage ref
                     Source: "cs"
              Identifier sender
                 Type: address
                 Source: "sender"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            tokenAmount = add(tokenAmount,participantsForCustomSale[cs.start][sender] * cs.saleSupply / cs.amountRaised);  //Token Amount Per Eth = cs.saleSupply / cs.amountRaised\r\n            participantsForCustomSale[cs.start][sender] = 0;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "tokenAmount = add(tokenAmount,participantsForCustomSale[cs.start][sender] * cs.saleSupply / cs.amountRaised)"
            Assignment using operator =
               Type: uint256
               Source: "tokenAmount = add(tokenAmount,participantsForCustomSale[cs.start][sender] * cs.saleSupply / cs.amountRaised)"
              Identifier tokenAmount
                 Type: uint256
                 Source: "tokenAmount"
              FunctionCall
                 Type: uint256
                 Source: "add(tokenAmount,participantsForCustomSale[cs.start][sender] * cs.saleSupply / cs.amountRaised)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                Identifier tokenAmount
                   Type: uint256
                   Source: "tokenAmount"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "participantsForCustomSale[cs.start][sender] * cs.saleSupply / cs.amountRaised"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "participantsForCustomSale[cs.start][sender] * cs.saleSupply"
                    IndexAccess
                       Type: uint256
                       Source: "participantsForCustomSale[cs.start][sender]"
                      IndexAccess
                         Type: mapping(address => uint256)
                         Source: "participantsForCustomSale[cs.start]"
                        Identifier participantsForCustomSale
                           Type: mapping(uint256 => mapping(address => uint256))
                           Source: "participantsForCustomSale"
                        MemberAccess to member start
                           Type: uint256
                           Source: "cs.start"
                          Identifier cs
                             Type: struct CrowdSale.CustomSaleAttr storage ref
                             Source: "cs"
                      Identifier sender
                         Type: address
                         Source: "sender"
                    MemberAccess to member saleSupply
                       Type: uint256
                       Source: "cs.saleSupply"
                      Identifier cs
                         Type: struct CrowdSale.CustomSaleAttr storage ref
                         Source: "cs"
                  MemberAccess to member amountRaised
                     Type: uint256
                     Source: "cs.amountRaised"
                    Identifier cs
                       Type: struct CrowdSale.CustomSaleAttr storage ref
                       Source: "cs"
          ExpressionStatement
             Gas costs: 0
             Source: "participantsForCustomSale[cs.start][sender] = 0"
            Assignment using operator =
               Type: uint256
               Source: "participantsForCustomSale[cs.start][sender] = 0"
              IndexAccess
                 Type: uint256
                 Source: "participantsForCustomSale[cs.start][sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "participantsForCustomSale[cs.start]"
                  Identifier participantsForCustomSale
                     Type: mapping(uint256 => mapping(address => uint256))
                     Source: "participantsForCustomSale"
                  MemberAccess to member start
                     Type: uint256
                     Source: "cs.start"
                    Identifier cs
                       Type: struct CrowdSale.CustomSaleAttr storage ref
                       Source: "cs"
                Identifier sender
                   Type: address
                   Source: "sender"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
ContractDefinition "Voting"
   Source: "contract Voting is SafeMath, Authable {\r\n    mapping(uint => uint) public voteRewardPerUnit; // If the voters vote, they will rewarded x% of tokens by their balances. 100 means 1%, 1000 means 10%\r\n    mapping(uint => uint) public voteWeightUnit;    // If 100 * 1 ether, each 100 * 1 ether token of holder will get vote weight 1. \r\n    mapping(uint => uint) public voteStart;\r\n    mapping(uint => uint) public voteEnd;\r\n    mapping(uint => uint) public maxCandidateId;\r\n\r\n    mapping(uint => mapping(address => bool)) public voted;\r\n    mapping(uint => mapping(uint => uint)) public results;\r\n\r\n    event LogVoteInitiate(uint _voteId, uint _voteRewardPerUnit, uint _voteWeightUnit, uint _voteStart, uint _voteEnd, uint _maxCandidateId);\r\n    event LogVote(address voter, uint weight, uint voteId, uint candidateId, uint candidateValue);\r\n\r\n    function voteInitiate(uint _voteId, uint _voteRewardPerUnit, uint _voteWeightUnit, uint _voteStart, uint _voteEnd, uint _maxCandidateId) onlyOwner {   \r\n        require(voteEnd[_voteId] == 0);  // Do not allow duplicate voteId\r\n        require(_voteEnd != 0);\r\n\r\n        voteRewardPerUnit[_voteId] = _voteRewardPerUnit;\r\n        voteWeightUnit[_voteId] = _voteWeightUnit;\r\n        voteStart[_voteId] = _voteStart;\r\n        voteEnd[_voteId] = _voteEnd;\r\n        maxCandidateId[_voteId] = _maxCandidateId;\r\n\r\n        LogVoteInitiate(_voteId, _voteRewardPerUnit, _voteWeightUnit, _voteStart, _voteEnd, _maxCandidateId);\r\n    }\r\n\r\n     function vote(address sender, uint holding, uint voteId, uint candidateId) onlyOwner returns (uint tokenAmount, uint lockUntil){\r\n        require(now > voteStart[voteId] && now <= voteEnd[voteId]);\r\n        require(maxCandidateId[voteId] >= candidateId);\r\n        require(holding >= voteRewardPerUnit[voteId]);\r\n        require(!voted[voteId][sender]);\r\n\r\n        uint weight = holding / voteWeightUnit[voteId];\r\n\r\n        results[voteId][candidateId] = add(results[voteId][candidateId], weight);\r\n        voted[voteId][sender] = true;\r\n        tokenAmount = weight * voteWeightUnit[voteId] * voteRewardPerUnit[voteId] / 100 / 100;\r\n        lockUntil = voteEnd[voteId];\r\n\r\n        LogVote(sender, weight, voteId, candidateId, results[voteId][candidateId]);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Authable"
    UserDefinedTypeName "Authable"
       Source: "Authable"
  VariableDeclaration "voteRewardPerUnit"
     Type: mapping(uint256 => uint256)
     Gas costs: 0
     Source: "mapping(uint => uint) public voteRewardPerUnit"
    Mapping
       Source: "mapping(uint => uint)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "voteWeightUnit"
     Type: mapping(uint256 => uint256)
     Gas costs: 0
     Source: "mapping(uint => uint) public voteWeightUnit"
    Mapping
       Source: "mapping(uint => uint)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "voteStart"
     Type: mapping(uint256 => uint256)
     Gas costs: 0
     Source: "mapping(uint => uint) public voteStart"
    Mapping
       Source: "mapping(uint => uint)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "voteEnd"
     Type: mapping(uint256 => uint256)
     Gas costs: 0
     Source: "mapping(uint => uint) public voteEnd"
    Mapping
       Source: "mapping(uint => uint)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "maxCandidateId"
     Type: mapping(uint256 => uint256)
     Gas costs: 0
     Source: "mapping(uint => uint) public maxCandidateId"
    Mapping
       Source: "mapping(uint => uint)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "voted"
     Type: mapping(uint256 => mapping(address => bool))
     Gas costs: 0
     Source: "mapping(uint => mapping(address => bool)) public voted"
    Mapping
       Source: "mapping(uint => mapping(address => bool))"
      ElementaryTypeName uint
         Source: "uint"
      Mapping
         Source: "mapping(address => bool)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName bool
           Source: "bool"
  VariableDeclaration "results"
     Type: mapping(uint256 => mapping(uint256 => uint256))
     Gas costs: 0
     Source: "mapping(uint => mapping(uint => uint)) public results"
    Mapping
       Source: "mapping(uint => mapping(uint => uint))"
      ElementaryTypeName uint
         Source: "uint"
      Mapping
         Source: "mapping(uint => uint)"
        ElementaryTypeName uint
           Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LogVoteInitiate"
     Gas costs: 0
     Source: "event LogVoteInitiate(uint _voteId, uint _voteRewardPerUnit, uint _voteWeightUnit, uint _voteStart, uint _voteEnd, uint _maxCandidateId);"
    ParameterList
       Source: "(uint _voteId, uint _voteRewardPerUnit, uint _voteWeightUnit, uint _voteStart, uint _voteEnd, uint _maxCandidateId)"
      VariableDeclaration "_voteId"
         Type: uint256
         Source: "uint _voteId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_voteRewardPerUnit"
         Type: uint256
         Source: "uint _voteRewardPerUnit"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_voteWeightUnit"
         Type: uint256
         Source: "uint _voteWeightUnit"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_voteStart"
         Type: uint256
         Source: "uint _voteStart"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_voteEnd"
         Type: uint256
         Source: "uint _voteEnd"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_maxCandidateId"
         Type: uint256
         Source: "uint _maxCandidateId"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LogVote"
     Gas costs: 0
     Source: "event LogVote(address voter, uint weight, uint voteId, uint candidateId, uint candidateValue);"
    ParameterList
       Source: "(address voter, uint weight, uint voteId, uint candidateId, uint candidateValue)"
      VariableDeclaration "voter"
         Type: address
         Source: "address voter"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "weight"
         Type: uint256
         Source: "uint weight"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "voteId"
         Type: uint256
         Source: "uint voteId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "candidateId"
         Type: uint256
         Source: "uint candidateId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "candidateValue"
         Type: uint256
         Source: "uint candidateValue"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "voteInitiate" - public
     Source: "function voteInitiate(uint _voteId, uint _voteRewardPerUnit, uint _voteWeightUnit, uint _voteStart, uint _voteEnd, uint _maxCandidateId) onlyOwner {   \r\n        require(voteEnd[_voteId] == 0);  // Do not allow duplicate voteId\r\n        require(_voteEnd != 0);\r\n\r\n        voteRewardPerUnit[_voteId] = _voteRewardPerUnit;\r\n        voteWeightUnit[_voteId] = _voteWeightUnit;\r\n        voteStart[_voteId] = _voteStart;\r\n        voteEnd[_voteId] = _voteEnd;\r\n        maxCandidateId[_voteId] = _maxCandidateId;\r\n\r\n        LogVoteInitiate(_voteId, _voteRewardPerUnit, _voteWeightUnit, _voteStart, _voteEnd, _maxCandidateId);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _voteId, uint _voteRewardPerUnit, uint _voteWeightUnit, uint _voteStart, uint _voteEnd, uint _maxCandidateId)"
      VariableDeclaration "_voteId"
         Type: uint256
         Source: "uint _voteId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_voteRewardPerUnit"
         Type: uint256
         Source: "uint _voteRewardPerUnit"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_voteWeightUnit"
         Type: uint256
         Source: "uint _voteWeightUnit"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_voteStart"
         Type: uint256
         Source: "uint _voteStart"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_voteEnd"
         Type: uint256
         Source: "uint _voteEnd"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_maxCandidateId"
         Type: uint256
         Source: "uint _maxCandidateId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{   \r\n        require(voteEnd[_voteId] == 0);  // Do not allow duplicate voteId\r\n        require(_voteEnd != 0);\r\n\r\n        voteRewardPerUnit[_voteId] = _voteRewardPerUnit;\r\n        voteWeightUnit[_voteId] = _voteWeightUnit;\r\n        voteStart[_voteId] = _voteStart;\r\n        voteEnd[_voteId] = _voteEnd;\r\n        maxCandidateId[_voteId] = _maxCandidateId;\r\n\r\n        LogVoteInitiate(_voteId, _voteRewardPerUnit, _voteWeightUnit, _voteStart, _voteEnd, _maxCandidateId);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(voteEnd[_voteId] == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(voteEnd[_voteId] == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "voteEnd[_voteId] == 0"
            IndexAccess
               Type: uint256
               Source: "voteEnd[_voteId]"
              Identifier voteEnd
                 Type: mapping(uint256 => uint256)
                 Source: "voteEnd"
              Identifier _voteId
                 Type: uint256
                 Source: "_voteId"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_voteEnd != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_voteEnd != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_voteEnd != 0"
            Identifier _voteEnd
               Type: uint256
               Source: "_voteEnd"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "voteRewardPerUnit[_voteId] = _voteRewardPerUnit"
        Assignment using operator =
           Type: uint256
           Source: "voteRewardPerUnit[_voteId] = _voteRewardPerUnit"
          IndexAccess
             Type: uint256
             Source: "voteRewardPerUnit[_voteId]"
            Identifier voteRewardPerUnit
               Type: mapping(uint256 => uint256)
               Source: "voteRewardPerUnit"
            Identifier _voteId
               Type: uint256
               Source: "_voteId"
          Identifier _voteRewardPerUnit
             Type: uint256
             Source: "_voteRewardPerUnit"
      ExpressionStatement
         Gas costs: 0
         Source: "voteWeightUnit[_voteId] = _voteWeightUnit"
        Assignment using operator =
           Type: uint256
           Source: "voteWeightUnit[_voteId] = _voteWeightUnit"
          IndexAccess
             Type: uint256
             Source: "voteWeightUnit[_voteId]"
            Identifier voteWeightUnit
               Type: mapping(uint256 => uint256)
               Source: "voteWeightUnit"
            Identifier _voteId
               Type: uint256
               Source: "_voteId"
          Identifier _voteWeightUnit
             Type: uint256
             Source: "_voteWeightUnit"
      ExpressionStatement
         Gas costs: 0
         Source: "voteStart[_voteId] = _voteStart"
        Assignment using operator =
           Type: uint256
           Source: "voteStart[_voteId] = _voteStart"
          IndexAccess
             Type: uint256
             Source: "voteStart[_voteId]"
            Identifier voteStart
               Type: mapping(uint256 => uint256)
               Source: "voteStart"
            Identifier _voteId
               Type: uint256
               Source: "_voteId"
          Identifier _voteStart
             Type: uint256
             Source: "_voteStart"
      ExpressionStatement
         Gas costs: 0
         Source: "voteEnd[_voteId] = _voteEnd"
        Assignment using operator =
           Type: uint256
           Source: "voteEnd[_voteId] = _voteEnd"
          IndexAccess
             Type: uint256
             Source: "voteEnd[_voteId]"
            Identifier voteEnd
               Type: mapping(uint256 => uint256)
               Source: "voteEnd"
            Identifier _voteId
               Type: uint256
               Source: "_voteId"
          Identifier _voteEnd
             Type: uint256
             Source: "_voteEnd"
      ExpressionStatement
         Gas costs: 0
         Source: "maxCandidateId[_voteId] = _maxCandidateId"
        Assignment using operator =
           Type: uint256
           Source: "maxCandidateId[_voteId] = _maxCandidateId"
          IndexAccess
             Type: uint256
             Source: "maxCandidateId[_voteId]"
            Identifier maxCandidateId
               Type: mapping(uint256 => uint256)
               Source: "maxCandidateId"
            Identifier _voteId
               Type: uint256
               Source: "_voteId"
          Identifier _maxCandidateId
             Type: uint256
             Source: "_maxCandidateId"
      ExpressionStatement
         Gas costs: 0
         Source: "LogVoteInitiate(_voteId, _voteRewardPerUnit, _voteWeightUnit, _voteStart, _voteEnd, _maxCandidateId)"
        FunctionCall
           Type: tuple()
           Source: "LogVoteInitiate(_voteId, _voteRewardPerUnit, _voteWeightUnit, _voteStart, _voteEnd, _maxCandidateId)"
          Identifier LogVoteInitiate
             Type: function (uint256,uint256,uint256,uint256,uint256,uint256)
             Source: "LogVoteInitiate"
          Identifier _voteId
             Type: uint256
             Source: "_voteId"
          Identifier _voteRewardPerUnit
             Type: uint256
             Source: "_voteRewardPerUnit"
          Identifier _voteWeightUnit
             Type: uint256
             Source: "_voteWeightUnit"
          Identifier _voteStart
             Type: uint256
             Source: "_voteStart"
          Identifier _voteEnd
             Type: uint256
             Source: "_voteEnd"
          Identifier _maxCandidateId
             Type: uint256
             Source: "_maxCandidateId"
  FunctionDefinition "vote" - public
     Source: "function vote(address sender, uint holding, uint voteId, uint candidateId) onlyOwner returns (uint tokenAmount, uint lockUntil){\r\n        require(now > voteStart[voteId] && now <= voteEnd[voteId]);\r\n        require(maxCandidateId[voteId] >= candidateId);\r\n        require(holding >= voteRewardPerUnit[voteId]);\r\n        require(!voted[voteId][sender]);\r\n\r\n        uint weight = holding / voteWeightUnit[voteId];\r\n\r\n        results[voteId][candidateId] = add(results[voteId][candidateId], weight);\r\n        voted[voteId][sender] = true;\r\n        tokenAmount = weight * voteWeightUnit[voteId] * voteRewardPerUnit[voteId] / 100 / 100;\r\n        lockUntil = voteEnd[voteId];\r\n\r\n        LogVote(sender, weight, voteId, candidateId, results[voteId][candidateId]);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address sender, uint holding, uint voteId, uint candidateId)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "holding"
         Type: uint256
         Source: "uint holding"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "voteId"
         Type: uint256
         Source: "uint voteId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "candidateId"
         Type: uint256
         Source: "uint candidateId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint tokenAmount, uint lockUntil)"
      VariableDeclaration "tokenAmount"
         Type: uint256
         Source: "uint tokenAmount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "lockUntil"
         Type: uint256
         Source: "uint lockUntil"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(now > voteStart[voteId] && now <= voteEnd[voteId]);\r\n        require(maxCandidateId[voteId] >= candidateId);\r\n        require(holding >= voteRewardPerUnit[voteId]);\r\n        require(!voted[voteId][sender]);\r\n\r\n        uint weight = holding / voteWeightUnit[voteId];\r\n\r\n        results[voteId][candidateId] = add(results[voteId][candidateId], weight);\r\n        voted[voteId][sender] = true;\r\n        tokenAmount = weight * voteWeightUnit[voteId] * voteRewardPerUnit[voteId] / 100 / 100;\r\n        lockUntil = voteEnd[voteId];\r\n\r\n        LogVote(sender, weight, voteId, candidateId, results[voteId][candidateId]);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(now > voteStart[voteId] && now <= voteEnd[voteId])"
        FunctionCall
           Type: tuple()
           Source: "require(now > voteStart[voteId] && now <= voteEnd[voteId])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "now > voteStart[voteId] && now <= voteEnd[voteId]"
            BinaryOperation using operator >
               Type: bool
               Source: "now > voteStart[voteId]"
              Identifier now
                 Type: uint256
                 Source: "now"
              IndexAccess
                 Type: uint256
                 Source: "voteStart[voteId]"
                Identifier voteStart
                   Type: mapping(uint256 => uint256)
                   Source: "voteStart"
                Identifier voteId
                   Type: uint256
                   Source: "voteId"
            BinaryOperation using operator <=
               Type: bool
               Source: "now <= voteEnd[voteId]"
              Identifier now
                 Type: uint256
                 Source: "now"
              IndexAccess
                 Type: uint256
                 Source: "voteEnd[voteId]"
                Identifier voteEnd
                   Type: mapping(uint256 => uint256)
                   Source: "voteEnd"
                Identifier voteId
                   Type: uint256
                   Source: "voteId"
      ExpressionStatement
         Gas costs: 0
         Source: "require(maxCandidateId[voteId] >= candidateId)"
        FunctionCall
           Type: tuple()
           Source: "require(maxCandidateId[voteId] >= candidateId)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "maxCandidateId[voteId] >= candidateId"
            IndexAccess
               Type: uint256
               Source: "maxCandidateId[voteId]"
              Identifier maxCandidateId
                 Type: mapping(uint256 => uint256)
                 Source: "maxCandidateId"
              Identifier voteId
                 Type: uint256
                 Source: "voteId"
            Identifier candidateId
               Type: uint256
               Source: "candidateId"
      ExpressionStatement
         Gas costs: 0
         Source: "require(holding >= voteRewardPerUnit[voteId])"
        FunctionCall
           Type: tuple()
           Source: "require(holding >= voteRewardPerUnit[voteId])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "holding >= voteRewardPerUnit[voteId]"
            Identifier holding
               Type: uint256
               Source: "holding"
            IndexAccess
               Type: uint256
               Source: "voteRewardPerUnit[voteId]"
              Identifier voteRewardPerUnit
                 Type: mapping(uint256 => uint256)
                 Source: "voteRewardPerUnit"
              Identifier voteId
                 Type: uint256
                 Source: "voteId"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!voted[voteId][sender])"
        FunctionCall
           Type: tuple()
           Source: "require(!voted[voteId][sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!voted[voteId][sender]"
            IndexAccess
               Type: bool
               Source: "voted[voteId][sender]"
              IndexAccess
                 Type: mapping(address => bool)
                 Source: "voted[voteId]"
                Identifier voted
                   Type: mapping(uint256 => mapping(address => bool))
                   Source: "voted"
                Identifier voteId
                   Type: uint256
                   Source: "voteId"
              Identifier sender
                 Type: address
                 Source: "sender"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint weight = holding / voteWeightUnit[voteId]"
        VariableDeclaration "weight"
           Type: uint256
           Source: "uint weight"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "holding / voteWeightUnit[voteId]"
          Identifier holding
             Type: uint256
             Source: "holding"
          IndexAccess
             Type: uint256
             Source: "voteWeightUnit[voteId]"
            Identifier voteWeightUnit
               Type: mapping(uint256 => uint256)
               Source: "voteWeightUnit"
            Identifier voteId
               Type: uint256
               Source: "voteId"
      ExpressionStatement
         Gas costs: 0
         Source: "results[voteId][candidateId] = add(results[voteId][candidateId], weight)"
        Assignment using operator =
           Type: uint256
           Source: "results[voteId][candidateId] = add(results[voteId][candidateId], weight)"
          IndexAccess
             Type: uint256
             Source: "results[voteId][candidateId]"
            IndexAccess
               Type: mapping(uint256 => uint256)
               Source: "results[voteId]"
              Identifier results
                 Type: mapping(uint256 => mapping(uint256 => uint256))
                 Source: "results"
              Identifier voteId
                 Type: uint256
                 Source: "voteId"
            Identifier candidateId
               Type: uint256
               Source: "candidateId"
          FunctionCall
             Type: uint256
             Source: "add(results[voteId][candidateId], weight)"
            Identifier add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "add"
            IndexAccess
               Type: uint256
               Source: "results[voteId][candidateId]"
              IndexAccess
                 Type: mapping(uint256 => uint256)
                 Source: "results[voteId]"
                Identifier results
                   Type: mapping(uint256 => mapping(uint256 => uint256))
                   Source: "results"
                Identifier voteId
                   Type: uint256
                   Source: "voteId"
              Identifier candidateId
                 Type: uint256
                 Source: "candidateId"
            Identifier weight
               Type: uint256
               Source: "weight"
      ExpressionStatement
         Gas costs: 0
         Source: "voted[voteId][sender] = true"
        Assignment using operator =
           Type: bool
           Source: "voted[voteId][sender] = true"
          IndexAccess
             Type: bool
             Source: "voted[voteId][sender]"
            IndexAccess
               Type: mapping(address => bool)
               Source: "voted[voteId]"
              Identifier voted
                 Type: mapping(uint256 => mapping(address => bool))
                 Source: "voted"
              Identifier voteId
                 Type: uint256
                 Source: "voteId"
            Identifier sender
               Type: address
               Source: "sender"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenAmount = weight * voteWeightUnit[voteId] * voteRewardPerUnit[voteId] / 100 / 100"
        Assignment using operator =
           Type: uint256
           Source: "tokenAmount = weight * voteWeightUnit[voteId] * voteRewardPerUnit[voteId] / 100 / 100"
          Identifier tokenAmount
             Type: uint256
             Source: "tokenAmount"
          BinaryOperation using operator /
             Type: uint256
             Source: "weight * voteWeightUnit[voteId] * voteRewardPerUnit[voteId] / 100 / 100"
            BinaryOperation using operator /
               Type: uint256
               Source: "weight * voteWeightUnit[voteId] * voteRewardPerUnit[voteId] / 100"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "weight * voteWeightUnit[voteId] * voteRewardPerUnit[voteId]"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "weight * voteWeightUnit[voteId]"
                  Identifier weight
                     Type: uint256
                     Source: "weight"
                  IndexAccess
                     Type: uint256
                     Source: "voteWeightUnit[voteId]"
                    Identifier voteWeightUnit
                       Type: mapping(uint256 => uint256)
                       Source: "voteWeightUnit"
                    Identifier voteId
                       Type: uint256
                       Source: "voteId"
                IndexAccess
                   Type: uint256
                   Source: "voteRewardPerUnit[voteId]"
                  Identifier voteRewardPerUnit
                     Type: mapping(uint256 => uint256)
                     Source: "voteRewardPerUnit"
                  Identifier voteId
                     Type: uint256
                     Source: "voteId"
              Literal, token: [no token] value: 100
                 Type: int_const 100
                 Source: "100"
            Literal, token: [no token] value: 100
               Type: int_const 100
               Source: "100"
      ExpressionStatement
         Gas costs: 0
         Source: "lockUntil = voteEnd[voteId]"
        Assignment using operator =
           Type: uint256
           Source: "lockUntil = voteEnd[voteId]"
          Identifier lockUntil
             Type: uint256
             Source: "lockUntil"
          IndexAccess
             Type: uint256
             Source: "voteEnd[voteId]"
            Identifier voteEnd
               Type: mapping(uint256 => uint256)
               Source: "voteEnd"
            Identifier voteId
               Type: uint256
               Source: "voteId"
      ExpressionStatement
         Gas costs: 0
         Source: "LogVote(sender, weight, voteId, candidateId, results[voteId][candidateId])"
        FunctionCall
           Type: tuple()
           Source: "LogVote(sender, weight, voteId, candidateId, results[voteId][candidateId])"
          Identifier LogVote
             Type: function (address,uint256,uint256,uint256,uint256)
             Source: "LogVote"
          Identifier sender
             Type: address
             Source: "sender"
          Identifier weight
             Type: uint256
             Source: "weight"
          Identifier voteId
             Type: uint256
             Source: "voteId"
          Identifier candidateId
             Type: uint256
             Source: "candidateId"
          IndexAccess
             Type: uint256
             Source: "results[voteId][candidateId]"
            IndexAccess
               Type: mapping(uint256 => uint256)
               Source: "results[voteId]"
              Identifier results
                 Type: mapping(uint256 => mapping(uint256 => uint256))
                 Source: "results"
              Identifier voteId
                 Type: uint256
                 Source: "voteId"
            Identifier candidateId
               Type: uint256
               Source: "candidateId"
ContractDefinition "Games"
   Source: "contract Games is SafeMath, DateTime, Authable {\r\n    enum GameTime { Hour, Month, Year, OutOfTime }\r\n    enum GameType { Range, Point}\r\n\r\n    struct Participant {\r\n        address sender;\r\n        uint value;\r\n        uint currency; // 1 : Eth, 2 : Tok\r\n    }\r\n\r\n    struct DateAttr{\r\n        uint currentYear;\r\n        uint gameStart; //Only for Range Game\r\n        uint gameEnd;   //For both Range Game and point Game(=intime timestamp)\r\n        uint prevGameEnd; //Only for Point Game\r\n    }\r\n    DateAttr public d;\r\n\r\n    struct CommonAttr{\r\n        GameTime currentGameTimeType;      // Current Game time type\r\n        GameType gameType;\r\n\r\n        uint hourlyAmountEth;  // Funded Eth amount\r\n        uint monthlyAmountEth;\r\n        uint yearlyAmountEth;\r\n        uint charityAmountEth;\r\n\r\n    }\r\n    CommonAttr public c;\r\n\r\n    struct FundAmountStatusAttr{\r\n        uint hourlyStatusEth;  // Funded Eth amount in current game time\r\n        uint monthlyStatusEth;\r\n        uint yearlyStatusEth;\r\n\r\n        uint hourlyStatusTok;  // Funded Token amount in current game time\r\n        uint monthlyStatusTok;\r\n    }\r\n    FundAmountStatusAttr public f;\r\n\r\n    struct PriceAttr{\r\n        uint bonusPerEth;   // If you not won, xx token to 1 Eth will be rewarded\r\n\r\n        uint inGameTokPricePerEth;   // Regard xx token to 1 Eth for token participants\r\n        uint inGameTokWinRatioMax;   // 100 means 100%. Disadventage against Eth. Change prize ratio like 25~50%\r\n        uint inGameTokWinRatioMin;\r\n        uint currentInGameTokWinRatio;  // Current token winners prize ratio\r\n\r\n        uint hourlyMinParticipateRatio;     // If participants.length are less than 100, x100 would be min prize ratio\r\n        uint monthlyMinParticipateRatio;    // If participants.length are less than 300, x300 would be min prize ratio\r\n        uint yearlyMinParticipateRatio;     // If participants.length are less than 1000, x1000 would be min prize ratio\r\n\r\n        uint boostPrizeEth;    // Boosts prize amount. Default is 100 and it means 100%\r\n    }\r\n    PriceAttr public p;\r\n\r\n\r\n    struct RangeGameAttr{\r\n        uint inTimeRange_H; // 10 means +-10 mins in time\r\n        uint inTimeRange_M;\r\n        uint inTimeRange_Y;\r\n    }\r\n    RangeGameAttr public r;\r\n    Participant[] public participants;  // RangeGame participants\r\n\r\n    mapping(uint256 => mapping(address => uint256)) public winners; // Eth reward\r\n    mapping(uint256 => mapping(address => uint256)) public tokTakers; // Tok reward\r\n    mapping(uint256 => uint256) public winPrizes;\r\n    mapping(uint256 => uint256) public tokPrizes;\r\n\r\n    event LogSelectWinner(uint rand, uint luckyNumber, address sender, uint reward, uint currency, uint amount);\r\n\r\n    function setPriceAttr(\r\n            GameType _gameType, uint _bonusPerEth, uint _inGameTokPricePerEth\r\n            , uint _inGameTokWinRatioMax, uint _inGameTokWinRatioMin, uint _currentInGameTokWinRatio\r\n            , uint _hourlyMinParticipateRatio, uint _monthlyMinParticipateRatio, uint _yearlyMinParticipateRatio, uint _boostPrizeEth\r\n        ) onlyAuth {\r\n        c.gameType = _gameType;\r\n\r\n        p.bonusPerEth = _bonusPerEth;   //300   // Depends on crowdSale average price. Vote needed, but we assume AVG/4 is reasonable.\r\n        p.inGameTokPricePerEth = _inGameTokPricePerEth; //300   // Regard xx token to 1 Eth for token participants. Depends on crowdSale, too.\r\n        p.inGameTokWinRatioMax = _inGameTokWinRatioMax; //50    // 100 means 100%. Disadventage against Eth. Change prize ratio like 25~50%\r\n        p.inGameTokWinRatioMin = _inGameTokWinRatioMin; //25\r\n        p.currentInGameTokWinRatio = _currentInGameTokWinRatio;    //50\r\n        p.hourlyMinParticipateRatio = _hourlyMinParticipateRatio;   //100   // If participants.length are less than 100, x100 would be min prize ratio\r\n        p.monthlyMinParticipateRatio = _monthlyMinParticipateRatio; //300\r\n        p.yearlyMinParticipateRatio = _yearlyMinParticipateRatio;   //1000\r\n        p.boostPrizeEth = _boostPrizeEth;   //100\r\n    }\r\n\r\n    function setRangeGameAttr(uint _inTimeRange_H, uint _inTimeRange_M, uint _inTimeRange_Y) onlyAuth {\r\n        r.inTimeRange_H = _inTimeRange_H;   //10       // 10 mean +-10 mins in time\r\n        r.inTimeRange_M = _inTimeRange_M;   //190 = 3 * 60 + r.inTimeRange_H\r\n        r.inTimeRange_Y = _inTimeRange_Y;   //370 = 6 * 60 + r.inTimeRange_H\r\n    }\r\n     \r\n    // Calulate game time and gc amount record\r\n    modifier beforeRangeGame(){\r\n        require(now > d.gameStart && now <= d.gameEnd);\r\n        _;\r\n    }\r\n\r\n    modifier beforePointGame(){\r\n        refreshGameTime();\r\n        _;\r\n    }\r\n\r\n    function process(address sender, uint sendValue) onlyOwner {\r\n        if(c.gameType == GameType.Range){\r\n            RangeGameProcess(sender, sendValue);\r\n        }else if(c.gameType == GameType.Point){\r\n            PointGameProcess(sender, sendValue);\r\n        }\r\n    }\r\n\r\n    function processWithITG(address sender, uint tokenAmountToGame) onlyOwner {\r\n        if(c.gameType == GameType.Range){\r\n            RangeGameWithITG(sender, tokenAmountToGame);\r\n        }else if(c.gameType == GameType.Point){\r\n            PointGameWithITG(sender, tokenAmountToGame);\r\n        }\r\n    }\r\n\r\n    // Range Game\r\n    function RangeGameProcess(address sender, uint sendValue) private beforeRangeGame {\r\n        if(c.currentGameTimeType == GameTime.Year){\r\n            c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue);\r\n            f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Month){\r\n            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\r\n            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }\r\n        participants.push(Participant(sender,sendValue,1));\r\n        if(p.bonusPerEth != 0){\r\n            tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth);\r\n            tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth);\r\n        }\r\n    }\r\n\r\n    function RangeGameWithITG(address sender, uint tokenAmountToGame) private beforeRangeGame {\r\n        require(c.currentGameTimeType != GameTime.Year);\r\n\r\n        if(c.currentGameTimeType == GameTime.Month){\r\n            f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\r\n        }\r\n        participants.push(Participant(sender,tokenAmountToGame,2));\r\n    }\r\n\r\n    function getTimeRangeInfo() private returns (GameTime, uint, uint, uint) {\r\n        uint nextTimeStamp;\r\n        uint nextYear;\r\n        uint nextMonth;\r\n        uint basis;\r\n        if(c.gameType == GameType.Range){\r\n            nextTimeStamp = now + r.inTimeRange_Y * 1 minutes + 1 hours;\r\n            nextYear = getYear(nextTimeStamp);\r\n            if(getYear(now - r.inTimeRange_Y * 1 minutes + 1 hours) != nextYear){\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days);    //Time range limit is less than 12 hours\r\n                return (GameTime.Year, nextYear, basis - r.inTimeRange_Y * 1 minutes, basis + r.inTimeRange_Y * 1 minutes);\r\n            }\r\n            nextTimeStamp = now + r.inTimeRange_M * 1 minutes + 1 hours;\r\n            nextMonth = getMonth(nextTimeStamp);\r\n            if(getMonth(now - r.inTimeRange_M * 1 minutes + 1 hours) != nextMonth){\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days); \r\n                return (GameTime.Month, nextYear, basis - r.inTimeRange_M * 1 minutes, basis + r.inTimeRange_M * 1 minutes);\r\n            }\r\n            nextTimeStamp = now + r.inTimeRange_H * 1 minutes + 1 hours;\r\n            basis = nextTimeStamp - (nextTimeStamp % 1 hours); \r\n            return (GameTime.Hour, nextYear, basis - r.inTimeRange_H * 1 minutes, basis + r.inTimeRange_H * 1 minutes);\r\n        }else if(c.gameType == GameType.Point){\r\n            nextTimeStamp = now - (now % 1 hours) + 1 hours;\r\n            nextYear = getYear(nextTimeStamp);\r\n            if(getYear(now) != nextYear){\r\n                return (GameTime.Year, nextYear, 0, nextTimeStamp);\r\n            }\r\n            nextMonth = getMonth(nextTimeStamp);\r\n            if(getMonth(now) != nextMonth){\r\n                return (GameTime.Month, nextYear, 0, nextTimeStamp);\r\n            }\r\n            return (GameTime.Hour, nextYear, 0, nextTimeStamp);\r\n        }\r\n    }\r\n\r\n    function refreshGameTime() private {\r\n        (c.currentGameTimeType, d.currentYear, d.gameStart, d.gameEnd) = getTimeRangeInfo();\r\n    }\r\n\r\n    // Garbage Collect previous funded amount record and log the status\r\n    function gcFundAmount() private {\r\n        f.hourlyStatusEth = 0;\r\n        f.monthlyStatusEth = 0;\r\n        f.yearlyStatusEth = 0;\r\n\r\n        f.hourlyStatusTok = 0;\r\n        f.monthlyStatusTok = 0;\r\n    }\r\n\r\n    function selectWinner(uint rand) onlyOwner {\r\n        uint luckyNumber = participants.length * rand / 100000000;\r\n        uint rewardDiv100 = 0;\r\n\r\n        uint participateRatio = participants.length;\r\n        if(participateRatio != 0){\r\n            if(c.currentGameTimeType == GameTime.Year){\r\n                participateRatio = participateRatio > p.yearlyMinParticipateRatio?participateRatio:p.yearlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Month){\r\n                participateRatio = participateRatio > p.monthlyMinParticipateRatio?participateRatio:p.monthlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                participateRatio = participateRatio > p.hourlyMinParticipateRatio?participateRatio:p.hourlyMinParticipateRatio;\r\n            }\r\n\r\n            if(participants[luckyNumber].currency == 1){\r\n                rewardDiv100 = participants[luckyNumber].value * participateRatio * p.boostPrizeEth / 100 / 100;\r\n                if(p.currentInGameTokWinRatio < p.inGameTokWinRatioMax){\r\n                    p.currentInGameTokWinRatio++;\r\n                }\r\n            }else if(participants[luckyNumber].currency == 2){\r\n                rewardDiv100 = (participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100) * participateRatio / 100;\r\n                if(p.currentInGameTokWinRatio > p.inGameTokWinRatioMin){\r\n                    p.currentInGameTokWinRatio--;\r\n                }\r\n            }\r\n\r\n            if(c.currentGameTimeType == GameTime.Year){\r\n                if(c.yearlyAmountEth >= rewardDiv100*104){  //1.04\r\n                    c.yearlyAmountEth = sub(c.yearlyAmountEth, rewardDiv100*104);\r\n                }else{\r\n                    rewardDiv100 = c.yearlyAmountEth / 104;\r\n                    c.yearlyAmountEth = 0;\r\n                }\r\n            }else if(c.currentGameTimeType == GameTime.Month){\r\n                if(c.monthlyAmountEth >= rewardDiv100*107){    //1.07\r\n                    c.monthlyAmountEth = sub(c.monthlyAmountEth, rewardDiv100*107);\r\n                }else{\r\n                    rewardDiv100 = c.monthlyAmountEth / 107;\r\n                    c.monthlyAmountEth = 0;\r\n                }\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3); //0.03, 1.1\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                if(c.hourlyAmountEth >= rewardDiv100*110){\r\n                    c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110);\r\n                }else{\r\n                    rewardDiv100 = c.hourlyAmountEth / 110;\r\n                    c.hourlyAmountEth = 0;\r\n                }\r\n                c.monthlyAmountEth = add(c.monthlyAmountEth,rewardDiv100 * 3);\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3);\r\n            }\r\n            c.charityAmountEth = add(c.charityAmountEth,rewardDiv100 * 4);\r\n\r\n            winners[d.currentYear][participants[luckyNumber].sender] = add(winners[d.currentYear][participants[luckyNumber].sender],rewardDiv100*100);\r\n            winPrizes[d.currentYear] = add(winPrizes[d.currentYear],rewardDiv100*100);\r\n        \r\n            LogSelectWinner(rand, luckyNumber, participants[luckyNumber].sender, rewardDiv100*100, participants[luckyNumber].currency, participants[luckyNumber].value);\r\n\r\n            // Initialize participants\r\n            participants.length = 0;\r\n        }\r\n        if(c.gameType == GameType.Range){\r\n            refreshGameTime();\r\n        }\r\n        gcFundAmount();    \r\n    }\r\n\r\n    //claimAll\r\n    function getPrize(address sender) onlyOwner returns (uint ethPrize, uint tokPrize) {\r\n        ethPrize = add(winners[d.currentYear][sender],winners[d.currentYear-1][sender]);\r\n        tokPrize = add(tokTakers[d.currentYear][sender],tokTakers[d.currentYear-1][sender]);\r\n\r\n        winPrizes[d.currentYear] = sub(winPrizes[d.currentYear],winners[d.currentYear][sender]);\r\n        tokPrizes[d.currentYear] = sub(tokPrizes[d.currentYear],tokTakers[d.currentYear][sender]);\r\n        winners[d.currentYear][sender] = 0;\r\n        tokTakers[d.currentYear][sender] = 0;\r\n\r\n        winPrizes[d.currentYear-1] = sub(winPrizes[d.currentYear-1],winners[d.currentYear-1][sender]);\r\n        tokPrizes[d.currentYear-1] = sub(tokPrizes[d.currentYear-1],tokTakers[d.currentYear-1][sender]);\r\n        winners[d.currentYear-1][sender] = 0;\r\n        tokTakers[d.currentYear-1][sender] = 0;\r\n    }\r\n\r\n    // Point Game\r\n    function PointGameProcess(address sender, uint sendValue) private beforePointGame {\r\n        if(c.currentGameTimeType == GameTime.Year){\r\n            c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue);\r\n            f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Month){\r\n            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\r\n            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }\r\n\r\n        PointGameParticipate(sender, sendValue, 1);\r\n        \r\n        if(p.bonusPerEth != 0){\r\n            tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth);\r\n            tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth);\r\n        }\r\n    }\r\n\r\n    function PointGameWithITG(address sender, uint tokenAmountToGame) private beforePointGame {\r\n        require(c.currentGameTimeType != GameTime.Year);\r\n\r\n        if(c.currentGameTimeType == GameTime.Month){\r\n            f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\r\n        }\r\n\r\n        PointGameParticipate(sender, tokenAmountToGame, 2);\r\n    }\r\n\r\n    function PointGameParticipate(address sender, uint sendValue, uint currency) private {\r\n        if(d.prevGameEnd != d.gameEnd){\r\n            selectWinner(1);\r\n        }\r\n        participants.length = 0;\r\n        participants.push(Participant(sender,sendValue,currency));\r\n\r\n        d.prevGameEnd = d.gameEnd;\r\n    }\r\n\r\n    function lossToCharity(uint year) onlyOwner returns (uint amt) {\r\n        require(year < d.currentYear-1);\r\n        \r\n        amt = winPrizes[year];\r\n        tokPrizes[year] = 0;\r\n        winPrizes[year] = 0;\r\n    }\r\n\r\n    function charityAmtToCharity() onlyOwner returns (uint amt) {\r\n        amt = c.charityAmountEth;\r\n        c.charityAmountEth = 0;\r\n    }\r\n\r\n    function distributeTokenSale(uint hour, uint month, uint year, uint charity) onlyOwner{\r\n        c.hourlyAmountEth = add(c.hourlyAmountEth, hour);\r\n        c.monthlyAmountEth = add(c.monthlyAmountEth, month);\r\n        c.yearlyAmountEth = add(c.yearlyAmountEth, year);\r\n        c.charityAmountEth = add(c.charityAmountEth, charity);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  InheritanceSpecifier
     Gas costs: 0
     Source: "DateTime"
    UserDefinedTypeName "DateTime"
       Source: "DateTime"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Authable"
    UserDefinedTypeName "Authable"
       Source: "Authable"
  EnumDefinition "GameTime"
    EnumValue "Hour"
    EnumValue "Month"
    EnumValue "Year"
    EnumValue "OutOfTime"
  EnumDefinition "GameType"
    EnumValue "Range"
    EnumValue "Point"
  StructDefinition "Participant"
     Gas costs: 0
     Source: "struct Participant {\r\n        address sender;\r\n        uint value;\r\n        uint currency; // 1 : Eth, 2 : Tok\r\n    }"
    VariableDeclaration "sender"
       Type: address
       Source: "address sender"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "value"
       Type: uint256
       Source: "uint value"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "currency"
       Type: uint256
       Source: "uint currency"
      ElementaryTypeName uint
         Source: "uint"
  StructDefinition "DateAttr"
     Gas costs: 0
     Source: "struct DateAttr{\r\n        uint currentYear;\r\n        uint gameStart; //Only for Range Game\r\n        uint gameEnd;   //For both Range Game and point Game(=intime timestamp)\r\n        uint prevGameEnd; //Only for Point Game\r\n    }"
    VariableDeclaration "currentYear"
       Type: uint256
       Source: "uint currentYear"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "gameStart"
       Type: uint256
       Source: "uint gameStart"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "gameEnd"
       Type: uint256
       Source: "uint gameEnd"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "prevGameEnd"
       Type: uint256
       Source: "uint prevGameEnd"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "d"
     Type: struct Games.DateAttr storage ref
     Gas costs: 0
     Source: "DateAttr public d"
    UserDefinedTypeName "DateAttr"
       Source: "DateAttr"
  StructDefinition "CommonAttr"
     Gas costs: 0
     Source: "struct CommonAttr{\r\n        GameTime currentGameTimeType;      // Current Game time type\r\n        GameType gameType;\r\n\r\n        uint hourlyAmountEth;  // Funded Eth amount\r\n        uint monthlyAmountEth;\r\n        uint yearlyAmountEth;\r\n        uint charityAmountEth;\r\n\r\n    }"
    VariableDeclaration "currentGameTimeType"
       Type: enum Games.GameTime
       Source: "GameTime currentGameTimeType"
      UserDefinedTypeName "GameTime"
         Source: "GameTime"
    VariableDeclaration "gameType"
       Type: enum Games.GameType
       Source: "GameType gameType"
      UserDefinedTypeName "GameType"
         Source: "GameType"
    VariableDeclaration "hourlyAmountEth"
       Type: uint256
       Source: "uint hourlyAmountEth"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "monthlyAmountEth"
       Type: uint256
       Source: "uint monthlyAmountEth"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "yearlyAmountEth"
       Type: uint256
       Source: "uint yearlyAmountEth"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "charityAmountEth"
       Type: uint256
       Source: "uint charityAmountEth"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "c"
     Type: struct Games.CommonAttr storage ref
     Gas costs: 0
     Source: "CommonAttr public c"
    UserDefinedTypeName "CommonAttr"
       Source: "CommonAttr"
  StructDefinition "FundAmountStatusAttr"
     Gas costs: 0
     Source: "struct FundAmountStatusAttr{\r\n        uint hourlyStatusEth;  // Funded Eth amount in current game time\r\n        uint monthlyStatusEth;\r\n        uint yearlyStatusEth;\r\n\r\n        uint hourlyStatusTok;  // Funded Token amount in current game time\r\n        uint monthlyStatusTok;\r\n    }"
    VariableDeclaration "hourlyStatusEth"
       Type: uint256
       Source: "uint hourlyStatusEth"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "monthlyStatusEth"
       Type: uint256
       Source: "uint monthlyStatusEth"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "yearlyStatusEth"
       Type: uint256
       Source: "uint yearlyStatusEth"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "hourlyStatusTok"
       Type: uint256
       Source: "uint hourlyStatusTok"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "monthlyStatusTok"
       Type: uint256
       Source: "uint monthlyStatusTok"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "f"
     Type: struct Games.FundAmountStatusAttr storage ref
     Gas costs: 0
     Source: "FundAmountStatusAttr public f"
    UserDefinedTypeName "FundAmountStatusAttr"
       Source: "FundAmountStatusAttr"
  StructDefinition "PriceAttr"
     Gas costs: 0
     Source: "struct PriceAttr{\r\n        uint bonusPerEth;   // If you not won, xx token to 1 Eth will be rewarded\r\n\r\n        uint inGameTokPricePerEth;   // Regard xx token to 1 Eth for token participants\r\n        uint inGameTokWinRatioMax;   // 100 means 100%. Disadventage against Eth. Change prize ratio like 25~50%\r\n        uint inGameTokWinRatioMin;\r\n        uint currentInGameTokWinRatio;  // Current token winners prize ratio\r\n\r\n        uint hourlyMinParticipateRatio;     // If participants.length are less than 100, x100 would be min prize ratio\r\n        uint monthlyMinParticipateRatio;    // If participants.length are less than 300, x300 would be min prize ratio\r\n        uint yearlyMinParticipateRatio;     // If participants.length are less than 1000, x1000 would be min prize ratio\r\n\r\n        uint boostPrizeEth;    // Boosts prize amount. Default is 100 and it means 100%\r\n    }"
    VariableDeclaration "bonusPerEth"
       Type: uint256
       Source: "uint bonusPerEth"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "inGameTokPricePerEth"
       Type: uint256
       Source: "uint inGameTokPricePerEth"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "inGameTokWinRatioMax"
       Type: uint256
       Source: "uint inGameTokWinRatioMax"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "inGameTokWinRatioMin"
       Type: uint256
       Source: "uint inGameTokWinRatioMin"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "currentInGameTokWinRatio"
       Type: uint256
       Source: "uint currentInGameTokWinRatio"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "hourlyMinParticipateRatio"
       Type: uint256
       Source: "uint hourlyMinParticipateRatio"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "monthlyMinParticipateRatio"
       Type: uint256
       Source: "uint monthlyMinParticipateRatio"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "yearlyMinParticipateRatio"
       Type: uint256
       Source: "uint yearlyMinParticipateRatio"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "boostPrizeEth"
       Type: uint256
       Source: "uint boostPrizeEth"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "p"
     Type: struct Games.PriceAttr storage ref
     Gas costs: 0
     Source: "PriceAttr public p"
    UserDefinedTypeName "PriceAttr"
       Source: "PriceAttr"
  StructDefinition "RangeGameAttr"
     Gas costs: 0
     Source: "struct RangeGameAttr{\r\n        uint inTimeRange_H; // 10 means +-10 mins in time\r\n        uint inTimeRange_M;\r\n        uint inTimeRange_Y;\r\n    }"
    VariableDeclaration "inTimeRange_H"
       Type: uint256
       Source: "uint inTimeRange_H"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "inTimeRange_M"
       Type: uint256
       Source: "uint inTimeRange_M"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "inTimeRange_Y"
       Type: uint256
       Source: "uint inTimeRange_Y"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "r"
     Type: struct Games.RangeGameAttr storage ref
     Gas costs: 0
     Source: "RangeGameAttr public r"
    UserDefinedTypeName "RangeGameAttr"
       Source: "RangeGameAttr"
  VariableDeclaration "participants"
     Type: struct Games.Participant storage ref[] storage ref
     Gas costs: 0
     Source: "Participant[] public participants"
    ArrayTypeName
       Source: "Participant[]"
      UserDefinedTypeName "Participant"
         Source: "Participant"
  VariableDeclaration "winners"
     Type: mapping(uint256 => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping(uint256 => mapping(address => uint256)) public winners"
    Mapping
       Source: "mapping(uint256 => mapping(address => uint256))"
      ElementaryTypeName uint256
         Source: "uint256"
      Mapping
         Source: "mapping(address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "tokTakers"
     Type: mapping(uint256 => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping(uint256 => mapping(address => uint256)) public tokTakers"
    Mapping
       Source: "mapping(uint256 => mapping(address => uint256))"
      ElementaryTypeName uint256
         Source: "uint256"
      Mapping
         Source: "mapping(address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "winPrizes"
     Type: mapping(uint256 => uint256)
     Gas costs: 0
     Source: "mapping(uint256 => uint256) public winPrizes"
    Mapping
       Source: "mapping(uint256 => uint256)"
      ElementaryTypeName uint256
         Source: "uint256"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "tokPrizes"
     Type: mapping(uint256 => uint256)
     Gas costs: 0
     Source: "mapping(uint256 => uint256) public tokPrizes"
    Mapping
       Source: "mapping(uint256 => uint256)"
      ElementaryTypeName uint256
         Source: "uint256"
      ElementaryTypeName uint256
         Source: "uint256"
  EventDefinition "LogSelectWinner"
     Gas costs: 0
     Source: "event LogSelectWinner(uint rand, uint luckyNumber, address sender, uint reward, uint currency, uint amount);"
    ParameterList
       Source: "(uint rand, uint luckyNumber, address sender, uint reward, uint currency, uint amount)"
      VariableDeclaration "rand"
         Type: uint256
         Source: "uint rand"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "luckyNumber"
         Type: uint256
         Source: "uint luckyNumber"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "reward"
         Type: uint256
         Source: "uint reward"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "currency"
         Type: uint256
         Source: "uint currency"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "setPriceAttr" - public
     Source: "function setPriceAttr(\r\n            GameType _gameType, uint _bonusPerEth, uint _inGameTokPricePerEth\r\n            , uint _inGameTokWinRatioMax, uint _inGameTokWinRatioMin, uint _currentInGameTokWinRatio\r\n            , uint _hourlyMinParticipateRatio, uint _monthlyMinParticipateRatio, uint _yearlyMinParticipateRatio, uint _boostPrizeEth\r\n        ) onlyAuth {\r\n        c.gameType = _gameType;\r\n\r\n        p.bonusPerEth = _bonusPerEth;   //300   // Depends on crowdSale average price. Vote needed, but we assume AVG/4 is reasonable.\r\n        p.inGameTokPricePerEth = _inGameTokPricePerEth; //300   // Regard xx token to 1 Eth for token participants. Depends on crowdSale, too.\r\n        p.inGameTokWinRatioMax = _inGameTokWinRatioMax; //50    // 100 means 100%. Disadventage against Eth. Change prize ratio like 25~50%\r\n        p.inGameTokWinRatioMin = _inGameTokWinRatioMin; //25\r\n        p.currentInGameTokWinRatio = _currentInGameTokWinRatio;    //50\r\n        p.hourlyMinParticipateRatio = _hourlyMinParticipateRatio;   //100   // If participants.length are less than 100, x100 would be min prize ratio\r\n        p.monthlyMinParticipateRatio = _monthlyMinParticipateRatio; //300\r\n        p.yearlyMinParticipateRatio = _yearlyMinParticipateRatio;   //1000\r\n        p.boostPrizeEth = _boostPrizeEth;   //100\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n            GameType _gameType, uint _bonusPerEth, uint _inGameTokPricePerEth\r\n            , uint _inGameTokWinRatioMax, uint _inGameTokWinRatioMin, uint _currentInGameTokWinRatio\r\n            , uint _hourlyMinParticipateRatio, uint _monthlyMinParticipateRatio, uint _yearlyMinParticipateRatio, uint _boostPrizeEth\r\n        )"
      VariableDeclaration "_gameType"
         Type: enum Games.GameType
         Source: "GameType _gameType"
        UserDefinedTypeName "GameType"
           Source: "GameType"
      VariableDeclaration "_bonusPerEth"
         Type: uint256
         Source: "uint _bonusPerEth"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_inGameTokPricePerEth"
         Type: uint256
         Source: "uint _inGameTokPricePerEth"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_inGameTokWinRatioMax"
         Type: uint256
         Source: "uint _inGameTokWinRatioMax"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_inGameTokWinRatioMin"
         Type: uint256
         Source: "uint _inGameTokWinRatioMin"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_currentInGameTokWinRatio"
         Type: uint256
         Source: "uint _currentInGameTokWinRatio"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_hourlyMinParticipateRatio"
         Type: uint256
         Source: "uint _hourlyMinParticipateRatio"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_monthlyMinParticipateRatio"
         Type: uint256
         Source: "uint _monthlyMinParticipateRatio"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_yearlyMinParticipateRatio"
         Type: uint256
         Source: "uint _yearlyMinParticipateRatio"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_boostPrizeEth"
         Type: uint256
         Source: "uint _boostPrizeEth"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAuth"
       Gas costs: 0
       Source: "onlyAuth"
      Identifier onlyAuth
         Type: modifier ()
         Source: "onlyAuth"
    Block
       Source: "{\r\n        c.gameType = _gameType;\r\n\r\n        p.bonusPerEth = _bonusPerEth;   //300   // Depends on crowdSale average price. Vote needed, but we assume AVG/4 is reasonable.\r\n        p.inGameTokPricePerEth = _inGameTokPricePerEth; //300   // Regard xx token to 1 Eth for token participants. Depends on crowdSale, too.\r\n        p.inGameTokWinRatioMax = _inGameTokWinRatioMax; //50    // 100 means 100%. Disadventage against Eth. Change prize ratio like 25~50%\r\n        p.inGameTokWinRatioMin = _inGameTokWinRatioMin; //25\r\n        p.currentInGameTokWinRatio = _currentInGameTokWinRatio;    //50\r\n        p.hourlyMinParticipateRatio = _hourlyMinParticipateRatio;   //100   // If participants.length are less than 100, x100 would be min prize ratio\r\n        p.monthlyMinParticipateRatio = _monthlyMinParticipateRatio; //300\r\n        p.yearlyMinParticipateRatio = _yearlyMinParticipateRatio;   //1000\r\n        p.boostPrizeEth = _boostPrizeEth;   //100\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "c.gameType = _gameType"
        Assignment using operator =
           Type: enum Games.GameType
           Source: "c.gameType = _gameType"
          MemberAccess to member gameType
             Type: enum Games.GameType
             Source: "c.gameType"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
          Identifier _gameType
             Type: enum Games.GameType
             Source: "_gameType"
      ExpressionStatement
         Gas costs: 0
         Source: "p.bonusPerEth = _bonusPerEth"
        Assignment using operator =
           Type: uint256
           Source: "p.bonusPerEth = _bonusPerEth"
          MemberAccess to member bonusPerEth
             Type: uint256
             Source: "p.bonusPerEth"
            Identifier p
               Type: struct Games.PriceAttr storage ref
               Source: "p"
          Identifier _bonusPerEth
             Type: uint256
             Source: "_bonusPerEth"
      ExpressionStatement
         Gas costs: 0
         Source: "p.inGameTokPricePerEth = _inGameTokPricePerEth"
        Assignment using operator =
           Type: uint256
           Source: "p.inGameTokPricePerEth = _inGameTokPricePerEth"
          MemberAccess to member inGameTokPricePerEth
             Type: uint256
             Source: "p.inGameTokPricePerEth"
            Identifier p
               Type: struct Games.PriceAttr storage ref
               Source: "p"
          Identifier _inGameTokPricePerEth
             Type: uint256
             Source: "_inGameTokPricePerEth"
      ExpressionStatement
         Gas costs: 0
         Source: "p.inGameTokWinRatioMax = _inGameTokWinRatioMax"
        Assignment using operator =
           Type: uint256
           Source: "p.inGameTokWinRatioMax = _inGameTokWinRatioMax"
          MemberAccess to member inGameTokWinRatioMax
             Type: uint256
             Source: "p.inGameTokWinRatioMax"
            Identifier p
               Type: struct Games.PriceAttr storage ref
               Source: "p"
          Identifier _inGameTokWinRatioMax
             Type: uint256
             Source: "_inGameTokWinRatioMax"
      ExpressionStatement
         Gas costs: 0
         Source: "p.inGameTokWinRatioMin = _inGameTokWinRatioMin"
        Assignment using operator =
           Type: uint256
           Source: "p.inGameTokWinRatioMin = _inGameTokWinRatioMin"
          MemberAccess to member inGameTokWinRatioMin
             Type: uint256
             Source: "p.inGameTokWinRatioMin"
            Identifier p
               Type: struct Games.PriceAttr storage ref
               Source: "p"
          Identifier _inGameTokWinRatioMin
             Type: uint256
             Source: "_inGameTokWinRatioMin"
      ExpressionStatement
         Gas costs: 0
         Source: "p.currentInGameTokWinRatio = _currentInGameTokWinRatio"
        Assignment using operator =
           Type: uint256
           Source: "p.currentInGameTokWinRatio = _currentInGameTokWinRatio"
          MemberAccess to member currentInGameTokWinRatio
             Type: uint256
             Source: "p.currentInGameTokWinRatio"
            Identifier p
               Type: struct Games.PriceAttr storage ref
               Source: "p"
          Identifier _currentInGameTokWinRatio
             Type: uint256
             Source: "_currentInGameTokWinRatio"
      ExpressionStatement
         Gas costs: 0
         Source: "p.hourlyMinParticipateRatio = _hourlyMinParticipateRatio"
        Assignment using operator =
           Type: uint256
           Source: "p.hourlyMinParticipateRatio = _hourlyMinParticipateRatio"
          MemberAccess to member hourlyMinParticipateRatio
             Type: uint256
             Source: "p.hourlyMinParticipateRatio"
            Identifier p
               Type: struct Games.PriceAttr storage ref
               Source: "p"
          Identifier _hourlyMinParticipateRatio
             Type: uint256
             Source: "_hourlyMinParticipateRatio"
      ExpressionStatement
         Gas costs: 0
         Source: "p.monthlyMinParticipateRatio = _monthlyMinParticipateRatio"
        Assignment using operator =
           Type: uint256
           Source: "p.monthlyMinParticipateRatio = _monthlyMinParticipateRatio"
          MemberAccess to member monthlyMinParticipateRatio
             Type: uint256
             Source: "p.monthlyMinParticipateRatio"
            Identifier p
               Type: struct Games.PriceAttr storage ref
               Source: "p"
          Identifier _monthlyMinParticipateRatio
             Type: uint256
             Source: "_monthlyMinParticipateRatio"
      ExpressionStatement
         Gas costs: 0
         Source: "p.yearlyMinParticipateRatio = _yearlyMinParticipateRatio"
        Assignment using operator =
           Type: uint256
           Source: "p.yearlyMinParticipateRatio = _yearlyMinParticipateRatio"
          MemberAccess to member yearlyMinParticipateRatio
             Type: uint256
             Source: "p.yearlyMinParticipateRatio"
            Identifier p
               Type: struct Games.PriceAttr storage ref
               Source: "p"
          Identifier _yearlyMinParticipateRatio
             Type: uint256
             Source: "_yearlyMinParticipateRatio"
      ExpressionStatement
         Gas costs: 0
         Source: "p.boostPrizeEth = _boostPrizeEth"
        Assignment using operator =
           Type: uint256
           Source: "p.boostPrizeEth = _boostPrizeEth"
          MemberAccess to member boostPrizeEth
             Type: uint256
             Source: "p.boostPrizeEth"
            Identifier p
               Type: struct Games.PriceAttr storage ref
               Source: "p"
          Identifier _boostPrizeEth
             Type: uint256
             Source: "_boostPrizeEth"
  FunctionDefinition "setRangeGameAttr" - public
     Source: "function setRangeGameAttr(uint _inTimeRange_H, uint _inTimeRange_M, uint _inTimeRange_Y) onlyAuth {\r\n        r.inTimeRange_H = _inTimeRange_H;   //10       // 10 mean +-10 mins in time\r\n        r.inTimeRange_M = _inTimeRange_M;   //190 = 3 * 60 + r.inTimeRange_H\r\n        r.inTimeRange_Y = _inTimeRange_Y;   //370 = 6 * 60 + r.inTimeRange_H\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _inTimeRange_H, uint _inTimeRange_M, uint _inTimeRange_Y)"
      VariableDeclaration "_inTimeRange_H"
         Type: uint256
         Source: "uint _inTimeRange_H"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_inTimeRange_M"
         Type: uint256
         Source: "uint _inTimeRange_M"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_inTimeRange_Y"
         Type: uint256
         Source: "uint _inTimeRange_Y"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAuth"
       Gas costs: 0
       Source: "onlyAuth"
      Identifier onlyAuth
         Type: modifier ()
         Source: "onlyAuth"
    Block
       Source: "{\r\n        r.inTimeRange_H = _inTimeRange_H;   //10       // 10 mean +-10 mins in time\r\n        r.inTimeRange_M = _inTimeRange_M;   //190 = 3 * 60 + r.inTimeRange_H\r\n        r.inTimeRange_Y = _inTimeRange_Y;   //370 = 6 * 60 + r.inTimeRange_H\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "r.inTimeRange_H = _inTimeRange_H"
        Assignment using operator =
           Type: uint256
           Source: "r.inTimeRange_H = _inTimeRange_H"
          MemberAccess to member inTimeRange_H
             Type: uint256
             Source: "r.inTimeRange_H"
            Identifier r
               Type: struct Games.RangeGameAttr storage ref
               Source: "r"
          Identifier _inTimeRange_H
             Type: uint256
             Source: "_inTimeRange_H"
      ExpressionStatement
         Gas costs: 0
         Source: "r.inTimeRange_M = _inTimeRange_M"
        Assignment using operator =
           Type: uint256
           Source: "r.inTimeRange_M = _inTimeRange_M"
          MemberAccess to member inTimeRange_M
             Type: uint256
             Source: "r.inTimeRange_M"
            Identifier r
               Type: struct Games.RangeGameAttr storage ref
               Source: "r"
          Identifier _inTimeRange_M
             Type: uint256
             Source: "_inTimeRange_M"
      ExpressionStatement
         Gas costs: 0
         Source: "r.inTimeRange_Y = _inTimeRange_Y"
        Assignment using operator =
           Type: uint256
           Source: "r.inTimeRange_Y = _inTimeRange_Y"
          MemberAccess to member inTimeRange_Y
             Type: uint256
             Source: "r.inTimeRange_Y"
            Identifier r
               Type: struct Games.RangeGameAttr storage ref
               Source: "r"
          Identifier _inTimeRange_Y
             Type: uint256
             Source: "_inTimeRange_Y"
  ModifierDefinition "beforeRangeGame"
     Source: "modifier beforeRangeGame(){\r\n        require(now > d.gameStart && now <= d.gameEnd);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(now > d.gameStart && now <= d.gameEnd);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(now > d.gameStart && now <= d.gameEnd)"
        FunctionCall
           Type: tuple()
           Source: "require(now > d.gameStart && now <= d.gameEnd)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "now > d.gameStart && now <= d.gameEnd"
            BinaryOperation using operator >
               Type: bool
               Source: "now > d.gameStart"
              Identifier now
                 Type: uint256
                 Source: "now"
              MemberAccess to member gameStart
                 Type: uint256
                 Source: "d.gameStart"
                Identifier d
                   Type: struct Games.DateAttr storage ref
                   Source: "d"
            BinaryOperation using operator <=
               Type: bool
               Source: "now <= d.gameEnd"
              Identifier now
                 Type: uint256
                 Source: "now"
              MemberAccess to member gameEnd
                 Type: uint256
                 Source: "d.gameEnd"
                Identifier d
                   Type: struct Games.DateAttr storage ref
                   Source: "d"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "beforePointGame"
     Source: "modifier beforePointGame(){\r\n        refreshGameTime();\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        refreshGameTime();\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "refreshGameTime()"
        FunctionCall
           Type: tuple()
           Source: "refreshGameTime()"
          Identifier refreshGameTime
             Type: function ()
             Source: "refreshGameTime"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "process" - public
     Source: "function process(address sender, uint sendValue) onlyOwner {\r\n        if(c.gameType == GameType.Range){\r\n            RangeGameProcess(sender, sendValue);\r\n        }else if(c.gameType == GameType.Point){\r\n            PointGameProcess(sender, sendValue);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address sender, uint sendValue)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "sendValue"
         Type: uint256
         Source: "uint sendValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        if(c.gameType == GameType.Range){\r\n            RangeGameProcess(sender, sendValue);\r\n        }else if(c.gameType == GameType.Point){\r\n            PointGameProcess(sender, sendValue);\r\n        }\r\n    }"
      IfStatement
         Source: "if(c.gameType == GameType.Range){\r\n            RangeGameProcess(sender, sendValue);\r\n        }else if(c.gameType == GameType.Point){\r\n            PointGameProcess(sender, sendValue);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "c.gameType == GameType.Range"
          MemberAccess to member gameType
             Type: enum Games.GameType
             Source: "c.gameType"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
          MemberAccess to member Range
             Type: enum Games.GameType
             Source: "GameType.Range"
            Identifier GameType
               Type: type(enum Games.GameType)
               Source: "GameType"
        Block
           Source: "{\r\n            RangeGameProcess(sender, sendValue);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "RangeGameProcess(sender, sendValue)"
            FunctionCall
               Type: tuple()
               Source: "RangeGameProcess(sender, sendValue)"
              Identifier RangeGameProcess
                 Type: function (address,uint256)
                 Source: "RangeGameProcess"
              Identifier sender
                 Type: address
                 Source: "sender"
              Identifier sendValue
                 Type: uint256
                 Source: "sendValue"
        IfStatement
           Source: "if(c.gameType == GameType.Point){\r\n            PointGameProcess(sender, sendValue);\r\n        }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 0
             Source: "c.gameType == GameType.Point"
            MemberAccess to member gameType
               Type: enum Games.GameType
               Source: "c.gameType"
              Identifier c
                 Type: struct Games.CommonAttr storage ref
                 Source: "c"
            MemberAccess to member Point
               Type: enum Games.GameType
               Source: "GameType.Point"
              Identifier GameType
                 Type: type(enum Games.GameType)
                 Source: "GameType"
          Block
             Source: "{\r\n            PointGameProcess(sender, sendValue);\r\n        }"
            ExpressionStatement
               Gas costs: 0
               Source: "PointGameProcess(sender, sendValue)"
              FunctionCall
                 Type: tuple()
                 Source: "PointGameProcess(sender, sendValue)"
                Identifier PointGameProcess
                   Type: function (address,uint256)
                   Source: "PointGameProcess"
                Identifier sender
                   Type: address
                   Source: "sender"
                Identifier sendValue
                   Type: uint256
                   Source: "sendValue"
  FunctionDefinition "processWithITG" - public
     Source: "function processWithITG(address sender, uint tokenAmountToGame) onlyOwner {\r\n        if(c.gameType == GameType.Range){\r\n            RangeGameWithITG(sender, tokenAmountToGame);\r\n        }else if(c.gameType == GameType.Point){\r\n            PointGameWithITG(sender, tokenAmountToGame);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address sender, uint tokenAmountToGame)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "tokenAmountToGame"
         Type: uint256
         Source: "uint tokenAmountToGame"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        if(c.gameType == GameType.Range){\r\n            RangeGameWithITG(sender, tokenAmountToGame);\r\n        }else if(c.gameType == GameType.Point){\r\n            PointGameWithITG(sender, tokenAmountToGame);\r\n        }\r\n    }"
      IfStatement
         Source: "if(c.gameType == GameType.Range){\r\n            RangeGameWithITG(sender, tokenAmountToGame);\r\n        }else if(c.gameType == GameType.Point){\r\n            PointGameWithITG(sender, tokenAmountToGame);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "c.gameType == GameType.Range"
          MemberAccess to member gameType
             Type: enum Games.GameType
             Source: "c.gameType"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
          MemberAccess to member Range
             Type: enum Games.GameType
             Source: "GameType.Range"
            Identifier GameType
               Type: type(enum Games.GameType)
               Source: "GameType"
        Block
           Source: "{\r\n            RangeGameWithITG(sender, tokenAmountToGame);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "RangeGameWithITG(sender, tokenAmountToGame)"
            FunctionCall
               Type: tuple()
               Source: "RangeGameWithITG(sender, tokenAmountToGame)"
              Identifier RangeGameWithITG
                 Type: function (address,uint256)
                 Source: "RangeGameWithITG"
              Identifier sender
                 Type: address
                 Source: "sender"
              Identifier tokenAmountToGame
                 Type: uint256
                 Source: "tokenAmountToGame"
        IfStatement
           Source: "if(c.gameType == GameType.Point){\r\n            PointGameWithITG(sender, tokenAmountToGame);\r\n        }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 0
             Source: "c.gameType == GameType.Point"
            MemberAccess to member gameType
               Type: enum Games.GameType
               Source: "c.gameType"
              Identifier c
                 Type: struct Games.CommonAttr storage ref
                 Source: "c"
            MemberAccess to member Point
               Type: enum Games.GameType
               Source: "GameType.Point"
              Identifier GameType
                 Type: type(enum Games.GameType)
                 Source: "GameType"
          Block
             Source: "{\r\n            PointGameWithITG(sender, tokenAmountToGame);\r\n        }"
            ExpressionStatement
               Gas costs: 0
               Source: "PointGameWithITG(sender, tokenAmountToGame)"
              FunctionCall
                 Type: tuple()
                 Source: "PointGameWithITG(sender, tokenAmountToGame)"
                Identifier PointGameWithITG
                   Type: function (address,uint256)
                   Source: "PointGameWithITG"
                Identifier sender
                   Type: address
                   Source: "sender"
                Identifier tokenAmountToGame
                   Type: uint256
                   Source: "tokenAmountToGame"
  FunctionDefinition "RangeGameProcess"
     Source: "function RangeGameProcess(address sender, uint sendValue) private beforeRangeGame {\r\n        if(c.currentGameTimeType == GameTime.Year){\r\n            c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue);\r\n            f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Month){\r\n            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\r\n            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }\r\n        participants.push(Participant(sender,sendValue,1));\r\n        if(p.bonusPerEth != 0){\r\n            tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth);\r\n            tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address sender, uint sendValue)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "sendValue"
         Type: uint256
         Source: "uint sendValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "beforeRangeGame"
       Gas costs: 0
       Source: "beforeRangeGame"
      Identifier beforeRangeGame
         Type: modifier ()
         Source: "beforeRangeGame"
    Block
       Source: "{\r\n        if(c.currentGameTimeType == GameTime.Year){\r\n            c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue);\r\n            f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Month){\r\n            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\r\n            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }\r\n        participants.push(Participant(sender,sendValue,1));\r\n        if(p.bonusPerEth != 0){\r\n            tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth);\r\n            tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth);\r\n        }\r\n    }"
      IfStatement
         Source: "if(c.currentGameTimeType == GameTime.Year){\r\n            c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue);\r\n            f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Month){\r\n            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\r\n            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "c.currentGameTimeType == GameTime.Year"
          MemberAccess to member currentGameTimeType
             Type: enum Games.GameTime
             Source: "c.currentGameTimeType"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
          MemberAccess to member Year
             Type: enum Games.GameTime
             Source: "GameTime.Year"
            Identifier GameTime
               Type: type(enum Games.GameTime)
               Source: "GameTime"
        Block
           Source: "{\r\n            c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue);\r\n            f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue)"
            Assignment using operator =
               Type: uint256
               Source: "c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue)"
              MemberAccess to member yearlyAmountEth
                 Type: uint256
                 Source: "c.yearlyAmountEth"
                Identifier c
                   Type: struct Games.CommonAttr storage ref
                   Source: "c"
              FunctionCall
                 Type: uint256
                 Source: "add(c.yearlyAmountEth, sendValue)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                MemberAccess to member yearlyAmountEth
                   Type: uint256
                   Source: "c.yearlyAmountEth"
                  Identifier c
                     Type: struct Games.CommonAttr storage ref
                     Source: "c"
                Identifier sendValue
                   Type: uint256
                   Source: "sendValue"
          ExpressionStatement
             Gas costs: 0
             Source: "f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue)"
            Assignment using operator =
               Type: uint256
               Source: "f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue)"
              MemberAccess to member yearlyStatusEth
                 Type: uint256
                 Source: "f.yearlyStatusEth"
                Identifier f
                   Type: struct Games.FundAmountStatusAttr storage ref
                   Source: "f"
              FunctionCall
                 Type: uint256
                 Source: "add(f.yearlyStatusEth, sendValue)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                MemberAccess to member yearlyStatusEth
                   Type: uint256
                   Source: "f.yearlyStatusEth"
                  Identifier f
                     Type: struct Games.FundAmountStatusAttr storage ref
                     Source: "f"
                Identifier sendValue
                   Type: uint256
                   Source: "sendValue"
        IfStatement
           Source: "if(c.currentGameTimeType == GameTime.Month){\r\n            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\r\n            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 0
             Source: "c.currentGameTimeType == GameTime.Month"
            MemberAccess to member currentGameTimeType
               Type: enum Games.GameTime
               Source: "c.currentGameTimeType"
              Identifier c
                 Type: struct Games.CommonAttr storage ref
                 Source: "c"
            MemberAccess to member Month
               Type: enum Games.GameTime
               Source: "GameTime.Month"
              Identifier GameTime
                 Type: type(enum Games.GameTime)
                 Source: "GameTime"
          Block
             Source: "{\r\n            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\r\n            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\r\n        }"
            ExpressionStatement
               Gas costs: 0
               Source: "c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue)"
              Assignment using operator =
                 Type: uint256
                 Source: "c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue)"
                MemberAccess to member monthlyAmountEth
                   Type: uint256
                   Source: "c.monthlyAmountEth"
                  Identifier c
                     Type: struct Games.CommonAttr storage ref
                     Source: "c"
                FunctionCall
                   Type: uint256
                   Source: "add(c.monthlyAmountEth, sendValue)"
                  Identifier add
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "add"
                  MemberAccess to member monthlyAmountEth
                     Type: uint256
                     Source: "c.monthlyAmountEth"
                    Identifier c
                       Type: struct Games.CommonAttr storage ref
                       Source: "c"
                  Identifier sendValue
                     Type: uint256
                     Source: "sendValue"
            ExpressionStatement
               Gas costs: 0
               Source: "f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue)"
              Assignment using operator =
                 Type: uint256
                 Source: "f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue)"
                MemberAccess to member monthlyStatusEth
                   Type: uint256
                   Source: "f.monthlyStatusEth"
                  Identifier f
                     Type: struct Games.FundAmountStatusAttr storage ref
                     Source: "f"
                FunctionCall
                   Type: uint256
                   Source: "add(f.monthlyStatusEth, sendValue)"
                  Identifier add
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "add"
                  MemberAccess to member monthlyStatusEth
                     Type: uint256
                     Source: "f.monthlyStatusEth"
                    Identifier f
                       Type: struct Games.FundAmountStatusAttr storage ref
                       Source: "f"
                  Identifier sendValue
                     Type: uint256
                     Source: "sendValue"
          IfStatement
             Source: "if(c.currentGameTimeType == GameTime.Hour){\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "c.currentGameTimeType == GameTime.Hour"
              MemberAccess to member currentGameTimeType
                 Type: enum Games.GameTime
                 Source: "c.currentGameTimeType"
                Identifier c
                   Type: struct Games.CommonAttr storage ref
                   Source: "c"
              MemberAccess to member Hour
                 Type: enum Games.GameTime
                 Source: "GameTime.Hour"
                Identifier GameTime
                   Type: type(enum Games.GameTime)
                   Source: "GameTime"
            Block
               Source: "{\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue)"
                Assignment using operator =
                   Type: uint256
                   Source: "c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue)"
                  MemberAccess to member hourlyAmountEth
                     Type: uint256
                     Source: "c.hourlyAmountEth"
                    Identifier c
                       Type: struct Games.CommonAttr storage ref
                       Source: "c"
                  FunctionCall
                     Type: uint256
                     Source: "add(c.hourlyAmountEth, sendValue)"
                    Identifier add
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "add"
                    MemberAccess to member hourlyAmountEth
                       Type: uint256
                       Source: "c.hourlyAmountEth"
                      Identifier c
                         Type: struct Games.CommonAttr storage ref
                         Source: "c"
                    Identifier sendValue
                       Type: uint256
                       Source: "sendValue"
              ExpressionStatement
                 Gas costs: 0
                 Source: "f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue)"
                Assignment using operator =
                   Type: uint256
                   Source: "f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue)"
                  MemberAccess to member hourlyStatusEth
                     Type: uint256
                     Source: "f.hourlyStatusEth"
                    Identifier f
                       Type: struct Games.FundAmountStatusAttr storage ref
                       Source: "f"
                  FunctionCall
                     Type: uint256
                     Source: "add(f.hourlyStatusEth, sendValue)"
                    Identifier add
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "add"
                    MemberAccess to member hourlyStatusEth
                       Type: uint256
                       Source: "f.hourlyStatusEth"
                      Identifier f
                         Type: struct Games.FundAmountStatusAttr storage ref
                         Source: "f"
                    Identifier sendValue
                       Type: uint256
                       Source: "sendValue"
      ExpressionStatement
         Gas costs: 0
         Source: "participants.push(Participant(sender,sendValue,1))"
        FunctionCall
           Type: uint256
           Source: "participants.push(Participant(sender,sendValue,1))"
          MemberAccess to member push
             Type: function (struct Games.Participant storage ref) returns (uint256)
             Source: "participants.push"
            Identifier participants
               Type: struct Games.Participant storage ref[] storage ref
               Source: "participants"
          FunctionCall
             Type: struct Games.Participant memory
             Source: "Participant(sender,sendValue,1)"
            Identifier Participant
               Type: type(struct Games.Participant storage pointer)
               Source: "Participant"
            Identifier sender
               Type: address
               Source: "sender"
            Identifier sendValue
               Type: uint256
               Source: "sendValue"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      IfStatement
         Source: "if(p.bonusPerEth != 0){\r\n            tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth);\r\n            tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth);\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "p.bonusPerEth != 0"
          MemberAccess to member bonusPerEth
             Type: uint256
             Source: "p.bonusPerEth"
            Identifier p
               Type: struct Games.PriceAttr storage ref
               Source: "p"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth);\r\n            tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth)"
            Assignment using operator =
               Type: uint256
               Source: "tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth)"
              IndexAccess
                 Type: uint256
                 Source: "tokTakers[d.currentYear][sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "tokTakers[d.currentYear]"
                  Identifier tokTakers
                     Type: mapping(uint256 => mapping(address => uint256))
                     Source: "tokTakers"
                  MemberAccess to member currentYear
                     Type: uint256
                     Source: "d.currentYear"
                    Identifier d
                       Type: struct Games.DateAttr storage ref
                       Source: "d"
                Identifier sender
                   Type: address
                   Source: "sender"
              FunctionCall
                 Type: uint256
                 Source: "add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                IndexAccess
                   Type: uint256
                   Source: "tokTakers[d.currentYear][sender]"
                  IndexAccess
                     Type: mapping(address => uint256)
                     Source: "tokTakers[d.currentYear]"
                    Identifier tokTakers
                       Type: mapping(uint256 => mapping(address => uint256))
                       Source: "tokTakers"
                    MemberAccess to member currentYear
                       Type: uint256
                       Source: "d.currentYear"
                      Identifier d
                         Type: struct Games.DateAttr storage ref
                         Source: "d"
                  Identifier sender
                     Type: address
                     Source: "sender"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "sendValue * p.bonusPerEth"
                  Identifier sendValue
                     Type: uint256
                     Source: "sendValue"
                  MemberAccess to member bonusPerEth
                     Type: uint256
                     Source: "p.bonusPerEth"
                    Identifier p
                       Type: struct Games.PriceAttr storage ref
                       Source: "p"
          ExpressionStatement
             Gas costs: 0
             Source: "tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth)"
            Assignment using operator =
               Type: uint256
               Source: "tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth)"
              IndexAccess
                 Type: uint256
                 Source: "tokPrizes[d.currentYear]"
                Identifier tokPrizes
                   Type: mapping(uint256 => uint256)
                   Source: "tokPrizes"
                MemberAccess to member currentYear
                   Type: uint256
                   Source: "d.currentYear"
                  Identifier d
                     Type: struct Games.DateAttr storage ref
                     Source: "d"
              FunctionCall
                 Type: uint256
                 Source: "add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                IndexAccess
                   Type: uint256
                   Source: "tokPrizes[d.currentYear]"
                  Identifier tokPrizes
                     Type: mapping(uint256 => uint256)
                     Source: "tokPrizes"
                  MemberAccess to member currentYear
                     Type: uint256
                     Source: "d.currentYear"
                    Identifier d
                       Type: struct Games.DateAttr storage ref
                       Source: "d"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "sendValue * p.bonusPerEth"
                  Identifier sendValue
                     Type: uint256
                     Source: "sendValue"
                  MemberAccess to member bonusPerEth
                     Type: uint256
                     Source: "p.bonusPerEth"
                    Identifier p
                       Type: struct Games.PriceAttr storage ref
                       Source: "p"
  FunctionDefinition "RangeGameWithITG"
     Source: "function RangeGameWithITG(address sender, uint tokenAmountToGame) private beforeRangeGame {\r\n        require(c.currentGameTimeType != GameTime.Year);\r\n\r\n        if(c.currentGameTimeType == GameTime.Month){\r\n            f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\r\n        }\r\n        participants.push(Participant(sender,tokenAmountToGame,2));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address sender, uint tokenAmountToGame)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "tokenAmountToGame"
         Type: uint256
         Source: "uint tokenAmountToGame"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "beforeRangeGame"
       Gas costs: 0
       Source: "beforeRangeGame"
      Identifier beforeRangeGame
         Type: modifier ()
         Source: "beforeRangeGame"
    Block
       Source: "{\r\n        require(c.currentGameTimeType != GameTime.Year);\r\n\r\n        if(c.currentGameTimeType == GameTime.Month){\r\n            f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\r\n        }\r\n        participants.push(Participant(sender,tokenAmountToGame,2));\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(c.currentGameTimeType != GameTime.Year)"
        FunctionCall
           Type: tuple()
           Source: "require(c.currentGameTimeType != GameTime.Year)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "c.currentGameTimeType != GameTime.Year"
            MemberAccess to member currentGameTimeType
               Type: enum Games.GameTime
               Source: "c.currentGameTimeType"
              Identifier c
                 Type: struct Games.CommonAttr storage ref
                 Source: "c"
            MemberAccess to member Year
               Type: enum Games.GameTime
               Source: "GameTime.Year"
              Identifier GameTime
                 Type: type(enum Games.GameTime)
                 Source: "GameTime"
      IfStatement
         Source: "if(c.currentGameTimeType == GameTime.Month){\r\n            f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "c.currentGameTimeType == GameTime.Month"
          MemberAccess to member currentGameTimeType
             Type: enum Games.GameTime
             Source: "c.currentGameTimeType"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
          MemberAccess to member Month
             Type: enum Games.GameTime
             Source: "GameTime.Month"
            Identifier GameTime
               Type: type(enum Games.GameTime)
               Source: "GameTime"
        Block
           Source: "{\r\n            f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame)"
            Assignment using operator =
               Type: uint256
               Source: "f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame)"
              MemberAccess to member monthlyStatusTok
                 Type: uint256
                 Source: "f.monthlyStatusTok"
                Identifier f
                   Type: struct Games.FundAmountStatusAttr storage ref
                   Source: "f"
              FunctionCall
                 Type: uint256
                 Source: "add(f.monthlyStatusTok, tokenAmountToGame)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                MemberAccess to member monthlyStatusTok
                   Type: uint256
                   Source: "f.monthlyStatusTok"
                  Identifier f
                     Type: struct Games.FundAmountStatusAttr storage ref
                     Source: "f"
                Identifier tokenAmountToGame
                   Type: uint256
                   Source: "tokenAmountToGame"
        IfStatement
           Source: "if(c.currentGameTimeType == GameTime.Hour){\r\n            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\r\n        }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 0
             Source: "c.currentGameTimeType == GameTime.Hour"
            MemberAccess to member currentGameTimeType
               Type: enum Games.GameTime
               Source: "c.currentGameTimeType"
              Identifier c
                 Type: struct Games.CommonAttr storage ref
                 Source: "c"
            MemberAccess to member Hour
               Type: enum Games.GameTime
               Source: "GameTime.Hour"
              Identifier GameTime
                 Type: type(enum Games.GameTime)
                 Source: "GameTime"
          Block
             Source: "{\r\n            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\r\n        }"
            ExpressionStatement
               Gas costs: 0
               Source: "f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame)"
              Assignment using operator =
                 Type: uint256
                 Source: "f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame)"
                MemberAccess to member hourlyStatusTok
                   Type: uint256
                   Source: "f.hourlyStatusTok"
                  Identifier f
                     Type: struct Games.FundAmountStatusAttr storage ref
                     Source: "f"
                FunctionCall
                   Type: uint256
                   Source: "add(f.hourlyStatusTok, tokenAmountToGame)"
                  Identifier add
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "add"
                  MemberAccess to member hourlyStatusTok
                     Type: uint256
                     Source: "f.hourlyStatusTok"
                    Identifier f
                       Type: struct Games.FundAmountStatusAttr storage ref
                       Source: "f"
                  Identifier tokenAmountToGame
                     Type: uint256
                     Source: "tokenAmountToGame"
      ExpressionStatement
         Gas costs: 0
         Source: "participants.push(Participant(sender,tokenAmountToGame,2))"
        FunctionCall
           Type: uint256
           Source: "participants.push(Participant(sender,tokenAmountToGame,2))"
          MemberAccess to member push
             Type: function (struct Games.Participant storage ref) returns (uint256)
             Source: "participants.push"
            Identifier participants
               Type: struct Games.Participant storage ref[] storage ref
               Source: "participants"
          FunctionCall
             Type: struct Games.Participant memory
             Source: "Participant(sender,tokenAmountToGame,2)"
            Identifier Participant
               Type: type(struct Games.Participant storage pointer)
               Source: "Participant"
            Identifier sender
               Type: address
               Source: "sender"
            Identifier tokenAmountToGame
               Type: uint256
               Source: "tokenAmountToGame"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
  FunctionDefinition "getTimeRangeInfo"
     Source: "function getTimeRangeInfo() private returns (GameTime, uint, uint, uint) {\r\n        uint nextTimeStamp;\r\n        uint nextYear;\r\n        uint nextMonth;\r\n        uint basis;\r\n        if(c.gameType == GameType.Range){\r\n            nextTimeStamp = now + r.inTimeRange_Y * 1 minutes + 1 hours;\r\n            nextYear = getYear(nextTimeStamp);\r\n            if(getYear(now - r.inTimeRange_Y * 1 minutes + 1 hours) != nextYear){\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days);    //Time range limit is less than 12 hours\r\n                return (GameTime.Year, nextYear, basis - r.inTimeRange_Y * 1 minutes, basis + r.inTimeRange_Y * 1 minutes);\r\n            }\r\n            nextTimeStamp = now + r.inTimeRange_M * 1 minutes + 1 hours;\r\n            nextMonth = getMonth(nextTimeStamp);\r\n            if(getMonth(now - r.inTimeRange_M * 1 minutes + 1 hours) != nextMonth){\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days); \r\n                return (GameTime.Month, nextYear, basis - r.inTimeRange_M * 1 minutes, basis + r.inTimeRange_M * 1 minutes);\r\n            }\r\n            nextTimeStamp = now + r.inTimeRange_H * 1 minutes + 1 hours;\r\n            basis = nextTimeStamp - (nextTimeStamp % 1 hours); \r\n            return (GameTime.Hour, nextYear, basis - r.inTimeRange_H * 1 minutes, basis + r.inTimeRange_H * 1 minutes);\r\n        }else if(c.gameType == GameType.Point){\r\n            nextTimeStamp = now - (now % 1 hours) + 1 hours;\r\n            nextYear = getYear(nextTimeStamp);\r\n            if(getYear(now) != nextYear){\r\n                return (GameTime.Year, nextYear, 0, nextTimeStamp);\r\n            }\r\n            nextMonth = getMonth(nextTimeStamp);\r\n            if(getMonth(now) != nextMonth){\r\n                return (GameTime.Month, nextYear, 0, nextTimeStamp);\r\n            }\r\n            return (GameTime.Hour, nextYear, 0, nextTimeStamp);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(GameTime, uint, uint, uint)"
      VariableDeclaration ""
         Type: enum Games.GameTime
         Source: "GameTime"
        UserDefinedTypeName "GameTime"
           Source: "GameTime"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint nextTimeStamp;\r\n        uint nextYear;\r\n        uint nextMonth;\r\n        uint basis;\r\n        if(c.gameType == GameType.Range){\r\n            nextTimeStamp = now + r.inTimeRange_Y * 1 minutes + 1 hours;\r\n            nextYear = getYear(nextTimeStamp);\r\n            if(getYear(now - r.inTimeRange_Y * 1 minutes + 1 hours) != nextYear){\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days);    //Time range limit is less than 12 hours\r\n                return (GameTime.Year, nextYear, basis - r.inTimeRange_Y * 1 minutes, basis + r.inTimeRange_Y * 1 minutes);\r\n            }\r\n            nextTimeStamp = now + r.inTimeRange_M * 1 minutes + 1 hours;\r\n            nextMonth = getMonth(nextTimeStamp);\r\n            if(getMonth(now - r.inTimeRange_M * 1 minutes + 1 hours) != nextMonth){\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days); \r\n                return (GameTime.Month, nextYear, basis - r.inTimeRange_M * 1 minutes, basis + r.inTimeRange_M * 1 minutes);\r\n            }\r\n            nextTimeStamp = now + r.inTimeRange_H * 1 minutes + 1 hours;\r\n            basis = nextTimeStamp - (nextTimeStamp % 1 hours); \r\n            return (GameTime.Hour, nextYear, basis - r.inTimeRange_H * 1 minutes, basis + r.inTimeRange_H * 1 minutes);\r\n        }else if(c.gameType == GameType.Point){\r\n            nextTimeStamp = now - (now % 1 hours) + 1 hours;\r\n            nextYear = getYear(nextTimeStamp);\r\n            if(getYear(now) != nextYear){\r\n                return (GameTime.Year, nextYear, 0, nextTimeStamp);\r\n            }\r\n            nextMonth = getMonth(nextTimeStamp);\r\n            if(getMonth(now) != nextMonth){\r\n                return (GameTime.Month, nextYear, 0, nextTimeStamp);\r\n            }\r\n            return (GameTime.Hour, nextYear, 0, nextTimeStamp);\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint nextTimeStamp"
        VariableDeclaration "nextTimeStamp"
           Type: uint256
           Source: "uint nextTimeStamp"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint nextYear"
        VariableDeclaration "nextYear"
           Type: uint256
           Source: "uint nextYear"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint nextMonth"
        VariableDeclaration "nextMonth"
           Type: uint256
           Source: "uint nextMonth"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint basis"
        VariableDeclaration "basis"
           Type: uint256
           Source: "uint basis"
          ElementaryTypeName uint
             Source: "uint"
      IfStatement
         Source: "if(c.gameType == GameType.Range){\r\n            nextTimeStamp = now + r.inTimeRange_Y * 1 minutes + 1 hours;\r\n            nextYear = getYear(nextTimeStamp);\r\n            if(getYear(now - r.inTimeRange_Y * 1 minutes + 1 hours) != nextYear){\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days);    //Time range limit is less than 12 hours\r\n                return (GameTime.Year, nextYear, basis - r.inTimeRange_Y * 1 minutes, basis + r.inTimeRange_Y * 1 minutes);\r\n            }\r\n            nextTimeStamp = now + r.inTimeRange_M * 1 minutes + 1 hours;\r\n            nextMonth = getMonth(nextTimeStamp);\r\n            if(getMonth(now - r.inTimeRange_M * 1 minutes + 1 hours) != nextMonth){\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days); \r\n                return (GameTime.Month, nextYear, basis - r.inTimeRange_M * 1 minutes, basis + r.inTimeRange_M * 1 minutes);\r\n            }\r\n            nextTimeStamp = now + r.inTimeRange_H * 1 minutes + 1 hours;\r\n            basis = nextTimeStamp - (nextTimeStamp % 1 hours); \r\n            return (GameTime.Hour, nextYear, basis - r.inTimeRange_H * 1 minutes, basis + r.inTimeRange_H * 1 minutes);\r\n        }else if(c.gameType == GameType.Point){\r\n            nextTimeStamp = now - (now % 1 hours) + 1 hours;\r\n            nextYear = getYear(nextTimeStamp);\r\n            if(getYear(now) != nextYear){\r\n                return (GameTime.Year, nextYear, 0, nextTimeStamp);\r\n            }\r\n            nextMonth = getMonth(nextTimeStamp);\r\n            if(getMonth(now) != nextMonth){\r\n                return (GameTime.Month, nextYear, 0, nextTimeStamp);\r\n            }\r\n            return (GameTime.Hour, nextYear, 0, nextTimeStamp);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "c.gameType == GameType.Range"
          MemberAccess to member gameType
             Type: enum Games.GameType
             Source: "c.gameType"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
          MemberAccess to member Range
             Type: enum Games.GameType
             Source: "GameType.Range"
            Identifier GameType
               Type: type(enum Games.GameType)
               Source: "GameType"
        Block
           Source: "{\r\n            nextTimeStamp = now + r.inTimeRange_Y * 1 minutes + 1 hours;\r\n            nextYear = getYear(nextTimeStamp);\r\n            if(getYear(now - r.inTimeRange_Y * 1 minutes + 1 hours) != nextYear){\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days);    //Time range limit is less than 12 hours\r\n                return (GameTime.Year, nextYear, basis - r.inTimeRange_Y * 1 minutes, basis + r.inTimeRange_Y * 1 minutes);\r\n            }\r\n            nextTimeStamp = now + r.inTimeRange_M * 1 minutes + 1 hours;\r\n            nextMonth = getMonth(nextTimeStamp);\r\n            if(getMonth(now - r.inTimeRange_M * 1 minutes + 1 hours) != nextMonth){\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days); \r\n                return (GameTime.Month, nextYear, basis - r.inTimeRange_M * 1 minutes, basis + r.inTimeRange_M * 1 minutes);\r\n            }\r\n            nextTimeStamp = now + r.inTimeRange_H * 1 minutes + 1 hours;\r\n            basis = nextTimeStamp - (nextTimeStamp % 1 hours); \r\n            return (GameTime.Hour, nextYear, basis - r.inTimeRange_H * 1 minutes, basis + r.inTimeRange_H * 1 minutes);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "nextTimeStamp = now + r.inTimeRange_Y * 1 minutes + 1 hours"
            Assignment using operator =
               Type: uint256
               Source: "nextTimeStamp = now + r.inTimeRange_Y * 1 minutes + 1 hours"
              Identifier nextTimeStamp
                 Type: uint256
                 Source: "nextTimeStamp"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "now + r.inTimeRange_Y * 1 minutes + 1 hours"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "now + r.inTimeRange_Y * 1 minutes"
                  Identifier now
                     Type: uint256
                     Source: "now"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "r.inTimeRange_Y * 1 minutes"
                    MemberAccess to member inTimeRange_Y
                       Type: uint256
                       Source: "r.inTimeRange_Y"
                      Identifier r
                         Type: struct Games.RangeGameAttr storage ref
                         Source: "r"
                    Literal, token: [no token] value: 1
                       Type: int_const 60
                       Source: "1 minutes"
                Literal, token: [no token] value: 1
                   Type: int_const 3600
                   Source: "1 hours"
          ExpressionStatement
             Gas costs: 0
             Source: "nextYear = getYear(nextTimeStamp)"
            Assignment using operator =
               Type: uint256
               Source: "nextYear = getYear(nextTimeStamp)"
              Identifier nextYear
                 Type: uint256
                 Source: "nextYear"
              FunctionCall
                 Type: uint16
                 Source: "getYear(nextTimeStamp)"
                Identifier getYear
                   Type: function (uint256) view returns (uint16)
                   Source: "getYear"
                Identifier nextTimeStamp
                   Type: uint256
                   Source: "nextTimeStamp"
          IfStatement
             Source: "if(getYear(now - r.inTimeRange_Y * 1 minutes + 1 hours) != nextYear){\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days);    //Time range limit is less than 12 hours\r\n                return (GameTime.Year, nextYear, basis - r.inTimeRange_Y * 1 minutes, basis + r.inTimeRange_Y * 1 minutes);\r\n            }"
            BinaryOperation using operator !=
               Type: bool
               Gas costs: 0
               Source: "getYear(now - r.inTimeRange_Y * 1 minutes + 1 hours) != nextYear"
              FunctionCall
                 Type: uint16
                 Source: "getYear(now - r.inTimeRange_Y * 1 minutes + 1 hours)"
                Identifier getYear
                   Type: function (uint256) view returns (uint16)
                   Source: "getYear"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "now - r.inTimeRange_Y * 1 minutes + 1 hours"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "now - r.inTimeRange_Y * 1 minutes"
                    Identifier now
                       Type: uint256
                       Source: "now"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "r.inTimeRange_Y * 1 minutes"
                      MemberAccess to member inTimeRange_Y
                         Type: uint256
                         Source: "r.inTimeRange_Y"
                        Identifier r
                           Type: struct Games.RangeGameAttr storage ref
                           Source: "r"
                      Literal, token: [no token] value: 1
                         Type: int_const 60
                         Source: "1 minutes"
                  Literal, token: [no token] value: 1
                     Type: int_const 3600
                     Source: "1 hours"
              Identifier nextYear
                 Type: uint256
                 Source: "nextYear"
            Block
               Source: "{\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days);    //Time range limit is less than 12 hours\r\n                return (GameTime.Year, nextYear, basis - r.inTimeRange_Y * 1 minutes, basis + r.inTimeRange_Y * 1 minutes);\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "basis = nextTimeStamp - (nextTimeStamp % 1 days)"
                Assignment using operator =
                   Type: uint256
                   Source: "basis = nextTimeStamp - (nextTimeStamp % 1 days)"
                  Identifier basis
                     Type: uint256
                     Source: "basis"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "nextTimeStamp - (nextTimeStamp % 1 days)"
                    Identifier nextTimeStamp
                       Type: uint256
                       Source: "nextTimeStamp"
                    TupleExpression
                       Type: uint256
                       Source: "(nextTimeStamp % 1 days)"
                      BinaryOperation using operator %
                         Type: uint256
                         Source: "nextTimeStamp % 1 days"
                        Identifier nextTimeStamp
                           Type: uint256
                           Source: "nextTimeStamp"
                        Literal, token: [no token] value: 1
                           Type: int_const 86400
                           Source: "1 days"
              Return
                 Gas costs: 0
                 Source: "return (GameTime.Year, nextYear, basis - r.inTimeRange_Y * 1 minutes, basis + r.inTimeRange_Y * 1 minutes)"
                TupleExpression
                   Type: tuple(enum Games.GameTime,uint256,uint256,uint256)
                   Source: "(GameTime.Year, nextYear, basis - r.inTimeRange_Y * 1 minutes, basis + r.inTimeRange_Y * 1 minutes)"
                  MemberAccess to member Year
                     Type: enum Games.GameTime
                     Source: "GameTime.Year"
                    Identifier GameTime
                       Type: type(enum Games.GameTime)
                       Source: "GameTime"
                  Identifier nextYear
                     Type: uint256
                     Source: "nextYear"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "basis - r.inTimeRange_Y * 1 minutes"
                    Identifier basis
                       Type: uint256
                       Source: "basis"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "r.inTimeRange_Y * 1 minutes"
                      MemberAccess to member inTimeRange_Y
                         Type: uint256
                         Source: "r.inTimeRange_Y"
                        Identifier r
                           Type: struct Games.RangeGameAttr storage ref
                           Source: "r"
                      Literal, token: [no token] value: 1
                         Type: int_const 60
                         Source: "1 minutes"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "basis + r.inTimeRange_Y * 1 minutes"
                    Identifier basis
                       Type: uint256
                       Source: "basis"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "r.inTimeRange_Y * 1 minutes"
                      MemberAccess to member inTimeRange_Y
                         Type: uint256
                         Source: "r.inTimeRange_Y"
                        Identifier r
                           Type: struct Games.RangeGameAttr storage ref
                           Source: "r"
                      Literal, token: [no token] value: 1
                         Type: int_const 60
                         Source: "1 minutes"
          ExpressionStatement
             Gas costs: 0
             Source: "nextTimeStamp = now + r.inTimeRange_M * 1 minutes + 1 hours"
            Assignment using operator =
               Type: uint256
               Source: "nextTimeStamp = now + r.inTimeRange_M * 1 minutes + 1 hours"
              Identifier nextTimeStamp
                 Type: uint256
                 Source: "nextTimeStamp"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "now + r.inTimeRange_M * 1 minutes + 1 hours"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "now + r.inTimeRange_M * 1 minutes"
                  Identifier now
                     Type: uint256
                     Source: "now"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "r.inTimeRange_M * 1 minutes"
                    MemberAccess to member inTimeRange_M
                       Type: uint256
                       Source: "r.inTimeRange_M"
                      Identifier r
                         Type: struct Games.RangeGameAttr storage ref
                         Source: "r"
                    Literal, token: [no token] value: 1
                       Type: int_const 60
                       Source: "1 minutes"
                Literal, token: [no token] value: 1
                   Type: int_const 3600
                   Source: "1 hours"
          ExpressionStatement
             Gas costs: 0
             Source: "nextMonth = getMonth(nextTimeStamp)"
            Assignment using operator =
               Type: uint256
               Source: "nextMonth = getMonth(nextTimeStamp)"
              Identifier nextMonth
                 Type: uint256
                 Source: "nextMonth"
              FunctionCall
                 Type: uint8
                 Source: "getMonth(nextTimeStamp)"
                Identifier getMonth
                   Type: function (uint256) view returns (uint8)
                   Source: "getMonth"
                Identifier nextTimeStamp
                   Type: uint256
                   Source: "nextTimeStamp"
          IfStatement
             Source: "if(getMonth(now - r.inTimeRange_M * 1 minutes + 1 hours) != nextMonth){\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days); \r\n                return (GameTime.Month, nextYear, basis - r.inTimeRange_M * 1 minutes, basis + r.inTimeRange_M * 1 minutes);\r\n            }"
            BinaryOperation using operator !=
               Type: bool
               Gas costs: 0
               Source: "getMonth(now - r.inTimeRange_M * 1 minutes + 1 hours) != nextMonth"
              FunctionCall
                 Type: uint8
                 Source: "getMonth(now - r.inTimeRange_M * 1 minutes + 1 hours)"
                Identifier getMonth
                   Type: function (uint256) view returns (uint8)
                   Source: "getMonth"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "now - r.inTimeRange_M * 1 minutes + 1 hours"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "now - r.inTimeRange_M * 1 minutes"
                    Identifier now
                       Type: uint256
                       Source: "now"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "r.inTimeRange_M * 1 minutes"
                      MemberAccess to member inTimeRange_M
                         Type: uint256
                         Source: "r.inTimeRange_M"
                        Identifier r
                           Type: struct Games.RangeGameAttr storage ref
                           Source: "r"
                      Literal, token: [no token] value: 1
                         Type: int_const 60
                         Source: "1 minutes"
                  Literal, token: [no token] value: 1
                     Type: int_const 3600
                     Source: "1 hours"
              Identifier nextMonth
                 Type: uint256
                 Source: "nextMonth"
            Block
               Source: "{\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days); \r\n                return (GameTime.Month, nextYear, basis - r.inTimeRange_M * 1 minutes, basis + r.inTimeRange_M * 1 minutes);\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "basis = nextTimeStamp - (nextTimeStamp % 1 days)"
                Assignment using operator =
                   Type: uint256
                   Source: "basis = nextTimeStamp - (nextTimeStamp % 1 days)"
                  Identifier basis
                     Type: uint256
                     Source: "basis"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "nextTimeStamp - (nextTimeStamp % 1 days)"
                    Identifier nextTimeStamp
                       Type: uint256
                       Source: "nextTimeStamp"
                    TupleExpression
                       Type: uint256
                       Source: "(nextTimeStamp % 1 days)"
                      BinaryOperation using operator %
                         Type: uint256
                         Source: "nextTimeStamp % 1 days"
                        Identifier nextTimeStamp
                           Type: uint256
                           Source: "nextTimeStamp"
                        Literal, token: [no token] value: 1
                           Type: int_const 86400
                           Source: "1 days"
              Return
                 Gas costs: 0
                 Source: "return (GameTime.Month, nextYear, basis - r.inTimeRange_M * 1 minutes, basis + r.inTimeRange_M * 1 minutes)"
                TupleExpression
                   Type: tuple(enum Games.GameTime,uint256,uint256,uint256)
                   Source: "(GameTime.Month, nextYear, basis - r.inTimeRange_M * 1 minutes, basis + r.inTimeRange_M * 1 minutes)"
                  MemberAccess to member Month
                     Type: enum Games.GameTime
                     Source: "GameTime.Month"
                    Identifier GameTime
                       Type: type(enum Games.GameTime)
                       Source: "GameTime"
                  Identifier nextYear
                     Type: uint256
                     Source: "nextYear"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "basis - r.inTimeRange_M * 1 minutes"
                    Identifier basis
                       Type: uint256
                       Source: "basis"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "r.inTimeRange_M * 1 minutes"
                      MemberAccess to member inTimeRange_M
                         Type: uint256
                         Source: "r.inTimeRange_M"
                        Identifier r
                           Type: struct Games.RangeGameAttr storage ref
                           Source: "r"
                      Literal, token: [no token] value: 1
                         Type: int_const 60
                         Source: "1 minutes"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "basis + r.inTimeRange_M * 1 minutes"
                    Identifier basis
                       Type: uint256
                       Source: "basis"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "r.inTimeRange_M * 1 minutes"
                      MemberAccess to member inTimeRange_M
                         Type: uint256
                         Source: "r.inTimeRange_M"
                        Identifier r
                           Type: struct Games.RangeGameAttr storage ref
                           Source: "r"
                      Literal, token: [no token] value: 1
                         Type: int_const 60
                         Source: "1 minutes"
          ExpressionStatement
             Gas costs: 0
             Source: "nextTimeStamp = now + r.inTimeRange_H * 1 minutes + 1 hours"
            Assignment using operator =
               Type: uint256
               Source: "nextTimeStamp = now + r.inTimeRange_H * 1 minutes + 1 hours"
              Identifier nextTimeStamp
                 Type: uint256
                 Source: "nextTimeStamp"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "now + r.inTimeRange_H * 1 minutes + 1 hours"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "now + r.inTimeRange_H * 1 minutes"
                  Identifier now
                     Type: uint256
                     Source: "now"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "r.inTimeRange_H * 1 minutes"
                    MemberAccess to member inTimeRange_H
                       Type: uint256
                       Source: "r.inTimeRange_H"
                      Identifier r
                         Type: struct Games.RangeGameAttr storage ref
                         Source: "r"
                    Literal, token: [no token] value: 1
                       Type: int_const 60
                       Source: "1 minutes"
                Literal, token: [no token] value: 1
                   Type: int_const 3600
                   Source: "1 hours"
          ExpressionStatement
             Gas costs: 0
             Source: "basis = nextTimeStamp - (nextTimeStamp % 1 hours)"
            Assignment using operator =
               Type: uint256
               Source: "basis = nextTimeStamp - (nextTimeStamp % 1 hours)"
              Identifier basis
                 Type: uint256
                 Source: "basis"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "nextTimeStamp - (nextTimeStamp % 1 hours)"
                Identifier nextTimeStamp
                   Type: uint256
                   Source: "nextTimeStamp"
                TupleExpression
                   Type: uint256
                   Source: "(nextTimeStamp % 1 hours)"
                  BinaryOperation using operator %
                     Type: uint256
                     Source: "nextTimeStamp % 1 hours"
                    Identifier nextTimeStamp
                       Type: uint256
                       Source: "nextTimeStamp"
                    Literal, token: [no token] value: 1
                       Type: int_const 3600
                       Source: "1 hours"
          Return
             Gas costs: 0
             Source: "return (GameTime.Hour, nextYear, basis - r.inTimeRange_H * 1 minutes, basis + r.inTimeRange_H * 1 minutes)"
            TupleExpression
               Type: tuple(enum Games.GameTime,uint256,uint256,uint256)
               Source: "(GameTime.Hour, nextYear, basis - r.inTimeRange_H * 1 minutes, basis + r.inTimeRange_H * 1 minutes)"
              MemberAccess to member Hour
                 Type: enum Games.GameTime
                 Source: "GameTime.Hour"
                Identifier GameTime
                   Type: type(enum Games.GameTime)
                   Source: "GameTime"
              Identifier nextYear
                 Type: uint256
                 Source: "nextYear"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "basis - r.inTimeRange_H * 1 minutes"
                Identifier basis
                   Type: uint256
                   Source: "basis"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "r.inTimeRange_H * 1 minutes"
                  MemberAccess to member inTimeRange_H
                     Type: uint256
                     Source: "r.inTimeRange_H"
                    Identifier r
                       Type: struct Games.RangeGameAttr storage ref
                       Source: "r"
                  Literal, token: [no token] value: 1
                     Type: int_const 60
                     Source: "1 minutes"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "basis + r.inTimeRange_H * 1 minutes"
                Identifier basis
                   Type: uint256
                   Source: "basis"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "r.inTimeRange_H * 1 minutes"
                  MemberAccess to member inTimeRange_H
                     Type: uint256
                     Source: "r.inTimeRange_H"
                    Identifier r
                       Type: struct Games.RangeGameAttr storage ref
                       Source: "r"
                  Literal, token: [no token] value: 1
                     Type: int_const 60
                     Source: "1 minutes"
        IfStatement
           Source: "if(c.gameType == GameType.Point){\r\n            nextTimeStamp = now - (now % 1 hours) + 1 hours;\r\n            nextYear = getYear(nextTimeStamp);\r\n            if(getYear(now) != nextYear){\r\n                return (GameTime.Year, nextYear, 0, nextTimeStamp);\r\n            }\r\n            nextMonth = getMonth(nextTimeStamp);\r\n            if(getMonth(now) != nextMonth){\r\n                return (GameTime.Month, nextYear, 0, nextTimeStamp);\r\n            }\r\n            return (GameTime.Hour, nextYear, 0, nextTimeStamp);\r\n        }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 0
             Source: "c.gameType == GameType.Point"
            MemberAccess to member gameType
               Type: enum Games.GameType
               Source: "c.gameType"
              Identifier c
                 Type: struct Games.CommonAttr storage ref
                 Source: "c"
            MemberAccess to member Point
               Type: enum Games.GameType
               Source: "GameType.Point"
              Identifier GameType
                 Type: type(enum Games.GameType)
                 Source: "GameType"
          Block
             Source: "{\r\n            nextTimeStamp = now - (now % 1 hours) + 1 hours;\r\n            nextYear = getYear(nextTimeStamp);\r\n            if(getYear(now) != nextYear){\r\n                return (GameTime.Year, nextYear, 0, nextTimeStamp);\r\n            }\r\n            nextMonth = getMonth(nextTimeStamp);\r\n            if(getMonth(now) != nextMonth){\r\n                return (GameTime.Month, nextYear, 0, nextTimeStamp);\r\n            }\r\n            return (GameTime.Hour, nextYear, 0, nextTimeStamp);\r\n        }"
            ExpressionStatement
               Gas costs: 0
               Source: "nextTimeStamp = now - (now % 1 hours) + 1 hours"
              Assignment using operator =
                 Type: uint256
                 Source: "nextTimeStamp = now - (now % 1 hours) + 1 hours"
                Identifier nextTimeStamp
                   Type: uint256
                   Source: "nextTimeStamp"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "now - (now % 1 hours) + 1 hours"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "now - (now % 1 hours)"
                    Identifier now
                       Type: uint256
                       Source: "now"
                    TupleExpression
                       Type: uint256
                       Source: "(now % 1 hours)"
                      BinaryOperation using operator %
                         Type: uint256
                         Source: "now % 1 hours"
                        Identifier now
                           Type: uint256
                           Source: "now"
                        Literal, token: [no token] value: 1
                           Type: int_const 3600
                           Source: "1 hours"
                  Literal, token: [no token] value: 1
                     Type: int_const 3600
                     Source: "1 hours"
            ExpressionStatement
               Gas costs: 0
               Source: "nextYear = getYear(nextTimeStamp)"
              Assignment using operator =
                 Type: uint256
                 Source: "nextYear = getYear(nextTimeStamp)"
                Identifier nextYear
                   Type: uint256
                   Source: "nextYear"
                FunctionCall
                   Type: uint16
                   Source: "getYear(nextTimeStamp)"
                  Identifier getYear
                     Type: function (uint256) view returns (uint16)
                     Source: "getYear"
                  Identifier nextTimeStamp
                     Type: uint256
                     Source: "nextTimeStamp"
            IfStatement
               Source: "if(getYear(now) != nextYear){\r\n                return (GameTime.Year, nextYear, 0, nextTimeStamp);\r\n            }"
              BinaryOperation using operator !=
                 Type: bool
                 Gas costs: 0
                 Source: "getYear(now) != nextYear"
                FunctionCall
                   Type: uint16
                   Source: "getYear(now)"
                  Identifier getYear
                     Type: function (uint256) view returns (uint16)
                     Source: "getYear"
                  Identifier now
                     Type: uint256
                     Source: "now"
                Identifier nextYear
                   Type: uint256
                   Source: "nextYear"
              Block
                 Source: "{\r\n                return (GameTime.Year, nextYear, 0, nextTimeStamp);\r\n            }"
                Return
                   Gas costs: 0
                   Source: "return (GameTime.Year, nextYear, 0, nextTimeStamp)"
                  TupleExpression
                     Type: tuple(enum Games.GameTime,uint256,int_const 0,uint256)
                     Source: "(GameTime.Year, nextYear, 0, nextTimeStamp)"
                    MemberAccess to member Year
                       Type: enum Games.GameTime
                       Source: "GameTime.Year"
                      Identifier GameTime
                         Type: type(enum Games.GameTime)
                         Source: "GameTime"
                    Identifier nextYear
                       Type: uint256
                       Source: "nextYear"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                    Identifier nextTimeStamp
                       Type: uint256
                       Source: "nextTimeStamp"
            ExpressionStatement
               Gas costs: 0
               Source: "nextMonth = getMonth(nextTimeStamp)"
              Assignment using operator =
                 Type: uint256
                 Source: "nextMonth = getMonth(nextTimeStamp)"
                Identifier nextMonth
                   Type: uint256
                   Source: "nextMonth"
                FunctionCall
                   Type: uint8
                   Source: "getMonth(nextTimeStamp)"
                  Identifier getMonth
                     Type: function (uint256) view returns (uint8)
                     Source: "getMonth"
                  Identifier nextTimeStamp
                     Type: uint256
                     Source: "nextTimeStamp"
            IfStatement
               Source: "if(getMonth(now) != nextMonth){\r\n                return (GameTime.Month, nextYear, 0, nextTimeStamp);\r\n            }"
              BinaryOperation using operator !=
                 Type: bool
                 Gas costs: 0
                 Source: "getMonth(now) != nextMonth"
                FunctionCall
                   Type: uint8
                   Source: "getMonth(now)"
                  Identifier getMonth
                     Type: function (uint256) view returns (uint8)
                     Source: "getMonth"
                  Identifier now
                     Type: uint256
                     Source: "now"
                Identifier nextMonth
                   Type: uint256
                   Source: "nextMonth"
              Block
                 Source: "{\r\n                return (GameTime.Month, nextYear, 0, nextTimeStamp);\r\n            }"
                Return
                   Gas costs: 0
                   Source: "return (GameTime.Month, nextYear, 0, nextTimeStamp)"
                  TupleExpression
                     Type: tuple(enum Games.GameTime,uint256,int_const 0,uint256)
                     Source: "(GameTime.Month, nextYear, 0, nextTimeStamp)"
                    MemberAccess to member Month
                       Type: enum Games.GameTime
                       Source: "GameTime.Month"
                      Identifier GameTime
                         Type: type(enum Games.GameTime)
                         Source: "GameTime"
                    Identifier nextYear
                       Type: uint256
                       Source: "nextYear"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                    Identifier nextTimeStamp
                       Type: uint256
                       Source: "nextTimeStamp"
            Return
               Gas costs: 0
               Source: "return (GameTime.Hour, nextYear, 0, nextTimeStamp)"
              TupleExpression
                 Type: tuple(enum Games.GameTime,uint256,int_const 0,uint256)
                 Source: "(GameTime.Hour, nextYear, 0, nextTimeStamp)"
                MemberAccess to member Hour
                   Type: enum Games.GameTime
                   Source: "GameTime.Hour"
                  Identifier GameTime
                     Type: type(enum Games.GameTime)
                     Source: "GameTime"
                Identifier nextYear
                   Type: uint256
                   Source: "nextYear"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
                Identifier nextTimeStamp
                   Type: uint256
                   Source: "nextTimeStamp"
  FunctionDefinition "refreshGameTime"
     Source: "function refreshGameTime() private {\r\n        (c.currentGameTimeType, d.currentYear, d.gameStart, d.gameEnd) = getTimeRangeInfo();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        (c.currentGameTimeType, d.currentYear, d.gameStart, d.gameEnd) = getTimeRangeInfo();\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "(c.currentGameTimeType, d.currentYear, d.gameStart, d.gameEnd) = getTimeRangeInfo()"
        Assignment using operator =
           Type: tuple()
           Source: "(c.currentGameTimeType, d.currentYear, d.gameStart, d.gameEnd) = getTimeRangeInfo()"
          TupleExpression
             Type: tuple(enum Games.GameTime,uint256,uint256,uint256)
             Source: "(c.currentGameTimeType, d.currentYear, d.gameStart, d.gameEnd)"
            MemberAccess to member currentGameTimeType
               Type: enum Games.GameTime
               Source: "c.currentGameTimeType"
              Identifier c
                 Type: struct Games.CommonAttr storage ref
                 Source: "c"
            MemberAccess to member currentYear
               Type: uint256
               Source: "d.currentYear"
              Identifier d
                 Type: struct Games.DateAttr storage ref
                 Source: "d"
            MemberAccess to member gameStart
               Type: uint256
               Source: "d.gameStart"
              Identifier d
                 Type: struct Games.DateAttr storage ref
                 Source: "d"
            MemberAccess to member gameEnd
               Type: uint256
               Source: "d.gameEnd"
              Identifier d
                 Type: struct Games.DateAttr storage ref
                 Source: "d"
          FunctionCall
             Type: tuple(enum Games.GameTime,uint256,uint256,uint256)
             Source: "getTimeRangeInfo()"
            Identifier getTimeRangeInfo
               Type: function () returns (enum Games.GameTime,uint256,uint256,uint256)
               Source: "getTimeRangeInfo"
  FunctionDefinition "gcFundAmount"
     Source: "function gcFundAmount() private {\r\n        f.hourlyStatusEth = 0;\r\n        f.monthlyStatusEth = 0;\r\n        f.yearlyStatusEth = 0;\r\n\r\n        f.hourlyStatusTok = 0;\r\n        f.monthlyStatusTok = 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        f.hourlyStatusEth = 0;\r\n        f.monthlyStatusEth = 0;\r\n        f.yearlyStatusEth = 0;\r\n\r\n        f.hourlyStatusTok = 0;\r\n        f.monthlyStatusTok = 0;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "f.hourlyStatusEth = 0"
        Assignment using operator =
           Type: uint256
           Source: "f.hourlyStatusEth = 0"
          MemberAccess to member hourlyStatusEth
             Type: uint256
             Source: "f.hourlyStatusEth"
            Identifier f
               Type: struct Games.FundAmountStatusAttr storage ref
               Source: "f"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "f.monthlyStatusEth = 0"
        Assignment using operator =
           Type: uint256
           Source: "f.monthlyStatusEth = 0"
          MemberAccess to member monthlyStatusEth
             Type: uint256
             Source: "f.monthlyStatusEth"
            Identifier f
               Type: struct Games.FundAmountStatusAttr storage ref
               Source: "f"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "f.yearlyStatusEth = 0"
        Assignment using operator =
           Type: uint256
           Source: "f.yearlyStatusEth = 0"
          MemberAccess to member yearlyStatusEth
             Type: uint256
             Source: "f.yearlyStatusEth"
            Identifier f
               Type: struct Games.FundAmountStatusAttr storage ref
               Source: "f"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "f.hourlyStatusTok = 0"
        Assignment using operator =
           Type: uint256
           Source: "f.hourlyStatusTok = 0"
          MemberAccess to member hourlyStatusTok
             Type: uint256
             Source: "f.hourlyStatusTok"
            Identifier f
               Type: struct Games.FundAmountStatusAttr storage ref
               Source: "f"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "f.monthlyStatusTok = 0"
        Assignment using operator =
           Type: uint256
           Source: "f.monthlyStatusTok = 0"
          MemberAccess to member monthlyStatusTok
             Type: uint256
             Source: "f.monthlyStatusTok"
            Identifier f
               Type: struct Games.FundAmountStatusAttr storage ref
               Source: "f"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "selectWinner" - public
     Source: "function selectWinner(uint rand) onlyOwner {\r\n        uint luckyNumber = participants.length * rand / 100000000;\r\n        uint rewardDiv100 = 0;\r\n\r\n        uint participateRatio = participants.length;\r\n        if(participateRatio != 0){\r\n            if(c.currentGameTimeType == GameTime.Year){\r\n                participateRatio = participateRatio > p.yearlyMinParticipateRatio?participateRatio:p.yearlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Month){\r\n                participateRatio = participateRatio > p.monthlyMinParticipateRatio?participateRatio:p.monthlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                participateRatio = participateRatio > p.hourlyMinParticipateRatio?participateRatio:p.hourlyMinParticipateRatio;\r\n            }\r\n\r\n            if(participants[luckyNumber].currency == 1){\r\n                rewardDiv100 = participants[luckyNumber].value * participateRatio * p.boostPrizeEth / 100 / 100;\r\n                if(p.currentInGameTokWinRatio < p.inGameTokWinRatioMax){\r\n                    p.currentInGameTokWinRatio++;\r\n                }\r\n            }else if(participants[luckyNumber].currency == 2){\r\n                rewardDiv100 = (participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100) * participateRatio / 100;\r\n                if(p.currentInGameTokWinRatio > p.inGameTokWinRatioMin){\r\n                    p.currentInGameTokWinRatio--;\r\n                }\r\n            }\r\n\r\n            if(c.currentGameTimeType == GameTime.Year){\r\n                if(c.yearlyAmountEth >= rewardDiv100*104){  //1.04\r\n                    c.yearlyAmountEth = sub(c.yearlyAmountEth, rewardDiv100*104);\r\n                }else{\r\n                    rewardDiv100 = c.yearlyAmountEth / 104;\r\n                    c.yearlyAmountEth = 0;\r\n                }\r\n            }else if(c.currentGameTimeType == GameTime.Month){\r\n                if(c.monthlyAmountEth >= rewardDiv100*107){    //1.07\r\n                    c.monthlyAmountEth = sub(c.monthlyAmountEth, rewardDiv100*107);\r\n                }else{\r\n                    rewardDiv100 = c.monthlyAmountEth / 107;\r\n                    c.monthlyAmountEth = 0;\r\n                }\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3); //0.03, 1.1\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                if(c.hourlyAmountEth >= rewardDiv100*110){\r\n                    c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110);\r\n                }else{\r\n                    rewardDiv100 = c.hourlyAmountEth / 110;\r\n                    c.hourlyAmountEth = 0;\r\n                }\r\n                c.monthlyAmountEth = add(c.monthlyAmountEth,rewardDiv100 * 3);\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3);\r\n            }\r\n            c.charityAmountEth = add(c.charityAmountEth,rewardDiv100 * 4);\r\n\r\n            winners[d.currentYear][participants[luckyNumber].sender] = add(winners[d.currentYear][participants[luckyNumber].sender],rewardDiv100*100);\r\n            winPrizes[d.currentYear] = add(winPrizes[d.currentYear],rewardDiv100*100);\r\n        \r\n            LogSelectWinner(rand, luckyNumber, participants[luckyNumber].sender, rewardDiv100*100, participants[luckyNumber].currency, participants[luckyNumber].value);\r\n\r\n            // Initialize participants\r\n            participants.length = 0;\r\n        }\r\n        if(c.gameType == GameType.Range){\r\n            refreshGameTime();\r\n        }\r\n        gcFundAmount();    \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint rand)"
      VariableDeclaration "rand"
         Type: uint256
         Source: "uint rand"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        uint luckyNumber = participants.length * rand / 100000000;\r\n        uint rewardDiv100 = 0;\r\n\r\n        uint participateRatio = participants.length;\r\n        if(participateRatio != 0){\r\n            if(c.currentGameTimeType == GameTime.Year){\r\n                participateRatio = participateRatio > p.yearlyMinParticipateRatio?participateRatio:p.yearlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Month){\r\n                participateRatio = participateRatio > p.monthlyMinParticipateRatio?participateRatio:p.monthlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                participateRatio = participateRatio > p.hourlyMinParticipateRatio?participateRatio:p.hourlyMinParticipateRatio;\r\n            }\r\n\r\n            if(participants[luckyNumber].currency == 1){\r\n                rewardDiv100 = participants[luckyNumber].value * participateRatio * p.boostPrizeEth / 100 / 100;\r\n                if(p.currentInGameTokWinRatio < p.inGameTokWinRatioMax){\r\n                    p.currentInGameTokWinRatio++;\r\n                }\r\n            }else if(participants[luckyNumber].currency == 2){\r\n                rewardDiv100 = (participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100) * participateRatio / 100;\r\n                if(p.currentInGameTokWinRatio > p.inGameTokWinRatioMin){\r\n                    p.currentInGameTokWinRatio--;\r\n                }\r\n            }\r\n\r\n            if(c.currentGameTimeType == GameTime.Year){\r\n                if(c.yearlyAmountEth >= rewardDiv100*104){  //1.04\r\n                    c.yearlyAmountEth = sub(c.yearlyAmountEth, rewardDiv100*104);\r\n                }else{\r\n                    rewardDiv100 = c.yearlyAmountEth / 104;\r\n                    c.yearlyAmountEth = 0;\r\n                }\r\n            }else if(c.currentGameTimeType == GameTime.Month){\r\n                if(c.monthlyAmountEth >= rewardDiv100*107){    //1.07\r\n                    c.monthlyAmountEth = sub(c.monthlyAmountEth, rewardDiv100*107);\r\n                }else{\r\n                    rewardDiv100 = c.monthlyAmountEth / 107;\r\n                    c.monthlyAmountEth = 0;\r\n                }\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3); //0.03, 1.1\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                if(c.hourlyAmountEth >= rewardDiv100*110){\r\n                    c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110);\r\n                }else{\r\n                    rewardDiv100 = c.hourlyAmountEth / 110;\r\n                    c.hourlyAmountEth = 0;\r\n                }\r\n                c.monthlyAmountEth = add(c.monthlyAmountEth,rewardDiv100 * 3);\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3);\r\n            }\r\n            c.charityAmountEth = add(c.charityAmountEth,rewardDiv100 * 4);\r\n\r\n            winners[d.currentYear][participants[luckyNumber].sender] = add(winners[d.currentYear][participants[luckyNumber].sender],rewardDiv100*100);\r\n            winPrizes[d.currentYear] = add(winPrizes[d.currentYear],rewardDiv100*100);\r\n        \r\n            LogSelectWinner(rand, luckyNumber, participants[luckyNumber].sender, rewardDiv100*100, participants[luckyNumber].currency, participants[luckyNumber].value);\r\n\r\n            // Initialize participants\r\n            participants.length = 0;\r\n        }\r\n        if(c.gameType == GameType.Range){\r\n            refreshGameTime();\r\n        }\r\n        gcFundAmount();    \r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint luckyNumber = participants.length * rand / 100000000"
        VariableDeclaration "luckyNumber"
           Type: uint256
           Source: "uint luckyNumber"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "participants.length * rand / 100000000"
          BinaryOperation using operator *
             Type: uint256
             Source: "participants.length * rand"
            MemberAccess to member length
               Type: uint256
               Source: "participants.length"
              Identifier participants
                 Type: struct Games.Participant storage ref[] storage ref
                 Source: "participants"
            Identifier rand
               Type: uint256
               Source: "rand"
          Literal, token: [no token] value: 100000000
             Type: int_const 100000000
             Source: "100000000"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint rewardDiv100 = 0"
        VariableDeclaration "rewardDiv100"
           Type: uint256
           Source: "uint rewardDiv100"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint participateRatio = participants.length"
        VariableDeclaration "participateRatio"
           Type: uint256
           Source: "uint participateRatio"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "participants.length"
          Identifier participants
             Type: struct Games.Participant storage ref[] storage ref
             Source: "participants"
      IfStatement
         Source: "if(participateRatio != 0){\r\n            if(c.currentGameTimeType == GameTime.Year){\r\n                participateRatio = participateRatio > p.yearlyMinParticipateRatio?participateRatio:p.yearlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Month){\r\n                participateRatio = participateRatio > p.monthlyMinParticipateRatio?participateRatio:p.monthlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                participateRatio = participateRatio > p.hourlyMinParticipateRatio?participateRatio:p.hourlyMinParticipateRatio;\r\n            }\r\n\r\n            if(participants[luckyNumber].currency == 1){\r\n                rewardDiv100 = participants[luckyNumber].value * participateRatio * p.boostPrizeEth / 100 / 100;\r\n                if(p.currentInGameTokWinRatio < p.inGameTokWinRatioMax){\r\n                    p.currentInGameTokWinRatio++;\r\n                }\r\n            }else if(participants[luckyNumber].currency == 2){\r\n                rewardDiv100 = (participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100) * participateRatio / 100;\r\n                if(p.currentInGameTokWinRatio > p.inGameTokWinRatioMin){\r\n                    p.currentInGameTokWinRatio--;\r\n                }\r\n            }\r\n\r\n            if(c.currentGameTimeType == GameTime.Year){\r\n                if(c.yearlyAmountEth >= rewardDiv100*104){  //1.04\r\n                    c.yearlyAmountEth = sub(c.yearlyAmountEth, rewardDiv100*104);\r\n                }else{\r\n                    rewardDiv100 = c.yearlyAmountEth / 104;\r\n                    c.yearlyAmountEth = 0;\r\n                }\r\n            }else if(c.currentGameTimeType == GameTime.Month){\r\n                if(c.monthlyAmountEth >= rewardDiv100*107){    //1.07\r\n                    c.monthlyAmountEth = sub(c.monthlyAmountEth, rewardDiv100*107);\r\n                }else{\r\n                    rewardDiv100 = c.monthlyAmountEth / 107;\r\n                    c.monthlyAmountEth = 0;\r\n                }\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3); //0.03, 1.1\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                if(c.hourlyAmountEth >= rewardDiv100*110){\r\n                    c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110);\r\n                }else{\r\n                    rewardDiv100 = c.hourlyAmountEth / 110;\r\n                    c.hourlyAmountEth = 0;\r\n                }\r\n                c.monthlyAmountEth = add(c.monthlyAmountEth,rewardDiv100 * 3);\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3);\r\n            }\r\n            c.charityAmountEth = add(c.charityAmountEth,rewardDiv100 * 4);\r\n\r\n            winners[d.currentYear][participants[luckyNumber].sender] = add(winners[d.currentYear][participants[luckyNumber].sender],rewardDiv100*100);\r\n            winPrizes[d.currentYear] = add(winPrizes[d.currentYear],rewardDiv100*100);\r\n        \r\n            LogSelectWinner(rand, luckyNumber, participants[luckyNumber].sender, rewardDiv100*100, participants[luckyNumber].currency, participants[luckyNumber].value);\r\n\r\n            // Initialize participants\r\n            participants.length = 0;\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "participateRatio != 0"
          Identifier participateRatio
             Type: uint256
             Source: "participateRatio"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            if(c.currentGameTimeType == GameTime.Year){\r\n                participateRatio = participateRatio > p.yearlyMinParticipateRatio?participateRatio:p.yearlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Month){\r\n                participateRatio = participateRatio > p.monthlyMinParticipateRatio?participateRatio:p.monthlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                participateRatio = participateRatio > p.hourlyMinParticipateRatio?participateRatio:p.hourlyMinParticipateRatio;\r\n            }\r\n\r\n            if(participants[luckyNumber].currency == 1){\r\n                rewardDiv100 = participants[luckyNumber].value * participateRatio * p.boostPrizeEth / 100 / 100;\r\n                if(p.currentInGameTokWinRatio < p.inGameTokWinRatioMax){\r\n                    p.currentInGameTokWinRatio++;\r\n                }\r\n            }else if(participants[luckyNumber].currency == 2){\r\n                rewardDiv100 = (participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100) * participateRatio / 100;\r\n                if(p.currentInGameTokWinRatio > p.inGameTokWinRatioMin){\r\n                    p.currentInGameTokWinRatio--;\r\n                }\r\n            }\r\n\r\n            if(c.currentGameTimeType == GameTime.Year){\r\n                if(c.yearlyAmountEth >= rewardDiv100*104){  //1.04\r\n                    c.yearlyAmountEth = sub(c.yearlyAmountEth, rewardDiv100*104);\r\n                }else{\r\n                    rewardDiv100 = c.yearlyAmountEth / 104;\r\n                    c.yearlyAmountEth = 0;\r\n                }\r\n            }else if(c.currentGameTimeType == GameTime.Month){\r\n                if(c.monthlyAmountEth >= rewardDiv100*107){    //1.07\r\n                    c.monthlyAmountEth = sub(c.monthlyAmountEth, rewardDiv100*107);\r\n                }else{\r\n                    rewardDiv100 = c.monthlyAmountEth / 107;\r\n                    c.monthlyAmountEth = 0;\r\n                }\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3); //0.03, 1.1\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                if(c.hourlyAmountEth >= rewardDiv100*110){\r\n                    c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110);\r\n                }else{\r\n                    rewardDiv100 = c.hourlyAmountEth / 110;\r\n                    c.hourlyAmountEth = 0;\r\n                }\r\n                c.monthlyAmountEth = add(c.monthlyAmountEth,rewardDiv100 * 3);\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3);\r\n            }\r\n            c.charityAmountEth = add(c.charityAmountEth,rewardDiv100 * 4);\r\n\r\n            winners[d.currentYear][participants[luckyNumber].sender] = add(winners[d.currentYear][participants[luckyNumber].sender],rewardDiv100*100);\r\n            winPrizes[d.currentYear] = add(winPrizes[d.currentYear],rewardDiv100*100);\r\n        \r\n            LogSelectWinner(rand, luckyNumber, participants[luckyNumber].sender, rewardDiv100*100, participants[luckyNumber].currency, participants[luckyNumber].value);\r\n\r\n            // Initialize participants\r\n            participants.length = 0;\r\n        }"
          IfStatement
             Source: "if(c.currentGameTimeType == GameTime.Year){\r\n                participateRatio = participateRatio > p.yearlyMinParticipateRatio?participateRatio:p.yearlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Month){\r\n                participateRatio = participateRatio > p.monthlyMinParticipateRatio?participateRatio:p.monthlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                participateRatio = participateRatio > p.hourlyMinParticipateRatio?participateRatio:p.hourlyMinParticipateRatio;\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "c.currentGameTimeType == GameTime.Year"
              MemberAccess to member currentGameTimeType
                 Type: enum Games.GameTime
                 Source: "c.currentGameTimeType"
                Identifier c
                   Type: struct Games.CommonAttr storage ref
                   Source: "c"
              MemberAccess to member Year
                 Type: enum Games.GameTime
                 Source: "GameTime.Year"
                Identifier GameTime
                   Type: type(enum Games.GameTime)
                   Source: "GameTime"
            Block
               Source: "{\r\n                participateRatio = participateRatio > p.yearlyMinParticipateRatio?participateRatio:p.yearlyMinParticipateRatio;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "participateRatio = participateRatio > p.yearlyMinParticipateRatio?participateRatio:p.yearlyMinParticipateRatio"
                Assignment using operator =
                   Type: uint256
                   Source: "participateRatio = participateRatio > p.yearlyMinParticipateRatio?participateRatio:p.yearlyMinParticipateRatio"
                  Identifier participateRatio
                     Type: uint256
                     Source: "participateRatio"
                  Conditional
                     Type: uint256
                     Source: "participateRatio > p.yearlyMinParticipateRatio?participateRatio:p.yearlyMinParticipateRatio"
                    BinaryOperation using operator >
                       Type: bool
                       Source: "participateRatio > p.yearlyMinParticipateRatio"
                      Identifier participateRatio
                         Type: uint256
                         Source: "participateRatio"
                      MemberAccess to member yearlyMinParticipateRatio
                         Type: uint256
                         Source: "p.yearlyMinParticipateRatio"
                        Identifier p
                           Type: struct Games.PriceAttr storage ref
                           Source: "p"
                    Identifier participateRatio
                       Type: uint256
                       Source: "participateRatio"
                    MemberAccess to member yearlyMinParticipateRatio
                       Type: uint256
                       Source: "p.yearlyMinParticipateRatio"
                      Identifier p
                         Type: struct Games.PriceAttr storage ref
                         Source: "p"
            IfStatement
               Source: "if(c.currentGameTimeType == GameTime.Month){\r\n                participateRatio = participateRatio > p.monthlyMinParticipateRatio?participateRatio:p.monthlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                participateRatio = participateRatio > p.hourlyMinParticipateRatio?participateRatio:p.hourlyMinParticipateRatio;\r\n            }"
              BinaryOperation using operator ==
                 Type: bool
                 Gas costs: 0
                 Source: "c.currentGameTimeType == GameTime.Month"
                MemberAccess to member currentGameTimeType
                   Type: enum Games.GameTime
                   Source: "c.currentGameTimeType"
                  Identifier c
                     Type: struct Games.CommonAttr storage ref
                     Source: "c"
                MemberAccess to member Month
                   Type: enum Games.GameTime
                   Source: "GameTime.Month"
                  Identifier GameTime
                     Type: type(enum Games.GameTime)
                     Source: "GameTime"
              Block
                 Source: "{\r\n                participateRatio = participateRatio > p.monthlyMinParticipateRatio?participateRatio:p.monthlyMinParticipateRatio;\r\n            }"
                ExpressionStatement
                   Gas costs: 0
                   Source: "participateRatio = participateRatio > p.monthlyMinParticipateRatio?participateRatio:p.monthlyMinParticipateRatio"
                  Assignment using operator =
                     Type: uint256
                     Source: "participateRatio = participateRatio > p.monthlyMinParticipateRatio?participateRatio:p.monthlyMinParticipateRatio"
                    Identifier participateRatio
                       Type: uint256
                       Source: "participateRatio"
                    Conditional
                       Type: uint256
                       Source: "participateRatio > p.monthlyMinParticipateRatio?participateRatio:p.monthlyMinParticipateRatio"
                      BinaryOperation using operator >
                         Type: bool
                         Source: "participateRatio > p.monthlyMinParticipateRatio"
                        Identifier participateRatio
                           Type: uint256
                           Source: "participateRatio"
                        MemberAccess to member monthlyMinParticipateRatio
                           Type: uint256
                           Source: "p.monthlyMinParticipateRatio"
                          Identifier p
                             Type: struct Games.PriceAttr storage ref
                             Source: "p"
                      Identifier participateRatio
                         Type: uint256
                         Source: "participateRatio"
                      MemberAccess to member monthlyMinParticipateRatio
                         Type: uint256
                         Source: "p.monthlyMinParticipateRatio"
                        Identifier p
                           Type: struct Games.PriceAttr storage ref
                           Source: "p"
              IfStatement
                 Source: "if(c.currentGameTimeType == GameTime.Hour){\r\n                participateRatio = participateRatio > p.hourlyMinParticipateRatio?participateRatio:p.hourlyMinParticipateRatio;\r\n            }"
                BinaryOperation using operator ==
                   Type: bool
                   Gas costs: 0
                   Source: "c.currentGameTimeType == GameTime.Hour"
                  MemberAccess to member currentGameTimeType
                     Type: enum Games.GameTime
                     Source: "c.currentGameTimeType"
                    Identifier c
                       Type: struct Games.CommonAttr storage ref
                       Source: "c"
                  MemberAccess to member Hour
                     Type: enum Games.GameTime
                     Source: "GameTime.Hour"
                    Identifier GameTime
                       Type: type(enum Games.GameTime)
                       Source: "GameTime"
                Block
                   Source: "{\r\n                participateRatio = participateRatio > p.hourlyMinParticipateRatio?participateRatio:p.hourlyMinParticipateRatio;\r\n            }"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "participateRatio = participateRatio > p.hourlyMinParticipateRatio?participateRatio:p.hourlyMinParticipateRatio"
                    Assignment using operator =
                       Type: uint256
                       Source: "participateRatio = participateRatio > p.hourlyMinParticipateRatio?participateRatio:p.hourlyMinParticipateRatio"
                      Identifier participateRatio
                         Type: uint256
                         Source: "participateRatio"
                      Conditional
                         Type: uint256
                         Source: "participateRatio > p.hourlyMinParticipateRatio?participateRatio:p.hourlyMinParticipateRatio"
                        BinaryOperation using operator >
                           Type: bool
                           Source: "participateRatio > p.hourlyMinParticipateRatio"
                          Identifier participateRatio
                             Type: uint256
                             Source: "participateRatio"
                          MemberAccess to member hourlyMinParticipateRatio
                             Type: uint256
                             Source: "p.hourlyMinParticipateRatio"
                            Identifier p
                               Type: struct Games.PriceAttr storage ref
                               Source: "p"
                        Identifier participateRatio
                           Type: uint256
                           Source: "participateRatio"
                        MemberAccess to member hourlyMinParticipateRatio
                           Type: uint256
                           Source: "p.hourlyMinParticipateRatio"
                          Identifier p
                             Type: struct Games.PriceAttr storage ref
                             Source: "p"
          IfStatement
             Source: "if(participants[luckyNumber].currency == 1){\r\n                rewardDiv100 = participants[luckyNumber].value * participateRatio * p.boostPrizeEth / 100 / 100;\r\n                if(p.currentInGameTokWinRatio < p.inGameTokWinRatioMax){\r\n                    p.currentInGameTokWinRatio++;\r\n                }\r\n            }else if(participants[luckyNumber].currency == 2){\r\n                rewardDiv100 = (participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100) * participateRatio / 100;\r\n                if(p.currentInGameTokWinRatio > p.inGameTokWinRatioMin){\r\n                    p.currentInGameTokWinRatio--;\r\n                }\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "participants[luckyNumber].currency == 1"
              MemberAccess to member currency
                 Type: uint256
                 Source: "participants[luckyNumber].currency"
                IndexAccess
                   Type: struct Games.Participant storage ref
                   Source: "participants[luckyNumber]"
                  Identifier participants
                     Type: struct Games.Participant storage ref[] storage ref
                     Source: "participants"
                  Identifier luckyNumber
                     Type: uint256
                     Source: "luckyNumber"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            Block
               Source: "{\r\n                rewardDiv100 = participants[luckyNumber].value * participateRatio * p.boostPrizeEth / 100 / 100;\r\n                if(p.currentInGameTokWinRatio < p.inGameTokWinRatioMax){\r\n                    p.currentInGameTokWinRatio++;\r\n                }\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "rewardDiv100 = participants[luckyNumber].value * participateRatio * p.boostPrizeEth / 100 / 100"
                Assignment using operator =
                   Type: uint256
                   Source: "rewardDiv100 = participants[luckyNumber].value * participateRatio * p.boostPrizeEth / 100 / 100"
                  Identifier rewardDiv100
                     Type: uint256
                     Source: "rewardDiv100"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "participants[luckyNumber].value * participateRatio * p.boostPrizeEth / 100 / 100"
                    BinaryOperation using operator /
                       Type: uint256
                       Source: "participants[luckyNumber].value * participateRatio * p.boostPrizeEth / 100"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "participants[luckyNumber].value * participateRatio * p.boostPrizeEth"
                        BinaryOperation using operator *
                           Type: uint256
                           Source: "participants[luckyNumber].value * participateRatio"
                          MemberAccess to member value
                             Type: uint256
                             Source: "participants[luckyNumber].value"
                            IndexAccess
                               Type: struct Games.Participant storage ref
                               Source: "participants[luckyNumber]"
                              Identifier participants
                                 Type: struct Games.Participant storage ref[] storage ref
                                 Source: "participants"
                              Identifier luckyNumber
                                 Type: uint256
                                 Source: "luckyNumber"
                          Identifier participateRatio
                             Type: uint256
                             Source: "participateRatio"
                        MemberAccess to member boostPrizeEth
                           Type: uint256
                           Source: "p.boostPrizeEth"
                          Identifier p
                             Type: struct Games.PriceAttr storage ref
                             Source: "p"
                      Literal, token: [no token] value: 100
                         Type: int_const 100
                         Source: "100"
                    Literal, token: [no token] value: 100
                       Type: int_const 100
                       Source: "100"
              IfStatement
                 Source: "if(p.currentInGameTokWinRatio < p.inGameTokWinRatioMax){\r\n                    p.currentInGameTokWinRatio++;\r\n                }"
                BinaryOperation using operator <
                   Type: bool
                   Gas costs: 0
                   Source: "p.currentInGameTokWinRatio < p.inGameTokWinRatioMax"
                  MemberAccess to member currentInGameTokWinRatio
                     Type: uint256
                     Source: "p.currentInGameTokWinRatio"
                    Identifier p
                       Type: struct Games.PriceAttr storage ref
                       Source: "p"
                  MemberAccess to member inGameTokWinRatioMax
                     Type: uint256
                     Source: "p.inGameTokWinRatioMax"
                    Identifier p
                       Type: struct Games.PriceAttr storage ref
                       Source: "p"
                Block
                   Source: "{\r\n                    p.currentInGameTokWinRatio++;\r\n                }"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "p.currentInGameTokWinRatio++"
                    UnaryOperation (postfix) ++
                       Type: uint256
                       Source: "p.currentInGameTokWinRatio++"
                      MemberAccess to member currentInGameTokWinRatio
                         Type: uint256
                         Source: "p.currentInGameTokWinRatio"
                        Identifier p
                           Type: struct Games.PriceAttr storage ref
                           Source: "p"
            IfStatement
               Source: "if(participants[luckyNumber].currency == 2){\r\n                rewardDiv100 = (participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100) * participateRatio / 100;\r\n                if(p.currentInGameTokWinRatio > p.inGameTokWinRatioMin){\r\n                    p.currentInGameTokWinRatio--;\r\n                }\r\n            }"
              BinaryOperation using operator ==
                 Type: bool
                 Gas costs: 0
                 Source: "participants[luckyNumber].currency == 2"
                MemberAccess to member currency
                   Type: uint256
                   Source: "participants[luckyNumber].currency"
                  IndexAccess
                     Type: struct Games.Participant storage ref
                     Source: "participants[luckyNumber]"
                    Identifier participants
                       Type: struct Games.Participant storage ref[] storage ref
                       Source: "participants"
                    Identifier luckyNumber
                       Type: uint256
                       Source: "luckyNumber"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
              Block
                 Source: "{\r\n                rewardDiv100 = (participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100) * participateRatio / 100;\r\n                if(p.currentInGameTokWinRatio > p.inGameTokWinRatioMin){\r\n                    p.currentInGameTokWinRatio--;\r\n                }\r\n            }"
                ExpressionStatement
                   Gas costs: 0
                   Source: "rewardDiv100 = (participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100) * participateRatio / 100"
                  Assignment using operator =
                     Type: uint256
                     Source: "rewardDiv100 = (participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100) * participateRatio / 100"
                    Identifier rewardDiv100
                       Type: uint256
                       Source: "rewardDiv100"
                    BinaryOperation using operator /
                       Type: uint256
                       Source: "(participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100) * participateRatio / 100"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "(participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100) * participateRatio"
                        TupleExpression
                           Type: uint256
                           Source: "(participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100)"
                          BinaryOperation using operator /
                             Type: uint256
                             Source: "participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100"
                            BinaryOperation using operator *
                               Type: uint256
                               Source: "participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio"
                              BinaryOperation using operator /
                                 Type: uint256
                                 Source: "participants[luckyNumber].value / p.inGameTokPricePerEth"
                                MemberAccess to member value
                                   Type: uint256
                                   Source: "participants[luckyNumber].value"
                                  IndexAccess
                                     Type: struct Games.Participant storage ref
                                     Source: "participants[luckyNumber]"
                                    Identifier participants
                                       Type: struct Games.Participant storage ref[] storage ref
                                       Source: "participants"
                                    Identifier luckyNumber
                                       Type: uint256
                                       Source: "luckyNumber"
                                MemberAccess to member inGameTokPricePerEth
                                   Type: uint256
                                   Source: "p.inGameTokPricePerEth"
                                  Identifier p
                                     Type: struct Games.PriceAttr storage ref
                                     Source: "p"
                              MemberAccess to member currentInGameTokWinRatio
                                 Type: uint256
                                 Source: "p.currentInGameTokWinRatio"
                                Identifier p
                                   Type: struct Games.PriceAttr storage ref
                                   Source: "p"
                            Literal, token: [no token] value: 100
                               Type: int_const 100
                               Source: "100"
                        Identifier participateRatio
                           Type: uint256
                           Source: "participateRatio"
                      Literal, token: [no token] value: 100
                         Type: int_const 100
                         Source: "100"
                IfStatement
                   Source: "if(p.currentInGameTokWinRatio > p.inGameTokWinRatioMin){\r\n                    p.currentInGameTokWinRatio--;\r\n                }"
                  BinaryOperation using operator >
                     Type: bool
                     Gas costs: 0
                     Source: "p.currentInGameTokWinRatio > p.inGameTokWinRatioMin"
                    MemberAccess to member currentInGameTokWinRatio
                       Type: uint256
                       Source: "p.currentInGameTokWinRatio"
                      Identifier p
                         Type: struct Games.PriceAttr storage ref
                         Source: "p"
                    MemberAccess to member inGameTokWinRatioMin
                       Type: uint256
                       Source: "p.inGameTokWinRatioMin"
                      Identifier p
                         Type: struct Games.PriceAttr storage ref
                         Source: "p"
                  Block
                     Source: "{\r\n                    p.currentInGameTokWinRatio--;\r\n                }"
                    ExpressionStatement
                       Gas costs: 0
                       Source: "p.currentInGameTokWinRatio--"
                      UnaryOperation (postfix) --
                         Type: uint256
                         Source: "p.currentInGameTokWinRatio--"
                        MemberAccess to member currentInGameTokWinRatio
                           Type: uint256
                           Source: "p.currentInGameTokWinRatio"
                          Identifier p
                             Type: struct Games.PriceAttr storage ref
                             Source: "p"
          IfStatement
             Source: "if(c.currentGameTimeType == GameTime.Year){\r\n                if(c.yearlyAmountEth >= rewardDiv100*104){  //1.04\r\n                    c.yearlyAmountEth = sub(c.yearlyAmountEth, rewardDiv100*104);\r\n                }else{\r\n                    rewardDiv100 = c.yearlyAmountEth / 104;\r\n                    c.yearlyAmountEth = 0;\r\n                }\r\n            }else if(c.currentGameTimeType == GameTime.Month){\r\n                if(c.monthlyAmountEth >= rewardDiv100*107){    //1.07\r\n                    c.monthlyAmountEth = sub(c.monthlyAmountEth, rewardDiv100*107);\r\n                }else{\r\n                    rewardDiv100 = c.monthlyAmountEth / 107;\r\n                    c.monthlyAmountEth = 0;\r\n                }\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3); //0.03, 1.1\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                if(c.hourlyAmountEth >= rewardDiv100*110){\r\n                    c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110);\r\n                }else{\r\n                    rewardDiv100 = c.hourlyAmountEth / 110;\r\n                    c.hourlyAmountEth = 0;\r\n                }\r\n                c.monthlyAmountEth = add(c.monthlyAmountEth,rewardDiv100 * 3);\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3);\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "c.currentGameTimeType == GameTime.Year"
              MemberAccess to member currentGameTimeType
                 Type: enum Games.GameTime
                 Source: "c.currentGameTimeType"
                Identifier c
                   Type: struct Games.CommonAttr storage ref
                   Source: "c"
              MemberAccess to member Year
                 Type: enum Games.GameTime
                 Source: "GameTime.Year"
                Identifier GameTime
                   Type: type(enum Games.GameTime)
                   Source: "GameTime"
            Block
               Source: "{\r\n                if(c.yearlyAmountEth >= rewardDiv100*104){  //1.04\r\n                    c.yearlyAmountEth = sub(c.yearlyAmountEth, rewardDiv100*104);\r\n                }else{\r\n                    rewardDiv100 = c.yearlyAmountEth / 104;\r\n                    c.yearlyAmountEth = 0;\r\n                }\r\n            }"
              IfStatement
                 Source: "if(c.yearlyAmountEth >= rewardDiv100*104){  //1.04\r\n                    c.yearlyAmountEth = sub(c.yearlyAmountEth, rewardDiv100*104);\r\n                }else{\r\n                    rewardDiv100 = c.yearlyAmountEth / 104;\r\n                    c.yearlyAmountEth = 0;\r\n                }"
                BinaryOperation using operator >=
                   Type: bool
                   Gas costs: 0
                   Source: "c.yearlyAmountEth >= rewardDiv100*104"
                  MemberAccess to member yearlyAmountEth
                     Type: uint256
                     Source: "c.yearlyAmountEth"
                    Identifier c
                       Type: struct Games.CommonAttr storage ref
                       Source: "c"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "rewardDiv100*104"
                    Identifier rewardDiv100
                       Type: uint256
                       Source: "rewardDiv100"
                    Literal, token: [no token] value: 104
                       Type: int_const 104
                       Source: "104"
                Block
                   Source: "{  //1.04\r\n                    c.yearlyAmountEth = sub(c.yearlyAmountEth, rewardDiv100*104);\r\n                }"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "c.yearlyAmountEth = sub(c.yearlyAmountEth, rewardDiv100*104)"
                    Assignment using operator =
                       Type: uint256
                       Source: "c.yearlyAmountEth = sub(c.yearlyAmountEth, rewardDiv100*104)"
                      MemberAccess to member yearlyAmountEth
                         Type: uint256
                         Source: "c.yearlyAmountEth"
                        Identifier c
                           Type: struct Games.CommonAttr storage ref
                           Source: "c"
                      FunctionCall
                         Type: uint256
                         Source: "sub(c.yearlyAmountEth, rewardDiv100*104)"
                        Identifier sub
                           Type: function (uint256,uint256) view returns (uint256)
                           Source: "sub"
                        MemberAccess to member yearlyAmountEth
                           Type: uint256
                           Source: "c.yearlyAmountEth"
                          Identifier c
                             Type: struct Games.CommonAttr storage ref
                             Source: "c"
                        BinaryOperation using operator *
                           Type: uint256
                           Source: "rewardDiv100*104"
                          Identifier rewardDiv100
                             Type: uint256
                             Source: "rewardDiv100"
                          Literal, token: [no token] value: 104
                             Type: int_const 104
                             Source: "104"
                Block
                   Source: "{\r\n                    rewardDiv100 = c.yearlyAmountEth / 104;\r\n                    c.yearlyAmountEth = 0;\r\n                }"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "rewardDiv100 = c.yearlyAmountEth / 104"
                    Assignment using operator =
                       Type: uint256
                       Source: "rewardDiv100 = c.yearlyAmountEth / 104"
                      Identifier rewardDiv100
                         Type: uint256
                         Source: "rewardDiv100"
                      BinaryOperation using operator /
                         Type: uint256
                         Source: "c.yearlyAmountEth / 104"
                        MemberAccess to member yearlyAmountEth
                           Type: uint256
                           Source: "c.yearlyAmountEth"
                          Identifier c
                             Type: struct Games.CommonAttr storage ref
                             Source: "c"
                        Literal, token: [no token] value: 104
                           Type: int_const 104
                           Source: "104"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "c.yearlyAmountEth = 0"
                    Assignment using operator =
                       Type: uint256
                       Source: "c.yearlyAmountEth = 0"
                      MemberAccess to member yearlyAmountEth
                         Type: uint256
                         Source: "c.yearlyAmountEth"
                        Identifier c
                           Type: struct Games.CommonAttr storage ref
                           Source: "c"
                      Literal, token: [no token] value: 0
                         Type: int_const 0
                         Source: "0"
            IfStatement
               Source: "if(c.currentGameTimeType == GameTime.Month){\r\n                if(c.monthlyAmountEth >= rewardDiv100*107){    //1.07\r\n                    c.monthlyAmountEth = sub(c.monthlyAmountEth, rewardDiv100*107);\r\n                }else{\r\n                    rewardDiv100 = c.monthlyAmountEth / 107;\r\n                    c.monthlyAmountEth = 0;\r\n                }\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3); //0.03, 1.1\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                if(c.hourlyAmountEth >= rewardDiv100*110){\r\n                    c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110);\r\n                }else{\r\n                    rewardDiv100 = c.hourlyAmountEth / 110;\r\n                    c.hourlyAmountEth = 0;\r\n                }\r\n                c.monthlyAmountEth = add(c.monthlyAmountEth,rewardDiv100 * 3);\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3);\r\n            }"
              BinaryOperation using operator ==
                 Type: bool
                 Gas costs: 0
                 Source: "c.currentGameTimeType == GameTime.Month"
                MemberAccess to member currentGameTimeType
                   Type: enum Games.GameTime
                   Source: "c.currentGameTimeType"
                  Identifier c
                     Type: struct Games.CommonAttr storage ref
                     Source: "c"
                MemberAccess to member Month
                   Type: enum Games.GameTime
                   Source: "GameTime.Month"
                  Identifier GameTime
                     Type: type(enum Games.GameTime)
                     Source: "GameTime"
              Block
                 Source: "{\r\n                if(c.monthlyAmountEth >= rewardDiv100*107){    //1.07\r\n                    c.monthlyAmountEth = sub(c.monthlyAmountEth, rewardDiv100*107);\r\n                }else{\r\n                    rewardDiv100 = c.monthlyAmountEth / 107;\r\n                    c.monthlyAmountEth = 0;\r\n                }\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3); //0.03, 1.1\r\n            }"
                IfStatement
                   Source: "if(c.monthlyAmountEth >= rewardDiv100*107){    //1.07\r\n                    c.monthlyAmountEth = sub(c.monthlyAmountEth, rewardDiv100*107);\r\n                }else{\r\n                    rewardDiv100 = c.monthlyAmountEth / 107;\r\n                    c.monthlyAmountEth = 0;\r\n                }"
                  BinaryOperation using operator >=
                     Type: bool
                     Gas costs: 0
                     Source: "c.monthlyAmountEth >= rewardDiv100*107"
                    MemberAccess to member monthlyAmountEth
                       Type: uint256
                       Source: "c.monthlyAmountEth"
                      Identifier c
                         Type: struct Games.CommonAttr storage ref
                         Source: "c"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "rewardDiv100*107"
                      Identifier rewardDiv100
                         Type: uint256
                         Source: "rewardDiv100"
                      Literal, token: [no token] value: 107
                         Type: int_const 107
                         Source: "107"
                  Block
                     Source: "{    //1.07\r\n                    c.monthlyAmountEth = sub(c.monthlyAmountEth, rewardDiv100*107);\r\n                }"
                    ExpressionStatement
                       Gas costs: 0
                       Source: "c.monthlyAmountEth = sub(c.monthlyAmountEth, rewardDiv100*107)"
                      Assignment using operator =
                         Type: uint256
                         Source: "c.monthlyAmountEth = sub(c.monthlyAmountEth, rewardDiv100*107)"
                        MemberAccess to member monthlyAmountEth
                           Type: uint256
                           Source: "c.monthlyAmountEth"
                          Identifier c
                             Type: struct Games.CommonAttr storage ref
                             Source: "c"
                        FunctionCall
                           Type: uint256
                           Source: "sub(c.monthlyAmountEth, rewardDiv100*107)"
                          Identifier sub
                             Type: function (uint256,uint256) view returns (uint256)
                             Source: "sub"
                          MemberAccess to member monthlyAmountEth
                             Type: uint256
                             Source: "c.monthlyAmountEth"
                            Identifier c
                               Type: struct Games.CommonAttr storage ref
                               Source: "c"
                          BinaryOperation using operator *
                             Type: uint256
                             Source: "rewardDiv100*107"
                            Identifier rewardDiv100
                               Type: uint256
                               Source: "rewardDiv100"
                            Literal, token: [no token] value: 107
                               Type: int_const 107
                               Source: "107"
                  Block
                     Source: "{\r\n                    rewardDiv100 = c.monthlyAmountEth / 107;\r\n                    c.monthlyAmountEth = 0;\r\n                }"
                    ExpressionStatement
                       Gas costs: 0
                       Source: "rewardDiv100 = c.monthlyAmountEth / 107"
                      Assignment using operator =
                         Type: uint256
                         Source: "rewardDiv100 = c.monthlyAmountEth / 107"
                        Identifier rewardDiv100
                           Type: uint256
                           Source: "rewardDiv100"
                        BinaryOperation using operator /
                           Type: uint256
                           Source: "c.monthlyAmountEth / 107"
                          MemberAccess to member monthlyAmountEth
                             Type: uint256
                             Source: "c.monthlyAmountEth"
                            Identifier c
                               Type: struct Games.CommonAttr storage ref
                               Source: "c"
                          Literal, token: [no token] value: 107
                             Type: int_const 107
                             Source: "107"
                    ExpressionStatement
                       Gas costs: 0
                       Source: "c.monthlyAmountEth = 0"
                      Assignment using operator =
                         Type: uint256
                         Source: "c.monthlyAmountEth = 0"
                        MemberAccess to member monthlyAmountEth
                           Type: uint256
                           Source: "c.monthlyAmountEth"
                          Identifier c
                             Type: struct Games.CommonAttr storage ref
                             Source: "c"
                        Literal, token: [no token] value: 0
                           Type: int_const 0
                           Source: "0"
                ExpressionStatement
                   Gas costs: 0
                   Source: "c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3)"
                  Assignment using operator =
                     Type: uint256
                     Source: "c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3)"
                    MemberAccess to member yearlyAmountEth
                       Type: uint256
                       Source: "c.yearlyAmountEth"
                      Identifier c
                         Type: struct Games.CommonAttr storage ref
                         Source: "c"
                    FunctionCall
                       Type: uint256
                       Source: "add(c.yearlyAmountEth,rewardDiv100 * 3)"
                      Identifier add
                         Type: function (uint256,uint256) view returns (uint256)
                         Source: "add"
                      MemberAccess to member yearlyAmountEth
                         Type: uint256
                         Source: "c.yearlyAmountEth"
                        Identifier c
                           Type: struct Games.CommonAttr storage ref
                           Source: "c"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "rewardDiv100 * 3"
                        Identifier rewardDiv100
                           Type: uint256
                           Source: "rewardDiv100"
                        Literal, token: [no token] value: 3
                           Type: int_const 3
                           Source: "3"
              IfStatement
                 Source: "if(c.currentGameTimeType == GameTime.Hour){\r\n                if(c.hourlyAmountEth >= rewardDiv100*110){\r\n                    c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110);\r\n                }else{\r\n                    rewardDiv100 = c.hourlyAmountEth / 110;\r\n                    c.hourlyAmountEth = 0;\r\n                }\r\n                c.monthlyAmountEth = add(c.monthlyAmountEth,rewardDiv100 * 3);\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3);\r\n            }"
                BinaryOperation using operator ==
                   Type: bool
                   Gas costs: 0
                   Source: "c.currentGameTimeType == GameTime.Hour"
                  MemberAccess to member currentGameTimeType
                     Type: enum Games.GameTime
                     Source: "c.currentGameTimeType"
                    Identifier c
                       Type: struct Games.CommonAttr storage ref
                       Source: "c"
                  MemberAccess to member Hour
                     Type: enum Games.GameTime
                     Source: "GameTime.Hour"
                    Identifier GameTime
                       Type: type(enum Games.GameTime)
                       Source: "GameTime"
                Block
                   Source: "{\r\n                if(c.hourlyAmountEth >= rewardDiv100*110){\r\n                    c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110);\r\n                }else{\r\n                    rewardDiv100 = c.hourlyAmountEth / 110;\r\n                    c.hourlyAmountEth = 0;\r\n                }\r\n                c.monthlyAmountEth = add(c.monthlyAmountEth,rewardDiv100 * 3);\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3);\r\n            }"
                  IfStatement
                     Source: "if(c.hourlyAmountEth >= rewardDiv100*110){\r\n                    c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110);\r\n                }else{\r\n                    rewardDiv100 = c.hourlyAmountEth / 110;\r\n                    c.hourlyAmountEth = 0;\r\n                }"
                    BinaryOperation using operator >=
                       Type: bool
                       Gas costs: 0
                       Source: "c.hourlyAmountEth >= rewardDiv100*110"
                      MemberAccess to member hourlyAmountEth
                         Type: uint256
                         Source: "c.hourlyAmountEth"
                        Identifier c
                           Type: struct Games.CommonAttr storage ref
                           Source: "c"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "rewardDiv100*110"
                        Identifier rewardDiv100
                           Type: uint256
                           Source: "rewardDiv100"
                        Literal, token: [no token] value: 110
                           Type: int_const 110
                           Source: "110"
                    Block
                       Source: "{\r\n                    c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110);\r\n                }"
                      ExpressionStatement
                         Gas costs: 0
                         Source: "c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110)"
                        Assignment using operator =
                           Type: uint256
                           Source: "c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110)"
                          MemberAccess to member hourlyAmountEth
                             Type: uint256
                             Source: "c.hourlyAmountEth"
                            Identifier c
                               Type: struct Games.CommonAttr storage ref
                               Source: "c"
                          FunctionCall
                             Type: uint256
                             Source: "sub(c.hourlyAmountEth, rewardDiv100*110)"
                            Identifier sub
                               Type: function (uint256,uint256) view returns (uint256)
                               Source: "sub"
                            MemberAccess to member hourlyAmountEth
                               Type: uint256
                               Source: "c.hourlyAmountEth"
                              Identifier c
                                 Type: struct Games.CommonAttr storage ref
                                 Source: "c"
                            BinaryOperation using operator *
                               Type: uint256
                               Source: "rewardDiv100*110"
                              Identifier rewardDiv100
                                 Type: uint256
                                 Source: "rewardDiv100"
                              Literal, token: [no token] value: 110
                                 Type: int_const 110
                                 Source: "110"
                    Block
                       Source: "{\r\n                    rewardDiv100 = c.hourlyAmountEth / 110;\r\n                    c.hourlyAmountEth = 0;\r\n                }"
                      ExpressionStatement
                         Gas costs: 0
                         Source: "rewardDiv100 = c.hourlyAmountEth / 110"
                        Assignment using operator =
                           Type: uint256
                           Source: "rewardDiv100 = c.hourlyAmountEth / 110"
                          Identifier rewardDiv100
                             Type: uint256
                             Source: "rewardDiv100"
                          BinaryOperation using operator /
                             Type: uint256
                             Source: "c.hourlyAmountEth / 110"
                            MemberAccess to member hourlyAmountEth
                               Type: uint256
                               Source: "c.hourlyAmountEth"
                              Identifier c
                                 Type: struct Games.CommonAttr storage ref
                                 Source: "c"
                            Literal, token: [no token] value: 110
                               Type: int_const 110
                               Source: "110"
                      ExpressionStatement
                         Gas costs: 0
                         Source: "c.hourlyAmountEth = 0"
                        Assignment using operator =
                           Type: uint256
                           Source: "c.hourlyAmountEth = 0"
                          MemberAccess to member hourlyAmountEth
                             Type: uint256
                             Source: "c.hourlyAmountEth"
                            Identifier c
                               Type: struct Games.CommonAttr storage ref
                               Source: "c"
                          Literal, token: [no token] value: 0
                             Type: int_const 0
                             Source: "0"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "c.monthlyAmountEth = add(c.monthlyAmountEth,rewardDiv100 * 3)"
                    Assignment using operator =
                       Type: uint256
                       Source: "c.monthlyAmountEth = add(c.monthlyAmountEth,rewardDiv100 * 3)"
                      MemberAccess to member monthlyAmountEth
                         Type: uint256
                         Source: "c.monthlyAmountEth"
                        Identifier c
                           Type: struct Games.CommonAttr storage ref
                           Source: "c"
                      FunctionCall
                         Type: uint256
                         Source: "add(c.monthlyAmountEth,rewardDiv100 * 3)"
                        Identifier add
                           Type: function (uint256,uint256) view returns (uint256)
                           Source: "add"
                        MemberAccess to member monthlyAmountEth
                           Type: uint256
                           Source: "c.monthlyAmountEth"
                          Identifier c
                             Type: struct Games.CommonAttr storage ref
                             Source: "c"
                        BinaryOperation using operator *
                           Type: uint256
                           Source: "rewardDiv100 * 3"
                          Identifier rewardDiv100
                             Type: uint256
                             Source: "rewardDiv100"
                          Literal, token: [no token] value: 3
                             Type: int_const 3
                             Source: "3"
                  ExpressionStatement
                     Gas costs: 0
                     Source: "c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3)"
                    Assignment using operator =
                       Type: uint256
                       Source: "c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3)"
                      MemberAccess to member yearlyAmountEth
                         Type: uint256
                         Source: "c.yearlyAmountEth"
                        Identifier c
                           Type: struct Games.CommonAttr storage ref
                           Source: "c"
                      FunctionCall
                         Type: uint256
                         Source: "add(c.yearlyAmountEth,rewardDiv100 * 3)"
                        Identifier add
                           Type: function (uint256,uint256) view returns (uint256)
                           Source: "add"
                        MemberAccess to member yearlyAmountEth
                           Type: uint256
                           Source: "c.yearlyAmountEth"
                          Identifier c
                             Type: struct Games.CommonAttr storage ref
                             Source: "c"
                        BinaryOperation using operator *
                           Type: uint256
                           Source: "rewardDiv100 * 3"
                          Identifier rewardDiv100
                             Type: uint256
                             Source: "rewardDiv100"
                          Literal, token: [no token] value: 3
                             Type: int_const 3
                             Source: "3"
          ExpressionStatement
             Gas costs: 0
             Source: "c.charityAmountEth = add(c.charityAmountEth,rewardDiv100 * 4)"
            Assignment using operator =
               Type: uint256
               Source: "c.charityAmountEth = add(c.charityAmountEth,rewardDiv100 * 4)"
              MemberAccess to member charityAmountEth
                 Type: uint256
                 Source: "c.charityAmountEth"
                Identifier c
                   Type: struct Games.CommonAttr storage ref
                   Source: "c"
              FunctionCall
                 Type: uint256
                 Source: "add(c.charityAmountEth,rewardDiv100 * 4)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                MemberAccess to member charityAmountEth
                   Type: uint256
                   Source: "c.charityAmountEth"
                  Identifier c
                     Type: struct Games.CommonAttr storage ref
                     Source: "c"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "rewardDiv100 * 4"
                  Identifier rewardDiv100
                     Type: uint256
                     Source: "rewardDiv100"
                  Literal, token: [no token] value: 4
                     Type: int_const 4
                     Source: "4"
          ExpressionStatement
             Gas costs: 0
             Source: "winners[d.currentYear][participants[luckyNumber].sender] = add(winners[d.currentYear][participants[luckyNumber].sender],rewardDiv100*100)"
            Assignment using operator =
               Type: uint256
               Source: "winners[d.currentYear][participants[luckyNumber].sender] = add(winners[d.currentYear][participants[luckyNumber].sender],rewardDiv100*100)"
              IndexAccess
                 Type: uint256
                 Source: "winners[d.currentYear][participants[luckyNumber].sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "winners[d.currentYear]"
                  Identifier winners
                     Type: mapping(uint256 => mapping(address => uint256))
                     Source: "winners"
                  MemberAccess to member currentYear
                     Type: uint256
                     Source: "d.currentYear"
                    Identifier d
                       Type: struct Games.DateAttr storage ref
                       Source: "d"
                MemberAccess to member sender
                   Type: address
                   Source: "participants[luckyNumber].sender"
                  IndexAccess
                     Type: struct Games.Participant storage ref
                     Source: "participants[luckyNumber]"
                    Identifier participants
                       Type: struct Games.Participant storage ref[] storage ref
                       Source: "participants"
                    Identifier luckyNumber
                       Type: uint256
                       Source: "luckyNumber"
              FunctionCall
                 Type: uint256
                 Source: "add(winners[d.currentYear][participants[luckyNumber].sender],rewardDiv100*100)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                IndexAccess
                   Type: uint256
                   Source: "winners[d.currentYear][participants[luckyNumber].sender]"
                  IndexAccess
                     Type: mapping(address => uint256)
                     Source: "winners[d.currentYear]"
                    Identifier winners
                       Type: mapping(uint256 => mapping(address => uint256))
                       Source: "winners"
                    MemberAccess to member currentYear
                       Type: uint256
                       Source: "d.currentYear"
                      Identifier d
                         Type: struct Games.DateAttr storage ref
                         Source: "d"
                  MemberAccess to member sender
                     Type: address
                     Source: "participants[luckyNumber].sender"
                    IndexAccess
                       Type: struct Games.Participant storage ref
                       Source: "participants[luckyNumber]"
                      Identifier participants
                         Type: struct Games.Participant storage ref[] storage ref
                         Source: "participants"
                      Identifier luckyNumber
                         Type: uint256
                         Source: "luckyNumber"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "rewardDiv100*100"
                  Identifier rewardDiv100
                     Type: uint256
                     Source: "rewardDiv100"
                  Literal, token: [no token] value: 100
                     Type: int_const 100
                     Source: "100"
          ExpressionStatement
             Gas costs: 0
             Source: "winPrizes[d.currentYear] = add(winPrizes[d.currentYear],rewardDiv100*100)"
            Assignment using operator =
               Type: uint256
               Source: "winPrizes[d.currentYear] = add(winPrizes[d.currentYear],rewardDiv100*100)"
              IndexAccess
                 Type: uint256
                 Source: "winPrizes[d.currentYear]"
                Identifier winPrizes
                   Type: mapping(uint256 => uint256)
                   Source: "winPrizes"
                MemberAccess to member currentYear
                   Type: uint256
                   Source: "d.currentYear"
                  Identifier d
                     Type: struct Games.DateAttr storage ref
                     Source: "d"
              FunctionCall
                 Type: uint256
                 Source: "add(winPrizes[d.currentYear],rewardDiv100*100)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                IndexAccess
                   Type: uint256
                   Source: "winPrizes[d.currentYear]"
                  Identifier winPrizes
                     Type: mapping(uint256 => uint256)
                     Source: "winPrizes"
                  MemberAccess to member currentYear
                     Type: uint256
                     Source: "d.currentYear"
                    Identifier d
                       Type: struct Games.DateAttr storage ref
                       Source: "d"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "rewardDiv100*100"
                  Identifier rewardDiv100
                     Type: uint256
                     Source: "rewardDiv100"
                  Literal, token: [no token] value: 100
                     Type: int_const 100
                     Source: "100"
          ExpressionStatement
             Gas costs: 0
             Source: "LogSelectWinner(rand, luckyNumber, participants[luckyNumber].sender, rewardDiv100*100, participants[luckyNumber].currency, participants[luckyNumber].value)"
            FunctionCall
               Type: tuple()
               Source: "LogSelectWinner(rand, luckyNumber, participants[luckyNumber].sender, rewardDiv100*100, participants[luckyNumber].currency, participants[luckyNumber].value)"
              Identifier LogSelectWinner
                 Type: function (uint256,uint256,address,uint256,uint256,uint256)
                 Source: "LogSelectWinner"
              Identifier rand
                 Type: uint256
                 Source: "rand"
              Identifier luckyNumber
                 Type: uint256
                 Source: "luckyNumber"
              MemberAccess to member sender
                 Type: address
                 Source: "participants[luckyNumber].sender"
                IndexAccess
                   Type: struct Games.Participant storage ref
                   Source: "participants[luckyNumber]"
                  Identifier participants
                     Type: struct Games.Participant storage ref[] storage ref
                     Source: "participants"
                  Identifier luckyNumber
                     Type: uint256
                     Source: "luckyNumber"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "rewardDiv100*100"
                Identifier rewardDiv100
                   Type: uint256
                   Source: "rewardDiv100"
                Literal, token: [no token] value: 100
                   Type: int_const 100
                   Source: "100"
              MemberAccess to member currency
                 Type: uint256
                 Source: "participants[luckyNumber].currency"
                IndexAccess
                   Type: struct Games.Participant storage ref
                   Source: "participants[luckyNumber]"
                  Identifier participants
                     Type: struct Games.Participant storage ref[] storage ref
                     Source: "participants"
                  Identifier luckyNumber
                     Type: uint256
                     Source: "luckyNumber"
              MemberAccess to member value
                 Type: uint256
                 Source: "participants[luckyNumber].value"
                IndexAccess
                   Type: struct Games.Participant storage ref
                   Source: "participants[luckyNumber]"
                  Identifier participants
                     Type: struct Games.Participant storage ref[] storage ref
                     Source: "participants"
                  Identifier luckyNumber
                     Type: uint256
                     Source: "luckyNumber"
          ExpressionStatement
             Gas costs: 0
             Source: "participants.length = 0"
            Assignment using operator =
               Type: uint256
               Source: "participants.length = 0"
              MemberAccess to member length
                 Type: uint256
                 Source: "participants.length"
                Identifier participants
                   Type: struct Games.Participant storage ref[] storage ref
                   Source: "participants"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      IfStatement
         Source: "if(c.gameType == GameType.Range){\r\n            refreshGameTime();\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "c.gameType == GameType.Range"
          MemberAccess to member gameType
             Type: enum Games.GameType
             Source: "c.gameType"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
          MemberAccess to member Range
             Type: enum Games.GameType
             Source: "GameType.Range"
            Identifier GameType
               Type: type(enum Games.GameType)
               Source: "GameType"
        Block
           Source: "{\r\n            refreshGameTime();\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "refreshGameTime()"
            FunctionCall
               Type: tuple()
               Source: "refreshGameTime()"
              Identifier refreshGameTime
                 Type: function ()
                 Source: "refreshGameTime"
      ExpressionStatement
         Gas costs: 0
         Source: "gcFundAmount()"
        FunctionCall
           Type: tuple()
           Source: "gcFundAmount()"
          Identifier gcFundAmount
             Type: function ()
             Source: "gcFundAmount"
  FunctionDefinition "getPrize" - public
     Source: "function getPrize(address sender) onlyOwner returns (uint ethPrize, uint tokPrize) {\r\n        ethPrize = add(winners[d.currentYear][sender],winners[d.currentYear-1][sender]);\r\n        tokPrize = add(tokTakers[d.currentYear][sender],tokTakers[d.currentYear-1][sender]);\r\n\r\n        winPrizes[d.currentYear] = sub(winPrizes[d.currentYear],winners[d.currentYear][sender]);\r\n        tokPrizes[d.currentYear] = sub(tokPrizes[d.currentYear],tokTakers[d.currentYear][sender]);\r\n        winners[d.currentYear][sender] = 0;\r\n        tokTakers[d.currentYear][sender] = 0;\r\n\r\n        winPrizes[d.currentYear-1] = sub(winPrizes[d.currentYear-1],winners[d.currentYear-1][sender]);\r\n        tokPrizes[d.currentYear-1] = sub(tokPrizes[d.currentYear-1],tokTakers[d.currentYear-1][sender]);\r\n        winners[d.currentYear-1][sender] = 0;\r\n        tokTakers[d.currentYear-1][sender] = 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address sender)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint ethPrize, uint tokPrize)"
      VariableDeclaration "ethPrize"
         Type: uint256
         Source: "uint ethPrize"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "tokPrize"
         Type: uint256
         Source: "uint tokPrize"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        ethPrize = add(winners[d.currentYear][sender],winners[d.currentYear-1][sender]);\r\n        tokPrize = add(tokTakers[d.currentYear][sender],tokTakers[d.currentYear-1][sender]);\r\n\r\n        winPrizes[d.currentYear] = sub(winPrizes[d.currentYear],winners[d.currentYear][sender]);\r\n        tokPrizes[d.currentYear] = sub(tokPrizes[d.currentYear],tokTakers[d.currentYear][sender]);\r\n        winners[d.currentYear][sender] = 0;\r\n        tokTakers[d.currentYear][sender] = 0;\r\n\r\n        winPrizes[d.currentYear-1] = sub(winPrizes[d.currentYear-1],winners[d.currentYear-1][sender]);\r\n        tokPrizes[d.currentYear-1] = sub(tokPrizes[d.currentYear-1],tokTakers[d.currentYear-1][sender]);\r\n        winners[d.currentYear-1][sender] = 0;\r\n        tokTakers[d.currentYear-1][sender] = 0;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "ethPrize = add(winners[d.currentYear][sender],winners[d.currentYear-1][sender])"
        Assignment using operator =
           Type: uint256
           Source: "ethPrize = add(winners[d.currentYear][sender],winners[d.currentYear-1][sender])"
          Identifier ethPrize
             Type: uint256
             Source: "ethPrize"
          FunctionCall
             Type: uint256
             Source: "add(winners[d.currentYear][sender],winners[d.currentYear-1][sender])"
            Identifier add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "add"
            IndexAccess
               Type: uint256
               Source: "winners[d.currentYear][sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "winners[d.currentYear]"
                Identifier winners
                   Type: mapping(uint256 => mapping(address => uint256))
                   Source: "winners"
                MemberAccess to member currentYear
                   Type: uint256
                   Source: "d.currentYear"
                  Identifier d
                     Type: struct Games.DateAttr storage ref
                     Source: "d"
              Identifier sender
                 Type: address
                 Source: "sender"
            IndexAccess
               Type: uint256
               Source: "winners[d.currentYear-1][sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "winners[d.currentYear-1]"
                Identifier winners
                   Type: mapping(uint256 => mapping(address => uint256))
                   Source: "winners"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "d.currentYear-1"
                  MemberAccess to member currentYear
                     Type: uint256
                     Source: "d.currentYear"
                    Identifier d
                       Type: struct Games.DateAttr storage ref
                       Source: "d"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              Identifier sender
                 Type: address
                 Source: "sender"
      ExpressionStatement
         Gas costs: 0
         Source: "tokPrize = add(tokTakers[d.currentYear][sender],tokTakers[d.currentYear-1][sender])"
        Assignment using operator =
           Type: uint256
           Source: "tokPrize = add(tokTakers[d.currentYear][sender],tokTakers[d.currentYear-1][sender])"
          Identifier tokPrize
             Type: uint256
             Source: "tokPrize"
          FunctionCall
             Type: uint256
             Source: "add(tokTakers[d.currentYear][sender],tokTakers[d.currentYear-1][sender])"
            Identifier add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "add"
            IndexAccess
               Type: uint256
               Source: "tokTakers[d.currentYear][sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "tokTakers[d.currentYear]"
                Identifier tokTakers
                   Type: mapping(uint256 => mapping(address => uint256))
                   Source: "tokTakers"
                MemberAccess to member currentYear
                   Type: uint256
                   Source: "d.currentYear"
                  Identifier d
                     Type: struct Games.DateAttr storage ref
                     Source: "d"
              Identifier sender
                 Type: address
                 Source: "sender"
            IndexAccess
               Type: uint256
               Source: "tokTakers[d.currentYear-1][sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "tokTakers[d.currentYear-1]"
                Identifier tokTakers
                   Type: mapping(uint256 => mapping(address => uint256))
                   Source: "tokTakers"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "d.currentYear-1"
                  MemberAccess to member currentYear
                     Type: uint256
                     Source: "d.currentYear"
                    Identifier d
                       Type: struct Games.DateAttr storage ref
                       Source: "d"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              Identifier sender
                 Type: address
                 Source: "sender"
      ExpressionStatement
         Gas costs: 0
         Source: "winPrizes[d.currentYear] = sub(winPrizes[d.currentYear],winners[d.currentYear][sender])"
        Assignment using operator =
           Type: uint256
           Source: "winPrizes[d.currentYear] = sub(winPrizes[d.currentYear],winners[d.currentYear][sender])"
          IndexAccess
             Type: uint256
             Source: "winPrizes[d.currentYear]"
            Identifier winPrizes
               Type: mapping(uint256 => uint256)
               Source: "winPrizes"
            MemberAccess to member currentYear
               Type: uint256
               Source: "d.currentYear"
              Identifier d
                 Type: struct Games.DateAttr storage ref
                 Source: "d"
          FunctionCall
             Type: uint256
             Source: "sub(winPrizes[d.currentYear],winners[d.currentYear][sender])"
            Identifier sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "sub"
            IndexAccess
               Type: uint256
               Source: "winPrizes[d.currentYear]"
              Identifier winPrizes
                 Type: mapping(uint256 => uint256)
                 Source: "winPrizes"
              MemberAccess to member currentYear
                 Type: uint256
                 Source: "d.currentYear"
                Identifier d
                   Type: struct Games.DateAttr storage ref
                   Source: "d"
            IndexAccess
               Type: uint256
               Source: "winners[d.currentYear][sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "winners[d.currentYear]"
                Identifier winners
                   Type: mapping(uint256 => mapping(address => uint256))
                   Source: "winners"
                MemberAccess to member currentYear
                   Type: uint256
                   Source: "d.currentYear"
                  Identifier d
                     Type: struct Games.DateAttr storage ref
                     Source: "d"
              Identifier sender
                 Type: address
                 Source: "sender"
      ExpressionStatement
         Gas costs: 0
         Source: "tokPrizes[d.currentYear] = sub(tokPrizes[d.currentYear],tokTakers[d.currentYear][sender])"
        Assignment using operator =
           Type: uint256
           Source: "tokPrizes[d.currentYear] = sub(tokPrizes[d.currentYear],tokTakers[d.currentYear][sender])"
          IndexAccess
             Type: uint256
             Source: "tokPrizes[d.currentYear]"
            Identifier tokPrizes
               Type: mapping(uint256 => uint256)
               Source: "tokPrizes"
            MemberAccess to member currentYear
               Type: uint256
               Source: "d.currentYear"
              Identifier d
                 Type: struct Games.DateAttr storage ref
                 Source: "d"
          FunctionCall
             Type: uint256
             Source: "sub(tokPrizes[d.currentYear],tokTakers[d.currentYear][sender])"
            Identifier sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "sub"
            IndexAccess
               Type: uint256
               Source: "tokPrizes[d.currentYear]"
              Identifier tokPrizes
                 Type: mapping(uint256 => uint256)
                 Source: "tokPrizes"
              MemberAccess to member currentYear
                 Type: uint256
                 Source: "d.currentYear"
                Identifier d
                   Type: struct Games.DateAttr storage ref
                   Source: "d"
            IndexAccess
               Type: uint256
               Source: "tokTakers[d.currentYear][sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "tokTakers[d.currentYear]"
                Identifier tokTakers
                   Type: mapping(uint256 => mapping(address => uint256))
                   Source: "tokTakers"
                MemberAccess to member currentYear
                   Type: uint256
                   Source: "d.currentYear"
                  Identifier d
                     Type: struct Games.DateAttr storage ref
                     Source: "d"
              Identifier sender
                 Type: address
                 Source: "sender"
      ExpressionStatement
         Gas costs: 0
         Source: "winners[d.currentYear][sender] = 0"
        Assignment using operator =
           Type: uint256
           Source: "winners[d.currentYear][sender] = 0"
          IndexAccess
             Type: uint256
             Source: "winners[d.currentYear][sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "winners[d.currentYear]"
              Identifier winners
                 Type: mapping(uint256 => mapping(address => uint256))
                 Source: "winners"
              MemberAccess to member currentYear
                 Type: uint256
                 Source: "d.currentYear"
                Identifier d
                   Type: struct Games.DateAttr storage ref
                   Source: "d"
            Identifier sender
               Type: address
               Source: "sender"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "tokTakers[d.currentYear][sender] = 0"
        Assignment using operator =
           Type: uint256
           Source: "tokTakers[d.currentYear][sender] = 0"
          IndexAccess
             Type: uint256
             Source: "tokTakers[d.currentYear][sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "tokTakers[d.currentYear]"
              Identifier tokTakers
                 Type: mapping(uint256 => mapping(address => uint256))
                 Source: "tokTakers"
              MemberAccess to member currentYear
                 Type: uint256
                 Source: "d.currentYear"
                Identifier d
                   Type: struct Games.DateAttr storage ref
                   Source: "d"
            Identifier sender
               Type: address
               Source: "sender"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "winPrizes[d.currentYear-1] = sub(winPrizes[d.currentYear-1],winners[d.currentYear-1][sender])"
        Assignment using operator =
           Type: uint256
           Source: "winPrizes[d.currentYear-1] = sub(winPrizes[d.currentYear-1],winners[d.currentYear-1][sender])"
          IndexAccess
             Type: uint256
             Source: "winPrizes[d.currentYear-1]"
            Identifier winPrizes
               Type: mapping(uint256 => uint256)
               Source: "winPrizes"
            BinaryOperation using operator -
               Type: uint256
               Source: "d.currentYear-1"
              MemberAccess to member currentYear
                 Type: uint256
                 Source: "d.currentYear"
                Identifier d
                   Type: struct Games.DateAttr storage ref
                   Source: "d"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          FunctionCall
             Type: uint256
             Source: "sub(winPrizes[d.currentYear-1],winners[d.currentYear-1][sender])"
            Identifier sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "sub"
            IndexAccess
               Type: uint256
               Source: "winPrizes[d.currentYear-1]"
              Identifier winPrizes
                 Type: mapping(uint256 => uint256)
                 Source: "winPrizes"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "d.currentYear-1"
                MemberAccess to member currentYear
                   Type: uint256
                   Source: "d.currentYear"
                  Identifier d
                     Type: struct Games.DateAttr storage ref
                     Source: "d"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
            IndexAccess
               Type: uint256
               Source: "winners[d.currentYear-1][sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "winners[d.currentYear-1]"
                Identifier winners
                   Type: mapping(uint256 => mapping(address => uint256))
                   Source: "winners"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "d.currentYear-1"
                  MemberAccess to member currentYear
                     Type: uint256
                     Source: "d.currentYear"
                    Identifier d
                       Type: struct Games.DateAttr storage ref
                       Source: "d"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              Identifier sender
                 Type: address
                 Source: "sender"
      ExpressionStatement
         Gas costs: 0
         Source: "tokPrizes[d.currentYear-1] = sub(tokPrizes[d.currentYear-1],tokTakers[d.currentYear-1][sender])"
        Assignment using operator =
           Type: uint256
           Source: "tokPrizes[d.currentYear-1] = sub(tokPrizes[d.currentYear-1],tokTakers[d.currentYear-1][sender])"
          IndexAccess
             Type: uint256
             Source: "tokPrizes[d.currentYear-1]"
            Identifier tokPrizes
               Type: mapping(uint256 => uint256)
               Source: "tokPrizes"
            BinaryOperation using operator -
               Type: uint256
               Source: "d.currentYear-1"
              MemberAccess to member currentYear
                 Type: uint256
                 Source: "d.currentYear"
                Identifier d
                   Type: struct Games.DateAttr storage ref
                   Source: "d"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          FunctionCall
             Type: uint256
             Source: "sub(tokPrizes[d.currentYear-1],tokTakers[d.currentYear-1][sender])"
            Identifier sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "sub"
            IndexAccess
               Type: uint256
               Source: "tokPrizes[d.currentYear-1]"
              Identifier tokPrizes
                 Type: mapping(uint256 => uint256)
                 Source: "tokPrizes"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "d.currentYear-1"
                MemberAccess to member currentYear
                   Type: uint256
                   Source: "d.currentYear"
                  Identifier d
                     Type: struct Games.DateAttr storage ref
                     Source: "d"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
            IndexAccess
               Type: uint256
               Source: "tokTakers[d.currentYear-1][sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "tokTakers[d.currentYear-1]"
                Identifier tokTakers
                   Type: mapping(uint256 => mapping(address => uint256))
                   Source: "tokTakers"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "d.currentYear-1"
                  MemberAccess to member currentYear
                     Type: uint256
                     Source: "d.currentYear"
                    Identifier d
                       Type: struct Games.DateAttr storage ref
                       Source: "d"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              Identifier sender
                 Type: address
                 Source: "sender"
      ExpressionStatement
         Gas costs: 0
         Source: "winners[d.currentYear-1][sender] = 0"
        Assignment using operator =
           Type: uint256
           Source: "winners[d.currentYear-1][sender] = 0"
          IndexAccess
             Type: uint256
             Source: "winners[d.currentYear-1][sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "winners[d.currentYear-1]"
              Identifier winners
                 Type: mapping(uint256 => mapping(address => uint256))
                 Source: "winners"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "d.currentYear-1"
                MemberAccess to member currentYear
                   Type: uint256
                   Source: "d.currentYear"
                  Identifier d
                     Type: struct Games.DateAttr storage ref
                     Source: "d"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
            Identifier sender
               Type: address
               Source: "sender"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "tokTakers[d.currentYear-1][sender] = 0"
        Assignment using operator =
           Type: uint256
           Source: "tokTakers[d.currentYear-1][sender] = 0"
          IndexAccess
             Type: uint256
             Source: "tokTakers[d.currentYear-1][sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "tokTakers[d.currentYear-1]"
              Identifier tokTakers
                 Type: mapping(uint256 => mapping(address => uint256))
                 Source: "tokTakers"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "d.currentYear-1"
                MemberAccess to member currentYear
                   Type: uint256
                   Source: "d.currentYear"
                  Identifier d
                     Type: struct Games.DateAttr storage ref
                     Source: "d"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
            Identifier sender
               Type: address
               Source: "sender"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "PointGameProcess"
     Source: "function PointGameProcess(address sender, uint sendValue) private beforePointGame {\r\n        if(c.currentGameTimeType == GameTime.Year){\r\n            c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue);\r\n            f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Month){\r\n            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\r\n            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }\r\n\r\n        PointGameParticipate(sender, sendValue, 1);\r\n        \r\n        if(p.bonusPerEth != 0){\r\n            tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth);\r\n            tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address sender, uint sendValue)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "sendValue"
         Type: uint256
         Source: "uint sendValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "beforePointGame"
       Gas costs: 0
       Source: "beforePointGame"
      Identifier beforePointGame
         Type: modifier ()
         Source: "beforePointGame"
    Block
       Source: "{\r\n        if(c.currentGameTimeType == GameTime.Year){\r\n            c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue);\r\n            f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Month){\r\n            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\r\n            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }\r\n\r\n        PointGameParticipate(sender, sendValue, 1);\r\n        \r\n        if(p.bonusPerEth != 0){\r\n            tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth);\r\n            tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth);\r\n        }\r\n    }"
      IfStatement
         Source: "if(c.currentGameTimeType == GameTime.Year){\r\n            c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue);\r\n            f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Month){\r\n            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\r\n            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "c.currentGameTimeType == GameTime.Year"
          MemberAccess to member currentGameTimeType
             Type: enum Games.GameTime
             Source: "c.currentGameTimeType"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
          MemberAccess to member Year
             Type: enum Games.GameTime
             Source: "GameTime.Year"
            Identifier GameTime
               Type: type(enum Games.GameTime)
               Source: "GameTime"
        Block
           Source: "{\r\n            c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue);\r\n            f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue)"
            Assignment using operator =
               Type: uint256
               Source: "c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue)"
              MemberAccess to member yearlyAmountEth
                 Type: uint256
                 Source: "c.yearlyAmountEth"
                Identifier c
                   Type: struct Games.CommonAttr storage ref
                   Source: "c"
              FunctionCall
                 Type: uint256
                 Source: "add(c.yearlyAmountEth, sendValue)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                MemberAccess to member yearlyAmountEth
                   Type: uint256
                   Source: "c.yearlyAmountEth"
                  Identifier c
                     Type: struct Games.CommonAttr storage ref
                     Source: "c"
                Identifier sendValue
                   Type: uint256
                   Source: "sendValue"
          ExpressionStatement
             Gas costs: 0
             Source: "f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue)"
            Assignment using operator =
               Type: uint256
               Source: "f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue)"
              MemberAccess to member yearlyStatusEth
                 Type: uint256
                 Source: "f.yearlyStatusEth"
                Identifier f
                   Type: struct Games.FundAmountStatusAttr storage ref
                   Source: "f"
              FunctionCall
                 Type: uint256
                 Source: "add(f.yearlyStatusEth, sendValue)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                MemberAccess to member yearlyStatusEth
                   Type: uint256
                   Source: "f.yearlyStatusEth"
                  Identifier f
                     Type: struct Games.FundAmountStatusAttr storage ref
                     Source: "f"
                Identifier sendValue
                   Type: uint256
                   Source: "sendValue"
        IfStatement
           Source: "if(c.currentGameTimeType == GameTime.Month){\r\n            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\r\n            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 0
             Source: "c.currentGameTimeType == GameTime.Month"
            MemberAccess to member currentGameTimeType
               Type: enum Games.GameTime
               Source: "c.currentGameTimeType"
              Identifier c
                 Type: struct Games.CommonAttr storage ref
                 Source: "c"
            MemberAccess to member Month
               Type: enum Games.GameTime
               Source: "GameTime.Month"
              Identifier GameTime
                 Type: type(enum Games.GameTime)
                 Source: "GameTime"
          Block
             Source: "{\r\n            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\r\n            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\r\n        }"
            ExpressionStatement
               Gas costs: 0
               Source: "c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue)"
              Assignment using operator =
                 Type: uint256
                 Source: "c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue)"
                MemberAccess to member monthlyAmountEth
                   Type: uint256
                   Source: "c.monthlyAmountEth"
                  Identifier c
                     Type: struct Games.CommonAttr storage ref
                     Source: "c"
                FunctionCall
                   Type: uint256
                   Source: "add(c.monthlyAmountEth, sendValue)"
                  Identifier add
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "add"
                  MemberAccess to member monthlyAmountEth
                     Type: uint256
                     Source: "c.monthlyAmountEth"
                    Identifier c
                       Type: struct Games.CommonAttr storage ref
                       Source: "c"
                  Identifier sendValue
                     Type: uint256
                     Source: "sendValue"
            ExpressionStatement
               Gas costs: 0
               Source: "f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue)"
              Assignment using operator =
                 Type: uint256
                 Source: "f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue)"
                MemberAccess to member monthlyStatusEth
                   Type: uint256
                   Source: "f.monthlyStatusEth"
                  Identifier f
                     Type: struct Games.FundAmountStatusAttr storage ref
                     Source: "f"
                FunctionCall
                   Type: uint256
                   Source: "add(f.monthlyStatusEth, sendValue)"
                  Identifier add
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "add"
                  MemberAccess to member monthlyStatusEth
                     Type: uint256
                     Source: "f.monthlyStatusEth"
                    Identifier f
                       Type: struct Games.FundAmountStatusAttr storage ref
                       Source: "f"
                  Identifier sendValue
                     Type: uint256
                     Source: "sendValue"
          IfStatement
             Source: "if(c.currentGameTimeType == GameTime.Hour){\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "c.currentGameTimeType == GameTime.Hour"
              MemberAccess to member currentGameTimeType
                 Type: enum Games.GameTime
                 Source: "c.currentGameTimeType"
                Identifier c
                   Type: struct Games.CommonAttr storage ref
                   Source: "c"
              MemberAccess to member Hour
                 Type: enum Games.GameTime
                 Source: "GameTime.Hour"
                Identifier GameTime
                   Type: type(enum Games.GameTime)
                   Source: "GameTime"
            Block
               Source: "{\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue)"
                Assignment using operator =
                   Type: uint256
                   Source: "c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue)"
                  MemberAccess to member hourlyAmountEth
                     Type: uint256
                     Source: "c.hourlyAmountEth"
                    Identifier c
                       Type: struct Games.CommonAttr storage ref
                       Source: "c"
                  FunctionCall
                     Type: uint256
                     Source: "add(c.hourlyAmountEth, sendValue)"
                    Identifier add
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "add"
                    MemberAccess to member hourlyAmountEth
                       Type: uint256
                       Source: "c.hourlyAmountEth"
                      Identifier c
                         Type: struct Games.CommonAttr storage ref
                         Source: "c"
                    Identifier sendValue
                       Type: uint256
                       Source: "sendValue"
              ExpressionStatement
                 Gas costs: 0
                 Source: "f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue)"
                Assignment using operator =
                   Type: uint256
                   Source: "f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue)"
                  MemberAccess to member hourlyStatusEth
                     Type: uint256
                     Source: "f.hourlyStatusEth"
                    Identifier f
                       Type: struct Games.FundAmountStatusAttr storage ref
                       Source: "f"
                  FunctionCall
                     Type: uint256
                     Source: "add(f.hourlyStatusEth, sendValue)"
                    Identifier add
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "add"
                    MemberAccess to member hourlyStatusEth
                       Type: uint256
                       Source: "f.hourlyStatusEth"
                      Identifier f
                         Type: struct Games.FundAmountStatusAttr storage ref
                         Source: "f"
                    Identifier sendValue
                       Type: uint256
                       Source: "sendValue"
      ExpressionStatement
         Gas costs: 0
         Source: "PointGameParticipate(sender, sendValue, 1)"
        FunctionCall
           Type: tuple()
           Source: "PointGameParticipate(sender, sendValue, 1)"
          Identifier PointGameParticipate
             Type: function (address,uint256,uint256)
             Source: "PointGameParticipate"
          Identifier sender
             Type: address
             Source: "sender"
          Identifier sendValue
             Type: uint256
             Source: "sendValue"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      IfStatement
         Source: "if(p.bonusPerEth != 0){\r\n            tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth);\r\n            tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth);\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "p.bonusPerEth != 0"
          MemberAccess to member bonusPerEth
             Type: uint256
             Source: "p.bonusPerEth"
            Identifier p
               Type: struct Games.PriceAttr storage ref
               Source: "p"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth);\r\n            tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth)"
            Assignment using operator =
               Type: uint256
               Source: "tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth)"
              IndexAccess
                 Type: uint256
                 Source: "tokTakers[d.currentYear][sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "tokTakers[d.currentYear]"
                  Identifier tokTakers
                     Type: mapping(uint256 => mapping(address => uint256))
                     Source: "tokTakers"
                  MemberAccess to member currentYear
                     Type: uint256
                     Source: "d.currentYear"
                    Identifier d
                       Type: struct Games.DateAttr storage ref
                       Source: "d"
                Identifier sender
                   Type: address
                   Source: "sender"
              FunctionCall
                 Type: uint256
                 Source: "add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                IndexAccess
                   Type: uint256
                   Source: "tokTakers[d.currentYear][sender]"
                  IndexAccess
                     Type: mapping(address => uint256)
                     Source: "tokTakers[d.currentYear]"
                    Identifier tokTakers
                       Type: mapping(uint256 => mapping(address => uint256))
                       Source: "tokTakers"
                    MemberAccess to member currentYear
                       Type: uint256
                       Source: "d.currentYear"
                      Identifier d
                         Type: struct Games.DateAttr storage ref
                         Source: "d"
                  Identifier sender
                     Type: address
                     Source: "sender"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "sendValue * p.bonusPerEth"
                  Identifier sendValue
                     Type: uint256
                     Source: "sendValue"
                  MemberAccess to member bonusPerEth
                     Type: uint256
                     Source: "p.bonusPerEth"
                    Identifier p
                       Type: struct Games.PriceAttr storage ref
                       Source: "p"
          ExpressionStatement
             Gas costs: 0
             Source: "tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth)"
            Assignment using operator =
               Type: uint256
               Source: "tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth)"
              IndexAccess
                 Type: uint256
                 Source: "tokPrizes[d.currentYear]"
                Identifier tokPrizes
                   Type: mapping(uint256 => uint256)
                   Source: "tokPrizes"
                MemberAccess to member currentYear
                   Type: uint256
                   Source: "d.currentYear"
                  Identifier d
                     Type: struct Games.DateAttr storage ref
                     Source: "d"
              FunctionCall
                 Type: uint256
                 Source: "add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                IndexAccess
                   Type: uint256
                   Source: "tokPrizes[d.currentYear]"
                  Identifier tokPrizes
                     Type: mapping(uint256 => uint256)
                     Source: "tokPrizes"
                  MemberAccess to member currentYear
                     Type: uint256
                     Source: "d.currentYear"
                    Identifier d
                       Type: struct Games.DateAttr storage ref
                       Source: "d"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "sendValue * p.bonusPerEth"
                  Identifier sendValue
                     Type: uint256
                     Source: "sendValue"
                  MemberAccess to member bonusPerEth
                     Type: uint256
                     Source: "p.bonusPerEth"
                    Identifier p
                       Type: struct Games.PriceAttr storage ref
                       Source: "p"
  FunctionDefinition "PointGameWithITG"
     Source: "function PointGameWithITG(address sender, uint tokenAmountToGame) private beforePointGame {\r\n        require(c.currentGameTimeType != GameTime.Year);\r\n\r\n        if(c.currentGameTimeType == GameTime.Month){\r\n            f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\r\n        }\r\n\r\n        PointGameParticipate(sender, tokenAmountToGame, 2);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address sender, uint tokenAmountToGame)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "tokenAmountToGame"
         Type: uint256
         Source: "uint tokenAmountToGame"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "beforePointGame"
       Gas costs: 0
       Source: "beforePointGame"
      Identifier beforePointGame
         Type: modifier ()
         Source: "beforePointGame"
    Block
       Source: "{\r\n        require(c.currentGameTimeType != GameTime.Year);\r\n\r\n        if(c.currentGameTimeType == GameTime.Month){\r\n            f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\r\n        }\r\n\r\n        PointGameParticipate(sender, tokenAmountToGame, 2);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(c.currentGameTimeType != GameTime.Year)"
        FunctionCall
           Type: tuple()
           Source: "require(c.currentGameTimeType != GameTime.Year)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "c.currentGameTimeType != GameTime.Year"
            MemberAccess to member currentGameTimeType
               Type: enum Games.GameTime
               Source: "c.currentGameTimeType"
              Identifier c
                 Type: struct Games.CommonAttr storage ref
                 Source: "c"
            MemberAccess to member Year
               Type: enum Games.GameTime
               Source: "GameTime.Year"
              Identifier GameTime
                 Type: type(enum Games.GameTime)
                 Source: "GameTime"
      IfStatement
         Source: "if(c.currentGameTimeType == GameTime.Month){\r\n            f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "c.currentGameTimeType == GameTime.Month"
          MemberAccess to member currentGameTimeType
             Type: enum Games.GameTime
             Source: "c.currentGameTimeType"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
          MemberAccess to member Month
             Type: enum Games.GameTime
             Source: "GameTime.Month"
            Identifier GameTime
               Type: type(enum Games.GameTime)
               Source: "GameTime"
        Block
           Source: "{\r\n            f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame)"
            Assignment using operator =
               Type: uint256
               Source: "f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame)"
              MemberAccess to member monthlyStatusTok
                 Type: uint256
                 Source: "f.monthlyStatusTok"
                Identifier f
                   Type: struct Games.FundAmountStatusAttr storage ref
                   Source: "f"
              FunctionCall
                 Type: uint256
                 Source: "add(f.monthlyStatusTok, tokenAmountToGame)"
                Identifier add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "add"
                MemberAccess to member monthlyStatusTok
                   Type: uint256
                   Source: "f.monthlyStatusTok"
                  Identifier f
                     Type: struct Games.FundAmountStatusAttr storage ref
                     Source: "f"
                Identifier tokenAmountToGame
                   Type: uint256
                   Source: "tokenAmountToGame"
        IfStatement
           Source: "if(c.currentGameTimeType == GameTime.Hour){\r\n            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\r\n        }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 0
             Source: "c.currentGameTimeType == GameTime.Hour"
            MemberAccess to member currentGameTimeType
               Type: enum Games.GameTime
               Source: "c.currentGameTimeType"
              Identifier c
                 Type: struct Games.CommonAttr storage ref
                 Source: "c"
            MemberAccess to member Hour
               Type: enum Games.GameTime
               Source: "GameTime.Hour"
              Identifier GameTime
                 Type: type(enum Games.GameTime)
                 Source: "GameTime"
          Block
             Source: "{\r\n            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\r\n        }"
            ExpressionStatement
               Gas costs: 0
               Source: "f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame)"
              Assignment using operator =
                 Type: uint256
                 Source: "f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame)"
                MemberAccess to member hourlyStatusTok
                   Type: uint256
                   Source: "f.hourlyStatusTok"
                  Identifier f
                     Type: struct Games.FundAmountStatusAttr storage ref
                     Source: "f"
                FunctionCall
                   Type: uint256
                   Source: "add(f.hourlyStatusTok, tokenAmountToGame)"
                  Identifier add
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "add"
                  MemberAccess to member hourlyStatusTok
                     Type: uint256
                     Source: "f.hourlyStatusTok"
                    Identifier f
                       Type: struct Games.FundAmountStatusAttr storage ref
                       Source: "f"
                  Identifier tokenAmountToGame
                     Type: uint256
                     Source: "tokenAmountToGame"
      ExpressionStatement
         Gas costs: 0
         Source: "PointGameParticipate(sender, tokenAmountToGame, 2)"
        FunctionCall
           Type: tuple()
           Source: "PointGameParticipate(sender, tokenAmountToGame, 2)"
          Identifier PointGameParticipate
             Type: function (address,uint256,uint256)
             Source: "PointGameParticipate"
          Identifier sender
             Type: address
             Source: "sender"
          Identifier tokenAmountToGame
             Type: uint256
             Source: "tokenAmountToGame"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
  FunctionDefinition "PointGameParticipate"
     Source: "function PointGameParticipate(address sender, uint sendValue, uint currency) private {\r\n        if(d.prevGameEnd != d.gameEnd){\r\n            selectWinner(1);\r\n        }\r\n        participants.length = 0;\r\n        participants.push(Participant(sender,sendValue,currency));\r\n\r\n        d.prevGameEnd = d.gameEnd;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address sender, uint sendValue, uint currency)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "sendValue"
         Type: uint256
         Source: "uint sendValue"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "currency"
         Type: uint256
         Source: "uint currency"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if(d.prevGameEnd != d.gameEnd){\r\n            selectWinner(1);\r\n        }\r\n        participants.length = 0;\r\n        participants.push(Participant(sender,sendValue,currency));\r\n\r\n        d.prevGameEnd = d.gameEnd;\r\n    }"
      IfStatement
         Source: "if(d.prevGameEnd != d.gameEnd){\r\n            selectWinner(1);\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "d.prevGameEnd != d.gameEnd"
          MemberAccess to member prevGameEnd
             Type: uint256
             Source: "d.prevGameEnd"
            Identifier d
               Type: struct Games.DateAttr storage ref
               Source: "d"
          MemberAccess to member gameEnd
             Type: uint256
             Source: "d.gameEnd"
            Identifier d
               Type: struct Games.DateAttr storage ref
               Source: "d"
        Block
           Source: "{\r\n            selectWinner(1);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "selectWinner(1)"
            FunctionCall
               Type: tuple()
               Source: "selectWinner(1)"
              Identifier selectWinner
                 Type: function (uint256)
                 Source: "selectWinner"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "participants.length = 0"
        Assignment using operator =
           Type: uint256
           Source: "participants.length = 0"
          MemberAccess to member length
             Type: uint256
             Source: "participants.length"
            Identifier participants
               Type: struct Games.Participant storage ref[] storage ref
               Source: "participants"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "participants.push(Participant(sender,sendValue,currency))"
        FunctionCall
           Type: uint256
           Source: "participants.push(Participant(sender,sendValue,currency))"
          MemberAccess to member push
             Type: function (struct Games.Participant storage ref) returns (uint256)
             Source: "participants.push"
            Identifier participants
               Type: struct Games.Participant storage ref[] storage ref
               Source: "participants"
          FunctionCall
             Type: struct Games.Participant memory
             Source: "Participant(sender,sendValue,currency)"
            Identifier Participant
               Type: type(struct Games.Participant storage pointer)
               Source: "Participant"
            Identifier sender
               Type: address
               Source: "sender"
            Identifier sendValue
               Type: uint256
               Source: "sendValue"
            Identifier currency
               Type: uint256
               Source: "currency"
      ExpressionStatement
         Gas costs: 0
         Source: "d.prevGameEnd = d.gameEnd"
        Assignment using operator =
           Type: uint256
           Source: "d.prevGameEnd = d.gameEnd"
          MemberAccess to member prevGameEnd
             Type: uint256
             Source: "d.prevGameEnd"
            Identifier d
               Type: struct Games.DateAttr storage ref
               Source: "d"
          MemberAccess to member gameEnd
             Type: uint256
             Source: "d.gameEnd"
            Identifier d
               Type: struct Games.DateAttr storage ref
               Source: "d"
  FunctionDefinition "lossToCharity" - public
     Source: "function lossToCharity(uint year) onlyOwner returns (uint amt) {\r\n        require(year < d.currentYear-1);\r\n        \r\n        amt = winPrizes[year];\r\n        tokPrizes[year] = 0;\r\n        winPrizes[year] = 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint year)"
      VariableDeclaration "year"
         Type: uint256
         Source: "uint year"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint amt)"
      VariableDeclaration "amt"
         Type: uint256
         Source: "uint amt"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(year < d.currentYear-1);\r\n        \r\n        amt = winPrizes[year];\r\n        tokPrizes[year] = 0;\r\n        winPrizes[year] = 0;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(year < d.currentYear-1)"
        FunctionCall
           Type: tuple()
           Source: "require(year < d.currentYear-1)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "year < d.currentYear-1"
            Identifier year
               Type: uint256
               Source: "year"
            BinaryOperation using operator -
               Type: uint256
               Source: "d.currentYear-1"
              MemberAccess to member currentYear
                 Type: uint256
                 Source: "d.currentYear"
                Identifier d
                   Type: struct Games.DateAttr storage ref
                   Source: "d"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "amt = winPrizes[year]"
        Assignment using operator =
           Type: uint256
           Source: "amt = winPrizes[year]"
          Identifier amt
             Type: uint256
             Source: "amt"
          IndexAccess
             Type: uint256
             Source: "winPrizes[year]"
            Identifier winPrizes
               Type: mapping(uint256 => uint256)
               Source: "winPrizes"
            Identifier year
               Type: uint256
               Source: "year"
      ExpressionStatement
         Gas costs: 0
         Source: "tokPrizes[year] = 0"
        Assignment using operator =
           Type: uint256
           Source: "tokPrizes[year] = 0"
          IndexAccess
             Type: uint256
             Source: "tokPrizes[year]"
            Identifier tokPrizes
               Type: mapping(uint256 => uint256)
               Source: "tokPrizes"
            Identifier year
               Type: uint256
               Source: "year"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "winPrizes[year] = 0"
        Assignment using operator =
           Type: uint256
           Source: "winPrizes[year] = 0"
          IndexAccess
             Type: uint256
             Source: "winPrizes[year]"
            Identifier winPrizes
               Type: mapping(uint256 => uint256)
               Source: "winPrizes"
            Identifier year
               Type: uint256
               Source: "year"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "charityAmtToCharity" - public
     Source: "function charityAmtToCharity() onlyOwner returns (uint amt) {\r\n        amt = c.charityAmountEth;\r\n        c.charityAmountEth = 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint amt)"
      VariableDeclaration "amt"
         Type: uint256
         Source: "uint amt"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        amt = c.charityAmountEth;\r\n        c.charityAmountEth = 0;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "amt = c.charityAmountEth"
        Assignment using operator =
           Type: uint256
           Source: "amt = c.charityAmountEth"
          Identifier amt
             Type: uint256
             Source: "amt"
          MemberAccess to member charityAmountEth
             Type: uint256
             Source: "c.charityAmountEth"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
      ExpressionStatement
         Gas costs: 0
         Source: "c.charityAmountEth = 0"
        Assignment using operator =
           Type: uint256
           Source: "c.charityAmountEth = 0"
          MemberAccess to member charityAmountEth
             Type: uint256
             Source: "c.charityAmountEth"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "distributeTokenSale" - public
     Source: "function distributeTokenSale(uint hour, uint month, uint year, uint charity) onlyOwner{\r\n        c.hourlyAmountEth = add(c.hourlyAmountEth, hour);\r\n        c.monthlyAmountEth = add(c.monthlyAmountEth, month);\r\n        c.yearlyAmountEth = add(c.yearlyAmountEth, year);\r\n        c.charityAmountEth = add(c.charityAmountEth, charity);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint hour, uint month, uint year, uint charity)"
      VariableDeclaration "hour"
         Type: uint256
         Source: "uint hour"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "month"
         Type: uint256
         Source: "uint month"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "year"
         Type: uint256
         Source: "uint year"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "charity"
         Type: uint256
         Source: "uint charity"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        c.hourlyAmountEth = add(c.hourlyAmountEth, hour);\r\n        c.monthlyAmountEth = add(c.monthlyAmountEth, month);\r\n        c.yearlyAmountEth = add(c.yearlyAmountEth, year);\r\n        c.charityAmountEth = add(c.charityAmountEth, charity);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "c.hourlyAmountEth = add(c.hourlyAmountEth, hour)"
        Assignment using operator =
           Type: uint256
           Source: "c.hourlyAmountEth = add(c.hourlyAmountEth, hour)"
          MemberAccess to member hourlyAmountEth
             Type: uint256
             Source: "c.hourlyAmountEth"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
          FunctionCall
             Type: uint256
             Source: "add(c.hourlyAmountEth, hour)"
            Identifier add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "add"
            MemberAccess to member hourlyAmountEth
               Type: uint256
               Source: "c.hourlyAmountEth"
              Identifier c
                 Type: struct Games.CommonAttr storage ref
                 Source: "c"
            Identifier hour
               Type: uint256
               Source: "hour"
      ExpressionStatement
         Gas costs: 0
         Source: "c.monthlyAmountEth = add(c.monthlyAmountEth, month)"
        Assignment using operator =
           Type: uint256
           Source: "c.monthlyAmountEth = add(c.monthlyAmountEth, month)"
          MemberAccess to member monthlyAmountEth
             Type: uint256
             Source: "c.monthlyAmountEth"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
          FunctionCall
             Type: uint256
             Source: "add(c.monthlyAmountEth, month)"
            Identifier add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "add"
            MemberAccess to member monthlyAmountEth
               Type: uint256
               Source: "c.monthlyAmountEth"
              Identifier c
                 Type: struct Games.CommonAttr storage ref
                 Source: "c"
            Identifier month
               Type: uint256
               Source: "month"
      ExpressionStatement
         Gas costs: 0
         Source: "c.yearlyAmountEth = add(c.yearlyAmountEth, year)"
        Assignment using operator =
           Type: uint256
           Source: "c.yearlyAmountEth = add(c.yearlyAmountEth, year)"
          MemberAccess to member yearlyAmountEth
             Type: uint256
             Source: "c.yearlyAmountEth"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
          FunctionCall
             Type: uint256
             Source: "add(c.yearlyAmountEth, year)"
            Identifier add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "add"
            MemberAccess to member yearlyAmountEth
               Type: uint256
               Source: "c.yearlyAmountEth"
              Identifier c
                 Type: struct Games.CommonAttr storage ref
                 Source: "c"
            Identifier year
               Type: uint256
               Source: "year"
      ExpressionStatement
         Gas costs: 0
         Source: "c.charityAmountEth = add(c.charityAmountEth, charity)"
        Assignment using operator =
           Type: uint256
           Source: "c.charityAmountEth = add(c.charityAmountEth, charity)"
          MemberAccess to member charityAmountEth
             Type: uint256
             Source: "c.charityAmountEth"
            Identifier c
               Type: struct Games.CommonAttr storage ref
               Source: "c"
          FunctionCall
             Type: uint256
             Source: "add(c.charityAmountEth, charity)"
            Identifier add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "add"
            MemberAccess to member charityAmountEth
               Type: uint256
               Source: "c.charityAmountEth"
              Identifier c
                 Type: struct Games.CommonAttr storage ref
                 Source: "c"
            Identifier charity
               Type: uint256
               Source: "charity"
ContractDefinition "ITGToken"
   Source: "contract ITGToken is ITGTokenBase, Authable {\r\n    bytes32  public  symbol = \"ITG\";\r\n    uint256  public  decimals = 18;\r\n    bytes32   public  name = \"ITG\";\r\n\r\n    enum Status { CrowdSale, Game, Pause }\r\n    Status public status;\r\n\r\n    CrowdSale crowdSale;\r\n    Games games;\r\n    Voting voting;\r\n\r\n    mapping(address => uint) public withdrawRestriction;\r\n\r\n    uint public minEtherParticipate;\r\n    uint public minTokParticipate;\r\n\r\n    event LogFundTransfer(address sender, address to, uint amount, uint8 currency);\r\n\r\n    modifier beforeTransfer(){\r\n        require(withdrawRestriction[msg.sender] < now);\r\n        _;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) beforeTransfer returns (bool success) {\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) beforeTransfer returns (bool success) {\r\n        uint _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_to] = add(balances[_to], _value);\r\n        balances[_from] = sub(balances[_from], _value);\r\n        allowed[_from][msg.sender] = sub(_allowance, _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /*  at initialization, setup the owner */\r\n    function ITGToken() {\r\n        owner = msg.sender;\r\n        totalSupply = 100000000 * 1 ether;\r\n        balances[msg.sender] = totalSupply;\r\n\r\n        status = Status.Pause;\r\n    }\r\n    function () payable {\r\n       if(msg.value < minEtherParticipate){\r\n            throw;\r\n       }\r\n\r\n       if(status == Status.CrowdSale){\r\n            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\r\n            itgTokenTransfer(crowdSale.process(msg.sender,msg.value),true);\r\n       }else if(status == Status.Game){\r\n            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\r\n            games.process(msg.sender, msg.value);\r\n       }else if(status == Status.Pause){\r\n            throw;\r\n       }\r\n    }\r\n\r\n    function setAttrs(address csAddr, address gmAddr, address vtAddr, Status _status, uint amtEth, uint amtTok) onlyAuth {\r\n        crowdSale = CrowdSale(csAddr);\r\n        games = Games(gmAddr);\r\n        voting = Voting(vtAddr);\r\n        status = _status;\r\n        minEtherParticipate = amtEth;\r\n        minTokParticipate = amtTok;\r\n    }\r\n\r\n    //getCrowdSaleToken\r\n    function USER_GET_CROWDSALE_TOKEN() {\r\n        itgTokenTransfer(crowdSale.getToken(msg.sender),true);\r\n    }\r\n\r\n    //vote\r\n    function USER_VOTE(uint voteId, uint candidateId){\r\n        uint addedToken;\r\n        uint lockUntil;\r\n        (addedToken, lockUntil) = voting.vote(msg.sender,balances[msg.sender],voteId,candidateId);\r\n        itgTokenTransfer(addedToken,true);\r\n\r\n        if(withdrawRestriction[msg.sender] < lockUntil){\r\n            withdrawRestriction[msg.sender] = lockUntil;\r\n        }\r\n    }\r\n\r\n    function voteInitiate(uint voteId, uint voteRewardPerUnit, uint voteWeightUnit, uint voteStart, uint voteEnd, uint maxCandidateId) onlyAuth {\r\n        voting.voteInitiate(voteId, voteRewardPerUnit, voteWeightUnit, voteStart, voteEnd, maxCandidateId);\r\n    }\r\n\r\n    function itgTokenTransfer(uint amt, bool fromOwner) private {\r\n        if(amt > 0){\r\n            if(fromOwner){\r\n                balances[owner] = sub(balances[owner], amt);\r\n                balances[msg.sender] = add(balances[msg.sender], amt);\r\n                Transfer(owner, msg.sender, amt);\r\n                LogFundTransfer(owner, msg.sender, amt, 2);\r\n            }else{\r\n                balances[owner] = add(balances[owner], amt);\r\n                balances[msg.sender] = sub(balances[msg.sender], amt);\r\n                Transfer(msg.sender, owner, amt);\r\n                LogFundTransfer(msg.sender, owner, amt, 2);\r\n            }\r\n        }\r\n    }\r\n\r\n    function ethTransfer(address target, uint amt) private {\r\n        if(amt > 0){\r\n            target.transfer(amt);\r\n            LogFundTransfer(0x0, target, amt, 1);\r\n        }\r\n    }\r\n\r\n    //gameWithToken\r\n    function USER_GAME_WITH_TOKEN(uint tokenAmountToGame) {\r\n        require(status == Status.Game);\r\n        require(balances[msg.sender] >= tokenAmountToGame * 1 ether);\r\n        require(tokenAmountToGame * 1 ether >= minTokParticipate);\r\n\r\n        itgTokenTransfer(tokenAmountToGame * 1 ether,false);\r\n\r\n        games.processWithITG(msg.sender, tokenAmountToGame * 1 ether);\r\n        \r\n    }\r\n\r\n    //getPrize\r\n    function USER_GET_PRIZE() {\r\n        uint ethPrize;\r\n        uint tokPrize;\r\n        (ethPrize, tokPrize) = games.getPrize(msg.sender);\r\n        itgTokenTransfer(tokPrize,true);\r\n        ethTransfer(msg.sender, ethPrize);\r\n    }\r\n\r\n    function selectWinner(uint rand) onlyAuth {\r\n        games.selectWinner(rand);\r\n    }\r\n\r\n    function burn(uint amt) onlyOwner {\r\n        balances[msg.sender] = sub(balances[msg.sender], amt);\r\n        totalSupply = sub(totalSupply,amt);\r\n    }\r\n\r\n    function mint(uint amt) onlyOwner {\r\n        balances[msg.sender] = add(balances[msg.sender], amt);\r\n        totalSupply = add(totalSupply,amt);\r\n    }\r\n\r\n    // We do not want big difference with our contract's balance and actual prize pool.\r\n    // So the ethereum that the winners didn't get over at least 1 year will be used for our charity business.\r\n    // We strongly hope winners get their prize after the game.\r\n    function lossToCharity(uint year,address charityAccount) onlyAuth {\r\n        ethTransfer(charityAccount, games.lossToCharity(year));\r\n    }\r\n\r\n    function charityAmtToCharity(address charityAccount) onlyOwner {\r\n        ethTransfer(charityAccount, games.charityAmtToCharity());\r\n    }\r\n\r\n    function distributeTokenSale(uint hour, uint month, uint year, uint charity) onlyAuth{\r\n        games.distributeTokenSale(hour, month, year, charity);\r\n    }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ITGTokenBase"
    UserDefinedTypeName "ITGTokenBase"
       Source: "ITGTokenBase"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Authable"
    UserDefinedTypeName "Authable"
       Source: "Authable"
  VariableDeclaration "symbol"
     Type: bytes32
     Gas costs: [???]
     Source: "bytes32  public  symbol = \"ITG\""
    ElementaryTypeName bytes32
       Source: "bytes32"
    Literal, token: [no token] value: ITG
       Type: literal_string "ITG"
       Source: "\"ITG\""
  VariableDeclaration "decimals"
     Type: uint256
     Gas costs: [???]
     Source: "uint256  public  decimals = 18"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "name"
     Type: bytes32
     Gas costs: [???]
     Source: "bytes32   public  name = \"ITG\""
    ElementaryTypeName bytes32
       Source: "bytes32"
    Literal, token: [no token] value: ITG
       Type: literal_string "ITG"
       Source: "\"ITG\""
  EnumDefinition "Status"
    EnumValue "CrowdSale"
    EnumValue "Game"
    EnumValue "Pause"
  VariableDeclaration "status"
     Type: enum ITGToken.Status
     Gas costs: [???]
     Source: "Status public status"
    UserDefinedTypeName "Status"
       Source: "Status"
  VariableDeclaration "crowdSale"
     Type: contract CrowdSale
     Gas costs: 0
     Source: "CrowdSale crowdSale"
    UserDefinedTypeName "CrowdSale"
       Source: "CrowdSale"
  VariableDeclaration "games"
     Type: contract Games
     Gas costs: 0
     Source: "Games games"
    UserDefinedTypeName "Games"
       Source: "Games"
  VariableDeclaration "voting"
     Type: contract Voting
     Gas costs: 0
     Source: "Voting voting"
    UserDefinedTypeName "Voting"
       Source: "Voting"
  VariableDeclaration "withdrawRestriction"
     Type: mapping(address => uint256)
     Gas costs: [???]
     Source: "mapping(address => uint) public withdrawRestriction"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "minEtherParticipate"
     Type: uint256
     Gas costs: [???]
     Source: "uint public minEtherParticipate"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "minTokParticipate"
     Type: uint256
     Gas costs: [???]
     Source: "uint public minTokParticipate"
    ElementaryTypeName uint
       Source: "uint"
  EventDefinition "LogFundTransfer"
     Gas costs: 0
     Source: "event LogFundTransfer(address sender, address to, uint amount, uint8 currency);"
    ParameterList
       Source: "(address sender, address to, uint amount, uint8 currency)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "currency"
         Type: uint8
         Source: "uint8 currency"
        ElementaryTypeName uint8
           Source: "uint8"
  ModifierDefinition "beforeTransfer"
     Source: "modifier beforeTransfer(){\r\n        require(withdrawRestriction[msg.sender] < now);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(withdrawRestriction[msg.sender] < now);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 658
         Source: "require(withdrawRestriction[msg.sender] < now)"
        FunctionCall
           Type: tuple()
           Source: "require(withdrawRestriction[msg.sender] < now)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "withdrawRestriction[msg.sender] < now"
            IndexAccess
               Type: uint256
               Source: "withdrawRestriction[msg.sender]"
              Identifier withdrawRestriction
                 Type: mapping(address => uint256)
                 Source: "withdrawRestriction"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier now
               Type: uint256
               Source: "now"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value) beforeTransfer returns (bool success) {\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "beforeTransfer"
       Gas costs: 0
       Source: "beforeTransfer"
      Identifier beforeTransfer
         Type: modifier ()
         Source: "beforeTransfer"
    Block
       Source: "{\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20422
         Source: "balances[msg.sender] = sub(balances[msg.sender], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = sub(balances[msg.sender], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "sub(balances[msg.sender], _value)"
            Identifier sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "sub"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20418
         Source: "balances[_to] = add(balances[_to], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = add(balances[_to], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "add(balances[_to], _value)"
            Identifier add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "add"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value) beforeTransfer returns (bool success) {\r\n        uint _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_to] = add(balances[_to], _value);\r\n        balances[_from] = sub(balances[_from], _value);\r\n        allowed[_from][msg.sender] = sub(_allowance, _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "beforeTransfer"
       Gas costs: 0
       Source: "beforeTransfer"
      Identifier beforeTransfer
         Type: modifier ()
         Source: "beforeTransfer"
    Block
       Source: "{\r\n        uint _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_to] = add(balances[_to], _value);\r\n        balances[_from] = sub(balances[_from], _value);\r\n        allowed[_from][msg.sender] = sub(_allowance, _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 396
         Source: "uint _allowance = allowed[_from][msg.sender]"
        VariableDeclaration "_allowance"
           Type: uint256
           Source: "uint _allowance"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "allowed[_from][msg.sender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_from]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _from
               Type: address
               Source: "_from"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20418
         Source: "balances[_to] = add(balances[_to], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = add(balances[_to], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "add(balances[_to], _value)"
            Identifier add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "add"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20418
         Source: "balances[_from] = sub(balances[_from], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_from] = sub(balances[_from], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "sub(balances[_from], _value)"
            Identifier sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "sub"
            IndexAccess
               Type: uint256
               Source: "balances[_from]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20217
         Source: "allowed[_from][msg.sender] = sub(_allowance, _value)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[_from][msg.sender] = sub(_allowance, _value)"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "sub(_allowance, _value)"
            Identifier sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "sub"
            Identifier _allowance
               Type: uint256
               Source: "_allowance"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "ITGToken" - public
     Source: "function ITGToken() {\r\n        owner = msg.sender;\r\n        totalSupply = 100000000 * 1 ether;\r\n        balances[msg.sender] = totalSupply;\r\n\r\n        status = Status.Pause;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = msg.sender;\r\n        totalSupply = 100000000 * 1 ether;\r\n        balances[msg.sender] = totalSupply;\r\n\r\n        status = Status.Pause;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = 100000000 * 1 ether"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = 100000000 * 1 ether"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          BinaryOperation using operator *
             Type: int_const 100000000000000000000000000
             Source: "100000000 * 1 ether"
            Literal, token: [no token] value: 100000000
               Type: int_const 100000000
               Source: "100000000"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] = totalSupply"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = totalSupply"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
      ExpressionStatement
         Gas costs: 0
         Source: "status = Status.Pause"
        Assignment using operator =
           Type: enum ITGToken.Status
           Source: "status = Status.Pause"
          Identifier status
             Type: enum ITGToken.Status
             Source: "status"
          MemberAccess to member Pause
             Type: enum ITGToken.Status
             Source: "Status.Pause"
            Identifier Status
               Type: type(enum ITGToken.Status)
               Source: "Status"
  FunctionDefinition "" - public
     Source: "function () payable {\r\n       if(msg.value < minEtherParticipate){\r\n            throw;\r\n       }\r\n\r\n       if(status == Status.CrowdSale){\r\n            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\r\n            itgTokenTransfer(crowdSale.process(msg.sender,msg.value),true);\r\n       }else if(status == Status.Game){\r\n            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\r\n            games.process(msg.sender, msg.value);\r\n       }else if(status == Status.Pause){\r\n            throw;\r\n       }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n       if(msg.value < minEtherParticipate){\r\n            throw;\r\n       }\r\n\r\n       if(status == Status.CrowdSale){\r\n            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\r\n            itgTokenTransfer(crowdSale.process(msg.sender,msg.value),true);\r\n       }else if(status == Status.Game){\r\n            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\r\n            games.process(msg.sender, msg.value);\r\n       }else if(status == Status.Pause){\r\n            throw;\r\n       }\r\n    }"
      IfStatement
         Source: "if(msg.value < minEtherParticipate){\r\n            throw;\r\n       }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 208
           Source: "msg.value < minEtherParticipate"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier minEtherParticipate
             Type: uint256
             Source: "minEtherParticipate"
        Block
           Source: "{\r\n            throw;\r\n       }"
          Throw
             Gas costs: 6
             Source: "throw"
      IfStatement
         Source: "if(status == Status.CrowdSale){\r\n            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\r\n            itgTokenTransfer(crowdSale.process(msg.sender,msg.value),true);\r\n       }else if(status == Status.Game){\r\n            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\r\n            games.process(msg.sender, msg.value);\r\n       }else if(status == Status.Pause){\r\n            throw;\r\n       }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 297
           Source: "status == Status.CrowdSale"
          Identifier status
             Type: enum ITGToken.Status
             Source: "status"
          MemberAccess to member CrowdSale
             Type: enum ITGToken.Status
             Source: "Status.CrowdSale"
            Identifier Status
               Type: type(enum ITGToken.Status)
               Source: "Status"
        Block
           Source: "{\r\n            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\r\n            itgTokenTransfer(crowdSale.process(msg.sender,msg.value),true);\r\n       }"
          ExpressionStatement
             Gas costs: [???]
             Source: "LogFundTransfer(msg.sender, 0x0, msg.value, 1)"
            FunctionCall
               Type: tuple()
               Source: "LogFundTransfer(msg.sender, 0x0, msg.value, 1)"
              Identifier LogFundTransfer
                 Type: function (address,address,uint256,uint8)
                 Source: "LogFundTransfer"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Literal, token: [no token] value: 0x0
                 Type: int_const 0
                 Source: "0x0"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          ExpressionStatement
             Gas costs: [???]
             Source: "itgTokenTransfer(crowdSale.process(msg.sender,msg.value),true)"
            FunctionCall
               Type: tuple()
               Source: "itgTokenTransfer(crowdSale.process(msg.sender,msg.value),true)"
              Identifier itgTokenTransfer
                 Type: function (uint256,bool)
                 Source: "itgTokenTransfer"
              FunctionCall
                 Type: uint256
                 Source: "crowdSale.process(msg.sender,msg.value)"
                MemberAccess to member process
                   Type: function (address,uint256) external returns (uint256)
                   Source: "crowdSale.process"
                  Identifier crowdSale
                     Type: contract CrowdSale
                     Source: "crowdSale"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                MemberAccess to member value
                   Type: uint256
                   Source: "msg.value"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
        IfStatement
           Source: "if(status == Status.Game){\r\n            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\r\n            games.process(msg.sender, msg.value);\r\n       }else if(status == Status.Pause){\r\n            throw;\r\n       }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 297
             Source: "status == Status.Game"
            Identifier status
               Type: enum ITGToken.Status
               Source: "status"
            MemberAccess to member Game
               Type: enum ITGToken.Status
               Source: "Status.Game"
              Identifier Status
                 Type: type(enum ITGToken.Status)
                 Source: "Status"
          Block
             Source: "{\r\n            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\r\n            games.process(msg.sender, msg.value);\r\n       }"
            ExpressionStatement
               Gas costs: [???]
               Source: "LogFundTransfer(msg.sender, 0x0, msg.value, 1)"
              FunctionCall
                 Type: tuple()
                 Source: "LogFundTransfer(msg.sender, 0x0, msg.value, 1)"
                Identifier LogFundTransfer
                   Type: function (address,address,uint256,uint8)
                   Source: "LogFundTransfer"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Literal, token: [no token] value: 0x0
                   Type: int_const 0
                   Source: "0x0"
                MemberAccess to member value
                   Type: uint256
                   Source: "msg.value"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
            ExpressionStatement
               Gas costs: [???]
               Source: "games.process(msg.sender, msg.value)"
              FunctionCall
                 Type: tuple()
                 Source: "games.process(msg.sender, msg.value)"
                MemberAccess to member process
                   Type: function (address,uint256) external
                   Source: "games.process"
                  Identifier games
                     Type: contract Games
                     Source: "games"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                MemberAccess to member value
                   Type: uint256
                   Source: "msg.value"
                  Identifier msg
                     Type: msg
                     Source: "msg"
          IfStatement
             Source: "if(status == Status.Pause){\r\n            throw;\r\n       }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 297
               Source: "status == Status.Pause"
              Identifier status
                 Type: enum ITGToken.Status
                 Source: "status"
              MemberAccess to member Pause
                 Type: enum ITGToken.Status
                 Source: "Status.Pause"
                Identifier Status
                   Type: type(enum ITGToken.Status)
                   Source: "Status"
            Block
               Source: "{\r\n            throw;\r\n       }"
              Throw
                 Gas costs: 6
                 Source: "throw"
  FunctionDefinition "setAttrs" - public
     Source: "function setAttrs(address csAddr, address gmAddr, address vtAddr, Status _status, uint amtEth, uint amtTok) onlyAuth {\r\n        crowdSale = CrowdSale(csAddr);\r\n        games = Games(gmAddr);\r\n        voting = Voting(vtAddr);\r\n        status = _status;\r\n        minEtherParticipate = amtEth;\r\n        minTokParticipate = amtTok;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address csAddr, address gmAddr, address vtAddr, Status _status, uint amtEth, uint amtTok)"
      VariableDeclaration "csAddr"
         Type: address
         Source: "address csAddr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "gmAddr"
         Type: address
         Source: "address gmAddr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "vtAddr"
         Type: address
         Source: "address vtAddr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_status"
         Type: enum ITGToken.Status
         Source: "Status _status"
        UserDefinedTypeName "Status"
           Source: "Status"
      VariableDeclaration "amtEth"
         Type: uint256
         Source: "uint amtEth"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "amtTok"
         Type: uint256
         Source: "uint amtTok"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAuth"
       Gas costs: 0
       Source: "onlyAuth"
      Identifier onlyAuth
         Type: modifier ()
         Source: "onlyAuth"
    Block
       Source: "{\r\n        crowdSale = CrowdSale(csAddr);\r\n        games = Games(gmAddr);\r\n        voting = Voting(vtAddr);\r\n        status = _status;\r\n        minEtherParticipate = amtEth;\r\n        minTokParticipate = amtTok;\r\n    }"
      ExpressionStatement
         Gas costs: 20317
         Source: "crowdSale = CrowdSale(csAddr)"
        Assignment using operator =
           Type: contract CrowdSale
           Source: "crowdSale = CrowdSale(csAddr)"
          Identifier crowdSale
             Type: contract CrowdSale
             Source: "crowdSale"
          FunctionCall
             Type: contract CrowdSale
             Source: "CrowdSale(csAddr)"
            Identifier CrowdSale
               Type: type(contract CrowdSale)
               Source: "CrowdSale"
            Identifier csAddr
               Type: address
               Source: "csAddr"
      ExpressionStatement
         Gas costs: 20267
         Source: "games = Games(gmAddr)"
        Assignment using operator =
           Type: contract Games
           Source: "games = Games(gmAddr)"
          Identifier games
             Type: contract Games
             Source: "games"
          FunctionCall
             Type: contract Games
             Source: "Games(gmAddr)"
            Identifier Games
               Type: type(contract Games)
               Source: "Games"
            Identifier gmAddr
               Type: address
               Source: "gmAddr"
      ExpressionStatement
         Gas costs: 20267
         Source: "voting = Voting(vtAddr)"
        Assignment using operator =
           Type: contract Voting
           Source: "voting = Voting(vtAddr)"
          Identifier voting
             Type: contract Voting
             Source: "voting"
          FunctionCall
             Type: contract Voting
             Source: "Voting(vtAddr)"
            Identifier Voting
               Type: type(contract Voting)
               Source: "Voting"
            Identifier vtAddr
               Type: address
               Source: "vtAddr"
      ExpressionStatement
         Gas costs: 20287
         Source: "status = _status"
        Assignment using operator =
           Type: enum ITGToken.Status
           Source: "status = _status"
          Identifier status
             Type: enum ITGToken.Status
             Source: "status"
          Identifier _status
             Type: enum ITGToken.Status
             Source: "_status"
      ExpressionStatement
         Gas costs: 20014
         Source: "minEtherParticipate = amtEth"
        Assignment using operator =
           Type: uint256
           Source: "minEtherParticipate = amtEth"
          Identifier minEtherParticipate
             Type: uint256
             Source: "minEtherParticipate"
          Identifier amtEth
             Type: uint256
             Source: "amtEth"
      ExpressionStatement
         Gas costs: 20014
         Source: "minTokParticipate = amtTok"
        Assignment using operator =
           Type: uint256
           Source: "minTokParticipate = amtTok"
          Identifier minTokParticipate
             Type: uint256
             Source: "minTokParticipate"
          Identifier amtTok
             Type: uint256
             Source: "amtTok"
  FunctionDefinition "USER_GET_CROWDSALE_TOKEN" - public
     Source: "function USER_GET_CROWDSALE_TOKEN() {\r\n        itgTokenTransfer(crowdSale.getToken(msg.sender),true);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        itgTokenTransfer(crowdSale.getToken(msg.sender),true);\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "itgTokenTransfer(crowdSale.getToken(msg.sender),true)"
        FunctionCall
           Type: tuple()
           Source: "itgTokenTransfer(crowdSale.getToken(msg.sender),true)"
          Identifier itgTokenTransfer
             Type: function (uint256,bool)
             Source: "itgTokenTransfer"
          FunctionCall
             Type: uint256
             Source: "crowdSale.getToken(msg.sender)"
            MemberAccess to member getToken
               Type: function (address) external returns (uint256)
               Source: "crowdSale.getToken"
              Identifier crowdSale
                 Type: contract CrowdSale
                 Source: "crowdSale"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "USER_VOTE" - public
     Source: "function USER_VOTE(uint voteId, uint candidateId){\r\n        uint addedToken;\r\n        uint lockUntil;\r\n        (addedToken, lockUntil) = voting.vote(msg.sender,balances[msg.sender],voteId,candidateId);\r\n        itgTokenTransfer(addedToken,true);\r\n\r\n        if(withdrawRestriction[msg.sender] < lockUntil){\r\n            withdrawRestriction[msg.sender] = lockUntil;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint voteId, uint candidateId)"
      VariableDeclaration "voteId"
         Type: uint256
         Source: "uint voteId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "candidateId"
         Type: uint256
         Source: "uint candidateId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint addedToken;\r\n        uint lockUntil;\r\n        (addedToken, lockUntil) = voting.vote(msg.sender,balances[msg.sender],voteId,candidateId);\r\n        itgTokenTransfer(addedToken,true);\r\n\r\n        if(withdrawRestriction[msg.sender] < lockUntil){\r\n            withdrawRestriction[msg.sender] = lockUntil;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint addedToken"
        VariableDeclaration "addedToken"
           Type: uint256
           Source: "uint addedToken"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint lockUntil"
        VariableDeclaration "lockUntil"
           Type: uint256
           Source: "uint lockUntil"
          ElementaryTypeName uint
             Source: "uint"
      ExpressionStatement
         Gas costs: [???]
         Source: "(addedToken, lockUntil) = voting.vote(msg.sender,balances[msg.sender],voteId,candidateId)"
        Assignment using operator =
           Type: tuple()
           Source: "(addedToken, lockUntil) = voting.vote(msg.sender,balances[msg.sender],voteId,candidateId)"
          TupleExpression
             Type: tuple(uint256,uint256)
             Source: "(addedToken, lockUntil)"
            Identifier addedToken
               Type: uint256
               Source: "addedToken"
            Identifier lockUntil
               Type: uint256
               Source: "lockUntil"
          FunctionCall
             Type: tuple(uint256,uint256)
             Source: "voting.vote(msg.sender,balances[msg.sender],voteId,candidateId)"
            MemberAccess to member vote
               Type: function (address,uint256,uint256,uint256) external returns (uint256,uint256)
               Source: "voting.vote"
              Identifier voting
                 Type: contract Voting
                 Source: "voting"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier voteId
               Type: uint256
               Source: "voteId"
            Identifier candidateId
               Type: uint256
               Source: "candidateId"
      ExpressionStatement
         Gas costs: 21
         Source: "itgTokenTransfer(addedToken,true)"
        FunctionCall
           Type: tuple()
           Source: "itgTokenTransfer(addedToken,true)"
          Identifier itgTokenTransfer
             Type: function (uint256,bool)
             Source: "itgTokenTransfer"
          Identifier addedToken
             Type: uint256
             Source: "addedToken"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      IfStatement
         Source: "if(withdrawRestriction[msg.sender] < lockUntil){\r\n            withdrawRestriction[msg.sender] = lockUntil;\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 304
           Source: "withdrawRestriction[msg.sender] < lockUntil"
          IndexAccess
             Type: uint256
             Source: "withdrawRestriction[msg.sender]"
            Identifier withdrawRestriction
               Type: mapping(address => uint256)
               Source: "withdrawRestriction"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier lockUntil
             Type: uint256
             Source: "lockUntil"
        Block
           Source: "{\r\n            withdrawRestriction[msg.sender] = lockUntil;\r\n        }"
          ExpressionStatement
             Gas costs: 20109
             Source: "withdrawRestriction[msg.sender] = lockUntil"
            Assignment using operator =
               Type: uint256
               Source: "withdrawRestriction[msg.sender] = lockUntil"
              IndexAccess
                 Type: uint256
                 Source: "withdrawRestriction[msg.sender]"
                Identifier withdrawRestriction
                   Type: mapping(address => uint256)
                   Source: "withdrawRestriction"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier lockUntil
                 Type: uint256
                 Source: "lockUntil"
  FunctionDefinition "voteInitiate" - public
     Source: "function voteInitiate(uint voteId, uint voteRewardPerUnit, uint voteWeightUnit, uint voteStart, uint voteEnd, uint maxCandidateId) onlyAuth {\r\n        voting.voteInitiate(voteId, voteRewardPerUnit, voteWeightUnit, voteStart, voteEnd, maxCandidateId);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint voteId, uint voteRewardPerUnit, uint voteWeightUnit, uint voteStart, uint voteEnd, uint maxCandidateId)"
      VariableDeclaration "voteId"
         Type: uint256
         Source: "uint voteId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "voteRewardPerUnit"
         Type: uint256
         Source: "uint voteRewardPerUnit"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "voteWeightUnit"
         Type: uint256
         Source: "uint voteWeightUnit"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "voteStart"
         Type: uint256
         Source: "uint voteStart"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "voteEnd"
         Type: uint256
         Source: "uint voteEnd"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "maxCandidateId"
         Type: uint256
         Source: "uint maxCandidateId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAuth"
       Gas costs: 0
       Source: "onlyAuth"
      Identifier onlyAuth
         Type: modifier ()
         Source: "onlyAuth"
    Block
       Source: "{\r\n        voting.voteInitiate(voteId, voteRewardPerUnit, voteWeightUnit, voteStart, voteEnd, maxCandidateId);\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "voting.voteInitiate(voteId, voteRewardPerUnit, voteWeightUnit, voteStart, voteEnd, maxCandidateId)"
        FunctionCall
           Type: tuple()
           Source: "voting.voteInitiate(voteId, voteRewardPerUnit, voteWeightUnit, voteStart, voteEnd, maxCandidateId)"
          MemberAccess to member voteInitiate
             Type: function (uint256,uint256,uint256,uint256,uint256,uint256) external
             Source: "voting.voteInitiate"
            Identifier voting
               Type: contract Voting
               Source: "voting"
          Identifier voteId
             Type: uint256
             Source: "voteId"
          Identifier voteRewardPerUnit
             Type: uint256
             Source: "voteRewardPerUnit"
          Identifier voteWeightUnit
             Type: uint256
             Source: "voteWeightUnit"
          Identifier voteStart
             Type: uint256
             Source: "voteStart"
          Identifier voteEnd
             Type: uint256
             Source: "voteEnd"
          Identifier maxCandidateId
             Type: uint256
             Source: "maxCandidateId"
  FunctionDefinition "itgTokenTransfer"
     Source: "function itgTokenTransfer(uint amt, bool fromOwner) private {\r\n        if(amt > 0){\r\n            if(fromOwner){\r\n                balances[owner] = sub(balances[owner], amt);\r\n                balances[msg.sender] = add(balances[msg.sender], amt);\r\n                Transfer(owner, msg.sender, amt);\r\n                LogFundTransfer(owner, msg.sender, amt, 2);\r\n            }else{\r\n                balances[owner] = add(balances[owner], amt);\r\n                balances[msg.sender] = sub(balances[msg.sender], amt);\r\n                Transfer(msg.sender, owner, amt);\r\n                LogFundTransfer(msg.sender, owner, amt, 2);\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint amt, bool fromOwner)"
      VariableDeclaration "amt"
         Type: uint256
         Source: "uint amt"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "fromOwner"
         Type: bool
         Source: "bool fromOwner"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if(amt > 0){\r\n            if(fromOwner){\r\n                balances[owner] = sub(balances[owner], amt);\r\n                balances[msg.sender] = add(balances[msg.sender], amt);\r\n                Transfer(owner, msg.sender, amt);\r\n                LogFundTransfer(owner, msg.sender, amt, 2);\r\n            }else{\r\n                balances[owner] = add(balances[owner], amt);\r\n                balances[msg.sender] = sub(balances[msg.sender], amt);\r\n                Transfer(msg.sender, owner, amt);\r\n                LogFundTransfer(msg.sender, owner, amt, 2);\r\n            }\r\n        }\r\n    }"
      IfStatement
         Source: "if(amt > 0){\r\n            if(fromOwner){\r\n                balances[owner] = sub(balances[owner], amt);\r\n                balances[msg.sender] = add(balances[msg.sender], amt);\r\n                Transfer(owner, msg.sender, amt);\r\n                LogFundTransfer(owner, msg.sender, amt, 2);\r\n            }else{\r\n                balances[owner] = add(balances[owner], amt);\r\n                balances[msg.sender] = sub(balances[msg.sender], amt);\r\n                Transfer(msg.sender, owner, amt);\r\n                LogFundTransfer(msg.sender, owner, amt, 2);\r\n            }\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "amt > 0"
          Identifier amt
             Type: uint256
             Source: "amt"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            if(fromOwner){\r\n                balances[owner] = sub(balances[owner], amt);\r\n                balances[msg.sender] = add(balances[msg.sender], amt);\r\n                Transfer(owner, msg.sender, amt);\r\n                LogFundTransfer(owner, msg.sender, amt, 2);\r\n            }else{\r\n                balances[owner] = add(balances[owner], amt);\r\n                balances[msg.sender] = sub(balances[msg.sender], amt);\r\n                Transfer(msg.sender, owner, amt);\r\n                LogFundTransfer(msg.sender, owner, amt, 2);\r\n            }\r\n        }"
          IfStatement
             Source: "if(fromOwner){\r\n                balances[owner] = sub(balances[owner], amt);\r\n                balances[msg.sender] = add(balances[msg.sender], amt);\r\n                Transfer(owner, msg.sender, amt);\r\n                LogFundTransfer(owner, msg.sender, amt, 2);\r\n            }else{\r\n                balances[owner] = add(balances[owner], amt);\r\n                balances[msg.sender] = sub(balances[msg.sender], amt);\r\n                Transfer(msg.sender, owner, amt);\r\n                LogFundTransfer(msg.sender, owner, amt, 2);\r\n            }"
            Identifier fromOwner
               Type: bool
               Gas costs: 3
               Source: "fromOwner"
            Block
               Source: "{\r\n                balances[owner] = sub(balances[owner], amt);\r\n                balances[msg.sender] = add(balances[msg.sender], amt);\r\n                Transfer(owner, msg.sender, amt);\r\n                LogFundTransfer(owner, msg.sender, amt, 2);\r\n            }"
              ExpressionStatement
                 Gas costs: 20896
                 Source: "balances[owner] = sub(balances[owner], amt)"
                Assignment using operator =
                   Type: uint256
                   Source: "balances[owner] = sub(balances[owner], amt)"
                  IndexAccess
                     Type: uint256
                     Source: "balances[owner]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    Identifier owner
                       Type: address
                       Source: "owner"
                  FunctionCall
                     Type: uint256
                     Source: "sub(balances[owner], amt)"
                    Identifier sub
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "sub"
                    IndexAccess
                       Type: uint256
                       Source: "balances[owner]"
                      Identifier balances
                         Type: mapping(address => uint256)
                         Source: "balances"
                      Identifier owner
                         Type: address
                         Source: "owner"
                    Identifier amt
                       Type: uint256
                       Source: "amt"
              ExpressionStatement
                 Gas costs: 20416
                 Source: "balances[msg.sender] = add(balances[msg.sender], amt)"
                Assignment using operator =
                   Type: uint256
                   Source: "balances[msg.sender] = add(balances[msg.sender], amt)"
                  IndexAccess
                     Type: uint256
                     Source: "balances[msg.sender]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                  FunctionCall
                     Type: uint256
                     Source: "add(balances[msg.sender], amt)"
                    Identifier add
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "add"
                    IndexAccess
                       Type: uint256
                       Source: "balances[msg.sender]"
                      Identifier balances
                         Type: mapping(address => uint256)
                         Source: "balances"
                      MemberAccess to member sender
                         Type: address
                         Source: "msg.sender"
                        Identifier msg
                           Type: msg
                           Source: "msg"
                    Identifier amt
                       Type: uint256
                       Source: "amt"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "Transfer(owner, msg.sender, amt)"
                FunctionCall
                   Type: tuple()
                   Source: "Transfer(owner, msg.sender, amt)"
                  Identifier Transfer
                     Type: function (address,address,uint256)
                     Source: "Transfer"
                  Identifier owner
                     Type: address
                     Source: "owner"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier amt
                     Type: uint256
                     Source: "amt"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "LogFundTransfer(owner, msg.sender, amt, 2)"
                FunctionCall
                   Type: tuple()
                   Source: "LogFundTransfer(owner, msg.sender, amt, 2)"
                  Identifier LogFundTransfer
                     Type: function (address,address,uint256,uint8)
                     Source: "LogFundTransfer"
                  Identifier owner
                     Type: address
                     Source: "owner"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier amt
                     Type: uint256
                     Source: "amt"
                  Literal, token: [no token] value: 2
                     Type: int_const 2
                     Source: "2"
            Block
               Source: "{\r\n                balances[owner] = add(balances[owner], amt);\r\n                balances[msg.sender] = sub(balances[msg.sender], amt);\r\n                Transfer(msg.sender, owner, amt);\r\n                LogFundTransfer(msg.sender, owner, amt, 2);\r\n            }"
              ExpressionStatement
                 Gas costs: 20885
                 Source: "balances[owner] = add(balances[owner], amt)"
                Assignment using operator =
                   Type: uint256
                   Source: "balances[owner] = add(balances[owner], amt)"
                  IndexAccess
                     Type: uint256
                     Source: "balances[owner]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    Identifier owner
                       Type: address
                       Source: "owner"
                  FunctionCall
                     Type: uint256
                     Source: "add(balances[owner], amt)"
                    Identifier add
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "add"
                    IndexAccess
                       Type: uint256
                       Source: "balances[owner]"
                      Identifier balances
                         Type: mapping(address => uint256)
                         Source: "balances"
                      Identifier owner
                         Type: address
                         Source: "owner"
                    Identifier amt
                       Type: uint256
                       Source: "amt"
              ExpressionStatement
                 Gas costs: 20405
                 Source: "balances[msg.sender] = sub(balances[msg.sender], amt)"
                Assignment using operator =
                   Type: uint256
                   Source: "balances[msg.sender] = sub(balances[msg.sender], amt)"
                  IndexAccess
                     Type: uint256
                     Source: "balances[msg.sender]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                  FunctionCall
                     Type: uint256
                     Source: "sub(balances[msg.sender], amt)"
                    Identifier sub
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "sub"
                    IndexAccess
                       Type: uint256
                       Source: "balances[msg.sender]"
                      Identifier balances
                         Type: mapping(address => uint256)
                         Source: "balances"
                      MemberAccess to member sender
                         Type: address
                         Source: "msg.sender"
                        Identifier msg
                           Type: msg
                           Source: "msg"
                    Identifier amt
                       Type: uint256
                       Source: "amt"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "Transfer(msg.sender, owner, amt)"
                FunctionCall
                   Type: tuple()
                   Source: "Transfer(msg.sender, owner, amt)"
                  Identifier Transfer
                     Type: function (address,address,uint256)
                     Source: "Transfer"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier owner
                     Type: address
                     Source: "owner"
                  Identifier amt
                     Type: uint256
                     Source: "amt"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "LogFundTransfer(msg.sender, owner, amt, 2)"
                FunctionCall
                   Type: tuple()
                   Source: "LogFundTransfer(msg.sender, owner, amt, 2)"
                  Identifier LogFundTransfer
                     Type: function (address,address,uint256,uint8)
                     Source: "LogFundTransfer"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier owner
                     Type: address
                     Source: "owner"
                  Identifier amt
                     Type: uint256
                     Source: "amt"
                  Literal, token: [no token] value: 2
                     Type: int_const 2
                     Source: "2"
  FunctionDefinition "ethTransfer"
     Source: "function ethTransfer(address target, uint amt) private {\r\n        if(amt > 0){\r\n            target.transfer(amt);\r\n            LogFundTransfer(0x0, target, amt, 1);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address target, uint amt)"
      VariableDeclaration "target"
         Type: address
         Source: "address target"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amt"
         Type: uint256
         Source: "uint amt"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if(amt > 0){\r\n            target.transfer(amt);\r\n            LogFundTransfer(0x0, target, amt, 1);\r\n        }\r\n    }"
      IfStatement
         Source: "if(amt > 0){\r\n            target.transfer(amt);\r\n            LogFundTransfer(0x0, target, amt, 1);\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "amt > 0"
          Identifier amt
             Type: uint256
             Source: "amt"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            target.transfer(amt);\r\n            LogFundTransfer(0x0, target, amt, 1);\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "target.transfer(amt)"
            FunctionCall
               Type: tuple()
               Source: "target.transfer(amt)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "target.transfer"
                Identifier target
                   Type: address
                   Source: "target"
              Identifier amt
                 Type: uint256
                 Source: "amt"
          ExpressionStatement
             Gas costs: [???]
             Source: "LogFundTransfer(0x0, target, amt, 1)"
            FunctionCall
               Type: tuple()
               Source: "LogFundTransfer(0x0, target, amt, 1)"
              Identifier LogFundTransfer
                 Type: function (address,address,uint256,uint8)
                 Source: "LogFundTransfer"
              Literal, token: [no token] value: 0x0
                 Type: int_const 0
                 Source: "0x0"
              Identifier target
                 Type: address
                 Source: "target"
              Identifier amt
                 Type: uint256
                 Source: "amt"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
  FunctionDefinition "USER_GAME_WITH_TOKEN" - public
     Source: "function USER_GAME_WITH_TOKEN(uint tokenAmountToGame) {\r\n        require(status == Status.Game);\r\n        require(balances[msg.sender] >= tokenAmountToGame * 1 ether);\r\n        require(tokenAmountToGame * 1 ether >= minTokParticipate);\r\n\r\n        itgTokenTransfer(tokenAmountToGame * 1 ether,false);\r\n\r\n        games.processWithITG(msg.sender, tokenAmountToGame * 1 ether);\r\n        \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint tokenAmountToGame)"
      VariableDeclaration "tokenAmountToGame"
         Type: uint256
         Source: "uint tokenAmountToGame"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(status == Status.Game);\r\n        require(balances[msg.sender] >= tokenAmountToGame * 1 ether);\r\n        require(tokenAmountToGame * 1 ether >= minTokParticipate);\r\n\r\n        itgTokenTransfer(tokenAmountToGame * 1 ether,false);\r\n\r\n        games.processWithITG(msg.sender, tokenAmountToGame * 1 ether);\r\n        \r\n    }"
      ExpressionStatement
         Gas costs: 323
         Source: "require(status == Status.Game)"
        FunctionCall
           Type: tuple()
           Source: "require(status == Status.Game)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "status == Status.Game"
            Identifier status
               Type: enum ITGToken.Status
               Source: "status"
            MemberAccess to member Game
               Type: enum ITGToken.Status
               Source: "Status.Game"
              Identifier Status
                 Type: type(enum ITGToken.Status)
                 Source: "Status"
      ExpressionStatement
         Gas costs: 341
         Source: "require(balances[msg.sender] >= tokenAmountToGame * 1 ether)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] >= tokenAmountToGame * 1 ether)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= tokenAmountToGame * 1 ether"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            BinaryOperation using operator *
               Type: uint256
               Source: "tokenAmountToGame * 1 ether"
              Identifier tokenAmountToGame
                 Type: uint256
                 Source: "tokenAmountToGame"
              Literal, token: [no token] value: 1
                 Type: int_const 1000000000000000000
                 Source: "1 ether"
      ExpressionStatement
         Gas costs: 246
         Source: "require(tokenAmountToGame * 1 ether >= minTokParticipate)"
        FunctionCall
           Type: tuple()
           Source: "require(tokenAmountToGame * 1 ether >= minTokParticipate)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "tokenAmountToGame * 1 ether >= minTokParticipate"
            BinaryOperation using operator *
               Type: uint256
               Source: "tokenAmountToGame * 1 ether"
              Identifier tokenAmountToGame
                 Type: uint256
                 Source: "tokenAmountToGame"
              Literal, token: [no token] value: 1
                 Type: int_const 1000000000000000000
                 Source: "1 ether"
            Identifier minTokParticipate
               Type: uint256
               Source: "minTokParticipate"
      ExpressionStatement
         Gas costs: 29
         Source: "itgTokenTransfer(tokenAmountToGame * 1 ether,false)"
        FunctionCall
           Type: tuple()
           Source: "itgTokenTransfer(tokenAmountToGame * 1 ether,false)"
          Identifier itgTokenTransfer
             Type: function (uint256,bool)
             Source: "itgTokenTransfer"
          BinaryOperation using operator *
             Type: uint256
             Source: "tokenAmountToGame * 1 ether"
            Identifier tokenAmountToGame
               Type: uint256
               Source: "tokenAmountToGame"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: [???]
         Source: "games.processWithITG(msg.sender, tokenAmountToGame * 1 ether)"
        FunctionCall
           Type: tuple()
           Source: "games.processWithITG(msg.sender, tokenAmountToGame * 1 ether)"
          MemberAccess to member processWithITG
             Type: function (address,uint256) external
             Source: "games.processWithITG"
            Identifier games
               Type: contract Games
               Source: "games"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          BinaryOperation using operator *
             Type: uint256
             Source: "tokenAmountToGame * 1 ether"
            Identifier tokenAmountToGame
               Type: uint256
               Source: "tokenAmountToGame"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
  FunctionDefinition "USER_GET_PRIZE" - public
     Source: "function USER_GET_PRIZE() {\r\n        uint ethPrize;\r\n        uint tokPrize;\r\n        (ethPrize, tokPrize) = games.getPrize(msg.sender);\r\n        itgTokenTransfer(tokPrize,true);\r\n        ethTransfer(msg.sender, ethPrize);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint ethPrize;\r\n        uint tokPrize;\r\n        (ethPrize, tokPrize) = games.getPrize(msg.sender);\r\n        itgTokenTransfer(tokPrize,true);\r\n        ethTransfer(msg.sender, ethPrize);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint ethPrize"
        VariableDeclaration "ethPrize"
           Type: uint256
           Source: "uint ethPrize"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint tokPrize"
        VariableDeclaration "tokPrize"
           Type: uint256
           Source: "uint tokPrize"
          ElementaryTypeName uint
             Source: "uint"
      ExpressionStatement
         Gas costs: [???]
         Source: "(ethPrize, tokPrize) = games.getPrize(msg.sender)"
        Assignment using operator =
           Type: tuple()
           Source: "(ethPrize, tokPrize) = games.getPrize(msg.sender)"
          TupleExpression
             Type: tuple(uint256,uint256)
             Source: "(ethPrize, tokPrize)"
            Identifier ethPrize
               Type: uint256
               Source: "ethPrize"
            Identifier tokPrize
               Type: uint256
               Source: "tokPrize"
          FunctionCall
             Type: tuple(uint256,uint256)
             Source: "games.getPrize(msg.sender)"
            MemberAccess to member getPrize
               Type: function (address) external returns (uint256,uint256)
               Source: "games.getPrize"
              Identifier games
                 Type: contract Games
                 Source: "games"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 21
         Source: "itgTokenTransfer(tokPrize,true)"
        FunctionCall
           Type: tuple()
           Source: "itgTokenTransfer(tokPrize,true)"
          Identifier itgTokenTransfer
             Type: function (uint256,bool)
             Source: "itgTokenTransfer"
          Identifier tokPrize
             Type: uint256
             Source: "tokPrize"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 20
         Source: "ethTransfer(msg.sender, ethPrize)"
        FunctionCall
           Type: tuple()
           Source: "ethTransfer(msg.sender, ethPrize)"
          Identifier ethTransfer
             Type: function (address,uint256)
             Source: "ethTransfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier ethPrize
             Type: uint256
             Source: "ethPrize"
  FunctionDefinition "selectWinner" - public
     Source: "function selectWinner(uint rand) onlyAuth {\r\n        games.selectWinner(rand);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint rand)"
      VariableDeclaration "rand"
         Type: uint256
         Source: "uint rand"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAuth"
       Gas costs: 0
       Source: "onlyAuth"
      Identifier onlyAuth
         Type: modifier ()
         Source: "onlyAuth"
    Block
       Source: "{\r\n        games.selectWinner(rand);\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "games.selectWinner(rand)"
        FunctionCall
           Type: tuple()
           Source: "games.selectWinner(rand)"
          MemberAccess to member selectWinner
             Type: function (uint256) external
             Source: "games.selectWinner"
            Identifier games
               Type: contract Games
               Source: "games"
          Identifier rand
             Type: uint256
             Source: "rand"
  FunctionDefinition "burn" - public
     Source: "function burn(uint amt) onlyOwner {\r\n        balances[msg.sender] = sub(balances[msg.sender], amt);\r\n        totalSupply = sub(totalSupply,amt);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint amt)"
      VariableDeclaration "amt"
         Type: uint256
         Source: "uint amt"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        balances[msg.sender] = sub(balances[msg.sender], amt);\r\n        totalSupply = sub(totalSupply,amt);\r\n    }"
      ExpressionStatement
         Gas costs: 20422
         Source: "balances[msg.sender] = sub(balances[msg.sender], amt)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = sub(balances[msg.sender], amt)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "sub(balances[msg.sender], amt)"
            Identifier sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "sub"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier amt
               Type: uint256
               Source: "amt"
      ExpressionStatement
         Gas costs: 20232
         Source: "totalSupply = sub(totalSupply,amt)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = sub(totalSupply,amt)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "sub(totalSupply,amt)"
            Identifier sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "sub"
            Identifier totalSupply
               Type: uint256
               Source: "totalSupply"
            Identifier amt
               Type: uint256
               Source: "amt"
  FunctionDefinition "mint" - public
     Source: "function mint(uint amt) onlyOwner {\r\n        balances[msg.sender] = add(balances[msg.sender], amt);\r\n        totalSupply = add(totalSupply,amt);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint amt)"
      VariableDeclaration "amt"
         Type: uint256
         Source: "uint amt"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        balances[msg.sender] = add(balances[msg.sender], amt);\r\n        totalSupply = add(totalSupply,amt);\r\n    }"
      ExpressionStatement
         Gas costs: 20422
         Source: "balances[msg.sender] = add(balances[msg.sender], amt)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = add(balances[msg.sender], amt)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "add(balances[msg.sender], amt)"
            Identifier add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "add"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier amt
               Type: uint256
               Source: "amt"
      ExpressionStatement
         Gas costs: 20232
         Source: "totalSupply = add(totalSupply,amt)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = add(totalSupply,amt)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "add(totalSupply,amt)"
            Identifier add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "add"
            Identifier totalSupply
               Type: uint256
               Source: "totalSupply"
            Identifier amt
               Type: uint256
               Source: "amt"
  FunctionDefinition "lossToCharity" - public
     Source: "function lossToCharity(uint year,address charityAccount) onlyAuth {\r\n        ethTransfer(charityAccount, games.lossToCharity(year));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint year,address charityAccount)"
      VariableDeclaration "year"
         Type: uint256
         Source: "uint year"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "charityAccount"
         Type: address
         Source: "address charityAccount"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAuth"
       Gas costs: 0
       Source: "onlyAuth"
      Identifier onlyAuth
         Type: modifier ()
         Source: "onlyAuth"
    Block
       Source: "{\r\n        ethTransfer(charityAccount, games.lossToCharity(year));\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "ethTransfer(charityAccount, games.lossToCharity(year))"
        FunctionCall
           Type: tuple()
           Source: "ethTransfer(charityAccount, games.lossToCharity(year))"
          Identifier ethTransfer
             Type: function (address,uint256)
             Source: "ethTransfer"
          Identifier charityAccount
             Type: address
             Source: "charityAccount"
          FunctionCall
             Type: uint256
             Source: "games.lossToCharity(year)"
            MemberAccess to member lossToCharity
               Type: function (uint256) external returns (uint256)
               Source: "games.lossToCharity"
              Identifier games
                 Type: contract Games
                 Source: "games"
            Identifier year
               Type: uint256
               Source: "year"
  FunctionDefinition "charityAmtToCharity" - public
     Source: "function charityAmtToCharity(address charityAccount) onlyOwner {\r\n        ethTransfer(charityAccount, games.charityAmtToCharity());\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address charityAccount)"
      VariableDeclaration "charityAccount"
         Type: address
         Source: "address charityAccount"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        ethTransfer(charityAccount, games.charityAmtToCharity());\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "ethTransfer(charityAccount, games.charityAmtToCharity())"
        FunctionCall
           Type: tuple()
           Source: "ethTransfer(charityAccount, games.charityAmtToCharity())"
          Identifier ethTransfer
             Type: function (address,uint256)
             Source: "ethTransfer"
          Identifier charityAccount
             Type: address
             Source: "charityAccount"
          FunctionCall
             Type: uint256
             Source: "games.charityAmtToCharity()"
            MemberAccess to member charityAmtToCharity
               Type: function () external returns (uint256)
               Source: "games.charityAmtToCharity"
              Identifier games
                 Type: contract Games
                 Source: "games"
  FunctionDefinition "distributeTokenSale" - public
     Source: "function distributeTokenSale(uint hour, uint month, uint year, uint charity) onlyAuth{\r\n        games.distributeTokenSale(hour, month, year, charity);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint hour, uint month, uint year, uint charity)"
      VariableDeclaration "hour"
         Type: uint256
         Source: "uint hour"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "month"
         Type: uint256
         Source: "uint month"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "year"
         Type: uint256
         Source: "uint year"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "charity"
         Type: uint256
         Source: "uint charity"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAuth"
       Gas costs: 0
       Source: "onlyAuth"
      Identifier onlyAuth
         Type: modifier ()
         Source: "onlyAuth"
    Block
       Source: "{\r\n        games.distributeTokenSale(hour, month, year, charity);\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "games.distributeTokenSale(hour, month, year, charity)"
        FunctionCall
           Type: tuple()
           Source: "games.distributeTokenSale(hour, month, year, charity)"
          MemberAccess to member distributeTokenSale
             Type: function (uint256,uint256,uint256,uint256) external
             Source: "games.distributeTokenSale"
            Identifier games
               Type: contract Games
               Source: "games"
          Identifier hour
             Type: uint256
             Source: "hour"
          Identifier month
             Type: uint256
             Source: "month"
          Identifier year
             Type: uint256
             Source: "year"
          Identifier charity
             Type: uint256
             Source: "charity"
