Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x6e95c8e8557abc08b46f3c347ba06f8dc012763f.sol =======
ContractDefinition "Factory"
   Source: "contract Factory {\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event ContractInstantiation(address sender, address instantiation);\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    mapping(address => bool) public isInstantiation;\r\n    mapping(address => address[]) public instantiations;\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Returns number of instantiations by creator.\r\n    /// @param creator Contract creator.\r\n    /// @return Returns number of instantiations by creator.\r\n    function getInstantiationCount(address creator)\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return instantiations[creator].length;\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Registers contract in factory registry.\r\n    /// @param instantiation Address of contract instantiation.\r\n    function register(address instantiation)\r\n        internal\r\n    {\r\n        isInstantiation[instantiation] = true;\r\n        instantiations[msg.sender].push(instantiation);\r\n        ContractInstantiation(msg.sender, instantiation);\r\n    }\r\n}"
  EventDefinition "ContractInstantiation"
     Gas costs: 0
     Source: "event ContractInstantiation(address sender, address instantiation);"
    ParameterList
       Source: "(address sender, address instantiation)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "instantiation"
         Type: address
         Source: "address instantiation"
        ElementaryTypeName address
           Source: "address"
  VariableDeclaration "isInstantiation"
     Type: mapping(address => bool)
     Gas costs: 468
     Source: "mapping(address => bool) public isInstantiation"
    Mapping
       Source: "mapping(address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "instantiations"
     Type: mapping(address => address[] storage ref)
     Gas costs: 792
     Source: "mapping(address => address[]) public instantiations"
    Mapping
       Source: "mapping(address => address[])"
      ElementaryTypeName address
         Source: "address"
      ArrayTypeName
         Source: "address[]"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "getInstantiationCount" - public - const
     Source: "function getInstantiationCount(address creator)\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return instantiations[creator].length;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address creator)"
      VariableDeclaration "creator"
         Type: address
         Source: "address creator"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return instantiations[creator].length;\r\n    }"
      Return
         Gas costs: 312
         Source: "return instantiations[creator].length"
        MemberAccess to member length
           Type: uint256
           Source: "instantiations[creator].length"
          IndexAccess
             Type: address[] storage ref
             Source: "instantiations[creator]"
            Identifier instantiations
               Type: mapping(address => address[] storage ref)
               Source: "instantiations"
            Identifier creator
               Type: address
               Source: "creator"
  FunctionDefinition "register"
     Source: "function register(address instantiation)\r\n        internal\r\n    {\r\n        isInstantiation[instantiation] = true;\r\n        instantiations[msg.sender].push(instantiation);\r\n        ContractInstantiation(msg.sender, instantiation);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address instantiation)"
      VariableDeclaration "instantiation"
         Type: address
         Source: "address instantiation"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        isInstantiation[instantiation] = true;\r\n        instantiations[msg.sender].push(instantiation);\r\n        ContractInstantiation(msg.sender, instantiation);\r\n    }"
      ExpressionStatement
         Gas costs: 20363
         Source: "isInstantiation[instantiation] = true"
        Assignment using operator =
           Type: bool
           Source: "isInstantiation[instantiation] = true"
          IndexAccess
             Type: bool
             Source: "isInstantiation[instantiation]"
            Identifier isInstantiation
               Type: mapping(address => bool)
               Source: "isInstantiation"
            Identifier instantiation
               Type: address
               Source: "instantiation"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 20451
         Source: "instantiations[msg.sender].push(instantiation)"
        FunctionCall
           Type: uint256
           Source: "instantiations[msg.sender].push(instantiation)"
          MemberAccess to member push
             Type: function (address) returns (uint256)
             Source: "instantiations[msg.sender].push"
            IndexAccess
               Type: address[] storage ref
               Source: "instantiations[msg.sender]"
              Identifier instantiations
                 Type: mapping(address => address[] storage ref)
                 Source: "instantiations"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          Identifier instantiation
             Type: address
             Source: "instantiation"
      ExpressionStatement
         Gas costs: [???]
         Source: "ContractInstantiation(msg.sender, instantiation)"
        FunctionCall
           Type: tuple()
           Source: "ContractInstantiation(msg.sender, instantiation)"
          Identifier ContractInstantiation
             Type: function (address,address)
             Source: "ContractInstantiation"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier instantiation
             Type: address
             Source: "instantiation"
ContractDefinition "MultiSigWallet"
   Source: "contract MultiSigWallet {\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint required);\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier onlyWallet() {\r\n        require(msg.sender == address(this));\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        require(!isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        require(isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        require(transactions[transactionId].destination != 0);\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        require(confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        require(!confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        require(!transactions[transactionId].executed);\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        require(_address != 0);\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        require(ownerCount <= MAX_OWNER_COUNT\r\n            && _required <= ownerCount\r\n            && _required != 0\r\n            && ownerCount != 0);\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function allows to deposit ether.\r\n    function()\r\n        payable\r\n    {\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    function MultiSigWallet(address[] _owners, uint _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of new owner.\r\n    function addOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerDoesNotExist(owner)\r\n        notNull(owner)\r\n        validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAddition(owner);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner.\r\n    function removeOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        OwnerRemoval(owner);\r\n    }\r\n\r\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner to be replaced.\r\n    /// @param newOwner Address of new owner.\r\n    function replaceOwner(address owner, address newOwner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n        ownerDoesNotExist(newOwner)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        OwnerRemoval(owner);\r\n        OwnerAddition(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n    /// @param _required Number of required confirmations.\r\n    function changeRequirement(uint _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        RequirementChange(_required);\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes data)\r\n        public\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction storage txn = transactions[transactionId];\r\n            txn.executed = true;\r\n            if (txn.destination.call.value(txn.value)(txn.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes data)\r\n        internal\r\n        notNull(destination)\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        Submission(transactionId);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n        public\r\n        constant\r\n        returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n}"
  EventDefinition "Confirmation"
     Gas costs: 0
     Source: "event Confirmation(address indexed sender, uint indexed transactionId);"
    ParameterList
       Source: "(address indexed sender, uint indexed transactionId)"
      VariableDeclaration "sender"
         Type: address
         Source: "address indexed sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint indexed transactionId"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Revocation"
     Gas costs: 0
     Source: "event Revocation(address indexed sender, uint indexed transactionId);"
    ParameterList
       Source: "(address indexed sender, uint indexed transactionId)"
      VariableDeclaration "sender"
         Type: address
         Source: "address indexed sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint indexed transactionId"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Submission"
     Gas costs: 0
     Source: "event Submission(uint indexed transactionId);"
    ParameterList
       Source: "(uint indexed transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint indexed transactionId"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Execution"
     Gas costs: 0
     Source: "event Execution(uint indexed transactionId);"
    ParameterList
       Source: "(uint indexed transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint indexed transactionId"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "ExecutionFailure"
     Gas costs: 0
     Source: "event ExecutionFailure(uint indexed transactionId);"
    ParameterList
       Source: "(uint indexed transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint indexed transactionId"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Deposit"
     Gas costs: 0
     Source: "event Deposit(address indexed sender, uint value);"
    ParameterList
       Source: "(address indexed sender, uint value)"
      VariableDeclaration "sender"
         Type: address
         Source: "address indexed sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "OwnerAddition"
     Gas costs: 0
     Source: "event OwnerAddition(address indexed owner);"
    ParameterList
       Source: "(address indexed owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "OwnerRemoval"
     Gas costs: 0
     Source: "event OwnerRemoval(address indexed owner);"
    ParameterList
       Source: "(address indexed owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "RequirementChange"
     Gas costs: 0
     Source: "event RequirementChange(uint required);"
    ParameterList
       Source: "(uint required)"
      VariableDeclaration "required"
         Type: uint256
         Source: "uint required"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "MAX_OWNER_COUNT"
     Type: uint256
     Gas costs: 0
     Source: "uint constant public MAX_OWNER_COUNT = 50"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 50
       Type: int_const 50
       Source: "50"
  VariableDeclaration "transactions"
     Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
     Gas costs: 0
     Source: "mapping (uint => Transaction) public transactions"
    Mapping
       Source: "mapping (uint => Transaction)"
      ElementaryTypeName uint
         Source: "uint"
      UserDefinedTypeName "Transaction"
         Source: "Transaction"
  VariableDeclaration "confirmations"
     Type: mapping(uint256 => mapping(address => bool))
     Gas costs: 0
     Source: "mapping (uint => mapping (address => bool)) public confirmations"
    Mapping
       Source: "mapping (uint => mapping (address => bool))"
      ElementaryTypeName uint
         Source: "uint"
      Mapping
         Source: "mapping (address => bool)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName bool
           Source: "bool"
  VariableDeclaration "isOwner"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping (address => bool) public isOwner"
    Mapping
       Source: "mapping (address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "owners"
     Type: address[] storage ref
     Gas costs: 0
     Source: "address[] public owners"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "required"
     Type: uint256
     Gas costs: 0
     Source: "uint public required"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "transactionCount"
     Type: uint256
     Gas costs: 0
     Source: "uint public transactionCount"
    ElementaryTypeName uint
       Source: "uint"
  StructDefinition "Transaction"
     Gas costs: 0
     Source: "struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }"
    VariableDeclaration "destination"
       Type: address
       Source: "address destination"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "value"
       Type: uint256
       Source: "uint value"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "data"
       Type: bytes storage pointer
       Source: "bytes data"
      ElementaryTypeName bytes
         Source: "bytes"
    VariableDeclaration "executed"
       Type: bool
       Source: "bool executed"
      ElementaryTypeName bool
         Source: "bool"
  ModifierDefinition "onlyWallet"
     Source: "modifier onlyWallet() {\r\n        require(msg.sender == address(this));\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(msg.sender == address(this));\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.sender == address(this))"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == address(this))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == address(this)"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            FunctionCall
               Type: address
               Source: "address(this)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Identifier this
                 Type: contract MultiSigWallet
                 Source: "this"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "ownerDoesNotExist"
     Source: "modifier ownerDoesNotExist(address owner) {\r\n        require(!isOwner[owner]);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        require(!isOwner[owner]);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!isOwner[owner])"
        FunctionCall
           Type: tuple()
           Source: "require(!isOwner[owner])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!isOwner[owner]"
            IndexAccess
               Type: bool
               Source: "isOwner[owner]"
              Identifier isOwner
                 Type: mapping(address => bool)
                 Source: "isOwner"
              Identifier owner
                 Type: address
                 Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "ownerExists"
     Source: "modifier ownerExists(address owner) {\r\n        require(isOwner[owner]);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        require(isOwner[owner]);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(isOwner[owner])"
        FunctionCall
           Type: tuple()
           Source: "require(isOwner[owner])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          IndexAccess
             Type: bool
             Source: "isOwner[owner]"
            Identifier isOwner
               Type: mapping(address => bool)
               Source: "isOwner"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "transactionExists"
     Source: "modifier transactionExists(uint transactionId) {\r\n        require(transactions[transactionId].destination != 0);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(transactions[transactionId].destination != 0);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(transactions[transactionId].destination != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(transactions[transactionId].destination != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "transactions[transactionId].destination != 0"
            MemberAccess to member destination
               Type: address
               Source: "transactions[transactionId].destination"
              IndexAccess
                 Type: struct MultiSigWallet.Transaction storage ref
                 Source: "transactions[transactionId]"
                Identifier transactions
                   Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
                   Source: "transactions"
                Identifier transactionId
                   Type: uint256
                   Source: "transactionId"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "confirmed"
     Source: "modifier confirmed(uint transactionId, address owner) {\r\n        require(confirmations[transactionId][owner]);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId, address owner)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        require(confirmations[transactionId][owner]);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(confirmations[transactionId][owner])"
        FunctionCall
           Type: tuple()
           Source: "require(confirmations[transactionId][owner])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          IndexAccess
             Type: bool
             Source: "confirmations[transactionId][owner]"
            IndexAccess
               Type: mapping(address => bool)
               Source: "confirmations[transactionId]"
              Identifier confirmations
                 Type: mapping(uint256 => mapping(address => bool))
                 Source: "confirmations"
              Identifier transactionId
                 Type: uint256
                 Source: "transactionId"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "notConfirmed"
     Source: "modifier notConfirmed(uint transactionId, address owner) {\r\n        require(!confirmations[transactionId][owner]);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId, address owner)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        require(!confirmations[transactionId][owner]);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!confirmations[transactionId][owner])"
        FunctionCall
           Type: tuple()
           Source: "require(!confirmations[transactionId][owner])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!confirmations[transactionId][owner]"
            IndexAccess
               Type: bool
               Source: "confirmations[transactionId][owner]"
              IndexAccess
                 Type: mapping(address => bool)
                 Source: "confirmations[transactionId]"
                Identifier confirmations
                   Type: mapping(uint256 => mapping(address => bool))
                   Source: "confirmations"
                Identifier transactionId
                   Type: uint256
                   Source: "transactionId"
              Identifier owner
                 Type: address
                 Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "notExecuted"
     Source: "modifier notExecuted(uint transactionId) {\r\n        require(!transactions[transactionId].executed);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(!transactions[transactionId].executed);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!transactions[transactionId].executed)"
        FunctionCall
           Type: tuple()
           Source: "require(!transactions[transactionId].executed)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!transactions[transactionId].executed"
            MemberAccess to member executed
               Type: bool
               Source: "transactions[transactionId].executed"
              IndexAccess
                 Type: struct MultiSigWallet.Transaction storage ref
                 Source: "transactions[transactionId]"
                Identifier transactions
                   Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
                   Source: "transactions"
                Identifier transactionId
                   Type: uint256
                   Source: "transactionId"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "notNull"
     Source: "modifier notNull(address _address) {\r\n        require(_address != 0);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        require(_address != 0);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_address != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_address != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_address != 0"
            Identifier _address
               Type: address
               Source: "_address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "validRequirement"
     Source: "modifier validRequirement(uint ownerCount, uint _required) {\r\n        require(ownerCount <= MAX_OWNER_COUNT\r\n            && _required <= ownerCount\r\n            && _required != 0\r\n            && ownerCount != 0);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint ownerCount, uint _required)"
      VariableDeclaration "ownerCount"
         Type: uint256
         Source: "uint ownerCount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_required"
         Type: uint256
         Source: "uint _required"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(ownerCount <= MAX_OWNER_COUNT\r\n            && _required <= ownerCount\r\n            && _required != 0\r\n            && ownerCount != 0);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(ownerCount <= MAX_OWNER_COUNT\r\n            && _required <= ownerCount\r\n            && _required != 0\r\n            && ownerCount != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(ownerCount <= MAX_OWNER_COUNT\r\n            && _required <= ownerCount\r\n            && _required != 0\r\n            && ownerCount != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "ownerCount <= MAX_OWNER_COUNT\r\n            && _required <= ownerCount\r\n            && _required != 0\r\n            && ownerCount != 0"
            BinaryOperation using operator &&
               Type: bool
               Source: "ownerCount <= MAX_OWNER_COUNT\r\n            && _required <= ownerCount\r\n            && _required != 0"
              BinaryOperation using operator &&
                 Type: bool
                 Source: "ownerCount <= MAX_OWNER_COUNT\r\n            && _required <= ownerCount"
                BinaryOperation using operator <=
                   Type: bool
                   Source: "ownerCount <= MAX_OWNER_COUNT"
                  Identifier ownerCount
                     Type: uint256
                     Source: "ownerCount"
                  Identifier MAX_OWNER_COUNT
                     Type: uint256
                     Source: "MAX_OWNER_COUNT"
                BinaryOperation using operator <=
                   Type: bool
                   Source: "_required <= ownerCount"
                  Identifier _required
                     Type: uint256
                     Source: "_required"
                  Identifier ownerCount
                     Type: uint256
                     Source: "ownerCount"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "_required != 0"
                Identifier _required
                   Type: uint256
                   Source: "_required"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            BinaryOperation using operator !=
               Type: bool
               Source: "ownerCount != 0"
              Identifier ownerCount
                 Type: uint256
                 Source: "ownerCount"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "" - public
     Source: "function()\r\n        payable\r\n    {\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }"
      IfStatement
         Source: "if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value)"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "msg.value > 0"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 0
           Source: "Deposit(msg.sender, msg.value)"
          FunctionCall
             Type: tuple()
             Source: "Deposit(msg.sender, msg.value)"
            Identifier Deposit
               Type: function (address,uint256)
               Source: "Deposit"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "MultiSigWallet" - public
     Source: "function MultiSigWallet(address[] _owners, uint _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _owners, uint _required)"
      VariableDeclaration "_owners"
         Type: address[] memory
         Source: "address[] _owners"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_required"
         Type: uint256
         Source: "uint _required"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "validRequirement"
       Gas costs: 0
       Source: "validRequirement(_owners.length, _required)"
      Identifier validRequirement
         Type: modifier (uint256,uint256)
         Source: "validRequirement"
      MemberAccess to member length
         Type: uint256
         Source: "_owners.length"
        Identifier _owners
           Type: address[] memory
           Source: "_owners"
      Identifier _required
         Type: uint256
         Source: "_required"
    Block
       Source: "{\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }"
      ForStatement
         Source: "for (uint i=0; i<_owners.length; i++) {\r\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\r\n            isOwner[_owners[i]] = true;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i<_owners.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_owners.length"
            Identifier _owners
               Type: address[] memory
               Source: "_owners"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\r\n            isOwner[_owners[i]] = true;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "require(!isOwner[_owners[i]] && _owners[i] != 0)"
            FunctionCall
               Type: tuple()
               Source: "require(!isOwner[_owners[i]] && _owners[i] != 0)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator &&
                 Type: bool
                 Source: "!isOwner[_owners[i]] && _owners[i] != 0"
                UnaryOperation (prefix) !
                   Type: bool
                   Source: "!isOwner[_owners[i]]"
                  IndexAccess
                     Type: bool
                     Source: "isOwner[_owners[i]]"
                    Identifier isOwner
                       Type: mapping(address => bool)
                       Source: "isOwner"
                    IndexAccess
                       Type: address
                       Source: "_owners[i]"
                      Identifier _owners
                         Type: address[] memory
                         Source: "_owners"
                      Identifier i
                         Type: uint256
                         Source: "i"
                BinaryOperation using operator !=
                   Type: bool
                   Source: "_owners[i] != 0"
                  IndexAccess
                     Type: address
                     Source: "_owners[i]"
                    Identifier _owners
                       Type: address[] memory
                       Source: "_owners"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
          ExpressionStatement
             Gas costs: 0
             Source: "isOwner[_owners[i]] = true"
            Assignment using operator =
               Type: bool
               Source: "isOwner[_owners[i]] = true"
              IndexAccess
                 Type: bool
                 Source: "isOwner[_owners[i]]"
                Identifier isOwner
                   Type: mapping(address => bool)
                   Source: "isOwner"
                IndexAccess
                   Type: address
                   Source: "_owners[i]"
                  Identifier _owners
                     Type: address[] memory
                     Source: "_owners"
                  Identifier i
                     Type: uint256
                     Source: "i"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "owners = _owners"
        Assignment using operator =
           Type: address[] storage ref
           Source: "owners = _owners"
          Identifier owners
             Type: address[] storage ref
             Source: "owners"
          Identifier _owners
             Type: address[] memory
             Source: "_owners"
      ExpressionStatement
         Gas costs: 0
         Source: "required = _required"
        Assignment using operator =
           Type: uint256
           Source: "required = _required"
          Identifier required
             Type: uint256
             Source: "required"
          Identifier _required
             Type: uint256
             Source: "_required"
  FunctionDefinition "addOwner" - public
     Source: "function addOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerDoesNotExist(owner)\r\n        notNull(owner)\r\n        validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAddition(owner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyWallet"
       Gas costs: 0
       Source: "onlyWallet"
      Identifier onlyWallet
         Type: modifier ()
         Source: "onlyWallet"
    ModifierInvocation "ownerDoesNotExist"
       Gas costs: 0
       Source: "ownerDoesNotExist(owner)"
      Identifier ownerDoesNotExist
         Type: modifier (address)
         Source: "ownerDoesNotExist"
      Identifier owner
         Type: address
         Source: "owner"
    ModifierInvocation "notNull"
       Gas costs: 0
       Source: "notNull(owner)"
      Identifier notNull
         Type: modifier (address)
         Source: "notNull"
      Identifier owner
         Type: address
         Source: "owner"
    ModifierInvocation "validRequirement"
       Gas costs: 0
       Source: "validRequirement(owners.length + 1, required)"
      Identifier validRequirement
         Type: modifier (uint256,uint256)
         Source: "validRequirement"
      BinaryOperation using operator +
         Type: uint256
         Source: "owners.length + 1"
        MemberAccess to member length
           Type: uint256
           Source: "owners.length"
          Identifier owners
             Type: address[] storage ref
             Source: "owners"
        Literal, token: [no token] value: 1
           Type: int_const 1
           Source: "1"
      Identifier required
         Type: uint256
         Source: "required"
    Block
       Source: "{\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAddition(owner);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "isOwner[owner] = true"
        Assignment using operator =
           Type: bool
           Source: "isOwner[owner] = true"
          IndexAccess
             Type: bool
             Source: "isOwner[owner]"
            Identifier isOwner
               Type: mapping(address => bool)
               Source: "isOwner"
            Identifier owner
               Type: address
               Source: "owner"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "owners.push(owner)"
        FunctionCall
           Type: uint256
           Source: "owners.push(owner)"
          MemberAccess to member push
             Type: function (address) returns (uint256)
             Source: "owners.push"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
          Identifier owner
             Type: address
             Source: "owner"
      ExpressionStatement
         Gas costs: 0
         Source: "OwnerAddition(owner)"
        FunctionCall
           Type: tuple()
           Source: "OwnerAddition(owner)"
          Identifier OwnerAddition
             Type: function (address)
             Source: "OwnerAddition"
          Identifier owner
             Type: address
             Source: "owner"
  FunctionDefinition "removeOwner" - public
     Source: "function removeOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        OwnerRemoval(owner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyWallet"
       Gas costs: 0
       Source: "onlyWallet"
      Identifier onlyWallet
         Type: modifier ()
         Source: "onlyWallet"
    ModifierInvocation "ownerExists"
       Gas costs: 0
       Source: "ownerExists(owner)"
      Identifier ownerExists
         Type: modifier (address)
         Source: "ownerExists"
      Identifier owner
         Type: address
         Source: "owner"
    Block
       Source: "{\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        OwnerRemoval(owner);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "isOwner[owner] = false"
        Assignment using operator =
           Type: bool
           Source: "isOwner[owner] = false"
          IndexAccess
             Type: bool
             Source: "isOwner[owner]"
            Identifier isOwner
               Type: mapping(address => bool)
               Source: "isOwner"
            Identifier owner
               Type: address
               Source: "owner"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ForStatement
         Source: "for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i<owners.length - 1"
          Identifier i
             Type: uint256
             Source: "i"
          BinaryOperation using operator -
             Type: uint256
             Source: "owners.length - 1"
            MemberAccess to member length
               Type: uint256
               Source: "owners.length"
              Identifier owners
                 Type: address[] storage ref
                 Source: "owners"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 0
             Source: "owners[i] == owner"
            IndexAccess
               Type: address
               Source: "owners[i]"
              Identifier owners
                 Type: address[] storage ref
                 Source: "owners"
              Identifier i
                 Type: uint256
                 Source: "i"
            Identifier owner
               Type: address
               Source: "owner"
          Block
             Source: "{\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }"
            ExpressionStatement
               Gas costs: 0
               Source: "owners[i] = owners[owners.length - 1]"
              Assignment using operator =
                 Type: address
                 Source: "owners[i] = owners[owners.length - 1]"
                IndexAccess
                   Type: address
                   Source: "owners[i]"
                  Identifier owners
                     Type: address[] storage ref
                     Source: "owners"
                  Identifier i
                     Type: uint256
                     Source: "i"
                IndexAccess
                   Type: address
                   Source: "owners[owners.length - 1]"
                  Identifier owners
                     Type: address[] storage ref
                     Source: "owners"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "owners.length - 1"
                    MemberAccess to member length
                       Type: uint256
                       Source: "owners.length"
                      Identifier owners
                         Type: address[] storage ref
                         Source: "owners"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
            Break
               Gas costs: 0
               Source: "break"
      ExpressionStatement
         Gas costs: 0
         Source: "owners.length -= 1"
        Assignment using operator -=
           Type: uint256
           Source: "owners.length -= 1"
          MemberAccess to member length
             Type: uint256
             Source: "owners.length"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      IfStatement
         Source: "if (required > owners.length)\r\n            changeRequirement(owners.length)"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "required > owners.length"
          Identifier required
             Type: uint256
             Source: "required"
          MemberAccess to member length
             Type: uint256
             Source: "owners.length"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
        ExpressionStatement
           Gas costs: 0
           Source: "changeRequirement(owners.length)"
          FunctionCall
             Type: tuple()
             Source: "changeRequirement(owners.length)"
            Identifier changeRequirement
               Type: function (uint256)
               Source: "changeRequirement"
            MemberAccess to member length
               Type: uint256
               Source: "owners.length"
              Identifier owners
                 Type: address[] storage ref
                 Source: "owners"
      ExpressionStatement
         Gas costs: 0
         Source: "OwnerRemoval(owner)"
        FunctionCall
           Type: tuple()
           Source: "OwnerRemoval(owner)"
          Identifier OwnerRemoval
             Type: function (address)
             Source: "OwnerRemoval"
          Identifier owner
             Type: address
             Source: "owner"
  FunctionDefinition "replaceOwner" - public
     Source: "function replaceOwner(address owner, address newOwner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n        ownerDoesNotExist(newOwner)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        OwnerRemoval(owner);\r\n        OwnerAddition(newOwner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address owner, address newOwner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyWallet"
       Gas costs: 0
       Source: "onlyWallet"
      Identifier onlyWallet
         Type: modifier ()
         Source: "onlyWallet"
    ModifierInvocation "ownerExists"
       Gas costs: 0
       Source: "ownerExists(owner)"
      Identifier ownerExists
         Type: modifier (address)
         Source: "ownerExists"
      Identifier owner
         Type: address
         Source: "owner"
    ModifierInvocation "ownerDoesNotExist"
       Gas costs: 0
       Source: "ownerDoesNotExist(newOwner)"
      Identifier ownerDoesNotExist
         Type: modifier (address)
         Source: "ownerDoesNotExist"
      Identifier newOwner
         Type: address
         Source: "newOwner"
    Block
       Source: "{\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        OwnerRemoval(owner);\r\n        OwnerAddition(newOwner);\r\n    }"
      ForStatement
         Source: "for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i<owners.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "owners.length"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 0
             Source: "owners[i] == owner"
            IndexAccess
               Type: address
               Source: "owners[i]"
              Identifier owners
                 Type: address[] storage ref
                 Source: "owners"
              Identifier i
                 Type: uint256
                 Source: "i"
            Identifier owner
               Type: address
               Source: "owner"
          Block
             Source: "{\r\n                owners[i] = newOwner;\r\n                break;\r\n            }"
            ExpressionStatement
               Gas costs: 0
               Source: "owners[i] = newOwner"
              Assignment using operator =
                 Type: address
                 Source: "owners[i] = newOwner"
                IndexAccess
                   Type: address
                   Source: "owners[i]"
                  Identifier owners
                     Type: address[] storage ref
                     Source: "owners"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Identifier newOwner
                   Type: address
                   Source: "newOwner"
            Break
               Gas costs: 0
               Source: "break"
      ExpressionStatement
         Gas costs: 0
         Source: "isOwner[owner] = false"
        Assignment using operator =
           Type: bool
           Source: "isOwner[owner] = false"
          IndexAccess
             Type: bool
             Source: "isOwner[owner]"
            Identifier isOwner
               Type: mapping(address => bool)
               Source: "isOwner"
            Identifier owner
               Type: address
               Source: "owner"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 0
         Source: "isOwner[newOwner] = true"
        Assignment using operator =
           Type: bool
           Source: "isOwner[newOwner] = true"
          IndexAccess
             Type: bool
             Source: "isOwner[newOwner]"
            Identifier isOwner
               Type: mapping(address => bool)
               Source: "isOwner"
            Identifier newOwner
               Type: address
               Source: "newOwner"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "OwnerRemoval(owner)"
        FunctionCall
           Type: tuple()
           Source: "OwnerRemoval(owner)"
          Identifier OwnerRemoval
             Type: function (address)
             Source: "OwnerRemoval"
          Identifier owner
             Type: address
             Source: "owner"
      ExpressionStatement
         Gas costs: 0
         Source: "OwnerAddition(newOwner)"
        FunctionCall
           Type: tuple()
           Source: "OwnerAddition(newOwner)"
          Identifier OwnerAddition
             Type: function (address)
             Source: "OwnerAddition"
          Identifier newOwner
             Type: address
             Source: "newOwner"
  FunctionDefinition "changeRequirement" - public
     Source: "function changeRequirement(uint _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        RequirementChange(_required);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _required)"
      VariableDeclaration "_required"
         Type: uint256
         Source: "uint _required"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyWallet"
       Gas costs: 0
       Source: "onlyWallet"
      Identifier onlyWallet
         Type: modifier ()
         Source: "onlyWallet"
    ModifierInvocation "validRequirement"
       Gas costs: 0
       Source: "validRequirement(owners.length, _required)"
      Identifier validRequirement
         Type: modifier (uint256,uint256)
         Source: "validRequirement"
      MemberAccess to member length
         Type: uint256
         Source: "owners.length"
        Identifier owners
           Type: address[] storage ref
           Source: "owners"
      Identifier _required
         Type: uint256
         Source: "_required"
    Block
       Source: "{\r\n        required = _required;\r\n        RequirementChange(_required);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "required = _required"
        Assignment using operator =
           Type: uint256
           Source: "required = _required"
          Identifier required
             Type: uint256
             Source: "required"
          Identifier _required
             Type: uint256
             Source: "_required"
      ExpressionStatement
         Gas costs: 0
         Source: "RequirementChange(_required)"
        FunctionCall
           Type: tuple()
           Source: "RequirementChange(_required)"
          Identifier RequirementChange
             Type: function (uint256)
             Source: "RequirementChange"
          Identifier _required
             Type: uint256
             Source: "_required"
  FunctionDefinition "submitTransaction" - public
     Source: "function submitTransaction(address destination, uint value, bytes data)\r\n        public\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address destination, uint value, bytes data)"
      VariableDeclaration "destination"
         Type: address
         Source: "address destination"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "data"
         Type: bytes memory
         Source: "bytes data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "transactionId = addTransaction(destination, value, data)"
        Assignment using operator =
           Type: uint256
           Source: "transactionId = addTransaction(destination, value, data)"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
          FunctionCall
             Type: uint256
             Source: "addTransaction(destination, value, data)"
            Identifier addTransaction
               Type: function (address,uint256,bytes memory) returns (uint256)
               Source: "addTransaction"
            Identifier destination
               Type: address
               Source: "destination"
            Identifier value
               Type: uint256
               Source: "value"
            Identifier data
               Type: bytes memory
               Source: "data"
      ExpressionStatement
         Gas costs: 0
         Source: "confirmTransaction(transactionId)"
        FunctionCall
           Type: tuple()
           Source: "confirmTransaction(transactionId)"
          Identifier confirmTransaction
             Type: function (uint256)
             Source: "confirmTransaction"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
  FunctionDefinition "confirmTransaction" - public
     Source: "function confirmTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerExists"
       Gas costs: 0
       Source: "ownerExists(msg.sender)"
      Identifier ownerExists
         Type: modifier (address)
         Source: "ownerExists"
      MemberAccess to member sender
         Type: address
         Source: "msg.sender"
        Identifier msg
           Type: msg
           Source: "msg"
    ModifierInvocation "transactionExists"
       Gas costs: 0
       Source: "transactionExists(transactionId)"
      Identifier transactionExists
         Type: modifier (uint256)
         Source: "transactionExists"
      Identifier transactionId
         Type: uint256
         Source: "transactionId"
    ModifierInvocation "notConfirmed"
       Gas costs: 0
       Source: "notConfirmed(transactionId, msg.sender)"
      Identifier notConfirmed
         Type: modifier (uint256,address)
         Source: "notConfirmed"
      Identifier transactionId
         Type: uint256
         Source: "transactionId"
      MemberAccess to member sender
         Type: address
         Source: "msg.sender"
        Identifier msg
           Type: msg
           Source: "msg"
    Block
       Source: "{\r\n        confirmations[transactionId][msg.sender] = true;\r\n        Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "confirmations[transactionId][msg.sender] = true"
        Assignment using operator =
           Type: bool
           Source: "confirmations[transactionId][msg.sender] = true"
          IndexAccess
             Type: bool
             Source: "confirmations[transactionId][msg.sender]"
            IndexAccess
               Type: mapping(address => bool)
               Source: "confirmations[transactionId]"
              Identifier confirmations
                 Type: mapping(uint256 => mapping(address => bool))
                 Source: "confirmations"
              Identifier transactionId
                 Type: uint256
                 Source: "transactionId"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "Confirmation(msg.sender, transactionId)"
        FunctionCall
           Type: tuple()
           Source: "Confirmation(msg.sender, transactionId)"
          Identifier Confirmation
             Type: function (address,uint256)
             Source: "Confirmation"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
      ExpressionStatement
         Gas costs: 0
         Source: "executeTransaction(transactionId)"
        FunctionCall
           Type: tuple()
           Source: "executeTransaction(transactionId)"
          Identifier executeTransaction
             Type: function (uint256)
             Source: "executeTransaction"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
  FunctionDefinition "revokeConfirmation" - public
     Source: "function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        Revocation(msg.sender, transactionId);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerExists"
       Gas costs: 0
       Source: "ownerExists(msg.sender)"
      Identifier ownerExists
         Type: modifier (address)
         Source: "ownerExists"
      MemberAccess to member sender
         Type: address
         Source: "msg.sender"
        Identifier msg
           Type: msg
           Source: "msg"
    ModifierInvocation "confirmed"
       Gas costs: 0
       Source: "confirmed(transactionId, msg.sender)"
      Identifier confirmed
         Type: modifier (uint256,address)
         Source: "confirmed"
      Identifier transactionId
         Type: uint256
         Source: "transactionId"
      MemberAccess to member sender
         Type: address
         Source: "msg.sender"
        Identifier msg
           Type: msg
           Source: "msg"
    ModifierInvocation "notExecuted"
       Gas costs: 0
       Source: "notExecuted(transactionId)"
      Identifier notExecuted
         Type: modifier (uint256)
         Source: "notExecuted"
      Identifier transactionId
         Type: uint256
         Source: "transactionId"
    Block
       Source: "{\r\n        confirmations[transactionId][msg.sender] = false;\r\n        Revocation(msg.sender, transactionId);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "confirmations[transactionId][msg.sender] = false"
        Assignment using operator =
           Type: bool
           Source: "confirmations[transactionId][msg.sender] = false"
          IndexAccess
             Type: bool
             Source: "confirmations[transactionId][msg.sender]"
            IndexAccess
               Type: mapping(address => bool)
               Source: "confirmations[transactionId]"
              Identifier confirmations
                 Type: mapping(uint256 => mapping(address => bool))
                 Source: "confirmations"
              Identifier transactionId
                 Type: uint256
                 Source: "transactionId"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 0
         Source: "Revocation(msg.sender, transactionId)"
        FunctionCall
           Type: tuple()
           Source: "Revocation(msg.sender, transactionId)"
          Identifier Revocation
             Type: function (address,uint256)
             Source: "Revocation"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
  FunctionDefinition "executeTransaction" - public
     Source: "function executeTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction storage txn = transactions[transactionId];\r\n            txn.executed = true;\r\n            if (txn.destination.call.value(txn.value)(txn.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerExists"
       Gas costs: 0
       Source: "ownerExists(msg.sender)"
      Identifier ownerExists
         Type: modifier (address)
         Source: "ownerExists"
      MemberAccess to member sender
         Type: address
         Source: "msg.sender"
        Identifier msg
           Type: msg
           Source: "msg"
    ModifierInvocation "confirmed"
       Gas costs: 0
       Source: "confirmed(transactionId, msg.sender)"
      Identifier confirmed
         Type: modifier (uint256,address)
         Source: "confirmed"
      Identifier transactionId
         Type: uint256
         Source: "transactionId"
      MemberAccess to member sender
         Type: address
         Source: "msg.sender"
        Identifier msg
           Type: msg
           Source: "msg"
    ModifierInvocation "notExecuted"
       Gas costs: 0
       Source: "notExecuted(transactionId)"
      Identifier notExecuted
         Type: modifier (uint256)
         Source: "notExecuted"
      Identifier transactionId
         Type: uint256
         Source: "transactionId"
    Block
       Source: "{\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction storage txn = transactions[transactionId];\r\n            txn.executed = true;\r\n            if (txn.destination.call.value(txn.value)(txn.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }\r\n        }\r\n    }"
      IfStatement
         Source: "if (isConfirmed(transactionId)) {\r\n            Transaction storage txn = transactions[transactionId];\r\n            txn.executed = true;\r\n            if (txn.destination.call.value(txn.value)(txn.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 0
           Source: "isConfirmed(transactionId)"
          Identifier isConfirmed
             Type: function (uint256) view returns (bool)
             Source: "isConfirmed"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
        Block
           Source: "{\r\n            Transaction storage txn = transactions[transactionId];\r\n            txn.executed = true;\r\n            if (txn.destination.call.value(txn.value)(txn.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }\r\n        }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "Transaction storage txn = transactions[transactionId]"
            VariableDeclaration "txn"
               Type: struct MultiSigWallet.Transaction storage pointer
               Source: "Transaction storage txn"
              UserDefinedTypeName "Transaction"
                 Source: "Transaction"
            IndexAccess
               Type: struct MultiSigWallet.Transaction storage ref
               Source: "transactions[transactionId]"
              Identifier transactions
                 Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
                 Source: "transactions"
              Identifier transactionId
                 Type: uint256
                 Source: "transactionId"
          ExpressionStatement
             Gas costs: 0
             Source: "txn.executed = true"
            Assignment using operator =
               Type: bool
               Source: "txn.executed = true"
              MemberAccess to member executed
                 Type: bool
                 Source: "txn.executed"
                Identifier txn
                   Type: struct MultiSigWallet.Transaction storage pointer
                   Source: "txn"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
          IfStatement
             Source: "if (txn.destination.call.value(txn.value)(txn.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }"
            FunctionCall
               Type: bool
               Gas costs: 0
               Source: "txn.destination.call.value(txn.value)(txn.data)"
              FunctionCall
                 Type: function () payable returns (bool)
                 Source: "txn.destination.call.value(txn.value)"
                MemberAccess to member value
                   Type: function (uint256) returns (function () payable returns (bool))
                   Source: "txn.destination.call.value"
                  MemberAccess to member call
                     Type: function () payable returns (bool)
                     Source: "txn.destination.call"
                    MemberAccess to member destination
                       Type: address
                       Source: "txn.destination"
                      Identifier txn
                         Type: struct MultiSigWallet.Transaction storage pointer
                         Source: "txn"
                MemberAccess to member value
                   Type: uint256
                   Source: "txn.value"
                  Identifier txn
                     Type: struct MultiSigWallet.Transaction storage pointer
                     Source: "txn"
              MemberAccess to member data
                 Type: bytes storage ref
                 Source: "txn.data"
                Identifier txn
                   Type: struct MultiSigWallet.Transaction storage pointer
                   Source: "txn"
            ExpressionStatement
               Gas costs: 0
               Source: "Execution(transactionId)"
              FunctionCall
                 Type: tuple()
                 Source: "Execution(transactionId)"
                Identifier Execution
                   Type: function (uint256)
                   Source: "Execution"
                Identifier transactionId
                   Type: uint256
                   Source: "transactionId"
            Block
               Source: "{\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "ExecutionFailure(transactionId)"
                FunctionCall
                   Type: tuple()
                   Source: "ExecutionFailure(transactionId)"
                  Identifier ExecutionFailure
                     Type: function (uint256)
                     Source: "ExecutionFailure"
                  Identifier transactionId
                     Type: uint256
                     Source: "transactionId"
              ExpressionStatement
                 Gas costs: 0
                 Source: "txn.executed = false"
                Assignment using operator =
                   Type: bool
                   Source: "txn.executed = false"
                  MemberAccess to member executed
                     Type: bool
                     Source: "txn.executed"
                    Identifier txn
                       Type: struct MultiSigWallet.Transaction storage pointer
                       Source: "txn"
                  Literal, token: false value: false
                     Type: bool
                     Source: "false"
  FunctionDefinition "isConfirmed" - public - const
     Source: "function isConfirmed(uint transactionId)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint count = 0"
        VariableDeclaration "count"
           Type: uint256
           Source: "uint count"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i<owners.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "owners.length"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }"
          IfStatement
             Source: "if (confirmations[transactionId][owners[i]])\r\n                count += 1"
            IndexAccess
               Type: bool
               Gas costs: 0
               Source: "confirmations[transactionId][owners[i]]"
              IndexAccess
                 Type: mapping(address => bool)
                 Source: "confirmations[transactionId]"
                Identifier confirmations
                   Type: mapping(uint256 => mapping(address => bool))
                   Source: "confirmations"
                Identifier transactionId
                   Type: uint256
                   Source: "transactionId"
              IndexAccess
                 Type: address
                 Source: "owners[i]"
                Identifier owners
                   Type: address[] storage ref
                   Source: "owners"
                Identifier i
                   Type: uint256
                   Source: "i"
            ExpressionStatement
               Gas costs: 0
               Source: "count += 1"
              Assignment using operator +=
                 Type: uint256
                 Source: "count += 1"
                Identifier count
                   Type: uint256
                   Source: "count"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
          IfStatement
             Source: "if (count == required)\r\n                return true"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "count == required"
              Identifier count
                 Type: uint256
                 Source: "count"
              Identifier required
                 Type: uint256
                 Source: "required"
            Return
               Gas costs: 0
               Source: "return true"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
  FunctionDefinition "addTransaction"
     Source: "function addTransaction(address destination, uint value, bytes data)\r\n        internal\r\n        notNull(destination)\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        Submission(transactionId);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address destination, uint value, bytes data)"
      VariableDeclaration "destination"
         Type: address
         Source: "address destination"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "data"
         Type: bytes memory
         Source: "bytes data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "notNull"
       Gas costs: 0
       Source: "notNull(destination)"
      Identifier notNull
         Type: modifier (address)
         Source: "notNull"
      Identifier destination
         Type: address
         Source: "destination"
    Block
       Source: "{\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        Submission(transactionId);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "transactionId = transactionCount"
        Assignment using operator =
           Type: uint256
           Source: "transactionId = transactionCount"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
          Identifier transactionCount
             Type: uint256
             Source: "transactionCount"
      ExpressionStatement
         Gas costs: 0
         Source: "transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        })"
        Assignment using operator =
           Type: struct MultiSigWallet.Transaction storage ref
           Source: "transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        })"
          IndexAccess
             Type: struct MultiSigWallet.Transaction storage ref
             Source: "transactions[transactionId]"
            Identifier transactions
               Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
               Source: "transactions"
            Identifier transactionId
               Type: uint256
               Source: "transactionId"
          FunctionCall
             Type: struct MultiSigWallet.Transaction memory
             Source: "Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        })"
            Identifier Transaction
               Type: type(struct MultiSigWallet.Transaction storage pointer)
               Source: "Transaction"
            Identifier destination
               Type: address
               Source: "destination"
            Identifier value
               Type: uint256
               Source: "value"
            Identifier data
               Type: bytes memory
               Source: "data"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      ExpressionStatement
         Gas costs: 0
         Source: "transactionCount += 1"
        Assignment using operator +=
           Type: uint256
           Source: "transactionCount += 1"
          Identifier transactionCount
             Type: uint256
             Source: "transactionCount"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "Submission(transactionId)"
        FunctionCall
           Type: tuple()
           Source: "Submission(transactionId)"
          Identifier Submission
             Type: function (uint256)
             Source: "Submission"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
  FunctionDefinition "getConfirmationCount" - public - const
     Source: "function getConfirmationCount(uint transactionId)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint count)"
      VariableDeclaration "count"
         Type: uint256
         Source: "uint count"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }"
      ForStatement
         Source: "for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i<owners.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "owners.length"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (confirmations[transactionId][owners[i]])\r\n                count += 1"
          IndexAccess
             Type: bool
             Gas costs: 0
             Source: "confirmations[transactionId][owners[i]]"
            IndexAccess
               Type: mapping(address => bool)
               Source: "confirmations[transactionId]"
              Identifier confirmations
                 Type: mapping(uint256 => mapping(address => bool))
                 Source: "confirmations"
              Identifier transactionId
                 Type: uint256
                 Source: "transactionId"
            IndexAccess
               Type: address
               Source: "owners[i]"
              Identifier owners
                 Type: address[] storage ref
                 Source: "owners"
              Identifier i
                 Type: uint256
                 Source: "i"
          ExpressionStatement
             Gas costs: 0
             Source: "count += 1"
            Assignment using operator +=
               Type: uint256
               Source: "count += 1"
              Identifier count
                 Type: uint256
                 Source: "count"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
  FunctionDefinition "getTransactionCount" - public - const
     Source: "function getTransactionCount(bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bool pending, bool executed)"
      VariableDeclaration "pending"
         Type: bool
         Source: "bool pending"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "executed"
         Type: bool
         Source: "bool executed"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: "(uint count)"
      VariableDeclaration "count"
         Type: uint256
         Source: "uint count"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1;\r\n    }"
      ForStatement
         Source: "for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i<transactionCount"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier transactionCount
             Type: uint256
             Source: "transactionCount"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1"
          BinaryOperation using operator ||
             Type: bool
             Gas costs: 0
             Source: "pending && !transactions[i].executed\r\n                || executed && transactions[i].executed"
            BinaryOperation using operator &&
               Type: bool
               Source: "pending && !transactions[i].executed"
              Identifier pending
                 Type: bool
                 Source: "pending"
              UnaryOperation (prefix) !
                 Type: bool
                 Source: "!transactions[i].executed"
                MemberAccess to member executed
                   Type: bool
                   Source: "transactions[i].executed"
                  IndexAccess
                     Type: struct MultiSigWallet.Transaction storage ref
                     Source: "transactions[i]"
                    Identifier transactions
                       Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
                       Source: "transactions"
                    Identifier i
                       Type: uint256
                       Source: "i"
            BinaryOperation using operator &&
               Type: bool
               Source: "executed && transactions[i].executed"
              Identifier executed
                 Type: bool
                 Source: "executed"
              MemberAccess to member executed
                 Type: bool
                 Source: "transactions[i].executed"
                IndexAccess
                   Type: struct MultiSigWallet.Transaction storage ref
                   Source: "transactions[i]"
                  Identifier transactions
                     Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
                     Source: "transactions"
                  Identifier i
                     Type: uint256
                     Source: "i"
          ExpressionStatement
             Gas costs: 0
             Source: "count += 1"
            Assignment using operator +=
               Type: uint256
               Source: "count += 1"
              Identifier count
                 Type: uint256
                 Source: "count"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
  FunctionDefinition "getOwners" - public - const
     Source: "function getOwners()\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return owners;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address[])"
      VariableDeclaration ""
         Type: address[] memory
         Source: "address[]"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\r\n        return owners;\r\n    }"
      Return
         Gas costs: 0
         Source: "return owners"
        Identifier owners
           Type: address[] storage ref
           Source: "owners"
  FunctionDefinition "getConfirmations" - public - const
     Source: "function getConfirmations(uint transactionId)\r\n        public\r\n        constant\r\n        returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(address[] _confirmations)"
      VariableDeclaration "_confirmations"
         Type: address[] memory
         Source: "address[] _confirmations"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "address[] memory confirmationsTemp = new address[](owners.length)"
        VariableDeclaration "confirmationsTemp"
           Type: address[] memory
           Source: "address[] memory confirmationsTemp"
          ArrayTypeName
             Source: "address[]"
            ElementaryTypeName address
               Source: "address"
        FunctionCall
           Type: address[] memory
           Source: "new address[](owners.length)"
          NewExpression
             Type: function (uint256) pure returns (address[] memory)
             Source: "new address[]"
            ArrayTypeName
               Source: "address[]"
              ElementaryTypeName address
                 Source: "address"
          MemberAccess to member length
             Type: uint256
             Source: "owners.length"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint count = 0"
        VariableDeclaration "count"
           Type: uint256
           Source: "uint count"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint i"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint i"
          ElementaryTypeName uint
             Source: "uint"
      ForStatement
         Source: "for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }"
        ExpressionStatement
           Gas costs: 0
           Source: "i=0"
          Assignment using operator =
             Type: uint256
             Source: "i=0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i<owners.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "owners.length"
            Identifier owners
               Type: address[] storage ref
               Source: "owners"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }"
          IndexAccess
             Type: bool
             Gas costs: 0
             Source: "confirmations[transactionId][owners[i]]"
            IndexAccess
               Type: mapping(address => bool)
               Source: "confirmations[transactionId]"
              Identifier confirmations
                 Type: mapping(uint256 => mapping(address => bool))
                 Source: "confirmations"
              Identifier transactionId
                 Type: uint256
                 Source: "transactionId"
            IndexAccess
               Type: address
               Source: "owners[i]"
              Identifier owners
                 Type: address[] storage ref
                 Source: "owners"
              Identifier i
                 Type: uint256
                 Source: "i"
          Block
             Source: "{\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }"
            ExpressionStatement
               Gas costs: 0
               Source: "confirmationsTemp[count] = owners[i]"
              Assignment using operator =
                 Type: address
                 Source: "confirmationsTemp[count] = owners[i]"
                IndexAccess
                   Type: address
                   Source: "confirmationsTemp[count]"
                  Identifier confirmationsTemp
                     Type: address[] memory
                     Source: "confirmationsTemp"
                  Identifier count
                     Type: uint256
                     Source: "count"
                IndexAccess
                   Type: address
                   Source: "owners[i]"
                  Identifier owners
                     Type: address[] storage ref
                     Source: "owners"
                  Identifier i
                     Type: uint256
                     Source: "i"
            ExpressionStatement
               Gas costs: 0
               Source: "count += 1"
              Assignment using operator +=
                 Type: uint256
                 Source: "count += 1"
                Identifier count
                   Type: uint256
                   Source: "count"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "_confirmations = new address[](count)"
        Assignment using operator =
           Type: address[] memory
           Source: "_confirmations = new address[](count)"
          Identifier _confirmations
             Type: address[] memory
             Source: "_confirmations"
          FunctionCall
             Type: address[] memory
             Source: "new address[](count)"
            NewExpression
               Type: function (uint256) pure returns (address[] memory)
               Source: "new address[]"
              ArrayTypeName
                 Source: "address[]"
                ElementaryTypeName address
                   Source: "address"
            Identifier count
               Type: uint256
               Source: "count"
      ForStatement
         Source: "for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i]"
        ExpressionStatement
           Gas costs: 0
           Source: "i=0"
          Assignment using operator =
             Type: uint256
             Source: "i=0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i<count"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier count
             Type: uint256
             Source: "count"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        ExpressionStatement
           Gas costs: 0
           Source: "_confirmations[i] = confirmationsTemp[i]"
          Assignment using operator =
             Type: address
             Source: "_confirmations[i] = confirmationsTemp[i]"
            IndexAccess
               Type: address
               Source: "_confirmations[i]"
              Identifier _confirmations
                 Type: address[] memory
                 Source: "_confirmations"
              Identifier i
                 Type: uint256
                 Source: "i"
            IndexAccess
               Type: address
               Source: "confirmationsTemp[i]"
              Identifier confirmationsTemp
                 Type: address[] memory
                 Source: "confirmationsTemp"
              Identifier i
                 Type: uint256
                 Source: "i"
  FunctionDefinition "getTransactionIds" - public - const
     Source: "function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint from, uint to, bool pending, bool executed)"
      VariableDeclaration "from"
         Type: uint256
         Source: "uint from"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "to"
         Type: uint256
         Source: "uint to"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "pending"
         Type: bool
         Source: "bool pending"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "executed"
         Type: bool
         Source: "bool executed"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: "(uint[] _transactionIds)"
      VariableDeclaration "_transactionIds"
         Type: uint256[] memory
         Source: "uint[] _transactionIds"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    Block
       Source: "{\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint[] memory transactionIdsTemp = new uint[](transactionCount)"
        VariableDeclaration "transactionIdsTemp"
           Type: uint256[] memory
           Source: "uint[] memory transactionIdsTemp"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](transactionCount)"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          Identifier transactionCount
             Type: uint256
             Source: "transactionCount"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint count = 0"
        VariableDeclaration "count"
           Type: uint256
           Source: "uint count"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint i"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint i"
          ElementaryTypeName uint
             Source: "uint"
      ForStatement
         Source: "for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }"
        ExpressionStatement
           Gas costs: 0
           Source: "i=0"
          Assignment using operator =
             Type: uint256
             Source: "i=0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i<transactionCount"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier transactionCount
             Type: uint256
             Source: "transactionCount"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }"
          BinaryOperation using operator ||
             Type: bool
             Gas costs: 0
             Source: "pending && !transactions[i].executed\r\n                || executed && transactions[i].executed"
            BinaryOperation using operator &&
               Type: bool
               Source: "pending && !transactions[i].executed"
              Identifier pending
                 Type: bool
                 Source: "pending"
              UnaryOperation (prefix) !
                 Type: bool
                 Source: "!transactions[i].executed"
                MemberAccess to member executed
                   Type: bool
                   Source: "transactions[i].executed"
                  IndexAccess
                     Type: struct MultiSigWallet.Transaction storage ref
                     Source: "transactions[i]"
                    Identifier transactions
                       Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
                       Source: "transactions"
                    Identifier i
                       Type: uint256
                       Source: "i"
            BinaryOperation using operator &&
               Type: bool
               Source: "executed && transactions[i].executed"
              Identifier executed
                 Type: bool
                 Source: "executed"
              MemberAccess to member executed
                 Type: bool
                 Source: "transactions[i].executed"
                IndexAccess
                   Type: struct MultiSigWallet.Transaction storage ref
                   Source: "transactions[i]"
                  Identifier transactions
                     Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
                     Source: "transactions"
                  Identifier i
                     Type: uint256
                     Source: "i"
          Block
             Source: "{\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }"
            ExpressionStatement
               Gas costs: 0
               Source: "transactionIdsTemp[count] = i"
              Assignment using operator =
                 Type: uint256
                 Source: "transactionIdsTemp[count] = i"
                IndexAccess
                   Type: uint256
                   Source: "transactionIdsTemp[count]"
                  Identifier transactionIdsTemp
                     Type: uint256[] memory
                     Source: "transactionIdsTemp"
                  Identifier count
                     Type: uint256
                     Source: "count"
                Identifier i
                   Type: uint256
                   Source: "i"
            ExpressionStatement
               Gas costs: 0
               Source: "count += 1"
              Assignment using operator +=
                 Type: uint256
                 Source: "count += 1"
                Identifier count
                   Type: uint256
                   Source: "count"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      ExpressionStatement
         Gas costs: 0
         Source: "_transactionIds = new uint[](to - from)"
        Assignment using operator =
           Type: uint256[] memory
           Source: "_transactionIds = new uint[](to - from)"
          Identifier _transactionIds
             Type: uint256[] memory
             Source: "_transactionIds"
          FunctionCall
             Type: uint256[] memory
             Source: "new uint[](to - from)"
            NewExpression
               Type: function (uint256) pure returns (uint256[] memory)
               Source: "new uint[]"
              ArrayTypeName
                 Source: "uint[]"
                ElementaryTypeName uint
                   Source: "uint"
            BinaryOperation using operator -
               Type: uint256
               Source: "to - from"
              Identifier to
                 Type: uint256
                 Source: "to"
              Identifier from
                 Type: uint256
                 Source: "from"
      ForStatement
         Source: "for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i]"
        ExpressionStatement
           Gas costs: 0
           Source: "i=from"
          Assignment using operator =
             Type: uint256
             Source: "i=from"
            Identifier i
               Type: uint256
               Source: "i"
            Identifier from
               Type: uint256
               Source: "from"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i<to"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier to
             Type: uint256
             Source: "to"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        ExpressionStatement
           Gas costs: 0
           Source: "_transactionIds[i - from] = transactionIdsTemp[i]"
          Assignment using operator =
             Type: uint256
             Source: "_transactionIds[i - from] = transactionIdsTemp[i]"
            IndexAccess
               Type: uint256
               Source: "_transactionIds[i - from]"
              Identifier _transactionIds
                 Type: uint256[] memory
                 Source: "_transactionIds"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "i - from"
                Identifier i
                   Type: uint256
                   Source: "i"
                Identifier from
                   Type: uint256
                   Source: "from"
            IndexAccess
               Type: uint256
               Source: "transactionIdsTemp[i]"
              Identifier transactionIdsTemp
                 Type: uint256[] memory
                 Source: "transactionIdsTemp"
              Identifier i
                 Type: uint256
                 Source: "i"
ContractDefinition "MultiSigWalletWithDailyLimit"
   Source: "contract MultiSigWalletWithDailyLimit is MultiSigWallet {\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event DailyLimitChange(uint dailyLimit);\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    uint public dailyLimit;\r\n    uint public lastDay;\r\n    uint public spentToday;\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners, required number of confirmations and daily withdraw limit.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    /// @param _dailyLimit Amount in wei, which can be withdrawn without confirmations on a daily basis.\r\n    function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)\r\n        public\r\n        MultiSigWallet(_owners, _required)\r\n    {\r\n        dailyLimit = _dailyLimit;\r\n    }\r\n\r\n    /// @dev Allows to change the daily limit. Transaction has to be sent by wallet.\r\n    /// @param _dailyLimit Amount in wei.\r\n    function changeDailyLimit(uint _dailyLimit)\r\n        public\r\n        onlyWallet\r\n    {\r\n        dailyLimit = _dailyLimit;\r\n        DailyLimitChange(_dailyLimit);\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction or ether withdraws until daily limit is reached.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        Transaction storage txn = transactions[transactionId];\r\n        bool _confirmed = isConfirmed(transactionId);\r\n        if (_confirmed || txn.data.length == 0 && isUnderLimit(txn.value)) {\r\n            txn.executed = true;\r\n            if (!_confirmed)\r\n                spentToday += txn.value;\r\n            if (txn.destination.call.value(txn.value)(txn.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n                if (!_confirmed)\r\n                    spentToday -= txn.value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Returns if amount is within daily limit and resets spentToday after one day.\r\n    /// @param amount Amount to withdraw.\r\n    /// @return Returns if amount is under daily limit.\r\n    function isUnderLimit(uint amount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (now > lastDay + 24 hours) {\r\n            lastDay = now;\r\n            spentToday = 0;\r\n        }\r\n        if (spentToday + amount > dailyLimit || spentToday + amount < spentToday)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns maximum withdraw amount.\r\n    /// @return Returns amount.\r\n    function calcMaxWithdraw()\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        if (now > lastDay + 24 hours)\r\n            return dailyLimit;\r\n        if (dailyLimit < spentToday)\r\n            return 0;\r\n        return dailyLimit - spentToday;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "MultiSigWallet"
    UserDefinedTypeName "MultiSigWallet"
       Source: "MultiSigWallet"
  EventDefinition "DailyLimitChange"
     Gas costs: 0
     Source: "event DailyLimitChange(uint dailyLimit);"
    ParameterList
       Source: "(uint dailyLimit)"
      VariableDeclaration "dailyLimit"
         Type: uint256
         Source: "uint dailyLimit"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "dailyLimit"
     Type: uint256
     Gas costs: 0
     Source: "uint public dailyLimit"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "lastDay"
     Type: uint256
     Gas costs: 0
     Source: "uint public lastDay"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "spentToday"
     Type: uint256
     Gas costs: 0
     Source: "uint public spentToday"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "MultiSigWalletWithDailyLimit" - public
     Source: "function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)\r\n        public\r\n        MultiSigWallet(_owners, _required)\r\n    {\r\n        dailyLimit = _dailyLimit;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _owners, uint _required, uint _dailyLimit)"
      VariableDeclaration "_owners"
         Type: address[] memory
         Source: "address[] _owners"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_required"
         Type: uint256
         Source: "uint _required"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_dailyLimit"
         Type: uint256
         Source: "uint _dailyLimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "MultiSigWallet"
       Gas costs: 0
       Source: "MultiSigWallet(_owners, _required)"
      Identifier MultiSigWallet
         Type: type(contract MultiSigWallet)
         Source: "MultiSigWallet"
      Identifier _owners
         Type: address[] memory
         Source: "_owners"
      Identifier _required
         Type: uint256
         Source: "_required"
    Block
       Source: "{\r\n        dailyLimit = _dailyLimit;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "dailyLimit = _dailyLimit"
        Assignment using operator =
           Type: uint256
           Source: "dailyLimit = _dailyLimit"
          Identifier dailyLimit
             Type: uint256
             Source: "dailyLimit"
          Identifier _dailyLimit
             Type: uint256
             Source: "_dailyLimit"
  FunctionDefinition "changeDailyLimit" - public
     Source: "function changeDailyLimit(uint _dailyLimit)\r\n        public\r\n        onlyWallet\r\n    {\r\n        dailyLimit = _dailyLimit;\r\n        DailyLimitChange(_dailyLimit);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _dailyLimit)"
      VariableDeclaration "_dailyLimit"
         Type: uint256
         Source: "uint _dailyLimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyWallet"
       Gas costs: 0
       Source: "onlyWallet"
      Identifier onlyWallet
         Type: modifier ()
         Source: "onlyWallet"
    Block
       Source: "{\r\n        dailyLimit = _dailyLimit;\r\n        DailyLimitChange(_dailyLimit);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "dailyLimit = _dailyLimit"
        Assignment using operator =
           Type: uint256
           Source: "dailyLimit = _dailyLimit"
          Identifier dailyLimit
             Type: uint256
             Source: "dailyLimit"
          Identifier _dailyLimit
             Type: uint256
             Source: "_dailyLimit"
      ExpressionStatement
         Gas costs: 0
         Source: "DailyLimitChange(_dailyLimit)"
        FunctionCall
           Type: tuple()
           Source: "DailyLimitChange(_dailyLimit)"
          Identifier DailyLimitChange
             Type: function (uint256)
             Source: "DailyLimitChange"
          Identifier _dailyLimit
             Type: uint256
             Source: "_dailyLimit"
  FunctionDefinition "executeTransaction" - public
     Source: "function executeTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        Transaction storage txn = transactions[transactionId];\r\n        bool _confirmed = isConfirmed(transactionId);\r\n        if (_confirmed || txn.data.length == 0 && isUnderLimit(txn.value)) {\r\n            txn.executed = true;\r\n            if (!_confirmed)\r\n                spentToday += txn.value;\r\n            if (txn.destination.call.value(txn.value)(txn.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n                if (!_confirmed)\r\n                    spentToday -= txn.value;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint transactionId)"
      VariableDeclaration "transactionId"
         Type: uint256
         Source: "uint transactionId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerExists"
       Gas costs: 0
       Source: "ownerExists(msg.sender)"
      Identifier ownerExists
         Type: modifier (address)
         Source: "ownerExists"
      MemberAccess to member sender
         Type: address
         Source: "msg.sender"
        Identifier msg
           Type: msg
           Source: "msg"
    ModifierInvocation "confirmed"
       Gas costs: 0
       Source: "confirmed(transactionId, msg.sender)"
      Identifier confirmed
         Type: modifier (uint256,address)
         Source: "confirmed"
      Identifier transactionId
         Type: uint256
         Source: "transactionId"
      MemberAccess to member sender
         Type: address
         Source: "msg.sender"
        Identifier msg
           Type: msg
           Source: "msg"
    ModifierInvocation "notExecuted"
       Gas costs: 0
       Source: "notExecuted(transactionId)"
      Identifier notExecuted
         Type: modifier (uint256)
         Source: "notExecuted"
      Identifier transactionId
         Type: uint256
         Source: "transactionId"
    Block
       Source: "{\r\n        Transaction storage txn = transactions[transactionId];\r\n        bool _confirmed = isConfirmed(transactionId);\r\n        if (_confirmed || txn.data.length == 0 && isUnderLimit(txn.value)) {\r\n            txn.executed = true;\r\n            if (!_confirmed)\r\n                spentToday += txn.value;\r\n            if (txn.destination.call.value(txn.value)(txn.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n                if (!_confirmed)\r\n                    spentToday -= txn.value;\r\n            }\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "Transaction storage txn = transactions[transactionId]"
        VariableDeclaration "txn"
           Type: struct MultiSigWallet.Transaction storage pointer
           Source: "Transaction storage txn"
          UserDefinedTypeName "Transaction"
             Source: "Transaction"
        IndexAccess
           Type: struct MultiSigWallet.Transaction storage ref
           Source: "transactions[transactionId]"
          Identifier transactions
             Type: mapping(uint256 => struct MultiSigWallet.Transaction storage ref)
             Source: "transactions"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bool _confirmed = isConfirmed(transactionId)"
        VariableDeclaration "_confirmed"
           Type: bool
           Source: "bool _confirmed"
          ElementaryTypeName bool
             Source: "bool"
        FunctionCall
           Type: bool
           Source: "isConfirmed(transactionId)"
          Identifier isConfirmed
             Type: function (uint256) view returns (bool)
             Source: "isConfirmed"
          Identifier transactionId
             Type: uint256
             Source: "transactionId"
      IfStatement
         Source: "if (_confirmed || txn.data.length == 0 && isUnderLimit(txn.value)) {\r\n            txn.executed = true;\r\n            if (!_confirmed)\r\n                spentToday += txn.value;\r\n            if (txn.destination.call.value(txn.value)(txn.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n                if (!_confirmed)\r\n                    spentToday -= txn.value;\r\n            }\r\n        }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 0
           Source: "_confirmed || txn.data.length == 0 && isUnderLimit(txn.value)"
          Identifier _confirmed
             Type: bool
             Source: "_confirmed"
          BinaryOperation using operator &&
             Type: bool
             Source: "txn.data.length == 0 && isUnderLimit(txn.value)"
            BinaryOperation using operator ==
               Type: bool
               Source: "txn.data.length == 0"
              MemberAccess to member length
                 Type: uint256
                 Source: "txn.data.length"
                MemberAccess to member data
                   Type: bytes storage ref
                   Source: "txn.data"
                  Identifier txn
                     Type: struct MultiSigWallet.Transaction storage pointer
                     Source: "txn"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            FunctionCall
               Type: bool
               Source: "isUnderLimit(txn.value)"
              Identifier isUnderLimit
                 Type: function (uint256) returns (bool)
                 Source: "isUnderLimit"
              MemberAccess to member value
                 Type: uint256
                 Source: "txn.value"
                Identifier txn
                   Type: struct MultiSigWallet.Transaction storage pointer
                   Source: "txn"
        Block
           Source: "{\r\n            txn.executed = true;\r\n            if (!_confirmed)\r\n                spentToday += txn.value;\r\n            if (txn.destination.call.value(txn.value)(txn.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n                if (!_confirmed)\r\n                    spentToday -= txn.value;\r\n            }\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "txn.executed = true"
            Assignment using operator =
               Type: bool
               Source: "txn.executed = true"
              MemberAccess to member executed
                 Type: bool
                 Source: "txn.executed"
                Identifier txn
                   Type: struct MultiSigWallet.Transaction storage pointer
                   Source: "txn"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
          IfStatement
             Source: "if (!_confirmed)\r\n                spentToday += txn.value"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: 0
               Source: "!_confirmed"
              Identifier _confirmed
                 Type: bool
                 Source: "_confirmed"
            ExpressionStatement
               Gas costs: 0
               Source: "spentToday += txn.value"
              Assignment using operator +=
                 Type: uint256
                 Source: "spentToday += txn.value"
                Identifier spentToday
                   Type: uint256
                   Source: "spentToday"
                MemberAccess to member value
                   Type: uint256
                   Source: "txn.value"
                  Identifier txn
                     Type: struct MultiSigWallet.Transaction storage pointer
                     Source: "txn"
          IfStatement
             Source: "if (txn.destination.call.value(txn.value)(txn.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n                if (!_confirmed)\r\n                    spentToday -= txn.value;\r\n            }"
            FunctionCall
               Type: bool
               Gas costs: 0
               Source: "txn.destination.call.value(txn.value)(txn.data)"
              FunctionCall
                 Type: function () payable returns (bool)
                 Source: "txn.destination.call.value(txn.value)"
                MemberAccess to member value
                   Type: function (uint256) returns (function () payable returns (bool))
                   Source: "txn.destination.call.value"
                  MemberAccess to member call
                     Type: function () payable returns (bool)
                     Source: "txn.destination.call"
                    MemberAccess to member destination
                       Type: address
                       Source: "txn.destination"
                      Identifier txn
                         Type: struct MultiSigWallet.Transaction storage pointer
                         Source: "txn"
                MemberAccess to member value
                   Type: uint256
                   Source: "txn.value"
                  Identifier txn
                     Type: struct MultiSigWallet.Transaction storage pointer
                     Source: "txn"
              MemberAccess to member data
                 Type: bytes storage ref
                 Source: "txn.data"
                Identifier txn
                   Type: struct MultiSigWallet.Transaction storage pointer
                   Source: "txn"
            ExpressionStatement
               Gas costs: 0
               Source: "Execution(transactionId)"
              FunctionCall
                 Type: tuple()
                 Source: "Execution(transactionId)"
                Identifier Execution
                   Type: function (uint256)
                   Source: "Execution"
                Identifier transactionId
                   Type: uint256
                   Source: "transactionId"
            Block
               Source: "{\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n                if (!_confirmed)\r\n                    spentToday -= txn.value;\r\n            }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "ExecutionFailure(transactionId)"
                FunctionCall
                   Type: tuple()
                   Source: "ExecutionFailure(transactionId)"
                  Identifier ExecutionFailure
                     Type: function (uint256)
                     Source: "ExecutionFailure"
                  Identifier transactionId
                     Type: uint256
                     Source: "transactionId"
              ExpressionStatement
                 Gas costs: 0
                 Source: "txn.executed = false"
                Assignment using operator =
                   Type: bool
                   Source: "txn.executed = false"
                  MemberAccess to member executed
                     Type: bool
                     Source: "txn.executed"
                    Identifier txn
                       Type: struct MultiSigWallet.Transaction storage pointer
                       Source: "txn"
                  Literal, token: false value: false
                     Type: bool
                     Source: "false"
              IfStatement
                 Source: "if (!_confirmed)\r\n                    spentToday -= txn.value"
                UnaryOperation (prefix) !
                   Type: bool
                   Gas costs: 0
                   Source: "!_confirmed"
                  Identifier _confirmed
                     Type: bool
                     Source: "_confirmed"
                ExpressionStatement
                   Gas costs: 0
                   Source: "spentToday -= txn.value"
                  Assignment using operator -=
                     Type: uint256
                     Source: "spentToday -= txn.value"
                    Identifier spentToday
                       Type: uint256
                       Source: "spentToday"
                    MemberAccess to member value
                       Type: uint256
                       Source: "txn.value"
                      Identifier txn
                         Type: struct MultiSigWallet.Transaction storage pointer
                         Source: "txn"
  FunctionDefinition "isUnderLimit"
     Source: "function isUnderLimit(uint amount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (now > lastDay + 24 hours) {\r\n            lastDay = now;\r\n            spentToday = 0;\r\n        }\r\n        if (spentToday + amount > dailyLimit || spentToday + amount < spentToday)\r\n            return false;\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if (now > lastDay + 24 hours) {\r\n            lastDay = now;\r\n            spentToday = 0;\r\n        }\r\n        if (spentToday + amount > dailyLimit || spentToday + amount < spentToday)\r\n            return false;\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (now > lastDay + 24 hours) {\r\n            lastDay = now;\r\n            spentToday = 0;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "now > lastDay + 24 hours"
          Identifier now
             Type: uint256
             Source: "now"
          BinaryOperation using operator +
             Type: uint256
             Source: "lastDay + 24 hours"
            Identifier lastDay
               Type: uint256
               Source: "lastDay"
            Literal, token: [no token] value: 24
               Type: int_const 86400
               Source: "24 hours"
        Block
           Source: "{\r\n            lastDay = now;\r\n            spentToday = 0;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "lastDay = now"
            Assignment using operator =
               Type: uint256
               Source: "lastDay = now"
              Identifier lastDay
                 Type: uint256
                 Source: "lastDay"
              Identifier now
                 Type: uint256
                 Source: "now"
          ExpressionStatement
             Gas costs: 0
             Source: "spentToday = 0"
            Assignment using operator =
               Type: uint256
               Source: "spentToday = 0"
              Identifier spentToday
                 Type: uint256
                 Source: "spentToday"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      IfStatement
         Source: "if (spentToday + amount > dailyLimit || spentToday + amount < spentToday)\r\n            return false"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 0
           Source: "spentToday + amount > dailyLimit || spentToday + amount < spentToday"
          BinaryOperation using operator >
             Type: bool
             Source: "spentToday + amount > dailyLimit"
            BinaryOperation using operator +
               Type: uint256
               Source: "spentToday + amount"
              Identifier spentToday
                 Type: uint256
                 Source: "spentToday"
              Identifier amount
                 Type: uint256
                 Source: "amount"
            Identifier dailyLimit
               Type: uint256
               Source: "dailyLimit"
          BinaryOperation using operator <
             Type: bool
             Source: "spentToday + amount < spentToday"
            BinaryOperation using operator +
               Type: uint256
               Source: "spentToday + amount"
              Identifier spentToday
                 Type: uint256
                 Source: "spentToday"
              Identifier amount
                 Type: uint256
                 Source: "amount"
            Identifier spentToday
               Type: uint256
               Source: "spentToday"
        Return
           Gas costs: 0
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "calcMaxWithdraw" - public - const
     Source: "function calcMaxWithdraw()\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        if (now > lastDay + 24 hours)\r\n            return dailyLimit;\r\n        if (dailyLimit < spentToday)\r\n            return 0;\r\n        return dailyLimit - spentToday;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (now > lastDay + 24 hours)\r\n            return dailyLimit;\r\n        if (dailyLimit < spentToday)\r\n            return 0;\r\n        return dailyLimit - spentToday;\r\n    }"
      IfStatement
         Source: "if (now > lastDay + 24 hours)\r\n            return dailyLimit"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "now > lastDay + 24 hours"
          Identifier now
             Type: uint256
             Source: "now"
          BinaryOperation using operator +
             Type: uint256
             Source: "lastDay + 24 hours"
            Identifier lastDay
               Type: uint256
               Source: "lastDay"
            Literal, token: [no token] value: 24
               Type: int_const 86400
               Source: "24 hours"
        Return
           Gas costs: 0
           Source: "return dailyLimit"
          Identifier dailyLimit
             Type: uint256
             Source: "dailyLimit"
      IfStatement
         Source: "if (dailyLimit < spentToday)\r\n            return 0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "dailyLimit < spentToday"
          Identifier dailyLimit
             Type: uint256
             Source: "dailyLimit"
          Identifier spentToday
             Type: uint256
             Source: "spentToday"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      Return
         Gas costs: 0
         Source: "return dailyLimit - spentToday"
        BinaryOperation using operator -
           Type: uint256
           Source: "dailyLimit - spentToday"
          Identifier dailyLimit
             Type: uint256
             Source: "dailyLimit"
          Identifier spentToday
             Type: uint256
             Source: "spentToday"
ContractDefinition "MultiSigWalletWithDailyLimitFactory"
   Source: "contract MultiSigWalletWithDailyLimitFactory is Factory {\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Allows verified creation of multisignature wallet.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    /// @param _dailyLimit Amount in wei, which can be withdrawn without confirmations on a daily basis.\r\n    /// @return Returns wallet address.\r\n    function create(address[] _owners, uint _required, uint _dailyLimit)\r\n        public\r\n        returns (address wallet)\r\n    {\r\n        wallet = new MultiSigWalletWithDailyLimit(_owners, _required, _dailyLimit);\r\n        register(wallet);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Factory"
    UserDefinedTypeName "Factory"
       Source: "Factory"
  FunctionDefinition "create" - public
     Source: "function create(address[] _owners, uint _required, uint _dailyLimit)\r\n        public\r\n        returns (address wallet)\r\n    {\r\n        wallet = new MultiSigWalletWithDailyLimit(_owners, _required, _dailyLimit);\r\n        register(wallet);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _owners, uint _required, uint _dailyLimit)"
      VariableDeclaration "_owners"
         Type: address[] memory
         Source: "address[] _owners"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_required"
         Type: uint256
         Source: "uint _required"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_dailyLimit"
         Type: uint256
         Source: "uint _dailyLimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(address wallet)"
      VariableDeclaration "wallet"
         Type: address
         Source: "address wallet"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        wallet = new MultiSigWalletWithDailyLimit(_owners, _required, _dailyLimit);\r\n        register(wallet);\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "wallet = new MultiSigWalletWithDailyLimit(_owners, _required, _dailyLimit)"
        Assignment using operator =
           Type: address
           Source: "wallet = new MultiSigWalletWithDailyLimit(_owners, _required, _dailyLimit)"
          Identifier wallet
             Type: address
             Source: "wallet"
          FunctionCall
             Type: contract MultiSigWalletWithDailyLimit
             Source: "new MultiSigWalletWithDailyLimit(_owners, _required, _dailyLimit)"
            NewExpression
               Type: function (address[] memory,uint256,uint256) returns (contract MultiSigWalletWithDailyLimit)
               Source: "new MultiSigWalletWithDailyLimit"
              UserDefinedTypeName "MultiSigWalletWithDailyLimit"
                 Source: "MultiSigWalletWithDailyLimit"
            Identifier _owners
               Type: address[] memory
               Source: "_owners"
            Identifier _required
               Type: uint256
               Source: "_required"
            Identifier _dailyLimit
               Type: uint256
               Source: "_dailyLimit"
      ExpressionStatement
         Gas costs: 7
         Source: "register(wallet)"
        FunctionCall
           Type: tuple()
           Source: "register(wallet)"
          Identifier register
             Type: function (address)
             Source: "register"
          Identifier wallet
             Type: address
             Source: "wallet"
