Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xb5c0651560e200d3e82be20799e47d9247947324.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function mul(uint256 a, uint256 b) pure internal  returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) pure internal  returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) pure internal  returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) pure internal  returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "mul"
     Source: "function mul(uint256 a, uint256 b) pure internal  returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div"
     Source: "function div(uint256 a, uint256 b) pure internal  returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub"
     Source: "function sub(uint256 a, uint256 b) pure internal  returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 0
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add"
     Source: "function add(uint256 a, uint256 b) pure internal  returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "Disbursement"
   Source: "contract Disbursement {\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    address public owner;\r\n    address public receiver;\r\n    uint public disbursementPeriod;\r\n    uint public startDate;\r\n    uint public withdrawnTokens;\r\n    Token public token;\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier isOwner() {\r\n        if (msg.sender != owner)\r\n            // Only owner is allowed to proceed\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier isReceiver() {\r\n        if (msg.sender != receiver)\r\n            // Only receiver is allowed to proceed\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier isSetUp() {\r\n        if (address(token) == 0)\r\n            // Contract is not set up\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Constructor function sets contract owner\r\n    /// @param _receiver Receiver of vested tokens\r\n    /// @param _disbursementPeriod Vesting period in seconds\r\n    /// @param _startDate Start date of disbursement period (cliff)\r\n    function Disbursement(address _receiver, uint _disbursementPeriod, uint _startDate)\r\n        public\r\n    {\r\n        if (_receiver == 0 || _disbursementPeriod == 0)\r\n            // Arguments are null\r\n            revert();\r\n        owner = msg.sender;\r\n        receiver = _receiver;\r\n        disbursementPeriod = _disbursementPeriod;\r\n        startDate = _startDate;\r\n        if (startDate == 0)\r\n            startDate = now;\r\n    }\r\n\r\n    /// @dev Setup function sets external contracts' addresses\r\n    /// @param _token Token address\r\n    function setup(Token _token)\r\n        public\r\n        isOwner\r\n    {\r\n        if (address(token) != 0 || address(_token) == 0)\r\n            // Setup was executed already or address is null\r\n            revert();\r\n        token = _token;\r\n    }\r\n\r\n    /// @dev Transfers tokens to a given address\r\n    /// @param _to Address of token receiver\r\n    /// @param _value Number of tokens to transfer\r\n    function withdraw(address _to, uint256 _value)\r\n        public\r\n        isReceiver\r\n        isSetUp\r\n    {\r\n        uint maxTokens = calcMaxWithdraw();\r\n        if (_value > maxTokens)\r\n            revert();\r\n        withdrawnTokens += _value;\r\n        token.transfer(_to, _value);\r\n    }\r\n\r\n    /// @dev Calculates the maximum amount of vested tokens\r\n    /// @return Number of vested tokens to withdraw\r\n    function calcMaxWithdraw()\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        uint maxTokens = (token.balanceOf(this) + withdrawnTokens) * (now - startDate) / disbursementPeriod;\r\n        if (withdrawnTokens >= maxTokens || startDate > now)\r\n            return 0;\r\n        if (maxTokens - withdrawnTokens > token.totalSupply())\r\n            return token.totalSupply();\r\n        return maxTokens - withdrawnTokens;\r\n    }\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: 0
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "receiver"
     Type: address
     Gas costs: 0
     Source: "address public receiver"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "disbursementPeriod"
     Type: uint256
     Gas costs: 0
     Source: "uint public disbursementPeriod"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "startDate"
     Type: uint256
     Gas costs: 0
     Source: "uint public startDate"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "withdrawnTokens"
     Type: uint256
     Gas costs: 0
     Source: "uint public withdrawnTokens"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "token"
     Type: contract Token
     Gas costs: 0
     Source: "Token public token"
    UserDefinedTypeName "Token"
       Source: "Token"
  ModifierDefinition "isOwner"
     Source: "modifier isOwner() {\r\n        if (msg.sender != owner)\r\n            // Only owner is allowed to proceed\r\n            revert();\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        if (msg.sender != owner)\r\n            // Only owner is allowed to proceed\r\n            revert();\r\n        _;\r\n    }"
      IfStatement
         Source: "if (msg.sender != owner)\r\n            // Only owner is allowed to proceed\r\n            revert()"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        ExpressionStatement
           Gas costs: 0
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "isReceiver"
     Source: "modifier isReceiver() {\r\n        if (msg.sender != receiver)\r\n            // Only receiver is allowed to proceed\r\n            revert();\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        if (msg.sender != receiver)\r\n            // Only receiver is allowed to proceed\r\n            revert();\r\n        _;\r\n    }"
      IfStatement
         Source: "if (msg.sender != receiver)\r\n            // Only receiver is allowed to proceed\r\n            revert()"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "msg.sender != receiver"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier receiver
             Type: address
             Source: "receiver"
        ExpressionStatement
           Gas costs: 0
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "isSetUp"
     Source: "modifier isSetUp() {\r\n        if (address(token) == 0)\r\n            // Contract is not set up\r\n            revert();\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        if (address(token) == 0)\r\n            // Contract is not set up\r\n            revert();\r\n        _;\r\n    }"
      IfStatement
         Source: "if (address(token) == 0)\r\n            // Contract is not set up\r\n            revert()"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "address(token) == 0"
          FunctionCall
             Type: address
             Source: "address(token)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier token
               Type: contract Token
               Source: "token"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 0
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "Disbursement" - public
     Source: "function Disbursement(address _receiver, uint _disbursementPeriod, uint _startDate)\r\n        public\r\n    {\r\n        if (_receiver == 0 || _disbursementPeriod == 0)\r\n            // Arguments are null\r\n            revert();\r\n        owner = msg.sender;\r\n        receiver = _receiver;\r\n        disbursementPeriod = _disbursementPeriod;\r\n        startDate = _startDate;\r\n        if (startDate == 0)\r\n            startDate = now;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _receiver, uint _disbursementPeriod, uint _startDate)"
      VariableDeclaration "_receiver"
         Type: address
         Source: "address _receiver"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_disbursementPeriod"
         Type: uint256
         Source: "uint _disbursementPeriod"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_startDate"
         Type: uint256
         Source: "uint _startDate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (_receiver == 0 || _disbursementPeriod == 0)\r\n            // Arguments are null\r\n            revert();\r\n        owner = msg.sender;\r\n        receiver = _receiver;\r\n        disbursementPeriod = _disbursementPeriod;\r\n        startDate = _startDate;\r\n        if (startDate == 0)\r\n            startDate = now;\r\n    }"
      IfStatement
         Source: "if (_receiver == 0 || _disbursementPeriod == 0)\r\n            // Arguments are null\r\n            revert()"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 0
           Source: "_receiver == 0 || _disbursementPeriod == 0"
          BinaryOperation using operator ==
             Type: bool
             Source: "_receiver == 0"
            Identifier _receiver
               Type: address
               Source: "_receiver"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator ==
             Type: bool
             Source: "_disbursementPeriod == 0"
            Identifier _disbursementPeriod
               Type: uint256
               Source: "_disbursementPeriod"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        ExpressionStatement
           Gas costs: 0
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "receiver = _receiver"
        Assignment using operator =
           Type: address
           Source: "receiver = _receiver"
          Identifier receiver
             Type: address
             Source: "receiver"
          Identifier _receiver
             Type: address
             Source: "_receiver"
      ExpressionStatement
         Gas costs: 0
         Source: "disbursementPeriod = _disbursementPeriod"
        Assignment using operator =
           Type: uint256
           Source: "disbursementPeriod = _disbursementPeriod"
          Identifier disbursementPeriod
             Type: uint256
             Source: "disbursementPeriod"
          Identifier _disbursementPeriod
             Type: uint256
             Source: "_disbursementPeriod"
      ExpressionStatement
         Gas costs: 0
         Source: "startDate = _startDate"
        Assignment using operator =
           Type: uint256
           Source: "startDate = _startDate"
          Identifier startDate
             Type: uint256
             Source: "startDate"
          Identifier _startDate
             Type: uint256
             Source: "_startDate"
      IfStatement
         Source: "if (startDate == 0)\r\n            startDate = now"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "startDate == 0"
          Identifier startDate
             Type: uint256
             Source: "startDate"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 0
           Source: "startDate = now"
          Assignment using operator =
             Type: uint256
             Source: "startDate = now"
            Identifier startDate
               Type: uint256
               Source: "startDate"
            Identifier now
               Type: uint256
               Source: "now"
  FunctionDefinition "setup" - public
     Source: "function setup(Token _token)\r\n        public\r\n        isOwner\r\n    {\r\n        if (address(token) != 0 || address(_token) == 0)\r\n            // Setup was executed already or address is null\r\n            revert();\r\n        token = _token;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Token _token)"
      VariableDeclaration "_token"
         Type: contract Token
         Source: "Token _token"
        UserDefinedTypeName "Token"
           Source: "Token"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "isOwner"
       Gas costs: 0
       Source: "isOwner"
      Identifier isOwner
         Type: modifier ()
         Source: "isOwner"
    Block
       Source: "{\r\n        if (address(token) != 0 || address(_token) == 0)\r\n            // Setup was executed already or address is null\r\n            revert();\r\n        token = _token;\r\n    }"
      IfStatement
         Source: "if (address(token) != 0 || address(_token) == 0)\r\n            // Setup was executed already or address is null\r\n            revert()"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 0
           Source: "address(token) != 0 || address(_token) == 0"
          BinaryOperation using operator !=
             Type: bool
             Source: "address(token) != 0"
            FunctionCall
               Type: address
               Source: "address(token)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Identifier token
                 Type: contract Token
                 Source: "token"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator ==
             Type: bool
             Source: "address(_token) == 0"
            FunctionCall
               Type: address
               Source: "address(_token)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Identifier _token
                 Type: contract Token
                 Source: "_token"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        ExpressionStatement
           Gas costs: 0
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 0
         Source: "token = _token"
        Assignment using operator =
           Type: contract Token
           Source: "token = _token"
          Identifier token
             Type: contract Token
             Source: "token"
          Identifier _token
             Type: contract Token
             Source: "_token"
  FunctionDefinition "withdraw" - public
     Source: "function withdraw(address _to, uint256 _value)\r\n        public\r\n        isReceiver\r\n        isSetUp\r\n    {\r\n        uint maxTokens = calcMaxWithdraw();\r\n        if (_value > maxTokens)\r\n            revert();\r\n        withdrawnTokens += _value;\r\n        token.transfer(_to, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "isReceiver"
       Gas costs: 0
       Source: "isReceiver"
      Identifier isReceiver
         Type: modifier ()
         Source: "isReceiver"
    ModifierInvocation "isSetUp"
       Gas costs: 0
       Source: "isSetUp"
      Identifier isSetUp
         Type: modifier ()
         Source: "isSetUp"
    Block
       Source: "{\r\n        uint maxTokens = calcMaxWithdraw();\r\n        if (_value > maxTokens)\r\n            revert();\r\n        withdrawnTokens += _value;\r\n        token.transfer(_to, _value);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint maxTokens = calcMaxWithdraw()"
        VariableDeclaration "maxTokens"
           Type: uint256
           Source: "uint maxTokens"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "calcMaxWithdraw()"
          Identifier calcMaxWithdraw
             Type: function () view returns (uint256)
             Source: "calcMaxWithdraw"
      IfStatement
         Source: "if (_value > maxTokens)\r\n            revert()"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "_value > maxTokens"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier maxTokens
             Type: uint256
             Source: "maxTokens"
        ExpressionStatement
           Gas costs: 0
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 0
         Source: "withdrawnTokens += _value"
        Assignment using operator +=
           Type: uint256
           Source: "withdrawnTokens += _value"
          Identifier withdrawnTokens
             Type: uint256
             Source: "withdrawnTokens"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "token.transfer(_to, _value)"
        FunctionCall
           Type: bool
           Source: "token.transfer(_to, _value)"
          MemberAccess to member transfer
             Type: function (address,uint256) external returns (bool)
             Source: "token.transfer"
            Identifier token
               Type: contract Token
               Source: "token"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "calcMaxWithdraw" - public - const
     Source: "function calcMaxWithdraw()\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        uint maxTokens = (token.balanceOf(this) + withdrawnTokens) * (now - startDate) / disbursementPeriod;\r\n        if (withdrawnTokens >= maxTokens || startDate > now)\r\n            return 0;\r\n        if (maxTokens - withdrawnTokens > token.totalSupply())\r\n            return token.totalSupply();\r\n        return maxTokens - withdrawnTokens;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint maxTokens = (token.balanceOf(this) + withdrawnTokens) * (now - startDate) / disbursementPeriod;\r\n        if (withdrawnTokens >= maxTokens || startDate > now)\r\n            return 0;\r\n        if (maxTokens - withdrawnTokens > token.totalSupply())\r\n            return token.totalSupply();\r\n        return maxTokens - withdrawnTokens;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint maxTokens = (token.balanceOf(this) + withdrawnTokens) * (now - startDate) / disbursementPeriod"
        VariableDeclaration "maxTokens"
           Type: uint256
           Source: "uint maxTokens"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "(token.balanceOf(this) + withdrawnTokens) * (now - startDate) / disbursementPeriod"
          BinaryOperation using operator *
             Type: uint256
             Source: "(token.balanceOf(this) + withdrawnTokens) * (now - startDate)"
            TupleExpression
               Type: uint256
               Source: "(token.balanceOf(this) + withdrawnTokens)"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "token.balanceOf(this) + withdrawnTokens"
                FunctionCall
                   Type: uint256
                   Source: "token.balanceOf(this)"
                  MemberAccess to member balanceOf
                     Type: function (address) view external returns (uint256)
                     Source: "token.balanceOf"
                    Identifier token
                       Type: contract Token
                       Source: "token"
                  Identifier this
                     Type: contract Disbursement
                     Source: "this"
                Identifier withdrawnTokens
                   Type: uint256
                   Source: "withdrawnTokens"
            TupleExpression
               Type: uint256
               Source: "(now - startDate)"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "now - startDate"
                Identifier now
                   Type: uint256
                   Source: "now"
                Identifier startDate
                   Type: uint256
                   Source: "startDate"
          Identifier disbursementPeriod
             Type: uint256
             Source: "disbursementPeriod"
      IfStatement
         Source: "if (withdrawnTokens >= maxTokens || startDate > now)\r\n            return 0"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 0
           Source: "withdrawnTokens >= maxTokens || startDate > now"
          BinaryOperation using operator >=
             Type: bool
             Source: "withdrawnTokens >= maxTokens"
            Identifier withdrawnTokens
               Type: uint256
               Source: "withdrawnTokens"
            Identifier maxTokens
               Type: uint256
               Source: "maxTokens"
          BinaryOperation using operator >
             Type: bool
             Source: "startDate > now"
            Identifier startDate
               Type: uint256
               Source: "startDate"
            Identifier now
               Type: uint256
               Source: "now"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      IfStatement
         Source: "if (maxTokens - withdrawnTokens > token.totalSupply())\r\n            return token.totalSupply()"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "maxTokens - withdrawnTokens > token.totalSupply()"
          BinaryOperation using operator -
             Type: uint256
             Source: "maxTokens - withdrawnTokens"
            Identifier maxTokens
               Type: uint256
               Source: "maxTokens"
            Identifier withdrawnTokens
               Type: uint256
               Source: "withdrawnTokens"
          FunctionCall
             Type: uint256
             Source: "token.totalSupply()"
            MemberAccess to member totalSupply
               Type: function () view external returns (uint256)
               Source: "token.totalSupply"
              Identifier token
                 Type: contract Token
                 Source: "token"
        Return
           Gas costs: 0
           Source: "return token.totalSupply()"
          FunctionCall
             Type: uint256
             Source: "token.totalSupply()"
            MemberAccess to member totalSupply
               Type: function () view external returns (uint256)
               Source: "token.totalSupply"
              Identifier token
                 Type: contract Token
                 Source: "token"
      Return
         Gas costs: 0
         Source: "return maxTokens - withdrawnTokens"
        BinaryOperation using operator -
           Type: uint256
           Source: "maxTokens - withdrawnTokens"
          Identifier maxTokens
             Type: uint256
             Source: "maxTokens"
          Identifier withdrawnTokens
             Type: uint256
             Source: "withdrawnTokens"
ContractDefinition "Token"
   Gas costs: 0
   Source: "contract Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n    address public sale;\r\n    bool public transfersAllowed;\r\n    \r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant public returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "sale"
     Type: address
     Source: "address public sale"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "transfersAllowed"
     Type: bool
     Source: "bool public transfersAllowed"
    ElementaryTypeName bool
       Source: "bool"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant public returns (uint256 balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant public returns (uint256 remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        validTransfer\r\n       \treturns (bool success) \r\n    {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n    \trequire(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        validTransfer\r\n      \treturns (bool success)\r\n      {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n\t    require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    modifier validTransfer()\r\n    {\r\n        require(msg.sender == sale || transfersAllowed);\r\n        _;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Token"
    UserDefinedTypeName "Token"
       Source: "Token"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value)\r\n        public\r\n        validTransfer\r\n       \treturns (bool success) \r\n    {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n    \trequire(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "validTransfer"
       Gas costs: 0
       Source: "validTransfer"
      Identifier validTransfer
         Type: modifier ()
         Source: "validTransfer"
    Block
       Source: "{\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n    \trequire(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balances[msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        validTransfer\r\n      \treturns (bool success)\r\n      {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n\t    require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "validTransfer"
       Gas costs: 0
       Source: "validTransfer"
      Identifier validTransfer
         Type: modifier ()
         Source: "validTransfer"
    Block
       Source: "{\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n\t    require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "balances[_from] >= _value && allowed[_from][msg.sender] >= _value"
            BinaryOperation using operator >=
               Type: bool
               Source: "balances[_from] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            BinaryOperation using operator >=
               Type: bool
               Source: "allowed[_from][msg.sender] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowed[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balances[_owner];\r\n    }"
      Return
         Gas costs: 0
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require(balances[msg.sender] >= _value);\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balances[msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 0
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balances"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  ModifierDefinition "validTransfer"
     Source: "modifier validTransfer()\r\n    {\r\n        require(msg.sender == sale || transfersAllowed);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(msg.sender == sale || transfersAllowed);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.sender == sale || transfersAllowed)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == sale || transfersAllowed)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "msg.sender == sale || transfersAllowed"
            BinaryOperation using operator ==
               Type: bool
               Source: "msg.sender == sale"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier sale
                 Type: address
                 Source: "sale"
            Identifier transfersAllowed
               Type: bool
               Source: "transfersAllowed"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
ContractDefinition "HumanStandardToken"
   Source: "contract HumanStandardToken is StandardToken {\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n    function HumanStandardToken(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        address _sale)\r\n        public\r\n    {\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n        sale = _sale;\r\n        transfersAllowed = false;\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n        return true;\r\n    }\r\n\r\n    function reversePurchase(address _tokenHolder)\r\n        public\r\n        onlySale\r\n    {\r\n        require(!transfersAllowed);\r\n        uint value = balances[_tokenHolder];\r\n        balances[_tokenHolder] -= value;\r\n        balances[sale] += value;\r\n        Transfer(_tokenHolder, sale, value);\r\n    }\r\n\r\n    function removeTransferLock()\r\n        public\r\n        onlySale\r\n    {\r\n        transfersAllowed = true;\r\n    }\r\n\r\n    modifier onlySale()\r\n    {\r\n        require(msg.sender == sale);\r\n        _;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: 0
     Source: "string public name"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: 0
     Source: "uint8 public decimals"
    ElementaryTypeName uint8
       Source: "uint8"
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: 0
     Source: "string public symbol"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "version"
     Type: string storage ref
     Gas costs: 0
     Source: "string public version = 'H0.1'"
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: H0.1
       Type: literal_string "H0.1"
       Source: "'H0.1'"
  FunctionDefinition "HumanStandardToken" - public
     Source: "function HumanStandardToken(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        address _sale)\r\n        public\r\n    {\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n        sale = _sale;\r\n        transfersAllowed = false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        address _sale)"
      VariableDeclaration "_initialAmount"
         Type: uint256
         Source: "uint256 _initialAmount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_tokenName"
         Type: string memory
         Source: "string _tokenName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_decimalUnits"
         Type: uint8
         Source: "uint8 _decimalUnits"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "_tokenSymbol"
         Type: string memory
         Source: "string _tokenSymbol"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_sale"
         Type: address
         Source: "address _sale"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n        sale = _sale;\r\n        transfersAllowed = false;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] = _initialAmount"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = _initialAmount"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _initialAmount
             Type: uint256
             Source: "_initialAmount"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = _initialAmount"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = _initialAmount"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _initialAmount
             Type: uint256
             Source: "_initialAmount"
      ExpressionStatement
         Gas costs: 0
         Source: "name = _tokenName"
        Assignment using operator =
           Type: string storage ref
           Source: "name = _tokenName"
          Identifier name
             Type: string storage ref
             Source: "name"
          Identifier _tokenName
             Type: string memory
             Source: "_tokenName"
      ExpressionStatement
         Gas costs: 0
         Source: "decimals = _decimalUnits"
        Assignment using operator =
           Type: uint8
           Source: "decimals = _decimalUnits"
          Identifier decimals
             Type: uint8
             Source: "decimals"
          Identifier _decimalUnits
             Type: uint8
             Source: "_decimalUnits"
      ExpressionStatement
         Gas costs: 0
         Source: "symbol = _tokenSymbol"
        Assignment using operator =
           Type: string storage ref
           Source: "symbol = _tokenSymbol"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
          Identifier _tokenSymbol
             Type: string memory
             Source: "_tokenSymbol"
      ExpressionStatement
         Gas costs: 0
         Source: "sale = _sale"
        Assignment using operator =
           Type: address
           Source: "sale = _sale"
          Identifier sale
             Type: address
             Source: "sale"
          Identifier _sale
             Type: address
             Source: "_sale"
      ExpressionStatement
         Gas costs: 0
         Source: "transfersAllowed = false"
        Assignment using operator =
           Type: bool
           Source: "transfersAllowed = false"
          Identifier transfersAllowed
             Type: bool
             Source: "transfersAllowed"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "approveAndCall" - public
     Source: "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value, bytes _extraData)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData))"
        FunctionCall
           Type: tuple()
           Source: "require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)"
            MemberAccess to member call
               Type: function () payable returns (bool)
               Source: "_spender.call"
              Identifier _spender
                 Type: address
                 Source: "_spender"
            FunctionCall
               Type: bytes4
               Source: "bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\")))"
              ElementaryTypeNameExpression bytes4
                 Type: type(bytes4)
                 Source: "bytes4"
              FunctionCall
                 Type: bytes32
                 Source: "bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))"
                ElementaryTypeNameExpression bytes32
                   Type: type(bytes32)
                   Source: "bytes32"
                FunctionCall
                   Type: bytes32
                   Source: "keccak256(\"receiveApproval(address,uint256,address,bytes)\")"
                  Identifier keccak256
                     Type: function () pure returns (bytes32)
                     Source: "keccak256"
                  Literal, token: [no token] value: receiveApproval(address,uint256,address,bytes)
                     Type: literal_string "receiveApproval(address,uint256,address,bytes)"
                     Source: "\"receiveApproval(address,uint256,address,bytes)\""
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
            Identifier this
               Type: contract HumanStandardToken
               Source: "this"
            Identifier _extraData
               Type: bytes memory
               Source: "_extraData"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "reversePurchase" - public
     Source: "function reversePurchase(address _tokenHolder)\r\n        public\r\n        onlySale\r\n    {\r\n        require(!transfersAllowed);\r\n        uint value = balances[_tokenHolder];\r\n        balances[_tokenHolder] -= value;\r\n        balances[sale] += value;\r\n        Transfer(_tokenHolder, sale, value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _tokenHolder)"
      VariableDeclaration "_tokenHolder"
         Type: address
         Source: "address _tokenHolder"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlySale"
       Gas costs: 0
       Source: "onlySale"
      Identifier onlySale
         Type: modifier ()
         Source: "onlySale"
    Block
       Source: "{\r\n        require(!transfersAllowed);\r\n        uint value = balances[_tokenHolder];\r\n        balances[_tokenHolder] -= value;\r\n        balances[sale] += value;\r\n        Transfer(_tokenHolder, sale, value);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!transfersAllowed)"
        FunctionCall
           Type: tuple()
           Source: "require(!transfersAllowed)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!transfersAllowed"
            Identifier transfersAllowed
               Type: bool
               Source: "transfersAllowed"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint value = balances[_tokenHolder]"
        VariableDeclaration "value"
           Type: uint256
           Source: "uint value"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "balances[_tokenHolder]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _tokenHolder
             Type: address
             Source: "_tokenHolder"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_tokenHolder] -= value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[_tokenHolder] -= value"
          IndexAccess
             Type: uint256
             Source: "balances[_tokenHolder]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _tokenHolder
               Type: address
               Source: "_tokenHolder"
          Identifier value
             Type: uint256
             Source: "value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[sale] += value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[sale] += value"
          IndexAccess
             Type: uint256
             Source: "balances[sale]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier sale
               Type: address
               Source: "sale"
          Identifier value
             Type: uint256
             Source: "value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(_tokenHolder, sale, value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_tokenHolder, sale, value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _tokenHolder
             Type: address
             Source: "_tokenHolder"
          Identifier sale
             Type: address
             Source: "sale"
          Identifier value
             Type: uint256
             Source: "value"
  FunctionDefinition "removeTransferLock" - public
     Source: "function removeTransferLock()\r\n        public\r\n        onlySale\r\n    {\r\n        transfersAllowed = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlySale"
       Gas costs: 0
       Source: "onlySale"
      Identifier onlySale
         Type: modifier ()
         Source: "onlySale"
    Block
       Source: "{\r\n        transfersAllowed = true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "transfersAllowed = true"
        Assignment using operator =
           Type: bool
           Source: "transfersAllowed = true"
          Identifier transfersAllowed
             Type: bool
             Source: "transfersAllowed"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  ModifierDefinition "onlySale"
     Source: "modifier onlySale()\r\n    {\r\n        require(msg.sender == sale);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(msg.sender == sale);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.sender == sale)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == sale)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == sale"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier sale
               Type: address
               Source: "sale"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
ContractDefinition "Sale"
   Source: "contract Sale {\r\n\r\n    // EVENTS\r\n\r\n    event TransferredTimelockedTokens(address beneficiary, address disbursement,uint beneficiaryTokens);\r\n    event PurchasedTokens(address indexed purchaser, uint amount);\r\n    event LockedUnsoldTokens(uint numTokensLocked, address disburser);\r\n\r\n    // STORAGE\r\n\r\n    uint public constant TOTAL_SUPPLY = 1000000000000000000;\r\n    uint public constant MAX_PRIVATE = 750000000000000000;\r\n    uint8 public constant DECIMALS = 9;\r\n    string public constant NAME = \"Leverj\";\r\n    string public constant SYMBOL = \"LEV\";\r\n\r\n    address public owner;\r\n    address public wallet;\r\n    HumanStandardToken public token;\r\n    uint public freezeBlock;\r\n    uint public startBlock;\r\n    uint public endBlock;\r\n    uint public presale_price_in_wei = 216685; //wei per 10**-9 of LEV!\r\n    uint public price_in_wei = 333333; //wei per 10**-9 of a LEV!\r\n\r\n    //address[] public filters;\r\n\r\n    uint public privateAllocated = 0;\r\n    bool public setupCompleteFlag = false;\r\n    bool public emergencyFlag = false;\r\n\r\n    address[] public disbursements;\r\n    mapping(address => uint) public whitelistRegistrants;\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    function Sale(\r\n        address _owner,\r\n        uint _freezeBlock,\r\n        uint _startBlock,\r\n        uint _endBlock)\r\n        public \r\n        checkBlockNumberInputs(_freezeBlock, _startBlock, _endBlock)\r\n    {\r\n        owner = _owner;\r\n        token = new HumanStandardToken(TOTAL_SUPPLY, NAME, DECIMALS, SYMBOL, address(this));\r\n        freezeBlock = _freezeBlock;\r\n        startBlock = _startBlock;\r\n        endBlock = _endBlock;\r\n        assert(token.transfer(this, token.totalSupply()));\r\n        assert(token.balanceOf(this) == token.totalSupply());\r\n        assert(token.balanceOf(this) == TOTAL_SUPPLY);\r\n    }\r\n\r\n    function purchaseTokens()\r\n        public\r\n        payable\r\n        setupComplete\r\n        notInEmergency\r\n        saleInProgress\r\n    {\r\n        require(whitelistRegistrants[msg.sender] > 0 );\r\n        uint tempWhitelistAmount = whitelistRegistrants[msg.sender];\r\n\r\n        /* Calculate whether any of the msg.value needs to be returned to\r\n           the sender. The purchaseAmount is the actual number of tokens which\r\n           will be purchased. */\r\n        uint purchaseAmount = msg.value / price_in_wei; \r\n        uint excessAmount = msg.value % price_in_wei;\r\n\r\n        if(purchaseAmount > whitelistRegistrants[msg.sender]){\r\n            uint extra = purchaseAmount - whitelistRegistrants[msg.sender];\r\n            purchaseAmount = whitelistRegistrants[msg.sender];\r\n            excessAmount += extra*price_in_wei;\r\n        }\r\n\r\n        whitelistRegistrants[msg.sender] -= purchaseAmount;\r\n        assert(whitelistRegistrants[msg.sender] < tempWhitelistAmount);\r\n\r\n        // Cannot purchase more tokens than this contract has available to sell\r\n        require(purchaseAmount <= token.balanceOf(this));\r\n\r\n        // Return any excess msg.value\r\n        if (excessAmount > 0) {\r\n            msg.sender.transfer(excessAmount);\r\n        }\r\n\r\n        // Forward received ether minus any excessAmount to the wallet\r\n        wallet.transfer(this.balance);\r\n\r\n        // Transfer the sum of tokens tokenPurchase to the msg.sender\r\n        assert(token.transfer(msg.sender, purchaseAmount));\r\n        PurchasedTokens(msg.sender, purchaseAmount);\r\n    }\r\n\r\n    function lockUnsoldTokens(address _unsoldTokensWallet)\r\n        public\r\n        saleEnded\r\n        setupComplete\r\n        onlyOwner\r\n    {\r\n        Disbursement disbursement = new Disbursement(\r\n            _unsoldTokensWallet,\r\n            1*365*24*60*60,\r\n            block.timestamp\r\n        );\r\n\r\n        disbursement.setup(token);\r\n        uint amountToLock = token.balanceOf(this);\r\n        disbursements.push(disbursement);\r\n        token.transfer(disbursement, amountToLock);\r\n        LockedUnsoldTokens(amountToLock, disbursement);\r\n    }\r\n\r\n    // OWNER-ONLY FUNCTIONS\r\n\r\n    function distributeTimelockedTokens(\r\n        address[] _beneficiaries,\r\n        uint[] _beneficiariesTokens,\r\n        uint[] _timelockStarts,\r\n        uint[] _periods\r\n    ) \r\n        public\r\n        onlyOwner\r\n        saleNotEnded\r\n    { \r\n        assert(!setupCompleteFlag);\r\n        assert(_beneficiariesTokens.length < 11);\r\n        assert(_beneficiaries.length == _beneficiariesTokens.length);\r\n        assert(_beneficiariesTokens.length == _timelockStarts.length);\r\n        assert(_timelockStarts.length == _periods.length);\r\n\r\n        for(uint i = 0; i < _beneficiaries.length; i++) {\r\n            require(privateAllocated + _beneficiariesTokens[i] <= MAX_PRIVATE);\r\n            privateAllocated += _beneficiariesTokens[i];\r\n            address beneficiary = _beneficiaries[i];\r\n            uint beneficiaryTokens = _beneficiariesTokens[i];\r\n\r\n            Disbursement disbursement = new Disbursement(\r\n                beneficiary,\r\n                _periods[i],\r\n                _timelockStarts[i]\r\n            );\r\n\r\n            disbursement.setup(token);\r\n            token.transfer(disbursement, beneficiaryTokens);\r\n            disbursements.push(disbursement);\r\n            TransferredTimelockedTokens(beneficiary, disbursement, beneficiaryTokens);\r\n        }\r\n\r\n        assert(token.balanceOf(this) >= (TOTAL_SUPPLY - MAX_PRIVATE));\r\n    }\r\n\r\n    function distributePresaleTokens(address[] _buyers, uint[] _amounts)\r\n        public\r\n        onlyOwner\r\n        saleNotEnded\r\n    {\r\n        assert(!setupCompleteFlag);\r\n        require(_buyers.length < 11);\r\n        require(_buyers.length == _amounts.length);\r\n\r\n        for(uint i=0; i < _buyers.length; i++){\r\n            require(privateAllocated + _amounts[i] <= MAX_PRIVATE);\r\n            assert(token.transfer(_buyers[i], _amounts[i]));\r\n            privateAllocated += _amounts[i];\r\n            PurchasedTokens(_buyers[i], _amounts[i]);\r\n        }\r\n\r\n        assert(token.balanceOf(this) >= (TOTAL_SUPPLY - MAX_PRIVATE));\r\n    }\r\n\r\n    function removeTransferLock()\r\n        public\r\n        onlyOwner\r\n    {\r\n        token.removeTransferLock();\r\n    }\r\n\r\n    function reversePurchase(address _tokenHolder)\r\n        payable\r\n        public\r\n        onlyOwner\r\n    {\r\n        uint refund = token.balanceOf(_tokenHolder)*price_in_wei;\r\n        require(msg.value >= refund);\r\n        uint excessAmount = msg.value - refund;\r\n\r\n        if (excessAmount > 0) {\r\n            msg.sender.transfer(excessAmount);\r\n        }\r\n\r\n        _tokenHolder.transfer(refund);\r\n        token.reversePurchase(_tokenHolder);\r\n    }\r\n\r\n    function setSetupComplete()\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(wallet!=0);\r\n        require(privateAllocated!=0);  \r\n        setupCompleteFlag = true;\r\n    }\r\n\r\n    function configureWallet(address _wallet)\r\n        public\r\n        onlyOwner\r\n    {\r\n        wallet = _wallet;\r\n    }\r\n\r\n    function changeOwner(address _newOwner)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(_newOwner != 0);\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function changePrice(uint _newPrice)\r\n        public\r\n        onlyOwner\r\n        notFrozen\r\n        validPrice(_newPrice)\r\n    {\r\n        price_in_wei = _newPrice;\r\n    }\r\n\r\n    function changeStartBlock(uint _newBlock)\r\n        public\r\n        onlyOwner\r\n        notFrozen\r\n    {\r\n        require(block.number <= _newBlock && _newBlock < startBlock);\r\n        freezeBlock = _newBlock - (startBlock - freezeBlock);\r\n        startBlock = _newBlock;\r\n    }\r\n\r\n    function emergencyToggle()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emergencyFlag = !emergencyFlag;\r\n    }\r\n    \r\n    function addWhitelist(address[] _purchaser, uint[] _amount)\r\n        public\r\n        onlyOwner\r\n        saleNotEnded\r\n    {\r\n        assert(_purchaser.length < 11 );\r\n        assert(_purchaser.length == _amount.length);\r\n        for(uint i = 0; i < _purchaser.length; i++) {\r\n            whitelistRegistrants[_purchaser[i]] = _amount[i];\r\n        }\r\n    }\r\n\r\n    // MODIFIERS\r\n\r\n    modifier saleEnded {\r\n        require(block.number >= endBlock);\r\n        _;\r\n    }\r\n\r\n    modifier saleNotEnded {\r\n        require(block.number < endBlock);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier notFrozen {\r\n        require(block.number < freezeBlock);\r\n        _;\r\n    }\r\n\r\n    modifier saleInProgress {\r\n        require(block.number >= startBlock && block.number < endBlock);\r\n        _;\r\n    }\r\n\r\n    modifier setupComplete {\r\n        assert(setupCompleteFlag);\r\n        _;\r\n    }\r\n\r\n    modifier notInEmergency {\r\n        assert(emergencyFlag == false);\r\n        _;\r\n    }\r\n\r\n    modifier checkBlockNumberInputs(uint _freeze, uint _start, uint _end) {\r\n        require(_freeze >= block.number\r\n        && _start >= _freeze\r\n        && _end >= _start);\r\n        _;\r\n    }\r\n\r\n    modifier validPrice(uint _price){\r\n        require(_price > 0);\r\n        _;\r\n    }\r\n\r\n}"
  EventDefinition "TransferredTimelockedTokens"
     Gas costs: 0
     Source: "event TransferredTimelockedTokens(address beneficiary, address disbursement,uint beneficiaryTokens);"
    ParameterList
       Source: "(address beneficiary, address disbursement,uint beneficiaryTokens)"
      VariableDeclaration "beneficiary"
         Type: address
         Source: "address beneficiary"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "disbursement"
         Type: address
         Source: "address disbursement"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "beneficiaryTokens"
         Type: uint256
         Source: "uint beneficiaryTokens"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "PurchasedTokens"
     Gas costs: 0
     Source: "event PurchasedTokens(address indexed purchaser, uint amount);"
    ParameterList
       Source: "(address indexed purchaser, uint amount)"
      VariableDeclaration "purchaser"
         Type: address
         Source: "address indexed purchaser"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LockedUnsoldTokens"
     Gas costs: 0
     Source: "event LockedUnsoldTokens(uint numTokensLocked, address disburser);"
    ParameterList
       Source: "(uint numTokensLocked, address disburser)"
      VariableDeclaration "numTokensLocked"
         Type: uint256
         Source: "uint numTokensLocked"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "disburser"
         Type: address
         Source: "address disburser"
        ElementaryTypeName address
           Source: "address"
  VariableDeclaration "TOTAL_SUPPLY"
     Type: uint256
     Gas costs: [???]
     Source: "uint public constant TOTAL_SUPPLY = 1000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1000000000000000000
       Type: int_const 1000000000000000000
       Source: "1000000000000000000"
  VariableDeclaration "MAX_PRIVATE"
     Type: uint256
     Gas costs: [???]
     Source: "uint public constant MAX_PRIVATE = 750000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 750000000000000000
       Type: int_const 750000000000000000
       Source: "750000000000000000"
  VariableDeclaration "DECIMALS"
     Type: uint8
     Gas costs: [???]
     Source: "uint8 public constant DECIMALS = 9"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 9
       Type: int_const 9
       Source: "9"
  VariableDeclaration "NAME"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant NAME = \"Leverj\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Leverj
       Type: literal_string "Leverj"
       Source: "\"Leverj\""
  VariableDeclaration "SYMBOL"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant SYMBOL = \"LEV\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: LEV
       Type: literal_string "LEV"
       Source: "\"LEV\""
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "wallet"
     Type: address
     Gas costs: [???]
     Source: "address public wallet"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "token"
     Type: contract HumanStandardToken
     Gas costs: [???]
     Source: "HumanStandardToken public token"
    UserDefinedTypeName "HumanStandardToken"
       Source: "HumanStandardToken"
  VariableDeclaration "freezeBlock"
     Type: uint256
     Gas costs: [???]
     Source: "uint public freezeBlock"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "startBlock"
     Type: uint256
     Gas costs: [???]
     Source: "uint public startBlock"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "endBlock"
     Type: uint256
     Gas costs: [???]
     Source: "uint public endBlock"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "presale_price_in_wei"
     Type: uint256
     Gas costs: [???]
     Source: "uint public presale_price_in_wei = 216685"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 216685
       Type: int_const 216685
       Source: "216685"
  VariableDeclaration "price_in_wei"
     Type: uint256
     Gas costs: [???]
     Source: "uint public price_in_wei = 333333"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 333333
       Type: int_const 333333
       Source: "333333"
  VariableDeclaration "privateAllocated"
     Type: uint256
     Gas costs: [???]
     Source: "uint public privateAllocated = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "setupCompleteFlag"
     Type: bool
     Gas costs: [???]
     Source: "bool public setupCompleteFlag = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "emergencyFlag"
     Type: bool
     Gas costs: [???]
     Source: "bool public emergencyFlag = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "disbursements"
     Type: address[] storage ref
     Gas costs: [???]
     Source: "address[] public disbursements"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "whitelistRegistrants"
     Type: mapping(address => uint256)
     Gas costs: [???]
     Source: "mapping(address => uint) public whitelistRegistrants"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  FunctionDefinition "Sale" - public
     Source: "function Sale(\r\n        address _owner,\r\n        uint _freezeBlock,\r\n        uint _startBlock,\r\n        uint _endBlock)\r\n        public \r\n        checkBlockNumberInputs(_freezeBlock, _startBlock, _endBlock)\r\n    {\r\n        owner = _owner;\r\n        token = new HumanStandardToken(TOTAL_SUPPLY, NAME, DECIMALS, SYMBOL, address(this));\r\n        freezeBlock = _freezeBlock;\r\n        startBlock = _startBlock;\r\n        endBlock = _endBlock;\r\n        assert(token.transfer(this, token.totalSupply()));\r\n        assert(token.balanceOf(this) == token.totalSupply());\r\n        assert(token.balanceOf(this) == TOTAL_SUPPLY);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address _owner,\r\n        uint _freezeBlock,\r\n        uint _startBlock,\r\n        uint _endBlock)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_freezeBlock"
         Type: uint256
         Source: "uint _freezeBlock"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_startBlock"
         Type: uint256
         Source: "uint _startBlock"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_endBlock"
         Type: uint256
         Source: "uint _endBlock"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "checkBlockNumberInputs"
       Gas costs: 0
       Source: "checkBlockNumberInputs(_freezeBlock, _startBlock, _endBlock)"
      Identifier checkBlockNumberInputs
         Type: modifier (uint256,uint256,uint256)
         Source: "checkBlockNumberInputs"
      Identifier _freezeBlock
         Type: uint256
         Source: "_freezeBlock"
      Identifier _startBlock
         Type: uint256
         Source: "_startBlock"
      Identifier _endBlock
         Type: uint256
         Source: "_endBlock"
    Block
       Source: "{\r\n        owner = _owner;\r\n        token = new HumanStandardToken(TOTAL_SUPPLY, NAME, DECIMALS, SYMBOL, address(this));\r\n        freezeBlock = _freezeBlock;\r\n        startBlock = _startBlock;\r\n        endBlock = _endBlock;\r\n        assert(token.transfer(this, token.totalSupply()));\r\n        assert(token.balanceOf(this) == token.totalSupply());\r\n        assert(token.balanceOf(this) == TOTAL_SUPPLY);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = _owner"
        Assignment using operator =
           Type: address
           Source: "owner = _owner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier _owner
             Type: address
             Source: "_owner"
      ExpressionStatement
         Gas costs: 0
         Source: "token = new HumanStandardToken(TOTAL_SUPPLY, NAME, DECIMALS, SYMBOL, address(this))"
        Assignment using operator =
           Type: contract HumanStandardToken
           Source: "token = new HumanStandardToken(TOTAL_SUPPLY, NAME, DECIMALS, SYMBOL, address(this))"
          Identifier token
             Type: contract HumanStandardToken
             Source: "token"
          FunctionCall
             Type: contract HumanStandardToken
             Source: "new HumanStandardToken(TOTAL_SUPPLY, NAME, DECIMALS, SYMBOL, address(this))"
            NewExpression
               Type: function (uint256,string memory,uint8,string memory,address) returns (contract HumanStandardToken)
               Source: "new HumanStandardToken"
              UserDefinedTypeName "HumanStandardToken"
                 Source: "HumanStandardToken"
            Identifier TOTAL_SUPPLY
               Type: uint256
               Source: "TOTAL_SUPPLY"
            Identifier NAME
               Type: string memory
               Source: "NAME"
            Identifier DECIMALS
               Type: uint8
               Source: "DECIMALS"
            Identifier SYMBOL
               Type: string memory
               Source: "SYMBOL"
            FunctionCall
               Type: address
               Source: "address(this)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Identifier this
                 Type: contract Sale
                 Source: "this"
      ExpressionStatement
         Gas costs: 0
         Source: "freezeBlock = _freezeBlock"
        Assignment using operator =
           Type: uint256
           Source: "freezeBlock = _freezeBlock"
          Identifier freezeBlock
             Type: uint256
             Source: "freezeBlock"
          Identifier _freezeBlock
             Type: uint256
             Source: "_freezeBlock"
      ExpressionStatement
         Gas costs: 0
         Source: "startBlock = _startBlock"
        Assignment using operator =
           Type: uint256
           Source: "startBlock = _startBlock"
          Identifier startBlock
             Type: uint256
             Source: "startBlock"
          Identifier _startBlock
             Type: uint256
             Source: "_startBlock"
      ExpressionStatement
         Gas costs: 0
         Source: "endBlock = _endBlock"
        Assignment using operator =
           Type: uint256
           Source: "endBlock = _endBlock"
          Identifier endBlock
             Type: uint256
             Source: "endBlock"
          Identifier _endBlock
             Type: uint256
             Source: "_endBlock"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(token.transfer(this, token.totalSupply()))"
        FunctionCall
           Type: tuple()
           Source: "assert(token.transfer(this, token.totalSupply()))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          FunctionCall
             Type: bool
             Source: "token.transfer(this, token.totalSupply())"
            MemberAccess to member transfer
               Type: function (address,uint256) external returns (bool)
               Source: "token.transfer"
              Identifier token
                 Type: contract HumanStandardToken
                 Source: "token"
            Identifier this
               Type: contract Sale
               Source: "this"
            FunctionCall
               Type: uint256
               Source: "token.totalSupply()"
              MemberAccess to member totalSupply
                 Type: function () view external returns (uint256)
                 Source: "token.totalSupply"
                Identifier token
                   Type: contract HumanStandardToken
                   Source: "token"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(token.balanceOf(this) == token.totalSupply())"
        FunctionCall
           Type: tuple()
           Source: "assert(token.balanceOf(this) == token.totalSupply())"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "token.balanceOf(this) == token.totalSupply()"
            FunctionCall
               Type: uint256
               Source: "token.balanceOf(this)"
              MemberAccess to member balanceOf
                 Type: function (address) view external returns (uint256)
                 Source: "token.balanceOf"
                Identifier token
                   Type: contract HumanStandardToken
                   Source: "token"
              Identifier this
                 Type: contract Sale
                 Source: "this"
            FunctionCall
               Type: uint256
               Source: "token.totalSupply()"
              MemberAccess to member totalSupply
                 Type: function () view external returns (uint256)
                 Source: "token.totalSupply"
                Identifier token
                   Type: contract HumanStandardToken
                   Source: "token"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(token.balanceOf(this) == TOTAL_SUPPLY)"
        FunctionCall
           Type: tuple()
           Source: "assert(token.balanceOf(this) == TOTAL_SUPPLY)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "token.balanceOf(this) == TOTAL_SUPPLY"
            FunctionCall
               Type: uint256
               Source: "token.balanceOf(this)"
              MemberAccess to member balanceOf
                 Type: function (address) view external returns (uint256)
                 Source: "token.balanceOf"
                Identifier token
                   Type: contract HumanStandardToken
                   Source: "token"
              Identifier this
                 Type: contract Sale
                 Source: "this"
            Identifier TOTAL_SUPPLY
               Type: uint256
               Source: "TOTAL_SUPPLY"
  FunctionDefinition "purchaseTokens" - public
     Source: "function purchaseTokens()\r\n        public\r\n        payable\r\n        setupComplete\r\n        notInEmergency\r\n        saleInProgress\r\n    {\r\n        require(whitelistRegistrants[msg.sender] > 0 );\r\n        uint tempWhitelistAmount = whitelistRegistrants[msg.sender];\r\n\r\n        /* Calculate whether any of the msg.value needs to be returned to\r\n           the sender. The purchaseAmount is the actual number of tokens which\r\n           will be purchased. */\r\n        uint purchaseAmount = msg.value / price_in_wei; \r\n        uint excessAmount = msg.value % price_in_wei;\r\n\r\n        if(purchaseAmount > whitelistRegistrants[msg.sender]){\r\n            uint extra = purchaseAmount - whitelistRegistrants[msg.sender];\r\n            purchaseAmount = whitelistRegistrants[msg.sender];\r\n            excessAmount += extra*price_in_wei;\r\n        }\r\n\r\n        whitelistRegistrants[msg.sender] -= purchaseAmount;\r\n        assert(whitelistRegistrants[msg.sender] < tempWhitelistAmount);\r\n\r\n        // Cannot purchase more tokens than this contract has available to sell\r\n        require(purchaseAmount <= token.balanceOf(this));\r\n\r\n        // Return any excess msg.value\r\n        if (excessAmount > 0) {\r\n            msg.sender.transfer(excessAmount);\r\n        }\r\n\r\n        // Forward received ether minus any excessAmount to the wallet\r\n        wallet.transfer(this.balance);\r\n\r\n        // Transfer the sum of tokens tokenPurchase to the msg.sender\r\n        assert(token.transfer(msg.sender, purchaseAmount));\r\n        PurchasedTokens(msg.sender, purchaseAmount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "setupComplete"
       Gas costs: 0
       Source: "setupComplete"
      Identifier setupComplete
         Type: modifier ()
         Source: "setupComplete"
    ModifierInvocation "notInEmergency"
       Gas costs: 0
       Source: "notInEmergency"
      Identifier notInEmergency
         Type: modifier ()
         Source: "notInEmergency"
    ModifierInvocation "saleInProgress"
       Gas costs: 0
       Source: "saleInProgress"
      Identifier saleInProgress
         Type: modifier ()
         Source: "saleInProgress"
    Block
       Source: "{\r\n        require(whitelistRegistrants[msg.sender] > 0 );\r\n        uint tempWhitelistAmount = whitelistRegistrants[msg.sender];\r\n\r\n        /* Calculate whether any of the msg.value needs to be returned to\r\n           the sender. The purchaseAmount is the actual number of tokens which\r\n           will be purchased. */\r\n        uint purchaseAmount = msg.value / price_in_wei; \r\n        uint excessAmount = msg.value % price_in_wei;\r\n\r\n        if(purchaseAmount > whitelistRegistrants[msg.sender]){\r\n            uint extra = purchaseAmount - whitelistRegistrants[msg.sender];\r\n            purchaseAmount = whitelistRegistrants[msg.sender];\r\n            excessAmount += extra*price_in_wei;\r\n        }\r\n\r\n        whitelistRegistrants[msg.sender] -= purchaseAmount;\r\n        assert(whitelistRegistrants[msg.sender] < tempWhitelistAmount);\r\n\r\n        // Cannot purchase more tokens than this contract has available to sell\r\n        require(purchaseAmount <= token.balanceOf(this));\r\n\r\n        // Return any excess msg.value\r\n        if (excessAmount > 0) {\r\n            msg.sender.transfer(excessAmount);\r\n        }\r\n\r\n        // Forward received ether minus any excessAmount to the wallet\r\n        wallet.transfer(this.balance);\r\n\r\n        // Transfer the sum of tokens tokenPurchase to the msg.sender\r\n        assert(token.transfer(msg.sender, purchaseAmount));\r\n        PurchasedTokens(msg.sender, purchaseAmount);\r\n    }"
      ExpressionStatement
         Gas costs: 330
         Source: "require(whitelistRegistrants[msg.sender] > 0 )"
        FunctionCall
           Type: tuple()
           Source: "require(whitelistRegistrants[msg.sender] > 0 )"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "whitelistRegistrants[msg.sender] > 0"
            IndexAccess
               Type: uint256
               Source: "whitelistRegistrants[msg.sender]"
              Identifier whitelistRegistrants
                 Type: mapping(address => uint256)
                 Source: "whitelistRegistrants"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 306
         Source: "uint tempWhitelistAmount = whitelistRegistrants[msg.sender]"
        VariableDeclaration "tempWhitelistAmount"
           Type: uint256
           Source: "uint tempWhitelistAmount"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "whitelistRegistrants[msg.sender]"
          Identifier whitelistRegistrants
             Type: mapping(address => uint256)
             Source: "whitelistRegistrants"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      VariableDeclarationStatement
         Gas costs: 241
         Source: "uint purchaseAmount = msg.value / price_in_wei"
        VariableDeclaration "purchaseAmount"
           Type: uint256
           Source: "uint purchaseAmount"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "msg.value / price_in_wei"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier price_in_wei
             Type: uint256
             Source: "price_in_wei"
      VariableDeclarationStatement
         Gas costs: 241
         Source: "uint excessAmount = msg.value % price_in_wei"
        VariableDeclaration "excessAmount"
           Type: uint256
           Source: "uint excessAmount"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator %
           Type: uint256
           Source: "msg.value % price_in_wei"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier price_in_wei
             Type: uint256
             Source: "price_in_wei"
      IfStatement
         Source: "if(purchaseAmount > whitelistRegistrants[msg.sender]){\r\n            uint extra = purchaseAmount - whitelistRegistrants[msg.sender];\r\n            purchaseAmount = whitelistRegistrants[msg.sender];\r\n            excessAmount += extra*price_in_wei;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 304
           Source: "purchaseAmount > whitelistRegistrants[msg.sender]"
          Identifier purchaseAmount
             Type: uint256
             Source: "purchaseAmount"
          IndexAccess
             Type: uint256
             Source: "whitelistRegistrants[msg.sender]"
            Identifier whitelistRegistrants
               Type: mapping(address => uint256)
               Source: "whitelistRegistrants"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
        Block
           Source: "{\r\n            uint extra = purchaseAmount - whitelistRegistrants[msg.sender];\r\n            purchaseAmount = whitelistRegistrants[msg.sender];\r\n            excessAmount += extra*price_in_wei;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 312
             Source: "uint extra = purchaseAmount - whitelistRegistrants[msg.sender]"
            VariableDeclaration "extra"
               Type: uint256
               Source: "uint extra"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator -
               Type: uint256
               Source: "purchaseAmount - whitelistRegistrants[msg.sender]"
              Identifier purchaseAmount
                 Type: uint256
                 Source: "purchaseAmount"
              IndexAccess
                 Type: uint256
                 Source: "whitelistRegistrants[msg.sender]"
                Identifier whitelistRegistrants
                   Type: mapping(address => uint256)
                   Source: "whitelistRegistrants"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
          ExpressionStatement
             Gas costs: 297
             Source: "purchaseAmount = whitelistRegistrants[msg.sender]"
            Assignment using operator =
               Type: uint256
               Source: "purchaseAmount = whitelistRegistrants[msg.sender]"
              Identifier purchaseAmount
                 Type: uint256
                 Source: "purchaseAmount"
              IndexAccess
                 Type: uint256
                 Source: "whitelistRegistrants[msg.sender]"
                Identifier whitelistRegistrants
                   Type: mapping(address => uint256)
                   Source: "whitelistRegistrants"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
          ExpressionStatement
             Gas costs: 222
             Source: "excessAmount += extra*price_in_wei"
            Assignment using operator +=
               Type: uint256
               Source: "excessAmount += extra*price_in_wei"
              Identifier excessAmount
                 Type: uint256
                 Source: "excessAmount"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "extra*price_in_wei"
                Identifier extra
                   Type: uint256
                   Source: "extra"
                Identifier price_in_wei
                   Type: uint256
                   Source: "price_in_wei"
      ExpressionStatement
         Gas costs: 20328
         Source: "whitelistRegistrants[msg.sender] -= purchaseAmount"
        Assignment using operator -=
           Type: uint256
           Source: "whitelistRegistrants[msg.sender] -= purchaseAmount"
          IndexAccess
             Type: uint256
             Source: "whitelistRegistrants[msg.sender]"
            Identifier whitelistRegistrants
               Type: mapping(address => uint256)
               Source: "whitelistRegistrants"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier purchaseAmount
             Type: uint256
             Source: "purchaseAmount"
      ExpressionStatement
         Gas costs: 318
         Source: "assert(whitelistRegistrants[msg.sender] < tempWhitelistAmount)"
        FunctionCall
           Type: tuple()
           Source: "assert(whitelistRegistrants[msg.sender] < tempWhitelistAmount)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <
             Type: bool
             Source: "whitelistRegistrants[msg.sender] < tempWhitelistAmount"
            IndexAccess
               Type: uint256
               Source: "whitelistRegistrants[msg.sender]"
              Identifier whitelistRegistrants
                 Type: mapping(address => uint256)
                 Source: "whitelistRegistrants"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier tempWhitelistAmount
               Type: uint256
               Source: "tempWhitelistAmount"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(purchaseAmount <= token.balanceOf(this))"
        FunctionCall
           Type: tuple()
           Source: "require(purchaseAmount <= token.balanceOf(this))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "purchaseAmount <= token.balanceOf(this)"
            Identifier purchaseAmount
               Type: uint256
               Source: "purchaseAmount"
            FunctionCall
               Type: uint256
               Source: "token.balanceOf(this)"
              MemberAccess to member balanceOf
                 Type: function (address) view external returns (uint256)
                 Source: "token.balanceOf"
                Identifier token
                   Type: contract HumanStandardToken
                   Source: "token"
              Identifier this
                 Type: contract Sale
                 Source: "this"
      IfStatement
         Source: "if (excessAmount > 0) {\r\n            msg.sender.transfer(excessAmount);\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "excessAmount > 0"
          Identifier excessAmount
             Type: uint256
             Source: "excessAmount"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            msg.sender.transfer(excessAmount);\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.transfer(excessAmount)"
            FunctionCall
               Type: tuple()
               Source: "msg.sender.transfer(excessAmount)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "msg.sender.transfer"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier excessAmount
                 Type: uint256
                 Source: "excessAmount"
      ExpressionStatement
         Gas costs: [???]
         Source: "wallet.transfer(this.balance)"
        FunctionCall
           Type: tuple()
           Source: "wallet.transfer(this.balance)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "wallet.transfer"
            Identifier wallet
               Type: address
               Source: "wallet"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract Sale
               Source: "this"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(token.transfer(msg.sender, purchaseAmount))"
        FunctionCall
           Type: tuple()
           Source: "assert(token.transfer(msg.sender, purchaseAmount))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          FunctionCall
             Type: bool
             Source: "token.transfer(msg.sender, purchaseAmount)"
            MemberAccess to member transfer
               Type: function (address,uint256) external returns (bool)
               Source: "token.transfer"
              Identifier token
                 Type: contract HumanStandardToken
                 Source: "token"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier purchaseAmount
               Type: uint256
               Source: "purchaseAmount"
      ExpressionStatement
         Gas costs: [???]
         Source: "PurchasedTokens(msg.sender, purchaseAmount)"
        FunctionCall
           Type: tuple()
           Source: "PurchasedTokens(msg.sender, purchaseAmount)"
          Identifier PurchasedTokens
             Type: function (address,uint256)
             Source: "PurchasedTokens"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier purchaseAmount
             Type: uint256
             Source: "purchaseAmount"
  FunctionDefinition "lockUnsoldTokens" - public
     Source: "function lockUnsoldTokens(address _unsoldTokensWallet)\r\n        public\r\n        saleEnded\r\n        setupComplete\r\n        onlyOwner\r\n    {\r\n        Disbursement disbursement = new Disbursement(\r\n            _unsoldTokensWallet,\r\n            1*365*24*60*60,\r\n            block.timestamp\r\n        );\r\n\r\n        disbursement.setup(token);\r\n        uint amountToLock = token.balanceOf(this);\r\n        disbursements.push(disbursement);\r\n        token.transfer(disbursement, amountToLock);\r\n        LockedUnsoldTokens(amountToLock, disbursement);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _unsoldTokensWallet)"
      VariableDeclaration "_unsoldTokensWallet"
         Type: address
         Source: "address _unsoldTokensWallet"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "saleEnded"
       Gas costs: 0
       Source: "saleEnded"
      Identifier saleEnded
         Type: modifier ()
         Source: "saleEnded"
    ModifierInvocation "setupComplete"
       Gas costs: 0
       Source: "setupComplete"
      Identifier setupComplete
         Type: modifier ()
         Source: "setupComplete"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        Disbursement disbursement = new Disbursement(\r\n            _unsoldTokensWallet,\r\n            1*365*24*60*60,\r\n            block.timestamp\r\n        );\r\n\r\n        disbursement.setup(token);\r\n        uint amountToLock = token.balanceOf(this);\r\n        disbursements.push(disbursement);\r\n        token.transfer(disbursement, amountToLock);\r\n        LockedUnsoldTokens(amountToLock, disbursement);\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "Disbursement disbursement = new Disbursement(\r\n            _unsoldTokensWallet,\r\n            1*365*24*60*60,\r\n            block.timestamp\r\n        )"
        VariableDeclaration "disbursement"
           Type: contract Disbursement
           Source: "Disbursement disbursement"
          UserDefinedTypeName "Disbursement"
             Source: "Disbursement"
        FunctionCall
           Type: contract Disbursement
           Source: "new Disbursement(\r\n            _unsoldTokensWallet,\r\n            1*365*24*60*60,\r\n            block.timestamp\r\n        )"
          NewExpression
             Type: function (address,uint256,uint256) returns (contract Disbursement)
             Source: "new Disbursement"
            UserDefinedTypeName "Disbursement"
               Source: "Disbursement"
          Identifier _unsoldTokensWallet
             Type: address
             Source: "_unsoldTokensWallet"
          BinaryOperation using operator *
             Type: int_const 31536000
             Source: "1*365*24*60*60"
            BinaryOperation using operator *
               Type: int_const 525600
               Source: "1*365*24*60"
              BinaryOperation using operator *
                 Type: int_const 8760
                 Source: "1*365*24"
                BinaryOperation using operator *
                   Type: int_const 365
                   Source: "1*365"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
                  Literal, token: [no token] value: 365
                     Type: int_const 365
                     Source: "365"
                Literal, token: [no token] value: 24
                   Type: int_const 24
                   Source: "24"
              Literal, token: [no token] value: 60
                 Type: int_const 60
                 Source: "60"
            Literal, token: [no token] value: 60
               Type: int_const 60
               Source: "60"
          MemberAccess to member timestamp
             Type: uint256
             Source: "block.timestamp"
            Identifier block
               Type: block
               Source: "block"
      ExpressionStatement
         Gas costs: [???]
         Source: "disbursement.setup(token)"
        FunctionCall
           Type: tuple()
           Source: "disbursement.setup(token)"
          MemberAccess to member setup
             Type: function (contract Token) external
             Source: "disbursement.setup"
            Identifier disbursement
               Type: contract Disbursement
               Source: "disbursement"
          Identifier token
             Type: contract HumanStandardToken
             Source: "token"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint amountToLock = token.balanceOf(this)"
        VariableDeclaration "amountToLock"
           Type: uint256
           Source: "uint amountToLock"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "token.balanceOf(this)"
          MemberAccess to member balanceOf
             Type: function (address) view external returns (uint256)
             Source: "token.balanceOf"
            Identifier token
               Type: contract HumanStandardToken
               Source: "token"
          Identifier this
             Type: contract Sale
             Source: "this"
      ExpressionStatement
         Gas costs: 20365
         Source: "disbursements.push(disbursement)"
        FunctionCall
           Type: uint256
           Source: "disbursements.push(disbursement)"
          MemberAccess to member push
             Type: function (address) returns (uint256)
             Source: "disbursements.push"
            Identifier disbursements
               Type: address[] storage ref
               Source: "disbursements"
          Identifier disbursement
             Type: contract Disbursement
             Source: "disbursement"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.transfer(disbursement, amountToLock)"
        FunctionCall
           Type: bool
           Source: "token.transfer(disbursement, amountToLock)"
          MemberAccess to member transfer
             Type: function (address,uint256) external returns (bool)
             Source: "token.transfer"
            Identifier token
               Type: contract HumanStandardToken
               Source: "token"
          Identifier disbursement
             Type: contract Disbursement
             Source: "disbursement"
          Identifier amountToLock
             Type: uint256
             Source: "amountToLock"
      ExpressionStatement
         Gas costs: [???]
         Source: "LockedUnsoldTokens(amountToLock, disbursement)"
        FunctionCall
           Type: tuple()
           Source: "LockedUnsoldTokens(amountToLock, disbursement)"
          Identifier LockedUnsoldTokens
             Type: function (uint256,address)
             Source: "LockedUnsoldTokens"
          Identifier amountToLock
             Type: uint256
             Source: "amountToLock"
          Identifier disbursement
             Type: contract Disbursement
             Source: "disbursement"
  FunctionDefinition "distributeTimelockedTokens" - public
     Source: "function distributeTimelockedTokens(\r\n        address[] _beneficiaries,\r\n        uint[] _beneficiariesTokens,\r\n        uint[] _timelockStarts,\r\n        uint[] _periods\r\n    ) \r\n        public\r\n        onlyOwner\r\n        saleNotEnded\r\n    { \r\n        assert(!setupCompleteFlag);\r\n        assert(_beneficiariesTokens.length < 11);\r\n        assert(_beneficiaries.length == _beneficiariesTokens.length);\r\n        assert(_beneficiariesTokens.length == _timelockStarts.length);\r\n        assert(_timelockStarts.length == _periods.length);\r\n\r\n        for(uint i = 0; i < _beneficiaries.length; i++) {\r\n            require(privateAllocated + _beneficiariesTokens[i] <= MAX_PRIVATE);\r\n            privateAllocated += _beneficiariesTokens[i];\r\n            address beneficiary = _beneficiaries[i];\r\n            uint beneficiaryTokens = _beneficiariesTokens[i];\r\n\r\n            Disbursement disbursement = new Disbursement(\r\n                beneficiary,\r\n                _periods[i],\r\n                _timelockStarts[i]\r\n            );\r\n\r\n            disbursement.setup(token);\r\n            token.transfer(disbursement, beneficiaryTokens);\r\n            disbursements.push(disbursement);\r\n            TransferredTimelockedTokens(beneficiary, disbursement, beneficiaryTokens);\r\n        }\r\n\r\n        assert(token.balanceOf(this) >= (TOTAL_SUPPLY - MAX_PRIVATE));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        address[] _beneficiaries,\r\n        uint[] _beneficiariesTokens,\r\n        uint[] _timelockStarts,\r\n        uint[] _periods\r\n    )"
      VariableDeclaration "_beneficiaries"
         Type: address[] memory
         Source: "address[] _beneficiaries"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_beneficiariesTokens"
         Type: uint256[] memory
         Source: "uint[] _beneficiariesTokens"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclaration "_timelockStarts"
         Type: uint256[] memory
         Source: "uint[] _timelockStarts"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclaration "_periods"
         Type: uint256[] memory
         Source: "uint[] _periods"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "saleNotEnded"
       Gas costs: 0
       Source: "saleNotEnded"
      Identifier saleNotEnded
         Type: modifier ()
         Source: "saleNotEnded"
    Block
       Source: "{ \r\n        assert(!setupCompleteFlag);\r\n        assert(_beneficiariesTokens.length < 11);\r\n        assert(_beneficiaries.length == _beneficiariesTokens.length);\r\n        assert(_beneficiariesTokens.length == _timelockStarts.length);\r\n        assert(_timelockStarts.length == _periods.length);\r\n\r\n        for(uint i = 0; i < _beneficiaries.length; i++) {\r\n            require(privateAllocated + _beneficiariesTokens[i] <= MAX_PRIVATE);\r\n            privateAllocated += _beneficiariesTokens[i];\r\n            address beneficiary = _beneficiaries[i];\r\n            uint beneficiaryTokens = _beneficiariesTokens[i];\r\n\r\n            Disbursement disbursement = new Disbursement(\r\n                beneficiary,\r\n                _periods[i],\r\n                _timelockStarts[i]\r\n            );\r\n\r\n            disbursement.setup(token);\r\n            token.transfer(disbursement, beneficiaryTokens);\r\n            disbursements.push(disbursement);\r\n            TransferredTimelockedTokens(beneficiary, disbursement, beneficiaryTokens);\r\n        }\r\n\r\n        assert(token.balanceOf(this) >= (TOTAL_SUPPLY - MAX_PRIVATE));\r\n    }"
      ExpressionStatement
         Gas costs: 262
         Source: "assert(!setupCompleteFlag)"
        FunctionCall
           Type: tuple()
           Source: "assert(!setupCompleteFlag)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!setupCompleteFlag"
            Identifier setupCompleteFlag
               Type: bool
               Source: "setupCompleteFlag"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(_beneficiariesTokens.length < 11)"
        FunctionCall
           Type: tuple()
           Source: "assert(_beneficiariesTokens.length < 11)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <
             Type: bool
             Source: "_beneficiariesTokens.length < 11"
            MemberAccess to member length
               Type: uint256
               Source: "_beneficiariesTokens.length"
              Identifier _beneficiariesTokens
                 Type: uint256[] memory
                 Source: "_beneficiariesTokens"
            Literal, token: [no token] value: 11
               Type: int_const 11
               Source: "11"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(_beneficiaries.length == _beneficiariesTokens.length)"
        FunctionCall
           Type: tuple()
           Source: "assert(_beneficiaries.length == _beneficiariesTokens.length)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "_beneficiaries.length == _beneficiariesTokens.length"
            MemberAccess to member length
               Type: uint256
               Source: "_beneficiaries.length"
              Identifier _beneficiaries
                 Type: address[] memory
                 Source: "_beneficiaries"
            MemberAccess to member length
               Type: uint256
               Source: "_beneficiariesTokens.length"
              Identifier _beneficiariesTokens
                 Type: uint256[] memory
                 Source: "_beneficiariesTokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(_beneficiariesTokens.length == _timelockStarts.length)"
        FunctionCall
           Type: tuple()
           Source: "assert(_beneficiariesTokens.length == _timelockStarts.length)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "_beneficiariesTokens.length == _timelockStarts.length"
            MemberAccess to member length
               Type: uint256
               Source: "_beneficiariesTokens.length"
              Identifier _beneficiariesTokens
                 Type: uint256[] memory
                 Source: "_beneficiariesTokens"
            MemberAccess to member length
               Type: uint256
               Source: "_timelockStarts.length"
              Identifier _timelockStarts
                 Type: uint256[] memory
                 Source: "_timelockStarts"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(_timelockStarts.length == _periods.length)"
        FunctionCall
           Type: tuple()
           Source: "assert(_timelockStarts.length == _periods.length)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "_timelockStarts.length == _periods.length"
            MemberAccess to member length
               Type: uint256
               Source: "_timelockStarts.length"
              Identifier _timelockStarts
                 Type: uint256[] memory
                 Source: "_timelockStarts"
            MemberAccess to member length
               Type: uint256
               Source: "_periods.length"
              Identifier _periods
                 Type: uint256[] memory
                 Source: "_periods"
      ForStatement
         Source: "for(uint i = 0; i < _beneficiaries.length; i++) {\r\n            require(privateAllocated + _beneficiariesTokens[i] <= MAX_PRIVATE);\r\n            privateAllocated += _beneficiariesTokens[i];\r\n            address beneficiary = _beneficiaries[i];\r\n            uint beneficiaryTokens = _beneficiariesTokens[i];\r\n\r\n            Disbursement disbursement = new Disbursement(\r\n                beneficiary,\r\n                _periods[i],\r\n                _timelockStarts[i]\r\n            );\r\n\r\n            disbursement.setup(token);\r\n            token.transfer(disbursement, beneficiaryTokens);\r\n            disbursements.push(disbursement);\r\n            TransferredTimelockedTokens(beneficiary, disbursement, beneficiaryTokens);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "i < _beneficiaries.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_beneficiaries.length"
            Identifier _beneficiaries
               Type: address[] memory
               Source: "_beneficiaries"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            require(privateAllocated + _beneficiariesTokens[i] <= MAX_PRIVATE);\r\n            privateAllocated += _beneficiariesTokens[i];\r\n            address beneficiary = _beneficiaries[i];\r\n            uint beneficiaryTokens = _beneficiariesTokens[i];\r\n\r\n            Disbursement disbursement = new Disbursement(\r\n                beneficiary,\r\n                _periods[i],\r\n                _timelockStarts[i]\r\n            );\r\n\r\n            disbursement.setup(token);\r\n            token.transfer(disbursement, beneficiaryTokens);\r\n            disbursements.push(disbursement);\r\n            TransferredTimelockedTokens(beneficiary, disbursement, beneficiaryTokens);\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(privateAllocated + _beneficiariesTokens[i] <= MAX_PRIVATE)"
            FunctionCall
               Type: tuple()
               Source: "require(privateAllocated + _beneficiariesTokens[i] <= MAX_PRIVATE)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "privateAllocated + _beneficiariesTokens[i] <= MAX_PRIVATE"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "privateAllocated + _beneficiariesTokens[i]"
                  Identifier privateAllocated
                     Type: uint256
                     Source: "privateAllocated"
                  IndexAccess
                     Type: uint256
                     Source: "_beneficiariesTokens[i]"
                    Identifier _beneficiariesTokens
                       Type: uint256[] memory
                       Source: "_beneficiariesTokens"
                    Identifier i
                       Type: uint256
                       Source: "i"
                Identifier MAX_PRIVATE
                   Type: uint256
                   Source: "MAX_PRIVATE"
          ExpressionStatement
             Gas costs: [???]
             Source: "privateAllocated += _beneficiariesTokens[i]"
            Assignment using operator +=
               Type: uint256
               Source: "privateAllocated += _beneficiariesTokens[i]"
              Identifier privateAllocated
                 Type: uint256
                 Source: "privateAllocated"
              IndexAccess
                 Type: uint256
                 Source: "_beneficiariesTokens[i]"
                Identifier _beneficiariesTokens
                   Type: uint256[] memory
                   Source: "_beneficiariesTokens"
                Identifier i
                   Type: uint256
                   Source: "i"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "address beneficiary = _beneficiaries[i]"
            VariableDeclaration "beneficiary"
               Type: address
               Source: "address beneficiary"
              ElementaryTypeName address
                 Source: "address"
            IndexAccess
               Type: address
               Source: "_beneficiaries[i]"
              Identifier _beneficiaries
                 Type: address[] memory
                 Source: "_beneficiaries"
              Identifier i
                 Type: uint256
                 Source: "i"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "uint beneficiaryTokens = _beneficiariesTokens[i]"
            VariableDeclaration "beneficiaryTokens"
               Type: uint256
               Source: "uint beneficiaryTokens"
              ElementaryTypeName uint
                 Source: "uint"
            IndexAccess
               Type: uint256
               Source: "_beneficiariesTokens[i]"
              Identifier _beneficiariesTokens
                 Type: uint256[] memory
                 Source: "_beneficiariesTokens"
              Identifier i
                 Type: uint256
                 Source: "i"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "Disbursement disbursement = new Disbursement(\r\n                beneficiary,\r\n                _periods[i],\r\n                _timelockStarts[i]\r\n            )"
            VariableDeclaration "disbursement"
               Type: contract Disbursement
               Source: "Disbursement disbursement"
              UserDefinedTypeName "Disbursement"
                 Source: "Disbursement"
            FunctionCall
               Type: contract Disbursement
               Source: "new Disbursement(\r\n                beneficiary,\r\n                _periods[i],\r\n                _timelockStarts[i]\r\n            )"
              NewExpression
                 Type: function (address,uint256,uint256) returns (contract Disbursement)
                 Source: "new Disbursement"
                UserDefinedTypeName "Disbursement"
                   Source: "Disbursement"
              Identifier beneficiary
                 Type: address
                 Source: "beneficiary"
              IndexAccess
                 Type: uint256
                 Source: "_periods[i]"
                Identifier _periods
                   Type: uint256[] memory
                   Source: "_periods"
                Identifier i
                   Type: uint256
                   Source: "i"
              IndexAccess
                 Type: uint256
                 Source: "_timelockStarts[i]"
                Identifier _timelockStarts
                   Type: uint256[] memory
                   Source: "_timelockStarts"
                Identifier i
                   Type: uint256
                   Source: "i"
          ExpressionStatement
             Gas costs: [???]
             Source: "disbursement.setup(token)"
            FunctionCall
               Type: tuple()
               Source: "disbursement.setup(token)"
              MemberAccess to member setup
                 Type: function (contract Token) external
                 Source: "disbursement.setup"
                Identifier disbursement
                   Type: contract Disbursement
                   Source: "disbursement"
              Identifier token
                 Type: contract HumanStandardToken
                 Source: "token"
          ExpressionStatement
             Gas costs: [???]
             Source: "token.transfer(disbursement, beneficiaryTokens)"
            FunctionCall
               Type: bool
               Source: "token.transfer(disbursement, beneficiaryTokens)"
              MemberAccess to member transfer
                 Type: function (address,uint256) external returns (bool)
                 Source: "token.transfer"
                Identifier token
                   Type: contract HumanStandardToken
                   Source: "token"
              Identifier disbursement
                 Type: contract Disbursement
                 Source: "disbursement"
              Identifier beneficiaryTokens
                 Type: uint256
                 Source: "beneficiaryTokens"
          ExpressionStatement
             Gas costs: 20365
             Source: "disbursements.push(disbursement)"
            FunctionCall
               Type: uint256
               Source: "disbursements.push(disbursement)"
              MemberAccess to member push
                 Type: function (address) returns (uint256)
                 Source: "disbursements.push"
                Identifier disbursements
                   Type: address[] storage ref
                   Source: "disbursements"
              Identifier disbursement
                 Type: contract Disbursement
                 Source: "disbursement"
          ExpressionStatement
             Gas costs: [???]
             Source: "TransferredTimelockedTokens(beneficiary, disbursement, beneficiaryTokens)"
            FunctionCall
               Type: tuple()
               Source: "TransferredTimelockedTokens(beneficiary, disbursement, beneficiaryTokens)"
              Identifier TransferredTimelockedTokens
                 Type: function (address,address,uint256)
                 Source: "TransferredTimelockedTokens"
              Identifier beneficiary
                 Type: address
                 Source: "beneficiary"
              Identifier disbursement
                 Type: contract Disbursement
                 Source: "disbursement"
              Identifier beneficiaryTokens
                 Type: uint256
                 Source: "beneficiaryTokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(token.balanceOf(this) >= (TOTAL_SUPPLY - MAX_PRIVATE))"
        FunctionCall
           Type: tuple()
           Source: "assert(token.balanceOf(this) >= (TOTAL_SUPPLY - MAX_PRIVATE))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "token.balanceOf(this) >= (TOTAL_SUPPLY - MAX_PRIVATE)"
            FunctionCall
               Type: uint256
               Source: "token.balanceOf(this)"
              MemberAccess to member balanceOf
                 Type: function (address) view external returns (uint256)
                 Source: "token.balanceOf"
                Identifier token
                   Type: contract HumanStandardToken
                   Source: "token"
              Identifier this
                 Type: contract Sale
                 Source: "this"
            TupleExpression
               Type: uint256
               Source: "(TOTAL_SUPPLY - MAX_PRIVATE)"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "TOTAL_SUPPLY - MAX_PRIVATE"
                Identifier TOTAL_SUPPLY
                   Type: uint256
                   Source: "TOTAL_SUPPLY"
                Identifier MAX_PRIVATE
                   Type: uint256
                   Source: "MAX_PRIVATE"
  FunctionDefinition "distributePresaleTokens" - public
     Source: "function distributePresaleTokens(address[] _buyers, uint[] _amounts)\r\n        public\r\n        onlyOwner\r\n        saleNotEnded\r\n    {\r\n        assert(!setupCompleteFlag);\r\n        require(_buyers.length < 11);\r\n        require(_buyers.length == _amounts.length);\r\n\r\n        for(uint i=0; i < _buyers.length; i++){\r\n            require(privateAllocated + _amounts[i] <= MAX_PRIVATE);\r\n            assert(token.transfer(_buyers[i], _amounts[i]));\r\n            privateAllocated += _amounts[i];\r\n            PurchasedTokens(_buyers[i], _amounts[i]);\r\n        }\r\n\r\n        assert(token.balanceOf(this) >= (TOTAL_SUPPLY - MAX_PRIVATE));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _buyers, uint[] _amounts)"
      VariableDeclaration "_buyers"
         Type: address[] memory
         Source: "address[] _buyers"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_amounts"
         Type: uint256[] memory
         Source: "uint[] _amounts"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "saleNotEnded"
       Gas costs: 0
       Source: "saleNotEnded"
      Identifier saleNotEnded
         Type: modifier ()
         Source: "saleNotEnded"
    Block
       Source: "{\r\n        assert(!setupCompleteFlag);\r\n        require(_buyers.length < 11);\r\n        require(_buyers.length == _amounts.length);\r\n\r\n        for(uint i=0; i < _buyers.length; i++){\r\n            require(privateAllocated + _amounts[i] <= MAX_PRIVATE);\r\n            assert(token.transfer(_buyers[i], _amounts[i]));\r\n            privateAllocated += _amounts[i];\r\n            PurchasedTokens(_buyers[i], _amounts[i]);\r\n        }\r\n\r\n        assert(token.balanceOf(this) >= (TOTAL_SUPPLY - MAX_PRIVATE));\r\n    }"
      ExpressionStatement
         Gas costs: 262
         Source: "assert(!setupCompleteFlag)"
        FunctionCall
           Type: tuple()
           Source: "assert(!setupCompleteFlag)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!setupCompleteFlag"
            Identifier setupCompleteFlag
               Type: bool
               Source: "setupCompleteFlag"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(_buyers.length < 11)"
        FunctionCall
           Type: tuple()
           Source: "require(_buyers.length < 11)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "_buyers.length < 11"
            MemberAccess to member length
               Type: uint256
               Source: "_buyers.length"
              Identifier _buyers
                 Type: address[] memory
                 Source: "_buyers"
            Literal, token: [no token] value: 11
               Type: int_const 11
               Source: "11"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(_buyers.length == _amounts.length)"
        FunctionCall
           Type: tuple()
           Source: "require(_buyers.length == _amounts.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "_buyers.length == _amounts.length"
            MemberAccess to member length
               Type: uint256
               Source: "_buyers.length"
              Identifier _buyers
                 Type: address[] memory
                 Source: "_buyers"
            MemberAccess to member length
               Type: uint256
               Source: "_amounts.length"
              Identifier _amounts
                 Type: uint256[] memory
                 Source: "_amounts"
      ForStatement
         Source: "for(uint i=0; i < _buyers.length; i++){\r\n            require(privateAllocated + _amounts[i] <= MAX_PRIVATE);\r\n            assert(token.transfer(_buyers[i], _amounts[i]));\r\n            privateAllocated += _amounts[i];\r\n            PurchasedTokens(_buyers[i], _amounts[i]);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "i < _buyers.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_buyers.length"
            Identifier _buyers
               Type: address[] memory
               Source: "_buyers"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            require(privateAllocated + _amounts[i] <= MAX_PRIVATE);\r\n            assert(token.transfer(_buyers[i], _amounts[i]));\r\n            privateAllocated += _amounts[i];\r\n            PurchasedTokens(_buyers[i], _amounts[i]);\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(privateAllocated + _amounts[i] <= MAX_PRIVATE)"
            FunctionCall
               Type: tuple()
               Source: "require(privateAllocated + _amounts[i] <= MAX_PRIVATE)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "privateAllocated + _amounts[i] <= MAX_PRIVATE"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "privateAllocated + _amounts[i]"
                  Identifier privateAllocated
                     Type: uint256
                     Source: "privateAllocated"
                  IndexAccess
                     Type: uint256
                     Source: "_amounts[i]"
                    Identifier _amounts
                       Type: uint256[] memory
                       Source: "_amounts"
                    Identifier i
                       Type: uint256
                       Source: "i"
                Identifier MAX_PRIVATE
                   Type: uint256
                   Source: "MAX_PRIVATE"
          ExpressionStatement
             Gas costs: [???]
             Source: "assert(token.transfer(_buyers[i], _amounts[i]))"
            FunctionCall
               Type: tuple()
               Source: "assert(token.transfer(_buyers[i], _amounts[i]))"
              Identifier assert
                 Type: function (bool) pure
                 Source: "assert"
              FunctionCall
                 Type: bool
                 Source: "token.transfer(_buyers[i], _amounts[i])"
                MemberAccess to member transfer
                   Type: function (address,uint256) external returns (bool)
                   Source: "token.transfer"
                  Identifier token
                     Type: contract HumanStandardToken
                     Source: "token"
                IndexAccess
                   Type: address
                   Source: "_buyers[i]"
                  Identifier _buyers
                     Type: address[] memory
                     Source: "_buyers"
                  Identifier i
                     Type: uint256
                     Source: "i"
                IndexAccess
                   Type: uint256
                   Source: "_amounts[i]"
                  Identifier _amounts
                     Type: uint256[] memory
                     Source: "_amounts"
                  Identifier i
                     Type: uint256
                     Source: "i"
          ExpressionStatement
             Gas costs: [???]
             Source: "privateAllocated += _amounts[i]"
            Assignment using operator +=
               Type: uint256
               Source: "privateAllocated += _amounts[i]"
              Identifier privateAllocated
                 Type: uint256
                 Source: "privateAllocated"
              IndexAccess
                 Type: uint256
                 Source: "_amounts[i]"
                Identifier _amounts
                   Type: uint256[] memory
                   Source: "_amounts"
                Identifier i
                   Type: uint256
                   Source: "i"
          ExpressionStatement
             Gas costs: [???]
             Source: "PurchasedTokens(_buyers[i], _amounts[i])"
            FunctionCall
               Type: tuple()
               Source: "PurchasedTokens(_buyers[i], _amounts[i])"
              Identifier PurchasedTokens
                 Type: function (address,uint256)
                 Source: "PurchasedTokens"
              IndexAccess
                 Type: address
                 Source: "_buyers[i]"
                Identifier _buyers
                   Type: address[] memory
                   Source: "_buyers"
                Identifier i
                   Type: uint256
                   Source: "i"
              IndexAccess
                 Type: uint256
                 Source: "_amounts[i]"
                Identifier _amounts
                   Type: uint256[] memory
                   Source: "_amounts"
                Identifier i
                   Type: uint256
                   Source: "i"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(token.balanceOf(this) >= (TOTAL_SUPPLY - MAX_PRIVATE))"
        FunctionCall
           Type: tuple()
           Source: "assert(token.balanceOf(this) >= (TOTAL_SUPPLY - MAX_PRIVATE))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "token.balanceOf(this) >= (TOTAL_SUPPLY - MAX_PRIVATE)"
            FunctionCall
               Type: uint256
               Source: "token.balanceOf(this)"
              MemberAccess to member balanceOf
                 Type: function (address) view external returns (uint256)
                 Source: "token.balanceOf"
                Identifier token
                   Type: contract HumanStandardToken
                   Source: "token"
              Identifier this
                 Type: contract Sale
                 Source: "this"
            TupleExpression
               Type: uint256
               Source: "(TOTAL_SUPPLY - MAX_PRIVATE)"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "TOTAL_SUPPLY - MAX_PRIVATE"
                Identifier TOTAL_SUPPLY
                   Type: uint256
                   Source: "TOTAL_SUPPLY"
                Identifier MAX_PRIVATE
                   Type: uint256
                   Source: "MAX_PRIVATE"
  FunctionDefinition "removeTransferLock" - public
     Source: "function removeTransferLock()\r\n        public\r\n        onlyOwner\r\n    {\r\n        token.removeTransferLock();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        token.removeTransferLock();\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.removeTransferLock()"
        FunctionCall
           Type: tuple()
           Source: "token.removeTransferLock()"
          MemberAccess to member removeTransferLock
             Type: function () external
             Source: "token.removeTransferLock"
            Identifier token
               Type: contract HumanStandardToken
               Source: "token"
  FunctionDefinition "reversePurchase" - public
     Source: "function reversePurchase(address _tokenHolder)\r\n        payable\r\n        public\r\n        onlyOwner\r\n    {\r\n        uint refund = token.balanceOf(_tokenHolder)*price_in_wei;\r\n        require(msg.value >= refund);\r\n        uint excessAmount = msg.value - refund;\r\n\r\n        if (excessAmount > 0) {\r\n            msg.sender.transfer(excessAmount);\r\n        }\r\n\r\n        _tokenHolder.transfer(refund);\r\n        token.reversePurchase(_tokenHolder);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _tokenHolder)"
      VariableDeclaration "_tokenHolder"
         Type: address
         Source: "address _tokenHolder"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        uint refund = token.balanceOf(_tokenHolder)*price_in_wei;\r\n        require(msg.value >= refund);\r\n        uint excessAmount = msg.value - refund;\r\n\r\n        if (excessAmount > 0) {\r\n            msg.sender.transfer(excessAmount);\r\n        }\r\n\r\n        _tokenHolder.transfer(refund);\r\n        token.reversePurchase(_tokenHolder);\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint refund = token.balanceOf(_tokenHolder)*price_in_wei"
        VariableDeclaration "refund"
           Type: uint256
           Source: "uint refund"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "token.balanceOf(_tokenHolder)*price_in_wei"
          FunctionCall
             Type: uint256
             Source: "token.balanceOf(_tokenHolder)"
            MemberAccess to member balanceOf
               Type: function (address) view external returns (uint256)
               Source: "token.balanceOf"
              Identifier token
                 Type: contract HumanStandardToken
                 Source: "token"
            Identifier _tokenHolder
               Type: address
               Source: "_tokenHolder"
          Identifier price_in_wei
             Type: uint256
             Source: "price_in_wei"
      ExpressionStatement
         Gas costs: 37
         Source: "require(msg.value >= refund)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value >= refund)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.value >= refund"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier refund
               Type: uint256
               Source: "refund"
      VariableDeclarationStatement
         Gas costs: 16
         Source: "uint excessAmount = msg.value - refund"
        VariableDeclaration "excessAmount"
           Type: uint256
           Source: "uint excessAmount"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator -
           Type: uint256
           Source: "msg.value - refund"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier refund
             Type: uint256
             Source: "refund"
      IfStatement
         Source: "if (excessAmount > 0) {\r\n            msg.sender.transfer(excessAmount);\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "excessAmount > 0"
          Identifier excessAmount
             Type: uint256
             Source: "excessAmount"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            msg.sender.transfer(excessAmount);\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.transfer(excessAmount)"
            FunctionCall
               Type: tuple()
               Source: "msg.sender.transfer(excessAmount)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "msg.sender.transfer"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier excessAmount
                 Type: uint256
                 Source: "excessAmount"
      ExpressionStatement
         Gas costs: [???]
         Source: "_tokenHolder.transfer(refund)"
        FunctionCall
           Type: tuple()
           Source: "_tokenHolder.transfer(refund)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "_tokenHolder.transfer"
            Identifier _tokenHolder
               Type: address
               Source: "_tokenHolder"
          Identifier refund
             Type: uint256
             Source: "refund"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.reversePurchase(_tokenHolder)"
        FunctionCall
           Type: tuple()
           Source: "token.reversePurchase(_tokenHolder)"
          MemberAccess to member reversePurchase
             Type: function (address) external
             Source: "token.reversePurchase"
            Identifier token
               Type: contract HumanStandardToken
               Source: "token"
          Identifier _tokenHolder
             Type: address
             Source: "_tokenHolder"
  FunctionDefinition "setSetupComplete" - public
     Source: "function setSetupComplete()\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(wallet!=0);\r\n        require(privateAllocated!=0);  \r\n        setupCompleteFlag = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(wallet!=0);\r\n        require(privateAllocated!=0);  \r\n        setupCompleteFlag = true;\r\n    }"
      ExpressionStatement
         Gas costs: 280
         Source: "require(wallet!=0)"
        FunctionCall
           Type: tuple()
           Source: "require(wallet!=0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "wallet!=0"
            Identifier wallet
               Type: address
               Source: "wallet"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 238
         Source: "require(privateAllocated!=0)"
        FunctionCall
           Type: tuple()
           Source: "require(privateAllocated!=0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "privateAllocated!=0"
            Identifier privateAllocated
               Type: uint256
               Source: "privateAllocated"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "setupCompleteFlag = true"
        Assignment using operator =
           Type: bool
           Source: "setupCompleteFlag = true"
          Identifier setupCompleteFlag
             Type: bool
             Source: "setupCompleteFlag"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "configureWallet" - public
     Source: "function configureWallet(address _wallet)\r\n        public\r\n        onlyOwner\r\n    {\r\n        wallet = _wallet;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _wallet)"
      VariableDeclaration "_wallet"
         Type: address
         Source: "address _wallet"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        wallet = _wallet;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "wallet = _wallet"
        Assignment using operator =
           Type: address
           Source: "wallet = _wallet"
          Identifier wallet
             Type: address
             Source: "wallet"
          Identifier _wallet
             Type: address
             Source: "_wallet"
  FunctionDefinition "changeOwner" - public
     Source: "function changeOwner(address _newOwner)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(_newOwner != 0);\r\n        owner = _newOwner;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _newOwner)"
      VariableDeclaration "_newOwner"
         Type: address
         Source: "address _newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_newOwner != 0);\r\n        owner = _newOwner;\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "require(_newOwner != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_newOwner != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_newOwner != 0"
            Identifier _newOwner
               Type: address
               Source: "_newOwner"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = _newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = _newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier _newOwner
             Type: address
             Source: "_newOwner"
  FunctionDefinition "changePrice" - public
     Source: "function changePrice(uint _newPrice)\r\n        public\r\n        onlyOwner\r\n        notFrozen\r\n        validPrice(_newPrice)\r\n    {\r\n        price_in_wei = _newPrice;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _newPrice)"
      VariableDeclaration "_newPrice"
         Type: uint256
         Source: "uint _newPrice"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "notFrozen"
       Gas costs: 0
       Source: "notFrozen"
      Identifier notFrozen
         Type: modifier ()
         Source: "notFrozen"
    ModifierInvocation "validPrice"
       Gas costs: 3
       Source: "validPrice(_newPrice)"
      Identifier validPrice
         Type: modifier (uint256)
         Source: "validPrice"
      Identifier _newPrice
         Type: uint256
         Source: "_newPrice"
    Block
       Source: "{\r\n        price_in_wei = _newPrice;\r\n    }"
      ExpressionStatement
         Gas costs: 20014
         Source: "price_in_wei = _newPrice"
        Assignment using operator =
           Type: uint256
           Source: "price_in_wei = _newPrice"
          Identifier price_in_wei
             Type: uint256
             Source: "price_in_wei"
          Identifier _newPrice
             Type: uint256
             Source: "_newPrice"
  FunctionDefinition "changeStartBlock" - public
     Source: "function changeStartBlock(uint _newBlock)\r\n        public\r\n        onlyOwner\r\n        notFrozen\r\n    {\r\n        require(block.number <= _newBlock && _newBlock < startBlock);\r\n        freezeBlock = _newBlock - (startBlock - freezeBlock);\r\n        startBlock = _newBlock;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _newBlock)"
      VariableDeclaration "_newBlock"
         Type: uint256
         Source: "uint _newBlock"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "notFrozen"
       Gas costs: 0
       Source: "notFrozen"
      Identifier notFrozen
         Type: modifier ()
         Source: "notFrozen"
    Block
       Source: "{\r\n        require(block.number <= _newBlock && _newBlock < startBlock);\r\n        freezeBlock = _newBlock - (startBlock - freezeBlock);\r\n        startBlock = _newBlock;\r\n    }"
      ExpressionStatement
         Gas costs: 268
         Source: "require(block.number <= _newBlock && _newBlock < startBlock)"
        FunctionCall
           Type: tuple()
           Source: "require(block.number <= _newBlock && _newBlock < startBlock)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "block.number <= _newBlock && _newBlock < startBlock"
            BinaryOperation using operator <=
               Type: bool
               Source: "block.number <= _newBlock"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              Identifier _newBlock
                 Type: uint256
                 Source: "_newBlock"
            BinaryOperation using operator <
               Type: bool
               Source: "_newBlock < startBlock"
              Identifier _newBlock
                 Type: uint256
                 Source: "_newBlock"
              Identifier startBlock
                 Type: uint256
                 Source: "startBlock"
      ExpressionStatement
         Gas costs: 20426
         Source: "freezeBlock = _newBlock - (startBlock - freezeBlock)"
        Assignment using operator =
           Type: uint256
           Source: "freezeBlock = _newBlock - (startBlock - freezeBlock)"
          Identifier freezeBlock
             Type: uint256
             Source: "freezeBlock"
          BinaryOperation using operator -
             Type: uint256
             Source: "_newBlock - (startBlock - freezeBlock)"
            Identifier _newBlock
               Type: uint256
               Source: "_newBlock"
            TupleExpression
               Type: uint256
               Source: "(startBlock - freezeBlock)"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "startBlock - freezeBlock"
                Identifier startBlock
                   Type: uint256
                   Source: "startBlock"
                Identifier freezeBlock
                   Type: uint256
                   Source: "freezeBlock"
      ExpressionStatement
         Gas costs: 20014
         Source: "startBlock = _newBlock"
        Assignment using operator =
           Type: uint256
           Source: "startBlock = _newBlock"
          Identifier startBlock
             Type: uint256
             Source: "startBlock"
          Identifier _newBlock
             Type: uint256
             Source: "_newBlock"
  FunctionDefinition "emergencyToggle" - public
     Source: "function emergencyToggle()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emergencyFlag = !emergencyFlag;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        emergencyFlag = !emergencyFlag;\r\n    }"
      ExpressionStatement
         Gas costs: 20606
         Source: "emergencyFlag = !emergencyFlag"
        Assignment using operator =
           Type: bool
           Source: "emergencyFlag = !emergencyFlag"
          Identifier emergencyFlag
             Type: bool
             Source: "emergencyFlag"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!emergencyFlag"
            Identifier emergencyFlag
               Type: bool
               Source: "emergencyFlag"
  FunctionDefinition "addWhitelist" - public
     Source: "function addWhitelist(address[] _purchaser, uint[] _amount)\r\n        public\r\n        onlyOwner\r\n        saleNotEnded\r\n    {\r\n        assert(_purchaser.length < 11 );\r\n        assert(_purchaser.length == _amount.length);\r\n        for(uint i = 0; i < _purchaser.length; i++) {\r\n            whitelistRegistrants[_purchaser[i]] = _amount[i];\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _purchaser, uint[] _amount)"
      VariableDeclaration "_purchaser"
         Type: address[] memory
         Source: "address[] _purchaser"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_amount"
         Type: uint256[] memory
         Source: "uint[] _amount"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "saleNotEnded"
       Gas costs: 0
       Source: "saleNotEnded"
      Identifier saleNotEnded
         Type: modifier ()
         Source: "saleNotEnded"
    Block
       Source: "{\r\n        assert(_purchaser.length < 11 );\r\n        assert(_purchaser.length == _amount.length);\r\n        for(uint i = 0; i < _purchaser.length; i++) {\r\n            whitelistRegistrants[_purchaser[i]] = _amount[i];\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(_purchaser.length < 11 )"
        FunctionCall
           Type: tuple()
           Source: "assert(_purchaser.length < 11 )"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <
             Type: bool
             Source: "_purchaser.length < 11"
            MemberAccess to member length
               Type: uint256
               Source: "_purchaser.length"
              Identifier _purchaser
                 Type: address[] memory
                 Source: "_purchaser"
            Literal, token: [no token] value: 11
               Type: int_const 11
               Source: "11"
      ExpressionStatement
         Gas costs: [???]
         Source: "assert(_purchaser.length == _amount.length)"
        FunctionCall
           Type: tuple()
           Source: "assert(_purchaser.length == _amount.length)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "_purchaser.length == _amount.length"
            MemberAccess to member length
               Type: uint256
               Source: "_purchaser.length"
              Identifier _purchaser
                 Type: address[] memory
                 Source: "_purchaser"
            MemberAccess to member length
               Type: uint256
               Source: "_amount.length"
              Identifier _amount
                 Type: uint256[] memory
                 Source: "_amount"
      ForStatement
         Source: "for(uint i = 0; i < _purchaser.length; i++) {\r\n            whitelistRegistrants[_purchaser[i]] = _amount[i];\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "i < _purchaser.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_purchaser.length"
            Identifier _purchaser
               Type: address[] memory
               Source: "_purchaser"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            whitelistRegistrants[_purchaser[i]] = _amount[i];\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "whitelistRegistrants[_purchaser[i]] = _amount[i]"
            Assignment using operator =
               Type: uint256
               Source: "whitelistRegistrants[_purchaser[i]] = _amount[i]"
              IndexAccess
                 Type: uint256
                 Source: "whitelistRegistrants[_purchaser[i]]"
                Identifier whitelistRegistrants
                   Type: mapping(address => uint256)
                   Source: "whitelistRegistrants"
                IndexAccess
                   Type: address
                   Source: "_purchaser[i]"
                  Identifier _purchaser
                     Type: address[] memory
                     Source: "_purchaser"
                  Identifier i
                     Type: uint256
                     Source: "i"
              IndexAccess
                 Type: uint256
                 Source: "_amount[i]"
                Identifier _amount
                   Type: uint256[] memory
                   Source: "_amount"
                Identifier i
                   Type: uint256
                   Source: "i"
  ModifierDefinition "saleEnded"
     Source: "modifier saleEnded {\r\n        require(block.number >= endBlock);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(block.number >= endBlock);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 237
         Source: "require(block.number >= endBlock)"
        FunctionCall
           Type: tuple()
           Source: "require(block.number >= endBlock)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "block.number >= endBlock"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier endBlock
               Type: uint256
               Source: "endBlock"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "saleNotEnded"
     Source: "modifier saleNotEnded {\r\n        require(block.number < endBlock);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(block.number < endBlock);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 702
         Source: "require(block.number < endBlock)"
        FunctionCall
           Type: tuple()
           Source: "require(block.number < endBlock)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "block.number < endBlock"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier endBlock
               Type: uint256
               Source: "endBlock"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 3384
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "notFrozen"
     Source: "modifier notFrozen {\r\n        require(block.number < freezeBlock);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(block.number < freezeBlock);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 468
         Source: "require(block.number < freezeBlock)"
        FunctionCall
           Type: tuple()
           Source: "require(block.number < freezeBlock)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "block.number < freezeBlock"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier freezeBlock
               Type: uint256
               Source: "freezeBlock"
      PlaceholderStatement
         Gas costs: 2
         Source: "_"
  ModifierDefinition "saleInProgress"
     Source: "modifier saleInProgress {\r\n        require(block.number >= startBlock && block.number < endBlock);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(block.number >= startBlock && block.number < endBlock);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 467
         Source: "require(block.number >= startBlock && block.number < endBlock)"
        FunctionCall
           Type: tuple()
           Source: "require(block.number >= startBlock && block.number < endBlock)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "block.number >= startBlock && block.number < endBlock"
            BinaryOperation using operator >=
               Type: bool
               Source: "block.number >= startBlock"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              Identifier startBlock
                 Type: uint256
                 Source: "startBlock"
            BinaryOperation using operator <
               Type: bool
               Source: "block.number < endBlock"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              Identifier endBlock
                 Type: uint256
                 Source: "endBlock"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "setupComplete"
     Source: "modifier setupComplete {\r\n        assert(setupCompleteFlag);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        assert(setupCompleteFlag);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 518
         Source: "assert(setupCompleteFlag)"
        FunctionCall
           Type: tuple()
           Source: "assert(setupCompleteFlag)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          Identifier setupCompleteFlag
             Type: bool
             Source: "setupCompleteFlag"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "notInEmergency"
     Source: "modifier notInEmergency {\r\n        assert(emergencyFlag == false);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        assert(emergencyFlag == false);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 327
         Source: "assert(emergencyFlag == false)"
        FunctionCall
           Type: tuple()
           Source: "assert(emergencyFlag == false)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "emergencyFlag == false"
            Identifier emergencyFlag
               Type: bool
               Source: "emergencyFlag"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "checkBlockNumberInputs"
     Source: "modifier checkBlockNumberInputs(uint _freeze, uint _start, uint _end) {\r\n        require(_freeze >= block.number\r\n        && _start >= _freeze\r\n        && _end >= _start);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _freeze, uint _start, uint _end)"
      VariableDeclaration "_freeze"
         Type: uint256
         Source: "uint _freeze"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_start"
         Type: uint256
         Source: "uint _start"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_end"
         Type: uint256
         Source: "uint _end"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(_freeze >= block.number\r\n        && _start >= _freeze\r\n        && _end >= _start);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_freeze >= block.number\r\n        && _start >= _freeze\r\n        && _end >= _start)"
        FunctionCall
           Type: tuple()
           Source: "require(_freeze >= block.number\r\n        && _start >= _freeze\r\n        && _end >= _start)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_freeze >= block.number\r\n        && _start >= _freeze\r\n        && _end >= _start"
            BinaryOperation using operator &&
               Type: bool
               Source: "_freeze >= block.number\r\n        && _start >= _freeze"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "_freeze >= block.number"
                Identifier _freeze
                   Type: uint256
                   Source: "_freeze"
                MemberAccess to member number
                   Type: uint256
                   Source: "block.number"
                  Identifier block
                     Type: block
                     Source: "block"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "_start >= _freeze"
                Identifier _start
                   Type: uint256
                   Source: "_start"
                Identifier _freeze
                   Type: uint256
                   Source: "_freeze"
            BinaryOperation using operator >=
               Type: bool
               Source: "_end >= _start"
              Identifier _end
                 Type: uint256
                 Source: "_end"
              Identifier _start
                 Type: uint256
                 Source: "_start"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "validPrice"
     Source: "modifier validPrice(uint _price){\r\n        require(_price > 0);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _price)"
      VariableDeclaration "_price"
         Type: uint256
         Source: "uint _price"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(_price > 0);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 35
         Source: "require(_price > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_price > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "_price > 0"
            Identifier _price
               Type: uint256
               Source: "_price"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
