Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x5b5d8a8a732a3c73ff0fb6980880ef399ecaf72e.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.0;"
ContractDefinition "owned"
   Source: "contract owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function owned() payable {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _owner) onlyOwner public {\r\n        require(_owner != 0);\r\n        newOwner = _owner;\r\n    }\r\n    \r\n    function confirmOwner() public {\r\n        require(newOwner == msg.sender);\r\n        owner = newOwner;\r\n        delete newOwner;\r\n    }\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "newOwner"
     Type: address
     Gas costs: [???]
     Source: "address public newOwner"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "owned" - public
     Source: "function owned() payable {\r\n        owner = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(owner == msg.sender);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 3102
         Source: "require(owner == msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "require(owner == msg.sender)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "owner == msg.sender"
            Identifier owner
               Type: address
               Source: "owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "changeOwner" - public
     Source: "function changeOwner(address _owner) onlyOwner public {\r\n        require(_owner != 0);\r\n        newOwner = _owner;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_owner != 0);\r\n        newOwner = _owner;\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "require(_owner != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_owner != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_owner != 0"
            Identifier _owner
               Type: address
               Source: "_owner"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "newOwner = _owner"
        Assignment using operator =
           Type: address
           Source: "newOwner = _owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "confirmOwner" - public
     Source: "function confirmOwner() public {\r\n        require(newOwner == msg.sender);\r\n        owner = newOwner;\r\n        delete newOwner;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(newOwner == msg.sender);\r\n        owner = newOwner;\r\n        delete newOwner;\r\n    }"
      ExpressionStatement
         Gas costs: 282
         Source: "require(newOwner == msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "require(newOwner == msg.sender)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "newOwner == msg.sender"
            Identifier newOwner
               Type: address
               Source: "newOwner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 20503
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
      ExpressionStatement
         Gas costs: 20242
         Source: "delete newOwner"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete newOwner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
ContractDefinition "ERC20"
   Gas costs: [???]
   Source: "contract ERC20 {\r\n    uint public totalSupply;\r\n    function balanceOf(address who) constant returns (uint);\r\n    function transfer(address to, uint value);\r\n    function allowance(address owner, address spender) constant returns (uint);\r\n    function transferFrom(address from, address to, uint value);\r\n    function approve(address spender, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint public totalSupply"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) constant returns (uint);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint value);"
    ParameterList
       Source: "(address to, uint value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) constant returns (uint);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint value);"
    ParameterList
       Source: "(address from, address to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint value);"
    ParameterList
       Source: "(address spender, uint value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "ManualMigration"
   Source: "contract ManualMigration is owned, ERC20 {\r\n    mapping (address => uint) internal balances;\r\n    address public migrationHost;\r\n\r\n    function ManualMigration(address _migrationHost) payable owned() {\r\n        migrationHost = _migrationHost;\r\n        //balances[this] = ERC20(migrationHost).balanceOf(migrationHost);\r\n    }\r\n\r\n    function migrateManual(address _tokensHolder) onlyOwner {\r\n        require(migrationHost != 0);\r\n        uint tokens = ERC20(migrationHost).balanceOf(_tokensHolder);\r\n        tokens = tokens * 125 / 100;\r\n        balances[_tokensHolder] = tokens;\r\n        totalSupply += tokens;\r\n        Transfer(migrationHost, _tokensHolder, tokens);\r\n    }\r\n    \r\n    function sealManualMigration() onlyOwner {\r\n        delete migrationHost;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "owned"
    UserDefinedTypeName "owned"
       Source: "owned"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint) internal balances"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "migrationHost"
     Type: address
     Gas costs: [???]
     Source: "address public migrationHost"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "ManualMigration" - public
     Source: "function ManualMigration(address _migrationHost) payable owned() {\r\n        migrationHost = _migrationHost;\r\n        //balances[this] = ERC20(migrationHost).balanceOf(migrationHost);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _migrationHost)"
      VariableDeclaration "_migrationHost"
         Type: address
         Source: "address _migrationHost"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "owned"
       Gas costs: 0
       Source: "owned()"
      Identifier owned
         Type: type(contract owned)
         Source: "owned"
    Block
       Source: "{\r\n        migrationHost = _migrationHost;\r\n        //balances[this] = ERC20(migrationHost).balanceOf(migrationHost);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "migrationHost = _migrationHost"
        Assignment using operator =
           Type: address
           Source: "migrationHost = _migrationHost"
          Identifier migrationHost
             Type: address
             Source: "migrationHost"
          Identifier _migrationHost
             Type: address
             Source: "_migrationHost"
  FunctionDefinition "migrateManual" - public
     Source: "function migrateManual(address _tokensHolder) onlyOwner {\r\n        require(migrationHost != 0);\r\n        uint tokens = ERC20(migrationHost).balanceOf(_tokensHolder);\r\n        tokens = tokens * 125 / 100;\r\n        balances[_tokensHolder] = tokens;\r\n        totalSupply += tokens;\r\n        Transfer(migrationHost, _tokensHolder, tokens);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _tokensHolder)"
      VariableDeclaration "_tokensHolder"
         Type: address
         Source: "address _tokensHolder"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(migrationHost != 0);\r\n        uint tokens = ERC20(migrationHost).balanceOf(_tokensHolder);\r\n        tokens = tokens * 125 / 100;\r\n        balances[_tokensHolder] = tokens;\r\n        totalSupply += tokens;\r\n        Transfer(migrationHost, _tokensHolder, tokens);\r\n    }"
      ExpressionStatement
         Gas costs: 280
         Source: "require(migrationHost != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(migrationHost != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "migrationHost != 0"
            Identifier migrationHost
               Type: address
               Source: "migrationHost"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint tokens = ERC20(migrationHost).balanceOf(_tokensHolder)"
        VariableDeclaration "tokens"
           Type: uint256
           Source: "uint tokens"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "ERC20(migrationHost).balanceOf(_tokensHolder)"
          MemberAccess to member balanceOf
             Type: function (address) view external returns (uint256)
             Source: "ERC20(migrationHost).balanceOf"
            FunctionCall
               Type: contract ERC20
               Source: "ERC20(migrationHost)"
              Identifier ERC20
                 Type: type(contract ERC20)
                 Source: "ERC20"
              Identifier migrationHost
                 Type: address
                 Source: "migrationHost"
          Identifier _tokensHolder
             Type: address
             Source: "_tokensHolder"
      ExpressionStatement
         Gas costs: 47
         Source: "tokens = tokens * 125 / 100"
        Assignment using operator =
           Type: uint256
           Source: "tokens = tokens * 125 / 100"
          Identifier tokens
             Type: uint256
             Source: "tokens"
          BinaryOperation using operator /
             Type: uint256
             Source: "tokens * 125 / 100"
            BinaryOperation using operator *
               Type: uint256
               Source: "tokens * 125"
              Identifier tokens
                 Type: uint256
                 Source: "tokens"
              Literal, token: [no token] value: 125
                 Type: int_const 125
                 Source: "125"
            Literal, token: [no token] value: 100
               Type: int_const 100
               Source: "100"
      ExpressionStatement
         Gas costs: 20110
         Source: "balances[_tokensHolder] = tokens"
        Assignment using operator =
           Type: uint256
           Source: "balances[_tokensHolder] = tokens"
          IndexAccess
             Type: uint256
             Source: "balances[_tokensHolder]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _tokensHolder
               Type: address
               Source: "_tokensHolder"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply += tokens"
        Assignment using operator +=
           Type: uint256
           Source: "totalSupply += tokens"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(migrationHost, _tokensHolder, tokens)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(migrationHost, _tokensHolder, tokens)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier migrationHost
             Type: address
             Source: "migrationHost"
          Identifier _tokensHolder
             Type: address
             Source: "_tokensHolder"
          Identifier tokens
             Type: uint256
             Source: "tokens"
  FunctionDefinition "sealManualMigration" - public
     Source: "function sealManualMigration() onlyOwner {\r\n        delete migrationHost;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        delete migrationHost;\r\n    }"
      ExpressionStatement
         Gas costs: 20242
         Source: "delete migrationHost"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete migrationHost"
          Identifier migrationHost
             Type: address
             Source: "migrationHost"
ContractDefinition "Crowdsale"
   Source: "contract Crowdsale is ManualMigration {\r\n    uint    public etherPrice;\r\n    address public crowdsaleOwner;\r\n    uint    public totalLimitUSD;\r\n    uint    public minimalSuccessUSD;\r\n    uint    public collectedUSD;\r\n\r\n    enum State { Disabled, PreICO, CompletePreICO, Crowdsale, Enabled, Migration }\r\n    event NewState(State state);\r\n    State   public state = State.Disabled;\r\n    uint    public crowdsaleStartTime;\r\n    uint    public crowdsaleFinishTime;\r\n\r\n    modifier enabledState {\r\n        require(state == State.Enabled);\r\n        _;\r\n    }\r\n\r\n    modifier enabledOrMigrationState {\r\n        require(state == State.Enabled || state == State.Migration);\r\n        _;\r\n    }\r\n\r\n    struct Investor {\r\n        uint amountTokens;\r\n        uint amountWei;\r\n    }\r\n    mapping (address => Investor) public investors;\r\n    mapping (uint => address)     public investorsIter;\r\n    uint                          public numberOfInvestors;\r\n\r\n    function Crowdsale(address _migrationHost)\r\n        payable ManualMigration(_migrationHost) {\r\n    }\r\n    \r\n    function () payable {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        require(now < crowdsaleFinishTime);\r\n        uint valueWei = msg.value;\r\n        uint valueUSD = valueWei * etherPrice / 1000000000000000000;\r\n        if (collectedUSD + valueUSD > totalLimitUSD) { // don't need so much ether\r\n            valueUSD = totalLimitUSD - collectedUSD;\r\n            valueWei = valueUSD * 1000000000000000000 / etherPrice;\r\n            require(msg.sender.call.gas(3000000).value(msg.value - valueWei)());\r\n            collectedUSD = totalLimitUSD; // to be sure!\r\n        } else {\r\n            collectedUSD += valueUSD;\r\n        }\r\n        mintTokens(msg.sender, valueUSD, valueWei);\r\n    }\r\n\r\n    function depositUSD(address _who, uint _valueUSD) public onlyOwner {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        require(now < crowdsaleFinishTime);\r\n        require(collectedUSD + _valueUSD <= totalLimitUSD);\r\n        collectedUSD += _valueUSD;\r\n        mintTokens(_who, _valueUSD, 0);\r\n    }\r\n\r\n    function mintTokens(address _who, uint _valueUSD, uint _valueWei) internal {\r\n        uint tokensPerUSD = 100;\r\n        if (state == State.PreICO) {\r\n            if (now < crowdsaleStartTime + 1 days && _valueUSD >= 50000) {\r\n                tokensPerUSD = 150;\r\n            } else {\r\n                tokensPerUSD = 125;\r\n            }\r\n        } else if (state == State.Crowdsale) {\r\n            if (now < crowdsaleStartTime + 1 days) {\r\n                tokensPerUSD = 115;\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokensPerUSD = 110;\r\n            }\r\n        }\r\n        uint tokens = tokensPerUSD * _valueUSD;\r\n        require(balances[_who] + tokens > balances[_who]); // overflow\r\n        require(tokens > 0);\r\n        Investor storage inv = investors[_who];\r\n        if (inv.amountTokens == 0) { // new investor\r\n            investorsIter[numberOfInvestors++] = _who;\r\n        }\r\n        inv.amountTokens += tokens;\r\n        inv.amountWei += _valueWei;\r\n        balances[_who] += tokens;\r\n        Transfer(this, _who, tokens);\r\n        totalSupply += tokens;\r\n    }\r\n    \r\n    function startTokensSale(\r\n            address _crowdsaleOwner,\r\n            uint    _crowdsaleDurationDays,\r\n            uint    _totalLimitUSD,\r\n            uint    _minimalSuccessUSD,\r\n            uint    _etherPrice) public onlyOwner {\r\n        require(state == State.Disabled || state == State.CompletePreICO);\r\n        crowdsaleStartTime = now;\r\n        crowdsaleOwner = _crowdsaleOwner;\r\n        etherPrice = _etherPrice;\r\n        delete numberOfInvestors;\r\n        delete collectedUSD;\r\n        crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days;\r\n        totalLimitUSD = _totalLimitUSD;\r\n        minimalSuccessUSD = _minimalSuccessUSD;\r\n        if (state == State.Disabled) {\r\n            state = State.PreICO;\r\n        } else {\r\n            state = State.Crowdsale;\r\n        }\r\n        NewState(state);\r\n    }\r\n    \r\n    function timeToFinishTokensSale() public constant returns(uint t) {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        if (now > crowdsaleFinishTime) {\r\n            t = 0;\r\n        } else {\r\n            t = crowdsaleFinishTime - now;\r\n        }\r\n    }\r\n    \r\n    function finishTokensSale(uint _investorsToProcess) public {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        require(now >= crowdsaleFinishTime || collectedUSD == totalLimitUSD ||\r\n            (collectedUSD >= minimalSuccessUSD && msg.sender == owner));\r\n        if (collectedUSD < minimalSuccessUSD) {\r\n            // Investors can get their ether calling withdrawBack() function\r\n            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n                address addr = investorsIter[--numberOfInvestors];\r\n                Investor memory inv = investors[addr];\r\n                balances[addr] -= inv.amountTokens;\r\n                totalSupply -= inv.amountTokens;\r\n                Transfer(addr, this, inv.amountTokens);\r\n                --_investorsToProcess;\r\n                delete investorsIter[numberOfInvestors];\r\n            }\r\n            if (numberOfInvestors > 0) {\r\n                return;\r\n            }\r\n            if (state == State.PreICO) {\r\n                state = State.Disabled;\r\n            } else {\r\n                state = State.CompletePreICO;\r\n            }\r\n        } else {\r\n            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n                --numberOfInvestors;\r\n                --_investorsToProcess;\r\n                delete investors[investorsIter[numberOfInvestors]];\r\n                delete investorsIter[numberOfInvestors];\r\n            }\r\n            if (numberOfInvestors > 0) {\r\n                return;\r\n            }\r\n            if (state == State.PreICO) {\r\n                require(crowdsaleOwner.call.gas(3000000).value(this.balance)());\r\n                state = State.CompletePreICO;\r\n            } else {\r\n                require(crowdsaleOwner.call.gas(3000000).value(minimalSuccessUSD * 1000000000000000000 / etherPrice)());\r\n                // Create additional tokens for owner (30% of complete totalSupply)\r\n                uint tokens = 3 * totalSupply / 7;\r\n                balances[owner] = tokens;\r\n                totalSupply += tokens;\r\n                Transfer(this, owner, tokens);\r\n                state = State.Enabled;\r\n            }\r\n        }\r\n        NewState(state);\r\n    }\r\n    \r\n    // This function must be called by token holder in case of crowdsale failed\r\n    function withdrawBack() public {\r\n        require(state == State.Disabled || state == State.CompletePreICO);\r\n        uint value = investors[msg.sender].amountWei;\r\n        if (value > 0) {\r\n            delete investors[msg.sender];\r\n            require(msg.sender.call.gas(3000000).value(value)());\r\n        }\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ManualMigration"
    UserDefinedTypeName "ManualMigration"
       Source: "ManualMigration"
  VariableDeclaration "etherPrice"
     Type: uint256
     Gas costs: [???]
     Source: "uint    public etherPrice"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "crowdsaleOwner"
     Type: address
     Gas costs: [???]
     Source: "address public crowdsaleOwner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "totalLimitUSD"
     Type: uint256
     Gas costs: [???]
     Source: "uint    public totalLimitUSD"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "minimalSuccessUSD"
     Type: uint256
     Gas costs: [???]
     Source: "uint    public minimalSuccessUSD"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "collectedUSD"
     Type: uint256
     Gas costs: [???]
     Source: "uint    public collectedUSD"
    ElementaryTypeName uint
       Source: "uint"
  EnumDefinition "State"
    EnumValue "Disabled"
    EnumValue "PreICO"
    EnumValue "CompletePreICO"
    EnumValue "Crowdsale"
    EnumValue "Enabled"
    EnumValue "Migration"
  EventDefinition "NewState"
     Gas costs: 0
     Source: "event NewState(State state);"
    ParameterList
       Source: "(State state)"
      VariableDeclaration "state"
         Type: enum Crowdsale.State
         Source: "State state"
        UserDefinedTypeName "State"
           Source: "State"
  VariableDeclaration "state"
     Type: enum Crowdsale.State
     Gas costs: [???]
     Source: "State   public state = State.Disabled"
    UserDefinedTypeName "State"
       Source: "State"
    MemberAccess to member Disabled
       Type: enum Crowdsale.State
       Source: "State.Disabled"
      Identifier State
         Type: type(enum Crowdsale.State)
         Source: "State"
  VariableDeclaration "crowdsaleStartTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint    public crowdsaleStartTime"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "crowdsaleFinishTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint    public crowdsaleFinishTime"
    ElementaryTypeName uint
       Source: "uint"
  ModifierDefinition "enabledState"
     Source: "modifier enabledState {\r\n        require(state == State.Enabled);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(state == State.Enabled);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 1292
         Source: "require(state == State.Enabled)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.Enabled)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "state == State.Enabled"
            Identifier state
               Type: enum Crowdsale.State
               Source: "state"
            MemberAccess to member Enabled
               Type: enum Crowdsale.State
               Source: "State.Enabled"
              Identifier State
                 Type: type(enum Crowdsale.State)
                 Source: "State"
      PlaceholderStatement
         Gas costs: 4
         Source: "_"
  ModifierDefinition "enabledOrMigrationState"
     Source: "modifier enabledOrMigrationState {\r\n        require(state == State.Enabled || state == State.Migration);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(state == State.Enabled || state == State.Migration);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 639
         Source: "require(state == State.Enabled || state == State.Migration)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.Enabled || state == State.Migration)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "state == State.Enabled || state == State.Migration"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.Enabled"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member Enabled
                 Type: enum Crowdsale.State
                 Source: "State.Enabled"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.Migration"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member Migration
                 Type: enum Crowdsale.State
                 Source: "State.Migration"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  StructDefinition "Investor"
     Gas costs: 0
     Source: "struct Investor {\r\n        uint amountTokens;\r\n        uint amountWei;\r\n    }"
    VariableDeclaration "amountTokens"
       Type: uint256
       Source: "uint amountTokens"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "amountWei"
       Type: uint256
       Source: "uint amountWei"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "investors"
     Type: mapping(address => struct Crowdsale.Investor storage ref)
     Gas costs: [???]
     Source: "mapping (address => Investor) public investors"
    Mapping
       Source: "mapping (address => Investor)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "Investor"
         Source: "Investor"
  VariableDeclaration "investorsIter"
     Type: mapping(uint256 => address)
     Gas costs: [???]
     Source: "mapping (uint => address)     public investorsIter"
    Mapping
       Source: "mapping (uint => address)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "numberOfInvestors"
     Type: uint256
     Gas costs: [???]
     Source: "uint                          public numberOfInvestors"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "Crowdsale" - public
     Source: "function Crowdsale(address _migrationHost)\r\n        payable ManualMigration(_migrationHost) {\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _migrationHost)"
      VariableDeclaration "_migrationHost"
         Type: address
         Source: "address _migrationHost"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ManualMigration"
       Gas costs: 0
       Source: "ManualMigration(_migrationHost)"
      Identifier ManualMigration
         Type: type(contract ManualMigration)
         Source: "ManualMigration"
      Identifier _migrationHost
         Type: address
         Source: "_migrationHost"
    Block
       Gas costs: 0
       Source: "{\r\n    }"
  FunctionDefinition "" - public
     Source: "function () payable {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        require(now < crowdsaleFinishTime);\r\n        uint valueWei = msg.value;\r\n        uint valueUSD = valueWei * etherPrice / 1000000000000000000;\r\n        if (collectedUSD + valueUSD > totalLimitUSD) { // don't need so much ether\r\n            valueUSD = totalLimitUSD - collectedUSD;\r\n            valueWei = valueUSD * 1000000000000000000 / etherPrice;\r\n            require(msg.sender.call.gas(3000000).value(msg.value - valueWei)());\r\n            collectedUSD = totalLimitUSD; // to be sure!\r\n        } else {\r\n            collectedUSD += valueUSD;\r\n        }\r\n        mintTokens(msg.sender, valueUSD, valueWei);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        require(now < crowdsaleFinishTime);\r\n        uint valueWei = msg.value;\r\n        uint valueUSD = valueWei * etherPrice / 1000000000000000000;\r\n        if (collectedUSD + valueUSD > totalLimitUSD) { // don't need so much ether\r\n            valueUSD = totalLimitUSD - collectedUSD;\r\n            valueWei = valueUSD * 1000000000000000000 / etherPrice;\r\n            require(msg.sender.call.gas(3000000).value(msg.value - valueWei)());\r\n            collectedUSD = totalLimitUSD; // to be sure!\r\n        } else {\r\n            collectedUSD += valueUSD;\r\n        }\r\n        mintTokens(msg.sender, valueUSD, valueWei);\r\n    }"
      ExpressionStatement
         Gas costs: 639
         Source: "require(state == State.PreICO || state == State.Crowdsale)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.PreICO || state == State.Crowdsale)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "state == State.PreICO || state == State.Crowdsale"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.PreICO"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member PreICO
                 Type: enum Crowdsale.State
                 Source: "State.PreICO"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.Crowdsale"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member Crowdsale
                 Type: enum Crowdsale.State
                 Source: "State.Crowdsale"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
      ExpressionStatement
         Gas costs: 234
         Source: "require(now < crowdsaleFinishTime)"
        FunctionCall
           Type: tuple()
           Source: "require(now < crowdsaleFinishTime)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "now < crowdsaleFinishTime"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier crowdsaleFinishTime
               Type: uint256
               Source: "crowdsaleFinishTime"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint valueWei = msg.value"
        VariableDeclaration "valueWei"
           Type: uint256
           Source: "uint valueWei"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member value
           Type: uint256
           Source: "msg.value"
          Identifier msg
             Type: msg
             Source: "msg"
      VariableDeclarationStatement
         Gas costs: 250
         Source: "uint valueUSD = valueWei * etherPrice / 1000000000000000000"
        VariableDeclaration "valueUSD"
           Type: uint256
           Source: "uint valueUSD"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "valueWei * etherPrice / 1000000000000000000"
          BinaryOperation using operator *
             Type: uint256
             Source: "valueWei * etherPrice"
            Identifier valueWei
               Type: uint256
               Source: "valueWei"
            Identifier etherPrice
               Type: uint256
               Source: "etherPrice"
          Literal, token: [no token] value: 1000000000000000000
             Type: int_const 1000000000000000000
             Source: "1000000000000000000"
      IfStatement
         Source: "if (collectedUSD + valueUSD > totalLimitUSD) { // don't need so much ether\r\n            valueUSD = totalLimitUSD - collectedUSD;\r\n            valueWei = valueUSD * 1000000000000000000 / etherPrice;\r\n            require(msg.sender.call.gas(3000000).value(msg.value - valueWei)());\r\n            collectedUSD = totalLimitUSD; // to be sure!\r\n        } else {\r\n            collectedUSD += valueUSD;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 415
           Source: "collectedUSD + valueUSD > totalLimitUSD"
          BinaryOperation using operator +
             Type: uint256
             Source: "collectedUSD + valueUSD"
            Identifier collectedUSD
               Type: uint256
               Source: "collectedUSD"
            Identifier valueUSD
               Type: uint256
               Source: "valueUSD"
          Identifier totalLimitUSD
             Type: uint256
             Source: "totalLimitUSD"
        Block
           Source: "{ // don't need so much ether\r\n            valueUSD = totalLimitUSD - collectedUSD;\r\n            valueWei = valueUSD * 1000000000000000000 / etherPrice;\r\n            require(msg.sender.call.gas(3000000).value(msg.value - valueWei)());\r\n            collectedUSD = totalLimitUSD; // to be sure!\r\n        }"
          ExpressionStatement
             Gas costs: 414
             Source: "valueUSD = totalLimitUSD - collectedUSD"
            Assignment using operator =
               Type: uint256
               Source: "valueUSD = totalLimitUSD - collectedUSD"
              Identifier valueUSD
                 Type: uint256
                 Source: "valueUSD"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "totalLimitUSD - collectedUSD"
                Identifier totalLimitUSD
                   Type: uint256
                   Source: "totalLimitUSD"
                Identifier collectedUSD
                   Type: uint256
                   Source: "collectedUSD"
          ExpressionStatement
             Gas costs: 247
             Source: "valueWei = valueUSD * 1000000000000000000 / etherPrice"
            Assignment using operator =
               Type: uint256
               Source: "valueWei = valueUSD * 1000000000000000000 / etherPrice"
              Identifier valueWei
                 Type: uint256
                 Source: "valueWei"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "valueUSD * 1000000000000000000 / etherPrice"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "valueUSD * 1000000000000000000"
                  Identifier valueUSD
                     Type: uint256
                     Source: "valueUSD"
                  Literal, token: [no token] value: 1000000000000000000
                     Type: int_const 1000000000000000000
                     Source: "1000000000000000000"
                Identifier etherPrice
                   Type: uint256
                   Source: "etherPrice"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(msg.sender.call.gas(3000000).value(msg.value - valueWei)())"
            FunctionCall
               Type: tuple()
               Source: "require(msg.sender.call.gas(3000000).value(msg.value - valueWei)())"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "msg.sender.call.gas(3000000).value(msg.value - valueWei)()"
                FunctionCall
                   Type: function () payable returns (bool)
                   Source: "msg.sender.call.gas(3000000).value(msg.value - valueWei)"
                  MemberAccess to member value
                     Type: function (uint256) returns (function () payable returns (bool))
                     Source: "msg.sender.call.gas(3000000).value"
                    FunctionCall
                       Type: function () payable returns (bool)
                       Source: "msg.sender.call.gas(3000000)"
                      MemberAccess to member gas
                         Type: function (uint256) returns (function () payable returns (bool))
                         Source: "msg.sender.call.gas"
                        MemberAccess to member call
                           Type: function () payable returns (bool)
                           Source: "msg.sender.call"
                          MemberAccess to member sender
                             Type: address
                             Source: "msg.sender"
                            Identifier msg
                               Type: msg
                               Source: "msg"
                      Literal, token: [no token] value: 3000000
                         Type: int_const 3000000
                         Source: "3000000"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "msg.value - valueWei"
                    MemberAccess to member value
                       Type: uint256
                       Source: "msg.value"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                    Identifier valueWei
                       Type: uint256
                       Source: "valueWei"
          ExpressionStatement
             Gas costs: 20214
             Source: "collectedUSD = totalLimitUSD"
            Assignment using operator =
               Type: uint256
               Source: "collectedUSD = totalLimitUSD"
              Identifier collectedUSD
                 Type: uint256
                 Source: "collectedUSD"
              Identifier totalLimitUSD
                 Type: uint256
                 Source: "totalLimitUSD"
        Block
           Source: "{\r\n            collectedUSD += valueUSD;\r\n        }"
          ExpressionStatement
             Gas costs: 20233
             Source: "collectedUSD += valueUSD"
            Assignment using operator +=
               Type: uint256
               Source: "collectedUSD += valueUSD"
              Identifier collectedUSD
                 Type: uint256
                 Source: "collectedUSD"
              Identifier valueUSD
                 Type: uint256
                 Source: "valueUSD"
      ExpressionStatement
         Gas costs: 12
         Source: "mintTokens(msg.sender, valueUSD, valueWei)"
        FunctionCall
           Type: tuple()
           Source: "mintTokens(msg.sender, valueUSD, valueWei)"
          Identifier mintTokens
             Type: function (address,uint256,uint256)
             Source: "mintTokens"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier valueUSD
             Type: uint256
             Source: "valueUSD"
          Identifier valueWei
             Type: uint256
             Source: "valueWei"
  FunctionDefinition "depositUSD" - public
     Source: "function depositUSD(address _who, uint _valueUSD) public onlyOwner {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        require(now < crowdsaleFinishTime);\r\n        require(collectedUSD + _valueUSD <= totalLimitUSD);\r\n        collectedUSD += _valueUSD;\r\n        mintTokens(_who, _valueUSD, 0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _who, uint _valueUSD)"
      VariableDeclaration "_who"
         Type: address
         Source: "address _who"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_valueUSD"
         Type: uint256
         Source: "uint _valueUSD"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        require(now < crowdsaleFinishTime);\r\n        require(collectedUSD + _valueUSD <= totalLimitUSD);\r\n        collectedUSD += _valueUSD;\r\n        mintTokens(_who, _valueUSD, 0);\r\n    }"
      ExpressionStatement
         Gas costs: 639
         Source: "require(state == State.PreICO || state == State.Crowdsale)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.PreICO || state == State.Crowdsale)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "state == State.PreICO || state == State.Crowdsale"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.PreICO"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member PreICO
                 Type: enum Crowdsale.State
                 Source: "State.PreICO"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.Crowdsale"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member Crowdsale
                 Type: enum Crowdsale.State
                 Source: "State.Crowdsale"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
      ExpressionStatement
         Gas costs: 234
         Source: "require(now < crowdsaleFinishTime)"
        FunctionCall
           Type: tuple()
           Source: "require(now < crowdsaleFinishTime)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "now < crowdsaleFinishTime"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier crowdsaleFinishTime
               Type: uint256
               Source: "crowdsaleFinishTime"
      ExpressionStatement
         Gas costs: 444
         Source: "require(collectedUSD + _valueUSD <= totalLimitUSD)"
        FunctionCall
           Type: tuple()
           Source: "require(collectedUSD + _valueUSD <= totalLimitUSD)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "collectedUSD + _valueUSD <= totalLimitUSD"
            BinaryOperation using operator +
               Type: uint256
               Source: "collectedUSD + _valueUSD"
              Identifier collectedUSD
                 Type: uint256
                 Source: "collectedUSD"
              Identifier _valueUSD
                 Type: uint256
                 Source: "_valueUSD"
            Identifier totalLimitUSD
               Type: uint256
               Source: "totalLimitUSD"
      ExpressionStatement
         Gas costs: 20233
         Source: "collectedUSD += _valueUSD"
        Assignment using operator +=
           Type: uint256
           Source: "collectedUSD += _valueUSD"
          Identifier collectedUSD
             Type: uint256
             Source: "collectedUSD"
          Identifier _valueUSD
             Type: uint256
             Source: "_valueUSD"
      ExpressionStatement
         Gas costs: 24
         Source: "mintTokens(_who, _valueUSD, 0)"
        FunctionCall
           Type: tuple()
           Source: "mintTokens(_who, _valueUSD, 0)"
          Identifier mintTokens
             Type: function (address,uint256,uint256)
             Source: "mintTokens"
          Identifier _who
             Type: address
             Source: "_who"
          Identifier _valueUSD
             Type: uint256
             Source: "_valueUSD"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "mintTokens"
     Source: "function mintTokens(address _who, uint _valueUSD, uint _valueWei) internal {\r\n        uint tokensPerUSD = 100;\r\n        if (state == State.PreICO) {\r\n            if (now < crowdsaleStartTime + 1 days && _valueUSD >= 50000) {\r\n                tokensPerUSD = 150;\r\n            } else {\r\n                tokensPerUSD = 125;\r\n            }\r\n        } else if (state == State.Crowdsale) {\r\n            if (now < crowdsaleStartTime + 1 days) {\r\n                tokensPerUSD = 115;\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokensPerUSD = 110;\r\n            }\r\n        }\r\n        uint tokens = tokensPerUSD * _valueUSD;\r\n        require(balances[_who] + tokens > balances[_who]); // overflow\r\n        require(tokens > 0);\r\n        Investor storage inv = investors[_who];\r\n        if (inv.amountTokens == 0) { // new investor\r\n            investorsIter[numberOfInvestors++] = _who;\r\n        }\r\n        inv.amountTokens += tokens;\r\n        inv.amountWei += _valueWei;\r\n        balances[_who] += tokens;\r\n        Transfer(this, _who, tokens);\r\n        totalSupply += tokens;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _who, uint _valueUSD, uint _valueWei)"
      VariableDeclaration "_who"
         Type: address
         Source: "address _who"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_valueUSD"
         Type: uint256
         Source: "uint _valueUSD"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_valueWei"
         Type: uint256
         Source: "uint _valueWei"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint tokensPerUSD = 100;\r\n        if (state == State.PreICO) {\r\n            if (now < crowdsaleStartTime + 1 days && _valueUSD >= 50000) {\r\n                tokensPerUSD = 150;\r\n            } else {\r\n                tokensPerUSD = 125;\r\n            }\r\n        } else if (state == State.Crowdsale) {\r\n            if (now < crowdsaleStartTime + 1 days) {\r\n                tokensPerUSD = 115;\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokensPerUSD = 110;\r\n            }\r\n        }\r\n        uint tokens = tokensPerUSD * _valueUSD;\r\n        require(balances[_who] + tokens > balances[_who]); // overflow\r\n        require(tokens > 0);\r\n        Investor storage inv = investors[_who];\r\n        if (inv.amountTokens == 0) { // new investor\r\n            investorsIter[numberOfInvestors++] = _who;\r\n        }\r\n        inv.amountTokens += tokens;\r\n        inv.amountWei += _valueWei;\r\n        balances[_who] += tokens;\r\n        Transfer(this, _who, tokens);\r\n        totalSupply += tokens;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint tokensPerUSD = 100"
        VariableDeclaration "tokensPerUSD"
           Type: uint256
           Source: "uint tokensPerUSD"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 100
           Type: int_const 100
           Source: "100"
      IfStatement
         Source: "if (state == State.PreICO) {\r\n            if (now < crowdsaleStartTime + 1 days && _valueUSD >= 50000) {\r\n                tokensPerUSD = 150;\r\n            } else {\r\n                tokensPerUSD = 125;\r\n            }\r\n        } else if (state == State.Crowdsale) {\r\n            if (now < crowdsaleStartTime + 1 days) {\r\n                tokensPerUSD = 115;\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokensPerUSD = 110;\r\n            }\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 297
           Source: "state == State.PreICO"
          Identifier state
             Type: enum Crowdsale.State
             Source: "state"
          MemberAccess to member PreICO
             Type: enum Crowdsale.State
             Source: "State.PreICO"
            Identifier State
               Type: type(enum Crowdsale.State)
               Source: "State"
        Block
           Source: "{\r\n            if (now < crowdsaleStartTime + 1 days && _valueUSD >= 50000) {\r\n                tokensPerUSD = 150;\r\n            } else {\r\n                tokensPerUSD = 125;\r\n            }\r\n        }"
          IfStatement
             Source: "if (now < crowdsaleStartTime + 1 days && _valueUSD >= 50000) {\r\n                tokensPerUSD = 150;\r\n            } else {\r\n                tokensPerUSD = 125;\r\n            }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 248
               Source: "now < crowdsaleStartTime + 1 days && _valueUSD >= 50000"
              BinaryOperation using operator <
                 Type: bool
                 Source: "now < crowdsaleStartTime + 1 days"
                Identifier now
                   Type: uint256
                   Source: "now"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "crowdsaleStartTime + 1 days"
                  Identifier crowdsaleStartTime
                     Type: uint256
                     Source: "crowdsaleStartTime"
                  Literal, token: [no token] value: 1
                     Type: int_const 86400
                     Source: "1 days"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "_valueUSD >= 50000"
                Identifier _valueUSD
                   Type: uint256
                   Source: "_valueUSD"
                Literal, token: [no token] value: 50000
                   Type: int_const 50000
                   Source: "50000"
            Block
               Source: "{\r\n                tokensPerUSD = 150;\r\n            }"
              ExpressionStatement
                 Gas costs: 8
                 Source: "tokensPerUSD = 150"
                Assignment using operator =
                   Type: uint256
                   Source: "tokensPerUSD = 150"
                  Identifier tokensPerUSD
                     Type: uint256
                     Source: "tokensPerUSD"
                  Literal, token: [no token] value: 150
                     Type: int_const 150
                     Source: "150"
            Block
               Source: "{\r\n                tokensPerUSD = 125;\r\n            }"
              ExpressionStatement
                 Gas costs: 8
                 Source: "tokensPerUSD = 125"
                Assignment using operator =
                   Type: uint256
                   Source: "tokensPerUSD = 125"
                  Identifier tokensPerUSD
                     Type: uint256
                     Source: "tokensPerUSD"
                  Literal, token: [no token] value: 125
                     Type: int_const 125
                     Source: "125"
        IfStatement
           Source: "if (state == State.Crowdsale) {\r\n            if (now < crowdsaleStartTime + 1 days) {\r\n                tokensPerUSD = 115;\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokensPerUSD = 110;\r\n            }\r\n        }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 297
             Source: "state == State.Crowdsale"
            Identifier state
               Type: enum Crowdsale.State
               Source: "state"
            MemberAccess to member Crowdsale
               Type: enum Crowdsale.State
               Source: "State.Crowdsale"
              Identifier State
                 Type: type(enum Crowdsale.State)
                 Source: "State"
          Block
             Source: "{\r\n            if (now < crowdsaleStartTime + 1 days) {\r\n                tokensPerUSD = 115;\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokensPerUSD = 110;\r\n            }\r\n        }"
            IfStatement
               Source: "if (now < crowdsaleStartTime + 1 days) {\r\n                tokensPerUSD = 115;\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokensPerUSD = 110;\r\n            }"
              BinaryOperation using operator <
                 Type: bool
                 Gas costs: 214
                 Source: "now < crowdsaleStartTime + 1 days"
                Identifier now
                   Type: uint256
                   Source: "now"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "crowdsaleStartTime + 1 days"
                  Identifier crowdsaleStartTime
                     Type: uint256
                     Source: "crowdsaleStartTime"
                  Literal, token: [no token] value: 1
                     Type: int_const 86400
                     Source: "1 days"
              Block
                 Source: "{\r\n                tokensPerUSD = 115;\r\n            }"
                ExpressionStatement
                   Gas costs: 8
                   Source: "tokensPerUSD = 115"
                  Assignment using operator =
                     Type: uint256
                     Source: "tokensPerUSD = 115"
                    Identifier tokensPerUSD
                       Type: uint256
                       Source: "tokensPerUSD"
                    Literal, token: [no token] value: 115
                       Type: int_const 115
                       Source: "115"
              IfStatement
                 Source: "if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokensPerUSD = 110;\r\n            }"
                BinaryOperation using operator <
                   Type: bool
                   Gas costs: 214
                   Source: "now < crowdsaleStartTime + 1 weeks"
                  Identifier now
                     Type: uint256
                     Source: "now"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "crowdsaleStartTime + 1 weeks"
                    Identifier crowdsaleStartTime
                       Type: uint256
                       Source: "crowdsaleStartTime"
                    Literal, token: [no token] value: 1
                       Type: int_const 604800
                       Source: "1 weeks"
                Block
                   Source: "{\r\n                tokensPerUSD = 110;\r\n            }"
                  ExpressionStatement
                     Gas costs: 8
                     Source: "tokensPerUSD = 110"
                    Assignment using operator =
                       Type: uint256
                       Source: "tokensPerUSD = 110"
                      Identifier tokensPerUSD
                         Type: uint256
                         Source: "tokensPerUSD"
                      Literal, token: [no token] value: 110
                         Type: int_const 110
                         Source: "110"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint tokens = tokensPerUSD * _valueUSD"
        VariableDeclaration "tokens"
           Type: uint256
           Source: "uint tokens"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "tokensPerUSD * _valueUSD"
          Identifier tokensPerUSD
             Type: uint256
             Source: "tokensPerUSD"
          Identifier _valueUSD
             Type: uint256
             Source: "_valueUSD"
      ExpressionStatement
         Gas costs: 627
         Source: "require(balances[_who] + tokens > balances[_who])"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_who] + tokens > balances[_who])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balances[_who] + tokens > balances[_who]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balances[_who] + tokens"
              IndexAccess
                 Type: uint256
                 Source: "balances[_who]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _who
                   Type: address
                   Source: "_who"
              Identifier tokens
                 Type: uint256
                 Source: "tokens"
            IndexAccess
               Type: uint256
               Source: "balances[_who]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _who
                 Type: address
                 Source: "_who"
      ExpressionStatement
         Gas costs: 35
         Source: "require(tokens > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(tokens > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "tokens > 0"
            Identifier tokens
               Type: uint256
               Source: "tokens"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 107
         Source: "Investor storage inv = investors[_who]"
        VariableDeclaration "inv"
           Type: struct Crowdsale.Investor storage pointer
           Source: "Investor storage inv"
          UserDefinedTypeName "Investor"
             Source: "Investor"
        IndexAccess
           Type: struct Crowdsale.Investor storage ref
           Source: "investors[_who]"
          Identifier investors
             Type: mapping(address => struct Crowdsale.Investor storage ref)
             Source: "investors"
          Identifier _who
             Type: address
             Source: "_who"
      IfStatement
         Source: "if (inv.amountTokens == 0) { // new investor\r\n            investorsIter[numberOfInvestors++] = _who;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 215
           Source: "inv.amountTokens == 0"
          MemberAccess to member amountTokens
             Type: uint256
             Source: "inv.amountTokens"
            Identifier inv
               Type: struct Crowdsale.Investor storage pointer
               Source: "inv"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{ // new investor\r\n            investorsIter[numberOfInvestors++] = _who;\r\n        }"
          ExpressionStatement
             Gas costs: 40583
             Source: "investorsIter[numberOfInvestors++] = _who"
            Assignment using operator =
               Type: address
               Source: "investorsIter[numberOfInvestors++] = _who"
              IndexAccess
                 Type: address
                 Source: "investorsIter[numberOfInvestors++]"
                Identifier investorsIter
                   Type: mapping(uint256 => address)
                   Source: "investorsIter"
                UnaryOperation (postfix) ++
                   Type: uint256
                   Source: "numberOfInvestors++"
                  Identifier numberOfInvestors
                     Type: uint256
                     Source: "numberOfInvestors"
              Identifier _who
                 Type: address
                 Source: "_who"
      ExpressionStatement
         Gas costs: 20239
         Source: "inv.amountTokens += tokens"
        Assignment using operator +=
           Type: uint256
           Source: "inv.amountTokens += tokens"
          MemberAccess to member amountTokens
             Type: uint256
             Source: "inv.amountTokens"
            Identifier inv
               Type: struct Crowdsale.Investor storage pointer
               Source: "inv"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: 20239
         Source: "inv.amountWei += _valueWei"
        Assignment using operator +=
           Type: uint256
           Source: "inv.amountWei += _valueWei"
          MemberAccess to member amountWei
             Type: uint256
             Source: "inv.amountWei"
            Identifier inv
               Type: struct Crowdsale.Investor storage pointer
               Source: "inv"
          Identifier _valueWei
             Type: uint256
             Source: "_valueWei"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[_who] += tokens"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_who] += tokens"
          IndexAccess
             Type: uint256
             Source: "balances[_who]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _who
               Type: address
               Source: "_who"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(this, _who, tokens)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(this, _who, tokens)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier this
             Type: contract Crowdsale
             Source: "this"
          Identifier _who
             Type: address
             Source: "_who"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply += tokens"
        Assignment using operator +=
           Type: uint256
           Source: "totalSupply += tokens"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier tokens
             Type: uint256
             Source: "tokens"
  FunctionDefinition "startTokensSale" - public
     Source: "function startTokensSale(\r\n            address _crowdsaleOwner,\r\n            uint    _crowdsaleDurationDays,\r\n            uint    _totalLimitUSD,\r\n            uint    _minimalSuccessUSD,\r\n            uint    _etherPrice) public onlyOwner {\r\n        require(state == State.Disabled || state == State.CompletePreICO);\r\n        crowdsaleStartTime = now;\r\n        crowdsaleOwner = _crowdsaleOwner;\r\n        etherPrice = _etherPrice;\r\n        delete numberOfInvestors;\r\n        delete collectedUSD;\r\n        crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days;\r\n        totalLimitUSD = _totalLimitUSD;\r\n        minimalSuccessUSD = _minimalSuccessUSD;\r\n        if (state == State.Disabled) {\r\n            state = State.PreICO;\r\n        } else {\r\n            state = State.Crowdsale;\r\n        }\r\n        NewState(state);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n            address _crowdsaleOwner,\r\n            uint    _crowdsaleDurationDays,\r\n            uint    _totalLimitUSD,\r\n            uint    _minimalSuccessUSD,\r\n            uint    _etherPrice)"
      VariableDeclaration "_crowdsaleOwner"
         Type: address
         Source: "address _crowdsaleOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_crowdsaleDurationDays"
         Type: uint256
         Source: "uint    _crowdsaleDurationDays"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_totalLimitUSD"
         Type: uint256
         Source: "uint    _totalLimitUSD"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_minimalSuccessUSD"
         Type: uint256
         Source: "uint    _minimalSuccessUSD"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_etherPrice"
         Type: uint256
         Source: "uint    _etherPrice"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(state == State.Disabled || state == State.CompletePreICO);\r\n        crowdsaleStartTime = now;\r\n        crowdsaleOwner = _crowdsaleOwner;\r\n        etherPrice = _etherPrice;\r\n        delete numberOfInvestors;\r\n        delete collectedUSD;\r\n        crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days;\r\n        totalLimitUSD = _totalLimitUSD;\r\n        minimalSuccessUSD = _minimalSuccessUSD;\r\n        if (state == State.Disabled) {\r\n            state = State.PreICO;\r\n        } else {\r\n            state = State.Crowdsale;\r\n        }\r\n        NewState(state);\r\n    }"
      ExpressionStatement
         Gas costs: 639
         Source: "require(state == State.Disabled || state == State.CompletePreICO)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.Disabled || state == State.CompletePreICO)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "state == State.Disabled || state == State.CompletePreICO"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.Disabled"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member Disabled
                 Type: enum Crowdsale.State
                 Source: "State.Disabled"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.CompletePreICO"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member CompletePreICO
                 Type: enum Crowdsale.State
                 Source: "State.CompletePreICO"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
      ExpressionStatement
         Gas costs: 20013
         Source: "crowdsaleStartTime = now"
        Assignment using operator =
           Type: uint256
           Source: "crowdsaleStartTime = now"
          Identifier crowdsaleStartTime
             Type: uint256
             Source: "crowdsaleStartTime"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 20267
         Source: "crowdsaleOwner = _crowdsaleOwner"
        Assignment using operator =
           Type: address
           Source: "crowdsaleOwner = _crowdsaleOwner"
          Identifier crowdsaleOwner
             Type: address
             Source: "crowdsaleOwner"
          Identifier _crowdsaleOwner
             Type: address
             Source: "_crowdsaleOwner"
      ExpressionStatement
         Gas costs: 20014
         Source: "etherPrice = _etherPrice"
        Assignment using operator =
           Type: uint256
           Source: "etherPrice = _etherPrice"
          Identifier etherPrice
             Type: uint256
             Source: "etherPrice"
          Identifier _etherPrice
             Type: uint256
             Source: "_etherPrice"
      ExpressionStatement
         Gas costs: 5009
         Source: "delete numberOfInvestors"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete numberOfInvestors"
          Identifier numberOfInvestors
             Type: uint256
             Source: "numberOfInvestors"
      ExpressionStatement
         Gas costs: 5009
         Source: "delete collectedUSD"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete collectedUSD"
          Identifier collectedUSD
             Type: uint256
             Source: "collectedUSD"
      ExpressionStatement
         Gas costs: 20027
         Source: "crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days"
        Assignment using operator =
           Type: uint256
           Source: "crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days"
          Identifier crowdsaleFinishTime
             Type: uint256
             Source: "crowdsaleFinishTime"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + _crowdsaleDurationDays * 1 days"
            Identifier now
               Type: uint256
               Source: "now"
            BinaryOperation using operator *
               Type: uint256
               Source: "_crowdsaleDurationDays * 1 days"
              Identifier _crowdsaleDurationDays
                 Type: uint256
                 Source: "_crowdsaleDurationDays"
              Literal, token: [no token] value: 1
                 Type: int_const 86400
                 Source: "1 days"
      ExpressionStatement
         Gas costs: 20014
         Source: "totalLimitUSD = _totalLimitUSD"
        Assignment using operator =
           Type: uint256
           Source: "totalLimitUSD = _totalLimitUSD"
          Identifier totalLimitUSD
             Type: uint256
             Source: "totalLimitUSD"
          Identifier _totalLimitUSD
             Type: uint256
             Source: "_totalLimitUSD"
      ExpressionStatement
         Gas costs: 20014
         Source: "minimalSuccessUSD = _minimalSuccessUSD"
        Assignment using operator =
           Type: uint256
           Source: "minimalSuccessUSD = _minimalSuccessUSD"
          Identifier minimalSuccessUSD
             Type: uint256
             Source: "minimalSuccessUSD"
          Identifier _minimalSuccessUSD
             Type: uint256
             Source: "_minimalSuccessUSD"
      IfStatement
         Source: "if (state == State.Disabled) {\r\n            state = State.PreICO;\r\n        } else {\r\n            state = State.Crowdsale;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 297
           Source: "state == State.Disabled"
          Identifier state
             Type: enum Crowdsale.State
             Source: "state"
          MemberAccess to member Disabled
             Type: enum Crowdsale.State
             Source: "State.Disabled"
            Identifier State
               Type: type(enum Crowdsale.State)
               Source: "State"
        Block
           Source: "{\r\n            state = State.PreICO;\r\n        }"
          ExpressionStatement
             Gas costs: 20287
             Source: "state = State.PreICO"
            Assignment using operator =
               Type: enum Crowdsale.State
               Source: "state = State.PreICO"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member PreICO
                 Type: enum Crowdsale.State
                 Source: "State.PreICO"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
        Block
           Source: "{\r\n            state = State.Crowdsale;\r\n        }"
          ExpressionStatement
             Gas costs: 20287
             Source: "state = State.Crowdsale"
            Assignment using operator =
               Type: enum Crowdsale.State
               Source: "state = State.Crowdsale"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member Crowdsale
                 Type: enum Crowdsale.State
                 Source: "State.Crowdsale"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
      ExpressionStatement
         Gas costs: [???]
         Source: "NewState(state)"
        FunctionCall
           Type: tuple()
           Source: "NewState(state)"
          Identifier NewState
             Type: function (enum Crowdsale.State)
             Source: "NewState"
          Identifier state
             Type: enum Crowdsale.State
             Source: "state"
  FunctionDefinition "timeToFinishTokensSale" - public - const
     Source: "function timeToFinishTokensSale() public constant returns(uint t) {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        if (now > crowdsaleFinishTime) {\r\n            t = 0;\r\n        } else {\r\n            t = crowdsaleFinishTime - now;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint t)"
      VariableDeclaration "t"
         Type: uint256
         Source: "uint t"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        if (now > crowdsaleFinishTime) {\r\n            t = 0;\r\n        } else {\r\n            t = crowdsaleFinishTime - now;\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 639
         Source: "require(state == State.PreICO || state == State.Crowdsale)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.PreICO || state == State.Crowdsale)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "state == State.PreICO || state == State.Crowdsale"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.PreICO"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member PreICO
                 Type: enum Crowdsale.State
                 Source: "State.PreICO"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.Crowdsale"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member Crowdsale
                 Type: enum Crowdsale.State
                 Source: "State.Crowdsale"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
      IfStatement
         Source: "if (now > crowdsaleFinishTime) {\r\n            t = 0;\r\n        } else {\r\n            t = crowdsaleFinishTime - now;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 208
           Source: "now > crowdsaleFinishTime"
          Identifier now
             Type: uint256
             Source: "now"
          Identifier crowdsaleFinishTime
             Type: uint256
             Source: "crowdsaleFinishTime"
        Block
           Source: "{\r\n            t = 0;\r\n        }"
          ExpressionStatement
             Gas costs: 8
             Source: "t = 0"
            Assignment using operator =
               Type: uint256
               Source: "t = 0"
              Identifier t
                 Type: uint256
                 Source: "t"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\r\n            t = crowdsaleFinishTime - now;\r\n        }"
          ExpressionStatement
             Gas costs: 213
             Source: "t = crowdsaleFinishTime - now"
            Assignment using operator =
               Type: uint256
               Source: "t = crowdsaleFinishTime - now"
              Identifier t
                 Type: uint256
                 Source: "t"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "crowdsaleFinishTime - now"
                Identifier crowdsaleFinishTime
                   Type: uint256
                   Source: "crowdsaleFinishTime"
                Identifier now
                   Type: uint256
                   Source: "now"
  FunctionDefinition "finishTokensSale" - public
     Source: "function finishTokensSale(uint _investorsToProcess) public {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        require(now >= crowdsaleFinishTime || collectedUSD == totalLimitUSD ||\r\n            (collectedUSD >= minimalSuccessUSD && msg.sender == owner));\r\n        if (collectedUSD < minimalSuccessUSD) {\r\n            // Investors can get their ether calling withdrawBack() function\r\n            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n                address addr = investorsIter[--numberOfInvestors];\r\n                Investor memory inv = investors[addr];\r\n                balances[addr] -= inv.amountTokens;\r\n                totalSupply -= inv.amountTokens;\r\n                Transfer(addr, this, inv.amountTokens);\r\n                --_investorsToProcess;\r\n                delete investorsIter[numberOfInvestors];\r\n            }\r\n            if (numberOfInvestors > 0) {\r\n                return;\r\n            }\r\n            if (state == State.PreICO) {\r\n                state = State.Disabled;\r\n            } else {\r\n                state = State.CompletePreICO;\r\n            }\r\n        } else {\r\n            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n                --numberOfInvestors;\r\n                --_investorsToProcess;\r\n                delete investors[investorsIter[numberOfInvestors]];\r\n                delete investorsIter[numberOfInvestors];\r\n            }\r\n            if (numberOfInvestors > 0) {\r\n                return;\r\n            }\r\n            if (state == State.PreICO) {\r\n                require(crowdsaleOwner.call.gas(3000000).value(this.balance)());\r\n                state = State.CompletePreICO;\r\n            } else {\r\n                require(crowdsaleOwner.call.gas(3000000).value(minimalSuccessUSD * 1000000000000000000 / etherPrice)());\r\n                // Create additional tokens for owner (30% of complete totalSupply)\r\n                uint tokens = 3 * totalSupply / 7;\r\n                balances[owner] = tokens;\r\n                totalSupply += tokens;\r\n                Transfer(this, owner, tokens);\r\n                state = State.Enabled;\r\n            }\r\n        }\r\n        NewState(state);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _investorsToProcess)"
      VariableDeclaration "_investorsToProcess"
         Type: uint256
         Source: "uint _investorsToProcess"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        require(now >= crowdsaleFinishTime || collectedUSD == totalLimitUSD ||\r\n            (collectedUSD >= minimalSuccessUSD && msg.sender == owner));\r\n        if (collectedUSD < minimalSuccessUSD) {\r\n            // Investors can get their ether calling withdrawBack() function\r\n            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n                address addr = investorsIter[--numberOfInvestors];\r\n                Investor memory inv = investors[addr];\r\n                balances[addr] -= inv.amountTokens;\r\n                totalSupply -= inv.amountTokens;\r\n                Transfer(addr, this, inv.amountTokens);\r\n                --_investorsToProcess;\r\n                delete investorsIter[numberOfInvestors];\r\n            }\r\n            if (numberOfInvestors > 0) {\r\n                return;\r\n            }\r\n            if (state == State.PreICO) {\r\n                state = State.Disabled;\r\n            } else {\r\n                state = State.CompletePreICO;\r\n            }\r\n        } else {\r\n            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n                --numberOfInvestors;\r\n                --_investorsToProcess;\r\n                delete investors[investorsIter[numberOfInvestors]];\r\n                delete investorsIter[numberOfInvestors];\r\n            }\r\n            if (numberOfInvestors > 0) {\r\n                return;\r\n            }\r\n            if (state == State.PreICO) {\r\n                require(crowdsaleOwner.call.gas(3000000).value(this.balance)());\r\n                state = State.CompletePreICO;\r\n            } else {\r\n                require(crowdsaleOwner.call.gas(3000000).value(minimalSuccessUSD * 1000000000000000000 / etherPrice)());\r\n                // Create additional tokens for owner (30% of complete totalSupply)\r\n                uint tokens = 3 * totalSupply / 7;\r\n                balances[owner] = tokens;\r\n                totalSupply += tokens;\r\n                Transfer(this, owner, tokens);\r\n                state = State.Enabled;\r\n            }\r\n        }\r\n        NewState(state);\r\n    }"
      ExpressionStatement
         Gas costs: 639
         Source: "require(state == State.PreICO || state == State.Crowdsale)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.PreICO || state == State.Crowdsale)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "state == State.PreICO || state == State.Crowdsale"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.PreICO"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member PreICO
                 Type: enum Crowdsale.State
                 Source: "State.PreICO"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.Crowdsale"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member Crowdsale
                 Type: enum Crowdsale.State
                 Source: "State.Crowdsale"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
      ExpressionStatement
         Gas costs: 1374
         Source: "require(now >= crowdsaleFinishTime || collectedUSD == totalLimitUSD ||\r\n            (collectedUSD >= minimalSuccessUSD && msg.sender == owner))"
        FunctionCall
           Type: tuple()
           Source: "require(now >= crowdsaleFinishTime || collectedUSD == totalLimitUSD ||\r\n            (collectedUSD >= minimalSuccessUSD && msg.sender == owner))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "now >= crowdsaleFinishTime || collectedUSD == totalLimitUSD ||\r\n            (collectedUSD >= minimalSuccessUSD && msg.sender == owner)"
            BinaryOperation using operator ||
               Type: bool
               Source: "now >= crowdsaleFinishTime || collectedUSD == totalLimitUSD"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "now >= crowdsaleFinishTime"
                Identifier now
                   Type: uint256
                   Source: "now"
                Identifier crowdsaleFinishTime
                   Type: uint256
                   Source: "crowdsaleFinishTime"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "collectedUSD == totalLimitUSD"
                Identifier collectedUSD
                   Type: uint256
                   Source: "collectedUSD"
                Identifier totalLimitUSD
                   Type: uint256
                   Source: "totalLimitUSD"
            TupleExpression
               Type: bool
               Source: "(collectedUSD >= minimalSuccessUSD && msg.sender == owner)"
              BinaryOperation using operator &&
                 Type: bool
                 Source: "collectedUSD >= minimalSuccessUSD && msg.sender == owner"
                BinaryOperation using operator >=
                   Type: bool
                   Source: "collectedUSD >= minimalSuccessUSD"
                  Identifier collectedUSD
                     Type: uint256
                     Source: "collectedUSD"
                  Identifier minimalSuccessUSD
                     Type: uint256
                     Source: "minimalSuccessUSD"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "msg.sender == owner"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier owner
                     Type: address
                     Source: "owner"
      IfStatement
         Source: "if (collectedUSD < minimalSuccessUSD) {\r\n            // Investors can get their ether calling withdrawBack() function\r\n            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n                address addr = investorsIter[--numberOfInvestors];\r\n                Investor memory inv = investors[addr];\r\n                balances[addr] -= inv.amountTokens;\r\n                totalSupply -= inv.amountTokens;\r\n                Transfer(addr, this, inv.amountTokens);\r\n                --_investorsToProcess;\r\n                delete investorsIter[numberOfInvestors];\r\n            }\r\n            if (numberOfInvestors > 0) {\r\n                return;\r\n            }\r\n            if (state == State.PreICO) {\r\n                state = State.Disabled;\r\n            } else {\r\n                state = State.CompletePreICO;\r\n            }\r\n        } else {\r\n            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n                --numberOfInvestors;\r\n                --_investorsToProcess;\r\n                delete investors[investorsIter[numberOfInvestors]];\r\n                delete investorsIter[numberOfInvestors];\r\n            }\r\n            if (numberOfInvestors > 0) {\r\n                return;\r\n            }\r\n            if (state == State.PreICO) {\r\n                require(crowdsaleOwner.call.gas(3000000).value(this.balance)());\r\n                state = State.CompletePreICO;\r\n            } else {\r\n                require(crowdsaleOwner.call.gas(3000000).value(minimalSuccessUSD * 1000000000000000000 / etherPrice)());\r\n                // Create additional tokens for owner (30% of complete totalSupply)\r\n                uint tokens = 3 * totalSupply / 7;\r\n                balances[owner] = tokens;\r\n                totalSupply += tokens;\r\n                Transfer(this, owner, tokens);\r\n                state = State.Enabled;\r\n            }\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 409
           Source: "collectedUSD < minimalSuccessUSD"
          Identifier collectedUSD
             Type: uint256
             Source: "collectedUSD"
          Identifier minimalSuccessUSD
             Type: uint256
             Source: "minimalSuccessUSD"
        Block
           Source: "{\r\n            // Investors can get their ether calling withdrawBack() function\r\n            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n                address addr = investorsIter[--numberOfInvestors];\r\n                Investor memory inv = investors[addr];\r\n                balances[addr] -= inv.amountTokens;\r\n                totalSupply -= inv.amountTokens;\r\n                Transfer(addr, this, inv.amountTokens);\r\n                --_investorsToProcess;\r\n                delete investorsIter[numberOfInvestors];\r\n            }\r\n            if (numberOfInvestors > 0) {\r\n                return;\r\n            }\r\n            if (state == State.PreICO) {\r\n                state = State.Disabled;\r\n            } else {\r\n                state = State.CompletePreICO;\r\n            }\r\n        }"
          WhileStatement
             Source: "while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n                address addr = investorsIter[--numberOfInvestors];\r\n                Investor memory inv = investors[addr];\r\n                balances[addr] -= inv.amountTokens;\r\n                totalSupply -= inv.amountTokens;\r\n                Transfer(addr, this, inv.amountTokens);\r\n                --_investorsToProcess;\r\n                delete investorsIter[numberOfInvestors];\r\n            }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 240
               Source: "_investorsToProcess > 0 && numberOfInvestors > 0"
              BinaryOperation using operator >
                 Type: bool
                 Source: "_investorsToProcess > 0"
                Identifier _investorsToProcess
                   Type: uint256
                   Source: "_investorsToProcess"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              BinaryOperation using operator >
                 Type: bool
                 Source: "numberOfInvestors > 0"
                Identifier numberOfInvestors
                   Type: uint256
                   Source: "numberOfInvestors"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            Block
               Source: "{\r\n                address addr = investorsIter[--numberOfInvestors];\r\n                Investor memory inv = investors[addr];\r\n                balances[addr] -= inv.amountTokens;\r\n                totalSupply -= inv.amountTokens;\r\n                Transfer(addr, this, inv.amountTokens);\r\n                --_investorsToProcess;\r\n                delete investorsIter[numberOfInvestors];\r\n            }"
              VariableDeclarationStatement
                 Gas costs: 20560
                 Source: "address addr = investorsIter[--numberOfInvestors]"
                VariableDeclaration "addr"
                   Type: address
                   Source: "address addr"
                  ElementaryTypeName address
                     Source: "address"
                IndexAccess
                   Type: address
                   Source: "investorsIter[--numberOfInvestors]"
                  Identifier investorsIter
                     Type: mapping(uint256 => address)
                     Source: "investorsIter"
                  UnaryOperation (prefix) --
                     Type: uint256
                     Source: "--numberOfInvestors"
                    Identifier numberOfInvestors
                       Type: uint256
                       Source: "numberOfInvestors"
              VariableDeclarationStatement
                 Gas costs: [???]
                 Source: "Investor memory inv = investors[addr]"
                VariableDeclaration "inv"
                   Type: struct Crowdsale.Investor memory
                   Source: "Investor memory inv"
                  UserDefinedTypeName "Investor"
                     Source: "Investor"
                IndexAccess
                   Type: struct Crowdsale.Investor storage ref
                   Source: "investors[addr]"
                  Identifier investors
                     Type: mapping(address => struct Crowdsale.Investor storage ref)
                     Source: "investors"
                  Identifier addr
                     Type: address
                     Source: "addr"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "balances[addr] -= inv.amountTokens"
                Assignment using operator -=
                   Type: uint256
                   Source: "balances[addr] -= inv.amountTokens"
                  IndexAccess
                     Type: uint256
                     Source: "balances[addr]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    Identifier addr
                       Type: address
                       Source: "addr"
                  MemberAccess to member amountTokens
                     Type: uint256
                     Source: "inv.amountTokens"
                    Identifier inv
                       Type: struct Crowdsale.Investor memory
                       Source: "inv"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "totalSupply -= inv.amountTokens"
                Assignment using operator -=
                   Type: uint256
                   Source: "totalSupply -= inv.amountTokens"
                  Identifier totalSupply
                     Type: uint256
                     Source: "totalSupply"
                  MemberAccess to member amountTokens
                     Type: uint256
                     Source: "inv.amountTokens"
                    Identifier inv
                       Type: struct Crowdsale.Investor memory
                       Source: "inv"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "Transfer(addr, this, inv.amountTokens)"
                FunctionCall
                   Type: tuple()
                   Source: "Transfer(addr, this, inv.amountTokens)"
                  Identifier Transfer
                     Type: function (address,address,uint256)
                     Source: "Transfer"
                  Identifier addr
                     Type: address
                     Source: "addr"
                  Identifier this
                     Type: contract Crowdsale
                     Source: "this"
                  MemberAccess to member amountTokens
                     Type: uint256
                     Source: "inv.amountTokens"
                    Identifier inv
                       Type: struct Crowdsale.Investor memory
                       Source: "inv"
              ExpressionStatement
                 Gas costs: 17
                 Source: "--_investorsToProcess"
                UnaryOperation (prefix) --
                   Type: uint256
                   Source: "--_investorsToProcess"
                  Identifier _investorsToProcess
                     Type: uint256
                     Source: "_investorsToProcess"
              ExpressionStatement
                 Gas costs: 20520
                 Source: "delete investorsIter[numberOfInvestors]"
                UnaryOperation (prefix) delete
                   Type: tuple()
                   Source: "delete investorsIter[numberOfInvestors]"
                  IndexAccess
                     Type: address
                     Source: "investorsIter[numberOfInvestors]"
                    Identifier investorsIter
                       Type: mapping(uint256 => address)
                       Source: "investorsIter"
                    Identifier numberOfInvestors
                       Type: uint256
                       Source: "numberOfInvestors"
          IfStatement
             Source: "if (numberOfInvestors > 0) {\r\n                return;\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 209
               Source: "numberOfInvestors > 0"
              Identifier numberOfInvestors
                 Type: uint256
                 Source: "numberOfInvestors"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{\r\n                return;\r\n            }"
              Return
                 Gas costs: 11
                 Source: "return;"
          IfStatement
             Source: "if (state == State.PreICO) {\r\n                state = State.Disabled;\r\n            } else {\r\n                state = State.CompletePreICO;\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 297
               Source: "state == State.PreICO"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member PreICO
                 Type: enum Crowdsale.State
                 Source: "State.PreICO"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
            Block
               Source: "{\r\n                state = State.Disabled;\r\n            }"
              ExpressionStatement
                 Gas costs: 20287
                 Source: "state = State.Disabled"
                Assignment using operator =
                   Type: enum Crowdsale.State
                   Source: "state = State.Disabled"
                  Identifier state
                     Type: enum Crowdsale.State
                     Source: "state"
                  MemberAccess to member Disabled
                     Type: enum Crowdsale.State
                     Source: "State.Disabled"
                    Identifier State
                       Type: type(enum Crowdsale.State)
                       Source: "State"
            Block
               Source: "{\r\n                state = State.CompletePreICO;\r\n            }"
              ExpressionStatement
                 Gas costs: 20287
                 Source: "state = State.CompletePreICO"
                Assignment using operator =
                   Type: enum Crowdsale.State
                   Source: "state = State.CompletePreICO"
                  Identifier state
                     Type: enum Crowdsale.State
                     Source: "state"
                  MemberAccess to member CompletePreICO
                     Type: enum Crowdsale.State
                     Source: "State.CompletePreICO"
                    Identifier State
                       Type: type(enum Crowdsale.State)
                       Source: "State"
        Block
           Source: "{\r\n            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n                --numberOfInvestors;\r\n                --_investorsToProcess;\r\n                delete investors[investorsIter[numberOfInvestors]];\r\n                delete investorsIter[numberOfInvestors];\r\n            }\r\n            if (numberOfInvestors > 0) {\r\n                return;\r\n            }\r\n            if (state == State.PreICO) {\r\n                require(crowdsaleOwner.call.gas(3000000).value(this.balance)());\r\n                state = State.CompletePreICO;\r\n            } else {\r\n                require(crowdsaleOwner.call.gas(3000000).value(minimalSuccessUSD * 1000000000000000000 / etherPrice)());\r\n                // Create additional tokens for owner (30% of complete totalSupply)\r\n                uint tokens = 3 * totalSupply / 7;\r\n                balances[owner] = tokens;\r\n                totalSupply += tokens;\r\n                Transfer(this, owner, tokens);\r\n                state = State.Enabled;\r\n            }\r\n        }"
          WhileStatement
             Source: "while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n                --numberOfInvestors;\r\n                --_investorsToProcess;\r\n                delete investors[investorsIter[numberOfInvestors]];\r\n                delete investorsIter[numberOfInvestors];\r\n            }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 240
               Source: "_investorsToProcess > 0 && numberOfInvestors > 0"
              BinaryOperation using operator >
                 Type: bool
                 Source: "_investorsToProcess > 0"
                Identifier _investorsToProcess
                   Type: uint256
                   Source: "_investorsToProcess"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              BinaryOperation using operator >
                 Type: bool
                 Source: "numberOfInvestors > 0"
                Identifier numberOfInvestors
                   Type: uint256
                   Source: "numberOfInvestors"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            Block
               Source: "{\r\n                --numberOfInvestors;\r\n                --_investorsToProcess;\r\n                delete investors[investorsIter[numberOfInvestors]];\r\n                delete investorsIter[numberOfInvestors];\r\n            }"
              ExpressionStatement
                 Gas costs: 20234
                 Source: "--numberOfInvestors"
                UnaryOperation (prefix) --
                   Type: uint256
                   Source: "--numberOfInvestors"
                  Identifier numberOfInvestors
                     Type: uint256
                     Source: "numberOfInvestors"
              ExpressionStatement
                 Gas costs: 17
                 Source: "--_investorsToProcess"
                UnaryOperation (prefix) --
                   Type: uint256
                   Source: "--_investorsToProcess"
                  Identifier _investorsToProcess
                     Type: uint256
                     Source: "_investorsToProcess"
              ExpressionStatement
                 Gas costs: 10650
                 Source: "delete investors[investorsIter[numberOfInvestors]]"
                UnaryOperation (prefix) delete
                   Type: tuple()
                   Source: "delete investors[investorsIter[numberOfInvestors]]"
                  IndexAccess
                     Type: struct Crowdsale.Investor storage ref
                     Source: "investors[investorsIter[numberOfInvestors]]"
                    Identifier investors
                       Type: mapping(address => struct Crowdsale.Investor storage ref)
                       Source: "investors"
                    IndexAccess
                       Type: address
                       Source: "investorsIter[numberOfInvestors]"
                      Identifier investorsIter
                         Type: mapping(uint256 => address)
                         Source: "investorsIter"
                      Identifier numberOfInvestors
                         Type: uint256
                         Source: "numberOfInvestors"
              ExpressionStatement
                 Gas costs: 20520
                 Source: "delete investorsIter[numberOfInvestors]"
                UnaryOperation (prefix) delete
                   Type: tuple()
                   Source: "delete investorsIter[numberOfInvestors]"
                  IndexAccess
                     Type: address
                     Source: "investorsIter[numberOfInvestors]"
                    Identifier investorsIter
                       Type: mapping(uint256 => address)
                       Source: "investorsIter"
                    Identifier numberOfInvestors
                       Type: uint256
                       Source: "numberOfInvestors"
          IfStatement
             Source: "if (numberOfInvestors > 0) {\r\n                return;\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 209
               Source: "numberOfInvestors > 0"
              Identifier numberOfInvestors
                 Type: uint256
                 Source: "numberOfInvestors"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{\r\n                return;\r\n            }"
              Return
                 Gas costs: 11
                 Source: "return;"
          IfStatement
             Source: "if (state == State.PreICO) {\r\n                require(crowdsaleOwner.call.gas(3000000).value(this.balance)());\r\n                state = State.CompletePreICO;\r\n            } else {\r\n                require(crowdsaleOwner.call.gas(3000000).value(minimalSuccessUSD * 1000000000000000000 / etherPrice)());\r\n                // Create additional tokens for owner (30% of complete totalSupply)\r\n                uint tokens = 3 * totalSupply / 7;\r\n                balances[owner] = tokens;\r\n                totalSupply += tokens;\r\n                Transfer(this, owner, tokens);\r\n                state = State.Enabled;\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 297
               Source: "state == State.PreICO"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member PreICO
                 Type: enum Crowdsale.State
                 Source: "State.PreICO"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
            Block
               Source: "{\r\n                require(crowdsaleOwner.call.gas(3000000).value(this.balance)());\r\n                state = State.CompletePreICO;\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "require(crowdsaleOwner.call.gas(3000000).value(this.balance)())"
                FunctionCall
                   Type: tuple()
                   Source: "require(crowdsaleOwner.call.gas(3000000).value(this.balance)())"
                  Identifier require
                     Type: function (bool) pure
                     Source: "require"
                  FunctionCall
                     Type: bool
                     Source: "crowdsaleOwner.call.gas(3000000).value(this.balance)()"
                    FunctionCall
                       Type: function () payable returns (bool)
                       Source: "crowdsaleOwner.call.gas(3000000).value(this.balance)"
                      MemberAccess to member value
                         Type: function (uint256) returns (function () payable returns (bool))
                         Source: "crowdsaleOwner.call.gas(3000000).value"
                        FunctionCall
                           Type: function () payable returns (bool)
                           Source: "crowdsaleOwner.call.gas(3000000)"
                          MemberAccess to member gas
                             Type: function (uint256) returns (function () payable returns (bool))
                             Source: "crowdsaleOwner.call.gas"
                            MemberAccess to member call
                               Type: function () payable returns (bool)
                               Source: "crowdsaleOwner.call"
                              Identifier crowdsaleOwner
                                 Type: address
                                 Source: "crowdsaleOwner"
                          Literal, token: [no token] value: 3000000
                             Type: int_const 3000000
                             Source: "3000000"
                      MemberAccess to member balance
                         Type: uint256
                         Source: "this.balance"
                        Identifier this
                           Type: contract Crowdsale
                           Source: "this"
              ExpressionStatement
                 Gas costs: 20287
                 Source: "state = State.CompletePreICO"
                Assignment using operator =
                   Type: enum Crowdsale.State
                   Source: "state = State.CompletePreICO"
                  Identifier state
                     Type: enum Crowdsale.State
                     Source: "state"
                  MemberAccess to member CompletePreICO
                     Type: enum Crowdsale.State
                     Source: "State.CompletePreICO"
                    Identifier State
                       Type: type(enum Crowdsale.State)
                       Source: "State"
            Block
               Source: "{\r\n                require(crowdsaleOwner.call.gas(3000000).value(minimalSuccessUSD * 1000000000000000000 / etherPrice)());\r\n                // Create additional tokens for owner (30% of complete totalSupply)\r\n                uint tokens = 3 * totalSupply / 7;\r\n                balances[owner] = tokens;\r\n                totalSupply += tokens;\r\n                Transfer(this, owner, tokens);\r\n                state = State.Enabled;\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "require(crowdsaleOwner.call.gas(3000000).value(minimalSuccessUSD * 1000000000000000000 / etherPrice)())"
                FunctionCall
                   Type: tuple()
                   Source: "require(crowdsaleOwner.call.gas(3000000).value(minimalSuccessUSD * 1000000000000000000 / etherPrice)())"
                  Identifier require
                     Type: function (bool) pure
                     Source: "require"
                  FunctionCall
                     Type: bool
                     Source: "crowdsaleOwner.call.gas(3000000).value(minimalSuccessUSD * 1000000000000000000 / etherPrice)()"
                    FunctionCall
                       Type: function () payable returns (bool)
                       Source: "crowdsaleOwner.call.gas(3000000).value(minimalSuccessUSD * 1000000000000000000 / etherPrice)"
                      MemberAccess to member value
                         Type: function (uint256) returns (function () payable returns (bool))
                         Source: "crowdsaleOwner.call.gas(3000000).value"
                        FunctionCall
                           Type: function () payable returns (bool)
                           Source: "crowdsaleOwner.call.gas(3000000)"
                          MemberAccess to member gas
                             Type: function (uint256) returns (function () payable returns (bool))
                             Source: "crowdsaleOwner.call.gas"
                            MemberAccess to member call
                               Type: function () payable returns (bool)
                               Source: "crowdsaleOwner.call"
                              Identifier crowdsaleOwner
                                 Type: address
                                 Source: "crowdsaleOwner"
                          Literal, token: [no token] value: 3000000
                             Type: int_const 3000000
                             Source: "3000000"
                      BinaryOperation using operator /
                         Type: uint256
                         Source: "minimalSuccessUSD * 1000000000000000000 / etherPrice"
                        BinaryOperation using operator *
                           Type: uint256
                           Source: "minimalSuccessUSD * 1000000000000000000"
                          Identifier minimalSuccessUSD
                             Type: uint256
                             Source: "minimalSuccessUSD"
                          Literal, token: [no token] value: 1000000000000000000
                             Type: int_const 1000000000000000000
                             Source: "1000000000000000000"
                        Identifier etherPrice
                           Type: uint256
                           Source: "etherPrice"
              VariableDeclarationStatement
                 Gas costs: 250
                 Source: "uint tokens = 3 * totalSupply / 7"
                VariableDeclaration "tokens"
                   Type: uint256
                   Source: "uint tokens"
                  ElementaryTypeName uint
                     Source: "uint"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "3 * totalSupply / 7"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "3 * totalSupply"
                    Literal, token: [no token] value: 3
                       Type: int_const 3
                       Source: "3"
                    Identifier totalSupply
                       Type: uint256
                       Source: "totalSupply"
                  Literal, token: [no token] value: 7
                     Type: int_const 7
                     Source: "7"
              ExpressionStatement
                 Gas costs: 20346
                 Source: "balances[owner] = tokens"
                Assignment using operator =
                   Type: uint256
                   Source: "balances[owner] = tokens"
                  IndexAccess
                     Type: uint256
                     Source: "balances[owner]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    Identifier owner
                       Type: address
                       Source: "owner"
                  Identifier tokens
                     Type: uint256
                     Source: "tokens"
              ExpressionStatement
                 Gas costs: 20233
                 Source: "totalSupply += tokens"
                Assignment using operator +=
                   Type: uint256
                   Source: "totalSupply += tokens"
                  Identifier totalSupply
                     Type: uint256
                     Source: "totalSupply"
                  Identifier tokens
                     Type: uint256
                     Source: "tokens"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "Transfer(this, owner, tokens)"
                FunctionCall
                   Type: tuple()
                   Source: "Transfer(this, owner, tokens)"
                  Identifier Transfer
                     Type: function (address,address,uint256)
                     Source: "Transfer"
                  Identifier this
                     Type: contract Crowdsale
                     Source: "this"
                  Identifier owner
                     Type: address
                     Source: "owner"
                  Identifier tokens
                     Type: uint256
                     Source: "tokens"
              ExpressionStatement
                 Gas costs: 20287
                 Source: "state = State.Enabled"
                Assignment using operator =
                   Type: enum Crowdsale.State
                   Source: "state = State.Enabled"
                  Identifier state
                     Type: enum Crowdsale.State
                     Source: "state"
                  MemberAccess to member Enabled
                     Type: enum Crowdsale.State
                     Source: "State.Enabled"
                    Identifier State
                       Type: type(enum Crowdsale.State)
                       Source: "State"
      ExpressionStatement
         Gas costs: [???]
         Source: "NewState(state)"
        FunctionCall
           Type: tuple()
           Source: "NewState(state)"
          Identifier NewState
             Type: function (enum Crowdsale.State)
             Source: "NewState"
          Identifier state
             Type: enum Crowdsale.State
             Source: "state"
  FunctionDefinition "withdrawBack" - public
     Source: "function withdrawBack() public {\r\n        require(state == State.Disabled || state == State.CompletePreICO);\r\n        uint value = investors[msg.sender].amountWei;\r\n        if (value > 0) {\r\n            delete investors[msg.sender];\r\n            require(msg.sender.call.gas(3000000).value(value)());\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(state == State.Disabled || state == State.CompletePreICO);\r\n        uint value = investors[msg.sender].amountWei;\r\n        if (value > 0) {\r\n            delete investors[msg.sender];\r\n            require(msg.sender.call.gas(3000000).value(value)());\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 639
         Source: "require(state == State.Disabled || state == State.CompletePreICO)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.Disabled || state == State.CompletePreICO)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "state == State.Disabled || state == State.CompletePreICO"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.Disabled"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member Disabled
                 Type: enum Crowdsale.State
                 Source: "State.Disabled"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
            BinaryOperation using operator ==
               Type: bool
               Source: "state == State.CompletePreICO"
              Identifier state
                 Type: enum Crowdsale.State
                 Source: "state"
              MemberAccess to member CompletePreICO
                 Type: enum Crowdsale.State
                 Source: "State.CompletePreICO"
                Identifier State
                   Type: type(enum Crowdsale.State)
                   Source: "State"
      VariableDeclarationStatement
         Gas costs: 312
         Source: "uint value = investors[msg.sender].amountWei"
        VariableDeclaration "value"
           Type: uint256
           Source: "uint value"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member amountWei
           Type: uint256
           Source: "investors[msg.sender].amountWei"
          IndexAccess
             Type: struct Crowdsale.Investor storage ref
             Source: "investors[msg.sender]"
            Identifier investors
               Type: mapping(address => struct Crowdsale.Investor storage ref)
               Source: "investors"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      IfStatement
         Source: "if (value > 0) {\r\n            delete investors[msg.sender];\r\n            require(msg.sender.call.gas(3000000).value(value)());\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "value > 0"
          Identifier value
             Type: uint256
             Source: "value"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            delete investors[msg.sender];\r\n            require(msg.sender.call.gas(3000000).value(value)());\r\n        }"
          ExpressionStatement
             Gas costs: 10135
             Source: "delete investors[msg.sender]"
            UnaryOperation (prefix) delete
               Type: tuple()
               Source: "delete investors[msg.sender]"
              IndexAccess
                 Type: struct Crowdsale.Investor storage ref
                 Source: "investors[msg.sender]"
                Identifier investors
                   Type: mapping(address => struct Crowdsale.Investor storage ref)
                   Source: "investors"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(msg.sender.call.gas(3000000).value(value)())"
            FunctionCall
               Type: tuple()
               Source: "require(msg.sender.call.gas(3000000).value(value)())"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "msg.sender.call.gas(3000000).value(value)()"
                FunctionCall
                   Type: function () payable returns (bool)
                   Source: "msg.sender.call.gas(3000000).value(value)"
                  MemberAccess to member value
                     Type: function (uint256) returns (function () payable returns (bool))
                     Source: "msg.sender.call.gas(3000000).value"
                    FunctionCall
                       Type: function () payable returns (bool)
                       Source: "msg.sender.call.gas(3000000)"
                      MemberAccess to member gas
                         Type: function (uint256) returns (function () payable returns (bool))
                         Source: "msg.sender.call.gas"
                        MemberAccess to member call
                           Type: function () payable returns (bool)
                           Source: "msg.sender.call"
                          MemberAccess to member sender
                             Type: address
                             Source: "msg.sender"
                            Identifier msg
                               Type: msg
                               Source: "msg"
                      Literal, token: [no token] value: 3000000
                         Type: int_const 3000000
                         Source: "3000000"
                  Identifier value
                     Type: uint256
                     Source: "value"
ContractDefinition "Fund"
   Gas costs: 0
   Source: "contract Fund {\r\n    function transferFund(address _to, uint _value);\r\n}"
  FunctionDefinition "transferFund" - public
     Source: "function transferFund(address _to, uint _value);"
    ParameterList
       Source: "(address _to, uint _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
ContractDefinition "Token"
   Source: "contract Token is Crowdsale, Fund {\r\n    \r\n    string  public standard    = 'Token 0.1';\r\n    string  public name        = 'PROOF';\r\n    string  public symbol      = \"PF\";\r\n    uint8   public decimals    = 0;\r\n\r\n    mapping (address => mapping (address => uint)) public allowed;\r\n    mapping (address => bool) public externalControllers;\r\n\r\n    modifier onlyTokenHolders {\r\n        require(balances[msg.sender] != 0);\r\n        _;\r\n    }\r\n\r\n    // Fix for the ERC20 short address attack\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    modifier externalController {\r\n        require(externalControllers[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function Token(address _migrationHost)\r\n        payable Crowdsale(_migrationHost) {}\r\n\r\n    function balanceOf(address who) constant returns (uint) {\r\n        return balances[who];\r\n    }\r\n\r\n    function transfer(address _to, uint _value)\r\n        public enabledState onlyPayloadSize(2 * 32) {\r\n        require(balances[msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public enabledState onlyPayloadSize(3 * 32) {\r\n        require(balances[_from] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        balances[_from] -= _value;\r\n        balances[_to] += _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public enabledState {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant enabledState\r\n        returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function transferFund(address _to, uint _value) public externalController {\r\n        require(balances[this] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        balances[this] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(this, _to, _value);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Crowdsale"
    UserDefinedTypeName "Crowdsale"
       Source: "Crowdsale"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Fund"
    UserDefinedTypeName "Fund"
       Source: "Fund"
  VariableDeclaration "standard"
     Type: string storage ref
     Gas costs: [???]
     Source: "string  public standard    = 'Token 0.1'"
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Token 0.1
       Type: literal_string "Token 0.1"
       Source: "'Token 0.1'"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: [???]
     Source: "string  public name        = 'PROOF'"
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: PROOF
       Type: literal_string "PROOF"
       Source: "'PROOF'"
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: [???]
     Source: "string  public symbol      = \"PF\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: PF
       Type: literal_string "PF"
       Source: "\"PF\""
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: [???]
     Source: "uint8   public decimals    = 0"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: [???]
     Source: "mapping (address => mapping (address => uint)) public allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "externalControllers"
     Type: mapping(address => bool)
     Gas costs: [???]
     Source: "mapping (address => bool) public externalControllers"
    Mapping
       Source: "mapping (address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  ModifierDefinition "onlyTokenHolders"
     Source: "modifier onlyTokenHolders {\r\n        require(balances[msg.sender] != 0);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(balances[msg.sender] != 0);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 333
         Source: "require(balances[msg.sender] != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "balances[msg.sender] != 0"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyPayloadSize"
     Source: "modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint size)"
      VariableDeclaration "size"
         Type: uint256
         Source: "uint size"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 102
         Source: "require(msg.data.length >= size + 4)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.data.length >= size + 4)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.data.length >= size + 4"
            MemberAccess to member length
               Type: uint256
               Source: "msg.data.length"
              MemberAccess to member data
                 Type: bytes calldata
                 Source: "msg.data"
                Identifier msg
                   Type: msg
                   Source: "msg"
            BinaryOperation using operator +
               Type: uint256
               Source: "size + 4"
              Identifier size
                 Type: uint256
                 Source: "size"
              Literal, token: [no token] value: 4
                 Type: int_const 4
                 Source: "4"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "externalController"
     Source: "modifier externalController {\r\n        require(externalControllers[msg.sender]);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(externalControllers[msg.sender]);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 360
         Source: "require(externalControllers[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(externalControllers[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          IndexAccess
             Type: bool
             Source: "externalControllers[msg.sender]"
            Identifier externalControllers
               Type: mapping(address => bool)
               Source: "externalControllers"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "Token" - public
     Source: "function Token(address _migrationHost)\r\n        payable Crowdsale(_migrationHost) {}"
    ParameterList
       Gas costs: 0
       Source: "(address _migrationHost)"
      VariableDeclaration "_migrationHost"
         Type: address
         Source: "address _migrationHost"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "Crowdsale"
       Gas costs: 0
       Source: "Crowdsale(_migrationHost)"
      Identifier Crowdsale
         Type: type(contract Crowdsale)
         Source: "Crowdsale"
      Identifier _migrationHost
         Type: address
         Source: "_migrationHost"
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) constant returns (uint) {\r\n        return balances[who];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return balances[who];\r\n    }"
      Return
         Gas costs: 304
         Source: "return balances[who]"
        IndexAccess
           Type: uint256
           Source: "balances[who]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier who
             Type: address
             Source: "who"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value)\r\n        public enabledState onlyPayloadSize(2 * 32) {\r\n        require(balances[msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "enabledState"
       Gas costs: 0
       Source: "enabledState"
      Identifier enabledState
         Type: modifier ()
         Source: "enabledState"
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 3
       Source: "onlyPayloadSize(2 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 64
         Source: "2 * 32"
        Literal, token: [no token] value: 2
           Type: int_const 2
           Source: "2"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n        require(balances[msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 333
         Source: "require(balances[msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 630
         Source: "require(balances[_to] + _value >= balances[_to])"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_to] + _value >= balances[_to])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[_to] + _value >= balances[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balances[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
      ExpressionStatement
         Gas costs: 20328
         Source: "balances[msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value)\r\n        public enabledState onlyPayloadSize(3 * 32) {\r\n        require(balances[_from] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        balances[_from] -= _value;\r\n        balances[_to] += _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "enabledState"
       Gas costs: 0
       Source: "enabledState"
      Identifier enabledState
         Type: modifier ()
         Source: "enabledState"
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 3
       Source: "onlyPayloadSize(3 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 96
         Source: "3 * 32"
        Literal, token: [no token] value: 3
           Type: int_const 3
           Source: "3"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n        require(balances[_from] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        balances[_from] -= _value;\r\n        balances[_to] += _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 334
         Source: "require(balances[_from] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_from] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[_from] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[_from]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 630
         Source: "require(balances[_to] + _value >= balances[_to])"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_to] + _value >= balances[_to])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[_to] + _value >= balances[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balances[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
      ExpressionStatement
         Gas costs: 423
         Source: "require(allowed[_from][msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(allowed[_from][msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "allowed[_from][msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "allowed[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[_from]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20412
         Source: "allowed[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowed[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint _value) public enabledState {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "enabledState"
       Gas costs: 0
       Source: "enabledState"
      Identifier enabledState
         Type: modifier ()
         Source: "enabledState"
    Block
       Source: "{\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public constant enabledState\r\n        returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint remaining"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "enabledState"
       Gas costs: 0
       Source: "enabledState"
      Identifier enabledState
         Type: modifier ()
         Source: "enabledState"
    Block
       Source: "{\r\n        return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  FunctionDefinition "transferFund" - public
     Source: "function transferFund(address _to, uint _value) public externalController {\r\n        require(balances[this] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        balances[this] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(this, _to, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "externalController"
       Gas costs: 0
       Source: "externalController"
      Identifier externalController
         Type: modifier ()
         Source: "externalController"
    Block
       Source: "{\r\n        require(balances[this] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        balances[this] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(this, _to, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 333
         Source: "require(balances[this] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[this] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[this] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[this]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier this
                 Type: contract Token
                 Source: "this"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 630
         Source: "require(balances[_to] + _value >= balances[_to])"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_to] + _value >= balances[_to])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[_to] + _value >= balances[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balances[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
      ExpressionStatement
         Gas costs: 20328
         Source: "balances[this] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[this] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[this]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier this
               Type: contract Token
               Source: "this"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(this, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(this, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier this
             Type: contract Token
             Source: "this"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
ContractDefinition "ProofVote"
   Source: "contract ProofVote is Token {\r\n\r\n    function ProofVote(address _migrationHost)\r\n        payable Token(_migrationHost) {}\r\n\r\n    event VotingStarted(uint weiReqFund, VoteReason voteReason);\r\n    event Voted(address indexed voter, bool inSupport);\r\n    event VotingFinished(bool inSupport);\r\n\r\n    enum Vote { NoVote, VoteYea, VoteNay }\r\n    enum VoteReason { Nothing, ReqFund, Migration, UpdateContract }\r\n\r\n    uint public weiReqFund;\r\n    uint public votingDeadline;\r\n    uint public numberOfVotes;\r\n    uint public yea;\r\n    uint public nay;\r\n    VoteReason  voteReason;\r\n    mapping (address => Vote) public votes;\r\n    mapping (uint => address) public votesIter;\r\n\r\n    address public migrationAgent;\r\n    address public migrationAgentCandidate;\r\n    address public externalControllerCandidate;\r\n\r\n    function startVoting(uint _weiReqFund) public enabledOrMigrationState onlyOwner {\r\n        require(_weiReqFund > 0);\r\n        internalStartVoting(_weiReqFund, VoteReason.ReqFund, 7);\r\n    }\r\n\r\n    function internalStartVoting(uint _weiReqFund, VoteReason _voteReason, uint _votingDurationDays) internal {\r\n        require(voteReason == VoteReason.Nothing && _weiReqFund <= this.balance);\r\n        weiReqFund = _weiReqFund;\r\n        votingDeadline = now + _votingDurationDays * 1 days;\r\n        voteReason = _voteReason;\r\n        delete yea;\r\n        delete nay;\r\n        VotingStarted(_weiReqFund, _voteReason);\r\n    }\r\n    \r\n    function votingInfo() public constant\r\n        returns(uint _weiReqFund, uint _timeToFinish, VoteReason _voteReason) {\r\n        _weiReqFund = weiReqFund;\r\n        _voteReason = voteReason;\r\n        if (votingDeadline <= now) {\r\n            _timeToFinish = 0;\r\n        } else {\r\n            _timeToFinish = votingDeadline - now;\r\n        }\r\n    }\r\n\r\n    function vote(bool _inSupport) public onlyTokenHolders returns (uint voteId) {\r\n        require(voteReason != VoteReason.Nothing);\r\n        require(votes[msg.sender] == Vote.NoVote);\r\n        require(votingDeadline > now);\r\n        voteId = numberOfVotes++;\r\n        votesIter[voteId] = msg.sender;\r\n        if (_inSupport) {\r\n            votes[msg.sender] = Vote.VoteYea;\r\n        } else {\r\n            votes[msg.sender] = Vote.VoteNay;\r\n        }\r\n        Voted(msg.sender, _inSupport);\r\n        return voteId;\r\n    }\r\n\r\n    function finishVoting(uint _votesToProcess) public returns (bool _inSupport) {\r\n        require(voteReason != VoteReason.Nothing);\r\n        require(now >= votingDeadline);\r\n\r\n        while (_votesToProcess > 0 && numberOfVotes > 0) {\r\n            address voter = votesIter[--numberOfVotes];\r\n            Vote v = votes[voter];\r\n            uint voteWeight = balances[voter];\r\n            if (v == Vote.VoteYea) {\r\n                yea += voteWeight;\r\n            } else if (v == Vote.VoteNay) {\r\n                nay += voteWeight;\r\n            }\r\n            delete votes[voter];\r\n            delete votesIter[numberOfVotes];\r\n            --_votesToProcess;\r\n        }\r\n        if (numberOfVotes > 0) {\r\n            _inSupport = false;\r\n            return;\r\n        }\r\n\r\n        _inSupport = (yea > nay);\r\n        uint weiForSend = weiReqFund;\r\n        delete weiReqFund;\r\n        delete votingDeadline;\r\n        delete numberOfVotes;\r\n\r\n        if (_inSupport) {\r\n            if (voteReason == VoteReason.ReqFund) {\r\n                require(owner.call.gas(3000000).value(weiForSend)());\r\n            } else if (voteReason == VoteReason.Migration) {\r\n                migrationAgent = migrationAgentCandidate;\r\n                require(migrationAgent.call.gas(3000000).value(this.balance)());\r\n                delete migrationAgentCandidate;\r\n                state = State.Migration;\r\n            } else if (voteReason == VoteReason.UpdateContract) {\r\n                externalControllers[externalControllerCandidate] = true;\r\n                delete externalControllerCandidate;\r\n            }\r\n        }\r\n\r\n        delete voteReason;\r\n        VotingFinished(_inSupport);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Token"
    UserDefinedTypeName "Token"
       Source: "Token"
  FunctionDefinition "ProofVote" - public
     Source: "function ProofVote(address _migrationHost)\r\n        payable Token(_migrationHost) {}"
    ParameterList
       Gas costs: 0
       Source: "(address _migrationHost)"
      VariableDeclaration "_migrationHost"
         Type: address
         Source: "address _migrationHost"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "Token"
       Gas costs: 0
       Source: "Token(_migrationHost)"
      Identifier Token
         Type: type(contract Token)
         Source: "Token"
      Identifier _migrationHost
         Type: address
         Source: "_migrationHost"
    Block
       Gas costs: 0
       Source: "{}"
  EventDefinition "VotingStarted"
     Gas costs: 0
     Source: "event VotingStarted(uint weiReqFund, VoteReason voteReason);"
    ParameterList
       Source: "(uint weiReqFund, VoteReason voteReason)"
      VariableDeclaration "weiReqFund"
         Type: uint256
         Source: "uint weiReqFund"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "voteReason"
         Type: enum ProofVote.VoteReason
         Source: "VoteReason voteReason"
        UserDefinedTypeName "VoteReason"
           Source: "VoteReason"
  EventDefinition "Voted"
     Gas costs: 0
     Source: "event Voted(address indexed voter, bool inSupport);"
    ParameterList
       Source: "(address indexed voter, bool inSupport)"
      VariableDeclaration "voter"
         Type: address
         Source: "address indexed voter"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "inSupport"
         Type: bool
         Source: "bool inSupport"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "VotingFinished"
     Gas costs: 0
     Source: "event VotingFinished(bool inSupport);"
    ParameterList
       Source: "(bool inSupport)"
      VariableDeclaration "inSupport"
         Type: bool
         Source: "bool inSupport"
        ElementaryTypeName bool
           Source: "bool"
  EnumDefinition "Vote"
    EnumValue "NoVote"
    EnumValue "VoteYea"
    EnumValue "VoteNay"
  EnumDefinition "VoteReason"
    EnumValue "Nothing"
    EnumValue "ReqFund"
    EnumValue "Migration"
    EnumValue "UpdateContract"
  VariableDeclaration "weiReqFund"
     Type: uint256
     Gas costs: [???]
     Source: "uint public weiReqFund"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "votingDeadline"
     Type: uint256
     Gas costs: [???]
     Source: "uint public votingDeadline"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "numberOfVotes"
     Type: uint256
     Gas costs: [???]
     Source: "uint public numberOfVotes"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "yea"
     Type: uint256
     Gas costs: [???]
     Source: "uint public yea"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "nay"
     Type: uint256
     Gas costs: [???]
     Source: "uint public nay"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "voteReason"
     Type: enum ProofVote.VoteReason
     Gas costs: 0
     Source: "VoteReason  voteReason"
    UserDefinedTypeName "VoteReason"
       Source: "VoteReason"
  VariableDeclaration "votes"
     Type: mapping(address => enum ProofVote.Vote)
     Gas costs: [???]
     Source: "mapping (address => Vote) public votes"
    Mapping
       Source: "mapping (address => Vote)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "Vote"
         Source: "Vote"
  VariableDeclaration "votesIter"
     Type: mapping(uint256 => address)
     Gas costs: [???]
     Source: "mapping (uint => address) public votesIter"
    Mapping
       Source: "mapping (uint => address)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "migrationAgent"
     Type: address
     Gas costs: [???]
     Source: "address public migrationAgent"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "migrationAgentCandidate"
     Type: address
     Gas costs: [???]
     Source: "address public migrationAgentCandidate"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "externalControllerCandidate"
     Type: address
     Gas costs: [???]
     Source: "address public externalControllerCandidate"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "startVoting" - public
     Source: "function startVoting(uint _weiReqFund) public enabledOrMigrationState onlyOwner {\r\n        require(_weiReqFund > 0);\r\n        internalStartVoting(_weiReqFund, VoteReason.ReqFund, 7);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _weiReqFund)"
      VariableDeclaration "_weiReqFund"
         Type: uint256
         Source: "uint _weiReqFund"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "enabledOrMigrationState"
       Gas costs: 0
       Source: "enabledOrMigrationState"
      Identifier enabledOrMigrationState
         Type: modifier ()
         Source: "enabledOrMigrationState"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_weiReqFund > 0);\r\n        internalStartVoting(_weiReqFund, VoteReason.ReqFund, 7);\r\n    }"
      ExpressionStatement
         Gas costs: 35
         Source: "require(_weiReqFund > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_weiReqFund > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "_weiReqFund > 0"
            Identifier _weiReqFund
               Type: uint256
               Source: "_weiReqFund"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 13
         Source: "internalStartVoting(_weiReqFund, VoteReason.ReqFund, 7)"
        FunctionCall
           Type: tuple()
           Source: "internalStartVoting(_weiReqFund, VoteReason.ReqFund, 7)"
          Identifier internalStartVoting
             Type: function (uint256,enum ProofVote.VoteReason,uint256)
             Source: "internalStartVoting"
          Identifier _weiReqFund
             Type: uint256
             Source: "_weiReqFund"
          MemberAccess to member ReqFund
             Type: enum ProofVote.VoteReason
             Source: "VoteReason.ReqFund"
            Identifier VoteReason
               Type: type(enum ProofVote.VoteReason)
               Source: "VoteReason"
          Literal, token: [no token] value: 7
             Type: int_const 7
             Source: "7"
  FunctionDefinition "internalStartVoting"
     Source: "function internalStartVoting(uint _weiReqFund, VoteReason _voteReason, uint _votingDurationDays) internal {\r\n        require(voteReason == VoteReason.Nothing && _weiReqFund <= this.balance);\r\n        weiReqFund = _weiReqFund;\r\n        votingDeadline = now + _votingDurationDays * 1 days;\r\n        voteReason = _voteReason;\r\n        delete yea;\r\n        delete nay;\r\n        VotingStarted(_weiReqFund, _voteReason);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _weiReqFund, VoteReason _voteReason, uint _votingDurationDays)"
      VariableDeclaration "_weiReqFund"
         Type: uint256
         Source: "uint _weiReqFund"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_voteReason"
         Type: enum ProofVote.VoteReason
         Source: "VoteReason _voteReason"
        UserDefinedTypeName "VoteReason"
           Source: "VoteReason"
      VariableDeclaration "_votingDurationDays"
         Type: uint256
         Source: "uint _votingDurationDays"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(voteReason == VoteReason.Nothing && _weiReqFund <= this.balance);\r\n        weiReqFund = _weiReqFund;\r\n        votingDeadline = now + _votingDurationDays * 1 days;\r\n        voteReason = _voteReason;\r\n        delete yea;\r\n        delete nay;\r\n        VotingStarted(_weiReqFund, _voteReason);\r\n    }"
      ExpressionStatement
         Gas costs: 762
         Source: "require(voteReason == VoteReason.Nothing && _weiReqFund <= this.balance)"
        FunctionCall
           Type: tuple()
           Source: "require(voteReason == VoteReason.Nothing && _weiReqFund <= this.balance)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "voteReason == VoteReason.Nothing && _weiReqFund <= this.balance"
            BinaryOperation using operator ==
               Type: bool
               Source: "voteReason == VoteReason.Nothing"
              Identifier voteReason
                 Type: enum ProofVote.VoteReason
                 Source: "voteReason"
              MemberAccess to member Nothing
                 Type: enum ProofVote.VoteReason
                 Source: "VoteReason.Nothing"
                Identifier VoteReason
                   Type: type(enum ProofVote.VoteReason)
                   Source: "VoteReason"
            BinaryOperation using operator <=
               Type: bool
               Source: "_weiReqFund <= this.balance"
              Identifier _weiReqFund
                 Type: uint256
                 Source: "_weiReqFund"
              MemberAccess to member balance
                 Type: uint256
                 Source: "this.balance"
                Identifier this
                   Type: contract ProofVote
                   Source: "this"
      ExpressionStatement
         Gas costs: 20014
         Source: "weiReqFund = _weiReqFund"
        Assignment using operator =
           Type: uint256
           Source: "weiReqFund = _weiReqFund"
          Identifier weiReqFund
             Type: uint256
             Source: "weiReqFund"
          Identifier _weiReqFund
             Type: uint256
             Source: "_weiReqFund"
      ExpressionStatement
         Gas costs: 20027
         Source: "votingDeadline = now + _votingDurationDays * 1 days"
        Assignment using operator =
           Type: uint256
           Source: "votingDeadline = now + _votingDurationDays * 1 days"
          Identifier votingDeadline
             Type: uint256
             Source: "votingDeadline"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + _votingDurationDays * 1 days"
            Identifier now
               Type: uint256
               Source: "now"
            BinaryOperation using operator *
               Type: uint256
               Source: "_votingDurationDays * 1 days"
              Identifier _votingDurationDays
                 Type: uint256
                 Source: "_votingDurationDays"
              Literal, token: [no token] value: 1
                 Type: int_const 86400
                 Source: "1 days"
      ExpressionStatement
         Gas costs: 20287
         Source: "voteReason = _voteReason"
        Assignment using operator =
           Type: enum ProofVote.VoteReason
           Source: "voteReason = _voteReason"
          Identifier voteReason
             Type: enum ProofVote.VoteReason
             Source: "voteReason"
          Identifier _voteReason
             Type: enum ProofVote.VoteReason
             Source: "_voteReason"
      ExpressionStatement
         Gas costs: 5009
         Source: "delete yea"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete yea"
          Identifier yea
             Type: uint256
             Source: "yea"
      ExpressionStatement
         Gas costs: 5009
         Source: "delete nay"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete nay"
          Identifier nay
             Type: uint256
             Source: "nay"
      ExpressionStatement
         Gas costs: [???]
         Source: "VotingStarted(_weiReqFund, _voteReason)"
        FunctionCall
           Type: tuple()
           Source: "VotingStarted(_weiReqFund, _voteReason)"
          Identifier VotingStarted
             Type: function (uint256,enum ProofVote.VoteReason)
             Source: "VotingStarted"
          Identifier _weiReqFund
             Type: uint256
             Source: "_weiReqFund"
          Identifier _voteReason
             Type: enum ProofVote.VoteReason
             Source: "_voteReason"
  FunctionDefinition "votingInfo" - public - const
     Source: "function votingInfo() public constant\r\n        returns(uint _weiReqFund, uint _timeToFinish, VoteReason _voteReason) {\r\n        _weiReqFund = weiReqFund;\r\n        _voteReason = voteReason;\r\n        if (votingDeadline <= now) {\r\n            _timeToFinish = 0;\r\n        } else {\r\n            _timeToFinish = votingDeadline - now;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 9
       Source: "(uint _weiReqFund, uint _timeToFinish, VoteReason _voteReason)"
      VariableDeclaration "_weiReqFund"
         Type: uint256
         Source: "uint _weiReqFund"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_timeToFinish"
         Type: uint256
         Source: "uint _timeToFinish"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_voteReason"
         Type: enum ProofVote.VoteReason
         Source: "VoteReason _voteReason"
        UserDefinedTypeName "VoteReason"
           Source: "VoteReason"
    Block
       Source: "{\r\n        _weiReqFund = weiReqFund;\r\n        _voteReason = voteReason;\r\n        if (votingDeadline <= now) {\r\n            _timeToFinish = 0;\r\n        } else {\r\n            _timeToFinish = votingDeadline - now;\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 208
         Source: "_weiReqFund = weiReqFund"
        Assignment using operator =
           Type: uint256
           Source: "_weiReqFund = weiReqFund"
          Identifier _weiReqFund
             Type: uint256
             Source: "_weiReqFund"
          Identifier weiReqFund
             Type: uint256
             Source: "weiReqFund"
      ExpressionStatement
         Gas costs: 244
         Source: "_voteReason = voteReason"
        Assignment using operator =
           Type: enum ProofVote.VoteReason
           Source: "_voteReason = voteReason"
          Identifier _voteReason
             Type: enum ProofVote.VoteReason
             Source: "_voteReason"
          Identifier voteReason
             Type: enum ProofVote.VoteReason
             Source: "voteReason"
      IfStatement
         Source: "if (votingDeadline <= now) {\r\n            _timeToFinish = 0;\r\n        } else {\r\n            _timeToFinish = votingDeadline - now;\r\n        }"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 211
           Source: "votingDeadline <= now"
          Identifier votingDeadline
             Type: uint256
             Source: "votingDeadline"
          Identifier now
             Type: uint256
             Source: "now"
        Block
           Source: "{\r\n            _timeToFinish = 0;\r\n        }"
          ExpressionStatement
             Gas costs: 8
             Source: "_timeToFinish = 0"
            Assignment using operator =
               Type: uint256
               Source: "_timeToFinish = 0"
              Identifier _timeToFinish
                 Type: uint256
                 Source: "_timeToFinish"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\r\n            _timeToFinish = votingDeadline - now;\r\n        }"
          ExpressionStatement
             Gas costs: 213
             Source: "_timeToFinish = votingDeadline - now"
            Assignment using operator =
               Type: uint256
               Source: "_timeToFinish = votingDeadline - now"
              Identifier _timeToFinish
                 Type: uint256
                 Source: "_timeToFinish"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "votingDeadline - now"
                Identifier votingDeadline
                   Type: uint256
                   Source: "votingDeadline"
                Identifier now
                   Type: uint256
                   Source: "now"
  FunctionDefinition "vote" - public
     Source: "function vote(bool _inSupport) public onlyTokenHolders returns (uint voteId) {\r\n        require(voteReason != VoteReason.Nothing);\r\n        require(votes[msg.sender] == Vote.NoVote);\r\n        require(votingDeadline > now);\r\n        voteId = numberOfVotes++;\r\n        votesIter[voteId] = msg.sender;\r\n        if (_inSupport) {\r\n            votes[msg.sender] = Vote.VoteYea;\r\n        } else {\r\n            votes[msg.sender] = Vote.VoteNay;\r\n        }\r\n        Voted(msg.sender, _inSupport);\r\n        return voteId;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bool _inSupport)"
      VariableDeclaration "_inSupport"
         Type: bool
         Source: "bool _inSupport"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 3
       Source: "(uint voteId)"
      VariableDeclaration "voteId"
         Type: uint256
         Source: "uint voteId"
        ElementaryTypeName uint
           Source: "uint"
    ModifierInvocation "onlyTokenHolders"
       Gas costs: 0
       Source: "onlyTokenHolders"
      Identifier onlyTokenHolders
         Type: modifier ()
         Source: "onlyTokenHolders"
    Block
       Source: "{\r\n        require(voteReason != VoteReason.Nothing);\r\n        require(votes[msg.sender] == Vote.NoVote);\r\n        require(votingDeadline > now);\r\n        voteId = numberOfVotes++;\r\n        votesIter[voteId] = msg.sender;\r\n        if (_inSupport) {\r\n            votes[msg.sender] = Vote.VoteYea;\r\n        } else {\r\n            votes[msg.sender] = Vote.VoteNay;\r\n        }\r\n        Voted(msg.sender, _inSupport);\r\n        return voteId;\r\n    }"
      ExpressionStatement
         Gas costs: 326
         Source: "require(voteReason != VoteReason.Nothing)"
        FunctionCall
           Type: tuple()
           Source: "require(voteReason != VoteReason.Nothing)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "voteReason != VoteReason.Nothing"
            Identifier voteReason
               Type: enum ProofVote.VoteReason
               Source: "voteReason"
            MemberAccess to member Nothing
               Type: enum ProofVote.VoteReason
               Source: "VoteReason.Nothing"
              Identifier VoteReason
                 Type: type(enum ProofVote.VoteReason)
                 Source: "VoteReason"
      ExpressionStatement
         Gas costs: 418
         Source: "require(votes[msg.sender] == Vote.NoVote)"
        FunctionCall
           Type: tuple()
           Source: "require(votes[msg.sender] == Vote.NoVote)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "votes[msg.sender] == Vote.NoVote"
            IndexAccess
               Type: enum ProofVote.Vote
               Source: "votes[msg.sender]"
              Identifier votes
                 Type: mapping(address => enum ProofVote.Vote)
                 Source: "votes"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            MemberAccess to member NoVote
               Type: enum ProofVote.Vote
               Source: "Vote.NoVote"
              Identifier Vote
                 Type: type(enum ProofVote.Vote)
                 Source: "Vote"
      ExpressionStatement
         Gas costs: 234
         Source: "require(votingDeadline > now)"
        FunctionCall
           Type: tuple()
           Source: "require(votingDeadline > now)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "votingDeadline > now"
            Identifier votingDeadline
               Type: uint256
               Source: "votingDeadline"
            Identifier now
               Type: uint256
               Source: "now"
      ExpressionStatement
         Gas costs: 20240
         Source: "voteId = numberOfVotes++"
        Assignment using operator =
           Type: uint256
           Source: "voteId = numberOfVotes++"
          Identifier voteId
             Type: uint256
             Source: "voteId"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "numberOfVotes++"
            Identifier numberOfVotes
               Type: uint256
               Source: "numberOfVotes"
      ExpressionStatement
         Gas costs: 20350
         Source: "votesIter[voteId] = msg.sender"
        Assignment using operator =
           Type: address
           Source: "votesIter[voteId] = msg.sender"
          IndexAccess
             Type: address
             Source: "votesIter[voteId]"
            Identifier votesIter
               Type: mapping(uint256 => address)
               Source: "votesIter"
            Identifier voteId
               Type: uint256
               Source: "voteId"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (_inSupport) {\r\n            votes[msg.sender] = Vote.VoteYea;\r\n        } else {\r\n            votes[msg.sender] = Vote.VoteNay;\r\n        }"
        Identifier _inSupport
           Type: bool
           Gas costs: 3
           Source: "_inSupport"
        Block
           Source: "{\r\n            votes[msg.sender] = Vote.VoteYea;\r\n        }"
          ExpressionStatement
             Gas costs: 20382
             Source: "votes[msg.sender] = Vote.VoteYea"
            Assignment using operator =
               Type: enum ProofVote.Vote
               Source: "votes[msg.sender] = Vote.VoteYea"
              IndexAccess
                 Type: enum ProofVote.Vote
                 Source: "votes[msg.sender]"
                Identifier votes
                   Type: mapping(address => enum ProofVote.Vote)
                   Source: "votes"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              MemberAccess to member VoteYea
                 Type: enum ProofVote.Vote
                 Source: "Vote.VoteYea"
                Identifier Vote
                   Type: type(enum ProofVote.Vote)
                   Source: "Vote"
        Block
           Source: "{\r\n            votes[msg.sender] = Vote.VoteNay;\r\n        }"
          ExpressionStatement
             Gas costs: 20382
             Source: "votes[msg.sender] = Vote.VoteNay"
            Assignment using operator =
               Type: enum ProofVote.Vote
               Source: "votes[msg.sender] = Vote.VoteNay"
              IndexAccess
                 Type: enum ProofVote.Vote
                 Source: "votes[msg.sender]"
                Identifier votes
                   Type: mapping(address => enum ProofVote.Vote)
                   Source: "votes"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              MemberAccess to member VoteNay
                 Type: enum ProofVote.Vote
                 Source: "Vote.VoteNay"
                Identifier Vote
                   Type: type(enum ProofVote.Vote)
                   Source: "Vote"
      ExpressionStatement
         Gas costs: [???]
         Source: "Voted(msg.sender, _inSupport)"
        FunctionCall
           Type: tuple()
           Source: "Voted(msg.sender, _inSupport)"
          Identifier Voted
             Type: function (address,bool)
             Source: "Voted"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _inSupport
             Type: bool
             Source: "_inSupport"
      Return
         Gas costs: 8
         Source: "return voteId"
        Identifier voteId
           Type: uint256
           Source: "voteId"
  FunctionDefinition "finishVoting" - public
     Source: "function finishVoting(uint _votesToProcess) public returns (bool _inSupport) {\r\n        require(voteReason != VoteReason.Nothing);\r\n        require(now >= votingDeadline);\r\n\r\n        while (_votesToProcess > 0 && numberOfVotes > 0) {\r\n            address voter = votesIter[--numberOfVotes];\r\n            Vote v = votes[voter];\r\n            uint voteWeight = balances[voter];\r\n            if (v == Vote.VoteYea) {\r\n                yea += voteWeight;\r\n            } else if (v == Vote.VoteNay) {\r\n                nay += voteWeight;\r\n            }\r\n            delete votes[voter];\r\n            delete votesIter[numberOfVotes];\r\n            --_votesToProcess;\r\n        }\r\n        if (numberOfVotes > 0) {\r\n            _inSupport = false;\r\n            return;\r\n        }\r\n\r\n        _inSupport = (yea > nay);\r\n        uint weiForSend = weiReqFund;\r\n        delete weiReqFund;\r\n        delete votingDeadline;\r\n        delete numberOfVotes;\r\n\r\n        if (_inSupport) {\r\n            if (voteReason == VoteReason.ReqFund) {\r\n                require(owner.call.gas(3000000).value(weiForSend)());\r\n            } else if (voteReason == VoteReason.Migration) {\r\n                migrationAgent = migrationAgentCandidate;\r\n                require(migrationAgent.call.gas(3000000).value(this.balance)());\r\n                delete migrationAgentCandidate;\r\n                state = State.Migration;\r\n            } else if (voteReason == VoteReason.UpdateContract) {\r\n                externalControllers[externalControllerCandidate] = true;\r\n                delete externalControllerCandidate;\r\n            }\r\n        }\r\n\r\n        delete voteReason;\r\n        VotingFinished(_inSupport);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _votesToProcess)"
      VariableDeclaration "_votesToProcess"
         Type: uint256
         Source: "uint _votesToProcess"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool _inSupport)"
      VariableDeclaration "_inSupport"
         Type: bool
         Source: "bool _inSupport"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require(voteReason != VoteReason.Nothing);\r\n        require(now >= votingDeadline);\r\n\r\n        while (_votesToProcess > 0 && numberOfVotes > 0) {\r\n            address voter = votesIter[--numberOfVotes];\r\n            Vote v = votes[voter];\r\n            uint voteWeight = balances[voter];\r\n            if (v == Vote.VoteYea) {\r\n                yea += voteWeight;\r\n            } else if (v == Vote.VoteNay) {\r\n                nay += voteWeight;\r\n            }\r\n            delete votes[voter];\r\n            delete votesIter[numberOfVotes];\r\n            --_votesToProcess;\r\n        }\r\n        if (numberOfVotes > 0) {\r\n            _inSupport = false;\r\n            return;\r\n        }\r\n\r\n        _inSupport = (yea > nay);\r\n        uint weiForSend = weiReqFund;\r\n        delete weiReqFund;\r\n        delete votingDeadline;\r\n        delete numberOfVotes;\r\n\r\n        if (_inSupport) {\r\n            if (voteReason == VoteReason.ReqFund) {\r\n                require(owner.call.gas(3000000).value(weiForSend)());\r\n            } else if (voteReason == VoteReason.Migration) {\r\n                migrationAgent = migrationAgentCandidate;\r\n                require(migrationAgent.call.gas(3000000).value(this.balance)());\r\n                delete migrationAgentCandidate;\r\n                state = State.Migration;\r\n            } else if (voteReason == VoteReason.UpdateContract) {\r\n                externalControllers[externalControllerCandidate] = true;\r\n                delete externalControllerCandidate;\r\n            }\r\n        }\r\n\r\n        delete voteReason;\r\n        VotingFinished(_inSupport);\r\n    }"
      ExpressionStatement
         Gas costs: 326
         Source: "require(voteReason != VoteReason.Nothing)"
        FunctionCall
           Type: tuple()
           Source: "require(voteReason != VoteReason.Nothing)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "voteReason != VoteReason.Nothing"
            Identifier voteReason
               Type: enum ProofVote.VoteReason
               Source: "voteReason"
            MemberAccess to member Nothing
               Type: enum ProofVote.VoteReason
               Source: "VoteReason.Nothing"
              Identifier VoteReason
                 Type: type(enum ProofVote.VoteReason)
                 Source: "VoteReason"
      ExpressionStatement
         Gas costs: 237
         Source: "require(now >= votingDeadline)"
        FunctionCall
           Type: tuple()
           Source: "require(now >= votingDeadline)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "now >= votingDeadline"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier votingDeadline
               Type: uint256
               Source: "votingDeadline"
      WhileStatement
         Source: "while (_votesToProcess > 0 && numberOfVotes > 0) {\r\n            address voter = votesIter[--numberOfVotes];\r\n            Vote v = votes[voter];\r\n            uint voteWeight = balances[voter];\r\n            if (v == Vote.VoteYea) {\r\n                yea += voteWeight;\r\n            } else if (v == Vote.VoteNay) {\r\n                nay += voteWeight;\r\n            }\r\n            delete votes[voter];\r\n            delete votesIter[numberOfVotes];\r\n            --_votesToProcess;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 240
           Source: "_votesToProcess > 0 && numberOfVotes > 0"
          BinaryOperation using operator >
             Type: bool
             Source: "_votesToProcess > 0"
            Identifier _votesToProcess
               Type: uint256
               Source: "_votesToProcess"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator >
             Type: bool
             Source: "numberOfVotes > 0"
            Identifier numberOfVotes
               Type: uint256
               Source: "numberOfVotes"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            address voter = votesIter[--numberOfVotes];\r\n            Vote v = votes[voter];\r\n            uint voteWeight = balances[voter];\r\n            if (v == Vote.VoteYea) {\r\n                yea += voteWeight;\r\n            } else if (v == Vote.VoteNay) {\r\n                nay += voteWeight;\r\n            }\r\n            delete votes[voter];\r\n            delete votesIter[numberOfVotes];\r\n            --_votesToProcess;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 20560
             Source: "address voter = votesIter[--numberOfVotes]"
            VariableDeclaration "voter"
               Type: address
               Source: "address voter"
              ElementaryTypeName address
                 Source: "address"
            IndexAccess
               Type: address
               Source: "votesIter[--numberOfVotes]"
              Identifier votesIter
                 Type: mapping(uint256 => address)
                 Source: "votesIter"
              UnaryOperation (prefix) --
                 Type: uint256
                 Source: "--numberOfVotes"
                Identifier numberOfVotes
                   Type: uint256
                   Source: "numberOfVotes"
          VariableDeclarationStatement
             Gas costs: 337
             Source: "Vote v = votes[voter]"
            VariableDeclaration "v"
               Type: enum ProofVote.Vote
               Source: "Vote v"
              UserDefinedTypeName "Vote"
                 Source: "Vote"
            IndexAccess
               Type: enum ProofVote.Vote
               Source: "votes[voter]"
              Identifier votes
                 Type: mapping(address => enum ProofVote.Vote)
                 Source: "votes"
              Identifier voter
                 Type: address
                 Source: "voter"
          VariableDeclarationStatement
             Gas costs: 301
             Source: "uint voteWeight = balances[voter]"
            VariableDeclaration "voteWeight"
               Type: uint256
               Source: "uint voteWeight"
              ElementaryTypeName uint
                 Source: "uint"
            IndexAccess
               Type: uint256
               Source: "balances[voter]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier voter
                 Type: address
                 Source: "voter"
          IfStatement
             Source: "if (v == Vote.VoteYea) {\r\n                yea += voteWeight;\r\n            } else if (v == Vote.VoteNay) {\r\n                nay += voteWeight;\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 61
               Source: "v == Vote.VoteYea"
              Identifier v
                 Type: enum ProofVote.Vote
                 Source: "v"
              MemberAccess to member VoteYea
                 Type: enum ProofVote.Vote
                 Source: "Vote.VoteYea"
                Identifier Vote
                   Type: type(enum ProofVote.Vote)
                   Source: "Vote"
            Block
               Source: "{\r\n                yea += voteWeight;\r\n            }"
              ExpressionStatement
                 Gas costs: 20233
                 Source: "yea += voteWeight"
                Assignment using operator +=
                   Type: uint256
                   Source: "yea += voteWeight"
                  Identifier yea
                     Type: uint256
                     Source: "yea"
                  Identifier voteWeight
                     Type: uint256
                     Source: "voteWeight"
            IfStatement
               Source: "if (v == Vote.VoteNay) {\r\n                nay += voteWeight;\r\n            }"
              BinaryOperation using operator ==
                 Type: bool
                 Gas costs: 61
                 Source: "v == Vote.VoteNay"
                Identifier v
                   Type: enum ProofVote.Vote
                   Source: "v"
                MemberAccess to member VoteNay
                   Type: enum ProofVote.Vote
                   Source: "Vote.VoteNay"
                  Identifier Vote
                     Type: type(enum ProofVote.Vote)
                     Source: "Vote"
              Block
                 Source: "{\r\n                nay += voteWeight;\r\n            }"
                ExpressionStatement
                   Gas costs: 20233
                   Source: "nay += voteWeight"
                  Assignment using operator +=
                     Type: uint256
                     Source: "nay += voteWeight"
                    Identifier nay
                       Type: uint256
                       Source: "nay"
                    Identifier voteWeight
                       Type: uint256
                       Source: "voteWeight"
          ExpressionStatement
             Gas costs: 20338
             Source: "delete votes[voter]"
            UnaryOperation (prefix) delete
               Type: tuple()
               Source: "delete votes[voter]"
              IndexAccess
                 Type: enum ProofVote.Vote
                 Source: "votes[voter]"
                Identifier votes
                   Type: mapping(address => enum ProofVote.Vote)
                   Source: "votes"
                Identifier voter
                   Type: address
                   Source: "voter"
          ExpressionStatement
             Gas costs: 20520
             Source: "delete votesIter[numberOfVotes]"
            UnaryOperation (prefix) delete
               Type: tuple()
               Source: "delete votesIter[numberOfVotes]"
              IndexAccess
                 Type: address
                 Source: "votesIter[numberOfVotes]"
                Identifier votesIter
                   Type: mapping(uint256 => address)
                   Source: "votesIter"
                Identifier numberOfVotes
                   Type: uint256
                   Source: "numberOfVotes"
          ExpressionStatement
             Gas costs: 17
             Source: "--_votesToProcess"
            UnaryOperation (prefix) --
               Type: uint256
               Source: "--_votesToProcess"
              Identifier _votesToProcess
                 Type: uint256
                 Source: "_votesToProcess"
      IfStatement
         Source: "if (numberOfVotes > 0) {\r\n            _inSupport = false;\r\n            return;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "numberOfVotes > 0"
          Identifier numberOfVotes
             Type: uint256
             Source: "numberOfVotes"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            _inSupport = false;\r\n            return;\r\n        }"
          ExpressionStatement
             Gas costs: 8
             Source: "_inSupport = false"
            Assignment using operator =
               Type: bool
               Source: "_inSupport = false"
              Identifier _inSupport
                 Type: bool
                 Source: "_inSupport"
              Literal, token: false value: false
                 Type: bool
                 Source: "false"
          Return
             Gas costs: 11
             Source: "return;"
      ExpressionStatement
         Gas costs: 414
         Source: "_inSupport = (yea > nay)"
        Assignment using operator =
           Type: bool
           Source: "_inSupport = (yea > nay)"
          Identifier _inSupport
             Type: bool
             Source: "_inSupport"
          TupleExpression
             Type: bool
             Source: "(yea > nay)"
            BinaryOperation using operator >
               Type: bool
               Source: "yea > nay"
              Identifier yea
                 Type: uint256
                 Source: "yea"
              Identifier nay
                 Type: uint256
                 Source: "nay"
      VariableDeclarationStatement
         Gas costs: 211
         Source: "uint weiForSend = weiReqFund"
        VariableDeclaration "weiForSend"
           Type: uint256
           Source: "uint weiForSend"
          ElementaryTypeName uint
             Source: "uint"
        Identifier weiReqFund
           Type: uint256
           Source: "weiReqFund"
      ExpressionStatement
         Gas costs: 5009
         Source: "delete weiReqFund"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete weiReqFund"
          Identifier weiReqFund
             Type: uint256
             Source: "weiReqFund"
      ExpressionStatement
         Gas costs: 5009
         Source: "delete votingDeadline"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete votingDeadline"
          Identifier votingDeadline
             Type: uint256
             Source: "votingDeadline"
      ExpressionStatement
         Gas costs: 5009
         Source: "delete numberOfVotes"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete numberOfVotes"
          Identifier numberOfVotes
             Type: uint256
             Source: "numberOfVotes"
      IfStatement
         Source: "if (_inSupport) {\r\n            if (voteReason == VoteReason.ReqFund) {\r\n                require(owner.call.gas(3000000).value(weiForSend)());\r\n            } else if (voteReason == VoteReason.Migration) {\r\n                migrationAgent = migrationAgentCandidate;\r\n                require(migrationAgent.call.gas(3000000).value(this.balance)());\r\n                delete migrationAgentCandidate;\r\n                state = State.Migration;\r\n            } else if (voteReason == VoteReason.UpdateContract) {\r\n                externalControllers[externalControllerCandidate] = true;\r\n                delete externalControllerCandidate;\r\n            }\r\n        }"
        Identifier _inSupport
           Type: bool
           Gas costs: 3
           Source: "_inSupport"
        Block
           Source: "{\r\n            if (voteReason == VoteReason.ReqFund) {\r\n                require(owner.call.gas(3000000).value(weiForSend)());\r\n            } else if (voteReason == VoteReason.Migration) {\r\n                migrationAgent = migrationAgentCandidate;\r\n                require(migrationAgent.call.gas(3000000).value(this.balance)());\r\n                delete migrationAgentCandidate;\r\n                state = State.Migration;\r\n            } else if (voteReason == VoteReason.UpdateContract) {\r\n                externalControllers[externalControllerCandidate] = true;\r\n                delete externalControllerCandidate;\r\n            }\r\n        }"
          IfStatement
             Source: "if (voteReason == VoteReason.ReqFund) {\r\n                require(owner.call.gas(3000000).value(weiForSend)());\r\n            } else if (voteReason == VoteReason.Migration) {\r\n                migrationAgent = migrationAgentCandidate;\r\n                require(migrationAgent.call.gas(3000000).value(this.balance)());\r\n                delete migrationAgentCandidate;\r\n                state = State.Migration;\r\n            } else if (voteReason == VoteReason.UpdateContract) {\r\n                externalControllers[externalControllerCandidate] = true;\r\n                delete externalControllerCandidate;\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 297
               Source: "voteReason == VoteReason.ReqFund"
              Identifier voteReason
                 Type: enum ProofVote.VoteReason
                 Source: "voteReason"
              MemberAccess to member ReqFund
                 Type: enum ProofVote.VoteReason
                 Source: "VoteReason.ReqFund"
                Identifier VoteReason
                   Type: type(enum ProofVote.VoteReason)
                   Source: "VoteReason"
            Block
               Source: "{\r\n                require(owner.call.gas(3000000).value(weiForSend)());\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "require(owner.call.gas(3000000).value(weiForSend)())"
                FunctionCall
                   Type: tuple()
                   Source: "require(owner.call.gas(3000000).value(weiForSend)())"
                  Identifier require
                     Type: function (bool) pure
                     Source: "require"
                  FunctionCall
                     Type: bool
                     Source: "owner.call.gas(3000000).value(weiForSend)()"
                    FunctionCall
                       Type: function () payable returns (bool)
                       Source: "owner.call.gas(3000000).value(weiForSend)"
                      MemberAccess to member value
                         Type: function (uint256) returns (function () payable returns (bool))
                         Source: "owner.call.gas(3000000).value"
                        FunctionCall
                           Type: function () payable returns (bool)
                           Source: "owner.call.gas(3000000)"
                          MemberAccess to member gas
                             Type: function (uint256) returns (function () payable returns (bool))
                             Source: "owner.call.gas"
                            MemberAccess to member call
                               Type: function () payable returns (bool)
                               Source: "owner.call"
                              Identifier owner
                                 Type: address
                                 Source: "owner"
                          Literal, token: [no token] value: 3000000
                             Type: int_const 3000000
                             Source: "3000000"
                      Identifier weiForSend
                         Type: uint256
                         Source: "weiForSend"
            IfStatement
               Source: "if (voteReason == VoteReason.Migration) {\r\n                migrationAgent = migrationAgentCandidate;\r\n                require(migrationAgent.call.gas(3000000).value(this.balance)());\r\n                delete migrationAgentCandidate;\r\n                state = State.Migration;\r\n            } else if (voteReason == VoteReason.UpdateContract) {\r\n                externalControllers[externalControllerCandidate] = true;\r\n                delete externalControllerCandidate;\r\n            }"
              BinaryOperation using operator ==
                 Type: bool
                 Gas costs: 297
                 Source: "voteReason == VoteReason.Migration"
                Identifier voteReason
                   Type: enum ProofVote.VoteReason
                   Source: "voteReason"
                MemberAccess to member Migration
                   Type: enum ProofVote.VoteReason
                   Source: "VoteReason.Migration"
                  Identifier VoteReason
                     Type: type(enum ProofVote.VoteReason)
                     Source: "VoteReason"
              Block
                 Source: "{\r\n                migrationAgent = migrationAgentCandidate;\r\n                require(migrationAgent.call.gas(3000000).value(this.balance)());\r\n                delete migrationAgentCandidate;\r\n                state = State.Migration;\r\n            }"
                ExpressionStatement
                   Gas costs: 20503
                   Source: "migrationAgent = migrationAgentCandidate"
                  Assignment using operator =
                     Type: address
                     Source: "migrationAgent = migrationAgentCandidate"
                    Identifier migrationAgent
                       Type: address
                       Source: "migrationAgent"
                    Identifier migrationAgentCandidate
                       Type: address
                       Source: "migrationAgentCandidate"
                ExpressionStatement
                   Gas costs: [???]
                   Source: "require(migrationAgent.call.gas(3000000).value(this.balance)())"
                  FunctionCall
                     Type: tuple()
                     Source: "require(migrationAgent.call.gas(3000000).value(this.balance)())"
                    Identifier require
                       Type: function (bool) pure
                       Source: "require"
                    FunctionCall
                       Type: bool
                       Source: "migrationAgent.call.gas(3000000).value(this.balance)()"
                      FunctionCall
                         Type: function () payable returns (bool)
                         Source: "migrationAgent.call.gas(3000000).value(this.balance)"
                        MemberAccess to member value
                           Type: function (uint256) returns (function () payable returns (bool))
                           Source: "migrationAgent.call.gas(3000000).value"
                          FunctionCall
                             Type: function () payable returns (bool)
                             Source: "migrationAgent.call.gas(3000000)"
                            MemberAccess to member gas
                               Type: function (uint256) returns (function () payable returns (bool))
                               Source: "migrationAgent.call.gas"
                              MemberAccess to member call
                                 Type: function () payable returns (bool)
                                 Source: "migrationAgent.call"
                                Identifier migrationAgent
                                   Type: address
                                   Source: "migrationAgent"
                            Literal, token: [no token] value: 3000000
                               Type: int_const 3000000
                               Source: "3000000"
                        MemberAccess to member balance
                           Type: uint256
                           Source: "this.balance"
                          Identifier this
                             Type: contract ProofVote
                             Source: "this"
                ExpressionStatement
                   Gas costs: 20242
                   Source: "delete migrationAgentCandidate"
                  UnaryOperation (prefix) delete
                     Type: tuple()
                     Source: "delete migrationAgentCandidate"
                    Identifier migrationAgentCandidate
                       Type: address
                       Source: "migrationAgentCandidate"
                ExpressionStatement
                   Gas costs: 20287
                   Source: "state = State.Migration"
                  Assignment using operator =
                     Type: enum Crowdsale.State
                     Source: "state = State.Migration"
                    Identifier state
                       Type: enum Crowdsale.State
                       Source: "state"
                    MemberAccess to member Migration
                       Type: enum Crowdsale.State
                       Source: "State.Migration"
                      Identifier State
                         Type: type(enum Crowdsale.State)
                         Source: "State"
              IfStatement
                 Source: "if (voteReason == VoteReason.UpdateContract) {\r\n                externalControllers[externalControllerCandidate] = true;\r\n                delete externalControllerCandidate;\r\n            }"
                BinaryOperation using operator ==
                   Type: bool
                   Gas costs: 297
                   Source: "voteReason == VoteReason.UpdateContract"
                  Identifier voteReason
                     Type: enum ProofVote.VoteReason
                     Source: "voteReason"
                  MemberAccess to member UpdateContract
                     Type: enum ProofVote.VoteReason
                     Source: "VoteReason.UpdateContract"
                    Identifier VoteReason
                       Type: type(enum ProofVote.VoteReason)
                       Source: "VoteReason"
                Block
                   Source: "{\r\n                externalControllers[externalControllerCandidate] = true;\r\n                delete externalControllerCandidate;\r\n            }"
                  ExpressionStatement
                     Gas costs: 20599
                     Source: "externalControllers[externalControllerCandidate] = true"
                    Assignment using operator =
                       Type: bool
                       Source: "externalControllers[externalControllerCandidate] = true"
                      IndexAccess
                         Type: bool
                         Source: "externalControllers[externalControllerCandidate]"
                        Identifier externalControllers
                           Type: mapping(address => bool)
                           Source: "externalControllers"
                        Identifier externalControllerCandidate
                           Type: address
                           Source: "externalControllerCandidate"
                      Literal, token: true value: true
                         Type: bool
                         Source: "true"
                  ExpressionStatement
                     Gas costs: 20242
                     Source: "delete externalControllerCandidate"
                    UnaryOperation (prefix) delete
                       Type: tuple()
                       Source: "delete externalControllerCandidate"
                      Identifier externalControllerCandidate
                         Type: address
                         Source: "externalControllerCandidate"
      ExpressionStatement
         Gas costs: 20242
         Source: "delete voteReason"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete voteReason"
          Identifier voteReason
             Type: enum ProofVote.VoteReason
             Source: "voteReason"
      ExpressionStatement
         Gas costs: [???]
         Source: "VotingFinished(_inSupport)"
        FunctionCall
           Type: tuple()
           Source: "VotingFinished(_inSupport)"
          Identifier VotingFinished
             Type: function (bool)
             Source: "VotingFinished"
          Identifier _inSupport
             Type: bool
             Source: "_inSupport"
ContractDefinition "MigrationAgent"
   Gas costs: 0
   Source: "contract MigrationAgent {\r\n    function migrateFrom(address _from, uint _value);\r\n}"
  FunctionDefinition "migrateFrom" - public
     Source: "function migrateFrom(address _from, uint _value);"
    ParameterList
       Source: "(address _from, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
ContractDefinition "TokenMigration"
   Source: "contract TokenMigration is ProofVote {\r\n    \r\n    uint public totalMigrated;\r\n\r\n    event Migrate(address indexed from, address indexed to, uint value);\r\n\r\n    function TokenMigration(address _migrationHost) payable ProofVote(_migrationHost) {}\r\n\r\n    // Migrate _value of tokens to the new token contract\r\n    function migrate() external {\r\n        require(state == State.Migration);\r\n        uint value = balances[msg.sender];\r\n        balances[msg.sender] -= value;\r\n        Transfer(msg.sender, this, value);\r\n        totalSupply -= value;\r\n        totalMigrated += value;\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);\r\n        Migrate(msg.sender, migrationAgent, value);\r\n    }\r\n\r\n    function setMigrationAgent(address _agent) external onlyOwner {\r\n        require(migrationAgent == 0 && _agent != 0);\r\n        migrationAgentCandidate = _agent;\r\n        internalStartVoting(0, VoteReason.Migration, 2);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ProofVote"
    UserDefinedTypeName "ProofVote"
       Source: "ProofVote"
  VariableDeclaration "totalMigrated"
     Type: uint256
     Gas costs: [???]
     Source: "uint public totalMigrated"
    ElementaryTypeName uint
       Source: "uint"
  EventDefinition "Migrate"
     Gas costs: 0
     Source: "event Migrate(address indexed from, address indexed to, uint value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "TokenMigration" - public
     Source: "function TokenMigration(address _migrationHost) payable ProofVote(_migrationHost) {}"
    ParameterList
       Gas costs: 0
       Source: "(address _migrationHost)"
      VariableDeclaration "_migrationHost"
         Type: address
         Source: "address _migrationHost"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ProofVote"
       Gas costs: 0
       Source: "ProofVote(_migrationHost)"
      Identifier ProofVote
         Type: type(contract ProofVote)
         Source: "ProofVote"
      Identifier _migrationHost
         Type: address
         Source: "_migrationHost"
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "migrate" - public
     Source: "function migrate() external {\r\n        require(state == State.Migration);\r\n        uint value = balances[msg.sender];\r\n        balances[msg.sender] -= value;\r\n        Transfer(msg.sender, this, value);\r\n        totalSupply -= value;\r\n        totalMigrated += value;\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);\r\n        Migrate(msg.sender, migrationAgent, value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(state == State.Migration);\r\n        uint value = balances[msg.sender];\r\n        balances[msg.sender] -= value;\r\n        Transfer(msg.sender, this, value);\r\n        totalSupply -= value;\r\n        totalMigrated += value;\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);\r\n        Migrate(msg.sender, migrationAgent, value);\r\n    }"
      ExpressionStatement
         Gas costs: 323
         Source: "require(state == State.Migration)"
        FunctionCall
           Type: tuple()
           Source: "require(state == State.Migration)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "state == State.Migration"
            Identifier state
               Type: enum Crowdsale.State
               Source: "state"
            MemberAccess to member Migration
               Type: enum Crowdsale.State
               Source: "State.Migration"
              Identifier State
                 Type: type(enum Crowdsale.State)
                 Source: "State"
      VariableDeclarationStatement
         Gas costs: 306
         Source: "uint value = balances[msg.sender]"
        VariableDeclaration "value"
           Type: uint256
           Source: "uint value"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "balances[msg.sender]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 5322
         Source: "balances[msg.sender] -= value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[msg.sender] -= value"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier value
             Type: uint256
             Source: "value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, this, value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, this, value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier this
             Type: contract TokenMigration
             Source: "this"
          Identifier value
             Type: uint256
             Source: "value"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply -= value"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= value"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier value
             Type: uint256
             Source: "value"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalMigrated += value"
        Assignment using operator +=
           Type: uint256
           Source: "totalMigrated += value"
          Identifier totalMigrated
             Type: uint256
             Source: "totalMigrated"
          Identifier value
             Type: uint256
             Source: "value"
      ExpressionStatement
         Gas costs: [???]
         Source: "MigrationAgent(migrationAgent).migrateFrom(msg.sender, value)"
        FunctionCall
           Type: tuple()
           Source: "MigrationAgent(migrationAgent).migrateFrom(msg.sender, value)"
          MemberAccess to member migrateFrom
             Type: function (address,uint256) external
             Source: "MigrationAgent(migrationAgent).migrateFrom"
            FunctionCall
               Type: contract MigrationAgent
               Source: "MigrationAgent(migrationAgent)"
              Identifier MigrationAgent
                 Type: type(contract MigrationAgent)
                 Source: "MigrationAgent"
              Identifier migrationAgent
                 Type: address
                 Source: "migrationAgent"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier value
             Type: uint256
             Source: "value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Migrate(msg.sender, migrationAgent, value)"
        FunctionCall
           Type: tuple()
           Source: "Migrate(msg.sender, migrationAgent, value)"
          Identifier Migrate
             Type: function (address,address,uint256)
             Source: "Migrate"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier migrationAgent
             Type: address
             Source: "migrationAgent"
          Identifier value
             Type: uint256
             Source: "value"
  FunctionDefinition "setMigrationAgent" - public
     Source: "function setMigrationAgent(address _agent) external onlyOwner {\r\n        require(migrationAgent == 0 && _agent != 0);\r\n        migrationAgentCandidate = _agent;\r\n        internalStartVoting(0, VoteReason.Migration, 2);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _agent)"
      VariableDeclaration "_agent"
         Type: address
         Source: "address _agent"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(migrationAgent == 0 && _agent != 0);\r\n        migrationAgentCandidate = _agent;\r\n        internalStartVoting(0, VoteReason.Migration, 2);\r\n    }"
      ExpressionStatement
         Gas costs: 317
         Source: "require(migrationAgent == 0 && _agent != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(migrationAgent == 0 && _agent != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "migrationAgent == 0 && _agent != 0"
            BinaryOperation using operator ==
               Type: bool
               Source: "migrationAgent == 0"
              Identifier migrationAgent
                 Type: address
                 Source: "migrationAgent"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator !=
               Type: bool
               Source: "_agent != 0"
              Identifier _agent
                 Type: address
                 Source: "_agent"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "migrationAgentCandidate = _agent"
        Assignment using operator =
           Type: address
           Source: "migrationAgentCandidate = _agent"
          Identifier migrationAgentCandidate
             Type: address
             Source: "migrationAgentCandidate"
          Identifier _agent
             Type: address
             Source: "_agent"
      ExpressionStatement
         Gas costs: 24
         Source: "internalStartVoting(0, VoteReason.Migration, 2)"
        FunctionCall
           Type: tuple()
           Source: "internalStartVoting(0, VoteReason.Migration, 2)"
          Identifier internalStartVoting
             Type: function (uint256,enum ProofVote.VoteReason,uint256)
             Source: "internalStartVoting"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          MemberAccess to member Migration
             Type: enum ProofVote.VoteReason
             Source: "VoteReason.Migration"
            Identifier VoteReason
               Type: type(enum ProofVote.VoteReason)
               Source: "VoteReason"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
ContractDefinition "ProofFund"
   Source: "contract ProofFund is TokenMigration {\r\n\r\n    function ProofFund(address _migrationHost)\r\n        payable TokenMigration(_migrationHost) {}\r\n\r\n    function addExternalController(address _externalControllerCandidate) public onlyOwner {\r\n        require(_externalControllerCandidate != 0);\r\n        externalControllerCandidate = _externalControllerCandidate;\r\n        internalStartVoting(0, VoteReason.UpdateContract, 2);\r\n    }\r\n\r\n    function removeExternalController(address _externalController) public onlyOwner {\r\n        delete externalControllers[_externalController];\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "TokenMigration"
    UserDefinedTypeName "TokenMigration"
       Source: "TokenMigration"
  FunctionDefinition "ProofFund" - public
     Source: "function ProofFund(address _migrationHost)\r\n        payable TokenMigration(_migrationHost) {}"
    ParameterList
       Gas costs: 0
       Source: "(address _migrationHost)"
      VariableDeclaration "_migrationHost"
         Type: address
         Source: "address _migrationHost"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "TokenMigration"
       Gas costs: 0
       Source: "TokenMigration(_migrationHost)"
      Identifier TokenMigration
         Type: type(contract TokenMigration)
         Source: "TokenMigration"
      Identifier _migrationHost
         Type: address
         Source: "_migrationHost"
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "addExternalController" - public
     Source: "function addExternalController(address _externalControllerCandidate) public onlyOwner {\r\n        require(_externalControllerCandidate != 0);\r\n        externalControllerCandidate = _externalControllerCandidate;\r\n        internalStartVoting(0, VoteReason.UpdateContract, 2);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _externalControllerCandidate)"
      VariableDeclaration "_externalControllerCandidate"
         Type: address
         Source: "address _externalControllerCandidate"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_externalControllerCandidate != 0);\r\n        externalControllerCandidate = _externalControllerCandidate;\r\n        internalStartVoting(0, VoteReason.UpdateContract, 2);\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "require(_externalControllerCandidate != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_externalControllerCandidate != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_externalControllerCandidate != 0"
            Identifier _externalControllerCandidate
               Type: address
               Source: "_externalControllerCandidate"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "externalControllerCandidate = _externalControllerCandidate"
        Assignment using operator =
           Type: address
           Source: "externalControllerCandidate = _externalControllerCandidate"
          Identifier externalControllerCandidate
             Type: address
             Source: "externalControllerCandidate"
          Identifier _externalControllerCandidate
             Type: address
             Source: "_externalControllerCandidate"
      ExpressionStatement
         Gas costs: 24
         Source: "internalStartVoting(0, VoteReason.UpdateContract, 2)"
        FunctionCall
           Type: tuple()
           Source: "internalStartVoting(0, VoteReason.UpdateContract, 2)"
          Identifier internalStartVoting
             Type: function (uint256,enum ProofVote.VoteReason,uint256)
             Source: "internalStartVoting"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          MemberAccess to member UpdateContract
             Type: enum ProofVote.VoteReason
             Source: "VoteReason.UpdateContract"
            Identifier VoteReason
               Type: type(enum ProofVote.VoteReason)
               Source: "VoteReason"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
  FunctionDefinition "removeExternalController" - public
     Source: "function removeExternalController(address _externalController) public onlyOwner {\r\n        delete externalControllers[_externalController];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _externalController)"
      VariableDeclaration "_externalController"
         Type: address
         Source: "address _externalController"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        delete externalControllers[_externalController];\r\n    }"
      ExpressionStatement
         Gas costs: 20338
         Source: "delete externalControllers[_externalController]"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete externalControllers[_externalController]"
          IndexAccess
             Type: bool
             Source: "externalControllers[_externalController]"
            Identifier externalControllers
               Type: mapping(address => bool)
               Source: "externalControllers"
            Identifier _externalController
               Type: address
               Source: "_externalController"
ContractDefinition "ProofAbstract"
   Gas costs: 0
   Source: "contract ProofAbstract {\r\n    function swypeCode(address _who) returns (uint16 _swype);\r\n    function setHash(address _who, uint16 _swype, bytes32 _hash);\r\n}"
  FunctionDefinition "swypeCode" - public
     Source: "function swypeCode(address _who) returns (uint16 _swype);"
    ParameterList
       Source: "(address _who)"
      VariableDeclaration "_who"
         Type: address
         Source: "address _who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint16 _swype)"
      VariableDeclaration "_swype"
         Type: uint16
         Source: "uint16 _swype"
        ElementaryTypeName uint16
           Source: "uint16"
  FunctionDefinition "setHash" - public
     Source: "function setHash(address _who, uint16 _swype, bytes32 _hash);"
    ParameterList
       Source: "(address _who, uint16 _swype, bytes32 _hash)"
      VariableDeclaration "_who"
         Type: address
         Source: "address _who"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_swype"
         Type: uint16
         Source: "uint16 _swype"
        ElementaryTypeName uint16
           Source: "uint16"
      VariableDeclaration "_hash"
         Type: bytes32
         Source: "bytes32 _hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Source: ""
ContractDefinition "Proof"
   Source: "contract Proof is ProofFund {\r\n\r\n    uint    public priceInTokens;\r\n    uint    public teamFee;\r\n    address public proofImpl;\r\n\r\n    function Proof(address _migrationHost)\r\n        payable ProofFund(_migrationHost) {}\r\n\r\n    function setPrice(uint _priceInTokens) public onlyOwner {\r\n        require(_priceInTokens >= 2);\r\n        teamFee = _priceInTokens / 10;\r\n        if (teamFee == 0) {\r\n            teamFee = 1;\r\n        }\r\n        priceInTokens = _priceInTokens - teamFee;\r\n    }\r\n\r\n    function setProofImpl(address _proofImpl) public onlyOwner {\r\n        proofImpl = _proofImpl;\r\n    }\r\n\r\n    function swypeCode() public returns (uint16 _swype) {\r\n        require(proofImpl != 0);\r\n        _swype = ProofAbstract(proofImpl).swypeCode(msg.sender);\r\n    }\r\n    \r\n    function setHash(uint16 _swype, bytes32 _hash) public {\r\n        require(proofImpl != 0);\r\n        transfer(owner, teamFee);\r\n        transfer(this, priceInTokens);\r\n        ProofAbstract(proofImpl).setHash(msg.sender, _swype, _hash);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ProofFund"
    UserDefinedTypeName "ProofFund"
       Source: "ProofFund"
  VariableDeclaration "priceInTokens"
     Type: uint256
     Gas costs: [???]
     Source: "uint    public priceInTokens"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "teamFee"
     Type: uint256
     Gas costs: [???]
     Source: "uint    public teamFee"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "proofImpl"
     Type: address
     Gas costs: [???]
     Source: "address public proofImpl"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "Proof" - public
     Source: "function Proof(address _migrationHost)\r\n        payable ProofFund(_migrationHost) {}"
    ParameterList
       Gas costs: 0
       Source: "(address _migrationHost)"
      VariableDeclaration "_migrationHost"
         Type: address
         Source: "address _migrationHost"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ProofFund"
       Gas costs: 0
       Source: "ProofFund(_migrationHost)"
      Identifier ProofFund
         Type: type(contract ProofFund)
         Source: "ProofFund"
      Identifier _migrationHost
         Type: address
         Source: "_migrationHost"
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "setPrice" - public
     Source: "function setPrice(uint _priceInTokens) public onlyOwner {\r\n        require(_priceInTokens >= 2);\r\n        teamFee = _priceInTokens / 10;\r\n        if (teamFee == 0) {\r\n            teamFee = 1;\r\n        }\r\n        priceInTokens = _priceInTokens - teamFee;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _priceInTokens)"
      VariableDeclaration "_priceInTokens"
         Type: uint256
         Source: "uint _priceInTokens"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_priceInTokens >= 2);\r\n        teamFee = _priceInTokens / 10;\r\n        if (teamFee == 0) {\r\n            teamFee = 1;\r\n        }\r\n        priceInTokens = _priceInTokens - teamFee;\r\n    }"
      ExpressionStatement
         Gas costs: 38
         Source: "require(_priceInTokens >= 2)"
        FunctionCall
           Type: tuple()
           Source: "require(_priceInTokens >= 2)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "_priceInTokens >= 2"
            Identifier _priceInTokens
               Type: uint256
               Source: "_priceInTokens"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
      ExpressionStatement
         Gas costs: 20045
         Source: "teamFee = _priceInTokens / 10"
        Assignment using operator =
           Type: uint256
           Source: "teamFee = _priceInTokens / 10"
          Identifier teamFee
             Type: uint256
             Source: "teamFee"
          BinaryOperation using operator /
             Type: uint256
             Source: "_priceInTokens / 10"
            Identifier _priceInTokens
               Type: uint256
               Source: "_priceInTokens"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
      IfStatement
         Source: "if (teamFee == 0) {\r\n            teamFee = 1;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 209
           Source: "teamFee == 0"
          Identifier teamFee
             Type: uint256
             Source: "teamFee"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            teamFee = 1;\r\n        }"
          ExpressionStatement
             Gas costs: 20014
             Source: "teamFee = 1"
            Assignment using operator =
               Type: uint256
               Source: "teamFee = 1"
              Identifier teamFee
                 Type: uint256
                 Source: "teamFee"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      ExpressionStatement
         Gas costs: 20220
         Source: "priceInTokens = _priceInTokens - teamFee"
        Assignment using operator =
           Type: uint256
           Source: "priceInTokens = _priceInTokens - teamFee"
          Identifier priceInTokens
             Type: uint256
             Source: "priceInTokens"
          BinaryOperation using operator -
             Type: uint256
             Source: "_priceInTokens - teamFee"
            Identifier _priceInTokens
               Type: uint256
               Source: "_priceInTokens"
            Identifier teamFee
               Type: uint256
               Source: "teamFee"
  FunctionDefinition "setProofImpl" - public
     Source: "function setProofImpl(address _proofImpl) public onlyOwner {\r\n        proofImpl = _proofImpl;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _proofImpl)"
      VariableDeclaration "_proofImpl"
         Type: address
         Source: "address _proofImpl"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        proofImpl = _proofImpl;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "proofImpl = _proofImpl"
        Assignment using operator =
           Type: address
           Source: "proofImpl = _proofImpl"
          Identifier proofImpl
             Type: address
             Source: "proofImpl"
          Identifier _proofImpl
             Type: address
             Source: "_proofImpl"
  FunctionDefinition "swypeCode" - public
     Source: "function swypeCode() public returns (uint16 _swype) {\r\n        require(proofImpl != 0);\r\n        _swype = ProofAbstract(proofImpl).swypeCode(msg.sender);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint16 _swype)"
      VariableDeclaration "_swype"
         Type: uint16
         Source: "uint16 _swype"
        ElementaryTypeName uint16
           Source: "uint16"
    Block
       Source: "{\r\n        require(proofImpl != 0);\r\n        _swype = ProofAbstract(proofImpl).swypeCode(msg.sender);\r\n    }"
      ExpressionStatement
         Gas costs: 280
         Source: "require(proofImpl != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(proofImpl != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "proofImpl != 0"
            Identifier proofImpl
               Type: address
               Source: "proofImpl"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "_swype = ProofAbstract(proofImpl).swypeCode(msg.sender)"
        Assignment using operator =
           Type: uint16
           Source: "_swype = ProofAbstract(proofImpl).swypeCode(msg.sender)"
          Identifier _swype
             Type: uint16
             Source: "_swype"
          FunctionCall
             Type: uint16
             Source: "ProofAbstract(proofImpl).swypeCode(msg.sender)"
            MemberAccess to member swypeCode
               Type: function (address) external returns (uint16)
               Source: "ProofAbstract(proofImpl).swypeCode"
              FunctionCall
                 Type: contract ProofAbstract
                 Source: "ProofAbstract(proofImpl)"
                Identifier ProofAbstract
                   Type: type(contract ProofAbstract)
                   Source: "ProofAbstract"
                Identifier proofImpl
                   Type: address
                   Source: "proofImpl"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "setHash" - public
     Source: "function setHash(uint16 _swype, bytes32 _hash) public {\r\n        require(proofImpl != 0);\r\n        transfer(owner, teamFee);\r\n        transfer(this, priceInTokens);\r\n        ProofAbstract(proofImpl).setHash(msg.sender, _swype, _hash);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint16 _swype, bytes32 _hash)"
      VariableDeclaration "_swype"
         Type: uint16
         Source: "uint16 _swype"
        ElementaryTypeName uint16
           Source: "uint16"
      VariableDeclaration "_hash"
         Type: bytes32
         Source: "bytes32 _hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(proofImpl != 0);\r\n        transfer(owner, teamFee);\r\n        transfer(this, priceInTokens);\r\n        ProofAbstract(proofImpl).setHash(msg.sender, _swype, _hash);\r\n    }"
      ExpressionStatement
         Gas costs: 280
         Source: "require(proofImpl != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(proofImpl != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "proofImpl != 0"
            Identifier proofImpl
               Type: address
               Source: "proofImpl"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 457
         Source: "transfer(owner, teamFee)"
        FunctionCall
           Type: tuple()
           Source: "transfer(owner, teamFee)"
          Identifier transfer
             Type: function (address,uint256)
             Source: "transfer"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier teamFee
             Type: uint256
             Source: "teamFee"
      ExpressionStatement
         Gas costs: 220
         Source: "transfer(this, priceInTokens)"
        FunctionCall
           Type: tuple()
           Source: "transfer(this, priceInTokens)"
          Identifier transfer
             Type: function (address,uint256)
             Source: "transfer"
          Identifier this
             Type: contract Proof
             Source: "this"
          Identifier priceInTokens
             Type: uint256
             Source: "priceInTokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "ProofAbstract(proofImpl).setHash(msg.sender, _swype, _hash)"
        FunctionCall
           Type: tuple()
           Source: "ProofAbstract(proofImpl).setHash(msg.sender, _swype, _hash)"
          MemberAccess to member setHash
             Type: function (address,uint16,bytes32) external
             Source: "ProofAbstract(proofImpl).setHash"
            FunctionCall
               Type: contract ProofAbstract
               Source: "ProofAbstract(proofImpl)"
              Identifier ProofAbstract
                 Type: type(contract ProofAbstract)
                 Source: "ProofAbstract"
              Identifier proofImpl
                 Type: address
                 Source: "proofImpl"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _swype
             Type: uint16
             Source: "_swype"
          Identifier _hash
             Type: bytes32
             Source: "_hash"
