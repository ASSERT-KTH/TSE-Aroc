Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x7c9d1395d34bab13d734a78a2ed2476c3dfb038d.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}"
  FunctionDefinition "mul" - const
     Source: "function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div" - const
     Source: "function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub" - const
     Source: "function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        assert(b <= a);\r\n        return a - b;\r\n    }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add" - const
     Source: "function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "Ownable"
   Source: "contract Ownable {\r\n    address public owner;\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "Ownable" - public
     Source: "function Ownable() {\r\n        owner = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 1128
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(newOwner != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(newOwner != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "newOwner != address(0)"
            Identifier newOwner
               Type: address
               Source: "newOwner"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
ContractDefinition "ERC20Basic"
   Gas costs: 0
   Source: "contract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) constant returns (uint256);\r\n    function transfer(address to, uint256 value) returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) constant returns (uint256);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint256 value) returns (bool);"
    ParameterList
       Source: "(address to, uint256 value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "ERC20"
   Gas costs: 0
   Source: "contract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) constant returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) returns (bool);\r\n    function approve(address spender, uint256 value) returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
  InheritanceSpecifier
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) constant returns (uint256);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint256 value) returns (bool);"
    ParameterList
       Source: "(address from, address to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint256 value) returns (bool);"
    ParameterList
       Source: "(address spender, uint256 value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint256 value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint256 value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "PassiveTokenStandard"
   Gas costs: 0
   Source: "contract PassiveTokenStandard {\r\n    uint256 public stakeStartTime;\r\n    uint256 public stakeMinAge;\r\n    uint256 public stakeMaxAge;\r\n    function mint() returns (bool);\r\n    function coinAge() constant returns (uint256);\r\n    function annualInterest() constant returns (uint256);\r\n    event Mint(address indexed _address, uint _reward);\r\n}"
  VariableDeclaration "stakeStartTime"
     Type: uint256
     Source: "uint256 public stakeStartTime"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "stakeMinAge"
     Type: uint256
     Source: "uint256 public stakeMinAge"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "stakeMaxAge"
     Type: uint256
     Source: "uint256 public stakeMaxAge"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "mint" - public
     Source: "function mint() returns (bool);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "coinAge" - public - const
     Source: "function coinAge() constant returns (uint256);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "annualInterest" - public - const
     Source: "function annualInterest() constant returns (uint256);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Mint"
     Source: "event Mint(address indexed _address, uint _reward);"
    ParameterList
       Source: "(address indexed _address, uint _reward)"
      VariableDeclaration "_address"
         Type: address
         Source: "address indexed _address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_reward"
         Type: uint256
         Source: "uint _reward"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "PassiveToken"
   Source: "contract PassiveToken is ERC20,PassiveTokenStandard,Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    string public name = \"PassiveToken\";\r\n    string public symbol = \"PAT\";\r\n    uint public decimals = 18;\r\n\r\n    uint public chainStartTime; //chain start time\r\n    uint public chainStartBlockNumber; //chain start block number\r\n    uint public stakeStartTime; //stake start time\r\n    uint public stakeMinAge = 1 days; // minimum age for coin age: 1D\r\n    uint public stakeMaxAge = 365 days; // stake age of full weight: 365D\r\n    uint public maxMintProofOfStake = 10**17; // default 10% annual interest\r\n\r\n    uint public totalSupply;\r\n    uint public maxTotalSupply;\r\n    uint public totalInitialSupply;\r\n\r\n    struct transferInStruct{\r\n    uint128 amount;\r\n    uint64 time;\r\n    }\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n    mapping(address => transferInStruct[]) transferIns;\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    /**\r\n     * @dev Fix for the ERC20 short address attack.\r\n     */\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    modifier canPassiveMint() {\r\n        require(totalSupply < maxTotalSupply);\r\n        _;\r\n    }\r\n\r\n    function PassiveToken() {\r\n        maxTotalSupply = 10**25; // 10 Mil.\r\n        totalInitialSupply = 10**24; // 1 Mil.\r\n\r\n        chainStartTime = now;\r\n        chainStartBlockNumber = block.number;\r\n\r\n        balances[msg.sender] = totalInitialSupply;\r\n        totalSupply = totalInitialSupply;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool) {\r\n        if(msg.sender == _to) return mint();\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];\r\n        uint64 _now = uint64(now);\r\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));\r\n        transferIns[_to].push(transferInStruct(uint128(_value),_now));\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        var _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // require (_value <= _allowance);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        if(transferIns[_from].length > 0) delete transferIns[_from];\r\n        uint64 _now = uint64(now);\r\n        transferIns[_from].push(transferInStruct(uint128(balances[_from]),_now));\r\n        transferIns[_to].push(transferInStruct(uint128(_value),_now));\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool) {\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function mint() canPassiveMint returns (bool) {\r\n        if(balances[msg.sender] <= 0) return false;\r\n        if(transferIns[msg.sender].length <= 0) return false;\r\n\r\n        uint reward = getProofOfStakeReward(msg.sender);\r\n        if(reward <= 0) return false;\r\n\r\n        totalSupply = totalSupply.add(reward);\r\n        balances[msg.sender] = balances[msg.sender].add(reward);\r\n        delete transferIns[msg.sender];\r\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));\r\n\r\n        Mint(msg.sender, reward);\r\n        return true;\r\n    }\r\n\r\n    function getBlockNumber() returns (uint blockNumber) {\r\n        blockNumber = block.number.sub(chainStartBlockNumber);\r\n    }\r\n\r\n    function coinAge() constant returns (uint myCoinAge) {\r\n        myCoinAge = getCoinAge(msg.sender,now);\r\n    }\r\n\r\n    function annualInterest() constant returns(uint interest) {\r\n        uint _now = now;\r\n        interest = maxMintProofOfStake;\r\n        if((_now.sub(stakeStartTime)).div(99 years) == 0) {\r\n            interest = (3650 * maxMintProofOfStake).div(100);\r\n        } else if((_now.sub(stakeStartTime)).div(99 years) == 1){\r\n            interest = (3640 * maxMintProofOfStake).div(100);\r\n        }\r\n    }\r\n\r\n    function getProofOfStakeReward(address _address) internal returns (uint) {\r\n        require( (now >= stakeStartTime) && (stakeStartTime > 0) );\r\n\r\n        uint _now = now;\r\n        uint _coinAge = getCoinAge(_address, _now);\r\n        if(_coinAge <= 0) return 0;\r\n\r\n        uint interest = maxMintProofOfStake;\r\n        if((_now.sub(stakeStartTime)).div(99 years) == 0) {\r\n            // first 99 years 365% POS interest\r\n            interest = (3650 * maxMintProofOfStake).div(100);\r\n        } else if((_now.sub(stakeStartTime)).div(99 years) == 1){\r\n            // 2nd 99 Years 364% POS INTEREST\r\n            interest = (3640 * maxMintProofOfStake).div(100);\r\n        }\r\n\t\t\t//after 198 years 10% POS INTEREST\r\n        return (_coinAge * interest).div(365 * (10**decimals));\r\n    }\r\n\r\n    function getCoinAge(address _address, uint _now) internal returns (uint _coinAge) {\r\n        if(transferIns[_address].length <= 0) return 0;\r\n\r\n        for (uint i = 0; i < transferIns[_address].length; i++){\r\n            if( _now < uint(transferIns[_address][i].time).add(stakeMinAge) ) continue;\r\n\r\n            uint nCoinSeconds = _now.sub(uint(transferIns[_address][i].time));\r\n            if( nCoinSeconds > stakeMaxAge ) nCoinSeconds = stakeMaxAge;\r\n\r\n            _coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days));\r\n        }\r\n    }\r\n\r\n    function ownerSetStakeStartTime(uint timestamp) onlyOwner {\r\n        require((stakeStartTime <= 0) && (timestamp >= chainStartTime));\r\n        stakeStartTime = timestamp;\r\n    }\r\n\r\n    function ownerBurnToken(uint _value) onlyOwner {\r\n        require(_value > 0);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        delete transferIns[msg.sender];\r\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));\r\n\r\n        totalSupply = totalSupply.sub(_value);\r\n        totalInitialSupply = totalInitialSupply.sub(_value);\r\n        maxTotalSupply = maxTotalSupply.sub(_value*10);\r\n\r\n        Burn(msg.sender, _value);\r\n    }\r\n\r\n    /* Batch token transfer. Used by contract creator to distribute initial tokens to holders */\r\n    function batchTransfer(address[] _recipients, uint[] _values) onlyOwner returns (bool) {\r\n        require( _recipients.length > 0 && _recipients.length == _values.length);\r\n\r\n        uint total = 0;\r\n        for(uint i = 0; i < _values.length; i++){\r\n            total = total.add(_values[i]);\r\n        }\r\n        require(total <= balances[msg.sender]);\r\n\r\n        uint64 _now = uint64(now);\r\n        for(uint j = 0; j < _recipients.length; j++){\r\n            balances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);\r\n            transferIns[_recipients[j]].push(transferInStruct(uint128(_values[j]),_now));\r\n            Transfer(msg.sender, _recipients[j], _values[j]);\r\n        }\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(total);\r\n        if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];\r\n        if(balances[msg.sender] > 0) transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));\r\n\r\n        return true;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  InheritanceSpecifier
     Gas costs: 0
     Source: "PassiveTokenStandard"
    UserDefinedTypeName "PassiveTokenStandard"
       Source: "PassiveTokenStandard"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public name = \"PassiveToken\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: PassiveToken
       Type: literal_string "PassiveToken"
       Source: "\"PassiveToken\""
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public symbol = \"PAT\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: PAT
       Type: literal_string "PAT"
       Source: "\"PAT\""
  VariableDeclaration "decimals"
     Type: uint256
     Gas costs: [???]
     Source: "uint public decimals = 18"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "chainStartTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint public chainStartTime"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "chainStartBlockNumber"
     Type: uint256
     Gas costs: [???]
     Source: "uint public chainStartBlockNumber"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "stakeStartTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint public stakeStartTime"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "stakeMinAge"
     Type: uint256
     Gas costs: [???]
     Source: "uint public stakeMinAge = 1 days"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1
       Type: int_const 86400
       Source: "1 days"
  VariableDeclaration "stakeMaxAge"
     Type: uint256
     Gas costs: [???]
     Source: "uint public stakeMaxAge = 365 days"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 365
       Type: int_const 31536000
       Source: "365 days"
  VariableDeclaration "maxMintProofOfStake"
     Type: uint256
     Gas costs: [???]
     Source: "uint public maxMintProofOfStake = 10**17"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator **
       Type: int_const 100000000000000000
       Source: "10**17"
      Literal, token: [no token] value: 10
         Type: int_const 10
         Source: "10"
      Literal, token: [no token] value: 17
         Type: int_const 17
         Source: "17"
  VariableDeclaration "totalSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint public totalSupply"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "maxTotalSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint public maxTotalSupply"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "totalInitialSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint public totalInitialSupply"
    ElementaryTypeName uint
       Source: "uint"
  StructDefinition "transferInStruct"
     Gas costs: 0
     Source: "struct transferInStruct{\r\n    uint128 amount;\r\n    uint64 time;\r\n    }"
    VariableDeclaration "amount"
       Type: uint128
       Source: "uint128 amount"
      ElementaryTypeName uint128
         Source: "uint128"
    VariableDeclaration "time"
       Type: uint64
       Source: "uint64 time"
      ElementaryTypeName uint64
         Source: "uint64"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) balances"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping(address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping(address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "transferIns"
     Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
     Gas costs: 0
     Source: "mapping(address => transferInStruct[]) transferIns"
    Mapping
       Source: "mapping(address => transferInStruct[])"
      ElementaryTypeName address
         Source: "address"
      ArrayTypeName
         Source: "transferInStruct[]"
        UserDefinedTypeName "transferInStruct"
           Source: "transferInStruct"
  EventDefinition "Burn"
     Gas costs: 0
     Source: "event Burn(address indexed burner, uint256 value);"
    ParameterList
       Source: "(address indexed burner, uint256 value)"
      VariableDeclaration "burner"
         Type: address
         Source: "address indexed burner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  ModifierDefinition "onlyPayloadSize"
     Source: "modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint size)"
      VariableDeclaration "size"
         Type: uint256
         Source: "uint size"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 102
         Source: "require(msg.data.length >= size + 4)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.data.length >= size + 4)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.data.length >= size + 4"
            MemberAccess to member length
               Type: uint256
               Source: "msg.data.length"
              MemberAccess to member data
                 Type: bytes calldata
                 Source: "msg.data"
                Identifier msg
                   Type: msg
                   Source: "msg"
            BinaryOperation using operator +
               Type: uint256
               Source: "size + 4"
              Identifier size
                 Type: uint256
                 Source: "size"
              Literal, token: [no token] value: 4
                 Type: int_const 4
                 Source: "4"
      PlaceholderStatement
         Gas costs: 1
         Source: "_"
  ModifierDefinition "canPassiveMint"
     Source: "modifier canPassiveMint() {\r\n        require(totalSupply < maxTotalSupply);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(totalSupply < maxTotalSupply);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 435
         Source: "require(totalSupply < maxTotalSupply)"
        FunctionCall
           Type: tuple()
           Source: "require(totalSupply < maxTotalSupply)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "totalSupply < maxTotalSupply"
            Identifier totalSupply
               Type: uint256
               Source: "totalSupply"
            Identifier maxTotalSupply
               Type: uint256
               Source: "maxTotalSupply"
      PlaceholderStatement
         Gas costs: 1
         Source: "_"
  FunctionDefinition "PassiveToken" - public
     Source: "function PassiveToken() {\r\n        maxTotalSupply = 10**25; // 10 Mil.\r\n        totalInitialSupply = 10**24; // 1 Mil.\r\n\r\n        chainStartTime = now;\r\n        chainStartBlockNumber = block.number;\r\n\r\n        balances[msg.sender] = totalInitialSupply;\r\n        totalSupply = totalInitialSupply;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        maxTotalSupply = 10**25; // 10 Mil.\r\n        totalInitialSupply = 10**24; // 1 Mil.\r\n\r\n        chainStartTime = now;\r\n        chainStartBlockNumber = block.number;\r\n\r\n        balances[msg.sender] = totalInitialSupply;\r\n        totalSupply = totalInitialSupply;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "maxTotalSupply = 10**25"
        Assignment using operator =
           Type: uint256
           Source: "maxTotalSupply = 10**25"
          Identifier maxTotalSupply
             Type: uint256
             Source: "maxTotalSupply"
          BinaryOperation using operator **
             Type: int_const 10000000000000000000000000
             Source: "10**25"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
            Literal, token: [no token] value: 25
               Type: int_const 25
               Source: "25"
      ExpressionStatement
         Gas costs: 0
         Source: "totalInitialSupply = 10**24"
        Assignment using operator =
           Type: uint256
           Source: "totalInitialSupply = 10**24"
          Identifier totalInitialSupply
             Type: uint256
             Source: "totalInitialSupply"
          BinaryOperation using operator **
             Type: int_const 1000000000000000000000000
             Source: "10**24"
            Literal, token: [no token] value: 10
               Type: int_const 10
               Source: "10"
            Literal, token: [no token] value: 24
               Type: int_const 24
               Source: "24"
      ExpressionStatement
         Gas costs: 0
         Source: "chainStartTime = now"
        Assignment using operator =
           Type: uint256
           Source: "chainStartTime = now"
          Identifier chainStartTime
             Type: uint256
             Source: "chainStartTime"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 0
         Source: "chainStartBlockNumber = block.number"
        Assignment using operator =
           Type: uint256
           Source: "chainStartBlockNumber = block.number"
          Identifier chainStartBlockNumber
             Type: uint256
             Source: "chainStartBlockNumber"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] = totalInitialSupply"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = totalInitialSupply"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier totalInitialSupply
             Type: uint256
             Source: "totalInitialSupply"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = totalInitialSupply"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = totalInitialSupply"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier totalInitialSupply
             Type: uint256
             Source: "totalInitialSupply"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool) {\r\n        if(msg.sender == _to) return mint();\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];\r\n        uint64 _now = uint64(now);\r\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));\r\n        transferIns[_to].push(transferInStruct(uint128(_value),_now));\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 3
       Source: "onlyPayloadSize(2 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 64
         Source: "2 * 32"
        Literal, token: [no token] value: 2
           Type: int_const 2
           Source: "2"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n        if(msg.sender == _to) return mint();\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];\r\n        uint64 _now = uint64(now);\r\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));\r\n        transferIns[_to].push(transferInStruct(uint128(_value),_now));\r\n        return true;\r\n    }"
      IfStatement
         Source: "if(msg.sender == _to) return mint()"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 20
           Source: "msg.sender == _to"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
        Return
           Gas costs: 31
           Source: "return mint()"
          FunctionCall
             Type: bool
             Source: "mint()"
            Identifier mint
               Type: function () returns (bool)
               Source: "mint"
      ExpressionStatement
         Gas costs: 20437
         Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "balances[msg.sender].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20433
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      IfStatement
         Source: "if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender]"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 306
           Source: "transferIns[msg.sender].length > 0"
          MemberAccess to member length
             Type: uint256
             Source: "transferIns[msg.sender].length"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[msg.sender]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 122
           Source: "delete transferIns[msg.sender]"
          UnaryOperation (prefix) delete
             Type: tuple()
             Source: "delete transferIns[msg.sender]"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[msg.sender]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint64 _now = uint64(now)"
        VariableDeclaration "_now"
           Type: uint64
           Source: "uint64 _now"
          ElementaryTypeName uint64
             Source: "uint64"
        FunctionCall
           Type: uint64
           Source: "uint64(now)"
          ElementaryTypeNameExpression uint64
             Type: type(uint64)
             Source: "uint64"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: [???]
         Source: "transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now))"
        FunctionCall
           Type: uint256
           Source: "transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now))"
          MemberAccess to member push
             Type: function (struct PassiveToken.transferInStruct storage ref) returns (uint256)
             Source: "transferIns[msg.sender].push"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[msg.sender]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          FunctionCall
             Type: struct PassiveToken.transferInStruct memory
             Source: "transferInStruct(uint128(balances[msg.sender]),_now)"
            Identifier transferInStruct
               Type: type(struct PassiveToken.transferInStruct storage pointer)
               Source: "transferInStruct"
            FunctionCall
               Type: uint128
               Source: "uint128(balances[msg.sender])"
              ElementaryTypeNameExpression uint128
                 Type: type(uint128)
                 Source: "uint128"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier _now
               Type: uint64
               Source: "_now"
      ExpressionStatement
         Gas costs: [???]
         Source: "transferIns[_to].push(transferInStruct(uint128(_value),_now))"
        FunctionCall
           Type: uint256
           Source: "transferIns[_to].push(transferInStruct(uint128(_value),_now))"
          MemberAccess to member push
             Type: function (struct PassiveToken.transferInStruct storage ref) returns (uint256)
             Source: "transferIns[_to].push"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[_to]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              Identifier _to
                 Type: address
                 Source: "_to"
          FunctionCall
             Type: struct PassiveToken.transferInStruct memory
             Source: "transferInStruct(uint128(_value),_now)"
            Identifier transferInStruct
               Type: type(struct PassiveToken.transferInStruct storage pointer)
               Source: "transferInStruct"
            FunctionCall
               Type: uint128
               Source: "uint128(_value)"
              ElementaryTypeNameExpression uint128
                 Type: type(uint128)
                 Source: "uint128"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            Identifier _now
               Type: uint64
               Source: "_now"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balances[_owner];\r\n    }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        var _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // require (_value <= _allowance);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        if(transferIns[_from].length > 0) delete transferIns[_from];\r\n        uint64 _now = uint64(now);\r\n        transferIns[_from].push(transferInStruct(uint128(balances[_from]),_now));\r\n        transferIns[_to].push(transferInStruct(uint128(_value),_now));\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 3
       Source: "onlyPayloadSize(3 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 96
         Source: "3 * 32"
        Literal, token: [no token] value: 3
           Type: int_const 3
           Source: "3"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n        require(_to != address(0));\r\n\r\n        var _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // require (_value <= _allowance);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        if(transferIns[_from].length > 0) delete transferIns[_from];\r\n        uint64 _now = uint64(now);\r\n        transferIns[_from].push(transferInStruct(uint128(balances[_from]),_now));\r\n        transferIns[_to].push(transferInStruct(uint128(_value),_now));\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(_to != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_to != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != address(0)"
            Identifier _to
               Type: address
               Source: "_to"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      VariableDeclarationStatement
         Gas costs: 396
         Source: "var _allowance = allowed[_from][msg.sender]"
        VariableDeclaration "_allowance"
           Type: uint256
           Source: "var _allowance"
        IndexAccess
           Type: uint256
           Source: "allowed[_from][msg.sender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_from]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _from
               Type: address
               Source: "_from"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20433
         Source: "balances[_from] = balances[_from].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_from] = balances[_from].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "balances[_from].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[_from].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20433
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20232
         Source: "allowed[_from][msg.sender] = _allowance.sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[_from][msg.sender] = _allowance.sub(_value)"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "_allowance.sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "_allowance.sub"
              Identifier _allowance
                 Type: uint256
                 Source: "_allowance"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      IfStatement
         Source: "if(transferIns[_from].length > 0) delete transferIns[_from]"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 307
           Source: "transferIns[_from].length > 0"
          MemberAccess to member length
             Type: uint256
             Source: "transferIns[_from].length"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[_from]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              Identifier _from
                 Type: address
                 Source: "_from"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 123
           Source: "delete transferIns[_from]"
          UnaryOperation (prefix) delete
             Type: tuple()
             Source: "delete transferIns[_from]"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[_from]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              Identifier _from
                 Type: address
                 Source: "_from"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint64 _now = uint64(now)"
        VariableDeclaration "_now"
           Type: uint64
           Source: "uint64 _now"
          ElementaryTypeName uint64
             Source: "uint64"
        FunctionCall
           Type: uint64
           Source: "uint64(now)"
          ElementaryTypeNameExpression uint64
             Type: type(uint64)
             Source: "uint64"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: [???]
         Source: "transferIns[_from].push(transferInStruct(uint128(balances[_from]),_now))"
        FunctionCall
           Type: uint256
           Source: "transferIns[_from].push(transferInStruct(uint128(balances[_from]),_now))"
          MemberAccess to member push
             Type: function (struct PassiveToken.transferInStruct storage ref) returns (uint256)
             Source: "transferIns[_from].push"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[_from]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              Identifier _from
                 Type: address
                 Source: "_from"
          FunctionCall
             Type: struct PassiveToken.transferInStruct memory
             Source: "transferInStruct(uint128(balances[_from]),_now)"
            Identifier transferInStruct
               Type: type(struct PassiveToken.transferInStruct storage pointer)
               Source: "transferInStruct"
            FunctionCall
               Type: uint128
               Source: "uint128(balances[_from])"
              ElementaryTypeNameExpression uint128
                 Type: type(uint128)
                 Source: "uint128"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
            Identifier _now
               Type: uint64
               Source: "_now"
      ExpressionStatement
         Gas costs: [???]
         Source: "transferIns[_to].push(transferInStruct(uint128(_value),_now))"
        FunctionCall
           Type: uint256
           Source: "transferIns[_to].push(transferInStruct(uint128(_value),_now))"
          MemberAccess to member push
             Type: function (struct PassiveToken.transferInStruct storage ref) returns (uint256)
             Source: "transferIns[_to].push"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[_to]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              Identifier _to
                 Type: address
                 Source: "_to"
          FunctionCall
             Type: struct PassiveToken.transferInStruct memory
             Source: "transferInStruct(uint128(_value),_now)"
            Identifier transferInStruct
               Type: type(struct PassiveToken.transferInStruct storage pointer)
               Source: "transferInStruct"
            FunctionCall
               Type: uint128
               Source: "uint128(_value)"
              ElementaryTypeNameExpression uint128
                 Type: type(uint128)
                 Source: "uint128"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            Identifier _now
               Type: uint64
               Source: "_now"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool) {\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 448
         Source: "require((_value == 0) || (allowed[msg.sender][_spender] == 0))"
        FunctionCall
           Type: tuple()
           Source: "require((_value == 0) || (allowed[msg.sender][_spender] == 0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "(_value == 0) || (allowed[msg.sender][_spender] == 0)"
            TupleExpression
               Type: bool
               Source: "(_value == 0)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "_value == 0"
                Identifier _value
                   Type: uint256
                   Source: "_value"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            TupleExpression
               Type: bool
               Source: "(allowed[msg.sender][_spender] == 0)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "allowed[msg.sender][_spender] == 0"
                IndexAccess
                   Type: uint256
                   Source: "allowed[msg.sender][_spender]"
                  IndexAccess
                     Type: mapping(address => uint256)
                     Source: "allowed[msg.sender]"
                    Identifier allowed
                       Type: mapping(address => mapping(address => uint256))
                       Source: "allowed"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                  Identifier _spender
                     Type: address
                     Source: "_spender"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  FunctionDefinition "mint" - public
     Source: "function mint() canPassiveMint returns (bool) {\r\n        if(balances[msg.sender] <= 0) return false;\r\n        if(transferIns[msg.sender].length <= 0) return false;\r\n\r\n        uint reward = getProofOfStakeReward(msg.sender);\r\n        if(reward <= 0) return false;\r\n\r\n        totalSupply = totalSupply.add(reward);\r\n        balances[msg.sender] = balances[msg.sender].add(reward);\r\n        delete transferIns[msg.sender];\r\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));\r\n\r\n        Mint(msg.sender, reward);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "canPassiveMint"
       Gas costs: 0
       Source: "canPassiveMint"
      Identifier canPassiveMint
         Type: modifier ()
         Source: "canPassiveMint"
    Block
       Source: "{\r\n        if(balances[msg.sender] <= 0) return false;\r\n        if(transferIns[msg.sender].length <= 0) return false;\r\n\r\n        uint reward = getProofOfStakeReward(msg.sender);\r\n        if(reward <= 0) return false;\r\n\r\n        totalSupply = totalSupply.add(reward);\r\n        balances[msg.sender] = balances[msg.sender].add(reward);\r\n        delete transferIns[msg.sender];\r\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));\r\n\r\n        Mint(msg.sender, reward);\r\n        return true;\r\n    }"
      IfStatement
         Source: "if(balances[msg.sender] <= 0) return false"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 307
           Source: "balances[msg.sender] <= 0"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      IfStatement
         Source: "if(transferIns[msg.sender].length <= 0) return false"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 315
           Source: "transferIns[msg.sender].length <= 0"
          MemberAccess to member length
             Type: uint256
             Source: "transferIns[msg.sender].length"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[msg.sender]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      VariableDeclarationStatement
         Gas costs: 14
         Source: "uint reward = getProofOfStakeReward(msg.sender)"
        VariableDeclaration "reward"
           Type: uint256
           Source: "uint reward"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getProofOfStakeReward(msg.sender)"
          Identifier getProofOfStakeReward
             Type: function (address) returns (uint256)
             Source: "getProofOfStakeReward"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if(reward <= 0) return false"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 12
           Source: "reward <= 0"
          Identifier reward
             Type: uint256
             Source: "reward"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 20247
         Source: "totalSupply = totalSupply.add(reward)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = totalSupply.add(reward)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "totalSupply.add(reward)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "totalSupply.add"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
            Identifier reward
               Type: uint256
               Source: "reward"
      ExpressionStatement
         Gas costs: 20437
         Source: "balances[msg.sender] = balances[msg.sender].add(reward)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = balances[msg.sender].add(reward)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "balances[msg.sender].add(reward)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[msg.sender].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier reward
               Type: uint256
               Source: "reward"
      ExpressionStatement
         Gas costs: 105
         Source: "delete transferIns[msg.sender]"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete transferIns[msg.sender]"
          IndexAccess
             Type: struct PassiveToken.transferInStruct storage ref[] storage ref
             Source: "transferIns[msg.sender]"
            Identifier transferIns
               Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
               Source: "transferIns"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: [???]
         Source: "transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)))"
        FunctionCall
           Type: uint256
           Source: "transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)))"
          MemberAccess to member push
             Type: function (struct PassiveToken.transferInStruct storage ref) returns (uint256)
             Source: "transferIns[msg.sender].push"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[msg.sender]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          FunctionCall
             Type: struct PassiveToken.transferInStruct memory
             Source: "transferInStruct(uint128(balances[msg.sender]),uint64(now))"
            Identifier transferInStruct
               Type: type(struct PassiveToken.transferInStruct storage pointer)
               Source: "transferInStruct"
            FunctionCall
               Type: uint128
               Source: "uint128(balances[msg.sender])"
              ElementaryTypeNameExpression uint128
                 Type: type(uint128)
                 Source: "uint128"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            FunctionCall
               Type: uint64
               Source: "uint64(now)"
              ElementaryTypeNameExpression uint64
                 Type: type(uint64)
                 Source: "uint64"
              Identifier now
                 Type: uint256
                 Source: "now"
      ExpressionStatement
         Gas costs: [???]
         Source: "Mint(msg.sender, reward)"
        FunctionCall
           Type: tuple()
           Source: "Mint(msg.sender, reward)"
          Identifier Mint
             Type: function (address,uint256)
             Source: "Mint"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier reward
             Type: uint256
             Source: "reward"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "getBlockNumber" - public
     Source: "function getBlockNumber() returns (uint blockNumber) {\r\n        blockNumber = block.number.sub(chainStartBlockNumber);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint blockNumber)"
      VariableDeclaration "blockNumber"
         Type: uint256
         Source: "uint blockNumber"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        blockNumber = block.number.sub(chainStartBlockNumber);\r\n    }"
      ExpressionStatement
         Gas costs: 240
         Source: "blockNumber = block.number.sub(chainStartBlockNumber)"
        Assignment using operator =
           Type: uint256
           Source: "blockNumber = block.number.sub(chainStartBlockNumber)"
          Identifier blockNumber
             Type: uint256
             Source: "blockNumber"
          FunctionCall
             Type: uint256
             Source: "block.number.sub(chainStartBlockNumber)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "block.number.sub"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
            Identifier chainStartBlockNumber
               Type: uint256
               Source: "chainStartBlockNumber"
  FunctionDefinition "coinAge" - public - const
     Source: "function coinAge() constant returns (uint myCoinAge) {\r\n        myCoinAge = getCoinAge(msg.sender,now);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint myCoinAge)"
      VariableDeclaration "myCoinAge"
         Type: uint256
         Source: "uint myCoinAge"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        myCoinAge = getCoinAge(msg.sender,now);\r\n    }"
      ExpressionStatement
         Gas costs: 13
         Source: "myCoinAge = getCoinAge(msg.sender,now)"
        Assignment using operator =
           Type: uint256
           Source: "myCoinAge = getCoinAge(msg.sender,now)"
          Identifier myCoinAge
             Type: uint256
             Source: "myCoinAge"
          FunctionCall
             Type: uint256
             Source: "getCoinAge(msg.sender,now)"
            Identifier getCoinAge
               Type: function (address,uint256) returns (uint256)
               Source: "getCoinAge"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier now
               Type: uint256
               Source: "now"
  FunctionDefinition "annualInterest" - public - const
     Source: "function annualInterest() constant returns(uint interest) {\r\n        uint _now = now;\r\n        interest = maxMintProofOfStake;\r\n        if((_now.sub(stakeStartTime)).div(99 years) == 0) {\r\n            interest = (3650 * maxMintProofOfStake).div(100);\r\n        } else if((_now.sub(stakeStartTime)).div(99 years) == 1){\r\n            interest = (3640 * maxMintProofOfStake).div(100);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint interest)"
      VariableDeclaration "interest"
         Type: uint256
         Source: "uint interest"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint _now = now;\r\n        interest = maxMintProofOfStake;\r\n        if((_now.sub(stakeStartTime)).div(99 years) == 0) {\r\n            interest = (3650 * maxMintProofOfStake).div(100);\r\n        } else if((_now.sub(stakeStartTime)).div(99 years) == 1){\r\n            interest = (3640 * maxMintProofOfStake).div(100);\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint _now = now"
        VariableDeclaration "_now"
           Type: uint256
           Source: "uint _now"
          ElementaryTypeName uint
             Source: "uint"
        Identifier now
           Type: uint256
           Source: "now"
      ExpressionStatement
         Gas costs: 208
         Source: "interest = maxMintProofOfStake"
        Assignment using operator =
           Type: uint256
           Source: "interest = maxMintProofOfStake"
          Identifier interest
             Type: uint256
             Source: "interest"
          Identifier maxMintProofOfStake
             Type: uint256
             Source: "maxMintProofOfStake"
      IfStatement
         Source: "if((_now.sub(stakeStartTime)).div(99 years) == 0) {\r\n            interest = (3650 * maxMintProofOfStake).div(100);\r\n        } else if((_now.sub(stakeStartTime)).div(99 years) == 1){\r\n            interest = (3640 * maxMintProofOfStake).div(100);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 275
           Source: "(_now.sub(stakeStartTime)).div(99 years) == 0"
          FunctionCall
             Type: uint256
             Source: "(_now.sub(stakeStartTime)).div(99 years)"
            MemberAccess to member div
               Type: function (uint256,uint256) view returns (uint256)
               Source: "(_now.sub(stakeStartTime)).div"
              TupleExpression
                 Type: uint256
                 Source: "(_now.sub(stakeStartTime))"
                FunctionCall
                   Type: uint256
                   Source: "_now.sub(stakeStartTime)"
                  MemberAccess to member sub
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "_now.sub"
                    Identifier _now
                       Type: uint256
                       Source: "_now"
                  Identifier stakeStartTime
                     Type: uint256
                     Source: "stakeStartTime"
            Literal, token: [no token] value: 99
               Type: int_const 3122064000
               Source: "99 years"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            interest = (3650 * maxMintProofOfStake).div(100);\r\n        }"
          ExpressionStatement
             Gas costs: 249
             Source: "interest = (3650 * maxMintProofOfStake).div(100)"
            Assignment using operator =
               Type: uint256
               Source: "interest = (3650 * maxMintProofOfStake).div(100)"
              Identifier interest
                 Type: uint256
                 Source: "interest"
              FunctionCall
                 Type: uint256
                 Source: "(3650 * maxMintProofOfStake).div(100)"
                MemberAccess to member div
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "(3650 * maxMintProofOfStake).div"
                  TupleExpression
                     Type: uint256
                     Source: "(3650 * maxMintProofOfStake)"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "3650 * maxMintProofOfStake"
                      Literal, token: [no token] value: 3650
                         Type: int_const 3650
                         Source: "3650"
                      Identifier maxMintProofOfStake
                         Type: uint256
                         Source: "maxMintProofOfStake"
                Literal, token: [no token] value: 100
                   Type: int_const 100
                   Source: "100"
        IfStatement
           Source: "if((_now.sub(stakeStartTime)).div(99 years) == 1){\r\n            interest = (3640 * maxMintProofOfStake).div(100);\r\n        }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 275
             Source: "(_now.sub(stakeStartTime)).div(99 years) == 1"
            FunctionCall
               Type: uint256
               Source: "(_now.sub(stakeStartTime)).div(99 years)"
              MemberAccess to member div
                 Type: function (uint256,uint256) view returns (uint256)
                 Source: "(_now.sub(stakeStartTime)).div"
                TupleExpression
                   Type: uint256
                   Source: "(_now.sub(stakeStartTime))"
                  FunctionCall
                     Type: uint256
                     Source: "_now.sub(stakeStartTime)"
                    MemberAccess to member sub
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "_now.sub"
                      Identifier _now
                         Type: uint256
                         Source: "_now"
                    Identifier stakeStartTime
                       Type: uint256
                       Source: "stakeStartTime"
              Literal, token: [no token] value: 99
                 Type: int_const 3122064000
                 Source: "99 years"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Block
             Source: "{\r\n            interest = (3640 * maxMintProofOfStake).div(100);\r\n        }"
            ExpressionStatement
               Gas costs: 249
               Source: "interest = (3640 * maxMintProofOfStake).div(100)"
              Assignment using operator =
                 Type: uint256
                 Source: "interest = (3640 * maxMintProofOfStake).div(100)"
                Identifier interest
                   Type: uint256
                   Source: "interest"
                FunctionCall
                   Type: uint256
                   Source: "(3640 * maxMintProofOfStake).div(100)"
                  MemberAccess to member div
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "(3640 * maxMintProofOfStake).div"
                    TupleExpression
                       Type: uint256
                       Source: "(3640 * maxMintProofOfStake)"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "3640 * maxMintProofOfStake"
                        Literal, token: [no token] value: 3640
                           Type: int_const 3640
                           Source: "3640"
                        Identifier maxMintProofOfStake
                           Type: uint256
                           Source: "maxMintProofOfStake"
                  Literal, token: [no token] value: 100
                     Type: int_const 100
                     Source: "100"
  FunctionDefinition "getProofOfStakeReward"
     Source: "function getProofOfStakeReward(address _address) internal returns (uint) {\r\n        require( (now >= stakeStartTime) && (stakeStartTime > 0) );\r\n\r\n        uint _now = now;\r\n        uint _coinAge = getCoinAge(_address, _now);\r\n        if(_coinAge <= 0) return 0;\r\n\r\n        uint interest = maxMintProofOfStake;\r\n        if((_now.sub(stakeStartTime)).div(99 years) == 0) {\r\n            // first 99 years 365% POS interest\r\n            interest = (3650 * maxMintProofOfStake).div(100);\r\n        } else if((_now.sub(stakeStartTime)).div(99 years) == 1){\r\n            // 2nd 99 Years 364% POS INTEREST\r\n            interest = (3640 * maxMintProofOfStake).div(100);\r\n        }\r\n\t\t\t//after 198 years 10% POS INTEREST\r\n        return (_coinAge * interest).div(365 * (10**decimals));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require( (now >= stakeStartTime) && (stakeStartTime > 0) );\r\n\r\n        uint _now = now;\r\n        uint _coinAge = getCoinAge(_address, _now);\r\n        if(_coinAge <= 0) return 0;\r\n\r\n        uint interest = maxMintProofOfStake;\r\n        if((_now.sub(stakeStartTime)).div(99 years) == 0) {\r\n            // first 99 years 365% POS interest\r\n            interest = (3650 * maxMintProofOfStake).div(100);\r\n        } else if((_now.sub(stakeStartTime)).div(99 years) == 1){\r\n            // 2nd 99 Years 364% POS INTEREST\r\n            interest = (3640 * maxMintProofOfStake).div(100);\r\n        }\r\n\t\t\t//after 198 years 10% POS INTEREST\r\n        return (_coinAge * interest).div(365 * (10**decimals));\r\n    }"
      ExpressionStatement
         Gas costs: 468
         Source: "require( (now >= stakeStartTime) && (stakeStartTime > 0) )"
        FunctionCall
           Type: tuple()
           Source: "require( (now >= stakeStartTime) && (stakeStartTime > 0) )"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "(now >= stakeStartTime) && (stakeStartTime > 0)"
            TupleExpression
               Type: bool
               Source: "(now >= stakeStartTime)"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "now >= stakeStartTime"
                Identifier now
                   Type: uint256
                   Source: "now"
                Identifier stakeStartTime
                   Type: uint256
                   Source: "stakeStartTime"
            TupleExpression
               Type: bool
               Source: "(stakeStartTime > 0)"
              BinaryOperation using operator >
                 Type: bool
                 Source: "stakeStartTime > 0"
                Identifier stakeStartTime
                   Type: uint256
                   Source: "stakeStartTime"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint _now = now"
        VariableDeclaration "_now"
           Type: uint256
           Source: "uint _now"
          ElementaryTypeName uint
             Source: "uint"
        Identifier now
           Type: uint256
           Source: "now"
      VariableDeclarationStatement
         Gas costs: 29
         Source: "uint _coinAge = getCoinAge(_address, _now)"
        VariableDeclaration "_coinAge"
           Type: uint256
           Source: "uint _coinAge"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getCoinAge(_address, _now)"
          Identifier getCoinAge
             Type: function (address,uint256) returns (uint256)
             Source: "getCoinAge"
          Identifier _address
             Type: address
             Source: "_address"
          Identifier _now
             Type: uint256
             Source: "_now"
      IfStatement
         Source: "if(_coinAge <= 0) return 0"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 12
           Source: "_coinAge <= 0"
          Identifier _coinAge
             Type: uint256
             Source: "_coinAge"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 19
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      VariableDeclarationStatement
         Gas costs: 211
         Source: "uint interest = maxMintProofOfStake"
        VariableDeclaration "interest"
           Type: uint256
           Source: "uint interest"
          ElementaryTypeName uint
             Source: "uint"
        Identifier maxMintProofOfStake
           Type: uint256
           Source: "maxMintProofOfStake"
      IfStatement
         Source: "if((_now.sub(stakeStartTime)).div(99 years) == 0) {\r\n            // first 99 years 365% POS interest\r\n            interest = (3650 * maxMintProofOfStake).div(100);\r\n        } else if((_now.sub(stakeStartTime)).div(99 years) == 1){\r\n            // 2nd 99 Years 364% POS INTEREST\r\n            interest = (3640 * maxMintProofOfStake).div(100);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 275
           Source: "(_now.sub(stakeStartTime)).div(99 years) == 0"
          FunctionCall
             Type: uint256
             Source: "(_now.sub(stakeStartTime)).div(99 years)"
            MemberAccess to member div
               Type: function (uint256,uint256) view returns (uint256)
               Source: "(_now.sub(stakeStartTime)).div"
              TupleExpression
                 Type: uint256
                 Source: "(_now.sub(stakeStartTime))"
                FunctionCall
                   Type: uint256
                   Source: "_now.sub(stakeStartTime)"
                  MemberAccess to member sub
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "_now.sub"
                    Identifier _now
                       Type: uint256
                       Source: "_now"
                  Identifier stakeStartTime
                     Type: uint256
                     Source: "stakeStartTime"
            Literal, token: [no token] value: 99
               Type: int_const 3122064000
               Source: "99 years"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            // first 99 years 365% POS interest\r\n            interest = (3650 * maxMintProofOfStake).div(100);\r\n        }"
          ExpressionStatement
             Gas costs: 249
             Source: "interest = (3650 * maxMintProofOfStake).div(100)"
            Assignment using operator =
               Type: uint256
               Source: "interest = (3650 * maxMintProofOfStake).div(100)"
              Identifier interest
                 Type: uint256
                 Source: "interest"
              FunctionCall
                 Type: uint256
                 Source: "(3650 * maxMintProofOfStake).div(100)"
                MemberAccess to member div
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "(3650 * maxMintProofOfStake).div"
                  TupleExpression
                     Type: uint256
                     Source: "(3650 * maxMintProofOfStake)"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "3650 * maxMintProofOfStake"
                      Literal, token: [no token] value: 3650
                         Type: int_const 3650
                         Source: "3650"
                      Identifier maxMintProofOfStake
                         Type: uint256
                         Source: "maxMintProofOfStake"
                Literal, token: [no token] value: 100
                   Type: int_const 100
                   Source: "100"
        IfStatement
           Source: "if((_now.sub(stakeStartTime)).div(99 years) == 1){\r\n            // 2nd 99 Years 364% POS INTEREST\r\n            interest = (3640 * maxMintProofOfStake).div(100);\r\n        }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 275
             Source: "(_now.sub(stakeStartTime)).div(99 years) == 1"
            FunctionCall
               Type: uint256
               Source: "(_now.sub(stakeStartTime)).div(99 years)"
              MemberAccess to member div
                 Type: function (uint256,uint256) view returns (uint256)
                 Source: "(_now.sub(stakeStartTime)).div"
                TupleExpression
                   Type: uint256
                   Source: "(_now.sub(stakeStartTime))"
                  FunctionCall
                     Type: uint256
                     Source: "_now.sub(stakeStartTime)"
                    MemberAccess to member sub
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "_now.sub"
                      Identifier _now
                         Type: uint256
                         Source: "_now"
                    Identifier stakeStartTime
                       Type: uint256
                       Source: "stakeStartTime"
              Literal, token: [no token] value: 99
                 Type: int_const 3122064000
                 Source: "99 years"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Block
             Source: "{\r\n            // 2nd 99 Years 364% POS INTEREST\r\n            interest = (3640 * maxMintProofOfStake).div(100);\r\n        }"
            ExpressionStatement
               Gas costs: 249
               Source: "interest = (3640 * maxMintProofOfStake).div(100)"
              Assignment using operator =
                 Type: uint256
                 Source: "interest = (3640 * maxMintProofOfStake).div(100)"
                Identifier interest
                   Type: uint256
                   Source: "interest"
                FunctionCall
                   Type: uint256
                   Source: "(3640 * maxMintProofOfStake).div(100)"
                  MemberAccess to member div
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "(3640 * maxMintProofOfStake).div"
                    TupleExpression
                       Type: uint256
                       Source: "(3640 * maxMintProofOfStake)"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "3640 * maxMintProofOfStake"
                        Literal, token: [no token] value: 3640
                           Type: int_const 3640
                           Source: "3640"
                        Identifier maxMintProofOfStake
                           Type: uint256
                           Source: "maxMintProofOfStake"
                  Literal, token: [no token] value: 100
                     Type: int_const 100
                     Source: "100"
      Return
         Gas costs: 1870
         Source: "return (_coinAge * interest).div(365 * (10**decimals))"
        FunctionCall
           Type: uint256
           Source: "(_coinAge * interest).div(365 * (10**decimals))"
          MemberAccess to member div
             Type: function (uint256,uint256) view returns (uint256)
             Source: "(_coinAge * interest).div"
            TupleExpression
               Type: uint256
               Source: "(_coinAge * interest)"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "_coinAge * interest"
                Identifier _coinAge
                   Type: uint256
                   Source: "_coinAge"
                Identifier interest
                   Type: uint256
                   Source: "interest"
          BinaryOperation using operator *
             Type: uint256
             Source: "365 * (10**decimals)"
            Literal, token: [no token] value: 365
               Type: int_const 365
               Source: "365"
            TupleExpression
               Type: uint256
               Source: "(10**decimals)"
              BinaryOperation using operator **
                 Type: uint256
                 Source: "10**decimals"
                Literal, token: [no token] value: 10
                   Type: int_const 10
                   Source: "10"
                Identifier decimals
                   Type: uint256
                   Source: "decimals"
  FunctionDefinition "getCoinAge"
     Source: "function getCoinAge(address _address, uint _now) internal returns (uint _coinAge) {\r\n        if(transferIns[_address].length <= 0) return 0;\r\n\r\n        for (uint i = 0; i < transferIns[_address].length; i++){\r\n            if( _now < uint(transferIns[_address][i].time).add(stakeMinAge) ) continue;\r\n\r\n            uint nCoinSeconds = _now.sub(uint(transferIns[_address][i].time));\r\n            if( nCoinSeconds > stakeMaxAge ) nCoinSeconds = stakeMaxAge;\r\n\r\n            _coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days));\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address, uint _now)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_now"
         Type: uint256
         Source: "uint _now"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint _coinAge)"
      VariableDeclaration "_coinAge"
         Type: uint256
         Source: "uint _coinAge"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if(transferIns[_address].length <= 0) return 0;\r\n\r\n        for (uint i = 0; i < transferIns[_address].length; i++){\r\n            if( _now < uint(transferIns[_address][i].time).add(stakeMinAge) ) continue;\r\n\r\n            uint nCoinSeconds = _now.sub(uint(transferIns[_address][i].time));\r\n            if( nCoinSeconds > stakeMaxAge ) nCoinSeconds = stakeMaxAge;\r\n\r\n            _coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days));\r\n        }\r\n    }"
      IfStatement
         Source: "if(transferIns[_address].length <= 0) return 0"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 316
           Source: "transferIns[_address].length <= 0"
          MemberAccess to member length
             Type: uint256
             Source: "transferIns[_address].length"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[_address]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              Identifier _address
                 Type: address
                 Source: "_address"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 19
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ForStatement
         Source: "for (uint i = 0; i < transferIns[_address].length; i++){\r\n            if( _now < uint(transferIns[_address][i].time).add(stakeMinAge) ) continue;\r\n\r\n            uint nCoinSeconds = _now.sub(uint(transferIns[_address][i].time));\r\n            if( nCoinSeconds > stakeMaxAge ) nCoinSeconds = stakeMaxAge;\r\n\r\n            _coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days));\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 313
           Source: "i < transferIns[_address].length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "transferIns[_address].length"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[_address]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              Identifier _address
                 Type: address
                 Source: "_address"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if( _now < uint(transferIns[_address][i].time).add(stakeMinAge) ) continue;\r\n\r\n            uint nCoinSeconds = _now.sub(uint(transferIns[_address][i].time));\r\n            if( nCoinSeconds > stakeMaxAge ) nCoinSeconds = stakeMaxAge;\r\n\r\n            _coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days));\r\n        }"
          IfStatement
             Source: "if( _now < uint(transferIns[_address][i].time).add(stakeMinAge) ) continue"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 925
               Source: "_now < uint(transferIns[_address][i].time).add(stakeMinAge)"
              Identifier _now
                 Type: uint256
                 Source: "_now"
              FunctionCall
                 Type: uint256
                 Source: "uint(transferIns[_address][i].time).add(stakeMinAge)"
                MemberAccess to member add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "uint(transferIns[_address][i].time).add"
                  FunctionCall
                     Type: uint256
                     Source: "uint(transferIns[_address][i].time)"
                    ElementaryTypeNameExpression uint
                       Type: type(uint256)
                       Source: "uint"
                    MemberAccess to member time
                       Type: uint64
                       Source: "transferIns[_address][i].time"
                      IndexAccess
                         Type: struct PassiveToken.transferInStruct storage ref
                         Source: "transferIns[_address][i]"
                        IndexAccess
                           Type: struct PassiveToken.transferInStruct storage ref[] storage ref
                           Source: "transferIns[_address]"
                          Identifier transferIns
                             Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                             Source: "transferIns"
                          Identifier _address
                             Type: address
                             Source: "_address"
                        Identifier i
                           Type: uint256
                           Source: "i"
                Identifier stakeMinAge
                   Type: uint256
                   Source: "stakeMinAge"
            Continue
               Gas costs: 11
               Source: "continue"
          VariableDeclarationStatement
             Gas costs: 727
             Source: "uint nCoinSeconds = _now.sub(uint(transferIns[_address][i].time))"
            VariableDeclaration "nCoinSeconds"
               Type: uint256
               Source: "uint nCoinSeconds"
              ElementaryTypeName uint
                 Source: "uint"
            FunctionCall
               Type: uint256
               Source: "_now.sub(uint(transferIns[_address][i].time))"
              MemberAccess to member sub
                 Type: function (uint256,uint256) view returns (uint256)
                 Source: "_now.sub"
                Identifier _now
                   Type: uint256
                   Source: "_now"
              FunctionCall
                 Type: uint256
                 Source: "uint(transferIns[_address][i].time)"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                MemberAccess to member time
                   Type: uint64
                   Source: "transferIns[_address][i].time"
                  IndexAccess
                     Type: struct PassiveToken.transferInStruct storage ref
                     Source: "transferIns[_address][i]"
                    IndexAccess
                       Type: struct PassiveToken.transferInStruct storage ref[] storage ref
                       Source: "transferIns[_address]"
                      Identifier transferIns
                         Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                         Source: "transferIns"
                      Identifier _address
                         Type: address
                         Source: "_address"
                    Identifier i
                       Type: uint256
                       Source: "i"
          IfStatement
             Source: "if( nCoinSeconds > stakeMaxAge ) nCoinSeconds = stakeMaxAge"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 209
               Source: "nCoinSeconds > stakeMaxAge"
              Identifier nCoinSeconds
                 Type: uint256
                 Source: "nCoinSeconds"
              Identifier stakeMaxAge
                 Type: uint256
                 Source: "stakeMaxAge"
            ExpressionStatement
               Gas costs: 208
               Source: "nCoinSeconds = stakeMaxAge"
              Assignment using operator =
                 Type: uint256
                 Source: "nCoinSeconds = stakeMaxAge"
                Identifier nCoinSeconds
                   Type: uint256
                   Source: "nCoinSeconds"
                Identifier stakeMaxAge
                   Type: uint256
                   Source: "stakeMaxAge"
          ExpressionStatement
             Gas costs: 715
             Source: "_coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days))"
            Assignment using operator =
               Type: uint256
               Source: "_coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days))"
              Identifier _coinAge
                 Type: uint256
                 Source: "_coinAge"
              FunctionCall
                 Type: uint256
                 Source: "_coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days))"
                MemberAccess to member add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "_coinAge.add"
                  Identifier _coinAge
                     Type: uint256
                     Source: "_coinAge"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days)"
                  FunctionCall
                     Type: uint256
                     Source: "uint(transferIns[_address][i].amount)"
                    ElementaryTypeNameExpression uint
                       Type: type(uint256)
                       Source: "uint"
                    MemberAccess to member amount
                       Type: uint128
                       Source: "transferIns[_address][i].amount"
                      IndexAccess
                         Type: struct PassiveToken.transferInStruct storage ref
                         Source: "transferIns[_address][i]"
                        IndexAccess
                           Type: struct PassiveToken.transferInStruct storage ref[] storage ref
                           Source: "transferIns[_address]"
                          Identifier transferIns
                             Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                             Source: "transferIns"
                          Identifier _address
                             Type: address
                             Source: "_address"
                        Identifier i
                           Type: uint256
                           Source: "i"
                  FunctionCall
                     Type: uint256
                     Source: "nCoinSeconds.div(1 days)"
                    MemberAccess to member div
                       Type: function (uint256,uint256) view returns (uint256)
                       Source: "nCoinSeconds.div"
                      Identifier nCoinSeconds
                         Type: uint256
                         Source: "nCoinSeconds"
                    Literal, token: [no token] value: 1
                       Type: int_const 86400
                       Source: "1 days"
  FunctionDefinition "ownerSetStakeStartTime" - public
     Source: "function ownerSetStakeStartTime(uint timestamp) onlyOwner {\r\n        require((stakeStartTime <= 0) && (timestamp >= chainStartTime));\r\n        stakeStartTime = timestamp;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint timestamp)"
      VariableDeclaration "timestamp"
         Type: uint256
         Source: "uint timestamp"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require((stakeStartTime <= 0) && (timestamp >= chainStartTime));\r\n        stakeStartTime = timestamp;\r\n    }"
      ExpressionStatement
         Gas costs: 472
         Source: "require((stakeStartTime <= 0) && (timestamp >= chainStartTime))"
        FunctionCall
           Type: tuple()
           Source: "require((stakeStartTime <= 0) && (timestamp >= chainStartTime))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "(stakeStartTime <= 0) && (timestamp >= chainStartTime)"
            TupleExpression
               Type: bool
               Source: "(stakeStartTime <= 0)"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "stakeStartTime <= 0"
                Identifier stakeStartTime
                   Type: uint256
                   Source: "stakeStartTime"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            TupleExpression
               Type: bool
               Source: "(timestamp >= chainStartTime)"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "timestamp >= chainStartTime"
                Identifier timestamp
                   Type: uint256
                   Source: "timestamp"
                Identifier chainStartTime
                   Type: uint256
                   Source: "chainStartTime"
      ExpressionStatement
         Gas costs: 20014
         Source: "stakeStartTime = timestamp"
        Assignment using operator =
           Type: uint256
           Source: "stakeStartTime = timestamp"
          Identifier stakeStartTime
             Type: uint256
             Source: "stakeStartTime"
          Identifier timestamp
             Type: uint256
             Source: "timestamp"
  FunctionDefinition "ownerBurnToken" - public
     Source: "function ownerBurnToken(uint _value) onlyOwner {\r\n        require(_value > 0);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        delete transferIns[msg.sender];\r\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));\r\n\r\n        totalSupply = totalSupply.sub(_value);\r\n        totalInitialSupply = totalInitialSupply.sub(_value);\r\n        maxTotalSupply = maxTotalSupply.sub(_value*10);\r\n\r\n        Burn(msg.sender, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _value)"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_value > 0);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        delete transferIns[msg.sender];\r\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));\r\n\r\n        totalSupply = totalSupply.sub(_value);\r\n        totalInitialSupply = totalInitialSupply.sub(_value);\r\n        maxTotalSupply = maxTotalSupply.sub(_value*10);\r\n\r\n        Burn(msg.sender, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 35
         Source: "require(_value > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_value > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "_value > 0"
            Identifier _value
               Type: uint256
               Source: "_value"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20437
         Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "balances[msg.sender].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 116
         Source: "delete transferIns[msg.sender]"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete transferIns[msg.sender]"
          IndexAccess
             Type: struct PassiveToken.transferInStruct storage ref[] storage ref
             Source: "transferIns[msg.sender]"
            Identifier transferIns
               Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
               Source: "transferIns"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: [???]
         Source: "transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)))"
        FunctionCall
           Type: uint256
           Source: "transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)))"
          MemberAccess to member push
             Type: function (struct PassiveToken.transferInStruct storage ref) returns (uint256)
             Source: "transferIns[msg.sender].push"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[msg.sender]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          FunctionCall
             Type: struct PassiveToken.transferInStruct memory
             Source: "transferInStruct(uint128(balances[msg.sender]),uint64(now))"
            Identifier transferInStruct
               Type: type(struct PassiveToken.transferInStruct storage pointer)
               Source: "transferInStruct"
            FunctionCall
               Type: uint128
               Source: "uint128(balances[msg.sender])"
              ElementaryTypeNameExpression uint128
                 Type: type(uint128)
                 Source: "uint128"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            FunctionCall
               Type: uint64
               Source: "uint64(now)"
              ElementaryTypeNameExpression uint64
                 Type: type(uint64)
                 Source: "uint64"
              Identifier now
                 Type: uint256
                 Source: "now"
      ExpressionStatement
         Gas costs: 20247
         Source: "totalSupply = totalSupply.sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = totalSupply.sub(_value)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "totalSupply.sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "totalSupply.sub"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20247
         Source: "totalInitialSupply = totalInitialSupply.sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "totalInitialSupply = totalInitialSupply.sub(_value)"
          Identifier totalInitialSupply
             Type: uint256
             Source: "totalInitialSupply"
          FunctionCall
             Type: uint256
             Source: "totalInitialSupply.sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "totalInitialSupply.sub"
              Identifier totalInitialSupply
                 Type: uint256
                 Source: "totalInitialSupply"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20255
         Source: "maxTotalSupply = maxTotalSupply.sub(_value*10)"
        Assignment using operator =
           Type: uint256
           Source: "maxTotalSupply = maxTotalSupply.sub(_value*10)"
          Identifier maxTotalSupply
             Type: uint256
             Source: "maxTotalSupply"
          FunctionCall
             Type: uint256
             Source: "maxTotalSupply.sub(_value*10)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "maxTotalSupply.sub"
              Identifier maxTotalSupply
                 Type: uint256
                 Source: "maxTotalSupply"
            BinaryOperation using operator *
               Type: uint256
               Source: "_value*10"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
      ExpressionStatement
         Gas costs: [???]
         Source: "Burn(msg.sender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Burn(msg.sender, _value)"
          Identifier Burn
             Type: function (address,uint256)
             Source: "Burn"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "batchTransfer" - public
     Source: "function batchTransfer(address[] _recipients, uint[] _values) onlyOwner returns (bool) {\r\n        require( _recipients.length > 0 && _recipients.length == _values.length);\r\n\r\n        uint total = 0;\r\n        for(uint i = 0; i < _values.length; i++){\r\n            total = total.add(_values[i]);\r\n        }\r\n        require(total <= balances[msg.sender]);\r\n\r\n        uint64 _now = uint64(now);\r\n        for(uint j = 0; j < _recipients.length; j++){\r\n            balances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);\r\n            transferIns[_recipients[j]].push(transferInStruct(uint128(_values[j]),_now));\r\n            Transfer(msg.sender, _recipients[j], _values[j]);\r\n        }\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(total);\r\n        if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];\r\n        if(balances[msg.sender] > 0) transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));\r\n\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _recipients, uint[] _values)"
      VariableDeclaration "_recipients"
         Type: address[] memory
         Source: "address[] _recipients"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_values"
         Type: uint256[] memory
         Source: "uint[] _values"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require( _recipients.length > 0 && _recipients.length == _values.length);\r\n\r\n        uint total = 0;\r\n        for(uint i = 0; i < _values.length; i++){\r\n            total = total.add(_values[i]);\r\n        }\r\n        require(total <= balances[msg.sender]);\r\n\r\n        uint64 _now = uint64(now);\r\n        for(uint j = 0; j < _recipients.length; j++){\r\n            balances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);\r\n            transferIns[_recipients[j]].push(transferInStruct(uint128(_values[j]),_now));\r\n            Transfer(msg.sender, _recipients[j], _values[j]);\r\n        }\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(total);\r\n        if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];\r\n        if(balances[msg.sender] > 0) transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));\r\n\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "require( _recipients.length > 0 && _recipients.length == _values.length)"
        FunctionCall
           Type: tuple()
           Source: "require( _recipients.length > 0 && _recipients.length == _values.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_recipients.length > 0 && _recipients.length == _values.length"
            BinaryOperation using operator >
               Type: bool
               Source: "_recipients.length > 0"
              MemberAccess to member length
                 Type: uint256
                 Source: "_recipients.length"
                Identifier _recipients
                   Type: address[] memory
                   Source: "_recipients"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "_recipients.length == _values.length"
              MemberAccess to member length
                 Type: uint256
                 Source: "_recipients.length"
                Identifier _recipients
                   Type: address[] memory
                   Source: "_recipients"
              MemberAccess to member length
                 Type: uint256
                 Source: "_values.length"
                Identifier _values
                   Type: uint256[] memory
                   Source: "_values"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint total = 0"
        VariableDeclaration "total"
           Type: uint256
           Source: "uint total"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for(uint i = 0; i < _values.length; i++){\r\n            total = total.add(_values[i]);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "i < _values.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_values.length"
            Identifier _values
               Type: uint256[] memory
               Source: "_values"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            total = total.add(_values[i]);\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "total = total.add(_values[i])"
            Assignment using operator =
               Type: uint256
               Source: "total = total.add(_values[i])"
              Identifier total
                 Type: uint256
                 Source: "total"
              FunctionCall
                 Type: uint256
                 Source: "total.add(_values[i])"
                MemberAccess to member add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "total.add"
                  Identifier total
                     Type: uint256
                     Source: "total"
                IndexAccess
                   Type: uint256
                   Source: "_values[i]"
                  Identifier _values
                     Type: uint256[] memory
                     Source: "_values"
                  Identifier i
                     Type: uint256
                     Source: "i"
      ExpressionStatement
         Gas costs: 333
         Source: "require(total <= balances[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(total <= balances[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "total <= balances[msg.sender]"
            Identifier total
               Type: uint256
               Source: "total"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint64 _now = uint64(now)"
        VariableDeclaration "_now"
           Type: uint64
           Source: "uint64 _now"
          ElementaryTypeName uint64
             Source: "uint64"
        FunctionCall
           Type: uint64
           Source: "uint64(now)"
          ElementaryTypeNameExpression uint64
             Type: type(uint64)
             Source: "uint64"
          Identifier now
             Type: uint256
             Source: "now"
      ForStatement
         Source: "for(uint j = 0; j < _recipients.length; j++){\r\n            balances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);\r\n            transferIns[_recipients[j]].push(transferInStruct(uint128(_values[j]),_now));\r\n            Transfer(msg.sender, _recipients[j], _values[j]);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint j = 0"
          VariableDeclaration "j"
             Type: uint256
             Source: "uint j"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "j < _recipients.length"
          Identifier j
             Type: uint256
             Source: "j"
          MemberAccess to member length
             Type: uint256
             Source: "_recipients.length"
            Identifier _recipients
               Type: address[] memory
               Source: "_recipients"
        ExpressionStatement
           Gas costs: 19
           Source: "j++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "j++"
            Identifier j
               Type: uint256
               Source: "j"
        Block
           Source: "{\r\n            balances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);\r\n            transferIns[_recipients[j]].push(transferInStruct(uint128(_values[j]),_now));\r\n            Transfer(msg.sender, _recipients[j], _values[j]);\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "balances[_recipients[j]] = balances[_recipients[j]].add(_values[j])"
            Assignment using operator =
               Type: uint256
               Source: "balances[_recipients[j]] = balances[_recipients[j]].add(_values[j])"
              IndexAccess
                 Type: uint256
                 Source: "balances[_recipients[j]]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                IndexAccess
                   Type: address
                   Source: "_recipients[j]"
                  Identifier _recipients
                     Type: address[] memory
                     Source: "_recipients"
                  Identifier j
                     Type: uint256
                     Source: "j"
              FunctionCall
                 Type: uint256
                 Source: "balances[_recipients[j]].add(_values[j])"
                MemberAccess to member add
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "balances[_recipients[j]].add"
                  IndexAccess
                     Type: uint256
                     Source: "balances[_recipients[j]]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    IndexAccess
                       Type: address
                       Source: "_recipients[j]"
                      Identifier _recipients
                         Type: address[] memory
                         Source: "_recipients"
                      Identifier j
                         Type: uint256
                         Source: "j"
                IndexAccess
                   Type: uint256
                   Source: "_values[j]"
                  Identifier _values
                     Type: uint256[] memory
                     Source: "_values"
                  Identifier j
                     Type: uint256
                     Source: "j"
          ExpressionStatement
             Gas costs: [???]
             Source: "transferIns[_recipients[j]].push(transferInStruct(uint128(_values[j]),_now))"
            FunctionCall
               Type: uint256
               Source: "transferIns[_recipients[j]].push(transferInStruct(uint128(_values[j]),_now))"
              MemberAccess to member push
                 Type: function (struct PassiveToken.transferInStruct storage ref) returns (uint256)
                 Source: "transferIns[_recipients[j]].push"
                IndexAccess
                   Type: struct PassiveToken.transferInStruct storage ref[] storage ref
                   Source: "transferIns[_recipients[j]]"
                  Identifier transferIns
                     Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                     Source: "transferIns"
                  IndexAccess
                     Type: address
                     Source: "_recipients[j]"
                    Identifier _recipients
                       Type: address[] memory
                       Source: "_recipients"
                    Identifier j
                       Type: uint256
                       Source: "j"
              FunctionCall
                 Type: struct PassiveToken.transferInStruct memory
                 Source: "transferInStruct(uint128(_values[j]),_now)"
                Identifier transferInStruct
                   Type: type(struct PassiveToken.transferInStruct storage pointer)
                   Source: "transferInStruct"
                FunctionCall
                   Type: uint128
                   Source: "uint128(_values[j])"
                  ElementaryTypeNameExpression uint128
                     Type: type(uint128)
                     Source: "uint128"
                  IndexAccess
                     Type: uint256
                     Source: "_values[j]"
                    Identifier _values
                       Type: uint256[] memory
                       Source: "_values"
                    Identifier j
                       Type: uint256
                       Source: "j"
                Identifier _now
                   Type: uint64
                   Source: "_now"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(msg.sender, _recipients[j], _values[j])"
            FunctionCall
               Type: tuple()
               Source: "Transfer(msg.sender, _recipients[j], _values[j])"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              IndexAccess
                 Type: address
                 Source: "_recipients[j]"
                Identifier _recipients
                   Type: address[] memory
                   Source: "_recipients"
                Identifier j
                   Type: uint256
                   Source: "j"
              IndexAccess
                 Type: uint256
                 Source: "_values[j]"
                Identifier _values
                   Type: uint256[] memory
                   Source: "_values"
                Identifier j
                   Type: uint256
                   Source: "j"
      ExpressionStatement
         Gas costs: 20437
         Source: "balances[msg.sender] = balances[msg.sender].sub(total)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = balances[msg.sender].sub(total)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "balances[msg.sender].sub(total)"
            MemberAccess to member sub
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balances[msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier total
               Type: uint256
               Source: "total"
      IfStatement
         Source: "if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender]"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 306
           Source: "transferIns[msg.sender].length > 0"
          MemberAccess to member length
             Type: uint256
             Source: "transferIns[msg.sender].length"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[msg.sender]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 122
           Source: "delete transferIns[msg.sender]"
          UnaryOperation (prefix) delete
             Type: tuple()
             Source: "delete transferIns[msg.sender]"
            IndexAccess
               Type: struct PassiveToken.transferInStruct storage ref[] storage ref
               Source: "transferIns[msg.sender]"
              Identifier transferIns
                 Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                 Source: "transferIns"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      IfStatement
         Source: "if(balances[msg.sender] > 0) transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now))"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 304
           Source: "balances[msg.sender] > 0"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: [???]
           Source: "transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now))"
          FunctionCall
             Type: uint256
             Source: "transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now))"
            MemberAccess to member push
               Type: function (struct PassiveToken.transferInStruct storage ref) returns (uint256)
               Source: "transferIns[msg.sender].push"
              IndexAccess
                 Type: struct PassiveToken.transferInStruct storage ref[] storage ref
                 Source: "transferIns[msg.sender]"
                Identifier transferIns
                   Type: mapping(address => struct PassiveToken.transferInStruct storage ref[] storage ref)
                   Source: "transferIns"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            FunctionCall
               Type: struct PassiveToken.transferInStruct memory
               Source: "transferInStruct(uint128(balances[msg.sender]),_now)"
              Identifier transferInStruct
                 Type: type(struct PassiveToken.transferInStruct storage pointer)
                 Source: "transferInStruct"
              FunctionCall
                 Type: uint128
                 Source: "uint128(balances[msg.sender])"
                ElementaryTypeNameExpression uint128
                   Type: type(uint128)
                   Source: "uint128"
                IndexAccess
                   Type: uint256
                   Source: "balances[msg.sender]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
              Identifier _now
                 Type: uint64
                 Source: "_now"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
