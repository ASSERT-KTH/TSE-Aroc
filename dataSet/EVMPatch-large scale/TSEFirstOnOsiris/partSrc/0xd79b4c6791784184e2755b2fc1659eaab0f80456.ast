Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xd79b4c6791784184e2755b2fc1659eaab0f80456.sol =======
ContractDefinition "HonestDice"
   Source: "contract HonestDice {\r\n\t\r\n\tevent Bet(address indexed user, uint blocknum, uint256 amount, uint chance);\r\n\tevent Won(address indexed user, uint256 amount, uint chance);\r\n\t\r\n\tstruct Roll {\r\n\t\tuint256 value;\r\n\t\tuint chance;\r\n\t\tuint blocknum;\r\n\t\tbytes32 secretHash;\r\n\t\tbytes32 serverSeed;\r\n\t}\r\n\t\r\n\tuint betsLocked;\r\n\taddress owner;\r\n\taddress feed;\t\t\t\t   \r\n\tuint256 minimumBet = 1 * 1000000000000000000; // 1 Ether\r\n\tuint256 constant maxPayout = 5; // 5% of bankroll\r\n\tuint constant seedCost = 100000000000000000; // This is the cost of supplyin the server seed, deduct it;\r\n\tmapping (address => Roll) rolls;\r\n\tuint constant timeout = 20; // 5 Minutes\r\n\t\r\n\tfunction HonestDice() {\r\n\t\towner = msg.sender;\r\n\t\tfeed = msg.sender;\r\n\t}\r\n\t\r\n\tfunction roll(uint chance, bytes32 secretHash) {\r\n\t\tif (chance < 1 || chance > 255 || msg.value < minimumBet || calcWinnings(msg.value, chance) > getMaxPayout() || betsLocked != 0) { \r\n\t\t\tmsg.sender.send(msg.value); // Refund\r\n\t\t\treturn;\r\n\t\t}\r\n\t\trolls[msg.sender] = Roll(msg.value, chance, block.number, secretHash, 0);\r\n\t\tBet(msg.sender, block.number, msg.value, chance);\r\n\t}\r\n\t\r\n\tfunction serverSeed(address user, bytes32 seed) {\r\n\t\t// The server calls this with a random seed\r\n\t\tif (msg.sender != feed) return;\r\n\t\tif (rolls[user].serverSeed != 0) return;\r\n\t\trolls[user].serverSeed = seed;\r\n\t}\r\n\t\r\n\tfunction hashTo256(bytes32 hash) constant returns (uint _r) {\r\n\t\t// Returns a number between 0 - 255 from a hash\r\n\t\treturn uint(hash) & 0xff;\r\n\t}\r\n\t\r\n\tfunction hash(bytes32 input) constant returns (uint _r) {\r\n\t\t// Simple sha3 hash. Not to be called via the blockchain\r\n\t\treturn uint(sha3(input));\r\n\t}\r\n\t\r\n\tfunction isReady() constant returns (bool _r) {\r\n\t\treturn isReadyFor(msg.sender);\r\n\t}\r\n\t\r\n\tfunction isReadyFor(address _user) constant returns (bool _r) {\r\n\t\tRoll r = rolls[_user];\r\n\t\tif (r.serverSeed == 0) return false;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction getResult(bytes32 secret) constant returns (uint _r) {\r\n\t\t// Get the result number of the roll\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed == 0) return;\r\n\t\tif (sha3(secret) != r.secretHash) return;\r\n\t\treturn hashTo256(sha3(secret, r.serverSeed));\r\n\t}\r\n\t\r\n\tfunction didWin(bytes32 secret) constant returns (bool _r) {\r\n\t\t// Returns if the player won or not\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed == 0) return;\r\n\t\tif (sha3(secret) != r.secretHash) return;\r\n\t\tif (hashTo256(sha3(secret, r.serverSeed)) < r.chance) { // Winner\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tfunction calcWinnings(uint256 value, uint chance) constant returns (uint256 _r) {\r\n\t\t// 1% house edge\r\n\t\treturn (value * 99 / 100) * 256 / chance;\r\n\t}\r\n\t\r\n\tfunction getMaxPayout() constant returns (uint256 _r) {\r\n\t\treturn this.balance * maxPayout / 100;\r\n\t}\r\n\t\r\n\tfunction claim(bytes32 secret) {\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed == 0) return;\r\n\t\tif (sha3(secret) != r.secretHash) return;\r\n\t\tif (hashTo256(sha3(secret, r.serverSeed)) < r.chance) { // Winner\r\n\t\t\tmsg.sender.send(calcWinnings(r.value, r.chance) - seedCost);\r\n\t\t\tWon(msg.sender, r.value, r.chance);\r\n\t\t}\r\n\t\t\r\n\t\tdelete rolls[msg.sender];\r\n\t}\r\n\t\r\n\tfunction canClaimTimeout() constant returns (bool _r) {\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed != 0) return false;\r\n\t\tif (r.value <= 0) return false;\r\n\t\tif (block.number < r.blocknum + timeout) return false;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction claimTimeout() {\r\n\t\t// Get your monies back if the server isn't responding with a seed\r\n\t\tif (!canClaimTimeout()) return;\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tmsg.sender.send(r.value);\r\n\t\tdelete rolls[msg.sender];\r\n\t}\r\n\t\r\n\tfunction getMinimumBet() constant returns (uint _r) {\r\n\t\treturn minimumBet;\r\n\t}\r\n\t\r\n\tfunction getBankroll() constant returns (uint256 _r) {\r\n\t\treturn this.balance;\r\n\t}\r\n\t\r\n\tfunction getBetsLocked() constant returns (uint _r) {\r\n\t\treturn betsLocked;\r\n\t}\r\n\t\r\n\tfunction setFeed(address newFeed) {\r\n\t\tif (msg.sender != owner) return;\r\n\t\tfeed = newFeed;\r\n\t}\r\n\t\r\n\tfunction lockBetsForWithdraw() {\r\n\t\tif (msg.sender != owner) return;\r\n\t\tuint betsLocked = block.number;\r\n\t}\r\n\t\r\n\tfunction unlockBets() {\r\n\t\tif (msg.sender != owner) return;\r\n\t\tuint betsLocked = 0;\r\n\t}\r\n\t\r\n\tfunction withdraw(uint amount) {\r\n\t\tif (msg.sender != owner) return;\r\n\t\tif (betsLocked == 0 || block.number < betsLocked + 5760) return;\r\n\t\towner.send(amount);\r\n\t}\r\n}"
  EventDefinition "Bet"
     Gas costs: 0
     Source: "event Bet(address indexed user, uint blocknum, uint256 amount, uint chance);"
    ParameterList
       Source: "(address indexed user, uint blocknum, uint256 amount, uint chance)"
      VariableDeclaration "user"
         Type: address
         Source: "address indexed user"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "blocknum"
         Type: uint256
         Source: "uint blocknum"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "chance"
         Type: uint256
         Source: "uint chance"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Won"
     Gas costs: 0
     Source: "event Won(address indexed user, uint256 amount, uint chance);"
    ParameterList
       Source: "(address indexed user, uint256 amount, uint chance)"
      VariableDeclaration "user"
         Type: address
         Source: "address indexed user"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "chance"
         Type: uint256
         Source: "uint chance"
        ElementaryTypeName uint
           Source: "uint"
  StructDefinition "Roll"
     Gas costs: 0
     Source: "struct Roll {\r\n\t\tuint256 value;\r\n\t\tuint chance;\r\n\t\tuint blocknum;\r\n\t\tbytes32 secretHash;\r\n\t\tbytes32 serverSeed;\r\n\t}"
    VariableDeclaration "value"
       Type: uint256
       Source: "uint256 value"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "chance"
       Type: uint256
       Source: "uint chance"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "blocknum"
       Type: uint256
       Source: "uint blocknum"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "secretHash"
       Type: bytes32
       Source: "bytes32 secretHash"
      ElementaryTypeName bytes32
         Source: "bytes32"
    VariableDeclaration "serverSeed"
       Type: bytes32
       Source: "bytes32 serverSeed"
      ElementaryTypeName bytes32
         Source: "bytes32"
  VariableDeclaration "betsLocked"
     Type: uint256
     Gas costs: 0
     Source: "uint betsLocked"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "owner"
     Type: address
     Gas costs: 0
     Source: "address owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "feed"
     Type: address
     Gas costs: 0
     Source: "address feed"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "minimumBet"
     Type: uint256
     Gas costs: 0
     Source: "uint256 minimumBet = 1 * 1000000000000000000"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator *
       Type: int_const 1000000000000000000
       Source: "1 * 1000000000000000000"
      Literal, token: [no token] value: 1
         Type: int_const 1
         Source: "1"
      Literal, token: [no token] value: 1000000000000000000
         Type: int_const 1000000000000000000
         Source: "1000000000000000000"
  VariableDeclaration "maxPayout"
     Type: uint256
     Gas costs: 3
     Source: "uint256 constant maxPayout = 5"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 5
       Type: int_const 5
       Source: "5"
  VariableDeclaration "seedCost"
     Type: uint256
     Gas costs: 3
     Source: "uint constant seedCost = 100000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 100000000000000000
       Type: int_const 100000000000000000
       Source: "100000000000000000"
  VariableDeclaration "rolls"
     Type: mapping(address => struct HonestDice.Roll storage ref)
     Gas costs: 0
     Source: "mapping (address => Roll) rolls"
    Mapping
       Source: "mapping (address => Roll)"
      ElementaryTypeName address
         Source: "address"
      UserDefinedTypeName "Roll"
         Source: "Roll"
  VariableDeclaration "timeout"
     Type: uint256
     Gas costs: 3
     Source: "uint constant timeout = 20"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 20
       Type: int_const 20
       Source: "20"
  FunctionDefinition "HonestDice" - public
     Source: "function HonestDice() {\r\n\t\towner = msg.sender;\r\n\t\tfeed = msg.sender;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\towner = msg.sender;\r\n\t\tfeed = msg.sender;\r\n\t}"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "feed = msg.sender"
        Assignment using operator =
           Type: address
           Source: "feed = msg.sender"
          Identifier feed
             Type: address
             Source: "feed"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "roll" - public
     Source: "function roll(uint chance, bytes32 secretHash) {\r\n\t\tif (chance < 1 || chance > 255 || msg.value < minimumBet || calcWinnings(msg.value, chance) > getMaxPayout() || betsLocked != 0) { \r\n\t\t\tmsg.sender.send(msg.value); // Refund\r\n\t\t\treturn;\r\n\t\t}\r\n\t\trolls[msg.sender] = Roll(msg.value, chance, block.number, secretHash, 0);\r\n\t\tBet(msg.sender, block.number, msg.value, chance);\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint chance, bytes32 secretHash)"
      VariableDeclaration "chance"
         Type: uint256
         Source: "uint chance"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "secretHash"
         Type: bytes32
         Source: "bytes32 secretHash"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tif (chance < 1 || chance > 255 || msg.value < minimumBet || calcWinnings(msg.value, chance) > getMaxPayout() || betsLocked != 0) { \r\n\t\t\tmsg.sender.send(msg.value); // Refund\r\n\t\t\treturn;\r\n\t\t}\r\n\t\trolls[msg.sender] = Roll(msg.value, chance, block.number, secretHash, 0);\r\n\t\tBet(msg.sender, block.number, msg.value, chance);\r\n\t}"
      IfStatement
         Source: "if (chance < 1 || chance > 255 || msg.value < minimumBet || calcWinnings(msg.value, chance) > getMaxPayout() || betsLocked != 0) { \r\n\t\t\tmsg.sender.send(msg.value); // Refund\r\n\t\t\treturn;\r\n\t\t}"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 552
           Source: "chance < 1 || chance > 255 || msg.value < minimumBet || calcWinnings(msg.value, chance) > getMaxPayout() || betsLocked != 0"
          BinaryOperation using operator ||
             Type: bool
             Source: "chance < 1 || chance > 255 || msg.value < minimumBet || calcWinnings(msg.value, chance) > getMaxPayout()"
            BinaryOperation using operator ||
               Type: bool
               Source: "chance < 1 || chance > 255 || msg.value < minimumBet"
              BinaryOperation using operator ||
                 Type: bool
                 Source: "chance < 1 || chance > 255"
                BinaryOperation using operator <
                   Type: bool
                   Source: "chance < 1"
                  Identifier chance
                     Type: uint256
                     Source: "chance"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
                BinaryOperation using operator >
                   Type: bool
                   Source: "chance > 255"
                  Identifier chance
                     Type: uint256
                     Source: "chance"
                  Literal, token: [no token] value: 255
                     Type: int_const 255
                     Source: "255"
              BinaryOperation using operator <
                 Type: bool
                 Source: "msg.value < minimumBet"
                MemberAccess to member value
                   Type: uint256
                   Source: "msg.value"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Identifier minimumBet
                   Type: uint256
                   Source: "minimumBet"
            BinaryOperation using operator >
               Type: bool
               Source: "calcWinnings(msg.value, chance) > getMaxPayout()"
              FunctionCall
                 Type: uint256
                 Source: "calcWinnings(msg.value, chance)"
                Identifier calcWinnings
                   Type: function (uint256,uint256) view returns (uint256)
                   Source: "calcWinnings"
                MemberAccess to member value
                   Type: uint256
                   Source: "msg.value"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Identifier chance
                   Type: uint256
                   Source: "chance"
              FunctionCall
                 Type: uint256
                 Source: "getMaxPayout()"
                Identifier getMaxPayout
                   Type: function () view returns (uint256)
                   Source: "getMaxPayout"
          BinaryOperation using operator !=
             Type: bool
             Source: "betsLocked != 0"
            Identifier betsLocked
               Type: uint256
               Source: "betsLocked"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{ \r\n\t\t\tmsg.sender.send(msg.value); // Refund\r\n\t\t\treturn;\r\n\t\t}"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.send(msg.value)"
            FunctionCall
               Type: bool
               Source: "msg.sender.send(msg.value)"
              MemberAccess to member send
                 Type: function (uint256) returns (bool)
                 Source: "msg.sender.send"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
          Return
             Gas costs: 11
             Source: "return;"
      ExpressionStatement
         Gas costs: [???]
         Source: "rolls[msg.sender] = Roll(msg.value, chance, block.number, secretHash, 0)"
        Assignment using operator =
           Type: struct HonestDice.Roll storage ref
           Source: "rolls[msg.sender] = Roll(msg.value, chance, block.number, secretHash, 0)"
          IndexAccess
             Type: struct HonestDice.Roll storage ref
             Source: "rolls[msg.sender]"
            Identifier rolls
               Type: mapping(address => struct HonestDice.Roll storage ref)
               Source: "rolls"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: struct HonestDice.Roll memory
             Source: "Roll(msg.value, chance, block.number, secretHash, 0)"
            Identifier Roll
               Type: type(struct HonestDice.Roll storage pointer)
               Source: "Roll"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier chance
               Type: uint256
               Source: "chance"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier secretHash
               Type: bytes32
               Source: "secretHash"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "Bet(msg.sender, block.number, msg.value, chance)"
        FunctionCall
           Type: tuple()
           Source: "Bet(msg.sender, block.number, msg.value, chance)"
          Identifier Bet
             Type: function (address,uint256,uint256,uint256)
             Source: "Bet"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier chance
             Type: uint256
             Source: "chance"
  FunctionDefinition "serverSeed" - public
     Source: "function serverSeed(address user, bytes32 seed) {\r\n\t\t// The server calls this with a random seed\r\n\t\tif (msg.sender != feed) return;\r\n\t\tif (rolls[user].serverSeed != 0) return;\r\n\t\trolls[user].serverSeed = seed;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address user, bytes32 seed)"
      VariableDeclaration "user"
         Type: address
         Source: "address user"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "seed"
         Type: bytes32
         Source: "bytes32 seed"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\t// The server calls this with a random seed\r\n\t\tif (msg.sender != feed) return;\r\n\t\tif (rolls[user].serverSeed != 0) return;\r\n\t\trolls[user].serverSeed = seed;\r\n\t}"
      IfStatement
         Source: "if (msg.sender != feed) return;"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != feed"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier feed
             Type: address
             Source: "feed"
        Return
           Gas costs: 11
           Source: "return;"
      IfStatement
         Source: "if (rolls[user].serverSeed != 0) return;"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 331
           Source: "rolls[user].serverSeed != 0"
          MemberAccess to member serverSeed
             Type: bytes32
             Source: "rolls[user].serverSeed"
            IndexAccess
               Type: struct HonestDice.Roll storage ref
               Source: "rolls[user]"
              Identifier rolls
                 Type: mapping(address => struct HonestDice.Roll storage ref)
                 Source: "rolls"
              Identifier user
                 Type: address
                 Source: "user"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 20125
         Source: "rolls[user].serverSeed = seed"
        Assignment using operator =
           Type: bytes32
           Source: "rolls[user].serverSeed = seed"
          MemberAccess to member serverSeed
             Type: bytes32
             Source: "rolls[user].serverSeed"
            IndexAccess
               Type: struct HonestDice.Roll storage ref
               Source: "rolls[user]"
              Identifier rolls
                 Type: mapping(address => struct HonestDice.Roll storage ref)
                 Source: "rolls"
              Identifier user
                 Type: address
                 Source: "user"
          Identifier seed
             Type: bytes32
             Source: "seed"
  FunctionDefinition "hashTo256" - public - const
     Source: "function hashTo256(bytes32 hash) constant returns (uint _r) {\r\n\t\t// Returns a number between 0 - 255 from a hash\r\n\t\treturn uint(hash) & 0xff;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 hash)"
      VariableDeclaration "hash"
         Type: bytes32
         Source: "bytes32 hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(uint _r)"
      VariableDeclaration "_r"
         Type: uint256
         Source: "uint _r"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\t\t// Returns a number between 0 - 255 from a hash\r\n\t\treturn uint(hash) & 0xff;\r\n\t}"
      Return
         Gas costs: 25
         Source: "return uint(hash) & 0xff"
        BinaryOperation using operator &
           Type: uint256
           Source: "uint(hash) & 0xff"
          FunctionCall
             Type: uint256
             Source: "uint(hash)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            Identifier hash
               Type: bytes32
               Source: "hash"
          Literal, token: [no token] value: 0xff
             Type: int_const 255
             Source: "0xff"
  FunctionDefinition "hash" - public - const
     Source: "function hash(bytes32 input) constant returns (uint _r) {\r\n\t\t// Simple sha3 hash. Not to be called via the blockchain\r\n\t\treturn uint(sha3(input));\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 input)"
      VariableDeclaration "input"
         Type: bytes32
         Source: "bytes32 input"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(uint _r)"
      VariableDeclaration "_r"
         Type: uint256
         Source: "uint _r"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\t\t// Simple sha3 hash. Not to be called via the blockchain\r\n\t\treturn uint(sha3(input));\r\n\t}"
      Return
         Gas costs: [???]
         Source: "return uint(sha3(input))"
        FunctionCall
           Type: uint256
           Source: "uint(sha3(input))"
          ElementaryTypeNameExpression uint
             Type: type(uint256)
             Source: "uint"
          FunctionCall
             Type: bytes32
             Source: "sha3(input)"
            Identifier sha3
               Type: function () pure returns (bytes32)
               Source: "sha3"
            Identifier input
               Type: bytes32
               Source: "input"
  FunctionDefinition "isReady" - public - const
     Source: "function isReady() constant returns (bool _r) {\r\n\t\treturn isReadyFor(msg.sender);\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool _r)"
      VariableDeclaration "_r"
         Type: bool
         Source: "bool _r"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\t\treturn isReadyFor(msg.sender);\r\n\t}"
      Return
         Gas costs: 22
         Source: "return isReadyFor(msg.sender)"
        FunctionCall
           Type: bool
           Source: "isReadyFor(msg.sender)"
          Identifier isReadyFor
             Type: function (address) view returns (bool)
             Source: "isReadyFor"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "isReadyFor" - public - const
     Source: "function isReadyFor(address _user) constant returns (bool _r) {\r\n\t\tRoll r = rolls[_user];\r\n\t\tif (r.serverSeed == 0) return false;\r\n\t\treturn true;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address _user)"
      VariableDeclaration "_user"
         Type: address
         Source: "address _user"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool _r)"
      VariableDeclaration "_r"
         Type: bool
         Source: "bool _r"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\t\tRoll r = rolls[_user];\r\n\t\tif (r.serverSeed == 0) return false;\r\n\t\treturn true;\r\n\t}"
      VariableDeclarationStatement
         Gas costs: 107
         Source: "Roll r = rolls[_user]"
        VariableDeclaration "r"
           Type: struct HonestDice.Roll storage pointer
           Source: "Roll r"
          UserDefinedTypeName "Roll"
             Source: "Roll"
        IndexAccess
           Type: struct HonestDice.Roll storage ref
           Source: "rolls[_user]"
          Identifier rolls
             Type: mapping(address => struct HonestDice.Roll storage ref)
             Source: "rolls"
          Identifier _user
             Type: address
             Source: "_user"
      IfStatement
         Source: "if (r.serverSeed == 0) return false"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 232
           Source: "r.serverSeed == 0"
          MemberAccess to member serverSeed
             Type: bytes32
             Source: "r.serverSeed"
            Identifier r
               Type: struct HonestDice.Roll storage pointer
               Source: "r"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "getResult" - public - const
     Source: "function getResult(bytes32 secret) constant returns (uint _r) {\r\n\t\t// Get the result number of the roll\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed == 0) return;\r\n\t\tif (sha3(secret) != r.secretHash) return;\r\n\t\treturn hashTo256(sha3(secret, r.serverSeed));\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 secret)"
      VariableDeclaration "secret"
         Type: bytes32
         Source: "bytes32 secret"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(uint _r)"
      VariableDeclaration "_r"
         Type: uint256
         Source: "uint _r"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\t\t// Get the result number of the roll\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed == 0) return;\r\n\t\tif (sha3(secret) != r.secretHash) return;\r\n\t\treturn hashTo256(sha3(secret, r.serverSeed));\r\n\t}"
      VariableDeclarationStatement
         Gas costs: 106
         Source: "Roll r = rolls[msg.sender]"
        VariableDeclaration "r"
           Type: struct HonestDice.Roll storage pointer
           Source: "Roll r"
          UserDefinedTypeName "Roll"
             Source: "Roll"
        IndexAccess
           Type: struct HonestDice.Roll storage ref
           Source: "rolls[msg.sender]"
          Identifier rolls
             Type: mapping(address => struct HonestDice.Roll storage ref)
             Source: "rolls"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (r.serverSeed == 0) return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 232
           Source: "r.serverSeed == 0"
          MemberAccess to member serverSeed
             Type: bytes32
             Source: "r.serverSeed"
            Identifier r
               Type: struct HonestDice.Roll storage pointer
               Source: "r"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      IfStatement
         Source: "if (sha3(secret) != r.secretHash) return;"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: [???]
           Source: "sha3(secret) != r.secretHash"
          FunctionCall
             Type: bytes32
             Source: "sha3(secret)"
            Identifier sha3
               Type: function () pure returns (bytes32)
               Source: "sha3"
            Identifier secret
               Type: bytes32
               Source: "secret"
          MemberAccess to member secretHash
             Type: bytes32
             Source: "r.secretHash"
            Identifier r
               Type: struct HonestDice.Roll storage pointer
               Source: "r"
        Return
           Gas costs: 11
           Source: "return;"
      Return
         Gas costs: [???]
         Source: "return hashTo256(sha3(secret, r.serverSeed))"
        FunctionCall
           Type: uint256
           Source: "hashTo256(sha3(secret, r.serverSeed))"
          Identifier hashTo256
             Type: function (bytes32) view returns (uint256)
             Source: "hashTo256"
          FunctionCall
             Type: bytes32
             Source: "sha3(secret, r.serverSeed)"
            Identifier sha3
               Type: function () pure returns (bytes32)
               Source: "sha3"
            Identifier secret
               Type: bytes32
               Source: "secret"
            MemberAccess to member serverSeed
               Type: bytes32
               Source: "r.serverSeed"
              Identifier r
                 Type: struct HonestDice.Roll storage pointer
                 Source: "r"
  FunctionDefinition "didWin" - public - const
     Source: "function didWin(bytes32 secret) constant returns (bool _r) {\r\n\t\t// Returns if the player won or not\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed == 0) return;\r\n\t\tif (sha3(secret) != r.secretHash) return;\r\n\t\tif (hashTo256(sha3(secret, r.serverSeed)) < r.chance) { // Winner\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 secret)"
      VariableDeclaration "secret"
         Type: bytes32
         Source: "bytes32 secret"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(bool _r)"
      VariableDeclaration "_r"
         Type: bool
         Source: "bool _r"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\t\t// Returns if the player won or not\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed == 0) return;\r\n\t\tif (sha3(secret) != r.secretHash) return;\r\n\t\tif (hashTo256(sha3(secret, r.serverSeed)) < r.chance) { // Winner\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}"
      VariableDeclarationStatement
         Gas costs: 106
         Source: "Roll r = rolls[msg.sender]"
        VariableDeclaration "r"
           Type: struct HonestDice.Roll storage pointer
           Source: "Roll r"
          UserDefinedTypeName "Roll"
             Source: "Roll"
        IndexAccess
           Type: struct HonestDice.Roll storage ref
           Source: "rolls[msg.sender]"
          Identifier rolls
             Type: mapping(address => struct HonestDice.Roll storage ref)
             Source: "rolls"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (r.serverSeed == 0) return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 232
           Source: "r.serverSeed == 0"
          MemberAccess to member serverSeed
             Type: bytes32
             Source: "r.serverSeed"
            Identifier r
               Type: struct HonestDice.Roll storage pointer
               Source: "r"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      IfStatement
         Source: "if (sha3(secret) != r.secretHash) return;"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: [???]
           Source: "sha3(secret) != r.secretHash"
          FunctionCall
             Type: bytes32
             Source: "sha3(secret)"
            Identifier sha3
               Type: function () pure returns (bytes32)
               Source: "sha3"
            Identifier secret
               Type: bytes32
               Source: "secret"
          MemberAccess to member secretHash
             Type: bytes32
             Source: "r.secretHash"
            Identifier r
               Type: struct HonestDice.Roll storage pointer
               Source: "r"
        Return
           Gas costs: 11
           Source: "return;"
      IfStatement
         Source: "if (hashTo256(sha3(secret, r.serverSeed)) < r.chance) { // Winner\r\n\t\t\treturn true;\r\n\t\t}"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "hashTo256(sha3(secret, r.serverSeed)) < r.chance"
          FunctionCall
             Type: uint256
             Source: "hashTo256(sha3(secret, r.serverSeed))"
            Identifier hashTo256
               Type: function (bytes32) view returns (uint256)
               Source: "hashTo256"
            FunctionCall
               Type: bytes32
               Source: "sha3(secret, r.serverSeed)"
              Identifier sha3
                 Type: function () pure returns (bytes32)
                 Source: "sha3"
              Identifier secret
                 Type: bytes32
                 Source: "secret"
              MemberAccess to member serverSeed
                 Type: bytes32
                 Source: "r.serverSeed"
                Identifier r
                   Type: struct HonestDice.Roll storage pointer
                   Source: "r"
          MemberAccess to member chance
             Type: uint256
             Source: "r.chance"
            Identifier r
               Type: struct HonestDice.Roll storage pointer
               Source: "r"
        Block
           Source: "{ // Winner\r\n\t\t\treturn true;\r\n\t\t}"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      Return
         Gas costs: 8
         Source: "return false"
        Literal, token: false value: false
           Type: bool
           Source: "false"
  FunctionDefinition "calcWinnings" - public - const
     Source: "function calcWinnings(uint256 value, uint chance) constant returns (uint256 _r) {\r\n\t\t// 1% house edge\r\n\t\treturn (value * 99 / 100) * 256 / chance;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint256 value, uint chance)"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "chance"
         Type: uint256
         Source: "uint chance"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint256 _r)"
      VariableDeclaration "_r"
         Type: uint256
         Source: "uint256 _r"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n\t\t// 1% house edge\r\n\t\treturn (value * 99 / 100) * 256 / chance;\r\n\t}"
      Return
         Gas costs: 86
         Source: "return (value * 99 / 100) * 256 / chance"
        BinaryOperation using operator /
           Type: uint256
           Source: "(value * 99 / 100) * 256 / chance"
          BinaryOperation using operator *
             Type: uint256
             Source: "(value * 99 / 100) * 256"
            TupleExpression
               Type: uint256
               Source: "(value * 99 / 100)"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "value * 99 / 100"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "value * 99"
                  Identifier value
                     Type: uint256
                     Source: "value"
                  Literal, token: [no token] value: 99
                     Type: int_const 99
                     Source: "99"
                Literal, token: [no token] value: 100
                   Type: int_const 100
                   Source: "100"
            Literal, token: [no token] value: 256
               Type: int_const 256
               Source: "256"
          Identifier chance
             Type: uint256
             Source: "chance"
  FunctionDefinition "getMaxPayout" - public - const
     Source: "function getMaxPayout() constant returns (uint256 _r) {\r\n\t\treturn this.balance * maxPayout / 100;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256 _r)"
      VariableDeclaration "_r"
         Type: uint256
         Source: "uint256 _r"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n\t\treturn this.balance * maxPayout / 100;\r\n\t}"
      Return
         Gas costs: 449
         Source: "return this.balance * maxPayout / 100"
        BinaryOperation using operator /
           Type: uint256
           Source: "this.balance * maxPayout / 100"
          BinaryOperation using operator *
             Type: uint256
             Source: "this.balance * maxPayout"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract HonestDice
                 Source: "this"
            Identifier maxPayout
               Type: uint256
               Source: "maxPayout"
          Literal, token: [no token] value: 100
             Type: int_const 100
             Source: "100"
  FunctionDefinition "claim" - public
     Source: "function claim(bytes32 secret) {\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed == 0) return;\r\n\t\tif (sha3(secret) != r.secretHash) return;\r\n\t\tif (hashTo256(sha3(secret, r.serverSeed)) < r.chance) { // Winner\r\n\t\t\tmsg.sender.send(calcWinnings(r.value, r.chance) - seedCost);\r\n\t\t\tWon(msg.sender, r.value, r.chance);\r\n\t\t}\r\n\t\t\r\n\t\tdelete rolls[msg.sender];\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 secret)"
      VariableDeclaration "secret"
         Type: bytes32
         Source: "bytes32 secret"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed == 0) return;\r\n\t\tif (sha3(secret) != r.secretHash) return;\r\n\t\tif (hashTo256(sha3(secret, r.serverSeed)) < r.chance) { // Winner\r\n\t\t\tmsg.sender.send(calcWinnings(r.value, r.chance) - seedCost);\r\n\t\t\tWon(msg.sender, r.value, r.chance);\r\n\t\t}\r\n\t\t\r\n\t\tdelete rolls[msg.sender];\r\n\t}"
      VariableDeclarationStatement
         Gas costs: 106
         Source: "Roll r = rolls[msg.sender]"
        VariableDeclaration "r"
           Type: struct HonestDice.Roll storage pointer
           Source: "Roll r"
          UserDefinedTypeName "Roll"
             Source: "Roll"
        IndexAccess
           Type: struct HonestDice.Roll storage ref
           Source: "rolls[msg.sender]"
          Identifier rolls
             Type: mapping(address => struct HonestDice.Roll storage ref)
             Source: "rolls"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (r.serverSeed == 0) return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 232
           Source: "r.serverSeed == 0"
          MemberAccess to member serverSeed
             Type: bytes32
             Source: "r.serverSeed"
            Identifier r
               Type: struct HonestDice.Roll storage pointer
               Source: "r"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      IfStatement
         Source: "if (sha3(secret) != r.secretHash) return;"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: [???]
           Source: "sha3(secret) != r.secretHash"
          FunctionCall
             Type: bytes32
             Source: "sha3(secret)"
            Identifier sha3
               Type: function () pure returns (bytes32)
               Source: "sha3"
            Identifier secret
               Type: bytes32
               Source: "secret"
          MemberAccess to member secretHash
             Type: bytes32
             Source: "r.secretHash"
            Identifier r
               Type: struct HonestDice.Roll storage pointer
               Source: "r"
        Return
           Gas costs: 11
           Source: "return;"
      IfStatement
         Source: "if (hashTo256(sha3(secret, r.serverSeed)) < r.chance) { // Winner\r\n\t\t\tmsg.sender.send(calcWinnings(r.value, r.chance) - seedCost);\r\n\t\t\tWon(msg.sender, r.value, r.chance);\r\n\t\t}"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "hashTo256(sha3(secret, r.serverSeed)) < r.chance"
          FunctionCall
             Type: uint256
             Source: "hashTo256(sha3(secret, r.serverSeed))"
            Identifier hashTo256
               Type: function (bytes32) view returns (uint256)
               Source: "hashTo256"
            FunctionCall
               Type: bytes32
               Source: "sha3(secret, r.serverSeed)"
              Identifier sha3
                 Type: function () pure returns (bytes32)
                 Source: "sha3"
              Identifier secret
                 Type: bytes32
                 Source: "secret"
              MemberAccess to member serverSeed
                 Type: bytes32
                 Source: "r.serverSeed"
                Identifier r
                   Type: struct HonestDice.Roll storage pointer
                   Source: "r"
          MemberAccess to member chance
             Type: uint256
             Source: "r.chance"
            Identifier r
               Type: struct HonestDice.Roll storage pointer
               Source: "r"
        Block
           Source: "{ // Winner\r\n\t\t\tmsg.sender.send(calcWinnings(r.value, r.chance) - seedCost);\r\n\t\t\tWon(msg.sender, r.value, r.chance);\r\n\t\t}"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.send(calcWinnings(r.value, r.chance) - seedCost)"
            FunctionCall
               Type: bool
               Source: "msg.sender.send(calcWinnings(r.value, r.chance) - seedCost)"
              MemberAccess to member send
                 Type: function (uint256) returns (bool)
                 Source: "msg.sender.send"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "calcWinnings(r.value, r.chance) - seedCost"
                FunctionCall
                   Type: uint256
                   Source: "calcWinnings(r.value, r.chance)"
                  Identifier calcWinnings
                     Type: function (uint256,uint256) view returns (uint256)
                     Source: "calcWinnings"
                  MemberAccess to member value
                     Type: uint256
                     Source: "r.value"
                    Identifier r
                       Type: struct HonestDice.Roll storage pointer
                       Source: "r"
                  MemberAccess to member chance
                     Type: uint256
                     Source: "r.chance"
                    Identifier r
                       Type: struct HonestDice.Roll storage pointer
                       Source: "r"
                Identifier seedCost
                   Type: uint256
                   Source: "seedCost"
          ExpressionStatement
             Gas costs: [???]
             Source: "Won(msg.sender, r.value, r.chance)"
            FunctionCall
               Type: tuple()
               Source: "Won(msg.sender, r.value, r.chance)"
              Identifier Won
                 Type: function (address,uint256,uint256)
                 Source: "Won"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              MemberAccess to member value
                 Type: uint256
                 Source: "r.value"
                Identifier r
                   Type: struct HonestDice.Roll storage pointer
                   Source: "r"
              MemberAccess to member chance
                 Type: uint256
                 Source: "r.chance"
                Identifier r
                   Type: struct HonestDice.Roll storage pointer
                   Source: "r"
      ExpressionStatement
         Gas costs: 25180
         Source: "delete rolls[msg.sender]"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete rolls[msg.sender]"
          IndexAccess
             Type: struct HonestDice.Roll storage ref
             Source: "rolls[msg.sender]"
            Identifier rolls
               Type: mapping(address => struct HonestDice.Roll storage ref)
               Source: "rolls"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "canClaimTimeout" - public - const
     Source: "function canClaimTimeout() constant returns (bool _r) {\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed != 0) return false;\r\n\t\tif (r.value <= 0) return false;\r\n\t\tif (block.number < r.blocknum + timeout) return false;\r\n\t\treturn true;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool _r)"
      VariableDeclaration "_r"
         Type: bool
         Source: "bool _r"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed != 0) return false;\r\n\t\tif (r.value <= 0) return false;\r\n\t\tif (block.number < r.blocknum + timeout) return false;\r\n\t\treturn true;\r\n\t}"
      VariableDeclarationStatement
         Gas costs: 106
         Source: "Roll r = rolls[msg.sender]"
        VariableDeclaration "r"
           Type: struct HonestDice.Roll storage pointer
           Source: "Roll r"
          UserDefinedTypeName "Roll"
             Source: "Roll"
        IndexAccess
           Type: struct HonestDice.Roll storage ref
           Source: "rolls[msg.sender]"
          Identifier rolls
             Type: mapping(address => struct HonestDice.Roll storage ref)
             Source: "rolls"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (r.serverSeed != 0) return false"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 235
           Source: "r.serverSeed != 0"
          MemberAccess to member serverSeed
             Type: bytes32
             Source: "r.serverSeed"
            Identifier r
               Type: struct HonestDice.Roll storage pointer
               Source: "r"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      IfStatement
         Source: "if (r.value <= 0) return false"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 218
           Source: "r.value <= 0"
          MemberAccess to member value
             Type: uint256
             Source: "r.value"
            Identifier r
               Type: struct HonestDice.Roll storage pointer
               Source: "r"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      IfStatement
         Source: "if (block.number < r.blocknum + timeout) return false"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 217
           Source: "block.number < r.blocknum + timeout"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          BinaryOperation using operator +
             Type: uint256
             Source: "r.blocknum + timeout"
            MemberAccess to member blocknum
               Type: uint256
               Source: "r.blocknum"
              Identifier r
                 Type: struct HonestDice.Roll storage pointer
                 Source: "r"
            Identifier timeout
               Type: uint256
               Source: "timeout"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "claimTimeout" - public
     Source: "function claimTimeout() {\r\n\t\t// Get your monies back if the server isn't responding with a seed\r\n\t\tif (!canClaimTimeout()) return;\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tmsg.sender.send(r.value);\r\n\t\tdelete rolls[msg.sender];\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\t// Get your monies back if the server isn't responding with a seed\r\n\t\tif (!canClaimTimeout()) return;\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tmsg.sender.send(r.value);\r\n\t\tdelete rolls[msg.sender];\r\n\t}"
      IfStatement
         Source: "if (!canClaimTimeout()) return;"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 7
           Source: "!canClaimTimeout()"
          FunctionCall
             Type: bool
             Source: "canClaimTimeout()"
            Identifier canClaimTimeout
               Type: function () view returns (bool)
               Source: "canClaimTimeout"
        Return
           Gas costs: 11
           Source: "return;"
      VariableDeclarationStatement
         Gas costs: 106
         Source: "Roll r = rolls[msg.sender]"
        VariableDeclaration "r"
           Type: struct HonestDice.Roll storage pointer
           Source: "Roll r"
          UserDefinedTypeName "Roll"
             Source: "Roll"
        IndexAccess
           Type: struct HonestDice.Roll storage ref
           Source: "rolls[msg.sender]"
          Identifier rolls
             Type: mapping(address => struct HonestDice.Roll storage ref)
             Source: "rolls"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: [???]
         Source: "msg.sender.send(r.value)"
        FunctionCall
           Type: bool
           Source: "msg.sender.send(r.value)"
          MemberAccess to member send
             Type: function (uint256) returns (bool)
             Source: "msg.sender.send"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          MemberAccess to member value
             Type: uint256
             Source: "r.value"
            Identifier r
               Type: struct HonestDice.Roll storage pointer
               Source: "r"
      ExpressionStatement
         Gas costs: 25174
         Source: "delete rolls[msg.sender]"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete rolls[msg.sender]"
          IndexAccess
             Type: struct HonestDice.Roll storage ref
             Source: "rolls[msg.sender]"
            Identifier rolls
               Type: mapping(address => struct HonestDice.Roll storage ref)
               Source: "rolls"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "getMinimumBet" - public - const
     Source: "function getMinimumBet() constant returns (uint _r) {\r\n\t\treturn minimumBet;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint _r)"
      VariableDeclaration "_r"
         Type: uint256
         Source: "uint _r"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\t\treturn minimumBet;\r\n\t}"
      Return
         Gas costs: 208
         Source: "return minimumBet"
        Identifier minimumBet
           Type: uint256
           Source: "minimumBet"
  FunctionDefinition "getBankroll" - public - const
     Source: "function getBankroll() constant returns (uint256 _r) {\r\n\t\treturn this.balance;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256 _r)"
      VariableDeclaration "_r"
         Type: uint256
         Source: "uint256 _r"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n\t\treturn this.balance;\r\n\t}"
      Return
         Gas costs: 413
         Source: "return this.balance"
        MemberAccess to member balance
           Type: uint256
           Source: "this.balance"
          Identifier this
             Type: contract HonestDice
             Source: "this"
  FunctionDefinition "getBetsLocked" - public - const
     Source: "function getBetsLocked() constant returns (uint _r) {\r\n\t\treturn betsLocked;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint _r)"
      VariableDeclaration "_r"
         Type: uint256
         Source: "uint _r"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\t\treturn betsLocked;\r\n\t}"
      Return
         Gas costs: 208
         Source: "return betsLocked"
        Identifier betsLocked
           Type: uint256
           Source: "betsLocked"
  FunctionDefinition "setFeed" - public
     Source: "function setFeed(address newFeed) {\r\n\t\tif (msg.sender != owner) return;\r\n\t\tfeed = newFeed;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address newFeed)"
      VariableDeclaration "newFeed"
         Type: address
         Source: "address newFeed"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tif (msg.sender != owner) return;\r\n\t\tfeed = newFeed;\r\n\t}"
      IfStatement
         Source: "if (msg.sender != owner) return;"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: 20267
         Source: "feed = newFeed"
        Assignment using operator =
           Type: address
           Source: "feed = newFeed"
          Identifier feed
             Type: address
             Source: "feed"
          Identifier newFeed
             Type: address
             Source: "newFeed"
  FunctionDefinition "lockBetsForWithdraw" - public
     Source: "function lockBetsForWithdraw() {\r\n\t\tif (msg.sender != owner) return;\r\n\t\tuint betsLocked = block.number;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tif (msg.sender != owner) return;\r\n\t\tuint betsLocked = block.number;\r\n\t}"
      IfStatement
         Source: "if (msg.sender != owner) return;"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Return
           Gas costs: 11
           Source: "return;"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint betsLocked = block.number"
        VariableDeclaration "betsLocked"
           Type: uint256
           Source: "uint betsLocked"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member number
           Type: uint256
           Source: "block.number"
          Identifier block
             Type: block
             Source: "block"
  FunctionDefinition "unlockBets" - public
     Source: "function unlockBets() {\r\n\t\tif (msg.sender != owner) return;\r\n\t\tuint betsLocked = 0;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tif (msg.sender != owner) return;\r\n\t\tuint betsLocked = 0;\r\n\t}"
      IfStatement
         Source: "if (msg.sender != owner) return;"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Return
           Gas costs: 11
           Source: "return;"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint betsLocked = 0"
        VariableDeclaration "betsLocked"
           Type: uint256
           Source: "uint betsLocked"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
  FunctionDefinition "withdraw" - public
     Source: "function withdraw(uint amount) {\r\n\t\tif (msg.sender != owner) return;\r\n\t\tif (betsLocked == 0 || block.number < betsLocked + 5760) return;\r\n\t\towner.send(amount);\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tif (msg.sender != owner) return;\r\n\t\tif (betsLocked == 0 || block.number < betsLocked + 5760) return;\r\n\t\towner.send(amount);\r\n\t}"
      IfStatement
         Source: "if (msg.sender != owner) return;"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Return
           Gas costs: 11
           Source: "return;"
      IfStatement
         Source: "if (betsLocked == 0 || block.number < betsLocked + 5760) return;"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 442
           Source: "betsLocked == 0 || block.number < betsLocked + 5760"
          BinaryOperation using operator ==
             Type: bool
             Source: "betsLocked == 0"
            Identifier betsLocked
               Type: uint256
               Source: "betsLocked"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator <
             Type: bool
             Source: "block.number < betsLocked + 5760"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            BinaryOperation using operator +
               Type: uint256
               Source: "betsLocked + 5760"
              Identifier betsLocked
                 Type: uint256
                 Source: "betsLocked"
              Literal, token: [no token] value: 5760
                 Type: int_const 5760
                 Source: "5760"
        Return
           Gas costs: 11
           Source: "return;"
      ExpressionStatement
         Gas costs: [???]
         Source: "owner.send(amount)"
        FunctionCall
           Type: bool
           Source: "owner.send(amount)"
          MemberAccess to member send
             Type: function (uint256) returns (bool)
             Source: "owner.send"
            Identifier owner
               Type: address
               Source: "owner"
          Identifier amount
             Type: uint256
             Source: "amount"
