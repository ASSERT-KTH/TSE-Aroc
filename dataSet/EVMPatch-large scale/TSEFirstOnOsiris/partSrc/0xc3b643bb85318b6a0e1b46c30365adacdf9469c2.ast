Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xc3b643bb85318b6a0e1b46c30365adacdf9469c2.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.0;"
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.0;"
ContractDefinition "OraclizeI"
   Gas costs: 0
   Source: "contract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}"
  VariableDeclaration "cbAddress"
     Type: address
     Source: "address public cbAddress"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "query" - public
     Source: "function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);"
    ParameterList
       Source: "(uint _timestamp, string _datasource, string _arg)"
      VariableDeclaration "_timestamp"
         Type: uint256
         Source: "uint _timestamp"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_datasource"
         Type: string memory
         Source: "string _datasource"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_arg"
         Type: string memory
         Source: "string _arg"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Source: "(bytes32 _id)"
      VariableDeclaration "_id"
         Type: bytes32
         Source: "bytes32 _id"
        ElementaryTypeName bytes32
           Source: "bytes32"
  FunctionDefinition "query_withGasLimit" - public
     Source: "function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);"
    ParameterList
       Source: "(uint _timestamp, string _datasource, string _arg, uint _gaslimit)"
      VariableDeclaration "_timestamp"
         Type: uint256
         Source: "uint _timestamp"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_datasource"
         Type: string memory
         Source: "string _datasource"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_arg"
         Type: string memory
         Source: "string _arg"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_gaslimit"
         Type: uint256
         Source: "uint _gaslimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bytes32 _id)"
      VariableDeclaration "_id"
         Type: bytes32
         Source: "bytes32 _id"
        ElementaryTypeName bytes32
           Source: "bytes32"
  FunctionDefinition "query2" - public
     Source: "function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);"
    ParameterList
       Source: "(uint _timestamp, string _datasource, string _arg1, string _arg2)"
      VariableDeclaration "_timestamp"
         Type: uint256
         Source: "uint _timestamp"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_datasource"
         Type: string memory
         Source: "string _datasource"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_arg1"
         Type: string memory
         Source: "string _arg1"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_arg2"
         Type: string memory
         Source: "string _arg2"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Source: "(bytes32 _id)"
      VariableDeclaration "_id"
         Type: bytes32
         Source: "bytes32 _id"
        ElementaryTypeName bytes32
           Source: "bytes32"
  FunctionDefinition "query2_withGasLimit" - public
     Source: "function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);"
    ParameterList
       Source: "(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit)"
      VariableDeclaration "_timestamp"
         Type: uint256
         Source: "uint _timestamp"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_datasource"
         Type: string memory
         Source: "string _datasource"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_arg1"
         Type: string memory
         Source: "string _arg1"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_arg2"
         Type: string memory
         Source: "string _arg2"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_gaslimit"
         Type: uint256
         Source: "uint _gaslimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bytes32 _id)"
      VariableDeclaration "_id"
         Type: bytes32
         Source: "bytes32 _id"
        ElementaryTypeName bytes32
           Source: "bytes32"
  FunctionDefinition "getPrice" - public
     Source: "function getPrice(string _datasource) returns (uint _dsprice);"
    ParameterList
       Source: "(string _datasource)"
      VariableDeclaration "_datasource"
         Type: string memory
         Source: "string _datasource"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Source: "(uint _dsprice)"
      VariableDeclaration "_dsprice"
         Type: uint256
         Source: "uint _dsprice"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "getPrice" - public
     Source: "function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);"
    ParameterList
       Source: "(string _datasource, uint gaslimit)"
      VariableDeclaration "_datasource"
         Type: string memory
         Source: "string _datasource"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "gaslimit"
         Type: uint256
         Source: "uint gaslimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint _dsprice)"
      VariableDeclaration "_dsprice"
         Type: uint256
         Source: "uint _dsprice"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "useCoupon" - public
     Source: "function useCoupon(string _coupon);"
    ParameterList
       Source: "(string _coupon)"
      VariableDeclaration "_coupon"
         Type: string memory
         Source: "string _coupon"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Source: ""
  FunctionDefinition "setProofType" - public
     Source: "function setProofType(byte _proofType);"
    ParameterList
       Source: "(byte _proofType)"
      VariableDeclaration "_proofType"
         Type: bytes1
         Source: "byte _proofType"
        ElementaryTypeName byte
           Source: "byte"
    ParameterList
       Source: ""
  FunctionDefinition "setConfig" - public
     Source: "function setConfig(bytes32 _config);"
    ParameterList
       Source: "(bytes32 _config)"
      VariableDeclaration "_config"
         Type: bytes32
         Source: "bytes32 _config"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Source: ""
  FunctionDefinition "setCustomGasPrice" - public
     Source: "function setCustomGasPrice(uint _gasPrice);"
    ParameterList
       Source: "(uint _gasPrice)"
      VariableDeclaration "_gasPrice"
         Type: uint256
         Source: "uint _gasPrice"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
ContractDefinition "OraclizeAddrResolverI"
   Gas costs: 0
   Source: "contract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}"
  FunctionDefinition "getAddress" - public
     Source: "function getAddress() returns (address _addr);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(address _addr)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
ContractDefinition "usingOraclize"
   Source: "contract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }    \r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    \r\n\r\n}"
  VariableDeclaration "day"
     Type: uint256
     Gas costs: 0
     Source: "uint constant day = 60*60*24"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: int_const 86400
       Source: "60*60*24"
      BinaryOperation using operator *
         Type: int_const 3600
         Source: "60*60"
        Literal, token: [no token] value: 60
           Type: int_const 60
           Source: "60"
        Literal, token: [no token] value: 60
           Type: int_const 60
           Source: "60"
      Literal, token: [no token] value: 24
         Type: int_const 24
         Source: "24"
  VariableDeclaration "week"
     Type: uint256
     Gas costs: 0
     Source: "uint constant week = 60*60*24*7"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: int_const 604800
       Source: "60*60*24*7"
      BinaryOperation using operator *
         Type: int_const 86400
         Source: "60*60*24"
        BinaryOperation using operator *
           Type: int_const 3600
           Source: "60*60"
          Literal, token: [no token] value: 60
             Type: int_const 60
             Source: "60"
          Literal, token: [no token] value: 60
             Type: int_const 60
             Source: "60"
        Literal, token: [no token] value: 24
           Type: int_const 24
           Source: "24"
      Literal, token: [no token] value: 7
         Type: int_const 7
         Source: "7"
  VariableDeclaration "month"
     Type: uint256
     Gas costs: 0
     Source: "uint constant month = 60*60*24*30"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: int_const 2592000
       Source: "60*60*24*30"
      BinaryOperation using operator *
         Type: int_const 86400
         Source: "60*60*24"
        BinaryOperation using operator *
           Type: int_const 3600
           Source: "60*60"
          Literal, token: [no token] value: 60
             Type: int_const 60
             Source: "60"
          Literal, token: [no token] value: 60
             Type: int_const 60
             Source: "60"
        Literal, token: [no token] value: 24
           Type: int_const 24
           Source: "24"
      Literal, token: [no token] value: 30
         Type: int_const 30
         Source: "30"
  VariableDeclaration "proofType_NONE"
     Type: bytes1
     Gas costs: 0
     Source: "byte constant proofType_NONE = 0x00"
    ElementaryTypeName byte
       Source: "byte"
    Literal, token: [no token] value: 0x00
       Type: int_const 0
       Source: "0x00"
  VariableDeclaration "proofType_TLSNotary"
     Type: bytes1
     Gas costs: 0
     Source: "byte constant proofType_TLSNotary = 0x10"
    ElementaryTypeName byte
       Source: "byte"
    Literal, token: [no token] value: 0x10
       Type: int_const 16
       Source: "0x10"
  VariableDeclaration "proofStorage_IPFS"
     Type: bytes1
     Gas costs: 3
     Source: "byte constant proofStorage_IPFS = 0x01"
    ElementaryTypeName byte
       Source: "byte"
    Literal, token: [no token] value: 0x01
       Type: int_const 1
       Source: "0x01"
  VariableDeclaration "networkID_auto"
     Type: uint8
     Gas costs: 12
     Source: "uint8 constant networkID_auto = 0"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "networkID_mainnet"
     Type: uint8
     Gas costs: 0
     Source: "uint8 constant networkID_mainnet = 1"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 1
       Type: int_const 1
       Source: "1"
  VariableDeclaration "networkID_testnet"
     Type: uint8
     Gas costs: 0
     Source: "uint8 constant networkID_testnet = 2"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 2
       Type: int_const 2
       Source: "2"
  VariableDeclaration "networkID_morden"
     Type: uint8
     Gas costs: 0
     Source: "uint8 constant networkID_morden = 2"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 2
       Type: int_const 2
       Source: "2"
  VariableDeclaration "networkID_consensys"
     Type: uint8
     Gas costs: 0
     Source: "uint8 constant networkID_consensys = 161"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 161
       Type: int_const 161
       Source: "161"
  VariableDeclaration "OAR"
     Type: contract OraclizeAddrResolverI
     Gas costs: 0
     Source: "OraclizeAddrResolverI OAR"
    UserDefinedTypeName "OraclizeAddrResolverI"
       Source: "OraclizeAddrResolverI"
  VariableDeclaration "oraclize"
     Type: contract OraclizeI
     Gas costs: 0
     Source: "OraclizeI oraclize"
    UserDefinedTypeName "OraclizeI"
       Source: "OraclizeI"
  ModifierDefinition "oraclizeAPI"
     Source: "modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }"
      IfStatement
         Source: "if(address(OAR)==0) oraclize_setNetwork(networkID_auto)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 1004
           Source: "address(OAR)==0"
          FunctionCall
             Type: address
             Source: "address(OAR)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier OAR
               Type: contract OraclizeAddrResolverI
               Source: "OAR"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 57
           Source: "oraclize_setNetwork(networkID_auto)"
          FunctionCall
             Type: bool
             Source: "oraclize_setNetwork(networkID_auto)"
            Identifier oraclize_setNetwork
               Type: function (uint8) returns (bool)
               Source: "oraclize_setNetwork"
            Identifier networkID_auto
               Type: uint8
               Source: "networkID_auto"
      ExpressionStatement
         Gas costs: [???]
         Source: "oraclize = OraclizeI(OAR.getAddress())"
        Assignment using operator =
           Type: contract OraclizeI
           Source: "oraclize = OraclizeI(OAR.getAddress())"
          Identifier oraclize
             Type: contract OraclizeI
             Source: "oraclize"
          FunctionCall
             Type: contract OraclizeI
             Source: "OraclizeI(OAR.getAddress())"
            Identifier OraclizeI
               Type: type(contract OraclizeI)
               Source: "OraclizeI"
            FunctionCall
               Type: address
               Source: "OAR.getAddress()"
              MemberAccess to member getAddress
                 Type: function () external returns (address)
                 Source: "OAR.getAddress"
                Identifier OAR
                   Type: contract OraclizeAddrResolverI
                   Source: "OAR"
      PlaceholderStatement
         Gas costs: 1
         Source: "_"
  ModifierDefinition "coupon"
     Source: "modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string code)"
      VariableDeclaration "code"
         Type: string memory
         Source: "string code"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "oraclize = OraclizeI(OAR.getAddress())"
        Assignment using operator =
           Type: contract OraclizeI
           Source: "oraclize = OraclizeI(OAR.getAddress())"
          Identifier oraclize
             Type: contract OraclizeI
             Source: "oraclize"
          FunctionCall
             Type: contract OraclizeI
             Source: "OraclizeI(OAR.getAddress())"
            Identifier OraclizeI
               Type: type(contract OraclizeI)
               Source: "OraclizeI"
            FunctionCall
               Type: address
               Source: "OAR.getAddress()"
              MemberAccess to member getAddress
                 Type: function () external returns (address)
                 Source: "OAR.getAddress"
                Identifier OAR
                   Type: contract OraclizeAddrResolverI
                   Source: "OAR"
      ExpressionStatement
         Gas costs: 0
         Source: "oraclize.useCoupon(code)"
        FunctionCall
           Type: tuple()
           Source: "oraclize.useCoupon(code)"
          MemberAccess to member useCoupon
             Type: function (string memory) external
             Source: "oraclize.useCoupon"
            Identifier oraclize
               Type: contract OraclizeI
               Source: "oraclize"
          Identifier code
             Type: string memory
             Source: "code"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "oraclize_setNetwork"
     Source: "function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint8 networkID)"
      VariableDeclaration "networkID"
         Type: uint8
         Source: "uint8 networkID"
        ElementaryTypeName uint8
           Source: "uint8"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }"
      IfStatement
         Source: "if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 13
           Source: "getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0"
          FunctionCall
             Type: uint256
             Source: "getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)"
            Identifier getCodeSize
               Type: function (address) view returns (uint256)
               Source: "getCodeSize"
            Literal, token: [no token] value: 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed
               Type: int_const 1668...(40 digits omitted)...3965
               Source: "0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 20267
             Source: "OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)"
            Assignment using operator =
               Type: contract OraclizeAddrResolverI
               Source: "OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)"
              Identifier OAR
                 Type: contract OraclizeAddrResolverI
                 Source: "OAR"
              FunctionCall
                 Type: contract OraclizeAddrResolverI
                 Source: "OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)"
                Identifier OraclizeAddrResolverI
                   Type: type(contract OraclizeAddrResolverI)
                   Source: "OraclizeAddrResolverI"
                Literal, token: [no token] value: 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed
                   Type: int_const 1668...(40 digits omitted)...3965
                   Source: "0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      IfStatement
         Source: "if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 24
           Source: "getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0"
          FunctionCall
             Type: uint256
             Source: "getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)"
            Identifier getCodeSize
               Type: function (address) view returns (uint256)
               Source: "getCodeSize"
            Literal, token: [no token] value: 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1
               Type: int_const 1097...(41 digits omitted)...2321
               Source: "0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 20267
             Source: "OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)"
            Assignment using operator =
               Type: contract OraclizeAddrResolverI
               Source: "OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)"
              Identifier OAR
                 Type: contract OraclizeAddrResolverI
                 Source: "OAR"
              FunctionCall
                 Type: contract OraclizeAddrResolverI
                 Source: "OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)"
                Identifier OraclizeAddrResolverI
                   Type: type(contract OraclizeAddrResolverI)
                   Source: "OraclizeAddrResolverI"
                Literal, token: [no token] value: 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1
                   Type: int_const 1097...(41 digits omitted)...2321
                   Source: "0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      IfStatement
         Source: "if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 24
           Source: "getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0"
          FunctionCall
             Type: uint256
             Source: "getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)"
            Identifier getCodeSize
               Type: function (address) view returns (uint256)
               Source: "getCodeSize"
            Literal, token: [no token] value: 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa
               Type: int_const 4677...(40 digits omitted)...1034
               Source: "0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 20267
             Source: "OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)"
            Assignment using operator =
               Type: contract OraclizeAddrResolverI
               Source: "OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)"
              Identifier OAR
                 Type: contract OraclizeAddrResolverI
                 Source: "OAR"
              FunctionCall
                 Type: contract OraclizeAddrResolverI
                 Source: "OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)"
                Identifier OraclizeAddrResolverI
                   Type: type(contract OraclizeAddrResolverI)
                   Source: "OraclizeAddrResolverI"
                Literal, token: [no token] value: 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa
                   Type: int_const 4677...(40 digits omitted)...1034
                   Source: "0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      Return
         Gas costs: 8
         Source: "return false"
        Literal, token: false value: false
           Type: bool
           Source: "false"
  FunctionDefinition "oraclize_query"
     Source: "function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string datasource, string arg)"
      VariableDeclaration "datasource"
         Type: string memory
         Source: "string datasource"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "arg"
         Type: string memory
         Source: "string arg"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 id)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ModifierInvocation "oraclizeAPI"
       Gas costs: 0
       Source: "oraclizeAPI"
      Identifier oraclizeAPI
         Type: modifier ()
         Source: "oraclizeAPI"
    Block
       Source: "{\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint price = oraclize.getPrice(datasource)"
        VariableDeclaration "price"
           Type: uint256
           Source: "uint price"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "oraclize.getPrice(datasource)"
          MemberAccess to member getPrice
             Type: function (string memory) external returns (uint256)
             Source: "oraclize.getPrice"
            Identifier oraclize
               Type: contract OraclizeI
               Source: "oraclize"
          Identifier datasource
             Type: string memory
             Source: "datasource"
      IfStatement
         Source: "if (price > 1 ether + tx.gasprice*200000) return 0"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "price > 1 ether + tx.gasprice*200000"
          Identifier price
             Type: uint256
             Source: "price"
          BinaryOperation using operator +
             Type: uint256
             Source: "1 ether + tx.gasprice*200000"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
            BinaryOperation using operator *
               Type: uint256
               Source: "tx.gasprice*200000"
              MemberAccess to member gasprice
                 Type: uint256
                 Source: "tx.gasprice"
                Identifier tx
                   Type: tx
                   Source: "tx"
              Literal, token: [no token] value: 200000
                 Type: int_const 200000
                 Source: "200000"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      Return
         Gas costs: 0
         Source: "return oraclize.query.value(price)(0, datasource, arg)"
        FunctionCall
           Type: bytes32
           Source: "oraclize.query.value(price)(0, datasource, arg)"
          FunctionCall
             Type: function (uint256,string memory,string memory) payable external returns (bytes32)
             Source: "oraclize.query.value(price)"
            MemberAccess to member value
               Type: function (uint256) returns (function (uint256,string memory,string memory) payable external returns (bytes32))
               Source: "oraclize.query.value"
              MemberAccess to member query
                 Type: function (uint256,string memory,string memory) payable external returns (bytes32)
                 Source: "oraclize.query"
                Identifier oraclize
                   Type: contract OraclizeI
                   Source: "oraclize"
            Identifier price
               Type: uint256
               Source: "price"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Identifier datasource
             Type: string memory
             Source: "datasource"
          Identifier arg
             Type: string memory
             Source: "arg"
  FunctionDefinition "oraclize_query"
     Source: "function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint timestamp, string datasource, string arg)"
      VariableDeclaration "timestamp"
         Type: uint256
         Source: "uint timestamp"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "datasource"
         Type: string memory
         Source: "string datasource"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "arg"
         Type: string memory
         Source: "string arg"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 id)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ModifierInvocation "oraclizeAPI"
       Gas costs: 0
       Source: "oraclizeAPI"
      Identifier oraclizeAPI
         Type: modifier ()
         Source: "oraclizeAPI"
    Block
       Source: "{\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint price = oraclize.getPrice(datasource)"
        VariableDeclaration "price"
           Type: uint256
           Source: "uint price"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "oraclize.getPrice(datasource)"
          MemberAccess to member getPrice
             Type: function (string memory) external returns (uint256)
             Source: "oraclize.getPrice"
            Identifier oraclize
               Type: contract OraclizeI
               Source: "oraclize"
          Identifier datasource
             Type: string memory
             Source: "datasource"
      IfStatement
         Source: "if (price > 1 ether + tx.gasprice*200000) return 0"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "price > 1 ether + tx.gasprice*200000"
          Identifier price
             Type: uint256
             Source: "price"
          BinaryOperation using operator +
             Type: uint256
             Source: "1 ether + tx.gasprice*200000"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
            BinaryOperation using operator *
               Type: uint256
               Source: "tx.gasprice*200000"
              MemberAccess to member gasprice
                 Type: uint256
                 Source: "tx.gasprice"
                Identifier tx
                   Type: tx
                   Source: "tx"
              Literal, token: [no token] value: 200000
                 Type: int_const 200000
                 Source: "200000"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      Return
         Gas costs: 0
         Source: "return oraclize.query.value(price)(timestamp, datasource, arg)"
        FunctionCall
           Type: bytes32
           Source: "oraclize.query.value(price)(timestamp, datasource, arg)"
          FunctionCall
             Type: function (uint256,string memory,string memory) payable external returns (bytes32)
             Source: "oraclize.query.value(price)"
            MemberAccess to member value
               Type: function (uint256) returns (function (uint256,string memory,string memory) payable external returns (bytes32))
               Source: "oraclize.query.value"
              MemberAccess to member query
                 Type: function (uint256,string memory,string memory) payable external returns (bytes32)
                 Source: "oraclize.query"
                Identifier oraclize
                   Type: contract OraclizeI
                   Source: "oraclize"
            Identifier price
               Type: uint256
               Source: "price"
          Identifier timestamp
             Type: uint256
             Source: "timestamp"
          Identifier datasource
             Type: string memory
             Source: "datasource"
          Identifier arg
             Type: string memory
             Source: "arg"
  FunctionDefinition "oraclize_query"
     Source: "function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint timestamp, string datasource, string arg, uint gaslimit)"
      VariableDeclaration "timestamp"
         Type: uint256
         Source: "uint timestamp"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "datasource"
         Type: string memory
         Source: "string datasource"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "arg"
         Type: string memory
         Source: "string arg"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "gaslimit"
         Type: uint256
         Source: "uint gaslimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 id)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ModifierInvocation "oraclizeAPI"
       Gas costs: 0
       Source: "oraclizeAPI"
      Identifier oraclizeAPI
         Type: modifier ()
         Source: "oraclizeAPI"
    Block
       Source: "{\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint price = oraclize.getPrice(datasource, gaslimit)"
        VariableDeclaration "price"
           Type: uint256
           Source: "uint price"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "oraclize.getPrice(datasource, gaslimit)"
          MemberAccess to member getPrice
             Type: function (string memory,uint256) external returns (uint256)
             Source: "oraclize.getPrice"
            Identifier oraclize
               Type: contract OraclizeI
               Source: "oraclize"
          Identifier datasource
             Type: string memory
             Source: "datasource"
          Identifier gaslimit
             Type: uint256
             Source: "gaslimit"
      IfStatement
         Source: "if (price > 1 ether + tx.gasprice*gaslimit) return 0"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "price > 1 ether + tx.gasprice*gaslimit"
          Identifier price
             Type: uint256
             Source: "price"
          BinaryOperation using operator +
             Type: uint256
             Source: "1 ether + tx.gasprice*gaslimit"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
            BinaryOperation using operator *
               Type: uint256
               Source: "tx.gasprice*gaslimit"
              MemberAccess to member gasprice
                 Type: uint256
                 Source: "tx.gasprice"
                Identifier tx
                   Type: tx
                   Source: "tx"
              Identifier gaslimit
                 Type: uint256
                 Source: "gaslimit"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      Return
         Gas costs: 0
         Source: "return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit)"
        FunctionCall
           Type: bytes32
           Source: "oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit)"
          FunctionCall
             Type: function (uint256,string memory,string memory,uint256) payable external returns (bytes32)
             Source: "oraclize.query_withGasLimit.value(price)"
            MemberAccess to member value
               Type: function (uint256) returns (function (uint256,string memory,string memory,uint256) payable external returns (bytes32))
               Source: "oraclize.query_withGasLimit.value"
              MemberAccess to member query_withGasLimit
                 Type: function (uint256,string memory,string memory,uint256) payable external returns (bytes32)
                 Source: "oraclize.query_withGasLimit"
                Identifier oraclize
                   Type: contract OraclizeI
                   Source: "oraclize"
            Identifier price
               Type: uint256
               Source: "price"
          Identifier timestamp
             Type: uint256
             Source: "timestamp"
          Identifier datasource
             Type: string memory
             Source: "datasource"
          Identifier arg
             Type: string memory
             Source: "arg"
          Identifier gaslimit
             Type: uint256
             Source: "gaslimit"
  FunctionDefinition "oraclize_query"
     Source: "function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string datasource, string arg, uint gaslimit)"
      VariableDeclaration "datasource"
         Type: string memory
         Source: "string datasource"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "arg"
         Type: string memory
         Source: "string arg"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "gaslimit"
         Type: uint256
         Source: "uint gaslimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bytes32 id)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ModifierInvocation "oraclizeAPI"
       Gas costs: 0
       Source: "oraclizeAPI"
      Identifier oraclizeAPI
         Type: modifier ()
         Source: "oraclizeAPI"
    Block
       Source: "{\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint price = oraclize.getPrice(datasource, gaslimit)"
        VariableDeclaration "price"
           Type: uint256
           Source: "uint price"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "oraclize.getPrice(datasource, gaslimit)"
          MemberAccess to member getPrice
             Type: function (string memory,uint256) external returns (uint256)
             Source: "oraclize.getPrice"
            Identifier oraclize
               Type: contract OraclizeI
               Source: "oraclize"
          Identifier datasource
             Type: string memory
             Source: "datasource"
          Identifier gaslimit
             Type: uint256
             Source: "gaslimit"
      IfStatement
         Source: "if (price > 1 ether + tx.gasprice*gaslimit) return 0"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 22
           Source: "price > 1 ether + tx.gasprice*gaslimit"
          Identifier price
             Type: uint256
             Source: "price"
          BinaryOperation using operator +
             Type: uint256
             Source: "1 ether + tx.gasprice*gaslimit"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
            BinaryOperation using operator *
               Type: uint256
               Source: "tx.gasprice*gaslimit"
              MemberAccess to member gasprice
                 Type: uint256
                 Source: "tx.gasprice"
                Identifier tx
                   Type: tx
                   Source: "tx"
              Identifier gaslimit
                 Type: uint256
                 Source: "gaslimit"
        Return
           Gas costs: 27
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      Return
         Gas costs: [???]
         Source: "return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit)"
        FunctionCall
           Type: bytes32
           Source: "oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit)"
          FunctionCall
             Type: function (uint256,string memory,string memory,uint256) payable external returns (bytes32)
             Source: "oraclize.query_withGasLimit.value(price)"
            MemberAccess to member value
               Type: function (uint256) returns (function (uint256,string memory,string memory,uint256) payable external returns (bytes32))
               Source: "oraclize.query_withGasLimit.value"
              MemberAccess to member query_withGasLimit
                 Type: function (uint256,string memory,string memory,uint256) payable external returns (bytes32)
                 Source: "oraclize.query_withGasLimit"
                Identifier oraclize
                   Type: contract OraclizeI
                   Source: "oraclize"
            Identifier price
               Type: uint256
               Source: "price"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Identifier datasource
             Type: string memory
             Source: "datasource"
          Identifier arg
             Type: string memory
             Source: "arg"
          Identifier gaslimit
             Type: uint256
             Source: "gaslimit"
  FunctionDefinition "oraclize_query"
     Source: "function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string datasource, string arg1, string arg2)"
      VariableDeclaration "datasource"
         Type: string memory
         Source: "string datasource"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "arg1"
         Type: string memory
         Source: "string arg1"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "arg2"
         Type: string memory
         Source: "string arg2"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 id)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ModifierInvocation "oraclizeAPI"
       Gas costs: 0
       Source: "oraclizeAPI"
      Identifier oraclizeAPI
         Type: modifier ()
         Source: "oraclizeAPI"
    Block
       Source: "{\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint price = oraclize.getPrice(datasource)"
        VariableDeclaration "price"
           Type: uint256
           Source: "uint price"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "oraclize.getPrice(datasource)"
          MemberAccess to member getPrice
             Type: function (string memory) external returns (uint256)
             Source: "oraclize.getPrice"
            Identifier oraclize
               Type: contract OraclizeI
               Source: "oraclize"
          Identifier datasource
             Type: string memory
             Source: "datasource"
      IfStatement
         Source: "if (price > 1 ether + tx.gasprice*200000) return 0"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "price > 1 ether + tx.gasprice*200000"
          Identifier price
             Type: uint256
             Source: "price"
          BinaryOperation using operator +
             Type: uint256
             Source: "1 ether + tx.gasprice*200000"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
            BinaryOperation using operator *
               Type: uint256
               Source: "tx.gasprice*200000"
              MemberAccess to member gasprice
                 Type: uint256
                 Source: "tx.gasprice"
                Identifier tx
                   Type: tx
                   Source: "tx"
              Literal, token: [no token] value: 200000
                 Type: int_const 200000
                 Source: "200000"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      Return
         Gas costs: 0
         Source: "return oraclize.query2.value(price)(0, datasource, arg1, arg2)"
        FunctionCall
           Type: bytes32
           Source: "oraclize.query2.value(price)(0, datasource, arg1, arg2)"
          FunctionCall
             Type: function (uint256,string memory,string memory,string memory) payable external returns (bytes32)
             Source: "oraclize.query2.value(price)"
            MemberAccess to member value
               Type: function (uint256) returns (function (uint256,string memory,string memory,string memory) payable external returns (bytes32))
               Source: "oraclize.query2.value"
              MemberAccess to member query2
                 Type: function (uint256,string memory,string memory,string memory) payable external returns (bytes32)
                 Source: "oraclize.query2"
                Identifier oraclize
                   Type: contract OraclizeI
                   Source: "oraclize"
            Identifier price
               Type: uint256
               Source: "price"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Identifier datasource
             Type: string memory
             Source: "datasource"
          Identifier arg1
             Type: string memory
             Source: "arg1"
          Identifier arg2
             Type: string memory
             Source: "arg2"
  FunctionDefinition "oraclize_query"
     Source: "function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint timestamp, string datasource, string arg1, string arg2)"
      VariableDeclaration "timestamp"
         Type: uint256
         Source: "uint timestamp"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "datasource"
         Type: string memory
         Source: "string datasource"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "arg1"
         Type: string memory
         Source: "string arg1"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "arg2"
         Type: string memory
         Source: "string arg2"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 id)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ModifierInvocation "oraclizeAPI"
       Gas costs: 0
       Source: "oraclizeAPI"
      Identifier oraclizeAPI
         Type: modifier ()
         Source: "oraclizeAPI"
    Block
       Source: "{\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint price = oraclize.getPrice(datasource)"
        VariableDeclaration "price"
           Type: uint256
           Source: "uint price"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "oraclize.getPrice(datasource)"
          MemberAccess to member getPrice
             Type: function (string memory) external returns (uint256)
             Source: "oraclize.getPrice"
            Identifier oraclize
               Type: contract OraclizeI
               Source: "oraclize"
          Identifier datasource
             Type: string memory
             Source: "datasource"
      IfStatement
         Source: "if (price > 1 ether + tx.gasprice*200000) return 0"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "price > 1 ether + tx.gasprice*200000"
          Identifier price
             Type: uint256
             Source: "price"
          BinaryOperation using operator +
             Type: uint256
             Source: "1 ether + tx.gasprice*200000"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
            BinaryOperation using operator *
               Type: uint256
               Source: "tx.gasprice*200000"
              MemberAccess to member gasprice
                 Type: uint256
                 Source: "tx.gasprice"
                Identifier tx
                   Type: tx
                   Source: "tx"
              Literal, token: [no token] value: 200000
                 Type: int_const 200000
                 Source: "200000"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      Return
         Gas costs: 0
         Source: "return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2)"
        FunctionCall
           Type: bytes32
           Source: "oraclize.query2.value(price)(timestamp, datasource, arg1, arg2)"
          FunctionCall
             Type: function (uint256,string memory,string memory,string memory) payable external returns (bytes32)
             Source: "oraclize.query2.value(price)"
            MemberAccess to member value
               Type: function (uint256) returns (function (uint256,string memory,string memory,string memory) payable external returns (bytes32))
               Source: "oraclize.query2.value"
              MemberAccess to member query2
                 Type: function (uint256,string memory,string memory,string memory) payable external returns (bytes32)
                 Source: "oraclize.query2"
                Identifier oraclize
                   Type: contract OraclizeI
                   Source: "oraclize"
            Identifier price
               Type: uint256
               Source: "price"
          Identifier timestamp
             Type: uint256
             Source: "timestamp"
          Identifier datasource
             Type: string memory
             Source: "datasource"
          Identifier arg1
             Type: string memory
             Source: "arg1"
          Identifier arg2
             Type: string memory
             Source: "arg2"
  FunctionDefinition "oraclize_query"
     Source: "function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit)"
      VariableDeclaration "timestamp"
         Type: uint256
         Source: "uint timestamp"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "datasource"
         Type: string memory
         Source: "string datasource"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "arg1"
         Type: string memory
         Source: "string arg1"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "arg2"
         Type: string memory
         Source: "string arg2"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "gaslimit"
         Type: uint256
         Source: "uint gaslimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 id)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ModifierInvocation "oraclizeAPI"
       Gas costs: 0
       Source: "oraclizeAPI"
      Identifier oraclizeAPI
         Type: modifier ()
         Source: "oraclizeAPI"
    Block
       Source: "{\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint price = oraclize.getPrice(datasource, gaslimit)"
        VariableDeclaration "price"
           Type: uint256
           Source: "uint price"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "oraclize.getPrice(datasource, gaslimit)"
          MemberAccess to member getPrice
             Type: function (string memory,uint256) external returns (uint256)
             Source: "oraclize.getPrice"
            Identifier oraclize
               Type: contract OraclizeI
               Source: "oraclize"
          Identifier datasource
             Type: string memory
             Source: "datasource"
          Identifier gaslimit
             Type: uint256
             Source: "gaslimit"
      IfStatement
         Source: "if (price > 1 ether + tx.gasprice*gaslimit) return 0"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "price > 1 ether + tx.gasprice*gaslimit"
          Identifier price
             Type: uint256
             Source: "price"
          BinaryOperation using operator +
             Type: uint256
             Source: "1 ether + tx.gasprice*gaslimit"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
            BinaryOperation using operator *
               Type: uint256
               Source: "tx.gasprice*gaslimit"
              MemberAccess to member gasprice
                 Type: uint256
                 Source: "tx.gasprice"
                Identifier tx
                   Type: tx
                   Source: "tx"
              Identifier gaslimit
                 Type: uint256
                 Source: "gaslimit"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      Return
         Gas costs: 0
         Source: "return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit)"
        FunctionCall
           Type: bytes32
           Source: "oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit)"
          FunctionCall
             Type: function (uint256,string memory,string memory,string memory,uint256) payable external returns (bytes32)
             Source: "oraclize.query2_withGasLimit.value(price)"
            MemberAccess to member value
               Type: function (uint256) returns (function (uint256,string memory,string memory,string memory,uint256) payable external returns (bytes32))
               Source: "oraclize.query2_withGasLimit.value"
              MemberAccess to member query2_withGasLimit
                 Type: function (uint256,string memory,string memory,string memory,uint256) payable external returns (bytes32)
                 Source: "oraclize.query2_withGasLimit"
                Identifier oraclize
                   Type: contract OraclizeI
                   Source: "oraclize"
            Identifier price
               Type: uint256
               Source: "price"
          Identifier timestamp
             Type: uint256
             Source: "timestamp"
          Identifier datasource
             Type: string memory
             Source: "datasource"
          Identifier arg1
             Type: string memory
             Source: "arg1"
          Identifier arg2
             Type: string memory
             Source: "arg2"
          Identifier gaslimit
             Type: uint256
             Source: "gaslimit"
  FunctionDefinition "oraclize_query"
     Source: "function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string datasource, string arg1, string arg2, uint gaslimit)"
      VariableDeclaration "datasource"
         Type: string memory
         Source: "string datasource"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "arg1"
         Type: string memory
         Source: "string arg1"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "arg2"
         Type: string memory
         Source: "string arg2"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "gaslimit"
         Type: uint256
         Source: "uint gaslimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 id)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ModifierInvocation "oraclizeAPI"
       Gas costs: 0
       Source: "oraclizeAPI"
      Identifier oraclizeAPI
         Type: modifier ()
         Source: "oraclizeAPI"
    Block
       Source: "{\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint price = oraclize.getPrice(datasource, gaslimit)"
        VariableDeclaration "price"
           Type: uint256
           Source: "uint price"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "oraclize.getPrice(datasource, gaslimit)"
          MemberAccess to member getPrice
             Type: function (string memory,uint256) external returns (uint256)
             Source: "oraclize.getPrice"
            Identifier oraclize
               Type: contract OraclizeI
               Source: "oraclize"
          Identifier datasource
             Type: string memory
             Source: "datasource"
          Identifier gaslimit
             Type: uint256
             Source: "gaslimit"
      IfStatement
         Source: "if (price > 1 ether + tx.gasprice*gaslimit) return 0"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "price > 1 ether + tx.gasprice*gaslimit"
          Identifier price
             Type: uint256
             Source: "price"
          BinaryOperation using operator +
             Type: uint256
             Source: "1 ether + tx.gasprice*gaslimit"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
            BinaryOperation using operator *
               Type: uint256
               Source: "tx.gasprice*gaslimit"
              MemberAccess to member gasprice
                 Type: uint256
                 Source: "tx.gasprice"
                Identifier tx
                   Type: tx
                   Source: "tx"
              Identifier gaslimit
                 Type: uint256
                 Source: "gaslimit"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      Return
         Gas costs: 0
         Source: "return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit)"
        FunctionCall
           Type: bytes32
           Source: "oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit)"
          FunctionCall
             Type: function (uint256,string memory,string memory,string memory,uint256) payable external returns (bytes32)
             Source: "oraclize.query2_withGasLimit.value(price)"
            MemberAccess to member value
               Type: function (uint256) returns (function (uint256,string memory,string memory,string memory,uint256) payable external returns (bytes32))
               Source: "oraclize.query2_withGasLimit.value"
              MemberAccess to member query2_withGasLimit
                 Type: function (uint256,string memory,string memory,string memory,uint256) payable external returns (bytes32)
                 Source: "oraclize.query2_withGasLimit"
                Identifier oraclize
                   Type: contract OraclizeI
                   Source: "oraclize"
            Identifier price
               Type: uint256
               Source: "price"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Identifier datasource
             Type: string memory
             Source: "datasource"
          Identifier arg1
             Type: string memory
             Source: "arg1"
          Identifier arg2
             Type: string memory
             Source: "arg2"
          Identifier gaslimit
             Type: uint256
             Source: "gaslimit"
  FunctionDefinition "oraclize_cbAddress"
     Source: "function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    ModifierInvocation "oraclizeAPI"
       Gas costs: 0
       Source: "oraclizeAPI"
      Identifier oraclizeAPI
         Type: modifier ()
         Source: "oraclizeAPI"
    Block
       Source: "{\r\n        return oraclize.cbAddress();\r\n    }"
      Return
         Gas costs: [???]
         Source: "return oraclize.cbAddress()"
        FunctionCall
           Type: address
           Source: "oraclize.cbAddress()"
          MemberAccess to member cbAddress
             Type: function () view external returns (address)
             Source: "oraclize.cbAddress"
            Identifier oraclize
               Type: contract OraclizeI
               Source: "oraclize"
  FunctionDefinition "oraclize_setProof"
     Source: "function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(byte proofP)"
      VariableDeclaration "proofP"
         Type: bytes1
         Source: "byte proofP"
        ElementaryTypeName byte
           Source: "byte"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "oraclizeAPI"
       Gas costs: 0
       Source: "oraclizeAPI"
      Identifier oraclizeAPI
         Type: modifier ()
         Source: "oraclizeAPI"
    Block
       Source: "{\r\n        return oraclize.setProofType(proofP);\r\n    }"
      Return
         Gas costs: [???]
         Source: "return oraclize.setProofType(proofP)"
        FunctionCall
           Type: tuple()
           Source: "oraclize.setProofType(proofP)"
          MemberAccess to member setProofType
             Type: function (bytes1) external
             Source: "oraclize.setProofType"
            Identifier oraclize
               Type: contract OraclizeI
               Source: "oraclize"
          Identifier proofP
             Type: bytes1
             Source: "proofP"
  FunctionDefinition "oraclize_setCustomGasPrice"
     Source: "function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint gasPrice)"
      VariableDeclaration "gasPrice"
         Type: uint256
         Source: "uint gasPrice"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "oraclizeAPI"
       Gas costs: 0
       Source: "oraclizeAPI"
      Identifier oraclizeAPI
         Type: modifier ()
         Source: "oraclizeAPI"
    Block
       Source: "{\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }"
      Return
         Gas costs: 0
         Source: "return oraclize.setCustomGasPrice(gasPrice)"
        FunctionCall
           Type: tuple()
           Source: "oraclize.setCustomGasPrice(gasPrice)"
          MemberAccess to member setCustomGasPrice
             Type: function (uint256) external
             Source: "oraclize.setCustomGasPrice"
            Identifier oraclize
               Type: contract OraclizeI
               Source: "oraclize"
          Identifier gasPrice
             Type: uint256
             Source: "gasPrice"
  FunctionDefinition "oraclize_setConfig"
     Source: "function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 config)"
      VariableDeclaration "config"
         Type: bytes32
         Source: "bytes32 config"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "oraclizeAPI"
       Gas costs: 0
       Source: "oraclizeAPI"
      Identifier oraclizeAPI
         Type: modifier ()
         Source: "oraclizeAPI"
    Block
       Source: "{\r\n        return oraclize.setConfig(config);\r\n    }"
      Return
         Gas costs: [???]
         Source: "return oraclize.setConfig(config)"
        FunctionCall
           Type: tuple()
           Source: "oraclize.setConfig(config)"
          MemberAccess to member setConfig
             Type: function (bytes32) external
             Source: "oraclize.setConfig"
            Identifier oraclize
               Type: contract OraclizeI
               Source: "oraclize"
          Identifier config
             Type: bytes32
             Source: "config"
  FunctionDefinition "getCodeSize" - const
     Source: "function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _addr)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint _size)"
      VariableDeclaration "_size"
         Type: uint256
         Source: "uint _size"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }"
  FunctionDefinition "parseAddr"
     Source: "function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string _a)"
      VariableDeclaration "_a"
         Type: string memory
         Source: "string _a"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory tmp = bytes(_a)"
        VariableDeclaration "tmp"
           Type: bytes memory
           Source: "bytes memory tmp"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(_a)"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          Identifier _a
             Type: string memory
             Source: "_a"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint160 iaddr = 0"
        VariableDeclaration "iaddr"
           Type: uint160
           Source: "uint160 iaddr"
          ElementaryTypeName uint160
             Source: "uint160"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint160 b1"
        VariableDeclaration "b1"
           Type: uint160
           Source: "uint160 b1"
          ElementaryTypeName uint160
             Source: "uint160"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint160 b2"
        VariableDeclaration "b2"
           Type: uint160
           Source: "uint160 b2"
          ElementaryTypeName uint160
             Source: "uint160"
      ForStatement
         Source: "for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i=2"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i<2+2*20"
          Identifier i
             Type: uint256
             Source: "i"
          BinaryOperation using operator +
             Type: int_const 42
             Source: "2+2*20"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
            BinaryOperation using operator *
               Type: int_const 40
               Source: "2*20"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
              Literal, token: [no token] value: 20
                 Type: int_const 20
                 Source: "20"
        ExpressionStatement
           Gas costs: 0
           Source: "i+=2"
          Assignment using operator +=
             Type: uint256
             Source: "i+=2"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
        Block
           Source: "{\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "iaddr *= 256"
            Assignment using operator *=
               Type: uint160
               Source: "iaddr *= 256"
              Identifier iaddr
                 Type: uint160
                 Source: "iaddr"
              Literal, token: [no token] value: 256
                 Type: int_const 256
                 Source: "256"
          ExpressionStatement
             Gas costs: 0
             Source: "b1 = uint160(tmp[i])"
            Assignment using operator =
               Type: uint160
               Source: "b1 = uint160(tmp[i])"
              Identifier b1
                 Type: uint160
                 Source: "b1"
              FunctionCall
                 Type: uint160
                 Source: "uint160(tmp[i])"
                ElementaryTypeNameExpression uint160
                   Type: type(uint160)
                   Source: "uint160"
                IndexAccess
                   Type: bytes1
                   Source: "tmp[i]"
                  Identifier tmp
                     Type: bytes memory
                     Source: "tmp"
                  Identifier i
                     Type: uint256
                     Source: "i"
          ExpressionStatement
             Gas costs: 0
             Source: "b2 = uint160(tmp[i+1])"
            Assignment using operator =
               Type: uint160
               Source: "b2 = uint160(tmp[i+1])"
              Identifier b2
                 Type: uint160
                 Source: "b2"
              FunctionCall
                 Type: uint160
                 Source: "uint160(tmp[i+1])"
                ElementaryTypeNameExpression uint160
                   Type: type(uint160)
                   Source: "uint160"
                IndexAccess
                   Type: bytes1
                   Source: "tmp[i+1]"
                  Identifier tmp
                     Type: bytes memory
                     Source: "tmp"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "i+1"
                    Identifier i
                       Type: uint256
                       Source: "i"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
          IfStatement
             Source: "if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 0
               Source: "(b1 >= 97)&&(b1 <= 102)"
              TupleExpression
                 Type: bool
                 Source: "(b1 >= 97)"
                BinaryOperation using operator >=
                   Type: bool
                   Source: "b1 >= 97"
                  Identifier b1
                     Type: uint160
                     Source: "b1"
                  Literal, token: [no token] value: 97
                     Type: int_const 97
                     Source: "97"
              TupleExpression
                 Type: bool
                 Source: "(b1 <= 102)"
                BinaryOperation using operator <=
                   Type: bool
                   Source: "b1 <= 102"
                  Identifier b1
                     Type: uint160
                     Source: "b1"
                  Literal, token: [no token] value: 102
                     Type: int_const 102
                     Source: "102"
            ExpressionStatement
               Gas costs: 0
               Source: "b1 -= 87"
              Assignment using operator -=
                 Type: uint160
                 Source: "b1 -= 87"
                Identifier b1
                   Type: uint160
                   Source: "b1"
                Literal, token: [no token] value: 87
                   Type: int_const 87
                   Source: "87"
            IfStatement
               Source: "if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48"
              BinaryOperation using operator &&
                 Type: bool
                 Gas costs: 0
                 Source: "(b1 >= 48)&&(b1 <= 57)"
                TupleExpression
                   Type: bool
                   Source: "(b1 >= 48)"
                  BinaryOperation using operator >=
                     Type: bool
                     Source: "b1 >= 48"
                    Identifier b1
                       Type: uint160
                       Source: "b1"
                    Literal, token: [no token] value: 48
                       Type: int_const 48
                       Source: "48"
                TupleExpression
                   Type: bool
                   Source: "(b1 <= 57)"
                  BinaryOperation using operator <=
                     Type: bool
                     Source: "b1 <= 57"
                    Identifier b1
                       Type: uint160
                       Source: "b1"
                    Literal, token: [no token] value: 57
                       Type: int_const 57
                       Source: "57"
              ExpressionStatement
                 Gas costs: 0
                 Source: "b1 -= 48"
                Assignment using operator -=
                   Type: uint160
                   Source: "b1 -= 48"
                  Identifier b1
                     Type: uint160
                     Source: "b1"
                  Literal, token: [no token] value: 48
                     Type: int_const 48
                     Source: "48"
          IfStatement
             Source: "if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 0
               Source: "(b2 >= 97)&&(b2 <= 102)"
              TupleExpression
                 Type: bool
                 Source: "(b2 >= 97)"
                BinaryOperation using operator >=
                   Type: bool
                   Source: "b2 >= 97"
                  Identifier b2
                     Type: uint160
                     Source: "b2"
                  Literal, token: [no token] value: 97
                     Type: int_const 97
                     Source: "97"
              TupleExpression
                 Type: bool
                 Source: "(b2 <= 102)"
                BinaryOperation using operator <=
                   Type: bool
                   Source: "b2 <= 102"
                  Identifier b2
                     Type: uint160
                     Source: "b2"
                  Literal, token: [no token] value: 102
                     Type: int_const 102
                     Source: "102"
            ExpressionStatement
               Gas costs: 0
               Source: "b2 -= 87"
              Assignment using operator -=
                 Type: uint160
                 Source: "b2 -= 87"
                Identifier b2
                   Type: uint160
                   Source: "b2"
                Literal, token: [no token] value: 87
                   Type: int_const 87
                   Source: "87"
            IfStatement
               Source: "if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48"
              BinaryOperation using operator &&
                 Type: bool
                 Gas costs: 0
                 Source: "(b2 >= 48)&&(b2 <= 57)"
                TupleExpression
                   Type: bool
                   Source: "(b2 >= 48)"
                  BinaryOperation using operator >=
                     Type: bool
                     Source: "b2 >= 48"
                    Identifier b2
                       Type: uint160
                       Source: "b2"
                    Literal, token: [no token] value: 48
                       Type: int_const 48
                       Source: "48"
                TupleExpression
                   Type: bool
                   Source: "(b2 <= 57)"
                  BinaryOperation using operator <=
                     Type: bool
                     Source: "b2 <= 57"
                    Identifier b2
                       Type: uint160
                       Source: "b2"
                    Literal, token: [no token] value: 57
                       Type: int_const 57
                       Source: "57"
              ExpressionStatement
                 Gas costs: 0
                 Source: "b2 -= 48"
                Assignment using operator -=
                   Type: uint160
                   Source: "b2 -= 48"
                  Identifier b2
                     Type: uint160
                     Source: "b2"
                  Literal, token: [no token] value: 48
                     Type: int_const 48
                     Source: "48"
          ExpressionStatement
             Gas costs: 0
             Source: "iaddr += (b1*16+b2)"
            Assignment using operator +=
               Type: uint160
               Source: "iaddr += (b1*16+b2)"
              Identifier iaddr
                 Type: uint160
                 Source: "iaddr"
              TupleExpression
                 Type: uint160
                 Source: "(b1*16+b2)"
                BinaryOperation using operator +
                   Type: uint160
                   Source: "b1*16+b2"
                  BinaryOperation using operator *
                     Type: uint160
                     Source: "b1*16"
                    Identifier b1
                       Type: uint160
                       Source: "b1"
                    Literal, token: [no token] value: 16
                       Type: int_const 16
                       Source: "16"
                  Identifier b2
                     Type: uint160
                     Source: "b2"
      Return
         Gas costs: 0
         Source: "return address(iaddr)"
        FunctionCall
           Type: address
           Source: "address(iaddr)"
          ElementaryTypeNameExpression address
             Type: type(address)
             Source: "address"
          Identifier iaddr
             Type: uint160
             Source: "iaddr"
  FunctionDefinition "strCompare"
     Source: "function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   }"
    ParameterList
       Gas costs: 0
       Source: "(string _a, string _b)"
      VariableDeclaration "_a"
         Type: string memory
         Source: "string _a"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_b"
         Type: string memory
         Source: "string _b"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(int)"
      VariableDeclaration ""
         Type: int256
         Source: "int"
        ElementaryTypeName int
           Source: "int"
    Block
       Source: "{\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory a = bytes(_a)"
        VariableDeclaration "a"
           Type: bytes memory
           Source: "bytes memory a"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(_a)"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          Identifier _a
             Type: string memory
             Source: "_a"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory b = bytes(_b)"
        VariableDeclaration "b"
           Type: bytes memory
           Source: "bytes memory b"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(_b)"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          Identifier _b
             Type: string memory
             Source: "_b"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint minLength = a.length"
        VariableDeclaration "minLength"
           Type: uint256
           Source: "uint minLength"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "a.length"
          Identifier a
             Type: bytes memory
             Source: "a"
      IfStatement
         Source: "if (b.length < minLength) minLength = b.length"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "b.length < minLength"
          MemberAccess to member length
             Type: uint256
             Source: "b.length"
            Identifier b
               Type: bytes memory
               Source: "b"
          Identifier minLength
             Type: uint256
             Source: "minLength"
        ExpressionStatement
           Gas costs: 0
           Source: "minLength = b.length"
          Assignment using operator =
             Type: uint256
             Source: "minLength = b.length"
            Identifier minLength
               Type: uint256
               Source: "minLength"
            MemberAccess to member length
               Type: uint256
               Source: "b.length"
              Identifier b
                 Type: bytes memory
                 Source: "b"
      ForStatement
         Source: "for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < minLength"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier minLength
             Type: uint256
             Source: "minLength"
        ExpressionStatement
           Gas costs: 0
           Source: "i ++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i ++"
            Identifier i
               Type: uint256
               Source: "i"
        IfStatement
           Source: "if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1"
          BinaryOperation using operator <
             Type: bool
             Gas costs: 0
             Source: "a[i] < b[i]"
            IndexAccess
               Type: bytes1
               Source: "a[i]"
              Identifier a
                 Type: bytes memory
                 Source: "a"
              Identifier i
                 Type: uint256
                 Source: "i"
            IndexAccess
               Type: bytes1
               Source: "b[i]"
              Identifier b
                 Type: bytes memory
                 Source: "b"
              Identifier i
                 Type: uint256
                 Source: "i"
          Return
             Gas costs: 0
             Source: "return -1"
            UnaryOperation (prefix) -
               Type: int_const -1
               Source: "-1"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          IfStatement
             Source: "if (a[i] > b[i])\r\n                return 1"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 0
               Source: "a[i] > b[i]"
              IndexAccess
                 Type: bytes1
                 Source: "a[i]"
                Identifier a
                   Type: bytes memory
                   Source: "a"
                Identifier i
                   Type: uint256
                   Source: "i"
              IndexAccess
                 Type: bytes1
                 Source: "b[i]"
                Identifier b
                   Type: bytes memory
                   Source: "b"
                Identifier i
                   Type: uint256
                   Source: "i"
            Return
               Gas costs: 0
               Source: "return 1"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      IfStatement
         Source: "if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "a.length < b.length"
          MemberAccess to member length
             Type: uint256
             Source: "a.length"
            Identifier a
               Type: bytes memory
               Source: "a"
          MemberAccess to member length
             Type: uint256
             Source: "b.length"
            Identifier b
               Type: bytes memory
               Source: "b"
        Return
           Gas costs: 0
           Source: "return -1"
          UnaryOperation (prefix) -
             Type: int_const -1
             Source: "-1"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
        IfStatement
           Source: "if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0"
          BinaryOperation using operator >
             Type: bool
             Gas costs: 0
             Source: "a.length > b.length"
            MemberAccess to member length
               Type: uint256
               Source: "a.length"
              Identifier a
                 Type: bytes memory
                 Source: "a"
            MemberAccess to member length
               Type: uint256
               Source: "b.length"
              Identifier b
                 Type: bytes memory
                 Source: "b"
          Return
             Gas costs: 0
             Source: "return 1"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Return
             Gas costs: 0
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "indexOf"
     Source: "function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string _haystack, string _needle)"
      VariableDeclaration "_haystack"
         Type: string memory
         Source: "string _haystack"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_needle"
         Type: string memory
         Source: "string _needle"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(int)"
      VariableDeclaration ""
         Type: int256
         Source: "int"
        ElementaryTypeName int
           Source: "int"
    Block
       Source: "{\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory h = bytes(_haystack)"
        VariableDeclaration "h"
           Type: bytes memory
           Source: "bytes memory h"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(_haystack)"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          Identifier _haystack
             Type: string memory
             Source: "_haystack"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory n = bytes(_needle)"
        VariableDeclaration "n"
           Type: bytes memory
           Source: "bytes memory n"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(_needle)"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          Identifier _needle
             Type: string memory
             Source: "_needle"
      IfStatement
         Source: "if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 0
           Source: "h.length < 1 || n.length < 1 || (n.length > h.length)"
          BinaryOperation using operator ||
             Type: bool
             Source: "h.length < 1 || n.length < 1"
            BinaryOperation using operator <
               Type: bool
               Source: "h.length < 1"
              MemberAccess to member length
                 Type: uint256
                 Source: "h.length"
                Identifier h
                   Type: bytes memory
                   Source: "h"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            BinaryOperation using operator <
               Type: bool
               Source: "n.length < 1"
              MemberAccess to member length
                 Type: uint256
                 Source: "n.length"
                Identifier n
                   Type: bytes memory
                   Source: "n"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          TupleExpression
             Type: bool
             Source: "(n.length > h.length)"
            BinaryOperation using operator >
               Type: bool
               Source: "n.length > h.length"
              MemberAccess to member length
                 Type: uint256
                 Source: "n.length"
                Identifier n
                   Type: bytes memory
                   Source: "n"
              MemberAccess to member length
                 Type: uint256
                 Source: "h.length"
                Identifier h
                   Type: bytes memory
                   Source: "h"
        Return
           Gas costs: 0
           Source: "return -1"
          UnaryOperation (prefix) -
             Type: int_const -1
             Source: "-1"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
        IfStatement
           Source: "if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }"
          BinaryOperation using operator >
             Type: bool
             Gas costs: 0
             Source: "h.length > (2**128 -1)"
            MemberAccess to member length
               Type: uint256
               Source: "h.length"
              Identifier h
                 Type: bytes memory
                 Source: "h"
            TupleExpression
               Type: int_const 3402...(31 digits omitted)...1455
               Source: "(2**128 -1)"
              BinaryOperation using operator -
                 Type: int_const 3402...(31 digits omitted)...1455
                 Source: "2**128 -1"
                BinaryOperation using operator **
                   Type: int_const 3402...(31 digits omitted)...1456
                   Source: "2**128"
                  Literal, token: [no token] value: 2
                     Type: int_const 2
                     Source: "2"
                  Literal, token: [no token] value: 128
                     Type: int_const 128
                     Source: "128"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
          Return
             Gas costs: 0
             Source: "return -1"
            UnaryOperation (prefix) -
               Type: int_const -1
               Source: "-1"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          Block
             Source: "{\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }"
            VariableDeclarationStatement
               Gas costs: 0
               Source: "uint subindex = 0"
              VariableDeclaration "subindex"
                 Type: uint256
                 Source: "uint subindex"
                ElementaryTypeName uint
                   Source: "uint"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            ForStatement
               Source: "for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }"
              VariableDeclarationStatement
                 Gas costs: 0
                 Source: "uint i = 0"
                VariableDeclaration "i"
                   Type: uint256
                   Source: "uint i"
                  ElementaryTypeName uint
                     Source: "uint"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              BinaryOperation using operator <
                 Type: bool
                 Gas costs: 0
                 Source: "i < h.length"
                Identifier i
                   Type: uint256
                   Source: "i"
                MemberAccess to member length
                   Type: uint256
                   Source: "h.length"
                  Identifier h
                     Type: bytes memory
                     Source: "h"
              ExpressionStatement
                 Gas costs: 0
                 Source: "i ++"
                UnaryOperation (postfix) ++
                   Type: uint256
                   Source: "i ++"
                  Identifier i
                     Type: uint256
                     Source: "i"
              Block
                 Source: "{\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }"
                IfStatement
                   Source: "if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }"
                  BinaryOperation using operator ==
                     Type: bool
                     Gas costs: 0
                     Source: "h[i] == n[0]"
                    IndexAccess
                       Type: bytes1
                       Source: "h[i]"
                      Identifier h
                         Type: bytes memory
                         Source: "h"
                      Identifier i
                         Type: uint256
                         Source: "i"
                    IndexAccess
                       Type: bytes1
                       Source: "n[0]"
                      Identifier n
                         Type: bytes memory
                         Source: "n"
                      Literal, token: [no token] value: 0
                         Type: int_const 0
                         Source: "0"
                  Block
                     Source: "{\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }"
                    ExpressionStatement
                       Gas costs: 0
                       Source: "subindex = 1"
                      Assignment using operator =
                         Type: uint256
                         Source: "subindex = 1"
                        Identifier subindex
                           Type: uint256
                           Source: "subindex"
                        Literal, token: [no token] value: 1
                           Type: int_const 1
                           Source: "1"
                    WhileStatement
                       Source: "while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }"
                      BinaryOperation using operator &&
                         Type: bool
                         Gas costs: 0
                         Source: "subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]"
                        BinaryOperation using operator &&
                           Type: bool
                           Source: "subindex < n.length && (i + subindex) < h.length"
                          BinaryOperation using operator <
                             Type: bool
                             Source: "subindex < n.length"
                            Identifier subindex
                               Type: uint256
                               Source: "subindex"
                            MemberAccess to member length
                               Type: uint256
                               Source: "n.length"
                              Identifier n
                                 Type: bytes memory
                                 Source: "n"
                          BinaryOperation using operator <
                             Type: bool
                             Source: "(i + subindex) < h.length"
                            TupleExpression
                               Type: uint256
                               Source: "(i + subindex)"
                              BinaryOperation using operator +
                                 Type: uint256
                                 Source: "i + subindex"
                                Identifier i
                                   Type: uint256
                                   Source: "i"
                                Identifier subindex
                                   Type: uint256
                                   Source: "subindex"
                            MemberAccess to member length
                               Type: uint256
                               Source: "h.length"
                              Identifier h
                                 Type: bytes memory
                                 Source: "h"
                        BinaryOperation using operator ==
                           Type: bool
                           Source: "h[i + subindex] == n[subindex]"
                          IndexAccess
                             Type: bytes1
                             Source: "h[i + subindex]"
                            Identifier h
                               Type: bytes memory
                               Source: "h"
                            BinaryOperation using operator +
                               Type: uint256
                               Source: "i + subindex"
                              Identifier i
                                 Type: uint256
                                 Source: "i"
                              Identifier subindex
                                 Type: uint256
                                 Source: "subindex"
                          IndexAccess
                             Type: bytes1
                             Source: "n[subindex]"
                            Identifier n
                               Type: bytes memory
                               Source: "n"
                            Identifier subindex
                               Type: uint256
                               Source: "subindex"
                      Block
                         Source: "{\r\n                        subindex++;\r\n                    }"
                        ExpressionStatement
                           Gas costs: 0
                           Source: "subindex++"
                          UnaryOperation (postfix) ++
                             Type: uint256
                             Source: "subindex++"
                            Identifier subindex
                               Type: uint256
                               Source: "subindex"
                    IfStatement
                       Source: "if(subindex == n.length)\r\n                        return int(i)"
                      BinaryOperation using operator ==
                         Type: bool
                         Gas costs: 0
                         Source: "subindex == n.length"
                        Identifier subindex
                           Type: uint256
                           Source: "subindex"
                        MemberAccess to member length
                           Type: uint256
                           Source: "n.length"
                          Identifier n
                             Type: bytes memory
                             Source: "n"
                      Return
                         Gas costs: 0
                         Source: "return int(i)"
                        FunctionCall
                           Type: int256
                           Source: "int(i)"
                          ElementaryTypeNameExpression int
                             Type: type(int256)
                             Source: "int"
                          Identifier i
                             Type: uint256
                             Source: "i"
            Return
               Gas costs: 0
               Source: "return -1"
              UnaryOperation (prefix) -
                 Type: int_const -1
                 Source: "-1"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
  FunctionDefinition "strConcat"
     Source: "function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string _a, string _b, string _c, string _d, string _e)"
      VariableDeclaration "_a"
         Type: string memory
         Source: "string _a"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_b"
         Type: string memory
         Source: "string _b"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_c"
         Type: string memory
         Source: "string _c"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_d"
         Type: string memory
         Source: "string _d"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_e"
         Type: string memory
         Source: "string _e"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(string)"
      VariableDeclaration ""
         Type: string memory
         Source: "string"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory _ba = bytes(_a)"
        VariableDeclaration "_ba"
           Type: bytes memory
           Source: "bytes memory _ba"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(_a)"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          Identifier _a
             Type: string memory
             Source: "_a"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory _bb = bytes(_b)"
        VariableDeclaration "_bb"
           Type: bytes memory
           Source: "bytes memory _bb"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(_b)"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          Identifier _b
             Type: string memory
             Source: "_b"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory _bc = bytes(_c)"
        VariableDeclaration "_bc"
           Type: bytes memory
           Source: "bytes memory _bc"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(_c)"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          Identifier _c
             Type: string memory
             Source: "_c"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory _bd = bytes(_d)"
        VariableDeclaration "_bd"
           Type: bytes memory
           Source: "bytes memory _bd"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(_d)"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          Identifier _d
             Type: string memory
             Source: "_d"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory _be = bytes(_e)"
        VariableDeclaration "_be"
           Type: bytes memory
           Source: "bytes memory _be"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(_e)"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          Identifier _e
             Type: string memory
             Source: "_e"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length)"
        VariableDeclaration "abcde"
           Type: string memory
           Source: "string memory abcde"
          ElementaryTypeName string
             Source: "string"
        FunctionCall
           Type: string memory
           Source: "new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length)"
          NewExpression
             Type: function (uint256) pure returns (string memory)
             Source: "new string"
            ElementaryTypeName string
               Source: "string"
          BinaryOperation using operator +
             Type: uint256
             Source: "_ba.length + _bb.length + _bc.length + _bd.length + _be.length"
            BinaryOperation using operator +
               Type: uint256
               Source: "_ba.length + _bb.length + _bc.length + _bd.length"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "_ba.length + _bb.length + _bc.length"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "_ba.length + _bb.length"
                  MemberAccess to member length
                     Type: uint256
                     Source: "_ba.length"
                    Identifier _ba
                       Type: bytes memory
                       Source: "_ba"
                  MemberAccess to member length
                     Type: uint256
                     Source: "_bb.length"
                    Identifier _bb
                       Type: bytes memory
                       Source: "_bb"
                MemberAccess to member length
                   Type: uint256
                   Source: "_bc.length"
                  Identifier _bc
                     Type: bytes memory
                     Source: "_bc"
              MemberAccess to member length
                 Type: uint256
                 Source: "_bd.length"
                Identifier _bd
                   Type: bytes memory
                   Source: "_bd"
            MemberAccess to member length
               Type: uint256
               Source: "_be.length"
              Identifier _be
                 Type: bytes memory
                 Source: "_be"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory babcde = bytes(abcde)"
        VariableDeclaration "babcde"
           Type: bytes memory
           Source: "bytes memory babcde"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(abcde)"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          Identifier abcde
             Type: string memory
             Source: "abcde"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint k = 0"
        VariableDeclaration "k"
           Type: uint256
           Source: "uint k"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < _ba.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_ba.length"
            Identifier _ba
               Type: bytes memory
               Source: "_ba"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        ExpressionStatement
           Gas costs: 0
           Source: "babcde[k++] = _ba[i]"
          Assignment using operator =
             Type: bytes1
             Source: "babcde[k++] = _ba[i]"
            IndexAccess
               Type: bytes1
               Source: "babcde[k++]"
              Identifier babcde
                 Type: bytes memory
                 Source: "babcde"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "k++"
                Identifier k
                   Type: uint256
                   Source: "k"
            IndexAccess
               Type: bytes1
               Source: "_ba[i]"
              Identifier _ba
                 Type: bytes memory
                 Source: "_ba"
              Identifier i
                 Type: uint256
                 Source: "i"
      ForStatement
         Source: "for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]"
        ExpressionStatement
           Gas costs: 0
           Source: "i = 0"
          Assignment using operator =
             Type: uint256
             Source: "i = 0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < _bb.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_bb.length"
            Identifier _bb
               Type: bytes memory
               Source: "_bb"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        ExpressionStatement
           Gas costs: 0
           Source: "babcde[k++] = _bb[i]"
          Assignment using operator =
             Type: bytes1
             Source: "babcde[k++] = _bb[i]"
            IndexAccess
               Type: bytes1
               Source: "babcde[k++]"
              Identifier babcde
                 Type: bytes memory
                 Source: "babcde"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "k++"
                Identifier k
                   Type: uint256
                   Source: "k"
            IndexAccess
               Type: bytes1
               Source: "_bb[i]"
              Identifier _bb
                 Type: bytes memory
                 Source: "_bb"
              Identifier i
                 Type: uint256
                 Source: "i"
      ForStatement
         Source: "for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]"
        ExpressionStatement
           Gas costs: 0
           Source: "i = 0"
          Assignment using operator =
             Type: uint256
             Source: "i = 0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < _bc.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_bc.length"
            Identifier _bc
               Type: bytes memory
               Source: "_bc"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        ExpressionStatement
           Gas costs: 0
           Source: "babcde[k++] = _bc[i]"
          Assignment using operator =
             Type: bytes1
             Source: "babcde[k++] = _bc[i]"
            IndexAccess
               Type: bytes1
               Source: "babcde[k++]"
              Identifier babcde
                 Type: bytes memory
                 Source: "babcde"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "k++"
                Identifier k
                   Type: uint256
                   Source: "k"
            IndexAccess
               Type: bytes1
               Source: "_bc[i]"
              Identifier _bc
                 Type: bytes memory
                 Source: "_bc"
              Identifier i
                 Type: uint256
                 Source: "i"
      ForStatement
         Source: "for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]"
        ExpressionStatement
           Gas costs: 0
           Source: "i = 0"
          Assignment using operator =
             Type: uint256
             Source: "i = 0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < _bd.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_bd.length"
            Identifier _bd
               Type: bytes memory
               Source: "_bd"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        ExpressionStatement
           Gas costs: 0
           Source: "babcde[k++] = _bd[i]"
          Assignment using operator =
             Type: bytes1
             Source: "babcde[k++] = _bd[i]"
            IndexAccess
               Type: bytes1
               Source: "babcde[k++]"
              Identifier babcde
                 Type: bytes memory
                 Source: "babcde"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "k++"
                Identifier k
                   Type: uint256
                   Source: "k"
            IndexAccess
               Type: bytes1
               Source: "_bd[i]"
              Identifier _bd
                 Type: bytes memory
                 Source: "_bd"
              Identifier i
                 Type: uint256
                 Source: "i"
      ForStatement
         Source: "for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]"
        ExpressionStatement
           Gas costs: 0
           Source: "i = 0"
          Assignment using operator =
             Type: uint256
             Source: "i = 0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < _be.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_be.length"
            Identifier _be
               Type: bytes memory
               Source: "_be"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        ExpressionStatement
           Gas costs: 0
           Source: "babcde[k++] = _be[i]"
          Assignment using operator =
             Type: bytes1
             Source: "babcde[k++] = _be[i]"
            IndexAccess
               Type: bytes1
               Source: "babcde[k++]"
              Identifier babcde
                 Type: bytes memory
                 Source: "babcde"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "k++"
                Identifier k
                   Type: uint256
                   Source: "k"
            IndexAccess
               Type: bytes1
               Source: "_be[i]"
              Identifier _be
                 Type: bytes memory
                 Source: "_be"
              Identifier i
                 Type: uint256
                 Source: "i"
      Return
         Gas costs: 0
         Source: "return string(babcde)"
        FunctionCall
           Type: string memory
           Source: "string(babcde)"
          ElementaryTypeNameExpression string
             Type: type(string storage pointer)
             Source: "string"
          Identifier babcde
             Type: bytes memory
             Source: "babcde"
  FunctionDefinition "strConcat"
     Source: "function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string _a, string _b, string _c, string _d)"
      VariableDeclaration "_a"
         Type: string memory
         Source: "string _a"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_b"
         Type: string memory
         Source: "string _b"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_c"
         Type: string memory
         Source: "string _c"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_d"
         Type: string memory
         Source: "string _d"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(string)"
      VariableDeclaration ""
         Type: string memory
         Source: "string"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }"
      Return
         Gas costs: 0
         Source: "return strConcat(_a, _b, _c, _d, \"\")"
        FunctionCall
           Type: string memory
           Source: "strConcat(_a, _b, _c, _d, \"\")"
          Identifier strConcat
             Type: function (string memory,string memory,string memory,string memory,string memory) returns (string memory)
             Source: "strConcat"
          Identifier _a
             Type: string memory
             Source: "_a"
          Identifier _b
             Type: string memory
             Source: "_b"
          Identifier _c
             Type: string memory
             Source: "_c"
          Identifier _d
             Type: string memory
             Source: "_d"
          Literal, token: [no token] value: 
             Type: literal_string ""
             Source: "\"\""
  FunctionDefinition "strConcat"
     Source: "function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string _a, string _b, string _c)"
      VariableDeclaration "_a"
         Type: string memory
         Source: "string _a"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_b"
         Type: string memory
         Source: "string _b"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_c"
         Type: string memory
         Source: "string _c"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(string)"
      VariableDeclaration ""
         Type: string memory
         Source: "string"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }"
      Return
         Gas costs: 0
         Source: "return strConcat(_a, _b, _c, \"\", \"\")"
        FunctionCall
           Type: string memory
           Source: "strConcat(_a, _b, _c, \"\", \"\")"
          Identifier strConcat
             Type: function (string memory,string memory,string memory,string memory,string memory) returns (string memory)
             Source: "strConcat"
          Identifier _a
             Type: string memory
             Source: "_a"
          Identifier _b
             Type: string memory
             Source: "_b"
          Identifier _c
             Type: string memory
             Source: "_c"
          Literal, token: [no token] value: 
             Type: literal_string ""
             Source: "\"\""
          Literal, token: [no token] value: 
             Type: literal_string ""
             Source: "\"\""
  FunctionDefinition "strConcat"
     Source: "function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string _a, string _b)"
      VariableDeclaration "_a"
         Type: string memory
         Source: "string _a"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_b"
         Type: string memory
         Source: "string _b"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(string)"
      VariableDeclaration ""
         Type: string memory
         Source: "string"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }"
      Return
         Gas costs: 0
         Source: "return strConcat(_a, _b, \"\", \"\", \"\")"
        FunctionCall
           Type: string memory
           Source: "strConcat(_a, _b, \"\", \"\", \"\")"
          Identifier strConcat
             Type: function (string memory,string memory,string memory,string memory,string memory) returns (string memory)
             Source: "strConcat"
          Identifier _a
             Type: string memory
             Source: "_a"
          Identifier _b
             Type: string memory
             Source: "_b"
          Literal, token: [no token] value: 
             Type: literal_string ""
             Source: "\"\""
          Literal, token: [no token] value: 
             Type: literal_string ""
             Source: "\"\""
          Literal, token: [no token] value: 
             Type: literal_string ""
             Source: "\"\""
  FunctionDefinition "parseInt"
     Source: "function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string _a)"
      VariableDeclaration "_a"
         Type: string memory
         Source: "string _a"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return parseInt(_a, 0);\r\n    }"
      Return
         Gas costs: 15
         Source: "return parseInt(_a, 0)"
        FunctionCall
           Type: uint256
           Source: "parseInt(_a, 0)"
          Identifier parseInt
             Type: function (string memory,uint256) returns (uint256)
             Source: "parseInt"
          Identifier _a
             Type: string memory
             Source: "_a"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "parseInt"
     Source: "function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string _a, uint _b)"
      VariableDeclaration "_a"
         Type: string memory
         Source: "string _a"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_b"
         Type: uint256
         Source: "uint _b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "bytes memory bresult = bytes(_a)"
        VariableDeclaration "bresult"
           Type: bytes memory
           Source: "bytes memory bresult"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(_a)"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          Identifier _a
             Type: string memory
             Source: "_a"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint mint = 0"
        VariableDeclaration "mint"
           Type: uint256
           Source: "uint mint"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "bool decimals = false"
        VariableDeclaration "decimals"
           Type: bool
           Source: "bool decimals"
          ElementaryTypeName bool
             Source: "bool"
        Literal, token: false value: false
           Type: bool
           Source: "false"
      ForStatement
         Source: "for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: [???]
           Source: "i<bresult.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "bresult.length"
            Identifier bresult
               Type: bytes memory
               Source: "bresult"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }"
          IfStatement
             Source: "if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: [???]
               Source: "(bresult[i] >= 48)&&(bresult[i] <= 57)"
              TupleExpression
                 Type: bool
                 Source: "(bresult[i] >= 48)"
                BinaryOperation using operator >=
                   Type: bool
                   Source: "bresult[i] >= 48"
                  IndexAccess
                     Type: bytes1
                     Source: "bresult[i]"
                    Identifier bresult
                       Type: bytes memory
                       Source: "bresult"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  Literal, token: [no token] value: 48
                     Type: int_const 48
                     Source: "48"
              TupleExpression
                 Type: bool
                 Source: "(bresult[i] <= 57)"
                BinaryOperation using operator <=
                   Type: bool
                   Source: "bresult[i] <= 57"
                  IndexAccess
                     Type: bytes1
                     Source: "bresult[i]"
                    Identifier bresult
                       Type: bytes memory
                       Source: "bresult"
                    Identifier i
                       Type: uint256
                       Source: "i"
                  Literal, token: [no token] value: 57
                     Type: int_const 57
                     Source: "57"
            Block
               Source: "{\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            }"
              IfStatement
                 Source: "if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }"
                Identifier decimals
                   Type: bool
                   Gas costs: 3
                   Source: "decimals"
                Block
                   Source: "{\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }"
                  IfStatement
                     Source: "if (_b == 0) break;\r\n                    else _b--"
                    BinaryOperation using operator ==
                       Type: bool
                       Gas costs: 9
                       Source: "_b == 0"
                      Identifier _b
                         Type: uint256
                         Source: "_b"
                      Literal, token: [no token] value: 0
                         Type: int_const 0
                         Source: "0"
                    Break
                       Gas costs: 0
                       Source: "break"
                    ExpressionStatement
                       Gas costs: 22
                       Source: "_b--"
                      UnaryOperation (postfix) --
                         Type: uint256
                         Source: "_b--"
                        Identifier _b
                           Type: uint256
                           Source: "_b"
              ExpressionStatement
                 Gas costs: 16
                 Source: "mint *= 10"
                Assignment using operator *=
                   Type: uint256
                   Source: "mint *= 10"
                  Identifier mint
                     Type: uint256
                     Source: "mint"
                  Literal, token: [no token] value: 10
                     Type: int_const 10
                     Source: "10"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "mint += uint(bresult[i]) - 48"
                Assignment using operator +=
                   Type: uint256
                   Source: "mint += uint(bresult[i]) - 48"
                  Identifier mint
                     Type: uint256
                     Source: "mint"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "uint(bresult[i]) - 48"
                    FunctionCall
                       Type: uint256
                       Source: "uint(bresult[i])"
                      ElementaryTypeNameExpression uint
                         Type: type(uint256)
                         Source: "uint"
                      IndexAccess
                         Type: bytes1
                         Source: "bresult[i]"
                        Identifier bresult
                           Type: bytes memory
                           Source: "bresult"
                        Identifier i
                           Type: uint256
                           Source: "i"
                    Literal, token: [no token] value: 48
                       Type: int_const 48
                       Source: "48"
            IfStatement
               Source: "if (bresult[i] == 46) decimals = true"
              BinaryOperation using operator ==
                 Type: bool
                 Gas costs: [???]
                 Source: "bresult[i] == 46"
                IndexAccess
                   Type: bytes1
                   Source: "bresult[i]"
                  Identifier bresult
                     Type: bytes memory
                     Source: "bresult"
                  Identifier i
                     Type: uint256
                     Source: "i"
                Literal, token: [no token] value: 46
                   Type: int_const 46
                   Source: "46"
              ExpressionStatement
                 Gas costs: 8
                 Source: "decimals = true"
                Assignment using operator =
                   Type: bool
                   Source: "decimals = true"
                  Identifier decimals
                     Type: bool
                     Source: "decimals"
                  Literal, token: true value: true
                     Type: bool
                     Source: "true"
      IfStatement
         Source: "if (_b > 0) mint *= 10**_b"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "_b > 0"
          Identifier _b
             Type: uint256
             Source: "_b"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 1629
           Source: "mint *= 10**_b"
          Assignment using operator *=
             Type: uint256
             Source: "mint *= 10**_b"
            Identifier mint
               Type: uint256
               Source: "mint"
            BinaryOperation using operator **
               Type: uint256
               Source: "10**_b"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Identifier _b
                 Type: uint256
                 Source: "_b"
      Return
         Gas costs: 8
         Source: "return mint"
        Identifier mint
           Type: uint256
           Source: "mint"
  FunctionDefinition "uint2str"
     Source: "function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint i)"
      VariableDeclaration "i"
         Type: uint256
         Source: "uint i"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(string)"
      VariableDeclaration ""
         Type: string memory
         Source: "string"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }"
      IfStatement
         Source: "if (i == 0) return \"0\""
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "i == 0"
          Identifier i
             Type: uint256
             Source: "i"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 0
           Source: "return \"0\""
          Literal, token: [no token] value: 0
             Type: literal_string "0"
             Source: "\"0\""
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint j = i"
        VariableDeclaration "j"
           Type: uint256
           Source: "uint j"
          ElementaryTypeName uint
             Source: "uint"
        Identifier i
           Type: uint256
           Source: "i"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint len"
        VariableDeclaration "len"
           Type: uint256
           Source: "uint len"
          ElementaryTypeName uint
             Source: "uint"
      WhileStatement
         Source: "while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "j != 0"
          Identifier j
             Type: uint256
             Source: "j"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            len++;\r\n            j /= 10;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "len++"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "len++"
              Identifier len
                 Type: uint256
                 Source: "len"
          ExpressionStatement
             Gas costs: 0
             Source: "j /= 10"
            Assignment using operator /=
               Type: uint256
               Source: "j /= 10"
              Identifier j
                 Type: uint256
                 Source: "j"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory bstr = new bytes(len)"
        VariableDeclaration "bstr"
           Type: bytes memory
           Source: "bytes memory bstr"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "new bytes(len)"
          NewExpression
             Type: function (uint256) pure returns (bytes memory)
             Source: "new bytes"
            ElementaryTypeName bytes
               Source: "bytes"
          Identifier len
             Type: uint256
             Source: "len"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint k = len - 1"
        VariableDeclaration "k"
           Type: uint256
           Source: "uint k"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator -
           Type: uint256
           Source: "len - 1"
          Identifier len
             Type: uint256
             Source: "len"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      WhileStatement
         Source: "while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "i != 0"
          Identifier i
             Type: uint256
             Source: "i"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "bstr[k--] = byte(48 + i % 10)"
            Assignment using operator =
               Type: bytes1
               Source: "bstr[k--] = byte(48 + i % 10)"
              IndexAccess
                 Type: bytes1
                 Source: "bstr[k--]"
                Identifier bstr
                   Type: bytes memory
                   Source: "bstr"
                UnaryOperation (postfix) --
                   Type: uint256
                   Source: "k--"
                  Identifier k
                     Type: uint256
                     Source: "k"
              FunctionCall
                 Type: bytes1
                 Source: "byte(48 + i % 10)"
                ElementaryTypeNameExpression byte
                   Type: type(bytes1)
                   Source: "byte"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "48 + i % 10"
                  Literal, token: [no token] value: 48
                     Type: int_const 48
                     Source: "48"
                  BinaryOperation using operator %
                     Type: uint256
                     Source: "i % 10"
                    Identifier i
                       Type: uint256
                       Source: "i"
                    Literal, token: [no token] value: 10
                       Type: int_const 10
                       Source: "10"
          ExpressionStatement
             Gas costs: 0
             Source: "i /= 10"
            Assignment using operator /=
               Type: uint256
               Source: "i /= 10"
              Identifier i
                 Type: uint256
                 Source: "i"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
      Return
         Gas costs: 0
         Source: "return string(bstr)"
        FunctionCall
           Type: string memory
           Source: "string(bstr)"
          ElementaryTypeNameExpression string
             Type: type(string storage pointer)
             Source: "string"
          Identifier bstr
             Type: bytes memory
             Source: "bstr"
ContractDefinition "Dice"
   Source: "contract Dice is usingOraclize {\r\n\r\n    uint constant pwin = 1000; //probability of winning (10000 = 100%)\r\n    uint constant edge = 190; //edge percentage (10000 = 100%)\r\n    uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint constant minBet = 200 finney;\r\n    uint constant maxInvestors = 10; //maximum number of investors\r\n    uint constant houseEdge = 25; //edge percentage (10000 = 100%)\r\n    uint constant divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 2300;\r\n    uint constant ORACLIZE_GAS_LIMIT = 175000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 3 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBet;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address public owner;\r\n    address public houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) public bets;\r\n    bytes32[] public betsKeys;\r\n\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLosses = 0;\r\n    bool profitDistributed;\r\n\r\n    event LOG_NewBet(address playerAddress, uint amount);\r\n    event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event LOG_BetLost(address playerAddress, uint numberRolled);\r\n    event LOG_EmergencyWithdrawalProposed();\r\n    event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event LOG_FailedSend(address receiver, uint amount);\r\n    event LOG_ZeroSend();\r\n    event LOG_InvestorEntrance(address investor, uint amount);\r\n    event LOG_InvestorCapitalUpdate(address investor, int amount);\r\n    event LOG_InvestorExit(address investor, uint amount);\r\n    event LOG_ContractStopped();\r\n    event LOG_ContractResumed();\r\n    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\r\n    event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\r\n    event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\r\n    event LOG_EmergencyAutoStop();\r\n    event LOG_EmergencyWithdrawalVote(address investor, bool vote);\r\n    event LOG_ValueIsTooBig();\r\n    event LOG_SuccessfulSend(address addr, uint amount);\r\n\r\n    function Dice() {\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetExist(bytes32 myid) {\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }\r\n\r\n    modifier investorsInvariant {\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }\r\n\r\n    function getMinInvestment()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus()\r\n        constant\r\n        returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id)\r\n        constant\r\n        returns(address, uint, uint) {\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets()\r\n        constant\r\n        returns(uint) {\r\n\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLossesShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }\r\n\r\n    function searchSmallestInvestor()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    function changeOraclizeProofType(byte _proofType)\r\n        onlyOwner {\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }\r\n\r\n    function changeOraclizeConfig(bytes32 _config)\r\n        onlyOwner {\r\n\r\n        oraclize_setConfig(_config);\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value)\r\n        private {\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }\r\n\r\n    function addInvestorAtID(uint id)\r\n        private {\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }\r\n\r\n    function profitDistribution()\r\n        private\r\n        onlyIfProfitNotDistributed {\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function()\r\n        payable {\r\n\r\n        bet();\r\n    }\r\n\r\n    function bet()\r\n        payable\r\n        onlyIfNotStopped {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BLY3bF2NWtUYMqKj+13fIJ+rR4IzmlNAP9UM1nmbCiivwFXmm3lU86zjsIldadlHwkH9H8ephiQ/FNgEraMknyVhlceoT1WgJv3h1iP87fRK34yqARHV8p/qKoYG1RE1lJ6IKI1oUvDqCfllxkf+u9vvWN188fs=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfBetExist(myid)\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyWinningBets(numberRolled) {\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyLosingBets(numberRolled) {\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyInvestors  {\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest()\r\n        onlyInvestors {\r\n\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }\r\n\r\n    function forceDivestOfAllInvestors()\r\n        onlyOwner {\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract()\r\n        onlyOwner {\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }\r\n\r\n    function resumeContract()\r\n        onlyOwner {\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse)\r\n        onlyOwner {\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner)\r\n        onlyOwner {\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit) {\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped {\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "usingOraclize"
    UserDefinedTypeName "usingOraclize"
       Source: "usingOraclize"
  VariableDeclaration "pwin"
     Type: uint256
     Gas costs: 30
     Source: "uint constant pwin = 1000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1000
       Type: int_const 1000
       Source: "1000"
  VariableDeclaration "edge"
     Type: uint256
     Gas costs: 15
     Source: "uint constant edge = 190"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 190
       Type: int_const 190
       Source: "190"
  VariableDeclaration "maxWin"
     Type: uint256
     Gas costs: 12
     Source: "uint constant maxWin = 100"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 100
       Type: int_const 100
       Source: "100"
  VariableDeclaration "minBet"
     Type: uint256
     Gas costs: 12
     Source: "uint constant minBet = 200 finney"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 200
       Type: int_const 200000000000000000
       Source: "200 finney"
  VariableDeclaration "maxInvestors"
     Type: uint256
     Gas costs: 12
     Source: "uint constant maxInvestors = 10"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 10
       Type: int_const 10
       Source: "10"
  VariableDeclaration "houseEdge"
     Type: uint256
     Gas costs: 3
     Source: "uint constant houseEdge = 25"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 25
       Type: int_const 25
       Source: "25"
  VariableDeclaration "divestFee"
     Type: uint256
     Gas costs: 3
     Source: "uint constant divestFee = 50"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 50
       Type: int_const 50
       Source: "50"
  VariableDeclaration "emergencyWithdrawalRatio"
     Type: uint256
     Gas costs: 3
     Source: "uint constant emergencyWithdrawalRatio = 10"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 10
       Type: int_const 10
       Source: "10"
  VariableDeclaration "safeGas"
     Type: uint256
     Gas costs: 0
     Source: "uint safeGas = 2300"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 2300
       Type: int_const 2300
       Source: "2300"
  VariableDeclaration "ORACLIZE_GAS_LIMIT"
     Type: uint256
     Gas costs: 18
     Source: "uint constant ORACLIZE_GAS_LIMIT = 175000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 175000
       Type: int_const 175000
       Source: "175000"
  VariableDeclaration "INVALID_BET_MARKER"
     Type: uint256
     Gas costs: 6
     Source: "uint constant INVALID_BET_MARKER = 99999"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 99999
       Type: int_const 99999
       Source: "99999"
  VariableDeclaration "EMERGENCY_TIMEOUT"
     Type: uint256
     Gas costs: 3
     Source: "uint constant EMERGENCY_TIMEOUT = 3 days"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 3
       Type: int_const 259200
       Source: "3 days"
  StructDefinition "Investor"
     Gas costs: 0
     Source: "struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }"
    VariableDeclaration "investorAddress"
       Type: address
       Source: "address investorAddress"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "amountInvested"
       Type: uint256
       Source: "uint amountInvested"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "votedForEmergencyWithdrawal"
       Type: bool
       Source: "bool votedForEmergencyWithdrawal"
      ElementaryTypeName bool
         Source: "bool"
  StructDefinition "Bet"
     Gas costs: 0
     Source: "struct Bet {\r\n        address playerAddress;\r\n        uint amountBet;\r\n        uint numberRolled;\r\n    }"
    VariableDeclaration "playerAddress"
       Type: address
       Source: "address playerAddress"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "amountBet"
       Type: uint256
       Source: "uint amountBet"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "numberRolled"
       Type: uint256
       Source: "uint numberRolled"
      ElementaryTypeName uint
         Source: "uint"
  StructDefinition "WithdrawalProposal"
     Gas costs: 0
     Source: "struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }"
    VariableDeclaration "toAddress"
       Type: address
       Source: "address toAddress"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "atTime"
       Type: uint256
       Source: "uint atTime"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "investorIDs"
     Type: mapping(address => uint256)
     Gas costs: [???]
     Source: "mapping(address => uint) public investorIDs"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "investors"
     Type: mapping(uint256 => struct Dice.Investor storage ref)
     Gas costs: [???]
     Source: "mapping(uint => Investor) public investors"
    Mapping
       Source: "mapping(uint => Investor)"
      ElementaryTypeName uint
         Source: "uint"
      UserDefinedTypeName "Investor"
         Source: "Investor"
  VariableDeclaration "numInvestors"
     Type: uint256
     Gas costs: [???]
     Source: "uint public numInvestors = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "invested"
     Type: uint256
     Gas costs: [???]
     Source: "uint public invested = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "houseAddress"
     Type: address
     Gas costs: [???]
     Source: "address public houseAddress"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "isStopped"
     Type: bool
     Gas costs: [???]
     Source: "bool public isStopped"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "proposedWithdrawal"
     Type: struct Dice.WithdrawalProposal storage ref
     Gas costs: [???]
     Source: "WithdrawalProposal public proposedWithdrawal"
    UserDefinedTypeName "WithdrawalProposal"
       Source: "WithdrawalProposal"
  VariableDeclaration "bets"
     Type: mapping(bytes32 => struct Dice.Bet storage ref)
     Gas costs: [???]
     Source: "mapping (bytes32 => Bet) public bets"
    Mapping
       Source: "mapping (bytes32 => Bet)"
      ElementaryTypeName bytes32
         Source: "bytes32"
      UserDefinedTypeName "Bet"
         Source: "Bet"
  VariableDeclaration "betsKeys"
     Type: bytes32[] storage ref
     Gas costs: [???]
     Source: "bytes32[] public betsKeys"
    ArrayTypeName
       Source: "bytes32[]"
      ElementaryTypeName bytes32
         Source: "bytes32"
  VariableDeclaration "investorsProfit"
     Type: uint256
     Gas costs: [???]
     Source: "uint public investorsProfit = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "investorsLosses"
     Type: uint256
     Gas costs: [???]
     Source: "uint public investorsLosses = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "profitDistributed"
     Type: bool
     Gas costs: 0
     Source: "bool profitDistributed"
    ElementaryTypeName bool
       Source: "bool"
  EventDefinition "LOG_NewBet"
     Gas costs: 0
     Source: "event LOG_NewBet(address playerAddress, uint amount);"
    ParameterList
       Source: "(address playerAddress, uint amount)"
      VariableDeclaration "playerAddress"
         Type: address
         Source: "address playerAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LOG_BetWon"
     Gas costs: 0
     Source: "event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);"
    ParameterList
       Source: "(address playerAddress, uint numberRolled, uint amountWon)"
      VariableDeclaration "playerAddress"
         Type: address
         Source: "address playerAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "numberRolled"
         Type: uint256
         Source: "uint numberRolled"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "amountWon"
         Type: uint256
         Source: "uint amountWon"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LOG_BetLost"
     Gas costs: 0
     Source: "event LOG_BetLost(address playerAddress, uint numberRolled);"
    ParameterList
       Source: "(address playerAddress, uint numberRolled)"
      VariableDeclaration "playerAddress"
         Type: address
         Source: "address playerAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "numberRolled"
         Type: uint256
         Source: "uint numberRolled"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LOG_EmergencyWithdrawalProposed"
     Gas costs: 0
     Source: "event LOG_EmergencyWithdrawalProposed();"
    ParameterList
       Source: "()"
  EventDefinition "LOG_EmergencyWithdrawalFailed"
     Gas costs: 0
     Source: "event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);"
    ParameterList
       Source: "(address withdrawalAddress)"
      VariableDeclaration "withdrawalAddress"
         Type: address
         Source: "address withdrawalAddress"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "LOG_EmergencyWithdrawalSucceeded"
     Gas costs: 0
     Source: "event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);"
    ParameterList
       Source: "(address withdrawalAddress, uint amountWithdrawn)"
      VariableDeclaration "withdrawalAddress"
         Type: address
         Source: "address withdrawalAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amountWithdrawn"
         Type: uint256
         Source: "uint amountWithdrawn"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LOG_FailedSend"
     Gas costs: 0
     Source: "event LOG_FailedSend(address receiver, uint amount);"
    ParameterList
       Source: "(address receiver, uint amount)"
      VariableDeclaration "receiver"
         Type: address
         Source: "address receiver"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LOG_ZeroSend"
     Gas costs: 0
     Source: "event LOG_ZeroSend();"
    ParameterList
       Source: "()"
  EventDefinition "LOG_InvestorEntrance"
     Gas costs: 0
     Source: "event LOG_InvestorEntrance(address investor, uint amount);"
    ParameterList
       Source: "(address investor, uint amount)"
      VariableDeclaration "investor"
         Type: address
         Source: "address investor"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LOG_InvestorCapitalUpdate"
     Gas costs: 0
     Source: "event LOG_InvestorCapitalUpdate(address investor, int amount);"
    ParameterList
       Source: "(address investor, int amount)"
      VariableDeclaration "investor"
         Type: address
         Source: "address investor"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: int256
         Source: "int amount"
        ElementaryTypeName int
           Source: "int"
  EventDefinition "LOG_InvestorExit"
     Gas costs: 0
     Source: "event LOG_InvestorExit(address investor, uint amount);"
    ParameterList
       Source: "(address investor, uint amount)"
      VariableDeclaration "investor"
         Type: address
         Source: "address investor"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LOG_ContractStopped"
     Gas costs: 0
     Source: "event LOG_ContractStopped();"
    ParameterList
       Source: "()"
  EventDefinition "LOG_ContractResumed"
     Gas costs: 0
     Source: "event LOG_ContractResumed();"
    ParameterList
       Source: "()"
  EventDefinition "LOG_OwnerAddressChanged"
     Gas costs: 0
     Source: "event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);"
    ParameterList
       Source: "(address oldAddr, address newOwnerAddress)"
      VariableDeclaration "oldAddr"
         Type: address
         Source: "address oldAddr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "newOwnerAddress"
         Type: address
         Source: "address newOwnerAddress"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "LOG_HouseAddressChanged"
     Gas costs: 0
     Source: "event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);"
    ParameterList
       Source: "(address oldAddr, address newHouseAddress)"
      VariableDeclaration "oldAddr"
         Type: address
         Source: "address oldAddr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "newHouseAddress"
         Type: address
         Source: "address newHouseAddress"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "LOG_GasLimitChanged"
     Gas costs: 0
     Source: "event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);"
    ParameterList
       Source: "(uint oldGasLimit, uint newGasLimit)"
      VariableDeclaration "oldGasLimit"
         Type: uint256
         Source: "uint oldGasLimit"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "newGasLimit"
         Type: uint256
         Source: "uint newGasLimit"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "LOG_EmergencyAutoStop"
     Gas costs: 0
     Source: "event LOG_EmergencyAutoStop();"
    ParameterList
       Source: "()"
  EventDefinition "LOG_EmergencyWithdrawalVote"
     Gas costs: 0
     Source: "event LOG_EmergencyWithdrawalVote(address investor, bool vote);"
    ParameterList
       Source: "(address investor, bool vote)"
      VariableDeclaration "investor"
         Type: address
         Source: "address investor"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "vote"
         Type: bool
         Source: "bool vote"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "LOG_ValueIsTooBig"
     Gas costs: 0
     Source: "event LOG_ValueIsTooBig();"
    ParameterList
       Source: "()"
  EventDefinition "LOG_SuccessfulSend"
     Gas costs: 0
     Source: "event LOG_SuccessfulSend(address addr, uint amount);"
    ParameterList
       Source: "(address addr, uint amount)"
      VariableDeclaration "addr"
         Type: address
         Source: "address addr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "Dice" - public
     Source: "function Dice() {\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS)"
        FunctionCall
           Type: tuple()
           Source: "oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS)"
          Identifier oraclize_setProof
             Type: function (bytes1)
             Source: "oraclize_setProof"
          BinaryOperation using operator |
             Type: bytes1
             Source: "proofType_TLSNotary | proofStorage_IPFS"
            Identifier proofType_TLSNotary
               Type: bytes1
               Source: "proofType_TLSNotary"
            Identifier proofStorage_IPFS
               Type: bytes1
               Source: "proofStorage_IPFS"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "houseAddress = msg.sender"
        Assignment using operator =
           Type: address
           Source: "houseAddress = msg.sender"
          Identifier houseAddress
             Type: address
             Source: "houseAddress"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyIfNotStopped"
     Source: "modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (isStopped) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (isStopped) throw"
        Identifier isStopped
           Type: bool
           Gas costs: 867
           Source: "isStopped"
        Throw
           Gas costs: 18
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyIfStopped"
     Source: "modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (!isStopped) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (!isStopped) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 1168
           Source: "!isStopped"
          Identifier isStopped
             Type: bool
             Source: "isStopped"
        Throw
           Gas costs: 24
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyInvestors"
     Source: "modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (investorIDs[msg.sender] == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 912
           Source: "investorIDs[msg.sender] == 0"
          IndexAccess
             Type: uint256
             Source: "investorIDs[msg.sender]"
            Identifier investorIDs
               Type: mapping(address => uint256)
               Source: "investorIDs"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 18
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyNotInvestors"
     Source: "modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (investorIDs[msg.sender] != 0) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 307
           Source: "investorIDs[msg.sender] != 0"
          IndexAccess
             Type: uint256
             Source: "investorIDs[msg.sender]"
            Identifier investorIDs
               Type: mapping(address => uint256)
               Source: "investorIDs"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (owner != msg.sender) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 2849
           Source: "owner != msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
        Throw
           Gas costs: 66
           Source: "throw"
      PlaceholderStatement
         Gas costs: 2
         Source: "_"
  ModifierDefinition "onlyOraclize"
     Source: "modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (msg.sender != oraclize_cbAddress()) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 24
           Source: "msg.sender != oraclize_cbAddress()"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          FunctionCall
             Type: address
             Source: "oraclize_cbAddress()"
            Identifier oraclize_cbAddress
               Type: function () returns (address)
               Source: "oraclize_cbAddress"
        Throw
           Gas costs: 6
           Source: "throw"
      PlaceholderStatement
         Gas costs: 2
         Source: "_"
  ModifierDefinition "onlyMoreThanMinInvestment"
     Source: "modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (msg.value <= getMinInvestment()) throw"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 23
           Source: "msg.value <= getMinInvestment()"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          FunctionCall
             Type: uint256
             Source: "getMinInvestment()"
            Identifier getMinInvestment
               Type: function () view returns (uint256)
               Source: "getMinInvestment"
        Throw
           Gas costs: 6
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyMoreThanZero"
     Source: "modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (msg.value == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 16
           Source: "msg.value == 0"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 12
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyIfBetExist"
     Source: "modifier onlyIfBetExist(bytes32 myid) {\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 myid)"
      VariableDeclaration "myid"
         Type: bytes32
         Source: "bytes32 myid"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if(bets[myid].playerAddress == address(0x0)) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 365
           Source: "bets[myid].playerAddress == address(0x0)"
          MemberAccess to member playerAddress
             Type: address
             Source: "bets[myid].playerAddress"
            IndexAccess
               Type: struct Dice.Bet storage ref
               Source: "bets[myid]"
              Identifier bets
                 Type: mapping(bytes32 => struct Dice.Bet storage ref)
                 Source: "bets"
              Identifier myid
                 Type: bytes32
                 Source: "myid"
          FunctionCall
             Type: address
             Source: "address(0x0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
        Throw
           Gas costs: 6
           Source: "throw"
      PlaceholderStatement
         Gas costs: 2
         Source: "_"
  ModifierDefinition "onlyIfBetSizeIsStillCorrect"
     Source: "modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 myid)"
      VariableDeclaration "myid"
         Type: bytes32
         Source: "bytes32 myid"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }"
      IfStatement
         Source: "if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 749
           Source: "(((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)"
          TupleExpression
             Type: bool
             Source: "(((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)"
            BinaryOperation using operator <=
               Type: bool
               Source: "((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000"
              TupleExpression
                 Type: uint256
                 Source: "((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin )"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "(bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin"
                  TupleExpression
                     Type: uint256
                     Source: "(bets[myid].amountBet * ((10000 - edge) - pwin))"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "bets[myid].amountBet * ((10000 - edge) - pwin)"
                      MemberAccess to member amountBet
                         Type: uint256
                         Source: "bets[myid].amountBet"
                        IndexAccess
                           Type: struct Dice.Bet storage ref
                           Source: "bets[myid]"
                          Identifier bets
                             Type: mapping(bytes32 => struct Dice.Bet storage ref)
                             Source: "bets"
                          Identifier myid
                             Type: bytes32
                             Source: "myid"
                      TupleExpression
                         Type: uint256
                         Source: "((10000 - edge) - pwin)"
                        BinaryOperation using operator -
                           Type: uint256
                           Source: "(10000 - edge) - pwin"
                          TupleExpression
                             Type: uint256
                             Source: "(10000 - edge)"
                            BinaryOperation using operator -
                               Type: uint256
                               Source: "10000 - edge"
                              Literal, token: [no token] value: 10000
                                 Type: int_const 10000
                                 Source: "10000"
                              Identifier edge
                                 Type: uint256
                                 Source: "edge"
                          Identifier pwin
                             Type: uint256
                             Source: "pwin"
                  Identifier pwin
                     Type: uint256
                     Source: "pwin"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "(maxWin * getBankroll()) / 10000"
                TupleExpression
                   Type: uint256
                   Source: "(maxWin * getBankroll())"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "maxWin * getBankroll()"
                    Identifier maxWin
                       Type: uint256
                       Source: "maxWin"
                    FunctionCall
                       Type: uint256
                       Source: "getBankroll()"
                      Identifier getBankroll
                         Type: function () view returns (uint256)
                         Source: "getBankroll"
                Literal, token: [no token] value: 10000
                   Type: int_const 10000
                   Source: "10000"
          TupleExpression
             Type: bool
             Source: "(bets[myid].amountBet >= minBet)"
            BinaryOperation using operator >=
               Type: bool
               Source: "bets[myid].amountBet >= minBet"
              MemberAccess to member amountBet
                 Type: uint256
                 Source: "bets[myid].amountBet"
                IndexAccess
                   Type: struct Dice.Bet storage ref
                   Source: "bets[myid]"
                  Identifier bets
                     Type: mapping(bytes32 => struct Dice.Bet storage ref)
                     Source: "bets"
                  Identifier myid
                     Type: bytes32
                     Source: "myid"
              Identifier minBet
                 Type: uint256
                 Source: "minBet"
        Block
           Source: "{\r\n             _;\r\n        }"
          PlaceholderStatement
             Gas costs: 0
             Source: "_"
        Block
           Source: "{\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }"
          ExpressionStatement
             Gas costs: 20119
             Source: "bets[myid].numberRolled = INVALID_BET_MARKER"
            Assignment using operator =
               Type: uint256
               Source: "bets[myid].numberRolled = INVALID_BET_MARKER"
              MemberAccess to member numberRolled
                 Type: uint256
                 Source: "bets[myid].numberRolled"
                IndexAccess
                   Type: struct Dice.Bet storage ref
                   Source: "bets[myid]"
                  Identifier bets
                     Type: mapping(bytes32 => struct Dice.Bet storage ref)
                     Source: "bets"
                  Identifier myid
                     Type: bytes32
                     Source: "myid"
              Identifier INVALID_BET_MARKER
                 Type: uint256
                 Source: "INVALID_BET_MARKER"
          ExpressionStatement
             Gas costs: 650
             Source: "safeSend(bets[myid].playerAddress, bets[myid].amountBet)"
            FunctionCall
               Type: tuple()
               Source: "safeSend(bets[myid].playerAddress, bets[myid].amountBet)"
              Identifier safeSend
                 Type: function (address,uint256)
                 Source: "safeSend"
              MemberAccess to member playerAddress
                 Type: address
                 Source: "bets[myid].playerAddress"
                IndexAccess
                   Type: struct Dice.Bet storage ref
                   Source: "bets[myid]"
                  Identifier bets
                     Type: mapping(bytes32 => struct Dice.Bet storage ref)
                     Source: "bets"
                  Identifier myid
                     Type: bytes32
                     Source: "myid"
              MemberAccess to member amountBet
                 Type: uint256
                 Source: "bets[myid].amountBet"
                IndexAccess
                   Type: struct Dice.Bet storage ref
                   Source: "bets[myid]"
                  Identifier bets
                     Type: mapping(bytes32 => struct Dice.Bet storage ref)
                     Source: "bets"
                  Identifier myid
                     Type: bytes32
                     Source: "myid"
          Return
             Gas costs: 11
             Source: "return;"
  ModifierDefinition "onlyIfValidRoll"
     Source: "modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 myid, string result)"
      VariableDeclaration "myid"
         Type: bytes32
         Source: "bytes32 myid"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "result"
         Type: string memory
         Source: "string result"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 15
         Source: "uint numberRolled = parseInt(result)"
        VariableDeclaration "numberRolled"
           Type: uint256
           Source: "uint numberRolled"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "parseInt(result)"
          Identifier parseInt
             Type: function (string memory) returns (uint256)
             Source: "parseInt"
          Identifier result
             Type: string memory
             Source: "result"
      IfStatement
         Source: "if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 376
           Source: "(numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0"
          TupleExpression
             Type: bool
             Source: "(numberRolled < 1 || numberRolled > 10000)"
            BinaryOperation using operator ||
               Type: bool
               Source: "numberRolled < 1 || numberRolled > 10000"
              BinaryOperation using operator <
                 Type: bool
                 Source: "numberRolled < 1"
                Identifier numberRolled
                   Type: uint256
                   Source: "numberRolled"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              BinaryOperation using operator >
                 Type: bool
                 Source: "numberRolled > 10000"
                Identifier numberRolled
                   Type: uint256
                   Source: "numberRolled"
                Literal, token: [no token] value: 10000
                   Type: int_const 10000
                   Source: "10000"
          BinaryOperation using operator ==
             Type: bool
             Source: "bets[myid].numberRolled == 0"
            MemberAccess to member numberRolled
               Type: uint256
               Source: "bets[myid].numberRolled"
              IndexAccess
                 Type: struct Dice.Bet storage ref
                 Source: "bets[myid]"
                Identifier bets
                   Type: mapping(bytes32 => struct Dice.Bet storage ref)
                   Source: "bets"
                Identifier myid
                   Type: bytes32
                   Source: "myid"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }"
          ExpressionStatement
             Gas costs: 20119
             Source: "bets[myid].numberRolled = INVALID_BET_MARKER"
            Assignment using operator =
               Type: uint256
               Source: "bets[myid].numberRolled = INVALID_BET_MARKER"
              MemberAccess to member numberRolled
                 Type: uint256
                 Source: "bets[myid].numberRolled"
                IndexAccess
                   Type: struct Dice.Bet storage ref
                   Source: "bets[myid]"
                  Identifier bets
                     Type: mapping(bytes32 => struct Dice.Bet storage ref)
                     Source: "bets"
                  Identifier myid
                     Type: bytes32
                     Source: "myid"
              Identifier INVALID_BET_MARKER
                 Type: uint256
                 Source: "INVALID_BET_MARKER"
          ExpressionStatement
             Gas costs: 661
             Source: "safeSend(bets[myid].playerAddress, bets[myid].amountBet)"
            FunctionCall
               Type: tuple()
               Source: "safeSend(bets[myid].playerAddress, bets[myid].amountBet)"
              Identifier safeSend
                 Type: function (address,uint256)
                 Source: "safeSend"
              MemberAccess to member playerAddress
                 Type: address
                 Source: "bets[myid].playerAddress"
                IndexAccess
                   Type: struct Dice.Bet storage ref
                   Source: "bets[myid]"
                  Identifier bets
                     Type: mapping(bytes32 => struct Dice.Bet storage ref)
                     Source: "bets"
                  Identifier myid
                     Type: bytes32
                     Source: "myid"
              MemberAccess to member amountBet
                 Type: uint256
                 Source: "bets[myid].amountBet"
                IndexAccess
                   Type: struct Dice.Bet storage ref
                   Source: "bets[myid]"
                  Identifier bets
                     Type: mapping(bytes32 => struct Dice.Bet storage ref)
                     Source: "bets"
                  Identifier myid
                     Type: bytes32
                     Source: "myid"
          Return
             Gas costs: 11
             Source: "return;"
      PlaceholderStatement
         Gas costs: 3
         Source: "_"
  ModifierDefinition "onlyWinningBets"
     Source: "modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint numberRolled)"
      VariableDeclaration "numberRolled"
         Type: uint256
         Source: "uint numberRolled"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }"
      IfStatement
         Source: "if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 12
           Source: "numberRolled - 1 < pwin"
          BinaryOperation using operator -
             Type: uint256
             Source: "numberRolled - 1"
            Identifier numberRolled
               Type: uint256
               Source: "numberRolled"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Identifier pwin
             Type: uint256
             Source: "pwin"
        Block
           Source: "{\r\n            _;\r\n        }"
          PlaceholderStatement
             Gas costs: 0
             Source: "_"
  ModifierDefinition "onlyLosingBets"
     Source: "modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint numberRolled)"
      VariableDeclaration "numberRolled"
         Type: uint256
         Source: "uint numberRolled"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }"
      IfStatement
         Source: "if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 15
           Source: "numberRolled - 1 >= pwin"
          BinaryOperation using operator -
             Type: uint256
             Source: "numberRolled - 1"
            Identifier numberRolled
               Type: uint256
               Source: "numberRolled"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Identifier pwin
             Type: uint256
             Source: "pwin"
        Block
           Source: "{\r\n            _;\r\n        }"
          PlaceholderStatement
             Gas costs: 0
             Source: "_"
  ModifierDefinition "onlyAfterProposed"
     Source: "modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (proposedWithdrawal.toAddress == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 514
           Source: "proposedWithdrawal.toAddress == 0"
          MemberAccess to member toAddress
             Type: address
             Source: "proposedWithdrawal.toAddress"
            Identifier proposedWithdrawal
               Type: struct Dice.WithdrawalProposal storage ref
               Source: "proposedWithdrawal"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 12
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyIfProfitNotDistributed"
     Source: "modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }"
      IfStatement
         Source: "if (!profitDistributed) {\r\n            _;\r\n        }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 242
           Source: "!profitDistributed"
          Identifier profitDistributed
             Type: bool
             Source: "profitDistributed"
        Block
           Source: "{\r\n            _;\r\n        }"
          PlaceholderStatement
             Gas costs: 0
             Source: "_"
  ModifierDefinition "onlyIfValidGas"
     Source: "modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint newGasLimit)"
      VariableDeclaration "newGasLimit"
         Type: uint256
         Source: "uint newGasLimit"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT"
          BinaryOperation using operator +
             Type: uint256
             Source: "ORACLIZE_GAS_LIMIT + newGasLimit"
            Identifier ORACLIZE_GAS_LIMIT
               Type: uint256
               Source: "ORACLIZE_GAS_LIMIT"
            Identifier newGasLimit
               Type: uint256
               Source: "newGasLimit"
          Identifier ORACLIZE_GAS_LIMIT
             Type: uint256
             Source: "ORACLIZE_GAS_LIMIT"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (newGasLimit < 25000) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "newGasLimit < 25000"
          Identifier newGasLimit
             Type: uint256
             Source: "newGasLimit"
          Literal, token: [no token] value: 25000
             Type: int_const 25000
             Source: "25000"
        Throw
           Gas costs: 6
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyIfNotProcessed"
     Source: "modifier onlyIfNotProcessed(bytes32 myid) {\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 myid)"
      VariableDeclaration "myid"
         Type: bytes32
         Source: "bytes32 myid"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (bets[myid].numberRolled > 0) throw"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 317
           Source: "bets[myid].numberRolled > 0"
          MemberAccess to member numberRolled
             Type: uint256
             Source: "bets[myid].numberRolled"
            IndexAccess
               Type: struct Dice.Bet storage ref
               Source: "bets[myid]"
              Identifier bets
                 Type: mapping(bytes32 => struct Dice.Bet storage ref)
                 Source: "bets"
              Identifier myid
                 Type: bytes32
                 Source: "myid"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      PlaceholderStatement
         Gas costs: 7
         Source: "_"
  ModifierDefinition "onlyIfEmergencyTimeOutHasPassed"
     Source: "modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }"
      IfStatement
         Source: "if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 217
           Source: "proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now"
          BinaryOperation using operator +
             Type: uint256
             Source: "proposedWithdrawal.atTime + EMERGENCY_TIMEOUT"
            MemberAccess to member atTime
               Type: uint256
               Source: "proposedWithdrawal.atTime"
              Identifier proposedWithdrawal
                 Type: struct Dice.WithdrawalProposal storage ref
                 Source: "proposedWithdrawal"
            Identifier EMERGENCY_TIMEOUT
               Type: uint256
               Source: "EMERGENCY_TIMEOUT"
          Identifier now
             Type: uint256
             Source: "now"
        Throw
           Gas costs: 6
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "investorsInvariant"
     Source: "modifier investorsInvariant {\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
      IfStatement
         Source: "if (numInvestors > maxInvestors) throw"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 412
           Source: "numInvestors > maxInvestors"
          Identifier numInvestors
             Type: uint256
             Source: "numInvestors"
          Identifier maxInvestors
             Type: uint256
             Source: "maxInvestors"
        Throw
           Gas costs: 12
           Source: "throw"
  FunctionDefinition "getBankroll" - public - const
     Source: "function getBankroll()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }"
      IfStatement
         Source: "if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 1677
           Source: "(invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)"
          BinaryOperation using operator ||
             Type: bool
             Source: "(invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested)"
            TupleExpression
               Type: bool
               Source: "(invested < investorsProfit)"
              BinaryOperation using operator <
                 Type: bool
                 Source: "invested < investorsProfit"
                Identifier invested
                   Type: uint256
                   Source: "invested"
                Identifier investorsProfit
                   Type: uint256
                   Source: "investorsProfit"
            TupleExpression
               Type: bool
               Source: "(invested + investorsProfit < invested)"
              BinaryOperation using operator <
                 Type: bool
                 Source: "invested + investorsProfit < invested"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "invested + investorsProfit"
                  Identifier invested
                     Type: uint256
                     Source: "invested"
                  Identifier investorsProfit
                     Type: uint256
                     Source: "investorsProfit"
                Identifier invested
                   Type: uint256
                   Source: "invested"
          TupleExpression
             Type: bool
             Source: "(invested + investorsProfit < investorsLosses)"
            BinaryOperation using operator <
               Type: bool
               Source: "invested + investorsProfit < investorsLosses"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "invested + investorsProfit"
                Identifier invested
                   Type: uint256
                   Source: "invested"
                Identifier investorsProfit
                   Type: uint256
                   Source: "investorsProfit"
              Identifier investorsLosses
                 Type: uint256
                 Source: "investorsLosses"
        Block
           Source: "{\r\n            return 0;\r\n        }"
          Return
             Gas costs: 19
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            return invested + investorsProfit - investorsLosses;\r\n        }"
          Return
             Gas costs: 620
             Source: "return invested + investorsProfit - investorsLosses"
            BinaryOperation using operator -
               Type: uint256
               Source: "invested + investorsProfit - investorsLosses"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "invested + investorsProfit"
                Identifier invested
                   Type: uint256
                   Source: "invested"
                Identifier investorsProfit
                   Type: uint256
                   Source: "investorsProfit"
              Identifier investorsLosses
                 Type: uint256
                 Source: "investorsLosses"
  FunctionDefinition "getMinInvestment" - public - const
     Source: "function getMinInvestment()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }"
      IfStatement
         Source: "if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 206
           Source: "numInvestors == maxInvestors"
          Identifier numInvestors
             Type: uint256
             Source: "numInvestors"
          Identifier maxInvestors
             Type: uint256
             Source: "maxInvestors"
        Block
           Source: "{\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }"
          VariableDeclarationStatement
             Gas costs: 23
             Source: "uint investorID = searchSmallestInvestor()"
            VariableDeclaration "investorID"
               Type: uint256
               Source: "uint investorID"
              ElementaryTypeName uint
                 Source: "uint"
            FunctionCall
               Type: uint256
               Source: "searchSmallestInvestor()"
              Identifier searchSmallestInvestor
                 Type: function () view returns (uint256)
                 Source: "searchSmallestInvestor"
          Return
             Gas costs: 360
             Source: "return getBalance(investors[investorID].investorAddress)"
            FunctionCall
               Type: uint256
               Source: "getBalance(investors[investorID].investorAddress)"
              Identifier getBalance
                 Type: function (address) view returns (uint256)
                 Source: "getBalance"
              MemberAccess to member investorAddress
                 Type: address
                 Source: "investors[investorID].investorAddress"
                IndexAccess
                   Type: struct Dice.Investor storage ref
                   Source: "investors[investorID]"
                  Identifier investors
                     Type: mapping(uint256 => struct Dice.Investor storage ref)
                     Source: "investors"
                  Identifier investorID
                     Type: uint256
                     Source: "investorID"
        Block
           Source: "{\r\n            return 0;\r\n        }"
          Return
             Gas costs: 8
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "getStatus" - public - const
     Source: "function getStatus()\r\n        constant\r\n        returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 24
       Source: "(uint, uint, uint, uint, uint, uint, uint, uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 23
         Source: "uint bankroll = getBankroll()"
        VariableDeclaration "bankroll"
           Type: uint256
           Source: "uint bankroll"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getBankroll()"
          Identifier getBankroll
             Type: function () view returns (uint256)
             Source: "getBankroll"
      VariableDeclarationStatement
         Gas costs: 23
         Source: "uint minInvestment = getMinInvestment()"
        VariableDeclaration "minInvestment"
           Type: uint256
           Source: "uint minInvestment"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getMinInvestment()"
          Identifier getMinInvestment
             Type: function () view returns (uint256)
             Source: "getMinInvestment"
      Return
         Gas costs: 666
         Source: "return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length)"
        TupleExpression
           Type: tuple(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)
           Source: "(bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length)"
          Identifier bankroll
             Type: uint256
             Source: "bankroll"
          Identifier pwin
             Type: uint256
             Source: "pwin"
          Identifier edge
             Type: uint256
             Source: "edge"
          Identifier maxWin
             Type: uint256
             Source: "maxWin"
          Identifier minBet
             Type: uint256
             Source: "minBet"
          TupleExpression
             Type: uint256
             Source: "(investorsProfit - investorsLosses)"
            BinaryOperation using operator -
               Type: uint256
               Source: "investorsProfit - investorsLosses"
              Identifier investorsProfit
                 Type: uint256
                 Source: "investorsProfit"
              Identifier investorsLosses
                 Type: uint256
                 Source: "investorsLosses"
          Identifier minInvestment
             Type: uint256
             Source: "minInvestment"
          MemberAccess to member length
             Type: uint256
             Source: "betsKeys.length"
            Identifier betsKeys
               Type: bytes32[] storage ref
               Source: "betsKeys"
  FunctionDefinition "getBet" - public - const
     Source: "function getBet(uint id)\r\n        constant\r\n        returns(address, uint, uint) {\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint id)"
      VariableDeclaration "id"
         Type: uint256
         Source: "uint id"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 9
       Source: "(address, uint, uint)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }"
      IfStatement
         Source: "if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 217
           Source: "id < betsKeys.length"
          Identifier id
             Type: uint256
             Source: "id"
          MemberAccess to member length
             Type: uint256
             Source: "betsKeys.length"
            Identifier betsKeys
               Type: bytes32[] storage ref
               Source: "betsKeys"
        Block
           Source: "{\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }"
          VariableDeclarationStatement
             Gas costs: 500
             Source: "bytes32 betKey = betsKeys[id]"
            VariableDeclaration "betKey"
               Type: bytes32
               Source: "bytes32 betKey"
              ElementaryTypeName bytes32
                 Source: "bytes32"
            IndexAccess
               Type: bytes32
               Source: "betsKeys[id]"
              Identifier betsKeys
                 Type: bytes32[] storage ref
                 Source: "betsKeys"
              Identifier id
                 Type: uint256
                 Source: "id"
          Return
             Gas costs: 980
             Source: "return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled)"
            TupleExpression
               Type: tuple(address,uint256,uint256)
               Source: "(bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled)"
              MemberAccess to member playerAddress
                 Type: address
                 Source: "bets[betKey].playerAddress"
                IndexAccess
                   Type: struct Dice.Bet storage ref
                   Source: "bets[betKey]"
                  Identifier bets
                     Type: mapping(bytes32 => struct Dice.Bet storage ref)
                     Source: "bets"
                  Identifier betKey
                     Type: bytes32
                     Source: "betKey"
              MemberAccess to member amountBet
                 Type: uint256
                 Source: "bets[betKey].amountBet"
                IndexAccess
                   Type: struct Dice.Bet storage ref
                   Source: "bets[betKey]"
                  Identifier bets
                     Type: mapping(bytes32 => struct Dice.Bet storage ref)
                     Source: "bets"
                  Identifier betKey
                     Type: bytes32
                     Source: "betKey"
              MemberAccess to member numberRolled
                 Type: uint256
                 Source: "bets[betKey].numberRolled"
                IndexAccess
                   Type: struct Dice.Bet storage ref
                   Source: "bets[betKey]"
                  Identifier bets
                     Type: mapping(bytes32 => struct Dice.Bet storage ref)
                     Source: "bets"
                  Identifier betKey
                     Type: bytes32
                     Source: "betKey"
  FunctionDefinition "numBets" - public - const
     Source: "function numBets()\r\n        constant\r\n        returns(uint) {\r\n\r\n        return betsKeys.length;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        return betsKeys.length;\r\n    }"
      Return
         Gas costs: 216
         Source: "return betsKeys.length"
        MemberAccess to member length
           Type: uint256
           Source: "betsKeys.length"
          Identifier betsKeys
             Type: bytes32[] storage ref
             Source: "betsKeys"
  FunctionDefinition "getMinBetAmount" - public - const
     Source: "function getMinBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas)"
        VariableDeclaration "oraclizeFee"
           Type: uint256
           Source: "uint oraclizeFee"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas)"
          MemberAccess to member getPrice
             Type: function (string memory,uint256) external returns (uint256)
             Source: "OraclizeI(OAR.getAddress()).getPrice"
            FunctionCall
               Type: contract OraclizeI
               Source: "OraclizeI(OAR.getAddress())"
              Identifier OraclizeI
                 Type: type(contract OraclizeI)
                 Source: "OraclizeI"
              FunctionCall
                 Type: address
                 Source: "OAR.getAddress()"
                MemberAccess to member getAddress
                   Type: function () external returns (address)
                   Source: "OAR.getAddress"
                  Identifier OAR
                     Type: contract OraclizeAddrResolverI
                     Source: "OAR"
          Literal, token: [no token] value: URL
             Type: literal_string "URL"
             Source: "\"URL\""
          BinaryOperation using operator +
             Type: uint256
             Source: "ORACLIZE_GAS_LIMIT + safeGas"
            Identifier ORACLIZE_GAS_LIMIT
               Type: uint256
               Source: "ORACLIZE_GAS_LIMIT"
            Identifier safeGas
               Type: uint256
               Source: "safeGas"
      Return
         Gas costs: 11
         Source: "return oraclizeFee + minBet"
        BinaryOperation using operator +
           Type: uint256
           Source: "oraclizeFee + minBet"
          Identifier oraclizeFee
             Type: uint256
             Source: "oraclizeFee"
          Identifier minBet
             Type: uint256
             Source: "minBet"
  FunctionDefinition "getMaxBetAmount" - public - const
     Source: "function getMaxBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas)"
        VariableDeclaration "oraclizeFee"
           Type: uint256
           Source: "uint oraclizeFee"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas)"
          MemberAccess to member getPrice
             Type: function (string memory,uint256) external returns (uint256)
             Source: "OraclizeI(OAR.getAddress()).getPrice"
            FunctionCall
               Type: contract OraclizeI
               Source: "OraclizeI(OAR.getAddress())"
              Identifier OraclizeI
                 Type: type(contract OraclizeI)
                 Source: "OraclizeI"
              FunctionCall
                 Type: address
                 Source: "OAR.getAddress()"
                MemberAccess to member getAddress
                   Type: function () external returns (address)
                   Source: "OAR.getAddress"
                  Identifier OAR
                     Type: contract OraclizeAddrResolverI
                     Source: "OAR"
          Literal, token: [no token] value: URL
             Type: literal_string "URL"
             Source: "\"URL\""
          BinaryOperation using operator +
             Type: uint256
             Source: "ORACLIZE_GAS_LIMIT + safeGas"
            Identifier ORACLIZE_GAS_LIMIT
               Type: uint256
               Source: "ORACLIZE_GAS_LIMIT"
            Identifier safeGas
               Type: uint256
               Source: "safeGas"
      VariableDeclarationStatement
         Gas costs: 78
         Source: "uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin))"
        VariableDeclaration "betValue"
           Type: uint256
           Source: "uint betValue"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "(maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin))"
          BinaryOperation using operator *
             Type: uint256
             Source: "(maxWin * getBankroll()) * pwin"
            TupleExpression
               Type: uint256
               Source: "(maxWin * getBankroll())"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "maxWin * getBankroll()"
                Identifier maxWin
                   Type: uint256
                   Source: "maxWin"
                FunctionCall
                   Type: uint256
                   Source: "getBankroll()"
                  Identifier getBankroll
                     Type: function () view returns (uint256)
                     Source: "getBankroll"
            Identifier pwin
               Type: uint256
               Source: "pwin"
          TupleExpression
             Type: uint256
             Source: "(10000 * (10000 - edge - pwin))"
            BinaryOperation using operator *
               Type: uint256
               Source: "10000 * (10000 - edge - pwin)"
              Literal, token: [no token] value: 10000
                 Type: int_const 10000
                 Source: "10000"
              TupleExpression
                 Type: uint256
                 Source: "(10000 - edge - pwin)"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "10000 - edge - pwin"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "10000 - edge"
                    Literal, token: [no token] value: 10000
                       Type: int_const 10000
                       Source: "10000"
                    Identifier edge
                       Type: uint256
                       Source: "edge"
                  Identifier pwin
                     Type: uint256
                     Source: "pwin"
      Return
         Gas costs: 14
         Source: "return betValue + oraclizeFee"
        BinaryOperation using operator +
           Type: uint256
           Source: "betValue + oraclizeFee"
          Identifier betValue
             Type: uint256
             Source: "betValue"
          Identifier oraclizeFee
             Type: uint256
             Source: "oraclizeFee"
  FunctionDefinition "getLossesShare" - public - const
     Source: "function getLossesShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address currentInvestor)"
      VariableDeclaration "currentInvestor"
         Type: address
         Source: "address currentInvestor"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }"
      Return
         Gas costs: 1027
         Source: "return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested"
        BinaryOperation using operator /
           Type: uint256
           Source: "investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested"
          BinaryOperation using operator *
             Type: uint256
             Source: "investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses)"
            MemberAccess to member amountInvested
               Type: uint256
               Source: "investors[investorIDs[currentInvestor]].amountInvested"
              IndexAccess
                 Type: struct Dice.Investor storage ref
                 Source: "investors[investorIDs[currentInvestor]]"
                Identifier investors
                   Type: mapping(uint256 => struct Dice.Investor storage ref)
                   Source: "investors"
                IndexAccess
                   Type: uint256
                   Source: "investorIDs[currentInvestor]"
                  Identifier investorIDs
                     Type: mapping(address => uint256)
                     Source: "investorIDs"
                  Identifier currentInvestor
                     Type: address
                     Source: "currentInvestor"
            TupleExpression
               Type: uint256
               Source: "(investorsLosses)"
              Identifier investorsLosses
                 Type: uint256
                 Source: "investorsLosses"
          Identifier invested
             Type: uint256
             Source: "invested"
  FunctionDefinition "getProfitShare" - public - const
     Source: "function getProfitShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address currentInvestor)"
      VariableDeclaration "currentInvestor"
         Type: address
         Source: "address currentInvestor"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }"
      Return
         Gas costs: 1027
         Source: "return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested"
        BinaryOperation using operator /
           Type: uint256
           Source: "investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested"
          BinaryOperation using operator *
             Type: uint256
             Source: "investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit)"
            MemberAccess to member amountInvested
               Type: uint256
               Source: "investors[investorIDs[currentInvestor]].amountInvested"
              IndexAccess
                 Type: struct Dice.Investor storage ref
                 Source: "investors[investorIDs[currentInvestor]]"
                Identifier investors
                   Type: mapping(uint256 => struct Dice.Investor storage ref)
                   Source: "investors"
                IndexAccess
                   Type: uint256
                   Source: "investorIDs[currentInvestor]"
                  Identifier investorIDs
                     Type: mapping(address => uint256)
                     Source: "investorIDs"
                  Identifier currentInvestor
                     Type: address
                     Source: "currentInvestor"
            TupleExpression
               Type: uint256
               Source: "(investorsProfit)"
              Identifier investorsProfit
                 Type: uint256
                 Source: "investorsProfit"
          Identifier invested
             Type: uint256
             Source: "invested"
  FunctionDefinition "getBalance" - public - const
     Source: "function getBalance(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address currentInvestor)"
      VariableDeclaration "currentInvestor"
         Type: address
         Source: "address currentInvestor"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 591
         Source: "uint invested = investors[investorIDs[currentInvestor]].amountInvested"
        VariableDeclaration "invested"
           Type: uint256
           Source: "uint invested"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member amountInvested
           Type: uint256
           Source: "investors[investorIDs[currentInvestor]].amountInvested"
          IndexAccess
             Type: struct Dice.Investor storage ref
             Source: "investors[investorIDs[currentInvestor]]"
            Identifier investors
               Type: mapping(uint256 => struct Dice.Investor storage ref)
               Source: "investors"
            IndexAccess
               Type: uint256
               Source: "investorIDs[currentInvestor]"
              Identifier investorIDs
                 Type: mapping(address => uint256)
                 Source: "investorIDs"
              Identifier currentInvestor
                 Type: address
                 Source: "currentInvestor"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint profit = getProfitShare(currentInvestor)"
        VariableDeclaration "profit"
           Type: uint256
           Source: "uint profit"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getProfitShare(currentInvestor)"
          Identifier getProfitShare
             Type: function (address) view returns (uint256)
             Source: "getProfitShare"
          Identifier currentInvestor
             Type: address
             Source: "currentInvestor"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint losses = getLossesShare(currentInvestor)"
        VariableDeclaration "losses"
           Type: uint256
           Source: "uint losses"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getLossesShare(currentInvestor)"
          Identifier getLossesShare
             Type: function (address) view returns (uint256)
             Source: "getLossesShare"
          Identifier currentInvestor
             Type: address
             Source: "currentInvestor"
      IfStatement
         Source: "if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 83
           Source: "(invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses)"
          BinaryOperation using operator ||
             Type: bool
             Source: "(invested + profit < profit) ||\r\n            (invested + profit < invested)"
            TupleExpression
               Type: bool
               Source: "(invested + profit < profit)"
              BinaryOperation using operator <
                 Type: bool
                 Source: "invested + profit < profit"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "invested + profit"
                  Identifier invested
                     Type: uint256
                     Source: "invested"
                  Identifier profit
                     Type: uint256
                     Source: "profit"
                Identifier profit
                   Type: uint256
                   Source: "profit"
            TupleExpression
               Type: bool
               Source: "(invested + profit < invested)"
              BinaryOperation using operator <
                 Type: bool
                 Source: "invested + profit < invested"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "invested + profit"
                  Identifier invested
                     Type: uint256
                     Source: "invested"
                  Identifier profit
                     Type: uint256
                     Source: "profit"
                Identifier invested
                   Type: uint256
                   Source: "invested"
          TupleExpression
             Type: bool
             Source: "(invested + profit < losses)"
            BinaryOperation using operator <
               Type: bool
               Source: "invested + profit < losses"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "invested + profit"
                Identifier invested
                   Type: uint256
                   Source: "invested"
                Identifier profit
                   Type: uint256
                   Source: "profit"
              Identifier losses
                 Type: uint256
                 Source: "losses"
        Return
           Gas costs: 19
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 20
           Source: "return invested + profit - losses"
          BinaryOperation using operator -
             Type: uint256
             Source: "invested + profit - losses"
            BinaryOperation using operator +
               Type: uint256
               Source: "invested + profit"
              Identifier invested
                 Type: uint256
                 Source: "invested"
              Identifier profit
                 Type: uint256
                 Source: "profit"
            Identifier losses
               Type: uint256
               Source: "losses"
  FunctionDefinition "searchSmallestInvestor" - public - const
     Source: "function searchSmallestInvestor()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint investorID = 1"
        VariableDeclaration "investorID"
           Type: uint256
           Source: "uint investorID"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 1
           Type: int_const 1
           Source: "1"
      ForStatement
         Source: "for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 1"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 212
           Source: "i <= numInvestors"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier numInvestors
             Type: uint256
             Source: "numInvestors"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }"
          IfStatement
             Source: "if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 691
               Source: "getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)"
              FunctionCall
                 Type: uint256
                 Source: "getBalance(investors[i].investorAddress)"
                Identifier getBalance
                   Type: function (address) view returns (uint256)
                   Source: "getBalance"
                MemberAccess to member investorAddress
                   Type: address
                   Source: "investors[i].investorAddress"
                  IndexAccess
                     Type: struct Dice.Investor storage ref
                     Source: "investors[i]"
                    Identifier investors
                       Type: mapping(uint256 => struct Dice.Investor storage ref)
                       Source: "investors"
                    Identifier i
                       Type: uint256
                       Source: "i"
              FunctionCall
                 Type: uint256
                 Source: "getBalance(investors[investorID].investorAddress)"
                Identifier getBalance
                   Type: function (address) view returns (uint256)
                   Source: "getBalance"
                MemberAccess to member investorAddress
                   Type: address
                   Source: "investors[investorID].investorAddress"
                  IndexAccess
                     Type: struct Dice.Investor storage ref
                     Source: "investors[investorID]"
                    Identifier investors
                       Type: mapping(uint256 => struct Dice.Investor storage ref)
                       Source: "investors"
                    Identifier investorID
                       Type: uint256
                       Source: "investorID"
            Block
               Source: "{\r\n                investorID = i;\r\n            }"
              ExpressionStatement
                 Gas costs: 8
                 Source: "investorID = i"
                Assignment using operator =
                   Type: uint256
                   Source: "investorID = i"
                  Identifier investorID
                     Type: uint256
                     Source: "investorID"
                  Identifier i
                     Type: uint256
                     Source: "i"
      Return
         Gas costs: 8
         Source: "return investorID"
        Identifier investorID
           Type: uint256
           Source: "investorID"
  FunctionDefinition "changeOraclizeProofType" - public
     Source: "function changeOraclizeProofType(byte _proofType)\r\n        onlyOwner {\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(byte _proofType)"
      VariableDeclaration "_proofType"
         Type: bytes1
         Source: "byte _proofType"
        ElementaryTypeName byte
           Source: "byte"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }"
      IfStatement
         Source: "if (_proofType == 0x00) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 26
           Source: "_proofType == 0x00"
          Identifier _proofType
             Type: bytes1
             Source: "_proofType"
          Literal, token: [no token] value: 0x00
             Type: int_const 0
             Source: "0x00"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 18
         Source: "oraclize_setProof( _proofType |  proofStorage_IPFS )"
        FunctionCall
           Type: tuple()
           Source: "oraclize_setProof( _proofType |  proofStorage_IPFS )"
          Identifier oraclize_setProof
             Type: function (bytes1)
             Source: "oraclize_setProof"
          BinaryOperation using operator |
             Type: bytes1
             Source: "_proofType |  proofStorage_IPFS"
            Identifier _proofType
               Type: bytes1
               Source: "_proofType"
            Identifier proofStorage_IPFS
               Type: bytes1
               Source: "proofStorage_IPFS"
  FunctionDefinition "changeOraclizeConfig" - public
     Source: "function changeOraclizeConfig(bytes32 _config)\r\n        onlyOwner {\r\n\r\n        oraclize_setConfig(_config);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _config)"
      VariableDeclaration "_config"
         Type: bytes32
         Source: "bytes32 _config"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n\r\n        oraclize_setConfig(_config);\r\n    }"
      ExpressionStatement
         Gas costs: 7
         Source: "oraclize_setConfig(_config)"
        FunctionCall
           Type: tuple()
           Source: "oraclize_setConfig(_config)"
          Identifier oraclize_setConfig
             Type: function (bytes32)
             Source: "oraclize_setConfig"
          Identifier _config
             Type: bytes32
             Source: "_config"
  FunctionDefinition "safeSend"
     Source: "function safeSend(address addr, uint value)\r\n        private {\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address addr, uint value)"
      VariableDeclaration "addr"
         Type: address
         Source: "address addr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }"
      IfStatement
         Source: "if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "value == 0"
          Identifier value
             Type: uint256
             Source: "value"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            LOG_ZeroSend();\r\n            return;\r\n        }"
          ExpressionStatement
             Gas costs: 786
             Source: "LOG_ZeroSend()"
            FunctionCall
               Type: tuple()
               Source: "LOG_ZeroSend()"
              Identifier LOG_ZeroSend
                 Type: function ()
                 Source: "LOG_ZeroSend"
          Return
             Gas costs: 11
             Source: "return;"
      IfStatement
         Source: "if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 414
           Source: "this.balance < value"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract Dice
               Source: "this"
          Identifier value
             Type: uint256
             Source: "value"
        Block
           Source: "{\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }"
          ExpressionStatement
             Gas costs: 786
             Source: "LOG_ValueIsTooBig()"
            FunctionCall
               Type: tuple()
               Source: "LOG_ValueIsTooBig()"
              Identifier LOG_ValueIsTooBig
                 Type: function ()
                 Source: "LOG_ValueIsTooBig"
          Return
             Gas costs: 11
             Source: "return;"
      IfStatement
         Source: "if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!(addr.call.gas(safeGas).value(value)())"
          TupleExpression
             Type: bool
             Source: "(addr.call.gas(safeGas).value(value)())"
            FunctionCall
               Type: bool
               Source: "addr.call.gas(safeGas).value(value)()"
              FunctionCall
                 Type: function () payable returns (bool)
                 Source: "addr.call.gas(safeGas).value(value)"
                MemberAccess to member value
                   Type: function (uint256) returns (function () payable returns (bool))
                   Source: "addr.call.gas(safeGas).value"
                  FunctionCall
                     Type: function () payable returns (bool)
                     Source: "addr.call.gas(safeGas)"
                    MemberAccess to member gas
                       Type: function (uint256) returns (function () payable returns (bool))
                       Source: "addr.call.gas"
                      MemberAccess to member call
                         Type: function () payable returns (bool)
                         Source: "addr.call"
                        Identifier addr
                           Type: address
                           Source: "addr"
                    Identifier safeGas
                       Type: uint256
                       Source: "safeGas"
                Identifier value
                   Type: uint256
                   Source: "value"
        Block
           Source: "{\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "LOG_FailedSend(addr, value)"
            FunctionCall
               Type: tuple()
               Source: "LOG_FailedSend(addr, value)"
              Identifier LOG_FailedSend
                 Type: function (address,uint256)
                 Source: "LOG_FailedSend"
              Identifier addr
                 Type: address
                 Source: "addr"
              Identifier value
                 Type: uint256
                 Source: "value"
          IfStatement
             Source: "if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }"
            BinaryOperation using operator !=
               Type: bool
               Gas costs: 260
               Source: "addr != houseAddress"
              Identifier addr
                 Type: address
                 Source: "addr"
              Identifier houseAddress
                 Type: address
                 Source: "houseAddress"
            Block
               Source: "{\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }"
              IfStatement
                 Source: "if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value)"
                UnaryOperation (prefix) !
                   Type: bool
                   Gas costs: [???]
                   Source: "!(houseAddress.call.gas(safeGas).value(value)())"
                  TupleExpression
                     Type: bool
                     Source: "(houseAddress.call.gas(safeGas).value(value)())"
                    FunctionCall
                       Type: bool
                       Source: "houseAddress.call.gas(safeGas).value(value)()"
                      FunctionCall
                         Type: function () payable returns (bool)
                         Source: "houseAddress.call.gas(safeGas).value(value)"
                        MemberAccess to member value
                           Type: function (uint256) returns (function () payable returns (bool))
                           Source: "houseAddress.call.gas(safeGas).value"
                          FunctionCall
                             Type: function () payable returns (bool)
                             Source: "houseAddress.call.gas(safeGas)"
                            MemberAccess to member gas
                               Type: function (uint256) returns (function () payable returns (bool))
                               Source: "houseAddress.call.gas"
                              MemberAccess to member call
                                 Type: function () payable returns (bool)
                                 Source: "houseAddress.call"
                                Identifier houseAddress
                                   Type: address
                                   Source: "houseAddress"
                            Identifier safeGas
                               Type: uint256
                               Source: "safeGas"
                        Identifier value
                           Type: uint256
                           Source: "value"
                ExpressionStatement
                   Gas costs: [???]
                   Source: "LOG_FailedSend(houseAddress, value)"
                  FunctionCall
                     Type: tuple()
                     Source: "LOG_FailedSend(houseAddress, value)"
                    Identifier LOG_FailedSend
                       Type: function (address,uint256)
                       Source: "LOG_FailedSend"
                    Identifier houseAddress
                       Type: address
                       Source: "houseAddress"
                    Identifier value
                       Type: uint256
                       Source: "value"
      ExpressionStatement
         Gas costs: [???]
         Source: "LOG_SuccessfulSend(addr,value)"
        FunctionCall
           Type: tuple()
           Source: "LOG_SuccessfulSend(addr,value)"
          Identifier LOG_SuccessfulSend
             Type: function (address,uint256)
             Source: "LOG_SuccessfulSend"
          Identifier addr
             Type: address
             Source: "addr"
          Identifier value
             Type: uint256
             Source: "value"
  FunctionDefinition "addInvestorAtID"
     Source: "function addInvestorAtID(uint id)\r\n        private {\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint id)"
      VariableDeclaration "id"
         Type: uint256
         Source: "uint id"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }"
      ExpressionStatement
         Gas costs: 20109
         Source: "investorIDs[msg.sender] = id"
        Assignment using operator =
           Type: uint256
           Source: "investorIDs[msg.sender] = id"
          IndexAccess
             Type: uint256
             Source: "investorIDs[msg.sender]"
            Identifier investorIDs
               Type: mapping(address => uint256)
               Source: "investorIDs"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier id
             Type: uint256
             Source: "id"
      ExpressionStatement
         Gas costs: 20350
         Source: "investors[id].investorAddress = msg.sender"
        Assignment using operator =
           Type: address
           Source: "investors[id].investorAddress = msg.sender"
          MemberAccess to member investorAddress
             Type: address
             Source: "investors[id].investorAddress"
            IndexAccess
               Type: struct Dice.Investor storage ref
               Source: "investors[id]"
              Identifier investors
                 Type: mapping(uint256 => struct Dice.Investor storage ref)
                 Source: "investors"
              Identifier id
                 Type: uint256
                 Source: "id"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20097
         Source: "investors[id].amountInvested = msg.value"
        Assignment using operator =
           Type: uint256
           Source: "investors[id].amountInvested = msg.value"
          MemberAccess to member amountInvested
             Type: uint256
             Source: "investors[id].amountInvested"
            IndexAccess
               Type: struct Dice.Investor storage ref
               Source: "investors[id]"
              Identifier investors
                 Type: mapping(uint256 => struct Dice.Investor storage ref)
                 Source: "investors"
              Identifier id
                 Type: uint256
                 Source: "id"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20232
         Source: "invested += msg.value"
        Assignment using operator +=
           Type: uint256
           Source: "invested += msg.value"
          Identifier invested
             Type: uint256
             Source: "invested"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: [???]
         Source: "LOG_InvestorEntrance(msg.sender, msg.value)"
        FunctionCall
           Type: tuple()
           Source: "LOG_InvestorEntrance(msg.sender, msg.value)"
          Identifier LOG_InvestorEntrance
             Type: function (address,uint256)
             Source: "LOG_InvestorEntrance"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "profitDistribution"
     Source: "function profitDistribution()\r\n        private\r\n        onlyIfProfitNotDistributed {\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyIfProfitNotDistributed"
       Gas costs: 0
       Source: "onlyIfProfitNotDistributed"
      Identifier onlyIfProfitNotDistributed
         Type: modifier ()
         Source: "onlyIfProfitNotDistributed"
    Block
       Source: "{\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint copyInvested"
        VariableDeclaration "copyInvested"
           Type: uint256
           Source: "uint copyInvested"
          ElementaryTypeName uint
             Source: "uint"
      ForStatement
         Source: "for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 1"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 212
           Source: "i <= numInvestors"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier numInvestors
             Type: uint256
             Source: "numInvestors"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 337
             Source: "address currentInvestor = investors[i].investorAddress"
            VariableDeclaration "currentInvestor"
               Type: address
               Source: "address currentInvestor"
              ElementaryTypeName address
                 Source: "address"
            MemberAccess to member investorAddress
               Type: address
               Source: "investors[i].investorAddress"
              IndexAccess
                 Type: struct Dice.Investor storage ref
                 Source: "investors[i]"
                Identifier investors
                   Type: mapping(uint256 => struct Dice.Investor storage ref)
                   Source: "investors"
                Identifier i
                   Type: uint256
                   Source: "i"
          VariableDeclarationStatement
             Gas costs: 26
             Source: "uint profitOfInvestor = getProfitShare(currentInvestor)"
            VariableDeclaration "profitOfInvestor"
               Type: uint256
               Source: "uint profitOfInvestor"
              ElementaryTypeName uint
                 Source: "uint"
            FunctionCall
               Type: uint256
               Source: "getProfitShare(currentInvestor)"
              Identifier getProfitShare
                 Type: function (address) view returns (uint256)
                 Source: "getProfitShare"
              Identifier currentInvestor
                 Type: address
                 Source: "currentInvestor"
          VariableDeclarationStatement
             Gas costs: 26
             Source: "uint lossesOfInvestor = getLossesShare(currentInvestor)"
            VariableDeclaration "lossesOfInvestor"
               Type: uint256
               Source: "uint lossesOfInvestor"
              ElementaryTypeName uint
                 Source: "uint"
            FunctionCall
               Type: uint256
               Source: "getLossesShare(currentInvestor)"
              Identifier getLossesShare
                 Type: function (address) view returns (uint256)
                 Source: "getLossesShare"
              Identifier currentInvestor
                 Type: address
                 Source: "currentInvestor"
          IfStatement
             Source: "if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 922
               Source: "(investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor)"
              TupleExpression
                 Type: bool
                 Source: "(investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested)"
                BinaryOperation using operator >=
                   Type: bool
                   Source: "investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "investors[i].amountInvested + profitOfInvestor"
                    MemberAccess to member amountInvested
                       Type: uint256
                       Source: "investors[i].amountInvested"
                      IndexAccess
                         Type: struct Dice.Investor storage ref
                         Source: "investors[i]"
                        Identifier investors
                           Type: mapping(uint256 => struct Dice.Investor storage ref)
                           Source: "investors"
                        Identifier i
                           Type: uint256
                           Source: "i"
                    Identifier profitOfInvestor
                       Type: uint256
                       Source: "profitOfInvestor"
                  MemberAccess to member amountInvested
                     Type: uint256
                     Source: "investors[i].amountInvested"
                    IndexAccess
                       Type: struct Dice.Investor storage ref
                       Source: "investors[i]"
                      Identifier investors
                         Type: mapping(uint256 => struct Dice.Investor storage ref)
                         Source: "investors"
                      Identifier i
                         Type: uint256
                         Source: "i"
              TupleExpression
                 Type: bool
                 Source: "(investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor)"
                BinaryOperation using operator >=
                   Type: bool
                   Source: "investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "investors[i].amountInvested + profitOfInvestor"
                    MemberAccess to member amountInvested
                       Type: uint256
                       Source: "investors[i].amountInvested"
                      IndexAccess
                         Type: struct Dice.Investor storage ref
                         Source: "investors[i]"
                        Identifier investors
                           Type: mapping(uint256 => struct Dice.Investor storage ref)
                           Source: "investors"
                        Identifier i
                           Type: uint256
                           Source: "i"
                    Identifier profitOfInvestor
                       Type: uint256
                       Source: "profitOfInvestor"
                  Identifier lossesOfInvestor
                     Type: uint256
                     Source: "lossesOfInvestor"
            Block
               Source: "{\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }"
              ExpressionStatement
                 Gas costs: 20329
                 Source: "investors[i].amountInvested += profitOfInvestor - lossesOfInvestor"
                Assignment using operator +=
                   Type: uint256
                   Source: "investors[i].amountInvested += profitOfInvestor - lossesOfInvestor"
                  MemberAccess to member amountInvested
                     Type: uint256
                     Source: "investors[i].amountInvested"
                    IndexAccess
                       Type: struct Dice.Investor storage ref
                       Source: "investors[i]"
                      Identifier investors
                         Type: mapping(uint256 => struct Dice.Investor storage ref)
                         Source: "investors"
                      Identifier i
                         Type: uint256
                         Source: "i"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "profitOfInvestor - lossesOfInvestor"
                    Identifier profitOfInvestor
                       Type: uint256
                       Source: "profitOfInvestor"
                    Identifier lossesOfInvestor
                       Type: uint256
                       Source: "lossesOfInvestor"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor))"
                FunctionCall
                   Type: tuple()
                   Source: "LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor))"
                  Identifier LOG_InvestorCapitalUpdate
                     Type: function (address,int256)
                     Source: "LOG_InvestorCapitalUpdate"
                  Identifier currentInvestor
                     Type: address
                     Source: "currentInvestor"
                  FunctionCall
                     Type: int256
                     Source: "(int) (profitOfInvestor - lossesOfInvestor)"
                    TupleExpression
                       Type: type(int256)
                       Source: "(int)"
                      ElementaryTypeNameExpression int
                         Type: type(int256)
                         Source: "int"
                    BinaryOperation using operator -
                       Type: uint256
                       Source: "profitOfInvestor - lossesOfInvestor"
                      Identifier profitOfInvestor
                         Type: uint256
                         Source: "profitOfInvestor"
                      Identifier lossesOfInvestor
                         Type: uint256
                         Source: "lossesOfInvestor"
            Block
               Source: "{\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }"
              ExpressionStatement
                 Gas costs: 20317
                 Source: "isStopped = true"
                Assignment using operator =
                   Type: bool
                   Source: "isStopped = true"
                  Identifier isStopped
                     Type: bool
                     Source: "isStopped"
                  Literal, token: true value: true
                     Type: bool
                     Source: "true"
              ExpressionStatement
                 Gas costs: 786
                 Source: "LOG_EmergencyAutoStop()"
                FunctionCall
                   Type: tuple()
                   Source: "LOG_EmergencyAutoStop()"
                  Identifier LOG_EmergencyAutoStop
                     Type: function ()
                     Source: "LOG_EmergencyAutoStop"
          IfStatement
             Source: "if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested"
            BinaryOperation using operator >=
               Type: bool
               Gas costs: 308
               Source: "copyInvested + investors[i].amountInvested >= copyInvested"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "copyInvested + investors[i].amountInvested"
                Identifier copyInvested
                   Type: uint256
                   Source: "copyInvested"
                MemberAccess to member amountInvested
                   Type: uint256
                   Source: "investors[i].amountInvested"
                  IndexAccess
                     Type: struct Dice.Investor storage ref
                     Source: "investors[i]"
                    Identifier investors
                       Type: mapping(uint256 => struct Dice.Investor storage ref)
                       Source: "investors"
                    Identifier i
                       Type: uint256
                       Source: "i"
              Identifier copyInvested
                 Type: uint256
                 Source: "copyInvested"
            ExpressionStatement
               Gas costs: 304
               Source: "copyInvested += investors[i].amountInvested"
              Assignment using operator +=
                 Type: uint256
                 Source: "copyInvested += investors[i].amountInvested"
                Identifier copyInvested
                   Type: uint256
                   Source: "copyInvested"
                MemberAccess to member amountInvested
                   Type: uint256
                   Source: "investors[i].amountInvested"
                  IndexAccess
                     Type: struct Dice.Investor storage ref
                     Source: "investors[i]"
                    Identifier investors
                       Type: mapping(uint256 => struct Dice.Investor storage ref)
                       Source: "investors"
                    Identifier i
                       Type: uint256
                       Source: "i"
      ExpressionStatement
         Gas costs: 5009
         Source: "delete investorsProfit"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete investorsProfit"
          Identifier investorsProfit
             Type: uint256
             Source: "investorsProfit"
      ExpressionStatement
         Gas costs: 5009
         Source: "delete investorsLosses"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete investorsLosses"
          Identifier investorsLosses
             Type: uint256
             Source: "investorsLosses"
      ExpressionStatement
         Gas costs: 20014
         Source: "invested = copyInvested"
        Assignment using operator =
           Type: uint256
           Source: "invested = copyInvested"
          Identifier invested
             Type: uint256
             Source: "invested"
          Identifier copyInvested
             Type: uint256
             Source: "copyInvested"
      ExpressionStatement
         Gas costs: 20267
         Source: "profitDistributed = true"
        Assignment using operator =
           Type: bool
           Source: "profitDistributed = true"
          Identifier profitDistributed
             Type: bool
             Source: "profitDistributed"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "" - public
     Source: "function()\r\n        payable {\r\n\r\n        bet();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\r\n        bet();\r\n    }"
      ExpressionStatement
         Gas costs: 4
         Source: "bet()"
        FunctionCall
           Type: tuple()
           Source: "bet()"
          Identifier bet
             Type: function ()
             Source: "bet"
  FunctionDefinition "bet" - public
     Source: "function bet()\r\n        payable\r\n        onlyIfNotStopped {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BLY3bF2NWtUYMqKj+13fIJ+rR4IzmlNAP9UM1nmbCiivwFXmm3lU86zjsIldadlHwkH9H8ephiQ/FNgEraMknyVhlceoT1WgJv3h1iP87fRK34yqARHV8p/qKoYG1RE1lJ6IKI1oUvDqCfllxkf+u9vvWN188fs=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyIfNotStopped"
       Gas costs: 0
       Source: "onlyIfNotStopped"
      Identifier onlyIfNotStopped
         Type: modifier ()
         Source: "onlyIfNotStopped"
    Block
       Source: "{\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BLY3bF2NWtUYMqKj+13fIJ+rR4IzmlNAP9UM1nmbCiivwFXmm3lU86zjsIldadlHwkH9H8ephiQ/FNgEraMknyVhlceoT1WgJv3h1iP87fRK34yqARHV8p/qKoYG1RE1lJ6IKI1oUvDqCfllxkf+u9vvWN188fs=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas)"
        VariableDeclaration "oraclizeFee"
           Type: uint256
           Source: "uint oraclizeFee"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas)"
          MemberAccess to member getPrice
             Type: function (string memory,uint256) external returns (uint256)
             Source: "OraclizeI(OAR.getAddress()).getPrice"
            FunctionCall
               Type: contract OraclizeI
               Source: "OraclizeI(OAR.getAddress())"
              Identifier OraclizeI
                 Type: type(contract OraclizeI)
                 Source: "OraclizeI"
              FunctionCall
                 Type: address
                 Source: "OAR.getAddress()"
                MemberAccess to member getAddress
                   Type: function () external returns (address)
                   Source: "OAR.getAddress"
                  Identifier OAR
                     Type: contract OraclizeAddrResolverI
                     Source: "OAR"
          Literal, token: [no token] value: URL
             Type: literal_string "URL"
             Source: "\"URL\""
          BinaryOperation using operator +
             Type: uint256
             Source: "ORACLIZE_GAS_LIMIT + safeGas"
            Identifier ORACLIZE_GAS_LIMIT
               Type: uint256
               Source: "ORACLIZE_GAS_LIMIT"
            Identifier safeGas
               Type: uint256
               Source: "safeGas"
      IfStatement
         Source: "if (oraclizeFee >= msg.value) throw"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 11
           Source: "oraclizeFee >= msg.value"
          Identifier oraclizeFee
             Type: uint256
             Source: "oraclizeFee"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
        Throw
           Gas costs: 6
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 16
         Source: "uint betValue = msg.value - oraclizeFee"
        VariableDeclaration "betValue"
           Type: uint256
           Source: "uint betValue"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator -
           Type: uint256
           Source: "msg.value - oraclizeFee"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier oraclizeFee
             Type: uint256
             Source: "oraclizeFee"
      IfStatement
         Source: "if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BLY3bF2NWtUYMqKj+13fIJ+rR4IzmlNAP9UM1nmbCiivwFXmm3lU86zjsIldadlHwkH9H8ephiQ/FNgEraMknyVhlceoT1WgJv3h1iP87fRK34yqARHV8p/qKoYG1RE1lJ6IKI1oUvDqCfllxkf+u9vvWN188fs=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 133
           Source: "(((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)"
          TupleExpression
             Type: bool
             Source: "(((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)"
            BinaryOperation using operator <=
               Type: bool
               Source: "((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000"
              TupleExpression
                 Type: uint256
                 Source: "((betValue * ((10000 - edge) - pwin)) / pwin )"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "(betValue * ((10000 - edge) - pwin)) / pwin"
                  TupleExpression
                     Type: uint256
                     Source: "(betValue * ((10000 - edge) - pwin))"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "betValue * ((10000 - edge) - pwin)"
                      Identifier betValue
                         Type: uint256
                         Source: "betValue"
                      TupleExpression
                         Type: uint256
                         Source: "((10000 - edge) - pwin)"
                        BinaryOperation using operator -
                           Type: uint256
                           Source: "(10000 - edge) - pwin"
                          TupleExpression
                             Type: uint256
                             Source: "(10000 - edge)"
                            BinaryOperation using operator -
                               Type: uint256
                               Source: "10000 - edge"
                              Literal, token: [no token] value: 10000
                                 Type: int_const 10000
                                 Source: "10000"
                              Identifier edge
                                 Type: uint256
                                 Source: "edge"
                          Identifier pwin
                             Type: uint256
                             Source: "pwin"
                  Identifier pwin
                     Type: uint256
                     Source: "pwin"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "(maxWin * getBankroll()) / 10000"
                TupleExpression
                   Type: uint256
                   Source: "(maxWin * getBankroll())"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "maxWin * getBankroll()"
                    Identifier maxWin
                       Type: uint256
                       Source: "maxWin"
                    FunctionCall
                       Type: uint256
                       Source: "getBankroll()"
                      Identifier getBankroll
                         Type: function () view returns (uint256)
                         Source: "getBankroll"
                Literal, token: [no token] value: 10000
                   Type: int_const 10000
                   Source: "10000"
          TupleExpression
             Type: bool
             Source: "(betValue >= minBet)"
            BinaryOperation using operator >=
               Type: bool
               Source: "betValue >= minBet"
              Identifier betValue
                 Type: uint256
                 Source: "betValue"
              Identifier minBet
                 Type: uint256
                 Source: "minBet"
        Block
           Source: "{\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BLY3bF2NWtUYMqKj+13fIJ+rR4IzmlNAP9UM1nmbCiivwFXmm3lU86zjsIldadlHwkH9H8ephiQ/FNgEraMknyVhlceoT1WgJv3h1iP87fRK34yqARHV8p/qKoYG1RE1lJ6IKI1oUvDqCfllxkf+u9vvWN188fs=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "LOG_NewBet(msg.sender, betValue)"
            FunctionCall
               Type: tuple()
               Source: "LOG_NewBet(msg.sender, betValue)"
              Identifier LOG_NewBet
                 Type: function (address,uint256)
                 Source: "LOG_NewBet"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier betValue
                 Type: uint256
                 Source: "betValue"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BLY3bF2NWtUYMqKj+13fIJ+rR4IzmlNAP9UM1nmbCiivwFXmm3lU86zjsIldadlHwkH9H8ephiQ/FNgEraMknyVhlceoT1WgJv3h1iP87fRK34yqARHV8p/qKoYG1RE1lJ6IKI1oUvDqCfllxkf+u9vvWN188fs=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                )"
            VariableDeclaration "myid"
               Type: bytes32
               Source: "bytes32 myid"
              ElementaryTypeName bytes32
                 Source: "bytes32"
            FunctionCall
               Type: bytes32
               Source: "oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BLY3bF2NWtUYMqKj+13fIJ+rR4IzmlNAP9UM1nmbCiivwFXmm3lU86zjsIldadlHwkH9H8ephiQ/FNgEraMknyVhlceoT1WgJv3h1iP87fRK34yqARHV8p/qKoYG1RE1lJ6IKI1oUvDqCfllxkf+u9vvWN188fs=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                )"
              Identifier oraclize_query
                 Type: function (string memory,string memory,uint256) returns (bytes32)
                 Source: "oraclize_query"
              Literal, token: [no token] value: nested
                 Type: literal_string "nested"
                 Source: "\"nested\""
              Literal, token: [no token] value: [URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\n{"jsonrpc":"2.0","method":"generateSignedIntegers","params":{"apiKey":${[decrypt] BLY3bF2NWtUYMqKj+13fIJ+rR4IzmlNAP9UM1nmbCiivwFXmm3lU86zjsIldadlHwkH9H8ephiQ/FNgEraMknyVhlceoT1WgJv3h1iP87fRK34yqARHV8p/qKoYG1RE1lJ6IKI1oUvDqCfllxkf+u9vvWN188fs=},"n":1,"min":1,"max":10000${[identity] "}"},"id":1${[identity] "}"}']
                 Type: literal_string "[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\n{"jsonrpc":"2.0","method":"generateSignedIntegers","params":{"apiKey":${[decrypt] BLY3bF2NWtUYMqKj+13fIJ+rR4IzmlNAP9UM1nmbCiivwFXmm3lU86zjsIldadlHwkH9H8ephiQ/FNgEraMknyVhlceoT1WgJv3h1iP87fRK34yqARHV8p/qKoYG1RE1lJ6IKI1oUvDqCfllxkf+u9vvWN188fs=},"n":1,"min":1,"max":10000${[identity] "}"},"id":1${[identity] "}"}']"
                 Source: "\"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BLY3bF2NWtUYMqKj+13fIJ+rR4IzmlNAP9UM1nmbCiivwFXmm3lU86zjsIldadlHwkH9H8ephiQ/FNgEraMknyVhlceoT1WgJv3h1iP87fRK34yqARHV8p/qKoYG1RE1lJ6IKI1oUvDqCfllxkf+u9vvWN188fs=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\""
              BinaryOperation using operator +
                 Type: uint256
                 Source: "ORACLIZE_GAS_LIMIT + safeGas"
                Identifier ORACLIZE_GAS_LIMIT
                   Type: uint256
                   Source: "ORACLIZE_GAS_LIMIT"
                Identifier safeGas
                   Type: uint256
                   Source: "safeGas"
          ExpressionStatement
             Gas costs: [???]
             Source: "bets[myid] = Bet(msg.sender, betValue, 0)"
            Assignment using operator =
               Type: struct Dice.Bet storage ref
               Source: "bets[myid] = Bet(msg.sender, betValue, 0)"
              IndexAccess
                 Type: struct Dice.Bet storage ref
                 Source: "bets[myid]"
                Identifier bets
                   Type: mapping(bytes32 => struct Dice.Bet storage ref)
                   Source: "bets"
                Identifier myid
                   Type: bytes32
                   Source: "myid"
              FunctionCall
                 Type: struct Dice.Bet memory
                 Source: "Bet(msg.sender, betValue, 0)"
                Identifier Bet
                   Type: type(struct Dice.Bet storage pointer)
                   Source: "Bet"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Identifier betValue
                   Type: uint256
                   Source: "betValue"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
          ExpressionStatement
             Gas costs: 20121
             Source: "betsKeys.push(myid)"
            FunctionCall
               Type: uint256
               Source: "betsKeys.push(myid)"
              MemberAccess to member push
                 Type: function (bytes32) returns (uint256)
                 Source: "betsKeys.push"
                Identifier betsKeys
                   Type: bytes32[] storage ref
                   Source: "betsKeys"
              Identifier myid
                 Type: bytes32
                 Source: "myid"
        Block
           Source: "{\r\n            throw;\r\n        }"
          Throw
             Gas costs: 6
             Source: "throw"
  FunctionDefinition "__callback" - public
     Source: "function __callback(bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfBetExist(myid)\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 myid, string result, bytes proof)"
      VariableDeclaration "myid"
         Type: bytes32
         Source: "bytes32 myid"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "result"
         Type: string memory
         Source: "string result"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "proof"
         Type: bytes memory
         Source: "bytes proof"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOraclize"
       Gas costs: 0
       Source: "onlyOraclize"
      Identifier onlyOraclize
         Type: modifier ()
         Source: "onlyOraclize"
    ModifierInvocation "onlyIfBetExist"
       Gas costs: 3
       Source: "onlyIfBetExist(myid)"
      Identifier onlyIfBetExist
         Type: modifier (bytes32)
         Source: "onlyIfBetExist"
      Identifier myid
         Type: bytes32
         Source: "myid"
    ModifierInvocation "onlyIfNotProcessed"
       Gas costs: 3
       Source: "onlyIfNotProcessed(myid)"
      Identifier onlyIfNotProcessed
         Type: modifier (bytes32)
         Source: "onlyIfNotProcessed"
      Identifier myid
         Type: bytes32
         Source: "myid"
    ModifierInvocation "onlyIfValidRoll"
       Gas costs: 6
       Source: "onlyIfValidRoll(myid, result)"
      Identifier onlyIfValidRoll
         Type: modifier (bytes32,string memory)
         Source: "onlyIfValidRoll"
      Identifier myid
         Type: bytes32
         Source: "myid"
      Identifier result
         Type: string memory
         Source: "result"
    ModifierInvocation "onlyIfBetSizeIsStillCorrect"
       Gas costs: 3
       Source: "onlyIfBetSizeIsStillCorrect(myid)"
      Identifier onlyIfBetSizeIsStillCorrect
         Type: modifier (bytes32)
         Source: "onlyIfBetSizeIsStillCorrect"
      Identifier myid
         Type: bytes32
         Source: "myid"
    Block
       Source: "{\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint numberRolled = parseInt(result)"
        VariableDeclaration "numberRolled"
           Type: uint256
           Source: "uint numberRolled"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "parseInt(result)"
          Identifier parseInt
             Type: function (string memory) returns (uint256)
             Source: "parseInt"
          Identifier result
             Type: string memory
             Source: "result"
      ExpressionStatement
         Gas costs: 20122
         Source: "bets[myid].numberRolled = numberRolled"
        Assignment using operator =
           Type: uint256
           Source: "bets[myid].numberRolled = numberRolled"
          MemberAccess to member numberRolled
             Type: uint256
             Source: "bets[myid].numberRolled"
            IndexAccess
               Type: struct Dice.Bet storage ref
               Source: "bets[myid]"
              Identifier bets
                 Type: mapping(bytes32 => struct Dice.Bet storage ref)
                 Source: "bets"
              Identifier myid
                 Type: bytes32
                 Source: "myid"
          Identifier numberRolled
             Type: uint256
             Source: "numberRolled"
      ExpressionStatement
         Gas costs: [???]
         Source: "isWinningBet(bets[myid], numberRolled)"
        FunctionCall
           Type: tuple()
           Source: "isWinningBet(bets[myid], numberRolled)"
          Identifier isWinningBet
             Type: function (struct Dice.Bet memory,uint256)
             Source: "isWinningBet"
          IndexAccess
             Type: struct Dice.Bet storage ref
             Source: "bets[myid]"
            Identifier bets
               Type: mapping(bytes32 => struct Dice.Bet storage ref)
               Source: "bets"
            Identifier myid
               Type: bytes32
               Source: "myid"
          Identifier numberRolled
             Type: uint256
             Source: "numberRolled"
      ExpressionStatement
         Gas costs: [???]
         Source: "isLosingBet(bets[myid], numberRolled)"
        FunctionCall
           Type: tuple()
           Source: "isLosingBet(bets[myid], numberRolled)"
          Identifier isLosingBet
             Type: function (struct Dice.Bet memory,uint256)
             Source: "isLosingBet"
          IndexAccess
             Type: struct Dice.Bet storage ref
             Source: "bets[myid]"
            Identifier bets
               Type: mapping(bytes32 => struct Dice.Bet storage ref)
               Source: "bets"
            Identifier myid
               Type: bytes32
               Source: "myid"
          Identifier numberRolled
             Type: uint256
             Source: "numberRolled"
      ExpressionStatement
         Gas costs: 20242
         Source: "delete profitDistributed"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete profitDistributed"
          Identifier profitDistributed
             Type: bool
             Source: "profitDistributed"
  FunctionDefinition "isWinningBet"
     Source: "function isWinningBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyWinningBets(numberRolled) {\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Bet thisBet, uint numberRolled)"
      VariableDeclaration "thisBet"
         Type: struct Dice.Bet memory
         Source: "Bet thisBet"
        UserDefinedTypeName "Bet"
           Source: "Bet"
      VariableDeclaration "numberRolled"
         Type: uint256
         Source: "uint numberRolled"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyWinningBets"
       Gas costs: 3
       Source: "onlyWinningBets(numberRolled)"
      Identifier onlyWinningBets
         Type: modifier (uint256)
         Source: "onlyWinningBets"
      Identifier numberRolled
         Type: uint256
         Source: "numberRolled"
    Block
       Source: "{\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin"
        VariableDeclaration "winAmount"
           Type: uint256
           Source: "uint winAmount"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "(thisBet.amountBet * (10000 - edge)) / pwin"
          TupleExpression
             Type: uint256
             Source: "(thisBet.amountBet * (10000 - edge))"
            BinaryOperation using operator *
               Type: uint256
               Source: "thisBet.amountBet * (10000 - edge)"
              MemberAccess to member amountBet
                 Type: uint256
                 Source: "thisBet.amountBet"
                Identifier thisBet
                   Type: struct Dice.Bet memory
                   Source: "thisBet"
              TupleExpression
                 Type: uint256
                 Source: "(10000 - edge)"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "10000 - edge"
                  Literal, token: [no token] value: 10000
                     Type: int_const 10000
                     Source: "10000"
                  Identifier edge
                     Type: uint256
                     Source: "edge"
          Identifier pwin
             Type: uint256
             Source: "pwin"
      ExpressionStatement
         Gas costs: [???]
         Source: "LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount)"
        FunctionCall
           Type: tuple()
           Source: "LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount)"
          Identifier LOG_BetWon
             Type: function (address,uint256,uint256)
             Source: "LOG_BetWon"
          MemberAccess to member playerAddress
             Type: address
             Source: "thisBet.playerAddress"
            Identifier thisBet
               Type: struct Dice.Bet memory
               Source: "thisBet"
          Identifier numberRolled
             Type: uint256
             Source: "numberRolled"
          Identifier winAmount
             Type: uint256
             Source: "winAmount"
      ExpressionStatement
         Gas costs: [???]
         Source: "safeSend(thisBet.playerAddress, winAmount)"
        FunctionCall
           Type: tuple()
           Source: "safeSend(thisBet.playerAddress, winAmount)"
          Identifier safeSend
             Type: function (address,uint256)
             Source: "safeSend"
          MemberAccess to member playerAddress
             Type: address
             Source: "thisBet.playerAddress"
            Identifier thisBet
               Type: struct Dice.Bet memory
               Source: "thisBet"
          Identifier winAmount
             Type: uint256
             Source: "winAmount"
      IfStatement
         Source: "if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: [???]
           Source: "(investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)"
          TupleExpression
             Type: bool
             Source: "(investorsLosses + winAmount < investorsLosses)"
            BinaryOperation using operator <
               Type: bool
               Source: "investorsLosses + winAmount < investorsLosses"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "investorsLosses + winAmount"
                Identifier investorsLosses
                   Type: uint256
                   Source: "investorsLosses"
                Identifier winAmount
                   Type: uint256
                   Source: "winAmount"
              Identifier investorsLosses
                 Type: uint256
                 Source: "investorsLosses"
          TupleExpression
             Type: bool
             Source: "(investorsLosses + winAmount < thisBet.amountBet)"
            BinaryOperation using operator <
               Type: bool
               Source: "investorsLosses + winAmount < thisBet.amountBet"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "investorsLosses + winAmount"
                Identifier investorsLosses
                   Type: uint256
                   Source: "investorsLosses"
                Identifier winAmount
                   Type: uint256
                   Source: "winAmount"
              MemberAccess to member amountBet
                 Type: uint256
                 Source: "thisBet.amountBet"
                Identifier thisBet
                   Type: struct Dice.Bet memory
                   Source: "thisBet"
        Block
           Source: "{\r\n                throw;\r\n            }"
          Throw
             Gas costs: 6
             Source: "throw"
      ExpressionStatement
         Gas costs: [???]
         Source: "investorsLosses += winAmount - thisBet.amountBet"
        Assignment using operator +=
           Type: uint256
           Source: "investorsLosses += winAmount - thisBet.amountBet"
          Identifier investorsLosses
             Type: uint256
             Source: "investorsLosses"
          BinaryOperation using operator -
             Type: uint256
             Source: "winAmount - thisBet.amountBet"
            Identifier winAmount
               Type: uint256
               Source: "winAmount"
            MemberAccess to member amountBet
               Type: uint256
               Source: "thisBet.amountBet"
              Identifier thisBet
                 Type: struct Dice.Bet memory
                 Source: "thisBet"
  FunctionDefinition "isLosingBet"
     Source: "function isLosingBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyLosingBets(numberRolled) {\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Bet thisBet, uint numberRolled)"
      VariableDeclaration "thisBet"
         Type: struct Dice.Bet memory
         Source: "Bet thisBet"
        UserDefinedTypeName "Bet"
           Source: "Bet"
      VariableDeclaration "numberRolled"
         Type: uint256
         Source: "uint numberRolled"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyLosingBets"
       Gas costs: 3
       Source: "onlyLosingBets(numberRolled)"
      Identifier onlyLosingBets
         Type: modifier (uint256)
         Source: "onlyLosingBets"
      Identifier numberRolled
         Type: uint256
         Source: "numberRolled"
    Block
       Source: "{\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "LOG_BetLost(thisBet.playerAddress, numberRolled)"
        FunctionCall
           Type: tuple()
           Source: "LOG_BetLost(thisBet.playerAddress, numberRolled)"
          Identifier LOG_BetLost
             Type: function (address,uint256)
             Source: "LOG_BetLost"
          MemberAccess to member playerAddress
             Type: address
             Source: "thisBet.playerAddress"
            Identifier thisBet
               Type: struct Dice.Bet memory
               Source: "thisBet"
          Identifier numberRolled
             Type: uint256
             Source: "numberRolled"
      ExpressionStatement
         Gas costs: [???]
         Source: "safeSend(thisBet.playerAddress, 1)"
        FunctionCall
           Type: tuple()
           Source: "safeSend(thisBet.playerAddress, 1)"
          Identifier safeSend
             Type: function (address,uint256)
             Source: "safeSend"
          MemberAccess to member playerAddress
             Type: address
             Source: "thisBet.playerAddress"
            Identifier thisBet
               Type: struct Dice.Bet memory
               Source: "thisBet"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      IfStatement
         Source: "if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: [???]
           Source: "(investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)"
          BinaryOperation using operator ||
             Type: bool
             Source: "(investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet)"
            TupleExpression
               Type: bool
               Source: "(investorsProfit + thisBet.amountBet < investorsProfit)"
              BinaryOperation using operator <
                 Type: bool
                 Source: "investorsProfit + thisBet.amountBet < investorsProfit"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "investorsProfit + thisBet.amountBet"
                  Identifier investorsProfit
                     Type: uint256
                     Source: "investorsProfit"
                  MemberAccess to member amountBet
                     Type: uint256
                     Source: "thisBet.amountBet"
                    Identifier thisBet
                       Type: struct Dice.Bet memory
                       Source: "thisBet"
                Identifier investorsProfit
                   Type: uint256
                   Source: "investorsProfit"
            TupleExpression
               Type: bool
               Source: "(investorsProfit + thisBet.amountBet < thisBet.amountBet)"
              BinaryOperation using operator <
                 Type: bool
                 Source: "investorsProfit + thisBet.amountBet < thisBet.amountBet"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "investorsProfit + thisBet.amountBet"
                  Identifier investorsProfit
                     Type: uint256
                     Source: "investorsProfit"
                  MemberAccess to member amountBet
                     Type: uint256
                     Source: "thisBet.amountBet"
                    Identifier thisBet
                       Type: struct Dice.Bet memory
                       Source: "thisBet"
                MemberAccess to member amountBet
                   Type: uint256
                   Source: "thisBet.amountBet"
                  Identifier thisBet
                     Type: struct Dice.Bet memory
                     Source: "thisBet"
          TupleExpression
             Type: bool
             Source: "(thisBet.amountBet == 1)"
            BinaryOperation using operator ==
               Type: bool
               Source: "thisBet.amountBet == 1"
              MemberAccess to member amountBet
                 Type: uint256
                 Source: "thisBet.amountBet"
                Identifier thisBet
                   Type: struct Dice.Bet memory
                   Source: "thisBet"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
        Block
           Source: "{\r\n                throw;\r\n            }"
          Throw
             Gas costs: 6
             Source: "throw"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint totalProfit = investorsProfit + (thisBet.amountBet - 1)"
        VariableDeclaration "totalProfit"
           Type: uint256
           Source: "uint totalProfit"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "investorsProfit + (thisBet.amountBet - 1)"
          Identifier investorsProfit
             Type: uint256
             Source: "investorsProfit"
          TupleExpression
             Type: uint256
             Source: "(thisBet.amountBet - 1)"
            BinaryOperation using operator -
               Type: uint256
               Source: "thisBet.amountBet - 1"
              MemberAccess to member amountBet
                 Type: uint256
                 Source: "thisBet.amountBet"
                Identifier thisBet
                   Type: struct Dice.Bet memory
                   Source: "thisBet"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      ExpressionStatement
         Gas costs: [???]
         Source: "investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000"
        Assignment using operator +=
           Type: uint256
           Source: "investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000"
          Identifier investorsProfit
             Type: uint256
             Source: "investorsProfit"
          BinaryOperation using operator /
             Type: uint256
             Source: "(thisBet.amountBet - 1)*(10000 - houseEdge)/10000"
            BinaryOperation using operator *
               Type: uint256
               Source: "(thisBet.amountBet - 1)*(10000 - houseEdge)"
              TupleExpression
                 Type: uint256
                 Source: "(thisBet.amountBet - 1)"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "thisBet.amountBet - 1"
                  MemberAccess to member amountBet
                     Type: uint256
                     Source: "thisBet.amountBet"
                    Identifier thisBet
                       Type: struct Dice.Bet memory
                       Source: "thisBet"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              TupleExpression
                 Type: uint256
                 Source: "(10000 - houseEdge)"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "10000 - houseEdge"
                  Literal, token: [no token] value: 10000
                     Type: int_const 10000
                     Source: "10000"
                  Identifier houseEdge
                     Type: uint256
                     Source: "houseEdge"
            Literal, token: [no token] value: 10000
               Type: int_const 10000
               Source: "10000"
      VariableDeclarationStatement
         Gas costs: 217
         Source: "uint houseProfit = totalProfit - investorsProfit"
        VariableDeclaration "houseProfit"
           Type: uint256
           Source: "uint houseProfit"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator -
           Type: uint256
           Source: "totalProfit - investorsProfit"
          Identifier totalProfit
             Type: uint256
             Source: "totalProfit"
          Identifier investorsProfit
             Type: uint256
             Source: "investorsProfit"
      ExpressionStatement
         Gas costs: 257
         Source: "safeSend(houseAddress, houseProfit)"
        FunctionCall
           Type: tuple()
           Source: "safeSend(houseAddress, houseProfit)"
          Identifier safeSend
             Type: function (address,uint256)
             Source: "safeSend"
          Identifier houseAddress
             Type: address
             Source: "houseAddress"
          Identifier houseProfit
             Type: uint256
             Source: "houseProfit"
  FunctionDefinition "increaseInvestment" - public
     Source: "function increaseInvestment()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyInvestors  {\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyIfNotStopped"
       Gas costs: 0
       Source: "onlyIfNotStopped"
      Identifier onlyIfNotStopped
         Type: modifier ()
         Source: "onlyIfNotStopped"
    ModifierInvocation "onlyMoreThanZero"
       Gas costs: 0
       Source: "onlyMoreThanZero"
      Identifier onlyMoreThanZero
         Type: modifier ()
         Source: "onlyMoreThanZero"
    ModifierInvocation "onlyInvestors"
       Gas costs: 0
       Source: "onlyInvestors"
      Identifier onlyInvestors
         Type: modifier ()
         Source: "onlyInvestors"
    Block
       Source: "{\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }"
      ExpressionStatement
         Gas costs: 15
         Source: "profitDistribution()"
        FunctionCall
           Type: tuple()
           Source: "profitDistribution()"
          Identifier profitDistribution
             Type: function ()
             Source: "profitDistribution"
      ExpressionStatement
         Gas costs: 20611
         Source: "investors[investorIDs[msg.sender]].amountInvested += msg.value"
        Assignment using operator +=
           Type: uint256
           Source: "investors[investorIDs[msg.sender]].amountInvested += msg.value"
          MemberAccess to member amountInvested
             Type: uint256
             Source: "investors[investorIDs[msg.sender]].amountInvested"
            IndexAccess
               Type: struct Dice.Investor storage ref
               Source: "investors[investorIDs[msg.sender]]"
              Identifier investors
                 Type: mapping(uint256 => struct Dice.Investor storage ref)
                 Source: "investors"
              IndexAccess
                 Type: uint256
                 Source: "investorIDs[msg.sender]"
                Identifier investorIDs
                   Type: mapping(address => uint256)
                   Source: "investorIDs"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20232
         Source: "invested += msg.value"
        Assignment using operator +=
           Type: uint256
           Source: "invested += msg.value"
          Identifier invested
             Type: uint256
             Source: "invested"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "newInvestor" - public
     Source: "function newInvestor()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyIfNotStopped"
       Gas costs: 0
       Source: "onlyIfNotStopped"
      Identifier onlyIfNotStopped
         Type: modifier ()
         Source: "onlyIfNotStopped"
    ModifierInvocation "onlyMoreThanZero"
       Gas costs: 0
       Source: "onlyMoreThanZero"
      Identifier onlyMoreThanZero
         Type: modifier ()
         Source: "onlyMoreThanZero"
    ModifierInvocation "onlyNotInvestors"
       Gas costs: 0
       Source: "onlyNotInvestors"
      Identifier onlyNotInvestors
         Type: modifier ()
         Source: "onlyNotInvestors"
    ModifierInvocation "onlyMoreThanMinInvestment"
       Gas costs: 0
       Source: "onlyMoreThanMinInvestment"
      Identifier onlyMoreThanMinInvestment
         Type: modifier ()
         Source: "onlyMoreThanMinInvestment"
    ModifierInvocation "investorsInvariant"
       Gas costs: 0
       Source: "investorsInvariant"
      Identifier investorsInvariant
         Type: modifier ()
         Source: "investorsInvariant"
    Block
       Source: "{\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }"
      ExpressionStatement
         Gas costs: 15
         Source: "profitDistribution()"
        FunctionCall
           Type: tuple()
           Source: "profitDistribution()"
          Identifier profitDistribution
             Type: function ()
             Source: "profitDistribution"
      IfStatement
         Source: "if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 206
           Source: "numInvestors == maxInvestors"
          Identifier numInvestors
             Type: uint256
             Source: "numInvestors"
          Identifier maxInvestors
             Type: uint256
             Source: "maxInvestors"
        Block
           Source: "{\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }"
          VariableDeclarationStatement
             Gas costs: 23
             Source: "uint smallestInvestorID = searchSmallestInvestor()"
            VariableDeclaration "smallestInvestorID"
               Type: uint256
               Source: "uint smallestInvestorID"
              ElementaryTypeName uint
                 Source: "uint"
            FunctionCall
               Type: uint256
               Source: "searchSmallestInvestor()"
              Identifier searchSmallestInvestor
                 Type: function () view returns (uint256)
                 Source: "searchSmallestInvestor"
          ExpressionStatement
             Gas costs: 344
             Source: "divest(investors[smallestInvestorID].investorAddress)"
            FunctionCall
               Type: tuple()
               Source: "divest(investors[smallestInvestorID].investorAddress)"
              Identifier divest
                 Type: function (address)
                 Source: "divest"
              MemberAccess to member investorAddress
                 Type: address
                 Source: "investors[smallestInvestorID].investorAddress"
                IndexAccess
                   Type: struct Dice.Investor storage ref
                   Source: "investors[smallestInvestorID]"
                  Identifier investors
                     Type: mapping(uint256 => struct Dice.Investor storage ref)
                     Source: "investors"
                  Identifier smallestInvestorID
                     Type: uint256
                     Source: "smallestInvestorID"
      ExpressionStatement
         Gas costs: 20237
         Source: "numInvestors++"
        UnaryOperation (postfix) ++
           Type: uint256
           Source: "numInvestors++"
          Identifier numInvestors
             Type: uint256
             Source: "numInvestors"
      ExpressionStatement
         Gas costs: 207
         Source: "addInvestorAtID(numInvestors)"
        FunctionCall
           Type: tuple()
           Source: "addInvestorAtID(numInvestors)"
          Identifier addInvestorAtID
             Type: function (uint256)
             Source: "addInvestorAtID"
          Identifier numInvestors
             Type: uint256
             Source: "numInvestors"
  FunctionDefinition "divest" - public
     Source: "function divest()\r\n        onlyInvestors {\r\n\r\n        divest(msg.sender);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyInvestors"
       Gas costs: 0
       Source: "onlyInvestors"
      Identifier onlyInvestors
         Type: modifier ()
         Source: "onlyInvestors"
    Block
       Source: "{\r\n\r\n        divest(msg.sender);\r\n    }"
      ExpressionStatement
         Gas costs: 6
         Source: "divest(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "divest(msg.sender)"
          Identifier divest
             Type: function (address)
             Source: "divest"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "divest"
     Source: "function divest(address currentInvestor)\r\n        private\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address currentInvestor)"
      VariableDeclaration "currentInvestor"
         Type: address
         Source: "address currentInvestor"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "investorsInvariant"
       Gas costs: 0
       Source: "investorsInvariant"
      Identifier investorsInvariant
         Type: modifier ()
         Source: "investorsInvariant"
    Block
       Source: "{\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 4
         Source: "profitDistribution()"
        FunctionCall
           Type: tuple()
           Source: "profitDistribution()"
          Identifier profitDistribution
             Type: function ()
             Source: "profitDistribution"
      VariableDeclarationStatement
         Gas costs: 307
         Source: "uint currentID = investorIDs[currentInvestor]"
        VariableDeclaration "currentID"
           Type: uint256
           Source: "uint currentID"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "investorIDs[currentInvestor]"
          Identifier investorIDs
             Type: mapping(address => uint256)
             Source: "investorIDs"
          Identifier currentInvestor
             Type: address
             Source: "currentInvestor"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint amountToReturn = getBalance(currentInvestor)"
        VariableDeclaration "amountToReturn"
           Type: uint256
           Source: "uint amountToReturn"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getBalance(currentInvestor)"
          Identifier getBalance
             Type: function (address) view returns (uint256)
             Source: "getBalance"
          Identifier currentInvestor
             Type: address
             Source: "currentInvestor"
      IfStatement
         Source: "if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }"
        TupleExpression
           Type: bool
           Gas costs: 502
           Source: "(invested >= investors[currentID].amountInvested)"
          BinaryOperation using operator >=
             Type: bool
             Source: "invested >= investors[currentID].amountInvested"
            Identifier invested
               Type: uint256
               Source: "invested"
            MemberAccess to member amountInvested
               Type: uint256
               Source: "investors[currentID].amountInvested"
              IndexAccess
                 Type: struct Dice.Investor storage ref
                 Source: "investors[currentID]"
                Identifier investors
                   Type: mapping(uint256 => struct Dice.Investor storage ref)
                   Source: "investors"
                Identifier currentID
                   Type: uint256
                   Source: "currentID"
        Block
           Source: "{\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        }"
          ExpressionStatement
             Gas costs: 20523
             Source: "invested -= investors[currentID].amountInvested"
            Assignment using operator -=
               Type: uint256
               Source: "invested -= investors[currentID].amountInvested"
              Identifier invested
                 Type: uint256
                 Source: "invested"
              MemberAccess to member amountInvested
                 Type: uint256
                 Source: "investors[currentID].amountInvested"
                IndexAccess
                   Type: struct Dice.Investor storage ref
                   Source: "investors[currentID]"
                  Identifier investors
                     Type: mapping(uint256 => struct Dice.Investor storage ref)
                     Source: "investors"
                  Identifier currentID
                     Type: uint256
                     Source: "currentID"
          VariableDeclarationStatement
             Gas costs: 47
             Source: "uint divestFeeAmount =  (amountToReturn*divestFee)/10000"
            VariableDeclaration "divestFeeAmount"
               Type: uint256
               Source: "uint divestFeeAmount"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator /
               Type: uint256
               Source: "(amountToReturn*divestFee)/10000"
              TupleExpression
                 Type: uint256
                 Source: "(amountToReturn*divestFee)"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "amountToReturn*divestFee"
                  Identifier amountToReturn
                     Type: uint256
                     Source: "amountToReturn"
                  Identifier divestFee
                     Type: uint256
                     Source: "divestFee"
              Literal, token: [no token] value: 10000
                 Type: int_const 10000
                 Source: "10000"
          ExpressionStatement
             Gas costs: 14
             Source: "amountToReturn -= divestFeeAmount"
            Assignment using operator -=
               Type: uint256
               Source: "amountToReturn -= divestFeeAmount"
              Identifier amountToReturn
                 Type: uint256
                 Source: "amountToReturn"
              Identifier divestFeeAmount
                 Type: uint256
                 Source: "divestFeeAmount"
          ExpressionStatement
             Gas costs: 45605
             Source: "delete investors[currentID]"
            UnaryOperation (prefix) delete
               Type: tuple()
               Source: "delete investors[currentID]"
              IndexAccess
                 Type: struct Dice.Investor storage ref
                 Source: "investors[currentID]"
                Identifier investors
                   Type: mapping(uint256 => struct Dice.Investor storage ref)
                   Source: "investors"
                Identifier currentID
                   Type: uint256
                   Source: "currentID"
          ExpressionStatement
             Gas costs: 5099
             Source: "delete investorIDs[currentInvestor]"
            UnaryOperation (prefix) delete
               Type: tuple()
               Source: "delete investorIDs[currentInvestor]"
              IndexAccess
                 Type: uint256
                 Source: "investorIDs[currentInvestor]"
                Identifier investorIDs
                   Type: mapping(address => uint256)
                   Source: "investorIDs"
                Identifier currentInvestor
                   Type: address
                   Source: "currentInvestor"
          IfStatement
             Source: "if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }"
            BinaryOperation using operator !=
               Type: bool
               Gas costs: 212
               Source: "currentID != numInvestors"
              Identifier currentID
                 Type: uint256
                 Source: "currentID"
              Identifier numInvestors
                 Type: uint256
                 Source: "numInvestors"
            Block
               Source: "{\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }"
              VariableDeclarationStatement
                 Gas costs: 295
                 Source: "Investor lastInvestor = investors[numInvestors]"
                VariableDeclaration "lastInvestor"
                   Type: struct Dice.Investor storage pointer
                   Source: "Investor lastInvestor"
                  UserDefinedTypeName "Investor"
                     Source: "Investor"
                IndexAccess
                   Type: struct Dice.Investor storage ref
                   Source: "investors[numInvestors]"
                  Identifier investors
                     Type: mapping(uint256 => struct Dice.Investor storage ref)
                     Source: "investors"
                  Identifier numInvestors
                     Type: uint256
                     Source: "numInvestors"
              ExpressionStatement
                 Gas costs: 20346
                 Source: "investorIDs[lastInvestor.investorAddress] = currentID"
                Assignment using operator =
                   Type: uint256
                   Source: "investorIDs[lastInvestor.investorAddress] = currentID"
                  IndexAccess
                     Type: uint256
                     Source: "investorIDs[lastInvestor.investorAddress]"
                    Identifier investorIDs
                       Type: mapping(address => uint256)
                       Source: "investorIDs"
                    MemberAccess to member investorAddress
                       Type: address
                       Source: "lastInvestor.investorAddress"
                      Identifier lastInvestor
                         Type: struct Dice.Investor storage pointer
                         Source: "lastInvestor"
                  Identifier currentID
                     Type: uint256
                     Source: "currentID"
              ExpressionStatement
                 Gas costs: 61339
                 Source: "investors[currentID] = lastInvestor"
                Assignment using operator =
                   Type: struct Dice.Investor storage ref
                   Source: "investors[currentID] = lastInvestor"
                  IndexAccess
                     Type: struct Dice.Investor storage ref
                     Source: "investors[currentID]"
                    Identifier investors
                       Type: mapping(uint256 => struct Dice.Investor storage ref)
                       Source: "investors"
                    Identifier currentID
                       Type: uint256
                       Source: "currentID"
                  Identifier lastInvestor
                     Type: struct Dice.Investor storage pointer
                     Source: "lastInvestor"
              ExpressionStatement
                 Gas costs: 45799
                 Source: "delete investors[numInvestors]"
                UnaryOperation (prefix) delete
                   Type: tuple()
                   Source: "delete investors[numInvestors]"
                  IndexAccess
                     Type: struct Dice.Investor storage ref
                     Source: "investors[numInvestors]"
                    Identifier investors
                       Type: mapping(uint256 => struct Dice.Investor storage ref)
                       Source: "investors"
                    Identifier numInvestors
                       Type: uint256
                       Source: "numInvestors"
          ExpressionStatement
             Gas costs: 20240
             Source: "numInvestors--"
            UnaryOperation (postfix) --
               Type: uint256
               Source: "numInvestors--"
              Identifier numInvestors
                 Type: uint256
                 Source: "numInvestors"
          ExpressionStatement
             Gas costs: 21
             Source: "safeSend(currentInvestor, amountToReturn)"
            FunctionCall
               Type: tuple()
               Source: "safeSend(currentInvestor, amountToReturn)"
              Identifier safeSend
                 Type: function (address,uint256)
                 Source: "safeSend"
              Identifier currentInvestor
                 Type: address
                 Source: "currentInvestor"
              Identifier amountToReturn
                 Type: uint256
                 Source: "amountToReturn"
          ExpressionStatement
             Gas costs: 257
             Source: "safeSend(houseAddress, divestFeeAmount)"
            FunctionCall
               Type: tuple()
               Source: "safeSend(houseAddress, divestFeeAmount)"
              Identifier safeSend
                 Type: function (address,uint256)
                 Source: "safeSend"
              Identifier houseAddress
                 Type: address
                 Source: "houseAddress"
              Identifier divestFeeAmount
                 Type: uint256
                 Source: "divestFeeAmount"
          ExpressionStatement
             Gas costs: [???]
             Source: "LOG_InvestorExit(currentInvestor, amountToReturn)"
            FunctionCall
               Type: tuple()
               Source: "LOG_InvestorExit(currentInvestor, amountToReturn)"
              Identifier LOG_InvestorExit
                 Type: function (address,uint256)
                 Source: "LOG_InvestorExit"
              Identifier currentInvestor
                 Type: address
                 Source: "currentInvestor"
              Identifier amountToReturn
                 Type: uint256
                 Source: "amountToReturn"
        Block
           Source: "{\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }"
          ExpressionStatement
             Gas costs: 20317
             Source: "isStopped = true"
            Assignment using operator =
               Type: bool
               Source: "isStopped = true"
              Identifier isStopped
                 Type: bool
                 Source: "isStopped"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
          ExpressionStatement
             Gas costs: 786
             Source: "LOG_EmergencyAutoStop()"
            FunctionCall
               Type: tuple()
               Source: "LOG_EmergencyAutoStop()"
              Identifier LOG_EmergencyAutoStop
                 Type: function ()
                 Source: "LOG_EmergencyAutoStop"
  FunctionDefinition "forceDivestOfAllInvestors" - public
     Source: "function forceDivestOfAllInvestors()\r\n        onlyOwner {\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 211
         Source: "uint copyNumInvestors = numInvestors"
        VariableDeclaration "copyNumInvestors"
           Type: uint256
           Source: "uint copyNumInvestors"
          ElementaryTypeName uint
             Source: "uint"
        Identifier numInvestors
           Type: uint256
           Source: "numInvestors"
      ForStatement
         Source: "for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 1"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 12
           Source: "i <= copyNumInvestors"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier copyNumInvestors
             Type: uint256
             Source: "copyNumInvestors"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            divest(investors[1].investorAddress);\r\n        }"
          ExpressionStatement
             Gas costs: 344
             Source: "divest(investors[1].investorAddress)"
            FunctionCall
               Type: tuple()
               Source: "divest(investors[1].investorAddress)"
              Identifier divest
                 Type: function (address)
                 Source: "divest"
              MemberAccess to member investorAddress
                 Type: address
                 Source: "investors[1].investorAddress"
                IndexAccess
                   Type: struct Dice.Investor storage ref
                   Source: "investors[1]"
                  Identifier investors
                     Type: mapping(uint256 => struct Dice.Investor storage ref)
                     Source: "investors"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
  FunctionDefinition "forceDivestOfOneInvestor" - public
     Source: "function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address currentInvestor)"
      VariableDeclaration "currentInvestor"
         Type: address
         Source: "address currentInvestor"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "onlyIfStopped"
       Gas costs: 0
       Source: "onlyIfStopped"
      Identifier onlyIfStopped
         Type: modifier ()
         Source: "onlyIfStopped"
    Block
       Source: "{\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }"
      ExpressionStatement
         Gas costs: 18
         Source: "divest(currentInvestor)"
        FunctionCall
           Type: tuple()
           Source: "divest(currentInvestor)"
          Identifier divest
             Type: function (address)
             Source: "divest"
          Identifier currentInvestor
             Type: address
             Source: "currentInvestor"
      ExpressionStatement
         Gas costs: 25273
         Source: "delete proposedWithdrawal"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete proposedWithdrawal"
          Identifier proposedWithdrawal
             Type: struct Dice.WithdrawalProposal storage ref
             Source: "proposedWithdrawal"
  FunctionDefinition "stopContract" - public
     Source: "function stopContract()\r\n        onlyOwner {\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }"
      ExpressionStatement
         Gas costs: 20317
         Source: "isStopped = true"
        Assignment using operator =
           Type: bool
           Source: "isStopped = true"
          Identifier isStopped
             Type: bool
             Source: "isStopped"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 786
         Source: "LOG_ContractStopped()"
        FunctionCall
           Type: tuple()
           Source: "LOG_ContractStopped()"
          Identifier LOG_ContractStopped
             Type: function ()
             Source: "LOG_ContractStopped"
  FunctionDefinition "resumeContract" - public
     Source: "function resumeContract()\r\n        onlyOwner {\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }"
      ExpressionStatement
         Gas costs: 20317
         Source: "isStopped = false"
        Assignment using operator =
           Type: bool
           Source: "isStopped = false"
          Identifier isStopped
             Type: bool
             Source: "isStopped"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 786
         Source: "LOG_ContractResumed()"
        FunctionCall
           Type: tuple()
           Source: "LOG_ContractResumed()"
          Identifier LOG_ContractResumed
             Type: function ()
             Source: "LOG_ContractResumed"
  FunctionDefinition "changeHouseAddress" - public
     Source: "function changeHouseAddress(address newHouse)\r\n        onlyOwner {\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address newHouse)"
      VariableDeclaration "newHouse"
         Type: address
         Source: "address newHouse"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }"
      IfStatement
         Source: "if (newHouse == address(0x0)) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 21
           Source: "newHouse == address(0x0)"
          Identifier newHouse
             Type: address
             Source: "newHouse"
          FunctionCall
             Type: address
             Source: "address(0x0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20267
         Source: "houseAddress = newHouse"
        Assignment using operator =
           Type: address
           Source: "houseAddress = newHouse"
          Identifier houseAddress
             Type: address
             Source: "houseAddress"
          Identifier newHouse
             Type: address
             Source: "newHouse"
      ExpressionStatement
         Gas costs: [???]
         Source: "LOG_HouseAddressChanged(houseAddress, newHouse)"
        FunctionCall
           Type: tuple()
           Source: "LOG_HouseAddressChanged(houseAddress, newHouse)"
          Identifier LOG_HouseAddressChanged
             Type: function (address,address)
             Source: "LOG_HouseAddressChanged"
          Identifier houseAddress
             Type: address
             Source: "houseAddress"
          Identifier newHouse
             Type: address
             Source: "newHouse"
  FunctionDefinition "changeOwnerAddress" - public
     Source: "function changeOwnerAddress(address newOwner)\r\n        onlyOwner {\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }"
      IfStatement
         Source: "if (newOwner == address(0x0)) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 21
           Source: "newOwner == address(0x0)"
          Identifier newOwner
             Type: address
             Source: "newOwner"
          FunctionCall
             Type: address
             Source: "address(0x0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
      ExpressionStatement
         Gas costs: [???]
         Source: "LOG_OwnerAddressChanged(owner, newOwner)"
        FunctionCall
           Type: tuple()
           Source: "LOG_OwnerAddressChanged(owner, newOwner)"
          Identifier LOG_OwnerAddressChanged
             Type: function (address,address)
             Source: "LOG_OwnerAddressChanged"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
  FunctionDefinition "changeGasLimitOfSafeSend" - public
     Source: "function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit) {\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint newGasLimit)"
      VariableDeclaration "newGasLimit"
         Type: uint256
         Source: "uint newGasLimit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "onlyIfValidGas"
       Gas costs: 3
       Source: "onlyIfValidGas(newGasLimit)"
      Identifier onlyIfValidGas
         Type: modifier (uint256)
         Source: "onlyIfValidGas"
      Identifier newGasLimit
         Type: uint256
         Source: "newGasLimit"
    Block
       Source: "{\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }"
      ExpressionStatement
         Gas costs: 20014
         Source: "safeGas = newGasLimit"
        Assignment using operator =
           Type: uint256
           Source: "safeGas = newGasLimit"
          Identifier safeGas
             Type: uint256
             Source: "safeGas"
          Identifier newGasLimit
             Type: uint256
             Source: "newGasLimit"
      ExpressionStatement
         Gas costs: [???]
         Source: "LOG_GasLimitChanged(safeGas, newGasLimit)"
        FunctionCall
           Type: tuple()
           Source: "LOG_GasLimitChanged(safeGas, newGasLimit)"
          Identifier LOG_GasLimitChanged
             Type: function (uint256,uint256)
             Source: "LOG_GasLimitChanged"
          Identifier safeGas
             Type: uint256
             Source: "safeGas"
          Identifier newGasLimit
             Type: uint256
             Source: "newGasLimit"
  FunctionDefinition "voteEmergencyWithdrawal" - public
     Source: "function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped {\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bool vote)"
      VariableDeclaration "vote"
         Type: bool
         Source: "bool vote"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyInvestors"
       Gas costs: 0
       Source: "onlyInvestors"
      Identifier onlyInvestors
         Type: modifier ()
         Source: "onlyInvestors"
    ModifierInvocation "onlyAfterProposed"
       Gas costs: 0
       Source: "onlyAfterProposed"
      Identifier onlyAfterProposed
         Type: modifier ()
         Source: "onlyAfterProposed"
    ModifierInvocation "onlyIfStopped"
       Gas costs: 0
       Source: "onlyIfStopped"
      Identifier onlyIfStopped
         Type: modifier ()
         Source: "onlyIfStopped"
    Block
       Source: "{\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }"
      ExpressionStatement
         Gas costs: 20646
         Source: "investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote"
        Assignment using operator =
           Type: bool
           Source: "investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote"
          MemberAccess to member votedForEmergencyWithdrawal
             Type: bool
             Source: "investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal"
            IndexAccess
               Type: struct Dice.Investor storage ref
               Source: "investors[investorIDs[msg.sender]]"
              Identifier investors
                 Type: mapping(uint256 => struct Dice.Investor storage ref)
                 Source: "investors"
              IndexAccess
                 Type: uint256
                 Source: "investorIDs[msg.sender]"
                Identifier investorIDs
                   Type: mapping(address => uint256)
                   Source: "investorIDs"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
          Identifier vote
             Type: bool
             Source: "vote"
      ExpressionStatement
         Gas costs: [???]
         Source: "LOG_EmergencyWithdrawalVote(msg.sender, vote)"
        FunctionCall
           Type: tuple()
           Source: "LOG_EmergencyWithdrawalVote(msg.sender, vote)"
          Identifier LOG_EmergencyWithdrawalVote
             Type: function (address,bool)
             Source: "LOG_EmergencyWithdrawalVote"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier vote
             Type: bool
             Source: "vote"
  FunctionDefinition "proposeEmergencyWithdrawal" - public
     Source: "function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address withdrawalAddress)"
      VariableDeclaration "withdrawalAddress"
         Type: address
         Source: "address withdrawalAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyIfStopped"
       Gas costs: 0
       Source: "onlyIfStopped"
      Identifier onlyIfStopped
         Type: modifier ()
         Source: "onlyIfStopped"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }"
      ForStatement
         Source: "for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 1"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 212
           Source: "i <= numInvestors"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier numInvestors
             Type: uint256
             Source: "numInvestors"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }"
          ExpressionStatement
             Gas costs: 20332
             Source: "delete investors[i].votedForEmergencyWithdrawal"
            UnaryOperation (prefix) delete
               Type: tuple()
               Source: "delete investors[i].votedForEmergencyWithdrawal"
              MemberAccess to member votedForEmergencyWithdrawal
                 Type: bool
                 Source: "investors[i].votedForEmergencyWithdrawal"
                IndexAccess
                   Type: struct Dice.Investor storage ref
                   Source: "investors[i]"
                  Identifier investors
                     Type: mapping(uint256 => struct Dice.Investor storage ref)
                     Source: "investors"
                  Identifier i
                     Type: uint256
                     Source: "i"
      ExpressionStatement
         Gas costs: [???]
         Source: "proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now)"
        Assignment using operator =
           Type: struct Dice.WithdrawalProposal storage ref
           Source: "proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now)"
          Identifier proposedWithdrawal
             Type: struct Dice.WithdrawalProposal storage ref
             Source: "proposedWithdrawal"
          FunctionCall
             Type: struct Dice.WithdrawalProposal memory
             Source: "WithdrawalProposal(withdrawalAddress, now)"
            Identifier WithdrawalProposal
               Type: type(struct Dice.WithdrawalProposal storage pointer)
               Source: "WithdrawalProposal"
            Identifier withdrawalAddress
               Type: address
               Source: "withdrawalAddress"
            Identifier now
               Type: uint256
               Source: "now"
      ExpressionStatement
         Gas costs: 777
         Source: "LOG_EmergencyWithdrawalProposed()"
        FunctionCall
           Type: tuple()
           Source: "LOG_EmergencyWithdrawalProposed()"
          Identifier LOG_EmergencyWithdrawalProposed
             Type: function ()
             Source: "LOG_EmergencyWithdrawalProposed"
  FunctionDefinition "executeEmergencyWithdrawal" - public
     Source: "function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "onlyAfterProposed"
       Gas costs: 0
       Source: "onlyAfterProposed"
      Identifier onlyAfterProposed
         Type: modifier ()
         Source: "onlyAfterProposed"
    ModifierInvocation "onlyIfStopped"
       Gas costs: 0
       Source: "onlyIfStopped"
      Identifier onlyIfStopped
         Type: modifier ()
         Source: "onlyIfStopped"
    ModifierInvocation "onlyIfEmergencyTimeOutHasPassed"
       Gas costs: 0
       Source: "onlyIfEmergencyTimeOutHasPassed"
      Identifier onlyIfEmergencyTimeOutHasPassed
         Type: modifier ()
         Source: "onlyIfEmergencyTimeOutHasPassed"
    Block
       Source: "{\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint numOfVotesInFavour"
        VariableDeclaration "numOfVotesInFavour"
           Type: uint256
           Source: "uint numOfVotesInFavour"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 416
         Source: "uint amountToWithdraw = this.balance"
        VariableDeclaration "amountToWithdraw"
           Type: uint256
           Source: "uint amountToWithdraw"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member balance
           Type: uint256
           Source: "this.balance"
          Identifier this
             Type: contract Dice
             Source: "this"
      ForStatement
         Source: "for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 1"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 212
           Source: "i <= numInvestors"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier numInvestors
             Type: uint256
             Source: "numInvestors"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }"
          IfStatement
             Source: "if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 347
               Source: "investors[i].votedForEmergencyWithdrawal == true"
              MemberAccess to member votedForEmergencyWithdrawal
                 Type: bool
                 Source: "investors[i].votedForEmergencyWithdrawal"
                IndexAccess
                   Type: struct Dice.Investor storage ref
                   Source: "investors[i]"
                  Identifier investors
                     Type: mapping(uint256 => struct Dice.Investor storage ref)
                     Source: "investors"
                  Identifier i
                     Type: uint256
                     Source: "i"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
            Block
               Source: "{\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }"
              ExpressionStatement
                 Gas costs: 19
                 Source: "numOfVotesInFavour++"
                UnaryOperation (postfix) ++
                   Type: uint256
                   Source: "numOfVotesInFavour++"
                  Identifier numOfVotesInFavour
                     Type: uint256
                     Source: "numOfVotesInFavour"
              ExpressionStatement
                 Gas costs: 20332
                 Source: "delete investors[i].votedForEmergencyWithdrawal"
                UnaryOperation (prefix) delete
                   Type: tuple()
                   Source: "delete investors[i].votedForEmergencyWithdrawal"
                  MemberAccess to member votedForEmergencyWithdrawal
                     Type: bool
                     Source: "investors[i].votedForEmergencyWithdrawal"
                    IndexAccess
                       Type: struct Dice.Investor storage ref
                       Source: "investors[i]"
                      Identifier investors
                         Type: mapping(uint256 => struct Dice.Investor storage ref)
                         Source: "investors"
                      Identifier i
                         Type: uint256
                         Source: "i"
      IfStatement
         Source: "if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 248
           Source: "numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100"
          Identifier numOfVotesInFavour
             Type: uint256
             Source: "numOfVotesInFavour"
          BinaryOperation using operator /
             Type: uint256
             Source: "emergencyWithdrawalRatio * numInvestors / 100"
            BinaryOperation using operator *
               Type: uint256
               Source: "emergencyWithdrawalRatio * numInvestors"
              Identifier emergencyWithdrawalRatio
                 Type: uint256
                 Source: "emergencyWithdrawalRatio"
              Identifier numInvestors
                 Type: uint256
                 Source: "numInvestors"
            Literal, token: [no token] value: 100
               Type: int_const 100
               Source: "100"
        Block
           Source: "{\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }"
          IfStatement
             Source: "if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: [???]
               Source: "!proposedWithdrawal.toAddress.send(amountToWithdraw)"
              FunctionCall
                 Type: bool
                 Source: "proposedWithdrawal.toAddress.send(amountToWithdraw)"
                MemberAccess to member send
                   Type: function (uint256) returns (bool)
                   Source: "proposedWithdrawal.toAddress.send"
                  MemberAccess to member toAddress
                     Type: address
                     Source: "proposedWithdrawal.toAddress"
                    Identifier proposedWithdrawal
                       Type: struct Dice.WithdrawalProposal storage ref
                       Source: "proposedWithdrawal"
                Identifier amountToWithdraw
                   Type: uint256
                   Source: "amountToWithdraw"
            Block
               Source: "{\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress)"
                FunctionCall
                   Type: tuple()
                   Source: "LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress)"
                  Identifier LOG_EmergencyWithdrawalFailed
                     Type: function (address)
                     Source: "LOG_EmergencyWithdrawalFailed"
                  MemberAccess to member toAddress
                     Type: address
                     Source: "proposedWithdrawal.toAddress"
                    Identifier proposedWithdrawal
                       Type: struct Dice.WithdrawalProposal storage ref
                       Source: "proposedWithdrawal"
            Block
               Source: "{\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw)"
                FunctionCall
                   Type: tuple()
                   Source: "LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw)"
                  Identifier LOG_EmergencyWithdrawalSucceeded
                     Type: function (address,uint256)
                     Source: "LOG_EmergencyWithdrawalSucceeded"
                  MemberAccess to member toAddress
                     Type: address
                     Source: "proposedWithdrawal.toAddress"
                    Identifier proposedWithdrawal
                       Type: struct Dice.WithdrawalProposal storage ref
                       Source: "proposedWithdrawal"
                  Identifier amountToWithdraw
                     Type: uint256
                     Source: "amountToWithdraw"
        Block
           Source: "{\r\n            throw;\r\n        }"
          Throw
             Gas costs: 6
             Source: "throw"
