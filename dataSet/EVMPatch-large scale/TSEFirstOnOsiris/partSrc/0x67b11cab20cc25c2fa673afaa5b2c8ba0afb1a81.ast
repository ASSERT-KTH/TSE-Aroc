Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x67b11cab20cc25c2fa673afaa5b2c8ba0afb1a81.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.13;"
ContractDefinition "MintableToken"
   Gas costs: 0
   Source: "contract MintableToken {\r\n    event Mint(address indexed to, uint256 amount);\r\n\r\n    /// @dev mints new tokens\r\n    function mint(address _to, uint256 _amount) public;\r\n}"
  EventDefinition "Mint"
     Source: "event Mint(address indexed to, uint256 amount);"
    ParameterList
       Source: "(address indexed to, uint256 amount)"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "mint" - public
     Source: "function mint(address _to, uint256 _amount) public;"
    ParameterList
       Source: "(address _to, uint256 _amount)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "mul"
     Source: "function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }"
      IfStatement
         Source: "if (a == 0) {\r\n      return 0;\r\n    }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "a == 0"
          Identifier a
             Type: uint256
             Source: "a"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n      return 0;\r\n    }"
          Return
             Gas costs: 0
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "c / a == b"
            BinaryOperation using operator /
               Type: uint256
               Source: "c / a"
              Identifier c
                 Type: uint256
                 Source: "c"
              Identifier a
                 Type: uint256
                 Source: "a"
            Identifier b
               Type: uint256
               Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div"
     Source: "function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub"
     Source: "function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add"
     Source: "function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "IApprovalRecipient"
   Gas costs: 0
   Source: "interface IApprovalRecipient {\r\n    /**\r\n     * @notice Signals that token holder approved spending of tokens and some action should be taken.\r\n     *\r\n     * @param _sender token holder which approved spending of his tokens\r\n     * @param _value amount of tokens approved to be spent\r\n     * @param _extraData any extra data token holder provided to the call\r\n     *\r\n     * @dev warning: implementors should validate sender of this message (it should be the token) and make no further\r\n     *      assumptions unless validated them via ERC20 methods.\r\n     */\r\n    function receiveApproval(address _sender, uint256 _value, bytes _extraData) public;\r\n}"
  FunctionDefinition "receiveApproval" - public
     Source: "function receiveApproval(address _sender, uint256 _value, bytes _extraData) public;"
    ParameterList
       Source: "(address _sender, uint256 _value, bytes _extraData)"
      VariableDeclaration "_sender"
         Type: address
         Source: "address _sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: ""
ContractDefinition "multiowned"
   Source: "contract multiowned {\r\n\r\n\t// TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct MultiOwnedOperationPendingState {\r\n        // count of confirmations needed\r\n        uint yetNeeded;\r\n\r\n        // bitmap of confirmations where owner #ownerIndex's decision corresponds to 2**ownerIndex bit\r\n        uint ownersDone;\r\n\r\n        // position of this operation key in m_multiOwnedPendingIndex\r\n        uint index;\r\n    }\r\n\r\n\t// EVENTS\r\n\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    event FinalConfirmation(address owner, bytes32 operation);\r\n\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n\t// MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        require(isOwner(msg.sender));\r\n        _;\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation)) {\r\n            _;\r\n        }\r\n        // Even if required number of confirmations has't been collected yet,\r\n        // we can't throw here - because changes to the state have to be preserved.\r\n        // But, confirmAndCheck itself will throw in case sender is not an owner.\r\n    }\r\n\r\n    modifier validNumOwners(uint _numOwners) {\r\n        require(_numOwners > 0 && _numOwners <= c_maxOwners);\r\n        _;\r\n    }\r\n\r\n    modifier multiOwnedValidRequirement(uint _required, uint _numOwners) {\r\n        require(_required > 0 && _required <= _numOwners);\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address _address) {\r\n        require(isOwner(_address));\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address _address) {\r\n        require(!isOwner(_address));\r\n        _;\r\n    }\r\n\r\n    modifier multiOwnedOperationIsActive(bytes32 _operation) {\r\n        require(isOperationActive(_operation));\r\n        _;\r\n    }\r\n\r\n\t// METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them (msg.sender is not added to the owners!).\r\n    function multiowned(address[] _owners, uint _required)\r\n        public\r\n        validNumOwners(_owners.length)\r\n        multiOwnedValidRequirement(_required, _owners.length)\r\n    {\r\n        assert(c_maxOwners <= 255);\r\n\r\n        m_numOwners = _owners.length;\r\n        m_multiOwnedRequired = _required;\r\n\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            address owner = _owners[i];\r\n            // invalid and duplicate addresses are not allowed\r\n            require(0 != owner && !isOwner(owner) /* not isOwner yet! */);\r\n\r\n            uint currentOwnerIndex = checkOwnerIndex(i + 1 /* first slot is unused */);\r\n            m_owners[currentOwnerIndex] = owner;\r\n            m_ownerIndex[owner] = currentOwnerIndex;\r\n        }\r\n\r\n        assertOwnersAreConsistent();\r\n    }\r\n\r\n    /// @notice replaces an owner `_from` with another `_to`.\r\n    /// @param _from address of owner to replace\r\n    /// @param _to address of new owner\r\n    // All pending operations will be canceled!\r\n    function changeOwner(address _from, address _to)\r\n        external\r\n        ownerExists(_from)\r\n        ownerDoesNotExist(_to)\r\n        onlymanyowners(keccak256(msg.data))\r\n    {\r\n        assertOwnersAreConsistent();\r\n\r\n        clearPending();\r\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[_from]);\r\n        m_owners[ownerIndex] = _to;\r\n        m_ownerIndex[_from] = 0;\r\n        m_ownerIndex[_to] = ownerIndex;\r\n\r\n        assertOwnersAreConsistent();\r\n        OwnerChanged(_from, _to);\r\n    }\r\n\r\n    /// @notice adds an owner\r\n    /// @param _owner address of new owner\r\n    // All pending operations will be canceled!\r\n    function addOwner(address _owner)\r\n        external\r\n        ownerDoesNotExist(_owner)\r\n        validNumOwners(m_numOwners + 1)\r\n        onlymanyowners(keccak256(msg.data))\r\n    {\r\n        assertOwnersAreConsistent();\r\n\r\n        clearPending();\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = _owner;\r\n        m_ownerIndex[_owner] = checkOwnerIndex(m_numOwners);\r\n\r\n        assertOwnersAreConsistent();\r\n        OwnerAdded(_owner);\r\n    }\r\n\r\n    /// @notice removes an owner\r\n    /// @param _owner address of owner to remove\r\n    // All pending operations will be canceled!\r\n    function removeOwner(address _owner)\r\n        external\r\n        ownerExists(_owner)\r\n        validNumOwners(m_numOwners - 1)\r\n        multiOwnedValidRequirement(m_multiOwnedRequired, m_numOwners - 1)\r\n        onlymanyowners(keccak256(msg.data))\r\n    {\r\n        assertOwnersAreConsistent();\r\n\r\n        clearPending();\r\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[_owner]);\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[_owner] = 0;\r\n        //make sure m_numOwners is equal to the number of owners and always points to the last owner\r\n        reorganizeOwners();\r\n\r\n        assertOwnersAreConsistent();\r\n        OwnerRemoved(_owner);\r\n    }\r\n\r\n    /// @notice changes the required number of owner signatures\r\n    /// @param _newRequired new number of signatures required\r\n    // All pending operations will be canceled!\r\n    function changeRequirement(uint _newRequired)\r\n        external\r\n        multiOwnedValidRequirement(_newRequired, m_numOwners)\r\n        onlymanyowners(keccak256(msg.data))\r\n    {\r\n        m_multiOwnedRequired = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n\r\n    /// @notice Gets an owner by 0-indexed position\r\n    /// @param ownerIndex 0-indexed owner position\r\n    function getOwner(uint ownerIndex) public constant returns (address) {\r\n        return m_owners[ownerIndex + 1];\r\n    }\r\n\r\n    /// @notice Gets owners\r\n    /// @return memory array of owners\r\n    function getOwners() public constant returns (address[]) {\r\n        address[] memory result = new address[](m_numOwners);\r\n        for (uint i = 0; i < m_numOwners; i++)\r\n            result[i] = getOwner(i);\r\n\r\n        return result;\r\n    }\r\n\r\n    /// @notice checks if provided address is an owner address\r\n    /// @param _addr address to check\r\n    /// @return true if it's an owner\r\n    function isOwner(address _addr) public constant returns (bool) {\r\n        return m_ownerIndex[_addr] > 0;\r\n    }\r\n\r\n    /// @notice Tests ownership of the current caller.\r\n    /// @return true if it's an owner\r\n    // It's advisable to call it by new owner to make sure that the same erroneous address is not copy-pasted to\r\n    // addOwner/changeOwner and to isOwner.\r\n    function amIOwner() external constant onlyowner returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /// @notice Revokes a prior confirmation of the given operation\r\n    /// @param _operation operation value, typically keccak256(msg.data)\r\n    function revoke(bytes32 _operation)\r\n        external\r\n        multiOwnedOperationIsActive(_operation)\r\n        onlyowner\r\n    {\r\n        uint ownerIndexBit = makeOwnerBitmapBit(msg.sender);\r\n        var pending = m_multiOwnedPending[_operation];\r\n        require(pending.ownersDone & ownerIndexBit > 0);\r\n\r\n        assertOperationIsConsistent(_operation);\r\n\r\n        pending.yetNeeded++;\r\n        pending.ownersDone -= ownerIndexBit;\r\n\r\n        assertOperationIsConsistent(_operation);\r\n        Revoke(msg.sender, _operation);\r\n    }\r\n\r\n    /// @notice Checks if owner confirmed given operation\r\n    /// @param _operation operation value, typically keccak256(msg.data)\r\n    /// @param _owner an owner address\r\n    function hasConfirmed(bytes32 _operation, address _owner)\r\n        external\r\n        constant\r\n        multiOwnedOperationIsActive(_operation)\r\n        ownerExists(_owner)\r\n        returns (bool)\r\n    {\r\n        return !(m_multiOwnedPending[_operation].ownersDone & makeOwnerBitmapBit(_owner) == 0);\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation)\r\n        private\r\n        onlyowner\r\n        returns (bool)\r\n    {\r\n        if (512 == m_multiOwnedPendingIndex.length)\r\n            // In case m_multiOwnedPendingIndex grows too much we have to shrink it: otherwise at some point\r\n            // we won't be able to do it because of block gas limit.\r\n            // Yes, pending confirmations will be lost. Dont see any security or stability implications.\r\n            // TODO use more graceful approach like compact or removal of clearPending completely\r\n            clearPending();\r\n\r\n        var pending = m_multiOwnedPending[_operation];\r\n\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (! isOperationActive(_operation)) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_multiOwnedRequired;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_multiOwnedPendingIndex.length++;\r\n            m_multiOwnedPendingIndex[pending.index] = _operation;\r\n            assertOperationIsConsistent(_operation);\r\n        }\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = makeOwnerBitmapBit(msg.sender);\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            // ok - check if count is enough to go ahead.\r\n            assert(pending.yetNeeded > 0);\r\n            if (pending.yetNeeded == 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index];\r\n                delete m_multiOwnedPending[_operation];\r\n                FinalConfirmation(msg.sender, _operation);\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n                assertOperationIsConsistent(_operation);\r\n                Confirmation(msg.sender, _operation);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Reclaims free slots between valid owners in m_owners.\r\n    // TODO given that its called after each removal, it could be simplified.\r\n    function reorganizeOwners() private {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            // iterating to the first free slot from the beginning\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n\r\n            // iterating to the first occupied slot from the end\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n\r\n            // swap, if possible, so free slot is located at the end after the swap\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                // owners between swapped slots should't be renumbered - that saves a lot of gas\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function clearPending() private onlyowner {\r\n        uint length = m_multiOwnedPendingIndex.length;\r\n        // TODO block gas limit\r\n        for (uint i = 0; i < length; ++i) {\r\n            if (m_multiOwnedPendingIndex[i] != 0)\r\n                delete m_multiOwnedPending[m_multiOwnedPendingIndex[i]];\r\n        }\r\n        delete m_multiOwnedPendingIndex;\r\n    }\r\n\r\n    function checkOwnerIndex(uint ownerIndex) private pure returns (uint) {\r\n        assert(0 != ownerIndex && ownerIndex <= c_maxOwners);\r\n        return ownerIndex;\r\n    }\r\n\r\n    function makeOwnerBitmapBit(address owner) private constant returns (uint) {\r\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[owner]);\r\n        return 2 ** ownerIndex;\r\n    }\r\n\r\n    function isOperationActive(bytes32 _operation) private constant returns (bool) {\r\n        return 0 != m_multiOwnedPending[_operation].yetNeeded;\r\n    }\r\n\r\n\r\n    function assertOwnersAreConsistent() private constant {\r\n        assert(m_numOwners > 0);\r\n        assert(m_numOwners <= c_maxOwners);\r\n        assert(m_owners[0] == 0);\r\n        assert(0 != m_multiOwnedRequired && m_multiOwnedRequired <= m_numOwners);\r\n    }\r\n\r\n    function assertOperationIsConsistent(bytes32 _operation) private constant {\r\n        var pending = m_multiOwnedPending[_operation];\r\n        assert(0 != pending.yetNeeded);\r\n        assert(m_multiOwnedPendingIndex[pending.index] == _operation);\r\n        assert(pending.yetNeeded <= m_multiOwnedRequired);\r\n    }\r\n\r\n\r\n   \t// FIELDS\r\n\r\n    uint constant c_maxOwners = 250;\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_multiOwnedRequired;\r\n\r\n\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n\r\n    // list of owners (addresses),\r\n    // slot 0 is unused so there are no owner which index is 0.\r\n    // TODO could we save space at the end of the array for the common case of <10 owners? and should we?\r\n    address[256] internal m_owners;\r\n\r\n    // index on the list of owners to allow reverse lookup: owner address => index in m_owners\r\n    mapping(address => uint) internal m_ownerIndex;\r\n\r\n\r\n    // the ongoing operations.\r\n    mapping(bytes32 => MultiOwnedOperationPendingState) internal m_multiOwnedPending;\r\n    bytes32[] internal m_multiOwnedPendingIndex;\r\n}"
  StructDefinition "MultiOwnedOperationPendingState"
     Gas costs: 0
     Source: "struct MultiOwnedOperationPendingState {\r\n        // count of confirmations needed\r\n        uint yetNeeded;\r\n\r\n        // bitmap of confirmations where owner #ownerIndex's decision corresponds to 2**ownerIndex bit\r\n        uint ownersDone;\r\n\r\n        // position of this operation key in m_multiOwnedPendingIndex\r\n        uint index;\r\n    }"
    VariableDeclaration "yetNeeded"
       Type: uint256
       Source: "uint yetNeeded"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "ownersDone"
       Type: uint256
       Source: "uint ownersDone"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "index"
       Type: uint256
       Source: "uint index"
      ElementaryTypeName uint
         Source: "uint"
  EventDefinition "Confirmation"
     Gas costs: 0
     Source: "event Confirmation(address owner, bytes32 operation);"
    ParameterList
       Source: "(address owner, bytes32 operation)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "operation"
         Type: bytes32
         Source: "bytes32 operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
  EventDefinition "Revoke"
     Gas costs: 0
     Source: "event Revoke(address owner, bytes32 operation);"
    ParameterList
       Source: "(address owner, bytes32 operation)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "operation"
         Type: bytes32
         Source: "bytes32 operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
  EventDefinition "FinalConfirmation"
     Gas costs: 0
     Source: "event FinalConfirmation(address owner, bytes32 operation);"
    ParameterList
       Source: "(address owner, bytes32 operation)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "operation"
         Type: bytes32
         Source: "bytes32 operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
  EventDefinition "OwnerChanged"
     Gas costs: 0
     Source: "event OwnerChanged(address oldOwner, address newOwner);"
    ParameterList
       Source: "(address oldOwner, address newOwner)"
      VariableDeclaration "oldOwner"
         Type: address
         Source: "address oldOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "OwnerAdded"
     Gas costs: 0
     Source: "event OwnerAdded(address newOwner);"
    ParameterList
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "OwnerRemoved"
     Gas costs: 0
     Source: "event OwnerRemoved(address oldOwner);"
    ParameterList
       Source: "(address oldOwner)"
      VariableDeclaration "oldOwner"
         Type: address
         Source: "address oldOwner"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "RequirementChanged"
     Gas costs: 0
     Source: "event RequirementChanged(uint newRequirement);"
    ParameterList
       Source: "(uint newRequirement)"
      VariableDeclaration "newRequirement"
         Type: uint256
         Source: "uint newRequirement"
        ElementaryTypeName uint
           Source: "uint"
  ModifierDefinition "onlyowner"
     Source: "modifier onlyowner {\r\n        require(isOwner(msg.sender));\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(isOwner(msg.sender));\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 172
         Source: "require(isOwner(msg.sender))"
        FunctionCall
           Type: tuple()
           Source: "require(isOwner(msg.sender))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "isOwner(msg.sender)"
            Identifier isOwner
               Type: function (address) view returns (bool)
               Source: "isOwner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      PlaceholderStatement
         Gas costs: 1
         Source: "_"
  ModifierDefinition "onlymanyowners"
     Source: "modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation)) {\r\n            _;\r\n        }\r\n        // Even if required number of confirmations has't been collected yet,\r\n        // we can't throw here - because changes to the state have to be preserved.\r\n        // But, confirmAndCheck itself will throw in case sender is not an owner.\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        if (confirmAndCheck(_operation)) {\r\n            _;\r\n        }\r\n        // Even if required number of confirmations has't been collected yet,\r\n        // we can't throw here - because changes to the state have to be preserved.\r\n        // But, confirmAndCheck itself will throw in case sender is not an owner.\r\n    }"
      IfStatement
         Source: "if (confirmAndCheck(_operation)) {\r\n            _;\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 79
           Source: "confirmAndCheck(_operation)"
          Identifier confirmAndCheck
             Type: function (bytes32) returns (bool)
             Source: "confirmAndCheck"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
        Block
           Source: "{\r\n            _;\r\n        }"
          PlaceholderStatement
             Gas costs: 0
             Source: "_"
  ModifierDefinition "validNumOwners"
     Source: "modifier validNumOwners(uint _numOwners) {\r\n        require(_numOwners > 0 && _numOwners <= c_maxOwners);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _numOwners)"
      VariableDeclaration "_numOwners"
         Type: uint256
         Source: "uint _numOwners"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(_numOwners > 0 && _numOwners <= c_maxOwners);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 132
         Source: "require(_numOwners > 0 && _numOwners <= c_maxOwners)"
        FunctionCall
           Type: tuple()
           Source: "require(_numOwners > 0 && _numOwners <= c_maxOwners)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_numOwners > 0 && _numOwners <= c_maxOwners"
            BinaryOperation using operator >
               Type: bool
               Source: "_numOwners > 0"
              Identifier _numOwners
                 Type: uint256
                 Source: "_numOwners"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator <=
               Type: bool
               Source: "_numOwners <= c_maxOwners"
              Identifier _numOwners
                 Type: uint256
                 Source: "_numOwners"
              Identifier c_maxOwners
                 Type: uint256
                 Source: "c_maxOwners"
      PlaceholderStatement
         Gas costs: 6
         Source: "_"
  ModifierDefinition "multiOwnedValidRequirement"
     Source: "modifier multiOwnedValidRequirement(uint _required, uint _numOwners) {\r\n        require(_required > 0 && _required <= _numOwners);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _required, uint _numOwners)"
      VariableDeclaration "_required"
         Type: uint256
         Source: "uint _required"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_numOwners"
         Type: uint256
         Source: "uint _numOwners"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require(_required > 0 && _required <= _numOwners);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 138
         Source: "require(_required > 0 && _required <= _numOwners)"
        FunctionCall
           Type: tuple()
           Source: "require(_required > 0 && _required <= _numOwners)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_required > 0 && _required <= _numOwners"
            BinaryOperation using operator >
               Type: bool
               Source: "_required > 0"
              Identifier _required
                 Type: uint256
                 Source: "_required"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator <=
               Type: bool
               Source: "_required <= _numOwners"
              Identifier _required
                 Type: uint256
                 Source: "_required"
              Identifier _numOwners
                 Type: uint256
                 Source: "_numOwners"
      PlaceholderStatement
         Gas costs: 4
         Source: "_"
  ModifierDefinition "ownerExists"
     Source: "modifier ownerExists(address _address) {\r\n        require(isOwner(_address));\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        require(isOwner(_address));\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 121
         Source: "require(isOwner(_address))"
        FunctionCall
           Type: tuple()
           Source: "require(isOwner(_address))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "isOwner(_address)"
            Identifier isOwner
               Type: function (address) view returns (bool)
               Source: "isOwner"
            Identifier _address
               Type: address
               Source: "_address"
      PlaceholderStatement
         Gas costs: 4
         Source: "_"
  ModifierDefinition "ownerDoesNotExist"
     Source: "modifier ownerDoesNotExist(address _address) {\r\n        require(!isOwner(_address));\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        require(!isOwner(_address));\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 94
         Source: "require(!isOwner(_address))"
        FunctionCall
           Type: tuple()
           Source: "require(!isOwner(_address))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!isOwner(_address)"
            FunctionCall
               Type: bool
               Source: "isOwner(_address)"
              Identifier isOwner
                 Type: function (address) view returns (bool)
                 Source: "isOwner"
              Identifier _address
                 Type: address
                 Source: "_address"
      PlaceholderStatement
         Gas costs: 4
         Source: "_"
  ModifierDefinition "multiOwnedOperationIsActive"
     Source: "modifier multiOwnedOperationIsActive(bytes32 _operation) {\r\n        require(isOperationActive(_operation));\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        require(isOperationActive(_operation));\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 77
         Source: "require(isOperationActive(_operation))"
        FunctionCall
           Type: tuple()
           Source: "require(isOperationActive(_operation))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "isOperationActive(_operation)"
            Identifier isOperationActive
               Type: function (bytes32) view returns (bool)
               Source: "isOperationActive"
            Identifier _operation
               Type: bytes32
               Source: "_operation"
      PlaceholderStatement
         Gas costs: 2
         Source: "_"
  FunctionDefinition "multiowned" - public
     Source: "function multiowned(address[] _owners, uint _required)\r\n        public\r\n        validNumOwners(_owners.length)\r\n        multiOwnedValidRequirement(_required, _owners.length)\r\n    {\r\n        assert(c_maxOwners <= 255);\r\n\r\n        m_numOwners = _owners.length;\r\n        m_multiOwnedRequired = _required;\r\n\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            address owner = _owners[i];\r\n            // invalid and duplicate addresses are not allowed\r\n            require(0 != owner && !isOwner(owner) /* not isOwner yet! */);\r\n\r\n            uint currentOwnerIndex = checkOwnerIndex(i + 1 /* first slot is unused */);\r\n            m_owners[currentOwnerIndex] = owner;\r\n            m_ownerIndex[owner] = currentOwnerIndex;\r\n        }\r\n\r\n        assertOwnersAreConsistent();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _owners, uint _required)"
      VariableDeclaration "_owners"
         Type: address[] memory
         Source: "address[] _owners"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_required"
         Type: uint256
         Source: "uint _required"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "validNumOwners"
       Gas costs: 0
       Source: "validNumOwners(_owners.length)"
      Identifier validNumOwners
         Type: modifier (uint256)
         Source: "validNumOwners"
      MemberAccess to member length
         Type: uint256
         Source: "_owners.length"
        Identifier _owners
           Type: address[] memory
           Source: "_owners"
    ModifierInvocation "multiOwnedValidRequirement"
       Gas costs: 0
       Source: "multiOwnedValidRequirement(_required, _owners.length)"
      Identifier multiOwnedValidRequirement
         Type: modifier (uint256,uint256)
         Source: "multiOwnedValidRequirement"
      Identifier _required
         Type: uint256
         Source: "_required"
      MemberAccess to member length
         Type: uint256
         Source: "_owners.length"
        Identifier _owners
           Type: address[] memory
           Source: "_owners"
    Block
       Source: "{\r\n        assert(c_maxOwners <= 255);\r\n\r\n        m_numOwners = _owners.length;\r\n        m_multiOwnedRequired = _required;\r\n\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            address owner = _owners[i];\r\n            // invalid and duplicate addresses are not allowed\r\n            require(0 != owner && !isOwner(owner) /* not isOwner yet! */);\r\n\r\n            uint currentOwnerIndex = checkOwnerIndex(i + 1 /* first slot is unused */);\r\n            m_owners[currentOwnerIndex] = owner;\r\n            m_ownerIndex[owner] = currentOwnerIndex;\r\n        }\r\n\r\n        assertOwnersAreConsistent();\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(c_maxOwners <= 255)"
        FunctionCall
           Type: tuple()
           Source: "assert(c_maxOwners <= 255)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "c_maxOwners <= 255"
            Identifier c_maxOwners
               Type: uint256
               Source: "c_maxOwners"
            Literal, token: [no token] value: 255
               Type: int_const 255
               Source: "255"
      ExpressionStatement
         Gas costs: 0
         Source: "m_numOwners = _owners.length"
        Assignment using operator =
           Type: uint256
           Source: "m_numOwners = _owners.length"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
          MemberAccess to member length
             Type: uint256
             Source: "_owners.length"
            Identifier _owners
               Type: address[] memory
               Source: "_owners"
      ExpressionStatement
         Gas costs: 0
         Source: "m_multiOwnedRequired = _required"
        Assignment using operator =
           Type: uint256
           Source: "m_multiOwnedRequired = _required"
          Identifier m_multiOwnedRequired
             Type: uint256
             Source: "m_multiOwnedRequired"
          Identifier _required
             Type: uint256
             Source: "_required"
      ForStatement
         Source: "for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            address owner = _owners[i];\r\n            // invalid and duplicate addresses are not allowed\r\n            require(0 != owner && !isOwner(owner) /* not isOwner yet! */);\r\n\r\n            uint currentOwnerIndex = checkOwnerIndex(i + 1 /* first slot is unused */);\r\n            m_owners[currentOwnerIndex] = owner;\r\n            m_ownerIndex[owner] = currentOwnerIndex;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < _owners.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_owners.length"
            Identifier _owners
               Type: address[] memory
               Source: "_owners"
        ExpressionStatement
           Gas costs: 0
           Source: "++i"
          UnaryOperation (prefix) ++
             Type: uint256
             Source: "++i"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            address owner = _owners[i];\r\n            // invalid and duplicate addresses are not allowed\r\n            require(0 != owner && !isOwner(owner) /* not isOwner yet! */);\r\n\r\n            uint currentOwnerIndex = checkOwnerIndex(i + 1 /* first slot is unused */);\r\n            m_owners[currentOwnerIndex] = owner;\r\n            m_ownerIndex[owner] = currentOwnerIndex;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "address owner = _owners[i]"
            VariableDeclaration "owner"
               Type: address
               Source: "address owner"
              ElementaryTypeName address
                 Source: "address"
            IndexAccess
               Type: address
               Source: "_owners[i]"
              Identifier _owners
                 Type: address[] memory
                 Source: "_owners"
              Identifier i
                 Type: uint256
                 Source: "i"
          ExpressionStatement
             Gas costs: 0
             Source: "require(0 != owner && !isOwner(owner) /* not isOwner yet! */)"
            FunctionCall
               Type: tuple()
               Source: "require(0 != owner && !isOwner(owner) /* not isOwner yet! */)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator &&
                 Type: bool
                 Source: "0 != owner && !isOwner(owner)"
                BinaryOperation using operator !=
                   Type: bool
                   Source: "0 != owner"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                  Identifier owner
                     Type: address
                     Source: "owner"
                UnaryOperation (prefix) !
                   Type: bool
                   Source: "!isOwner(owner)"
                  FunctionCall
                     Type: bool
                     Source: "isOwner(owner)"
                    Identifier isOwner
                       Type: function (address) view returns (bool)
                       Source: "isOwner"
                    Identifier owner
                       Type: address
                       Source: "owner"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "uint currentOwnerIndex = checkOwnerIndex(i + 1 /* first slot is unused */)"
            VariableDeclaration "currentOwnerIndex"
               Type: uint256
               Source: "uint currentOwnerIndex"
              ElementaryTypeName uint
                 Source: "uint"
            FunctionCall
               Type: uint256
               Source: "checkOwnerIndex(i + 1 /* first slot is unused */)"
              Identifier checkOwnerIndex
                 Type: function (uint256) pure returns (uint256)
                 Source: "checkOwnerIndex"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "i + 1"
                Identifier i
                   Type: uint256
                   Source: "i"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
          ExpressionStatement
             Gas costs: 0
             Source: "m_owners[currentOwnerIndex] = owner"
            Assignment using operator =
               Type: address
               Source: "m_owners[currentOwnerIndex] = owner"
              IndexAccess
                 Type: address
                 Source: "m_owners[currentOwnerIndex]"
                Identifier m_owners
                   Type: address[256] storage ref
                   Source: "m_owners"
                Identifier currentOwnerIndex
                   Type: uint256
                   Source: "currentOwnerIndex"
              Identifier owner
                 Type: address
                 Source: "owner"
          ExpressionStatement
             Gas costs: 0
             Source: "m_ownerIndex[owner] = currentOwnerIndex"
            Assignment using operator =
               Type: uint256
               Source: "m_ownerIndex[owner] = currentOwnerIndex"
              IndexAccess
                 Type: uint256
                 Source: "m_ownerIndex[owner]"
                Identifier m_ownerIndex
                   Type: mapping(address => uint256)
                   Source: "m_ownerIndex"
                Identifier owner
                   Type: address
                   Source: "owner"
              Identifier currentOwnerIndex
                 Type: uint256
                 Source: "currentOwnerIndex"
      ExpressionStatement
         Gas costs: 0
         Source: "assertOwnersAreConsistent()"
        FunctionCall
           Type: tuple()
           Source: "assertOwnersAreConsistent()"
          Identifier assertOwnersAreConsistent
             Type: function () view
             Source: "assertOwnersAreConsistent"
  FunctionDefinition "changeOwner" - public
     Source: "function changeOwner(address _from, address _to)\r\n        external\r\n        ownerExists(_from)\r\n        ownerDoesNotExist(_to)\r\n        onlymanyowners(keccak256(msg.data))\r\n    {\r\n        assertOwnersAreConsistent();\r\n\r\n        clearPending();\r\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[_from]);\r\n        m_owners[ownerIndex] = _to;\r\n        m_ownerIndex[_from] = 0;\r\n        m_ownerIndex[_to] = ownerIndex;\r\n\r\n        assertOwnersAreConsistent();\r\n        OwnerChanged(_from, _to);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerExists"
       Gas costs: 3
       Source: "ownerExists(_from)"
      Identifier ownerExists
         Type: modifier (address)
         Source: "ownerExists"
      Identifier _from
         Type: address
         Source: "_from"
    ModifierInvocation "ownerDoesNotExist"
       Gas costs: 3
       Source: "ownerDoesNotExist(_to)"
      Identifier ownerDoesNotExist
         Type: modifier (address)
         Source: "ownerDoesNotExist"
      Identifier _to
         Type: address
         Source: "_to"
    ModifierInvocation "onlymanyowners"
       Gas costs: [???]
       Source: "onlymanyowners(keccak256(msg.data))"
      Identifier onlymanyowners
         Type: modifier (bytes32)
         Source: "onlymanyowners"
      FunctionCall
         Type: bytes32
         Source: "keccak256(msg.data)"
        Identifier keccak256
           Type: function () pure returns (bytes32)
           Source: "keccak256"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        assertOwnersAreConsistent();\r\n\r\n        clearPending();\r\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[_from]);\r\n        m_owners[ownerIndex] = _to;\r\n        m_ownerIndex[_from] = 0;\r\n        m_ownerIndex[_to] = ownerIndex;\r\n\r\n        assertOwnersAreConsistent();\r\n        OwnerChanged(_from, _to);\r\n    }"
      ExpressionStatement
         Gas costs: 15
         Source: "assertOwnersAreConsistent()"
        FunctionCall
           Type: tuple()
           Source: "assertOwnersAreConsistent()"
          Identifier assertOwnersAreConsistent
             Type: function () view
             Source: "assertOwnersAreConsistent"
      ExpressionStatement
         Gas costs: 15
         Source: "clearPending()"
        FunctionCall
           Type: tuple()
           Source: "clearPending()"
          Identifier clearPending
             Type: function ()
             Source: "clearPending"
      VariableDeclarationStatement
         Gas costs: 322
         Source: "uint ownerIndex = checkOwnerIndex(m_ownerIndex[_from])"
        VariableDeclaration "ownerIndex"
           Type: uint256
           Source: "uint ownerIndex"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "checkOwnerIndex(m_ownerIndex[_from])"
          Identifier checkOwnerIndex
             Type: function (uint256) pure returns (uint256)
             Source: "checkOwnerIndex"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[_from]"
            Identifier m_ownerIndex
               Type: mapping(address => uint256)
               Source: "m_ownerIndex"
            Identifier _from
               Type: address
               Source: "_from"
      ExpressionStatement
         Gas costs: 20302
         Source: "m_owners[ownerIndex] = _to"
        Assignment using operator =
           Type: address
           Source: "m_owners[ownerIndex] = _to"
          IndexAccess
             Type: address
             Source: "m_owners[ownerIndex]"
            Identifier m_owners
               Type: address[256] storage ref
               Source: "m_owners"
            Identifier ownerIndex
               Type: uint256
               Source: "ownerIndex"
          Identifier _to
             Type: address
             Source: "_to"
      ExpressionStatement
         Gas costs: 5110
         Source: "m_ownerIndex[_from] = 0"
        Assignment using operator =
           Type: uint256
           Source: "m_ownerIndex[_from] = 0"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[_from]"
            Identifier m_ownerIndex
               Type: mapping(address => uint256)
               Source: "m_ownerIndex"
            Identifier _from
               Type: address
               Source: "_from"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 20104
         Source: "m_ownerIndex[_to] = ownerIndex"
        Assignment using operator =
           Type: uint256
           Source: "m_ownerIndex[_to] = ownerIndex"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[_to]"
            Identifier m_ownerIndex
               Type: mapping(address => uint256)
               Source: "m_ownerIndex"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
      ExpressionStatement
         Gas costs: 15
         Source: "assertOwnersAreConsistent()"
        FunctionCall
           Type: tuple()
           Source: "assertOwnersAreConsistent()"
          Identifier assertOwnersAreConsistent
             Type: function () view
             Source: "assertOwnersAreConsistent"
      ExpressionStatement
         Gas costs: [???]
         Source: "OwnerChanged(_from, _to)"
        FunctionCall
           Type: tuple()
           Source: "OwnerChanged(_from, _to)"
          Identifier OwnerChanged
             Type: function (address,address)
             Source: "OwnerChanged"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
  FunctionDefinition "addOwner" - public
     Source: "function addOwner(address _owner)\r\n        external\r\n        ownerDoesNotExist(_owner)\r\n        validNumOwners(m_numOwners + 1)\r\n        onlymanyowners(keccak256(msg.data))\r\n    {\r\n        assertOwnersAreConsistent();\r\n\r\n        clearPending();\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = _owner;\r\n        m_ownerIndex[_owner] = checkOwnerIndex(m_numOwners);\r\n\r\n        assertOwnersAreConsistent();\r\n        OwnerAdded(_owner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerDoesNotExist"
       Gas costs: 3
       Source: "ownerDoesNotExist(_owner)"
      Identifier ownerDoesNotExist
         Type: modifier (address)
         Source: "ownerDoesNotExist"
      Identifier _owner
         Type: address
         Source: "_owner"
    ModifierInvocation "validNumOwners"
       Gas costs: 209
       Source: "validNumOwners(m_numOwners + 1)"
      Identifier validNumOwners
         Type: modifier (uint256)
         Source: "validNumOwners"
      BinaryOperation using operator +
         Type: uint256
         Source: "m_numOwners + 1"
        Identifier m_numOwners
           Type: uint256
           Source: "m_numOwners"
        Literal, token: [no token] value: 1
           Type: int_const 1
           Source: "1"
    ModifierInvocation "onlymanyowners"
       Gas costs: [???]
       Source: "onlymanyowners(keccak256(msg.data))"
      Identifier onlymanyowners
         Type: modifier (bytes32)
         Source: "onlymanyowners"
      FunctionCall
         Type: bytes32
         Source: "keccak256(msg.data)"
        Identifier keccak256
           Type: function () pure returns (bytes32)
           Source: "keccak256"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        assertOwnersAreConsistent();\r\n\r\n        clearPending();\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = _owner;\r\n        m_ownerIndex[_owner] = checkOwnerIndex(m_numOwners);\r\n\r\n        assertOwnersAreConsistent();\r\n        OwnerAdded(_owner);\r\n    }"
      ExpressionStatement
         Gas costs: 15
         Source: "assertOwnersAreConsistent()"
        FunctionCall
           Type: tuple()
           Source: "assertOwnersAreConsistent()"
          Identifier assertOwnersAreConsistent
             Type: function () view
             Source: "assertOwnersAreConsistent"
      ExpressionStatement
         Gas costs: 15
         Source: "clearPending()"
        FunctionCall
           Type: tuple()
           Source: "clearPending()"
          Identifier clearPending
             Type: function ()
             Source: "clearPending"
      ExpressionStatement
         Gas costs: 20237
         Source: "m_numOwners++"
        UnaryOperation (postfix) ++
           Type: uint256
           Source: "m_numOwners++"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
      ExpressionStatement
         Gas costs: 20502
         Source: "m_owners[m_numOwners] = _owner"
        Assignment using operator =
           Type: address
           Source: "m_owners[m_numOwners] = _owner"
          IndexAccess
             Type: address
             Source: "m_owners[m_numOwners]"
            Identifier m_owners
               Type: address[256] storage ref
               Source: "m_owners"
            Identifier m_numOwners
               Type: uint256
               Source: "m_numOwners"
          Identifier _owner
             Type: address
             Source: "_owner"
      ExpressionStatement
         Gas costs: 20325
         Source: "m_ownerIndex[_owner] = checkOwnerIndex(m_numOwners)"
        Assignment using operator =
           Type: uint256
           Source: "m_ownerIndex[_owner] = checkOwnerIndex(m_numOwners)"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[_owner]"
            Identifier m_ownerIndex
               Type: mapping(address => uint256)
               Source: "m_ownerIndex"
            Identifier _owner
               Type: address
               Source: "_owner"
          FunctionCall
             Type: uint256
             Source: "checkOwnerIndex(m_numOwners)"
            Identifier checkOwnerIndex
               Type: function (uint256) pure returns (uint256)
               Source: "checkOwnerIndex"
            Identifier m_numOwners
               Type: uint256
               Source: "m_numOwners"
      ExpressionStatement
         Gas costs: 15
         Source: "assertOwnersAreConsistent()"
        FunctionCall
           Type: tuple()
           Source: "assertOwnersAreConsistent()"
          Identifier assertOwnersAreConsistent
             Type: function () view
             Source: "assertOwnersAreConsistent"
      ExpressionStatement
         Gas costs: [???]
         Source: "OwnerAdded(_owner)"
        FunctionCall
           Type: tuple()
           Source: "OwnerAdded(_owner)"
          Identifier OwnerAdded
             Type: function (address)
             Source: "OwnerAdded"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "removeOwner" - public
     Source: "function removeOwner(address _owner)\r\n        external\r\n        ownerExists(_owner)\r\n        validNumOwners(m_numOwners - 1)\r\n        multiOwnedValidRequirement(m_multiOwnedRequired, m_numOwners - 1)\r\n        onlymanyowners(keccak256(msg.data))\r\n    {\r\n        assertOwnersAreConsistent();\r\n\r\n        clearPending();\r\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[_owner]);\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[_owner] = 0;\r\n        //make sure m_numOwners is equal to the number of owners and always points to the last owner\r\n        reorganizeOwners();\r\n\r\n        assertOwnersAreConsistent();\r\n        OwnerRemoved(_owner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ownerExists"
       Gas costs: 3
       Source: "ownerExists(_owner)"
      Identifier ownerExists
         Type: modifier (address)
         Source: "ownerExists"
      Identifier _owner
         Type: address
         Source: "_owner"
    ModifierInvocation "validNumOwners"
       Gas costs: 209
       Source: "validNumOwners(m_numOwners - 1)"
      Identifier validNumOwners
         Type: modifier (uint256)
         Source: "validNumOwners"
      BinaryOperation using operator -
         Type: uint256
         Source: "m_numOwners - 1"
        Identifier m_numOwners
           Type: uint256
           Source: "m_numOwners"
        Literal, token: [no token] value: 1
           Type: int_const 1
           Source: "1"
    ModifierInvocation "multiOwnedValidRequirement"
       Gas costs: 412
       Source: "multiOwnedValidRequirement(m_multiOwnedRequired, m_numOwners - 1)"
      Identifier multiOwnedValidRequirement
         Type: modifier (uint256,uint256)
         Source: "multiOwnedValidRequirement"
      Identifier m_multiOwnedRequired
         Type: uint256
         Source: "m_multiOwnedRequired"
      BinaryOperation using operator -
         Type: uint256
         Source: "m_numOwners - 1"
        Identifier m_numOwners
           Type: uint256
           Source: "m_numOwners"
        Literal, token: [no token] value: 1
           Type: int_const 1
           Source: "1"
    ModifierInvocation "onlymanyowners"
       Gas costs: [???]
       Source: "onlymanyowners(keccak256(msg.data))"
      Identifier onlymanyowners
         Type: modifier (bytes32)
         Source: "onlymanyowners"
      FunctionCall
         Type: bytes32
         Source: "keccak256(msg.data)"
        Identifier keccak256
           Type: function () pure returns (bytes32)
           Source: "keccak256"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        assertOwnersAreConsistent();\r\n\r\n        clearPending();\r\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[_owner]);\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[_owner] = 0;\r\n        //make sure m_numOwners is equal to the number of owners and always points to the last owner\r\n        reorganizeOwners();\r\n\r\n        assertOwnersAreConsistent();\r\n        OwnerRemoved(_owner);\r\n    }"
      ExpressionStatement
         Gas costs: 15
         Source: "assertOwnersAreConsistent()"
        FunctionCall
           Type: tuple()
           Source: "assertOwnersAreConsistent()"
          Identifier assertOwnersAreConsistent
             Type: function () view
             Source: "assertOwnersAreConsistent"
      ExpressionStatement
         Gas costs: 4
         Source: "clearPending()"
        FunctionCall
           Type: tuple()
           Source: "clearPending()"
          Identifier clearPending
             Type: function ()
             Source: "clearPending"
      VariableDeclarationStatement
         Gas costs: 311
         Source: "uint ownerIndex = checkOwnerIndex(m_ownerIndex[_owner])"
        VariableDeclaration "ownerIndex"
           Type: uint256
           Source: "uint ownerIndex"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "checkOwnerIndex(m_ownerIndex[_owner])"
          Identifier checkOwnerIndex
             Type: function (uint256) pure returns (uint256)
             Source: "checkOwnerIndex"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[_owner]"
            Identifier m_ownerIndex
               Type: mapping(address => uint256)
               Source: "m_ownerIndex"
            Identifier _owner
               Type: address
               Source: "_owner"
      ExpressionStatement
         Gas costs: 20302
         Source: "m_owners[ownerIndex] = 0"
        Assignment using operator =
           Type: address
           Source: "m_owners[ownerIndex] = 0"
          IndexAccess
             Type: address
             Source: "m_owners[ownerIndex]"
            Identifier m_owners
               Type: address[256] storage ref
               Source: "m_owners"
            Identifier ownerIndex
               Type: uint256
               Source: "ownerIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 5110
         Source: "m_ownerIndex[_owner] = 0"
        Assignment using operator =
           Type: uint256
           Source: "m_ownerIndex[_owner] = 0"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[_owner]"
            Identifier m_ownerIndex
               Type: mapping(address => uint256)
               Source: "m_ownerIndex"
            Identifier _owner
               Type: address
               Source: "_owner"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 4
         Source: "reorganizeOwners()"
        FunctionCall
           Type: tuple()
           Source: "reorganizeOwners()"
          Identifier reorganizeOwners
             Type: function ()
             Source: "reorganizeOwners"
      ExpressionStatement
         Gas costs: 4
         Source: "assertOwnersAreConsistent()"
        FunctionCall
           Type: tuple()
           Source: "assertOwnersAreConsistent()"
          Identifier assertOwnersAreConsistent
             Type: function () view
             Source: "assertOwnersAreConsistent"
      ExpressionStatement
         Gas costs: [???]
         Source: "OwnerRemoved(_owner)"
        FunctionCall
           Type: tuple()
           Source: "OwnerRemoved(_owner)"
          Identifier OwnerRemoved
             Type: function (address)
             Source: "OwnerRemoved"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "changeRequirement" - public
     Source: "function changeRequirement(uint _newRequired)\r\n        external\r\n        multiOwnedValidRequirement(_newRequired, m_numOwners)\r\n        onlymanyowners(keccak256(msg.data))\r\n    {\r\n        m_multiOwnedRequired = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _newRequired)"
      VariableDeclaration "_newRequired"
         Type: uint256
         Source: "uint _newRequired"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "multiOwnedValidRequirement"
       Gas costs: 206
       Source: "multiOwnedValidRequirement(_newRequired, m_numOwners)"
      Identifier multiOwnedValidRequirement
         Type: modifier (uint256,uint256)
         Source: "multiOwnedValidRequirement"
      Identifier _newRequired
         Type: uint256
         Source: "_newRequired"
      Identifier m_numOwners
         Type: uint256
         Source: "m_numOwners"
    ModifierInvocation "onlymanyowners"
       Gas costs: [???]
       Source: "onlymanyowners(keccak256(msg.data))"
      Identifier onlymanyowners
         Type: modifier (bytes32)
         Source: "onlymanyowners"
      FunctionCall
         Type: bytes32
         Source: "keccak256(msg.data)"
        Identifier keccak256
           Type: function () pure returns (bytes32)
           Source: "keccak256"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        m_multiOwnedRequired = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }"
      ExpressionStatement
         Gas costs: 20014
         Source: "m_multiOwnedRequired = _newRequired"
        Assignment using operator =
           Type: uint256
           Source: "m_multiOwnedRequired = _newRequired"
          Identifier m_multiOwnedRequired
             Type: uint256
             Source: "m_multiOwnedRequired"
          Identifier _newRequired
             Type: uint256
             Source: "_newRequired"
      ExpressionStatement
         Gas costs: 15
         Source: "clearPending()"
        FunctionCall
           Type: tuple()
           Source: "clearPending()"
          Identifier clearPending
             Type: function ()
             Source: "clearPending"
      ExpressionStatement
         Gas costs: [???]
         Source: "RequirementChanged(_newRequired)"
        FunctionCall
           Type: tuple()
           Source: "RequirementChanged(_newRequired)"
          Identifier RequirementChanged
             Type: function (uint256)
             Source: "RequirementChanged"
          Identifier _newRequired
             Type: uint256
             Source: "_newRequired"
  FunctionDefinition "getOwner" - public - const
     Source: "function getOwner(uint ownerIndex) public constant returns (address) {\r\n        return m_owners[ownerIndex + 1];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint ownerIndex)"
      VariableDeclaration "ownerIndex"
         Type: uint256
         Source: "uint ownerIndex"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return m_owners[ownerIndex + 1];\r\n    }"
      Return
         Gas costs: 285
         Source: "return m_owners[ownerIndex + 1]"
        IndexAccess
           Type: address
           Source: "m_owners[ownerIndex + 1]"
          Identifier m_owners
             Type: address[256] storage ref
             Source: "m_owners"
          BinaryOperation using operator +
             Type: uint256
             Source: "ownerIndex + 1"
            Identifier ownerIndex
               Type: uint256
               Source: "ownerIndex"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
  FunctionDefinition "getOwners" - public - const
     Source: "function getOwners() public constant returns (address[]) {\r\n        address[] memory result = new address[](m_numOwners);\r\n        for (uint i = 0; i < m_numOwners; i++)\r\n            result[i] = getOwner(i);\r\n\r\n        return result;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(address[])"
      VariableDeclaration ""
         Type: address[] memory
         Source: "address[]"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\r\n        address[] memory result = new address[](m_numOwners);\r\n        for (uint i = 0; i < m_numOwners; i++)\r\n            result[i] = getOwner(i);\r\n\r\n        return result;\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "address[] memory result = new address[](m_numOwners)"
        VariableDeclaration "result"
           Type: address[] memory
           Source: "address[] memory result"
          ArrayTypeName
             Source: "address[]"
            ElementaryTypeName address
               Source: "address"
        FunctionCall
           Type: address[] memory
           Source: "new address[](m_numOwners)"
          NewExpression
             Type: function (uint256) pure returns (address[] memory)
             Source: "new address[]"
            ArrayTypeName
               Source: "address[]"
              ElementaryTypeName address
                 Source: "address"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
      ForStatement
         Source: "for (uint i = 0; i < m_numOwners; i++)\r\n            result[i] = getOwner(i)"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 209
           Source: "i < m_numOwners"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        ExpressionStatement
           Gas costs: [???]
           Source: "result[i] = getOwner(i)"
          Assignment using operator =
             Type: address
             Source: "result[i] = getOwner(i)"
            IndexAccess
               Type: address
               Source: "result[i]"
              Identifier result
                 Type: address[] memory
                 Source: "result"
              Identifier i
                 Type: uint256
                 Source: "i"
            FunctionCall
               Type: address
               Source: "getOwner(i)"
              Identifier getOwner
                 Type: function (uint256) view returns (address)
                 Source: "getOwner"
              Identifier i
                 Type: uint256
                 Source: "i"
      Return
         Gas costs: 8
         Source: "return result"
        Identifier result
           Type: address[] memory
           Source: "result"
  FunctionDefinition "isOwner" - public - const
     Source: "function isOwner(address _addr) public constant returns (bool) {\r\n        return m_ownerIndex[_addr] > 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _addr)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        return m_ownerIndex[_addr] > 0;\r\n    }"
      Return
         Gas costs: 310
         Source: "return m_ownerIndex[_addr] > 0"
        BinaryOperation using operator >
           Type: bool
           Source: "m_ownerIndex[_addr] > 0"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[_addr]"
            Identifier m_ownerIndex
               Type: mapping(address => uint256)
               Source: "m_ownerIndex"
            Identifier _addr
               Type: address
               Source: "_addr"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "amIOwner" - public - const
     Source: "function amIOwner() external constant onlyowner returns (bool) {\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyowner"
       Gas costs: 0
       Source: "onlyowner"
      Identifier onlyowner
         Type: modifier ()
         Source: "onlyowner"
    Block
       Source: "{\r\n        return true;\r\n    }"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "revoke" - public
     Source: "function revoke(bytes32 _operation)\r\n        external\r\n        multiOwnedOperationIsActive(_operation)\r\n        onlyowner\r\n    {\r\n        uint ownerIndexBit = makeOwnerBitmapBit(msg.sender);\r\n        var pending = m_multiOwnedPending[_operation];\r\n        require(pending.ownersDone & ownerIndexBit > 0);\r\n\r\n        assertOperationIsConsistent(_operation);\r\n\r\n        pending.yetNeeded++;\r\n        pending.ownersDone -= ownerIndexBit;\r\n\r\n        assertOperationIsConsistent(_operation);\r\n        Revoke(msg.sender, _operation);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "multiOwnedOperationIsActive"
       Gas costs: 3
       Source: "multiOwnedOperationIsActive(_operation)"
      Identifier multiOwnedOperationIsActive
         Type: modifier (bytes32)
         Source: "multiOwnedOperationIsActive"
      Identifier _operation
         Type: bytes32
         Source: "_operation"
    ModifierInvocation "onlyowner"
       Gas costs: 0
       Source: "onlyowner"
      Identifier onlyowner
         Type: modifier ()
         Source: "onlyowner"
    Block
       Source: "{\r\n        uint ownerIndexBit = makeOwnerBitmapBit(msg.sender);\r\n        var pending = m_multiOwnedPending[_operation];\r\n        require(pending.ownersDone & ownerIndexBit > 0);\r\n\r\n        assertOperationIsConsistent(_operation);\r\n\r\n        pending.yetNeeded++;\r\n        pending.ownersDone -= ownerIndexBit;\r\n\r\n        assertOperationIsConsistent(_operation);\r\n        Revoke(msg.sender, _operation);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 14
         Source: "uint ownerIndexBit = makeOwnerBitmapBit(msg.sender)"
        VariableDeclaration "ownerIndexBit"
           Type: uint256
           Source: "uint ownerIndexBit"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "makeOwnerBitmapBit(msg.sender)"
          Identifier makeOwnerBitmapBit
             Type: function (address) view returns (uint256)
             Source: "makeOwnerBitmapBit"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      VariableDeclarationStatement
         Gas costs: 113
         Source: "var pending = m_multiOwnedPending[_operation]"
        VariableDeclaration "pending"
           Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
           Source: "var pending"
        IndexAccess
           Type: struct multiowned.MultiOwnedOperationPendingState storage ref
           Source: "m_multiOwnedPending[_operation]"
          Identifier m_multiOwnedPending
             Type: mapping(bytes32 => struct multiowned.MultiOwnedOperationPendingState storage ref)
             Source: "m_multiOwnedPending"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
      ExpressionStatement
         Gas costs: 247
         Source: "require(pending.ownersDone & ownerIndexBit > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(pending.ownersDone & ownerIndexBit > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "pending.ownersDone & ownerIndexBit > 0"
            BinaryOperation using operator &
               Type: uint256
               Source: "pending.ownersDone & ownerIndexBit"
              MemberAccess to member ownersDone
                 Type: uint256
                 Source: "pending.ownersDone"
                Identifier pending
                   Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
                   Source: "pending"
              Identifier ownerIndexBit
                 Type: uint256
                 Source: "ownerIndexBit"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 7
         Source: "assertOperationIsConsistent(_operation)"
        FunctionCall
           Type: tuple()
           Source: "assertOperationIsConsistent(_operation)"
          Identifier assertOperationIsConsistent
             Type: function (bytes32) view
             Source: "assertOperationIsConsistent"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
      ExpressionStatement
         Gas costs: 20243
         Source: "pending.yetNeeded++"
        UnaryOperation (postfix) ++
           Type: uint256
           Source: "pending.yetNeeded++"
          MemberAccess to member yetNeeded
             Type: uint256
             Source: "pending.yetNeeded"
            Identifier pending
               Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
               Source: "pending"
      ExpressionStatement
         Gas costs: 20239
         Source: "pending.ownersDone -= ownerIndexBit"
        Assignment using operator -=
           Type: uint256
           Source: "pending.ownersDone -= ownerIndexBit"
          MemberAccess to member ownersDone
             Type: uint256
             Source: "pending.ownersDone"
            Identifier pending
               Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
               Source: "pending"
          Identifier ownerIndexBit
             Type: uint256
             Source: "ownerIndexBit"
      ExpressionStatement
         Gas costs: 18
         Source: "assertOperationIsConsistent(_operation)"
        FunctionCall
           Type: tuple()
           Source: "assertOperationIsConsistent(_operation)"
          Identifier assertOperationIsConsistent
             Type: function (bytes32) view
             Source: "assertOperationIsConsistent"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
      ExpressionStatement
         Gas costs: [???]
         Source: "Revoke(msg.sender, _operation)"
        FunctionCall
           Type: tuple()
           Source: "Revoke(msg.sender, _operation)"
          Identifier Revoke
             Type: function (address,bytes32)
             Source: "Revoke"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
  FunctionDefinition "hasConfirmed" - public - const
     Source: "function hasConfirmed(bytes32 _operation, address _owner)\r\n        external\r\n        constant\r\n        multiOwnedOperationIsActive(_operation)\r\n        ownerExists(_owner)\r\n        returns (bool)\r\n    {\r\n        return !(m_multiOwnedPending[_operation].ownersDone & makeOwnerBitmapBit(_owner) == 0);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation, address _owner)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "multiOwnedOperationIsActive"
       Gas costs: 3
       Source: "multiOwnedOperationIsActive(_operation)"
      Identifier multiOwnedOperationIsActive
         Type: modifier (bytes32)
         Source: "multiOwnedOperationIsActive"
      Identifier _operation
         Type: bytes32
         Source: "_operation"
    ModifierInvocation "ownerExists"
       Gas costs: 3
       Source: "ownerExists(_owner)"
      Identifier ownerExists
         Type: modifier (address)
         Source: "ownerExists"
      Identifier _owner
         Type: address
         Source: "_owner"
    Block
       Source: "{\r\n        return !(m_multiOwnedPending[_operation].ownersDone & makeOwnerBitmapBit(_owner) == 0);\r\n    }"
      Return
         Gas costs: 346
         Source: "return !(m_multiOwnedPending[_operation].ownersDone & makeOwnerBitmapBit(_owner) == 0)"
        UnaryOperation (prefix) !
           Type: bool
           Source: "!(m_multiOwnedPending[_operation].ownersDone & makeOwnerBitmapBit(_owner) == 0)"
          TupleExpression
             Type: bool
             Source: "(m_multiOwnedPending[_operation].ownersDone & makeOwnerBitmapBit(_owner) == 0)"
            BinaryOperation using operator ==
               Type: bool
               Source: "m_multiOwnedPending[_operation].ownersDone & makeOwnerBitmapBit(_owner) == 0"
              BinaryOperation using operator &
                 Type: uint256
                 Source: "m_multiOwnedPending[_operation].ownersDone & makeOwnerBitmapBit(_owner)"
                MemberAccess to member ownersDone
                   Type: uint256
                   Source: "m_multiOwnedPending[_operation].ownersDone"
                  IndexAccess
                     Type: struct multiowned.MultiOwnedOperationPendingState storage ref
                     Source: "m_multiOwnedPending[_operation]"
                    Identifier m_multiOwnedPending
                       Type: mapping(bytes32 => struct multiowned.MultiOwnedOperationPendingState storage ref)
                       Source: "m_multiOwnedPending"
                    Identifier _operation
                       Type: bytes32
                       Source: "_operation"
                FunctionCall
                   Type: uint256
                   Source: "makeOwnerBitmapBit(_owner)"
                  Identifier makeOwnerBitmapBit
                     Type: function (address) view returns (uint256)
                     Source: "makeOwnerBitmapBit"
                  Identifier _owner
                     Type: address
                     Source: "_owner"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
  FunctionDefinition "confirmAndCheck"
     Source: "function confirmAndCheck(bytes32 _operation)\r\n        private\r\n        onlyowner\r\n        returns (bool)\r\n    {\r\n        if (512 == m_multiOwnedPendingIndex.length)\r\n            // In case m_multiOwnedPendingIndex grows too much we have to shrink it: otherwise at some point\r\n            // we won't be able to do it because of block gas limit.\r\n            // Yes, pending confirmations will be lost. Dont see any security or stability implications.\r\n            // TODO use more graceful approach like compact or removal of clearPending completely\r\n            clearPending();\r\n\r\n        var pending = m_multiOwnedPending[_operation];\r\n\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (! isOperationActive(_operation)) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_multiOwnedRequired;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_multiOwnedPendingIndex.length++;\r\n            m_multiOwnedPendingIndex[pending.index] = _operation;\r\n            assertOperationIsConsistent(_operation);\r\n        }\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = makeOwnerBitmapBit(msg.sender);\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            // ok - check if count is enough to go ahead.\r\n            assert(pending.yetNeeded > 0);\r\n            if (pending.yetNeeded == 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index];\r\n                delete m_multiOwnedPending[_operation];\r\n                FinalConfirmation(msg.sender, _operation);\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n                assertOperationIsConsistent(_operation);\r\n                Confirmation(msg.sender, _operation);\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyowner"
       Gas costs: 0
       Source: "onlyowner"
      Identifier onlyowner
         Type: modifier ()
         Source: "onlyowner"
    Block
       Source: "{\r\n        if (512 == m_multiOwnedPendingIndex.length)\r\n            // In case m_multiOwnedPendingIndex grows too much we have to shrink it: otherwise at some point\r\n            // we won't be able to do it because of block gas limit.\r\n            // Yes, pending confirmations will be lost. Dont see any security or stability implications.\r\n            // TODO use more graceful approach like compact or removal of clearPending completely\r\n            clearPending();\r\n\r\n        var pending = m_multiOwnedPending[_operation];\r\n\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (! isOperationActive(_operation)) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_multiOwnedRequired;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_multiOwnedPendingIndex.length++;\r\n            m_multiOwnedPendingIndex[pending.index] = _operation;\r\n            assertOperationIsConsistent(_operation);\r\n        }\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = makeOwnerBitmapBit(msg.sender);\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            // ok - check if count is enough to go ahead.\r\n            assert(pending.yetNeeded > 0);\r\n            if (pending.yetNeeded == 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index];\r\n                delete m_multiOwnedPending[_operation];\r\n                FinalConfirmation(msg.sender, _operation);\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n                assertOperationIsConsistent(_operation);\r\n                Confirmation(msg.sender, _operation);\r\n            }\r\n        }\r\n    }"
      IfStatement
         Source: "if (512 == m_multiOwnedPendingIndex.length)\r\n            // In case m_multiOwnedPendingIndex grows too much we have to shrink it: otherwise at some point\r\n            // we won't be able to do it because of block gas limit.\r\n            // Yes, pending confirmations will be lost. Dont see any security or stability implications.\r\n            // TODO use more graceful approach like compact or removal of clearPending completely\r\n            clearPending()"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 217
           Source: "512 == m_multiOwnedPendingIndex.length"
          Literal, token: [no token] value: 512
             Type: int_const 512
             Source: "512"
          MemberAccess to member length
             Type: uint256
             Source: "m_multiOwnedPendingIndex.length"
            Identifier m_multiOwnedPendingIndex
               Type: bytes32[] storage ref
               Source: "m_multiOwnedPendingIndex"
        ExpressionStatement
           Gas costs: 15
           Source: "clearPending()"
          FunctionCall
             Type: tuple()
             Source: "clearPending()"
            Identifier clearPending
               Type: function ()
               Source: "clearPending"
      VariableDeclarationStatement
         Gas costs: 113
         Source: "var pending = m_multiOwnedPending[_operation]"
        VariableDeclaration "pending"
           Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
           Source: "var pending"
        IndexAccess
           Type: struct multiowned.MultiOwnedOperationPendingState storage ref
           Source: "m_multiOwnedPending[_operation]"
          Identifier m_multiOwnedPending
             Type: mapping(bytes32 => struct multiowned.MultiOwnedOperationPendingState storage ref)
             Source: "m_multiOwnedPending"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
      IfStatement
         Source: "if (! isOperationActive(_operation)) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_multiOwnedRequired;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_multiOwnedPendingIndex.length++;\r\n            m_multiOwnedPendingIndex[pending.index] = _operation;\r\n            assertOperationIsConsistent(_operation);\r\n        }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 21
           Source: "! isOperationActive(_operation)"
          FunctionCall
             Type: bool
             Source: "isOperationActive(_operation)"
            Identifier isOperationActive
               Type: function (bytes32) view returns (bool)
               Source: "isOperationActive"
            Identifier _operation
               Type: bytes32
               Source: "_operation"
        Block
           Source: "{\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_multiOwnedRequired;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_multiOwnedPendingIndex.length++;\r\n            m_multiOwnedPendingIndex[pending.index] = _operation;\r\n            assertOperationIsConsistent(_operation);\r\n        }"
          ExpressionStatement
             Gas costs: 20220
             Source: "pending.yetNeeded = m_multiOwnedRequired"
            Assignment using operator =
               Type: uint256
               Source: "pending.yetNeeded = m_multiOwnedRequired"
              MemberAccess to member yetNeeded
                 Type: uint256
                 Source: "pending.yetNeeded"
                Identifier pending
                   Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
                   Source: "pending"
              Identifier m_multiOwnedRequired
                 Type: uint256
                 Source: "m_multiOwnedRequired"
          ExpressionStatement
             Gas costs: 5020
             Source: "pending.ownersDone = 0"
            Assignment using operator =
               Type: uint256
               Source: "pending.ownersDone = 0"
              MemberAccess to member ownersDone
                 Type: uint256
                 Source: "pending.ownersDone"
                Identifier pending
                   Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
                   Source: "pending"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          ExpressionStatement
             Gas costs: 20248
             Source: "pending.index = m_multiOwnedPendingIndex.length++"
            Assignment using operator =
               Type: uint256
               Source: "pending.index = m_multiOwnedPendingIndex.length++"
              MemberAccess to member index
                 Type: uint256
                 Source: "pending.index"
                Identifier pending
                   Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
                   Source: "pending"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "m_multiOwnedPendingIndex.length++"
                MemberAccess to member length
                   Type: uint256
                   Source: "m_multiOwnedPendingIndex.length"
                  Identifier m_multiOwnedPendingIndex
                     Type: bytes32[] storage ref
                     Source: "m_multiOwnedPendingIndex"
          ExpressionStatement
             Gas costs: 20518
             Source: "m_multiOwnedPendingIndex[pending.index] = _operation"
            Assignment using operator =
               Type: bytes32
               Source: "m_multiOwnedPendingIndex[pending.index] = _operation"
              IndexAccess
                 Type: bytes32
                 Source: "m_multiOwnedPendingIndex[pending.index]"
                Identifier m_multiOwnedPendingIndex
                   Type: bytes32[] storage ref
                   Source: "m_multiOwnedPendingIndex"
                MemberAccess to member index
                   Type: uint256
                   Source: "pending.index"
                  Identifier pending
                     Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
                     Source: "pending"
              Identifier _operation
                 Type: bytes32
                 Source: "_operation"
          ExpressionStatement
             Gas costs: 18
             Source: "assertOperationIsConsistent(_operation)"
            FunctionCall
               Type: tuple()
               Source: "assertOperationIsConsistent(_operation)"
              Identifier assertOperationIsConsistent
                 Type: function (bytes32) view
                 Source: "assertOperationIsConsistent"
              Identifier _operation
                 Type: bytes32
                 Source: "_operation"
      VariableDeclarationStatement
         Gas costs: 25
         Source: "uint ownerIndexBit = makeOwnerBitmapBit(msg.sender)"
        VariableDeclaration "ownerIndexBit"
           Type: uint256
           Source: "uint ownerIndexBit"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "makeOwnerBitmapBit(msg.sender)"
          Identifier makeOwnerBitmapBit
             Type: function (address) view returns (uint256)
             Source: "makeOwnerBitmapBit"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (pending.ownersDone & ownerIndexBit == 0) {\r\n            // ok - check if count is enough to go ahead.\r\n            assert(pending.yetNeeded > 0);\r\n            if (pending.yetNeeded == 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index];\r\n                delete m_multiOwnedPending[_operation];\r\n                FinalConfirmation(msg.sender, _operation);\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n                assertOperationIsConsistent(_operation);\r\n                Confirmation(msg.sender, _operation);\r\n            }\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 221
           Source: "pending.ownersDone & ownerIndexBit == 0"
          BinaryOperation using operator &
             Type: uint256
             Source: "pending.ownersDone & ownerIndexBit"
            MemberAccess to member ownersDone
               Type: uint256
               Source: "pending.ownersDone"
              Identifier pending
                 Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
                 Source: "pending"
            Identifier ownerIndexBit
               Type: uint256
               Source: "ownerIndexBit"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            // ok - check if count is enough to go ahead.\r\n            assert(pending.yetNeeded > 0);\r\n            if (pending.yetNeeded == 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index];\r\n                delete m_multiOwnedPending[_operation];\r\n                FinalConfirmation(msg.sender, _operation);\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n                assertOperationIsConsistent(_operation);\r\n                Confirmation(msg.sender, _operation);\r\n            }\r\n        }"
          ExpressionStatement
             Gas costs: 235
             Source: "assert(pending.yetNeeded > 0)"
            FunctionCall
               Type: tuple()
               Source: "assert(pending.yetNeeded > 0)"
              Identifier assert
                 Type: function (bool) pure
                 Source: "assert"
              BinaryOperation using operator >
                 Type: bool
                 Source: "pending.yetNeeded > 0"
                MemberAccess to member yetNeeded
                   Type: uint256
                   Source: "pending.yetNeeded"
                  Identifier pending
                     Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
                     Source: "pending"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
          IfStatement
             Source: "if (pending.yetNeeded == 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index];\r\n                delete m_multiOwnedPending[_operation];\r\n                FinalConfirmation(msg.sender, _operation);\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n                assertOperationIsConsistent(_operation);\r\n                Confirmation(msg.sender, _operation);\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 215
               Source: "pending.yetNeeded == 1"
              MemberAccess to member yetNeeded
                 Type: uint256
                 Source: "pending.yetNeeded"
                Identifier pending
                   Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
                   Source: "pending"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            Block
               Source: "{\r\n                // enough confirmations: reset and run interior.\r\n                delete m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index];\r\n                delete m_multiOwnedPending[_operation];\r\n                FinalConfirmation(msg.sender, _operation);\r\n                return true;\r\n            }"
              ExpressionStatement
                 Gas costs: 5606
                 Source: "delete m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index]"
                UnaryOperation (prefix) delete
                   Type: tuple()
                   Source: "delete m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index]"
                  IndexAccess
                     Type: bytes32
                     Source: "m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index]"
                    Identifier m_multiOwnedPendingIndex
                       Type: bytes32[] storage ref
                       Source: "m_multiOwnedPendingIndex"
                    MemberAccess to member index
                       Type: uint256
                       Source: "m_multiOwnedPending[_operation].index"
                      IndexAccess
                         Type: struct multiowned.MultiOwnedOperationPendingState storage ref
                         Source: "m_multiOwnedPending[_operation]"
                        Identifier m_multiOwnedPending
                           Type: mapping(bytes32 => struct multiowned.MultiOwnedOperationPendingState storage ref)
                           Source: "m_multiOwnedPending"
                        Identifier _operation
                           Type: bytes32
                           Source: "_operation"
              ExpressionStatement
                 Gas costs: 15154
                 Source: "delete m_multiOwnedPending[_operation]"
                UnaryOperation (prefix) delete
                   Type: tuple()
                   Source: "delete m_multiOwnedPending[_operation]"
                  IndexAccess
                     Type: struct multiowned.MultiOwnedOperationPendingState storage ref
                     Source: "m_multiOwnedPending[_operation]"
                    Identifier m_multiOwnedPending
                       Type: mapping(bytes32 => struct multiowned.MultiOwnedOperationPendingState storage ref)
                       Source: "m_multiOwnedPending"
                    Identifier _operation
                       Type: bytes32
                       Source: "_operation"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "FinalConfirmation(msg.sender, _operation)"
                FunctionCall
                   Type: tuple()
                   Source: "FinalConfirmation(msg.sender, _operation)"
                  Identifier FinalConfirmation
                     Type: function (address,bytes32)
                     Source: "FinalConfirmation"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier _operation
                     Type: bytes32
                     Source: "_operation"
              Return
                 Gas costs: 19
                 Source: "return true"
                Literal, token: true value: true
                   Type: bool
                   Source: "true"
            Block
               Source: "{\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n                assertOperationIsConsistent(_operation);\r\n                Confirmation(msg.sender, _operation);\r\n            }"
              ExpressionStatement
                 Gas costs: 20246
                 Source: "pending.yetNeeded--"
                UnaryOperation (postfix) --
                   Type: uint256
                   Source: "pending.yetNeeded--"
                  MemberAccess to member yetNeeded
                     Type: uint256
                     Source: "pending.yetNeeded"
                    Identifier pending
                       Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
                       Source: "pending"
              ExpressionStatement
                 Gas costs: 20239
                 Source: "pending.ownersDone |= ownerIndexBit"
                Assignment using operator |=
                   Type: uint256
                   Source: "pending.ownersDone |= ownerIndexBit"
                  MemberAccess to member ownersDone
                     Type: uint256
                     Source: "pending.ownersDone"
                    Identifier pending
                       Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
                       Source: "pending"
                  Identifier ownerIndexBit
                     Type: uint256
                     Source: "ownerIndexBit"
              ExpressionStatement
                 Gas costs: 18
                 Source: "assertOperationIsConsistent(_operation)"
                FunctionCall
                   Type: tuple()
                   Source: "assertOperationIsConsistent(_operation)"
                  Identifier assertOperationIsConsistent
                     Type: function (bytes32) view
                     Source: "assertOperationIsConsistent"
                  Identifier _operation
                     Type: bytes32
                     Source: "_operation"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "Confirmation(msg.sender, _operation)"
                FunctionCall
                   Type: tuple()
                   Source: "Confirmation(msg.sender, _operation)"
                  Identifier Confirmation
                     Type: function (address,bytes32)
                     Source: "Confirmation"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier _operation
                     Type: bytes32
                     Source: "_operation"
  FunctionDefinition "reorganizeOwners"
     Source: "function reorganizeOwners() private {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            // iterating to the first free slot from the beginning\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n\r\n            // iterating to the first occupied slot from the end\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n\r\n            // swap, if possible, so free slot is located at the end after the swap\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                // owners between swapped slots should't be renumbered - that saves a lot of gas\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            // iterating to the first free slot from the beginning\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n\r\n            // iterating to the first occupied slot from the end\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n\r\n            // swap, if possible, so free slot is located at the end after the swap\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                // owners between swapped slots should't be renumbered - that saves a lot of gas\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint free = 1"
        VariableDeclaration "free"
           Type: uint256
           Source: "uint free"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 1
           Type: int_const 1
           Source: "1"
      WhileStatement
         Source: "while (free < m_numOwners)\r\n        {\r\n            // iterating to the first free slot from the beginning\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n\r\n            // iterating to the first occupied slot from the end\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n\r\n            // swap, if possible, so free slot is located at the end after the swap\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                // owners between swapped slots should't be renumbered - that saves a lot of gas\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 209
           Source: "free < m_numOwners"
          Identifier free
             Type: uint256
             Source: "free"
          Identifier m_numOwners
             Type: uint256
             Source: "m_numOwners"
        Block
           Source: "{\r\n            // iterating to the first free slot from the beginning\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n\r\n            // iterating to the first occupied slot from the end\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n\r\n            // swap, if possible, so free slot is located at the end after the swap\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                // owners between swapped slots should't be renumbered - that saves a lot of gas\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }"
          WhileStatement
             Source: "while (free < m_numOwners && m_owners[free] != 0) free++"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 520
               Source: "free < m_numOwners && m_owners[free] != 0"
              BinaryOperation using operator <
                 Type: bool
                 Source: "free < m_numOwners"
                Identifier free
                   Type: uint256
                   Source: "free"
                Identifier m_numOwners
                   Type: uint256
                   Source: "m_numOwners"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "m_owners[free] != 0"
                IndexAccess
                   Type: address
                   Source: "m_owners[free]"
                  Identifier m_owners
                     Type: address[256] storage ref
                     Source: "m_owners"
                  Identifier free
                     Type: uint256
                     Source: "free"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            ExpressionStatement
               Gas costs: 19
               Source: "free++"
              UnaryOperation (postfix) ++
                 Type: uint256
                 Source: "free++"
                Identifier free
                   Type: uint256
                   Source: "free"
          WhileStatement
             Source: "while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 717
               Source: "m_numOwners > 1 && m_owners[m_numOwners] == 0"
              BinaryOperation using operator >
                 Type: bool
                 Source: "m_numOwners > 1"
                Identifier m_numOwners
                   Type: uint256
                   Source: "m_numOwners"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "m_owners[m_numOwners] == 0"
                IndexAccess
                   Type: address
                   Source: "m_owners[m_numOwners]"
                  Identifier m_owners
                     Type: address[256] storage ref
                     Source: "m_owners"
                  Identifier m_numOwners
                     Type: uint256
                     Source: "m_numOwners"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            ExpressionStatement
               Gas costs: 20240
               Source: "m_numOwners--"
              UnaryOperation (postfix) --
                 Type: uint256
                 Source: "m_numOwners--"
                Identifier m_numOwners
                   Type: uint256
                   Source: "m_numOwners"
          IfStatement
             Source: "if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                // owners between swapped slots should't be renumbered - that saves a lot of gas\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 1028
               Source: "free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0"
              BinaryOperation using operator &&
                 Type: bool
                 Source: "free < m_numOwners && m_owners[m_numOwners] != 0"
                BinaryOperation using operator <
                   Type: bool
                   Source: "free < m_numOwners"
                  Identifier free
                     Type: uint256
                     Source: "free"
                  Identifier m_numOwners
                     Type: uint256
                     Source: "m_numOwners"
                BinaryOperation using operator !=
                   Type: bool
                   Source: "m_owners[m_numOwners] != 0"
                  IndexAccess
                     Type: address
                     Source: "m_owners[m_numOwners]"
                    Identifier m_owners
                       Type: address[256] storage ref
                       Source: "m_owners"
                    Identifier m_numOwners
                       Type: uint256
                       Source: "m_numOwners"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "m_owners[free] == 0"
                IndexAccess
                   Type: address
                   Source: "m_owners[free]"
                  Identifier m_owners
                     Type: address[256] storage ref
                     Source: "m_owners"
                  Identifier free
                     Type: uint256
                     Source: "free"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            Block
               Source: "{\r\n                // owners between swapped slots should't be renumbered - that saves a lot of gas\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }"
              ExpressionStatement
                 Gas costs: 20773
                 Source: "m_owners[free] = m_owners[m_numOwners]"
                Assignment using operator =
                   Type: address
                   Source: "m_owners[free] = m_owners[m_numOwners]"
                  IndexAccess
                     Type: address
                     Source: "m_owners[free]"
                    Identifier m_owners
                       Type: address[256] storage ref
                       Source: "m_owners"
                    Identifier free
                       Type: uint256
                       Source: "free"
                  IndexAccess
                     Type: address
                     Source: "m_owners[m_numOwners]"
                    Identifier m_owners
                       Type: address[256] storage ref
                       Source: "m_owners"
                    Identifier m_numOwners
                       Type: uint256
                       Source: "m_numOwners"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "m_ownerIndex[m_owners[free]] = free"
                Assignment using operator =
                   Type: uint256
                   Source: "m_ownerIndex[m_owners[free]] = free"
                  IndexAccess
                     Type: uint256
                     Source: "m_ownerIndex[m_owners[free]]"
                    Identifier m_ownerIndex
                       Type: mapping(address => uint256)
                       Source: "m_ownerIndex"
                    IndexAccess
                       Type: address
                       Source: "m_owners[free]"
                      Identifier m_owners
                         Type: address[256] storage ref
                         Source: "m_owners"
                      Identifier free
                         Type: uint256
                         Source: "free"
                  Identifier free
                     Type: uint256
                     Source: "free"
              ExpressionStatement
                 Gas costs: 20502
                 Source: "m_owners[m_numOwners] = 0"
                Assignment using operator =
                   Type: address
                   Source: "m_owners[m_numOwners] = 0"
                  IndexAccess
                     Type: address
                     Source: "m_owners[m_numOwners]"
                    Identifier m_owners
                       Type: address[256] storage ref
                       Source: "m_owners"
                    Identifier m_numOwners
                       Type: uint256
                       Source: "m_numOwners"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
  FunctionDefinition "clearPending"
     Source: "function clearPending() private onlyowner {\r\n        uint length = m_multiOwnedPendingIndex.length;\r\n        // TODO block gas limit\r\n        for (uint i = 0; i < length; ++i) {\r\n            if (m_multiOwnedPendingIndex[i] != 0)\r\n                delete m_multiOwnedPending[m_multiOwnedPendingIndex[i]];\r\n        }\r\n        delete m_multiOwnedPendingIndex;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyowner"
       Gas costs: 0
       Source: "onlyowner"
      Identifier onlyowner
         Type: modifier ()
         Source: "onlyowner"
    Block
       Source: "{\r\n        uint length = m_multiOwnedPendingIndex.length;\r\n        // TODO block gas limit\r\n        for (uint i = 0; i < length; ++i) {\r\n            if (m_multiOwnedPendingIndex[i] != 0)\r\n                delete m_multiOwnedPending[m_multiOwnedPendingIndex[i]];\r\n        }\r\n        delete m_multiOwnedPendingIndex;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 219
         Source: "uint length = m_multiOwnedPendingIndex.length"
        VariableDeclaration "length"
           Type: uint256
           Source: "uint length"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "m_multiOwnedPendingIndex.length"
          Identifier m_multiOwnedPendingIndex
             Type: bytes32[] storage ref
             Source: "m_multiOwnedPendingIndex"
      ForStatement
         Source: "for (uint i = 0; i < length; ++i) {\r\n            if (m_multiOwnedPendingIndex[i] != 0)\r\n                delete m_multiOwnedPending[m_multiOwnedPendingIndex[i]];\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < length"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier length
             Type: uint256
             Source: "length"
        ExpressionStatement
           Gas costs: 14
           Source: "++i"
          UnaryOperation (prefix) ++
             Type: uint256
             Source: "++i"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (m_multiOwnedPendingIndex[i] != 0)\r\n                delete m_multiOwnedPending[m_multiOwnedPendingIndex[i]];\r\n        }"
          IfStatement
             Source: "if (m_multiOwnedPendingIndex[i] != 0)\r\n                delete m_multiOwnedPending[m_multiOwnedPendingIndex[i]]"
            BinaryOperation using operator !=
               Type: bool
               Gas costs: 518
               Source: "m_multiOwnedPendingIndex[i] != 0"
              IndexAccess
                 Type: bytes32
                 Source: "m_multiOwnedPendingIndex[i]"
                Identifier m_multiOwnedPendingIndex
                   Type: bytes32[] storage ref
                   Source: "m_multiOwnedPendingIndex"
                Identifier i
                   Type: uint256
                   Source: "i"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            ExpressionStatement
               Gas costs: [???]
               Source: "delete m_multiOwnedPending[m_multiOwnedPendingIndex[i]]"
              UnaryOperation (prefix) delete
                 Type: tuple()
                 Source: "delete m_multiOwnedPending[m_multiOwnedPendingIndex[i]]"
                IndexAccess
                   Type: struct multiowned.MultiOwnedOperationPendingState storage ref
                   Source: "m_multiOwnedPending[m_multiOwnedPendingIndex[i]]"
                  Identifier m_multiOwnedPending
                     Type: mapping(bytes32 => struct multiowned.MultiOwnedOperationPendingState storage ref)
                     Source: "m_multiOwnedPending"
                  IndexAccess
                     Type: bytes32
                     Source: "m_multiOwnedPendingIndex[i]"
                    Identifier m_multiOwnedPendingIndex
                       Type: bytes32[] storage ref
                       Source: "m_multiOwnedPendingIndex"
                    Identifier i
                       Type: uint256
                       Source: "i"
      ExpressionStatement
         Gas costs: 16
         Source: "delete m_multiOwnedPendingIndex"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete m_multiOwnedPendingIndex"
          Identifier m_multiOwnedPendingIndex
             Type: bytes32[] storage ref
             Source: "m_multiOwnedPendingIndex"
  FunctionDefinition "checkOwnerIndex"
     Source: "function checkOwnerIndex(uint ownerIndex) private pure returns (uint) {\r\n        assert(0 != ownerIndex && ownerIndex <= c_maxOwners);\r\n        return ownerIndex;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint ownerIndex)"
      VariableDeclaration "ownerIndex"
         Type: uint256
         Source: "uint ownerIndex"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        assert(0 != ownerIndex && ownerIndex <= c_maxOwners);\r\n        return ownerIndex;\r\n    }"
      ExpressionStatement
         Gas costs: 63
         Source: "assert(0 != ownerIndex && ownerIndex <= c_maxOwners)"
        FunctionCall
           Type: tuple()
           Source: "assert(0 != ownerIndex && ownerIndex <= c_maxOwners)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator &&
             Type: bool
             Source: "0 != ownerIndex && ownerIndex <= c_maxOwners"
            BinaryOperation using operator !=
               Type: bool
               Source: "0 != ownerIndex"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
              Identifier ownerIndex
                 Type: uint256
                 Source: "ownerIndex"
            BinaryOperation using operator <=
               Type: bool
               Source: "ownerIndex <= c_maxOwners"
              Identifier ownerIndex
                 Type: uint256
                 Source: "ownerIndex"
              Identifier c_maxOwners
                 Type: uint256
                 Source: "c_maxOwners"
      Return
         Gas costs: 8
         Source: "return ownerIndex"
        Identifier ownerIndex
           Type: uint256
           Source: "ownerIndex"
  FunctionDefinition "makeOwnerBitmapBit" - const
     Source: "function makeOwnerBitmapBit(address owner) private constant returns (uint) {\r\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[owner]);\r\n        return 2 ** ownerIndex;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint ownerIndex = checkOwnerIndex(m_ownerIndex[owner]);\r\n        return 2 ** ownerIndex;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 322
         Source: "uint ownerIndex = checkOwnerIndex(m_ownerIndex[owner])"
        VariableDeclaration "ownerIndex"
           Type: uint256
           Source: "uint ownerIndex"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "checkOwnerIndex(m_ownerIndex[owner])"
          Identifier checkOwnerIndex
             Type: function (uint256) pure returns (uint256)
             Source: "checkOwnerIndex"
          IndexAccess
             Type: uint256
             Source: "m_ownerIndex[owner]"
            Identifier m_ownerIndex
               Type: mapping(address => uint256)
               Source: "m_ownerIndex"
            Identifier owner
               Type: address
               Source: "owner"
      Return
         Gas costs: 1621
         Source: "return 2 ** ownerIndex"
        BinaryOperation using operator **
           Type: uint256
           Source: "2 ** ownerIndex"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
          Identifier ownerIndex
             Type: uint256
             Source: "ownerIndex"
  FunctionDefinition "isOperationActive" - const
     Source: "function isOperationActive(bytes32 _operation) private constant returns (bool) {\r\n        return 0 != m_multiOwnedPending[_operation].yetNeeded;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        return 0 != m_multiOwnedPending[_operation].yetNeeded;\r\n    }"
      Return
         Gas costs: 325
         Source: "return 0 != m_multiOwnedPending[_operation].yetNeeded"
        BinaryOperation using operator !=
           Type: bool
           Source: "0 != m_multiOwnedPending[_operation].yetNeeded"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          MemberAccess to member yetNeeded
             Type: uint256
             Source: "m_multiOwnedPending[_operation].yetNeeded"
            IndexAccess
               Type: struct multiowned.MultiOwnedOperationPendingState storage ref
               Source: "m_multiOwnedPending[_operation]"
              Identifier m_multiOwnedPending
                 Type: mapping(bytes32 => struct multiowned.MultiOwnedOperationPendingState storage ref)
                 Source: "m_multiOwnedPending"
              Identifier _operation
                 Type: bytes32
                 Source: "_operation"
  FunctionDefinition "assertOwnersAreConsistent" - const
     Source: "function assertOwnersAreConsistent() private constant {\r\n        assert(m_numOwners > 0);\r\n        assert(m_numOwners <= c_maxOwners);\r\n        assert(m_owners[0] == 0);\r\n        assert(0 != m_multiOwnedRequired && m_multiOwnedRequired <= m_numOwners);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        assert(m_numOwners > 0);\r\n        assert(m_numOwners <= c_maxOwners);\r\n        assert(m_owners[0] == 0);\r\n        assert(0 != m_multiOwnedRequired && m_multiOwnedRequired <= m_numOwners);\r\n    }"
      ExpressionStatement
         Gas costs: 229
         Source: "assert(m_numOwners > 0)"
        FunctionCall
           Type: tuple()
           Source: "assert(m_numOwners > 0)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >
             Type: bool
             Source: "m_numOwners > 0"
            Identifier m_numOwners
               Type: uint256
               Source: "m_numOwners"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 229
         Source: "assert(m_numOwners <= c_maxOwners)"
        FunctionCall
           Type: tuple()
           Source: "assert(m_numOwners <= c_maxOwners)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "m_numOwners <= c_maxOwners"
            Identifier m_numOwners
               Type: uint256
               Source: "m_numOwners"
            Identifier c_maxOwners
               Type: uint256
               Source: "c_maxOwners"
      ExpressionStatement
         Gas costs: 306
         Source: "assert(m_owners[0] == 0)"
        FunctionCall
           Type: tuple()
           Source: "assert(m_owners[0] == 0)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "m_owners[0] == 0"
            IndexAccess
               Type: address
               Source: "m_owners[0]"
              Identifier m_owners
                 Type: address[256] storage ref
                 Source: "m_owners"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 666
         Source: "assert(0 != m_multiOwnedRequired && m_multiOwnedRequired <= m_numOwners)"
        FunctionCall
           Type: tuple()
           Source: "assert(0 != m_multiOwnedRequired && m_multiOwnedRequired <= m_numOwners)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator &&
             Type: bool
             Source: "0 != m_multiOwnedRequired && m_multiOwnedRequired <= m_numOwners"
            BinaryOperation using operator !=
               Type: bool
               Source: "0 != m_multiOwnedRequired"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
              Identifier m_multiOwnedRequired
                 Type: uint256
                 Source: "m_multiOwnedRequired"
            BinaryOperation using operator <=
               Type: bool
               Source: "m_multiOwnedRequired <= m_numOwners"
              Identifier m_multiOwnedRequired
                 Type: uint256
                 Source: "m_multiOwnedRequired"
              Identifier m_numOwners
                 Type: uint256
                 Source: "m_numOwners"
  FunctionDefinition "assertOperationIsConsistent" - const
     Source: "function assertOperationIsConsistent(bytes32 _operation) private constant {\r\n        var pending = m_multiOwnedPending[_operation];\r\n        assert(0 != pending.yetNeeded);\r\n        assert(m_multiOwnedPendingIndex[pending.index] == _operation);\r\n        assert(pending.yetNeeded <= m_multiOwnedRequired);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _operation)"
      VariableDeclaration "_operation"
         Type: bytes32
         Source: "bytes32 _operation"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        var pending = m_multiOwnedPending[_operation];\r\n        assert(0 != pending.yetNeeded);\r\n        assert(m_multiOwnedPendingIndex[pending.index] == _operation);\r\n        assert(pending.yetNeeded <= m_multiOwnedRequired);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 113
         Source: "var pending = m_multiOwnedPending[_operation]"
        VariableDeclaration "pending"
           Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
           Source: "var pending"
        IndexAccess
           Type: struct multiowned.MultiOwnedOperationPendingState storage ref
           Source: "m_multiOwnedPending[_operation]"
          Identifier m_multiOwnedPending
             Type: mapping(bytes32 => struct multiowned.MultiOwnedOperationPendingState storage ref)
             Source: "m_multiOwnedPending"
          Identifier _operation
             Type: bytes32
             Source: "_operation"
      ExpressionStatement
         Gas costs: 238
         Source: "assert(0 != pending.yetNeeded)"
        FunctionCall
           Type: tuple()
           Source: "assert(0 != pending.yetNeeded)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator !=
             Type: bool
             Source: "0 != pending.yetNeeded"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
            MemberAccess to member yetNeeded
               Type: uint256
               Source: "pending.yetNeeded"
              Identifier pending
                 Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
                 Source: "pending"
      ExpressionStatement
         Gas costs: 742
         Source: "assert(m_multiOwnedPendingIndex[pending.index] == _operation)"
        FunctionCall
           Type: tuple()
           Source: "assert(m_multiOwnedPendingIndex[pending.index] == _operation)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "m_multiOwnedPendingIndex[pending.index] == _operation"
            IndexAccess
               Type: bytes32
               Source: "m_multiOwnedPendingIndex[pending.index]"
              Identifier m_multiOwnedPendingIndex
                 Type: bytes32[] storage ref
                 Source: "m_multiOwnedPendingIndex"
              MemberAccess to member index
                 Type: uint256
                 Source: "pending.index"
                Identifier pending
                   Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
                   Source: "pending"
            Identifier _operation
               Type: bytes32
               Source: "_operation"
      ExpressionStatement
         Gas costs: 438
         Source: "assert(pending.yetNeeded <= m_multiOwnedRequired)"
        FunctionCall
           Type: tuple()
           Source: "assert(pending.yetNeeded <= m_multiOwnedRequired)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "pending.yetNeeded <= m_multiOwnedRequired"
            MemberAccess to member yetNeeded
               Type: uint256
               Source: "pending.yetNeeded"
              Identifier pending
                 Type: struct multiowned.MultiOwnedOperationPendingState storage pointer
                 Source: "pending"
            Identifier m_multiOwnedRequired
               Type: uint256
               Source: "m_multiOwnedRequired"
  VariableDeclaration "c_maxOwners"
     Type: uint256
     Gas costs: 12
     Source: "uint constant c_maxOwners = 250"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 250
       Type: int_const 250
       Source: "250"
  VariableDeclaration "m_multiOwnedRequired"
     Type: uint256
     Gas costs: [???]
     Source: "uint public m_multiOwnedRequired"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "m_numOwners"
     Type: uint256
     Gas costs: [???]
     Source: "uint public m_numOwners"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "m_owners"
     Type: address[256] storage ref
     Gas costs: 0
     Source: "address[256] internal m_owners"
    ArrayTypeName
       Source: "address[256]"
      ElementaryTypeName address
         Source: "address"
      Literal, token: [no token] value: 256
         Type unknown.
         Source: "256"
  VariableDeclaration "m_ownerIndex"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint) internal m_ownerIndex"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "m_multiOwnedPending"
     Type: mapping(bytes32 => struct multiowned.MultiOwnedOperationPendingState storage ref)
     Gas costs: 0
     Source: "mapping(bytes32 => MultiOwnedOperationPendingState) internal m_multiOwnedPending"
    Mapping
       Source: "mapping(bytes32 => MultiOwnedOperationPendingState)"
      ElementaryTypeName bytes32
         Source: "bytes32"
      UserDefinedTypeName "MultiOwnedOperationPendingState"
         Source: "MultiOwnedOperationPendingState"
  VariableDeclaration "m_multiOwnedPendingIndex"
     Type: bytes32[] storage ref
     Gas costs: 0
     Source: "bytes32[] internal m_multiOwnedPendingIndex"
    ArrayTypeName
       Source: "bytes32[]"
      ElementaryTypeName bytes32
         Source: "bytes32"
ContractDefinition "ERC20Basic"
   Gas costs: [???]
   Source: "contract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) public view returns (uint256);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address to, uint256 value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "BasicToken"
   Source: "contract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) balances"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(_to != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_to != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != address(0)"
            Identifier _to
               Type: address
               Source: "_to"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 333
         Source: "require(_value <= balances[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= balances[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= balances[msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 20437
         Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "balances[msg.sender].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20433
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return balances[_owner];\r\n  }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
ContractDefinition "MultiownedControlled"
   Source: "contract MultiownedControlled is multiowned {\r\n\r\n    event ControllerSet(address controller);\r\n    event ControllerRetired(address was);\r\n    event ControllerRetiredForever(address was);\r\n\r\n\r\n    modifier onlyController {\r\n        require(msg.sender == m_controller);\r\n        _;\r\n    }\r\n\r\n\r\n    // PUBLIC interface\r\n\r\n    function MultiownedControlled(address[] _owners, uint _signaturesRequired, address _controller)\r\n        public\r\n        multiowned(_owners, _signaturesRequired)\r\n    {\r\n        m_controller = _controller;\r\n        ControllerSet(m_controller);\r\n    }\r\n\r\n    /// @dev sets the controller\r\n    function setController(address _controller) external onlymanyowners(keccak256(msg.data)) {\r\n        require(m_attaching_enabled);\r\n        m_controller = _controller;\r\n        ControllerSet(m_controller);\r\n    }\r\n\r\n    /// @dev ability for controller to step down\r\n    function detachController() external onlyController {\r\n        address was = m_controller;\r\n        m_controller = address(0);\r\n        ControllerRetired(was);\r\n    }\r\n\r\n    /// @dev ability for controller to step down and make this contract completely automatic (without third-party control)\r\n    function detachControllerForever() external onlyController {\r\n        assert(m_attaching_enabled);\r\n        address was = m_controller;\r\n        m_controller = address(0);\r\n        m_attaching_enabled = false;\r\n        ControllerRetiredForever(was);\r\n    }\r\n\r\n\r\n    // FIELDS\r\n\r\n    /// @notice address of entity entitled to mint new tokens\r\n    address public m_controller;\r\n\r\n    bool public m_attaching_enabled = true;\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "multiowned"
    UserDefinedTypeName "multiowned"
       Source: "multiowned"
  EventDefinition "ControllerSet"
     Gas costs: 0
     Source: "event ControllerSet(address controller);"
    ParameterList
       Source: "(address controller)"
      VariableDeclaration "controller"
         Type: address
         Source: "address controller"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "ControllerRetired"
     Gas costs: 0
     Source: "event ControllerRetired(address was);"
    ParameterList
       Source: "(address was)"
      VariableDeclaration "was"
         Type: address
         Source: "address was"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "ControllerRetiredForever"
     Gas costs: 0
     Source: "event ControllerRetiredForever(address was);"
    ParameterList
       Source: "(address was)"
      VariableDeclaration "was"
         Type: address
         Source: "address was"
        ElementaryTypeName address
           Source: "address"
  ModifierDefinition "onlyController"
     Source: "modifier onlyController {\r\n        require(msg.sender == m_controller);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(msg.sender == m_controller);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 1410
         Source: "require(msg.sender == m_controller)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == m_controller)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == m_controller"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier m_controller
               Type: address
               Source: "m_controller"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "MultiownedControlled" - public
     Source: "function MultiownedControlled(address[] _owners, uint _signaturesRequired, address _controller)\r\n        public\r\n        multiowned(_owners, _signaturesRequired)\r\n    {\r\n        m_controller = _controller;\r\n        ControllerSet(m_controller);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _owners, uint _signaturesRequired, address _controller)"
      VariableDeclaration "_owners"
         Type: address[] memory
         Source: "address[] _owners"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_signaturesRequired"
         Type: uint256
         Source: "uint _signaturesRequired"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_controller"
         Type: address
         Source: "address _controller"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "multiowned"
       Gas costs: 0
       Source: "multiowned(_owners, _signaturesRequired)"
      Identifier multiowned
         Type: type(contract multiowned)
         Source: "multiowned"
      Identifier _owners
         Type: address[] memory
         Source: "_owners"
      Identifier _signaturesRequired
         Type: uint256
         Source: "_signaturesRequired"
    Block
       Source: "{\r\n        m_controller = _controller;\r\n        ControllerSet(m_controller);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "m_controller = _controller"
        Assignment using operator =
           Type: address
           Source: "m_controller = _controller"
          Identifier m_controller
             Type: address
             Source: "m_controller"
          Identifier _controller
             Type: address
             Source: "_controller"
      ExpressionStatement
         Gas costs: 0
         Source: "ControllerSet(m_controller)"
        FunctionCall
           Type: tuple()
           Source: "ControllerSet(m_controller)"
          Identifier ControllerSet
             Type: function (address)
             Source: "ControllerSet"
          Identifier m_controller
             Type: address
             Source: "m_controller"
  FunctionDefinition "setController" - public
     Source: "function setController(address _controller) external onlymanyowners(keccak256(msg.data)) {\r\n        require(m_attaching_enabled);\r\n        m_controller = _controller;\r\n        ControllerSet(m_controller);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _controller)"
      VariableDeclaration "_controller"
         Type: address
         Source: "address _controller"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlymanyowners"
       Gas costs: [???]
       Source: "onlymanyowners(keccak256(msg.data))"
      Identifier onlymanyowners
         Type: modifier (bytes32)
         Source: "onlymanyowners"
      FunctionCall
         Type: bytes32
         Source: "keccak256(msg.data)"
        Identifier keccak256
           Type: function () pure returns (bytes32)
           Source: "keccak256"
        MemberAccess to member data
           Type: bytes calldata
           Source: "msg.data"
          Identifier msg
             Type: msg
             Source: "msg"
    Block
       Source: "{\r\n        require(m_attaching_enabled);\r\n        m_controller = _controller;\r\n        ControllerSet(m_controller);\r\n    }"
      ExpressionStatement
         Gas costs: 315
         Source: "require(m_attaching_enabled)"
        FunctionCall
           Type: tuple()
           Source: "require(m_attaching_enabled)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier m_attaching_enabled
             Type: bool
             Source: "m_attaching_enabled"
      ExpressionStatement
         Gas costs: 20267
         Source: "m_controller = _controller"
        Assignment using operator =
           Type: address
           Source: "m_controller = _controller"
          Identifier m_controller
             Type: address
             Source: "m_controller"
          Identifier _controller
             Type: address
             Source: "_controller"
      ExpressionStatement
         Gas costs: [???]
         Source: "ControllerSet(m_controller)"
        FunctionCall
           Type: tuple()
           Source: "ControllerSet(m_controller)"
          Identifier ControllerSet
             Type: function (address)
             Source: "ControllerSet"
          Identifier m_controller
             Type: address
             Source: "m_controller"
  FunctionDefinition "detachController" - public
     Source: "function detachController() external onlyController {\r\n        address was = m_controller;\r\n        m_controller = address(0);\r\n        ControllerRetired(was);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        address was = m_controller;\r\n        m_controller = address(0);\r\n        ControllerRetired(was);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 247
         Source: "address was = m_controller"
        VariableDeclaration "was"
           Type: address
           Source: "address was"
          ElementaryTypeName address
             Source: "address"
        Identifier m_controller
           Type: address
           Source: "m_controller"
      ExpressionStatement
         Gas costs: 20267
         Source: "m_controller = address(0)"
        Assignment using operator =
           Type: address
           Source: "m_controller = address(0)"
          Identifier m_controller
             Type: address
             Source: "m_controller"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "ControllerRetired(was)"
        FunctionCall
           Type: tuple()
           Source: "ControllerRetired(was)"
          Identifier ControllerRetired
             Type: function (address)
             Source: "ControllerRetired"
          Identifier was
             Type: address
             Source: "was"
  FunctionDefinition "detachControllerForever" - public
     Source: "function detachControllerForever() external onlyController {\r\n        assert(m_attaching_enabled);\r\n        address was = m_controller;\r\n        m_controller = address(0);\r\n        m_attaching_enabled = false;\r\n        ControllerRetiredForever(was);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        assert(m_attaching_enabled);\r\n        address was = m_controller;\r\n        m_controller = address(0);\r\n        m_attaching_enabled = false;\r\n        ControllerRetiredForever(was);\r\n    }"
      ExpressionStatement
         Gas costs: 309
         Source: "assert(m_attaching_enabled)"
        FunctionCall
           Type: tuple()
           Source: "assert(m_attaching_enabled)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          Identifier m_attaching_enabled
             Type: bool
             Source: "m_attaching_enabled"
      VariableDeclarationStatement
         Gas costs: 247
         Source: "address was = m_controller"
        VariableDeclaration "was"
           Type: address
           Source: "address was"
          ElementaryTypeName address
             Source: "address"
        Identifier m_controller
           Type: address
           Source: "m_controller"
      ExpressionStatement
         Gas costs: 20267
         Source: "m_controller = address(0)"
        Assignment using operator =
           Type: address
           Source: "m_controller = address(0)"
          Identifier m_controller
             Type: address
             Source: "m_controller"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20317
         Source: "m_attaching_enabled = false"
        Assignment using operator =
           Type: bool
           Source: "m_attaching_enabled = false"
          Identifier m_attaching_enabled
             Type: bool
             Source: "m_attaching_enabled"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: [???]
         Source: "ControllerRetiredForever(was)"
        FunctionCall
           Type: tuple()
           Source: "ControllerRetiredForever(was)"
          Identifier ControllerRetiredForever
             Type: function (address)
             Source: "ControllerRetiredForever"
          Identifier was
             Type: address
             Source: "was"
  VariableDeclaration "m_controller"
     Type: address
     Gas costs: [???]
     Source: "address public m_controller"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "m_attaching_enabled"
     Type: bool
     Gas costs: [???]
     Source: "bool public m_attaching_enabled = true"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: true value: true
       Type: bool
       Source: "true"
ContractDefinition "ERC20"
   Gas costs: 0
   Source: "contract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
  InheritanceSpecifier
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) public view returns (uint256);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address from, address to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address spender, uint256 value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint256 value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint256 value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  InheritanceSpecifier
     Gas costs: 0
     Source: "BasicToken"
    UserDefinedTypeName "BasicToken"
       Source: "BasicToken"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) internal allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(_to != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_to != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != address(0)"
            Identifier _to
               Type: address
               Source: "_to"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 334
         Source: "require(_value <= balances[_from])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= balances[_from])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= balances[_from]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[_from]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _from
                 Type: address
                 Source: "_from"
      ExpressionStatement
         Gas costs: 423
         Source: "require(_value <= allowed[_from][msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= allowed[_from][msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= allowed[_from][msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "allowed[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[_from]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 20439
         Source: "balances[_from] = balances[_from].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_from] = balances[_from].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "balances[_from].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[_from].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20433
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20611
         Source: "allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "allowed[_from][msg.sender].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "allowed[_from][msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return allowed[_owner][_spender];\r\n  }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  FunctionDefinition "increaseApproval" - public
     Source: "function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _addedValue)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_addedValue"
         Type: uint256
         Source: "uint _addedValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 20617
         Source: "allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          FunctionCall
             Type: uint256
             Source: "allowed[msg.sender][_spender].add(_addedValue)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "allowed[msg.sender][_spender].add"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
            Identifier _addedValue
               Type: uint256
               Source: "_addedValue"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "decreaseApproval" - public
     Source: "function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _subtractedValue)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_subtractedValue"
         Type: uint256
         Source: "uint _subtractedValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 396
         Source: "uint oldValue = allowed[msg.sender][_spender]"
        VariableDeclaration "oldValue"
           Type: uint256
           Source: "uint oldValue"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "allowed[msg.sender][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[msg.sender]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
      IfStatement
         Source: "if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "_subtractedValue > oldValue"
          Identifier _subtractedValue
             Type: uint256
             Source: "_subtractedValue"
          Identifier oldValue
             Type: uint256
             Source: "oldValue"
        Block
           Source: "{\r\n      allowed[msg.sender][_spender] = 0;\r\n    }"
          ExpressionStatement
             Gas costs: 5199
             Source: "allowed[msg.sender][_spender] = 0"
            Assignment using operator =
               Type: uint256
               Source: "allowed[msg.sender][_spender] = 0"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }"
          ExpressionStatement
             Gas costs: 20232
             Source: "allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)"
            Assignment using operator =
               Type: uint256
               Source: "allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
              FunctionCall
                 Type: uint256
                 Source: "oldValue.sub(_subtractedValue)"
                MemberAccess to member sub
                   Type: function (uint256,uint256) pure returns (uint256)
                   Source: "oldValue.sub"
                  Identifier oldValue
                     Type: uint256
                     Source: "oldValue"
                Identifier _subtractedValue
                   Type: uint256
                   Source: "_subtractedValue"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
ContractDefinition "MintableMultiownedToken"
   Source: "contract MintableMultiownedToken is MintableToken, MultiownedControlled, StandardToken {\r\n\r\n    // PUBLIC interface\r\n\r\n    function MintableMultiownedToken(address[] _owners, uint _signaturesRequired, address _minter)\r\n        public\r\n        MultiownedControlled(_owners, _signaturesRequired, _minter)\r\n    {\r\n    }\r\n\r\n\r\n    /// @dev mints new tokens\r\n    function mint(address _to, uint256 _amount) public onlyController {\r\n        require(m_externalMintingEnabled);\r\n        mintInternal(_to, _amount);\r\n    }\r\n\r\n    /// @dev disables mint(), irreversible!\r\n    function disableMinting() public onlyController {\r\n        require(m_externalMintingEnabled);\r\n        m_externalMintingEnabled = false;\r\n    }\r\n\r\n\r\n    // INTERNAL functions\r\n\r\n    function mintInternal(address _to, uint256 _amount) internal {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Transfer(address(0), _to, _amount);\r\n        Mint(_to, _amount);\r\n    }\r\n\r\n\r\n    // FIELDS\r\n\r\n    /// @notice if this true then token is still externally mintable\r\n    bool public m_externalMintingEnabled = true;\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "MintableToken"
    UserDefinedTypeName "MintableToken"
       Source: "MintableToken"
  InheritanceSpecifier
     Gas costs: 0
     Source: "MultiownedControlled"
    UserDefinedTypeName "MultiownedControlled"
       Source: "MultiownedControlled"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  FunctionDefinition "MintableMultiownedToken" - public
     Source: "function MintableMultiownedToken(address[] _owners, uint _signaturesRequired, address _minter)\r\n        public\r\n        MultiownedControlled(_owners, _signaturesRequired, _minter)\r\n    {\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _owners, uint _signaturesRequired, address _minter)"
      VariableDeclaration "_owners"
         Type: address[] memory
         Source: "address[] _owners"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_signaturesRequired"
         Type: uint256
         Source: "uint _signaturesRequired"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_minter"
         Type: address
         Source: "address _minter"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "MultiownedControlled"
       Gas costs: 0
       Source: "MultiownedControlled(_owners, _signaturesRequired, _minter)"
      Identifier MultiownedControlled
         Type: type(contract MultiownedControlled)
         Source: "MultiownedControlled"
      Identifier _owners
         Type: address[] memory
         Source: "_owners"
      Identifier _signaturesRequired
         Type: uint256
         Source: "_signaturesRequired"
      Identifier _minter
         Type: address
         Source: "_minter"
    Block
       Gas costs: 0
       Source: "{\r\n    }"
  FunctionDefinition "mint" - public
     Source: "function mint(address _to, uint256 _amount) public onlyController {\r\n        require(m_externalMintingEnabled);\r\n        mintInternal(_to, _amount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _amount)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        require(m_externalMintingEnabled);\r\n        mintInternal(_to, _amount);\r\n    }"
      ExpressionStatement
         Gas costs: 315
         Source: "require(m_externalMintingEnabled)"
        FunctionCall
           Type: tuple()
           Source: "require(m_externalMintingEnabled)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier m_externalMintingEnabled
             Type: bool
             Source: "m_externalMintingEnabled"
      ExpressionStatement
         Gas costs: 10
         Source: "mintInternal(_to, _amount)"
        FunctionCall
           Type: tuple()
           Source: "mintInternal(_to, _amount)"
          Identifier mintInternal
             Type: function (address,uint256)
             Source: "mintInternal"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
  FunctionDefinition "disableMinting" - public
     Source: "function disableMinting() public onlyController {\r\n        require(m_externalMintingEnabled);\r\n        m_externalMintingEnabled = false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        require(m_externalMintingEnabled);\r\n        m_externalMintingEnabled = false;\r\n    }"
      ExpressionStatement
         Gas costs: 315
         Source: "require(m_externalMintingEnabled)"
        FunctionCall
           Type: tuple()
           Source: "require(m_externalMintingEnabled)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier m_externalMintingEnabled
             Type: bool
             Source: "m_externalMintingEnabled"
      ExpressionStatement
         Gas costs: 20317
         Source: "m_externalMintingEnabled = false"
        Assignment using operator =
           Type: bool
           Source: "m_externalMintingEnabled = false"
          Identifier m_externalMintingEnabled
             Type: bool
             Source: "m_externalMintingEnabled"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "mintInternal"
     Source: "function mintInternal(address _to, uint256 _amount) internal {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Transfer(address(0), _to, _amount);\r\n        Mint(_to, _amount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _amount)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Transfer(address(0), _to, _amount);\r\n        Mint(_to, _amount);\r\n    }"
      ExpressionStatement
         Gas costs: 20247
         Source: "totalSupply = totalSupply.add(_amount)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = totalSupply.add(_amount)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "totalSupply.add(_amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "totalSupply.add"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 20439
         Source: "balances[_to] = balances[_to].add(_amount)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_amount)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(address(0), _to, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(address(0), _to, _amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Mint(_to, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Mint(_to, _amount)"
          Identifier Mint
             Type: function (address,uint256)
             Source: "Mint"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
  VariableDeclaration "m_externalMintingEnabled"
     Type: bool
     Gas costs: [???]
     Source: "bool public m_externalMintingEnabled = true"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: true value: true
       Type: bool
       Source: "true"
ContractDefinition "CirculatingToken"
   Source: "contract CirculatingToken is StandardToken {\r\n\r\n    event CirculationEnabled();\r\n\r\n    modifier requiresCirculation {\r\n        require(m_isCirculating);\r\n        _;\r\n    }\r\n\r\n\r\n    // PUBLIC interface\r\n\r\n    function transfer(address _to, uint256 _value) public requiresCirculation returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public requiresCirculation returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public requiresCirculation returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n\r\n    // INTERNAL functions\r\n\r\n    function enableCirculation() internal returns (bool) {\r\n        if (m_isCirculating)\r\n            return false;\r\n\r\n        m_isCirculating = true;\r\n        CirculationEnabled();\r\n        return true;\r\n    }\r\n\r\n\r\n    // FIELDS\r\n\r\n    /// @notice are the circulation started?\r\n    bool public m_isCirculating;\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  EventDefinition "CirculationEnabled"
     Gas costs: 0
     Source: "event CirculationEnabled();"
    ParameterList
       Source: "()"
  ModifierDefinition "requiresCirculation"
     Source: "modifier requiresCirculation {\r\n        require(m_isCirculating);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(m_isCirculating);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 795
         Source: "require(m_isCirculating)"
        FunctionCall
           Type: tuple()
           Source: "require(m_isCirculating)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier m_isCirculating
             Type: bool
             Source: "m_isCirculating"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public requiresCirculation returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "requiresCirculation"
       Gas costs: 0
       Source: "requiresCirculation"
      Identifier requiresCirculation
         Type: modifier ()
         Source: "requiresCirculation"
    Block
       Source: "{\r\n        return super.transfer(_to, _value);\r\n    }"
      Return
         Gas costs: 15
         Source: "return super.transfer(_to, _value)"
        FunctionCall
           Type: bool
           Source: "super.transfer(_to, _value)"
          MemberAccess to member transfer
             Type: function (address,uint256) returns (bool)
             Source: "super.transfer"
            Identifier super
               Type: contract super CirculatingToken
               Source: "super"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public requiresCirculation returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "requiresCirculation"
       Gas costs: 0
       Source: "requiresCirculation"
      Identifier requiresCirculation
         Type: modifier ()
         Source: "requiresCirculation"
    Block
       Source: "{\r\n        return super.transferFrom(_from, _to, _value);\r\n    }"
      Return
         Gas costs: 18
         Source: "return super.transferFrom(_from, _to, _value)"
        FunctionCall
           Type: bool
           Source: "super.transferFrom(_from, _to, _value)"
          MemberAccess to member transferFrom
             Type: function (address,address,uint256) returns (bool)
             Source: "super.transferFrom"
            Identifier super
               Type: contract super CirculatingToken
               Source: "super"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public requiresCirculation returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "requiresCirculation"
       Gas costs: 0
       Source: "requiresCirculation"
      Identifier requiresCirculation
         Type: modifier ()
         Source: "requiresCirculation"
    Block
       Source: "{\r\n        return super.approve(_spender, _value);\r\n    }"
      Return
         Gas costs: 15
         Source: "return super.approve(_spender, _value)"
        FunctionCall
           Type: bool
           Source: "super.approve(_spender, _value)"
          MemberAccess to member approve
             Type: function (address,uint256) returns (bool)
             Source: "super.approve"
            Identifier super
               Type: contract super CirculatingToken
               Source: "super"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "enableCirculation"
     Source: "function enableCirculation() internal returns (bool) {\r\n        if (m_isCirculating)\r\n            return false;\r\n\r\n        m_isCirculating = true;\r\n        CirculationEnabled();\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if (m_isCirculating)\r\n            return false;\r\n\r\n        m_isCirculating = true;\r\n        CirculationEnabled();\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (m_isCirculating)\r\n            return false"
        Identifier m_isCirculating
           Type: bool
           Gas costs: 239
           Source: "m_isCirculating"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 20267
         Source: "m_isCirculating = true"
        Assignment using operator =
           Type: bool
           Source: "m_isCirculating = true"
          Identifier m_isCirculating
             Type: bool
             Source: "m_isCirculating"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 786
         Source: "CirculationEnabled()"
        FunctionCall
           Type: tuple()
           Source: "CirculationEnabled()"
          Identifier CirculationEnabled
             Type: function ()
             Source: "CirculationEnabled"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  VariableDeclaration "m_isCirculating"
     Type: bool
     Gas costs: [???]
     Source: "bool public m_isCirculating"
    ElementaryTypeName bool
       Source: "bool"
ContractDefinition "SmartzToken"
   Source: "contract SmartzToken is CirculatingToken, MintableMultiownedToken {\r\n\r\n    event Burn(address indexed from, uint256 amount);\r\n\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    /**\r\n     * @notice Constructs token.\r\n     *\r\n     * @param _initialOwners initial multi-signatures, see comment below\r\n     * @param _signaturesRequired quorum of multi-signatures\r\n     *\r\n     * Initial owners have power over the token contract only during bootstrap phase (early investments and token\r\n     * sales). After final token sale any control over the token removed by issuing detachControllerForever call.\r\n     * For lifecycle example please see test/SmartzTokenTest.js, 'test full lifecycle'.\r\n     */\r\n    function SmartzToken(address[] _initialOwners, uint _signaturesRequired)\r\n        public\r\n        MintableMultiownedToken(_initialOwners, _signaturesRequired, address(0))\r\n    {\r\n    }\r\n\r\n    /**\r\n     * Function to burn msg.sender's tokens.\r\n     *\r\n     * @param _amount The amount of tokens to burn\r\n     *\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function burn(uint256 _amount) public returns (bool) {\r\n        address from = msg.sender;\r\n        require(_amount > 0);\r\n        require(_amount <= balances[from]);\r\n\r\n        totalSupply = totalSupply.sub(_amount);\r\n        balances[from] = balances[from].sub(_amount);\r\n        Burn(from, _amount);\r\n        Transfer(from, address(0), _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Approves spending tokens and immediately triggers token recipient logic.\r\n     *\r\n     * @param _spender contract which supports IApprovalRecipient and allowed to receive tokens\r\n     * @param _value amount of tokens approved to be spent\r\n     * @param _extraData any extra data which to be provided to the _spender\r\n     *\r\n     * By invoking this utility function token holder could do two things in one transaction: approve spending his\r\n     * tokens and execute some external contract which spends them on token holder's behalf.\r\n     * It can't be known if _spender's invocation succeed or not.\r\n     * This function will throw if approval failed.\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public {\r\n        require(approve(_spender, _value));\r\n        IApprovalRecipient(_spender).receiveApproval(msg.sender, _value, _extraData);\r\n    }\r\n\r\n\r\n    // ADMINISTRATIVE FUNCTIONS\r\n\r\n    function startCirculation() external onlyController returns (bool) {\r\n        return enableCirculation();\r\n    }\r\n\r\n\r\n    // CONSTANTS\r\n\r\n    string public constant name = \"Smartz token\";\r\n    string public constant symbol = \"SMR\";\r\n    uint8 public constant decimals = 18;\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "CirculatingToken"
    UserDefinedTypeName "CirculatingToken"
       Source: "CirculatingToken"
  InheritanceSpecifier
     Gas costs: 0
     Source: "MintableMultiownedToken"
    UserDefinedTypeName "MintableMultiownedToken"
       Source: "MintableMultiownedToken"
  EventDefinition "Burn"
     Gas costs: 0
     Source: "event Burn(address indexed from, uint256 amount);"
    ParameterList
       Source: "(address indexed from, uint256 amount)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "SmartzToken" - public
     Source: "function SmartzToken(address[] _initialOwners, uint _signaturesRequired)\r\n        public\r\n        MintableMultiownedToken(_initialOwners, _signaturesRequired, address(0))\r\n    {\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _initialOwners, uint _signaturesRequired)"
      VariableDeclaration "_initialOwners"
         Type: address[] memory
         Source: "address[] _initialOwners"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_signaturesRequired"
         Type: uint256
         Source: "uint _signaturesRequired"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "MintableMultiownedToken"
       Gas costs: 0
       Source: "MintableMultiownedToken(_initialOwners, _signaturesRequired, address(0))"
      Identifier MintableMultiownedToken
         Type: type(contract MintableMultiownedToken)
         Source: "MintableMultiownedToken"
      Identifier _initialOwners
         Type: address[] memory
         Source: "_initialOwners"
      Identifier _signaturesRequired
         Type: uint256
         Source: "_signaturesRequired"
      FunctionCall
         Type: address
         Source: "address(0)"
        ElementaryTypeNameExpression address
           Type: type(address)
           Source: "address"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
    Block
       Gas costs: 0
       Source: "{\r\n    }"
  FunctionDefinition "burn" - public
     Source: "function burn(uint256 _amount) public returns (bool) {\r\n        address from = msg.sender;\r\n        require(_amount > 0);\r\n        require(_amount <= balances[from]);\r\n\r\n        totalSupply = totalSupply.sub(_amount);\r\n        balances[from] = balances[from].sub(_amount);\r\n        Burn(from, _amount);\r\n        Transfer(from, address(0), _amount);\r\n\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _amount)"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        address from = msg.sender;\r\n        require(_amount > 0);\r\n        require(_amount <= balances[from]);\r\n\r\n        totalSupply = totalSupply.sub(_amount);\r\n        balances[from] = balances[from].sub(_amount);\r\n        Burn(from, _amount);\r\n        Transfer(from, address(0), _amount);\r\n\r\n        return true;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "address from = msg.sender"
        VariableDeclaration "from"
           Type: address
           Source: "address from"
          ElementaryTypeName address
             Source: "address"
        MemberAccess to member sender
           Type: address
           Source: "msg.sender"
          Identifier msg
             Type: msg
             Source: "msg"
      ExpressionStatement
         Gas costs: 35
         Source: "require(_amount > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_amount > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "_amount > 0"
            Identifier _amount
               Type: uint256
               Source: "_amount"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 334
         Source: "require(_amount <= balances[from])"
        FunctionCall
           Type: tuple()
           Source: "require(_amount <= balances[from])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_amount <= balances[from]"
            Identifier _amount
               Type: uint256
               Source: "_amount"
            IndexAccess
               Type: uint256
               Source: "balances[from]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier from
                 Type: address
                 Source: "from"
      ExpressionStatement
         Gas costs: 20247
         Source: "totalSupply = totalSupply.sub(_amount)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = totalSupply.sub(_amount)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "totalSupply.sub(_amount)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "totalSupply.sub"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 20439
         Source: "balances[from] = balances[from].sub(_amount)"
        Assignment using operator =
           Type: uint256
           Source: "balances[from] = balances[from].sub(_amount)"
          IndexAccess
             Type: uint256
             Source: "balances[from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier from
               Type: address
               Source: "from"
          FunctionCall
             Type: uint256
             Source: "balances[from].sub(_amount)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[from].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier from
                   Type: address
                   Source: "from"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Burn(from, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Burn(from, _amount)"
          Identifier Burn
             Type: function (address,uint256)
             Source: "Burn"
          Identifier from
             Type: address
             Source: "from"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(from, address(0), _amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(from, address(0), _amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier from
             Type: address
             Source: "from"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approveAndCall" - public
     Source: "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public {\r\n        require(approve(_spender, _value));\r\n        IApprovalRecipient(_spender).receiveApproval(msg.sender, _value, _extraData);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value, bytes _extraData)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(approve(_spender, _value));\r\n        IApprovalRecipient(_spender).receiveApproval(msg.sender, _value, _extraData);\r\n    }"
      ExpressionStatement
         Gas costs: 47
         Source: "require(approve(_spender, _value))"
        FunctionCall
           Type: tuple()
           Source: "require(approve(_spender, _value))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "approve(_spender, _value)"
            Identifier approve
               Type: function (address,uint256) returns (bool)
               Source: "approve"
            Identifier _spender
               Type: address
               Source: "_spender"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "IApprovalRecipient(_spender).receiveApproval(msg.sender, _value, _extraData)"
        FunctionCall
           Type: tuple()
           Source: "IApprovalRecipient(_spender).receiveApproval(msg.sender, _value, _extraData)"
          MemberAccess to member receiveApproval
             Type: function (address,uint256,bytes memory) external
             Source: "IApprovalRecipient(_spender).receiveApproval"
            FunctionCall
               Type: contract IApprovalRecipient
               Source: "IApprovalRecipient(_spender)"
              Identifier IApprovalRecipient
                 Type: type(contract IApprovalRecipient)
                 Source: "IApprovalRecipient"
              Identifier _spender
                 Type: address
                 Source: "_spender"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier _extraData
             Type: bytes memory
             Source: "_extraData"
  FunctionDefinition "startCirculation" - public
     Source: "function startCirculation() external onlyController returns (bool) {\r\n        return enableCirculation();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyController"
       Gas costs: 0
       Source: "onlyController"
      Identifier onlyController
         Type: modifier ()
         Source: "onlyController"
    Block
       Source: "{\r\n        return enableCirculation();\r\n    }"
      Return
         Gas costs: 9
         Source: "return enableCirculation()"
        FunctionCall
           Type: bool
           Source: "enableCirculation()"
          Identifier enableCirculation
             Type: function () returns (bool)
             Source: "enableCirculation"
  VariableDeclaration "name"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant name = \"Smartz token\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Smartz token
       Type: literal_string "Smartz token"
       Source: "\"Smartz token\""
  VariableDeclaration "symbol"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant symbol = \"SMR\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: SMR
       Type: literal_string "SMR"
       Source: "\"SMR\""
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: [???]
     Source: "uint8 public constant decimals = 18"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
