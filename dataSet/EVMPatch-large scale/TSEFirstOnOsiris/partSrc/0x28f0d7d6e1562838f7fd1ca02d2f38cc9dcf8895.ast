Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x28f0d7d6e1562838f7fd1ca02d2f38cc9dcf8895.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.8;"
ContractDefinition "SafeMath"
   Source: "contract SafeMath {\r\n    function safeDiv(uint a, uint b) internal returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x + y;\r\n        assert((z >= x) && (z >= y));\r\n        return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n        assert(x >= y);\r\n        uint256 z = x - y;\r\n        return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0)||(z/x == y));\r\n        return z;\r\n    }\r\n}"
  FunctionDefinition "safeDiv"
     Source: "function safeDiv(uint a, uint b) internal returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }"
      ExpressionStatement
         Gas costs: 29
         Source: "assert(b > 0)"
        FunctionCall
           Type: tuple()
           Source: "assert(b > 0)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >
             Type: bool
             Source: "b > 0"
            Identifier b
               Type: uint256
               Source: "b"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 74
         Source: "assert(a == b * c + a % b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == b * c + a % b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "a == b * c + a % b"
            Identifier a
               Type: uint256
               Source: "a"
            BinaryOperation using operator +
               Type: uint256
               Source: "b * c + a % b"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "b * c"
                Identifier b
                   Type: uint256
                   Source: "b"
                Identifier c
                   Type: uint256
                   Source: "c"
              BinaryOperation using operator %
                 Type: uint256
                 Source: "a % b"
                Identifier a
                   Type: uint256
                   Source: "a"
                Identifier b
                   Type: uint256
                   Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "safeAdd"
     Source: "function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x + y;\r\n        assert((z >= x) && (z >= y));\r\n        return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        uint256 z = x + y;\r\n        assert((z >= x) && (z >= y));\r\n        return z;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 z = x + y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "x + y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
      ExpressionStatement
         Gas costs: 66
         Source: "assert((z >= x) && (z >= y))"
        FunctionCall
           Type: tuple()
           Source: "assert((z >= x) && (z >= y))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator &&
             Type: bool
             Source: "(z >= x) && (z >= y)"
            TupleExpression
               Type: bool
               Source: "(z >= x)"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "z >= x"
                Identifier z
                   Type: uint256
                   Source: "z"
                Identifier x
                   Type: uint256
                   Source: "x"
            TupleExpression
               Type: bool
               Source: "(z >= y)"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "z >= y"
                Identifier z
                   Type: uint256
                   Source: "z"
                Identifier y
                   Type: uint256
                   Source: "y"
      Return
         Gas costs: 8
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
  FunctionDefinition "safeSubtract"
     Source: "function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n        assert(x >= y);\r\n        uint256 z = x - y;\r\n        return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        assert(x >= y);\r\n        uint256 z = x - y;\r\n        return z;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(x >= y)"
        FunctionCall
           Type: tuple()
           Source: "assert(x >= y)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "x >= y"
            Identifier x
               Type: uint256
               Source: "x"
            Identifier y
               Type: uint256
               Source: "y"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 z = x - y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator -
           Type: uint256
           Source: "x - y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
      Return
         Gas costs: 0
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
  FunctionDefinition "safeMult"
     Source: "function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0)||(z/x == y));\r\n        return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        uint256 z = x * y;\r\n        assert((x == 0)||(z/x == y));\r\n        return z;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint256 z = x * y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "x * y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
      ExpressionStatement
         Gas costs: 88
         Source: "assert((x == 0)||(z/x == y))"
        FunctionCall
           Type: tuple()
           Source: "assert((x == 0)||(z/x == y))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "(x == 0)||(z/x == y)"
            TupleExpression
               Type: bool
               Source: "(x == 0)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "x == 0"
                Identifier x
                   Type: uint256
                   Source: "x"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            TupleExpression
               Type: bool
               Source: "(z/x == y)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "z/x == y"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "z/x"
                  Identifier z
                     Type: uint256
                     Source: "z"
                  Identifier x
                     Type: uint256
                     Source: "x"
                Identifier y
                   Type: uint256
                   Source: "y"
      Return
         Gas costs: 8
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
ContractDefinition "Token"
   Gas costs: [???]
   Source: "contract Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is Token {\r\n\r\n    uint256 constant MAX_UINT256 = 2**256 - 1;\r\n\r\n    bool public isFrozen;              // switched to true in frozen state\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (isFrozen) revert();\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (isFrozen) revert();\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Token"
    UserDefinedTypeName "Token"
       Source: "Token"
  VariableDeclaration "MAX_UINT256"
     Type: uint256
     Gas costs: 3
     Source: "uint256 constant MAX_UINT256 = 2**256 - 1"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator -
       Type: int_const 1157...(70 digits omitted)...9935
       Source: "2**256 - 1"
      BinaryOperation using operator **
         Type: int_const 1157...(70 digits omitted)...9936
         Source: "2**256"
        Literal, token: [no token] value: 2
           Type: int_const 2
           Source: "2"
        Literal, token: [no token] value: 256
           Type: int_const 256
           Source: "256"
      Literal, token: [no token] value: 1
         Type: int_const 1
         Source: "1"
  VariableDeclaration "isFrozen"
     Type: bool
     Gas costs: [???]
     Source: "bool public isFrozen"
    ElementaryTypeName bool
       Source: "bool"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (isFrozen) revert();\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if (isFrozen) revert();\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (isFrozen) revert()"
        Identifier isFrozen
           Type: bool
           Gas costs: 239
           Source: "isFrozen"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 333
         Source: "require(balances[msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20328
         Source: "balances[msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (isFrozen) revert();\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if (isFrozen) revert();\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (isFrozen) revert()"
        Identifier isFrozen
           Type: bool
           Gas costs: 239
           Source: "isFrozen"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      VariableDeclarationStatement
         Gas costs: 396
         Source: "uint256 allowance = allowed[_from][msg.sender]"
        VariableDeclaration "allowance"
           Type: uint256
           Source: "uint256 allowance"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "allowed[_from][msg.sender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_from]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _from
               Type: address
               Source: "_from"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 362
         Source: "require(balances[_from] >= _value && allowance >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_from] >= _value && allowance >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "balances[_from] >= _value && allowance >= _value"
            BinaryOperation using operator >=
               Type: bool
               Source: "balances[_from] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            BinaryOperation using operator >=
               Type: bool
               Source: "allowance >= _value"
              Identifier allowance
                 Type: uint256
                 Source: "allowance"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balances[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      IfStatement
         Source: "if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 6
           Source: "allowance < MAX_UINT256"
          Identifier allowance
             Type: uint256
             Source: "allowance"
          Identifier MAX_UINT256
             Type: uint256
             Source: "MAX_UINT256"
        Block
           Source: "{\r\n            allowed[_from][msg.sender] -= _value;\r\n        }"
          ExpressionStatement
             Gas costs: 20418
             Source: "allowed[_from][msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "allowed[_from][msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balances[_owner];\r\n    }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balances"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "PreAdsMobileToken"
   Source: "contract PreAdsMobileToken is StandardToken, SafeMath {\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n        NOTE:\r\n        The following variables are OPTIONAL vanities. One does not have to include them.\r\n        They allow one to customise the token contract & in no way influences the core functionality.\r\n        Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals = 18;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n    // contracts\r\n    address public ethFundDeposit;      // deposit address for ETH for AdsMobile\r\n\r\n    // crowdsale parameters\r\n    bool public isFinalized;              // switched to true in operational state\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n    uint256 public checkNumber;\r\n    uint256 public totalSupplyWithOutBonus;\r\n    uint256 public constant tokenExchangeRate               = 400; // 400 AdsMobile tokens per 1 ETH\r\n    uint256 public constant tokenCreationCapWithOutBonus    = 400 * 10**18;\r\n    uint256 public constant tokenNeedForBonusLevel0         = 2 * 10**17; // 0.2\r\n    uint256 public constant bonusLevel0PercentModifier      = 300;\r\n    uint256 public constant tokenNeedForBonusLevel1         = 1 * 10**17; // 0.1\r\n    uint256 public constant bonusLevel1PercentModifier      = 200;\r\n    uint256 public constant tokenCreationMinPayment         = 1 * 10**17; // 0.1\r\n\r\n    // events\r\n    event CreateAds(address indexed _to, uint256 _value);\r\n\r\n    // constructor\r\n    function PreAdsMobileToken(\r\n    string _tokenName,\r\n    string _tokenSymbol,\r\n    address _ethFundDeposit,\r\n    uint256 _fundingStartBlock,\r\n    uint256 _fundingEndBlock\r\n    )\r\n    {\r\n        balances[msg.sender] = 0;               // Give the creator all initial tokens\r\n        totalSupply = 0;                        // Update total supply\r\n        name = _tokenName;           // Set the name for display purposes\r\n        decimals = 18;                          // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                        // Set the symbol for display purposes\r\n        isFinalized = false;                    // controls pre through crowdsale state\r\n        isFrozen = false;\r\n        ethFundDeposit = _ethFundDeposit;\r\n        fundingStartBlock = _fundingStartBlock;\r\n        fundingEndBlock = _fundingEndBlock;\r\n        checkNumber = 42;                       //Answer to the Ultimate Question of Life, the Universe, and Everything\r\n    }\r\n\r\n    /// @dev Accepts ether and creates new ADS tokens.\r\n    function createTokens() public payable {\r\n        if (isFinalized) revert();\r\n        if (block.number < fundingStartBlock) revert();\r\n        if (block.number > fundingEndBlock) revert();\r\n        if (msg.value == 0) revert();\r\n        uint256 tokensWithOutBonus = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\r\n        if (tokensWithOutBonus < tokenCreationMinPayment) revert();\r\n        uint256 checkedSupplyWithOutBonus = safeAdd(totalSupplyWithOutBonus, tokensWithOutBonus);\r\n        // return money if something goes wrong\r\n        if (tokenCreationCapWithOutBonus < checkedSupplyWithOutBonus) revert();  // odd fractions won't be found\r\n        totalSupplyWithOutBonus = checkedSupplyWithOutBonus;\r\n\r\n        uint256 tokens = tokensWithOutBonus;\r\n        if(tokens >= tokenNeedForBonusLevel0) {\r\n            tokens = safeDiv(tokens, 100);\r\n            tokens = safeMult(tokens, bonusLevel0PercentModifier);\r\n        } else {\r\n            if(tokens >= tokenNeedForBonusLevel1) {\r\n                tokens = safeDiv(tokens, 100);\r\n                tokens = safeMult(tokens, bonusLevel1PercentModifier);\r\n            }\r\n        }\r\n        uint256 checkedSupply = safeAdd(totalSupply, tokens);\r\n        totalSupply = checkedSupply;\r\n        balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n        CreateAds(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n    //just for test cashin and cashout on small amount before let it go\r\n    function cashin() external payable {\r\n        if (isFinalized) revert();\r\n    }\r\n\r\n    function cashout(uint256 amount) external {\r\n        if (isFinalized) revert();\r\n        if (msg.sender != ethFundDeposit) revert(); // locks finalize to the ultimate ETH owner\r\n        if (!ethFundDeposit.send(amount)) revert();  // send the eth to AdsMobile\r\n    }\r\n\r\n    //in case we want to transfer token to other contract we need freeze all future transfers\r\n    function freeze() external {\r\n        if (msg.sender != ethFundDeposit) revert(); // locks finalize to the ultimate ETH owner\r\n        isFrozen = true;\r\n    }\r\n\r\n    function unFreeze() external {\r\n        if (msg.sender != ethFundDeposit) revert(); // locks finalize to the ultimate ETH owner\r\n        isFrozen = false;\r\n    }\r\n\r\n    /// @dev Ends the funding period and sends the ETH home\r\n    function finalize() external {\r\n        if (isFinalized) revert();\r\n        if (msg.sender != ethFundDeposit) revert(); // locks finalize to the ultimate ETH owner\r\n        if (block.number <= fundingEndBlock && totalSupplyWithOutBonus < tokenCreationCapWithOutBonus - tokenCreationMinPayment) revert();\r\n        // move to operational\r\n        if (!ethFundDeposit.send(this.balance)) revert();  // send the eth to AdsMobile\r\n        isFinalized = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function which receives ether and created the appropriate number of tokens for the\r\n     * msg.sender.\r\n     */\r\n    function() external payable {\r\n        createTokens();\r\n    }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public name"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: [???]
     Source: "uint8 public decimals = 18"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public symbol"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "version"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public version = 'H0.1'"
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: H0.1
       Type: literal_string "H0.1"
       Source: "'H0.1'"
  VariableDeclaration "ethFundDeposit"
     Type: address
     Gas costs: [???]
     Source: "address public ethFundDeposit"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "isFinalized"
     Type: bool
     Gas costs: [???]
     Source: "bool public isFinalized"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "fundingStartBlock"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public fundingStartBlock"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "fundingEndBlock"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public fundingEndBlock"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "checkNumber"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public checkNumber"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "totalSupplyWithOutBonus"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public totalSupplyWithOutBonus"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "tokenExchangeRate"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant tokenExchangeRate               = 400"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 400
       Type: int_const 400
       Source: "400"
  VariableDeclaration "tokenCreationCapWithOutBonus"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant tokenCreationCapWithOutBonus    = 400 * 10**18"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator *
       Type: int_const 400000000000000000000
       Source: "400 * 10**18"
      Literal, token: [no token] value: 400
         Type: int_const 400
         Source: "400"
      BinaryOperation using operator **
         Type: int_const 1000000000000000000
         Source: "10**18"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Literal, token: [no token] value: 18
           Type: int_const 18
           Source: "18"
  VariableDeclaration "tokenNeedForBonusLevel0"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant tokenNeedForBonusLevel0         = 2 * 10**17"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator *
       Type: int_const 200000000000000000
       Source: "2 * 10**17"
      Literal, token: [no token] value: 2
         Type: int_const 2
         Source: "2"
      BinaryOperation using operator **
         Type: int_const 100000000000000000
         Source: "10**17"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Literal, token: [no token] value: 17
           Type: int_const 17
           Source: "17"
  VariableDeclaration "bonusLevel0PercentModifier"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant bonusLevel0PercentModifier      = 300"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 300
       Type: int_const 300
       Source: "300"
  VariableDeclaration "tokenNeedForBonusLevel1"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant tokenNeedForBonusLevel1         = 1 * 10**17"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator *
       Type: int_const 100000000000000000
       Source: "1 * 10**17"
      Literal, token: [no token] value: 1
         Type: int_const 1
         Source: "1"
      BinaryOperation using operator **
         Type: int_const 100000000000000000
         Source: "10**17"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Literal, token: [no token] value: 17
           Type: int_const 17
           Source: "17"
  VariableDeclaration "bonusLevel1PercentModifier"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant bonusLevel1PercentModifier      = 200"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 200
       Type: int_const 200
       Source: "200"
  VariableDeclaration "tokenCreationMinPayment"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant tokenCreationMinPayment         = 1 * 10**17"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator *
       Type: int_const 100000000000000000
       Source: "1 * 10**17"
      Literal, token: [no token] value: 1
         Type: int_const 1
         Source: "1"
      BinaryOperation using operator **
         Type: int_const 100000000000000000
         Source: "10**17"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Literal, token: [no token] value: 17
           Type: int_const 17
           Source: "17"
  EventDefinition "CreateAds"
     Gas costs: 0
     Source: "event CreateAds(address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "PreAdsMobileToken" - public
     Source: "function PreAdsMobileToken(\r\n    string _tokenName,\r\n    string _tokenSymbol,\r\n    address _ethFundDeposit,\r\n    uint256 _fundingStartBlock,\r\n    uint256 _fundingEndBlock\r\n    )\r\n    {\r\n        balances[msg.sender] = 0;               // Give the creator all initial tokens\r\n        totalSupply = 0;                        // Update total supply\r\n        name = _tokenName;           // Set the name for display purposes\r\n        decimals = 18;                          // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                        // Set the symbol for display purposes\r\n        isFinalized = false;                    // controls pre through crowdsale state\r\n        isFrozen = false;\r\n        ethFundDeposit = _ethFundDeposit;\r\n        fundingStartBlock = _fundingStartBlock;\r\n        fundingEndBlock = _fundingEndBlock;\r\n        checkNumber = 42;                       //Answer to the Ultimate Question of Life, the Universe, and Everything\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n    string _tokenName,\r\n    string _tokenSymbol,\r\n    address _ethFundDeposit,\r\n    uint256 _fundingStartBlock,\r\n    uint256 _fundingEndBlock\r\n    )"
      VariableDeclaration "_tokenName"
         Type: string memory
         Source: "string _tokenName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_tokenSymbol"
         Type: string memory
         Source: "string _tokenSymbol"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_ethFundDeposit"
         Type: address
         Source: "address _ethFundDeposit"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_fundingStartBlock"
         Type: uint256
         Source: "uint256 _fundingStartBlock"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_fundingEndBlock"
         Type: uint256
         Source: "uint256 _fundingEndBlock"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        balances[msg.sender] = 0;               // Give the creator all initial tokens\r\n        totalSupply = 0;                        // Update total supply\r\n        name = _tokenName;           // Set the name for display purposes\r\n        decimals = 18;                          // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                        // Set the symbol for display purposes\r\n        isFinalized = false;                    // controls pre through crowdsale state\r\n        isFrozen = false;\r\n        ethFundDeposit = _ethFundDeposit;\r\n        fundingStartBlock = _fundingStartBlock;\r\n        fundingEndBlock = _fundingEndBlock;\r\n        checkNumber = 42;                       //Answer to the Ultimate Question of Life, the Universe, and Everything\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] = 0"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = 0"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = 0"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = 0"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "name = _tokenName"
        Assignment using operator =
           Type: string storage ref
           Source: "name = _tokenName"
          Identifier name
             Type: string storage ref
             Source: "name"
          Identifier _tokenName
             Type: string memory
             Source: "_tokenName"
      ExpressionStatement
         Gas costs: 0
         Source: "decimals = 18"
        Assignment using operator =
           Type: uint8
           Source: "decimals = 18"
          Identifier decimals
             Type: uint8
             Source: "decimals"
          Literal, token: [no token] value: 18
             Type: int_const 18
             Source: "18"
      ExpressionStatement
         Gas costs: 0
         Source: "symbol = _tokenSymbol"
        Assignment using operator =
           Type: string storage ref
           Source: "symbol = _tokenSymbol"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
          Identifier _tokenSymbol
             Type: string memory
             Source: "_tokenSymbol"
      ExpressionStatement
         Gas costs: 0
         Source: "isFinalized = false"
        Assignment using operator =
           Type: bool
           Source: "isFinalized = false"
          Identifier isFinalized
             Type: bool
             Source: "isFinalized"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 0
         Source: "isFrozen = false"
        Assignment using operator =
           Type: bool
           Source: "isFrozen = false"
          Identifier isFrozen
             Type: bool
             Source: "isFrozen"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 0
         Source: "ethFundDeposit = _ethFundDeposit"
        Assignment using operator =
           Type: address
           Source: "ethFundDeposit = _ethFundDeposit"
          Identifier ethFundDeposit
             Type: address
             Source: "ethFundDeposit"
          Identifier _ethFundDeposit
             Type: address
             Source: "_ethFundDeposit"
      ExpressionStatement
         Gas costs: 0
         Source: "fundingStartBlock = _fundingStartBlock"
        Assignment using operator =
           Type: uint256
           Source: "fundingStartBlock = _fundingStartBlock"
          Identifier fundingStartBlock
             Type: uint256
             Source: "fundingStartBlock"
          Identifier _fundingStartBlock
             Type: uint256
             Source: "_fundingStartBlock"
      ExpressionStatement
         Gas costs: 0
         Source: "fundingEndBlock = _fundingEndBlock"
        Assignment using operator =
           Type: uint256
           Source: "fundingEndBlock = _fundingEndBlock"
          Identifier fundingEndBlock
             Type: uint256
             Source: "fundingEndBlock"
          Identifier _fundingEndBlock
             Type: uint256
             Source: "_fundingEndBlock"
      ExpressionStatement
         Gas costs: 0
         Source: "checkNumber = 42"
        Assignment using operator =
           Type: uint256
           Source: "checkNumber = 42"
          Identifier checkNumber
             Type: uint256
             Source: "checkNumber"
          Literal, token: [no token] value: 42
             Type: int_const 42
             Source: "42"
  FunctionDefinition "createTokens" - public
     Source: "function createTokens() public payable {\r\n        if (isFinalized) revert();\r\n        if (block.number < fundingStartBlock) revert();\r\n        if (block.number > fundingEndBlock) revert();\r\n        if (msg.value == 0) revert();\r\n        uint256 tokensWithOutBonus = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\r\n        if (tokensWithOutBonus < tokenCreationMinPayment) revert();\r\n        uint256 checkedSupplyWithOutBonus = safeAdd(totalSupplyWithOutBonus, tokensWithOutBonus);\r\n        // return money if something goes wrong\r\n        if (tokenCreationCapWithOutBonus < checkedSupplyWithOutBonus) revert();  // odd fractions won't be found\r\n        totalSupplyWithOutBonus = checkedSupplyWithOutBonus;\r\n\r\n        uint256 tokens = tokensWithOutBonus;\r\n        if(tokens >= tokenNeedForBonusLevel0) {\r\n            tokens = safeDiv(tokens, 100);\r\n            tokens = safeMult(tokens, bonusLevel0PercentModifier);\r\n        } else {\r\n            if(tokens >= tokenNeedForBonusLevel1) {\r\n                tokens = safeDiv(tokens, 100);\r\n                tokens = safeMult(tokens, bonusLevel1PercentModifier);\r\n            }\r\n        }\r\n        uint256 checkedSupply = safeAdd(totalSupply, tokens);\r\n        totalSupply = checkedSupply;\r\n        balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n        CreateAds(msg.sender, tokens);  // logs token creation\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (isFinalized) revert();\r\n        if (block.number < fundingStartBlock) revert();\r\n        if (block.number > fundingEndBlock) revert();\r\n        if (msg.value == 0) revert();\r\n        uint256 tokensWithOutBonus = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\r\n        if (tokensWithOutBonus < tokenCreationMinPayment) revert();\r\n        uint256 checkedSupplyWithOutBonus = safeAdd(totalSupplyWithOutBonus, tokensWithOutBonus);\r\n        // return money if something goes wrong\r\n        if (tokenCreationCapWithOutBonus < checkedSupplyWithOutBonus) revert();  // odd fractions won't be found\r\n        totalSupplyWithOutBonus = checkedSupplyWithOutBonus;\r\n\r\n        uint256 tokens = tokensWithOutBonus;\r\n        if(tokens >= tokenNeedForBonusLevel0) {\r\n            tokens = safeDiv(tokens, 100);\r\n            tokens = safeMult(tokens, bonusLevel0PercentModifier);\r\n        } else {\r\n            if(tokens >= tokenNeedForBonusLevel1) {\r\n                tokens = safeDiv(tokens, 100);\r\n                tokens = safeMult(tokens, bonusLevel1PercentModifier);\r\n            }\r\n        }\r\n        uint256 checkedSupply = safeAdd(totalSupply, tokens);\r\n        totalSupply = checkedSupply;\r\n        balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n        CreateAds(msg.sender, tokens);  // logs token creation\r\n    }"
      IfStatement
         Source: "if (isFinalized) revert()"
        Identifier isFinalized
           Type: bool
           Gas costs: 289
           Source: "isFinalized"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      IfStatement
         Source: "if (block.number < fundingStartBlock) revert()"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 208
           Source: "block.number < fundingStartBlock"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          Identifier fundingStartBlock
             Type: uint256
             Source: "fundingStartBlock"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      IfStatement
         Source: "if (block.number > fundingEndBlock) revert()"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 208
           Source: "block.number > fundingEndBlock"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          Identifier fundingEndBlock
             Type: uint256
             Source: "fundingEndBlock"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      IfStatement
         Source: "if (msg.value == 0) revert()"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 8
           Source: "msg.value == 0"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      VariableDeclarationStatement
         Gas costs: 14
         Source: "uint256 tokensWithOutBonus = safeMult(msg.value, tokenExchangeRate)"
        VariableDeclaration "tokensWithOutBonus"
           Type: uint256
           Source: "uint256 tokensWithOutBonus"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "safeMult(msg.value, tokenExchangeRate)"
          Identifier safeMult
             Type: function (uint256,uint256) returns (uint256)
             Source: "safeMult"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier tokenExchangeRate
             Type: uint256
             Source: "tokenExchangeRate"
      IfStatement
         Source: "if (tokensWithOutBonus < tokenCreationMinPayment) revert()"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 6
           Source: "tokensWithOutBonus < tokenCreationMinPayment"
          Identifier tokensWithOutBonus
             Type: uint256
             Source: "tokensWithOutBonus"
          Identifier tokenCreationMinPayment
             Type: uint256
             Source: "tokenCreationMinPayment"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      VariableDeclarationStatement
         Gas costs: 218
         Source: "uint256 checkedSupplyWithOutBonus = safeAdd(totalSupplyWithOutBonus, tokensWithOutBonus)"
        VariableDeclaration "checkedSupplyWithOutBonus"
           Type: uint256
           Source: "uint256 checkedSupplyWithOutBonus"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "safeAdd(totalSupplyWithOutBonus, tokensWithOutBonus)"
          Identifier safeAdd
             Type: function (uint256,uint256) returns (uint256)
             Source: "safeAdd"
          Identifier totalSupplyWithOutBonus
             Type: uint256
             Source: "totalSupplyWithOutBonus"
          Identifier tokensWithOutBonus
             Type: uint256
             Source: "tokensWithOutBonus"
      IfStatement
         Source: "if (tokenCreationCapWithOutBonus < checkedSupplyWithOutBonus) revert()"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 6
           Source: "tokenCreationCapWithOutBonus < checkedSupplyWithOutBonus"
          Identifier tokenCreationCapWithOutBonus
             Type: uint256
             Source: "tokenCreationCapWithOutBonus"
          Identifier checkedSupplyWithOutBonus
             Type: uint256
             Source: "checkedSupplyWithOutBonus"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 20014
         Source: "totalSupplyWithOutBonus = checkedSupplyWithOutBonus"
        Assignment using operator =
           Type: uint256
           Source: "totalSupplyWithOutBonus = checkedSupplyWithOutBonus"
          Identifier totalSupplyWithOutBonus
             Type: uint256
             Source: "totalSupplyWithOutBonus"
          Identifier checkedSupplyWithOutBonus
             Type: uint256
             Source: "checkedSupplyWithOutBonus"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint256 tokens = tokensWithOutBonus"
        VariableDeclaration "tokens"
           Type: uint256
           Source: "uint256 tokens"
          ElementaryTypeName uint256
             Source: "uint256"
        Identifier tokensWithOutBonus
           Type: uint256
           Source: "tokensWithOutBonus"
      IfStatement
         Source: "if(tokens >= tokenNeedForBonusLevel0) {\r\n            tokens = safeDiv(tokens, 100);\r\n            tokens = safeMult(tokens, bonusLevel0PercentModifier);\r\n        } else {\r\n            if(tokens >= tokenNeedForBonusLevel1) {\r\n                tokens = safeDiv(tokens, 100);\r\n                tokens = safeMult(tokens, bonusLevel1PercentModifier);\r\n            }\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 9
           Source: "tokens >= tokenNeedForBonusLevel0"
          Identifier tokens
             Type: uint256
             Source: "tokens"
          Identifier tokenNeedForBonusLevel0
             Type: uint256
             Source: "tokenNeedForBonusLevel0"
        Block
           Source: "{\r\n            tokens = safeDiv(tokens, 100);\r\n            tokens = safeMult(tokens, bonusLevel0PercentModifier);\r\n        }"
          ExpressionStatement
             Gas costs: 15
             Source: "tokens = safeDiv(tokens, 100)"
            Assignment using operator =
               Type: uint256
               Source: "tokens = safeDiv(tokens, 100)"
              Identifier tokens
                 Type: uint256
                 Source: "tokens"
              FunctionCall
                 Type: uint256
                 Source: "safeDiv(tokens, 100)"
                Identifier safeDiv
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "safeDiv"
                Identifier tokens
                   Type: uint256
                   Source: "tokens"
                Literal, token: [no token] value: 100
                   Type: int_const 100
                   Source: "100"
          ExpressionStatement
             Gas costs: 23
             Source: "tokens = safeMult(tokens, bonusLevel0PercentModifier)"
            Assignment using operator =
               Type: uint256
               Source: "tokens = safeMult(tokens, bonusLevel0PercentModifier)"
              Identifier tokens
                 Type: uint256
                 Source: "tokens"
              FunctionCall
                 Type: uint256
                 Source: "safeMult(tokens, bonusLevel0PercentModifier)"
                Identifier safeMult
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "safeMult"
                Identifier tokens
                   Type: uint256
                   Source: "tokens"
                Identifier bonusLevel0PercentModifier
                   Type: uint256
                   Source: "bonusLevel0PercentModifier"
        Block
           Source: "{\r\n            if(tokens >= tokenNeedForBonusLevel1) {\r\n                tokens = safeDiv(tokens, 100);\r\n                tokens = safeMult(tokens, bonusLevel1PercentModifier);\r\n            }\r\n        }"
          IfStatement
             Source: "if(tokens >= tokenNeedForBonusLevel1) {\r\n                tokens = safeDiv(tokens, 100);\r\n                tokens = safeMult(tokens, bonusLevel1PercentModifier);\r\n            }"
            BinaryOperation using operator >=
               Type: bool
               Gas costs: 9
               Source: "tokens >= tokenNeedForBonusLevel1"
              Identifier tokens
                 Type: uint256
                 Source: "tokens"
              Identifier tokenNeedForBonusLevel1
                 Type: uint256
                 Source: "tokenNeedForBonusLevel1"
            Block
               Source: "{\r\n                tokens = safeDiv(tokens, 100);\r\n                tokens = safeMult(tokens, bonusLevel1PercentModifier);\r\n            }"
              ExpressionStatement
                 Gas costs: 26
                 Source: "tokens = safeDiv(tokens, 100)"
                Assignment using operator =
                   Type: uint256
                   Source: "tokens = safeDiv(tokens, 100)"
                  Identifier tokens
                     Type: uint256
                     Source: "tokens"
                  FunctionCall
                     Type: uint256
                     Source: "safeDiv(tokens, 100)"
                    Identifier safeDiv
                       Type: function (uint256,uint256) returns (uint256)
                       Source: "safeDiv"
                    Identifier tokens
                       Type: uint256
                       Source: "tokens"
                    Literal, token: [no token] value: 100
                       Type: int_const 100
                       Source: "100"
              ExpressionStatement
                 Gas costs: 23
                 Source: "tokens = safeMult(tokens, bonusLevel1PercentModifier)"
                Assignment using operator =
                   Type: uint256
                   Source: "tokens = safeMult(tokens, bonusLevel1PercentModifier)"
                  Identifier tokens
                     Type: uint256
                     Source: "tokens"
                  FunctionCall
                     Type: uint256
                     Source: "safeMult(tokens, bonusLevel1PercentModifier)"
                    Identifier safeMult
                       Type: function (uint256,uint256) returns (uint256)
                       Source: "safeMult"
                    Identifier tokens
                       Type: uint256
                       Source: "tokens"
                    Identifier bonusLevel1PercentModifier
                       Type: uint256
                       Source: "bonusLevel1PercentModifier"
      VariableDeclarationStatement
         Gas costs: 229
         Source: "uint256 checkedSupply = safeAdd(totalSupply, tokens)"
        VariableDeclaration "checkedSupply"
           Type: uint256
           Source: "uint256 checkedSupply"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "safeAdd(totalSupply, tokens)"
          Identifier safeAdd
             Type: function (uint256,uint256) returns (uint256)
             Source: "safeAdd"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: 20014
         Source: "totalSupply = checkedSupply"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = checkedSupply"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier checkedSupply
             Type: uint256
             Source: "checkedSupply"
      ExpressionStatement
         Gas costs: 20328
         Source: "balances[msg.sender] += tokens"
        Assignment using operator +=
           Type: uint256
           Source: "balances[msg.sender] += tokens"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "CreateAds(msg.sender, tokens)"
        FunctionCall
           Type: tuple()
           Source: "CreateAds(msg.sender, tokens)"
          Identifier CreateAds
             Type: function (address,uint256)
             Source: "CreateAds"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier tokens
             Type: uint256
             Source: "tokens"
  FunctionDefinition "cashin" - public
     Source: "function cashin() external payable {\r\n        if (isFinalized) revert();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (isFinalized) revert();\r\n    }"
      IfStatement
         Source: "if (isFinalized) revert()"
        Identifier isFinalized
           Type: bool
           Gas costs: 289
           Source: "isFinalized"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
  FunctionDefinition "cashout" - public
     Source: "function cashout(uint256 amount) external {\r\n        if (isFinalized) revert();\r\n        if (msg.sender != ethFundDeposit) revert(); // locks finalize to the ultimate ETH owner\r\n        if (!ethFundDeposit.send(amount)) revert();  // send the eth to AdsMobile\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (isFinalized) revert();\r\n        if (msg.sender != ethFundDeposit) revert(); // locks finalize to the ultimate ETH owner\r\n        if (!ethFundDeposit.send(amount)) revert();  // send the eth to AdsMobile\r\n    }"
      IfStatement
         Source: "if (isFinalized) revert()"
        Identifier isFinalized
           Type: bool
           Gas costs: 289
           Source: "isFinalized"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      IfStatement
         Source: "if (msg.sender != ethFundDeposit) revert()"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != ethFundDeposit"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier ethFundDeposit
             Type: address
             Source: "ethFundDeposit"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      IfStatement
         Source: "if (!ethFundDeposit.send(amount)) revert()"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!ethFundDeposit.send(amount)"
          FunctionCall
             Type: bool
             Source: "ethFundDeposit.send(amount)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "ethFundDeposit.send"
              Identifier ethFundDeposit
                 Type: address
                 Source: "ethFundDeposit"
            Identifier amount
               Type: uint256
               Source: "amount"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
  FunctionDefinition "freeze" - public
     Source: "function freeze() external {\r\n        if (msg.sender != ethFundDeposit) revert(); // locks finalize to the ultimate ETH owner\r\n        isFrozen = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (msg.sender != ethFundDeposit) revert(); // locks finalize to the ultimate ETH owner\r\n        isFrozen = true;\r\n    }"
      IfStatement
         Source: "if (msg.sender != ethFundDeposit) revert()"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != ethFundDeposit"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier ethFundDeposit
             Type: address
             Source: "ethFundDeposit"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 20267
         Source: "isFrozen = true"
        Assignment using operator =
           Type: bool
           Source: "isFrozen = true"
          Identifier isFrozen
             Type: bool
             Source: "isFrozen"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "unFreeze" - public
     Source: "function unFreeze() external {\r\n        if (msg.sender != ethFundDeposit) revert(); // locks finalize to the ultimate ETH owner\r\n        isFrozen = false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (msg.sender != ethFundDeposit) revert(); // locks finalize to the ultimate ETH owner\r\n        isFrozen = false;\r\n    }"
      IfStatement
         Source: "if (msg.sender != ethFundDeposit) revert()"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != ethFundDeposit"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier ethFundDeposit
             Type: address
             Source: "ethFundDeposit"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 20267
         Source: "isFrozen = false"
        Assignment using operator =
           Type: bool
           Source: "isFrozen = false"
          Identifier isFrozen
             Type: bool
             Source: "isFrozen"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "finalize" - public
     Source: "function finalize() external {\r\n        if (isFinalized) revert();\r\n        if (msg.sender != ethFundDeposit) revert(); // locks finalize to the ultimate ETH owner\r\n        if (block.number <= fundingEndBlock && totalSupplyWithOutBonus < tokenCreationCapWithOutBonus - tokenCreationMinPayment) revert();\r\n        // move to operational\r\n        if (!ethFundDeposit.send(this.balance)) revert();  // send the eth to AdsMobile\r\n        isFinalized = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (isFinalized) revert();\r\n        if (msg.sender != ethFundDeposit) revert(); // locks finalize to the ultimate ETH owner\r\n        if (block.number <= fundingEndBlock && totalSupplyWithOutBonus < tokenCreationCapWithOutBonus - tokenCreationMinPayment) revert();\r\n        // move to operational\r\n        if (!ethFundDeposit.send(this.balance)) revert();  // send the eth to AdsMobile\r\n        isFinalized = true;\r\n    }"
      IfStatement
         Source: "if (isFinalized) revert()"
        Identifier isFinalized
           Type: bool
           Gas costs: 289
           Source: "isFinalized"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      IfStatement
         Source: "if (msg.sender != ethFundDeposit) revert()"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != ethFundDeposit"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier ethFundDeposit
             Type: address
             Source: "ethFundDeposit"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      IfStatement
         Source: "if (block.number <= fundingEndBlock && totalSupplyWithOutBonus < tokenCreationCapWithOutBonus - tokenCreationMinPayment) revert()"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 442
           Source: "block.number <= fundingEndBlock && totalSupplyWithOutBonus < tokenCreationCapWithOutBonus - tokenCreationMinPayment"
          BinaryOperation using operator <=
             Type: bool
             Source: "block.number <= fundingEndBlock"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier fundingEndBlock
               Type: uint256
               Source: "fundingEndBlock"
          BinaryOperation using operator <
             Type: bool
             Source: "totalSupplyWithOutBonus < tokenCreationCapWithOutBonus - tokenCreationMinPayment"
            Identifier totalSupplyWithOutBonus
               Type: uint256
               Source: "totalSupplyWithOutBonus"
            BinaryOperation using operator -
               Type: uint256
               Source: "tokenCreationCapWithOutBonus - tokenCreationMinPayment"
              Identifier tokenCreationCapWithOutBonus
                 Type: uint256
                 Source: "tokenCreationCapWithOutBonus"
              Identifier tokenCreationMinPayment
                 Type: uint256
                 Source: "tokenCreationMinPayment"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      IfStatement
         Source: "if (!ethFundDeposit.send(this.balance)) revert()"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!ethFundDeposit.send(this.balance)"
          FunctionCall
             Type: bool
             Source: "ethFundDeposit.send(this.balance)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "ethFundDeposit.send"
              Identifier ethFundDeposit
                 Type: address
                 Source: "ethFundDeposit"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract PreAdsMobileToken
                 Source: "this"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 20317
         Source: "isFinalized = true"
        Assignment using operator =
           Type: bool
           Source: "isFinalized = true"
          Identifier isFinalized
             Type: bool
             Source: "isFinalized"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "" - public
     Source: "function() external payable {\r\n        createTokens();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        createTokens();\r\n    }"
      ExpressionStatement
         Gas costs: 4
         Source: "createTokens()"
        FunctionCall
           Type: tuple()
           Source: "createTokens()"
          Identifier createTokens
             Type: function ()
             Source: "createTokens"
