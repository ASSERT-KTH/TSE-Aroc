Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xf190ff4c51b2b115981008194438f3add9032489.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.10;"
ContractDefinition "ForeignToken"
   Gas costs: 0
   Source: "contract ForeignToken {\r\n    function balanceOf(address _owner) constant returns (uint256);\r\n    function transfer(address _to, uint256 _value) returns (bool);\r\n}"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
ContractDefinition "TheMoneyFightToken"
   Source: "contract TheMoneyFightToken {\r\n    \r\n    enum betStatus{Running,Pending,Done}\r\n    \r\n    address public owner = msg.sender;\r\n    \r\n    uint gamesIndex = 0;\r\n    \r\n    \r\n    uint public constant LOSER_LOCK_TIME = 4 weeks;\r\n    bool public purchasingAllowed = false;\r\n    \r\n    mapping (uint => Game) games;\r\n    mapping (uint => Result) results;\r\n    mapping (uint => Option[]) gameOptions;\r\n    \r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    uint256 public totalContribution = 0;\r\n    uint256 public cap = 10000000000000000000000;\r\n   \r\n    \r\n    uint256 public totalSupply = 0;\r\n    \r\n    event gameStarted(string gameName,uint id, uint options,uint endTime);\r\n    event gameFinished(uint gameId,uint winningOption, uint256 totalBets, uint256 totalBetsForWinningOption);\r\n    event betAdded(uint gameId,uint option, address ownerAddress, uint256 value);\r\n    event Redeem(uint gameId,uint option,bool winner, address ownerAddress, uint256 reward);\r\n    event Transfer(address indexed _from, address indexed _recipient, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    \r\n    struct Option{\r\n        mapping (address=>uint256) status;\r\n    }\r\n    \r\n    struct Game{\r\n        betStatus status;\r\n        mapping (uint => uint256) totalBets;\r\n        uint256 total;\r\n        uint endTime;\r\n        uint finishTime;\r\n    }\r\n    \r\n    struct Result{\r\n        uint winningOption;\r\n        uint locktime;\r\n        uint256 betTotal;\r\n        uint256 winningOptionTotal;\r\n    }\r\n    \r\n    modifier only_owner() {\r\n\t\tif (msg.sender != owner) throw;\r\n\t\t_;\r\n\t}\r\n\t\r\n\tmodifier canRedeem(uint gameId){\r\n\t    if(games[gameId].status != betStatus.Done) throw;\r\n\t    _;\r\n\t}\r\n\t\r\n\tmodifier etherCapNotReached(uint256 _contribution) {\r\n        assert(safeAdd(totalContribution, _contribution) <= cap);\r\n        _;\r\n    }\r\n\t\r\n\tfunction canBet(uint gameId) returns(bool success){\r\n\t    bool running = now < games[gameId].finishTime;\r\n\t    bool statusOk =  games[gameId].status == betStatus.Running;\r\n\t    if(statusOk && !running) {\r\n\t        games[gameId].status = betStatus.Pending; \r\n\t        statusOk = false;\r\n\t    }\r\n\t    return running && statusOk;\r\n\t} \r\n\t\r\n   function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n   }\r\n   \r\n   function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal returns (uint) {\r\n     assert(b > 0);\r\n     uint c = a / b;\r\n     assert(a == b * c + a % b);\r\n     return c;\r\n    }\r\n    \r\n\r\n\r\n    function name() constant returns (string) { return \"The Money Fight\"; }\r\n    function symbol() constant returns (string) { return \"MFT\"; }\r\n    function decimals() constant returns (uint8) { return 18; }\r\n    function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; }\r\n    \r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        // mitigates the ERC20 short address attack\r\n        if(msg.data.length < (2 * 32) + 4) { throw; }\r\n\r\n        if (_value == 0) { return false; }\r\n\r\n        uint256 fromBalance = balances[msg.sender];\r\n\r\n        bool sufficientFunds = fromBalance >= _value;\r\n        bool overflowed = balances[_to] + _value < balances[_to];\r\n        \r\n        if (sufficientFunds && !overflowed) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            \r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        // mitigates the ERC20 short address attack\r\n        if(msg.data.length < (3 * 32) + 4) { throw; }\r\n\r\n        if (_value == 0) { return false; }\r\n        \r\n        uint256 fromBalance = balances[_from];\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n\r\n        bool sufficientFunds = fromBalance <= _value;\r\n        bool sufficientAllowance = allowance <= _value;\r\n        bool overflowed = balances[_to] + _value > balances[_to];\r\n\r\n        if (sufficientFunds && sufficientAllowance && !overflowed) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            \r\n            allowed[_from][msg.sender] -= _value;\r\n            \r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n    \r\n    \r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        // mitigates the ERC20 spend/approval race condition\r\n        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\r\n        \r\n        allowed[msg.sender][_spender] = _value;\r\n        \r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    } \r\n    \r\n    function createGame(string name,uint opts,uint endTime) only_owner { \r\n        uint currGame = ++gamesIndex;\r\n        games[currGame] = Game(betStatus.Running, 0 , 0, endTime);\r\n        for(uint i = 0 ; i < opts ; i++ ){\r\n            gameOptions[currGame].push(Option());\r\n        }\r\n        gameStarted(name,currGame,opts,endTime);\r\n    }\r\n    \r\n    function predictWinner(uint game, uint option, uint256 _value) {\r\n        Game curr = games[game];\r\n        betStatus status = curr.status;\r\n        uint256 fromBalance = balances[msg.sender];\r\n        bool sufficientFunds =  fromBalance >= _value;\r\n        if (_value > 0 && sufficientFunds && canBet(game)) {\r\n            balances[msg.sender] -= _value;\r\n            gameOptions[game][option].status[msg.sender]= _value;\r\n            curr.totalBets[option] += _value;\r\n            curr.total += _value;\r\n            betAdded(game,option,msg.sender,_value);\r\n        }\r\n    }\r\n    \r\n    function redeem(uint game, uint256 option) canRedeem(game) {\r\n            bool won = results[game].winningOption == option;\r\n            if(!won){\r\n                uint256 val =gameOptions[game][option].status[msg.sender];\r\n                if(val > 0 && results[game].locktime < now){\r\n                    gameOptions[game][option].status[msg.sender] = 0;\r\n                    balances[msg.sender] += val;\r\n                    Redeem(game,option,false,msg.sender,val);\r\n                }\r\n            } else {\r\n                uint256 total = calculatePrize(msg.sender,game,option);\r\n                if(total > 0){\r\n                    uint256 value = gameOptions[game][option].status[msg.sender];\r\n                    gameOptions[game][option].status[msg.sender] = 0;\r\n                    totalSupply += (total - value);\r\n                    balances[msg.sender] += total;\r\n                    Redeem(game,option,true,msg.sender,total);\r\n                }\r\n            }\r\n    }\r\n    \r\n    function calculatePrize(address sender, uint game,uint option) internal returns (uint256 val){\r\n        uint256 value = gameOptions[game][option].status[sender];\r\n        if(value > 0){\r\n            uint256 total =safeDiv(safeMul(results[game].betTotal,value),results[game].winningOptionTotal);\r\n            return total;\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    \r\n    function finishGame(uint game, uint winOption) only_owner {\r\n       Game curr = games[game];\r\n       curr.status = betStatus.Done;  \r\n       results[game] = Result(winOption, now + LOSER_LOCK_TIME, curr.total, curr.totalBets[winOption]); \r\n       gameFinished(game, winOption, curr.total, curr.totalBets[winOption]);\r\n    }\r\n    \r\n    function drain(uint256 bal) only_owner {\r\n\t\tif (!owner.send(bal)) throw;\r\n\t}\r\n\t\r\n\tfunction getTotalPrediction(uint game, uint option) public constant returns (uint256 total,uint256 totalOption){\r\n\t    Game curr = games[game];\r\n\t    return (curr.total, curr.totalBets[option]);\r\n\t}\r\n\t\r\n    function getPrediction(uint game, uint o) returns (uint256 bet) {\r\n        return gameOptions[game][o].status[msg.sender];\r\n    }\r\n    \r\n    function withdrawForeignTokens(address _tokenContract) only_owner returns (bool) {\r\n        ForeignToken token = ForeignToken(_tokenContract);\r\n        uint256 amount = token.balanceOf(address(this));\r\n        return token.transfer(owner, amount);\r\n    } \r\n   \r\n    function enablePurchasing() only_owner {\r\n        purchasingAllowed = true;\r\n    }\r\n\r\n    function disablePurchasing() only_owner{\r\n        purchasingAllowed = false;\r\n    }\r\n    function() payable etherCapNotReached(msg.value) {\r\n        if (!purchasingAllowed) { throw; }\r\n        \r\n        if (msg.value == 0) { return; }\r\n\r\n        owner.transfer(msg.value);\r\n        totalContribution += msg.value;\r\n\r\n        uint256 tokensIssued = msg.value * 100;\r\n\r\n        totalSupply += tokensIssued;\r\n        balances[msg.sender] += tokensIssued;\r\n        \r\n        Transfer(address(this), msg.sender, tokensIssued);\r\n    }\r\n    \r\n}"
  EnumDefinition "betStatus"
    EnumValue "Running"
    EnumValue "Pending"
    EnumValue "Done"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner = msg.sender"
    ElementaryTypeName address
       Source: "address"
    MemberAccess to member sender
       Type: address
       Source: "msg.sender"
      Identifier msg
         Type: msg
         Source: "msg"
  VariableDeclaration "gamesIndex"
     Type: uint256
     Gas costs: 0
     Source: "uint gamesIndex = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "LOSER_LOCK_TIME"
     Type: uint256
     Gas costs: [???]
     Source: "uint public constant LOSER_LOCK_TIME = 4 weeks"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 4
       Type: int_const 2419200
       Source: "4 weeks"
  VariableDeclaration "purchasingAllowed"
     Type: bool
     Gas costs: [???]
     Source: "bool public purchasingAllowed = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "games"
     Type: mapping(uint256 => struct TheMoneyFightToken.Game storage ref)
     Gas costs: 0
     Source: "mapping (uint => Game) games"
    Mapping
       Source: "mapping (uint => Game)"
      ElementaryTypeName uint
         Source: "uint"
      UserDefinedTypeName "Game"
         Source: "Game"
  VariableDeclaration "results"
     Type: mapping(uint256 => struct TheMoneyFightToken.Result storage ref)
     Gas costs: 0
     Source: "mapping (uint => Result) results"
    Mapping
       Source: "mapping (uint => Result)"
      ElementaryTypeName uint
         Source: "uint"
      UserDefinedTypeName "Result"
         Source: "Result"
  VariableDeclaration "gameOptions"
     Type: mapping(uint256 => struct TheMoneyFightToken.Option storage ref[] storage ref)
     Gas costs: 0
     Source: "mapping (uint => Option[]) gameOptions"
    Mapping
       Source: "mapping (uint => Option[])"
      ElementaryTypeName uint
         Source: "uint"
      ArrayTypeName
         Source: "Option[]"
        UserDefinedTypeName "Option"
           Source: "Option"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balances"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "totalContribution"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public totalContribution = 0"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "cap"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public cap = 10000000000000000000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 10000000000000000000000
       Type: int_const 10000000000000000000000
       Source: "10000000000000000000000"
  VariableDeclaration "totalSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public totalSupply = 0"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  EventDefinition "gameStarted"
     Gas costs: 0
     Source: "event gameStarted(string gameName,uint id, uint options,uint endTime);"
    ParameterList
       Source: "(string gameName,uint id, uint options,uint endTime)"
      VariableDeclaration "gameName"
         Type: string memory
         Source: "string gameName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "id"
         Type: uint256
         Source: "uint id"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "options"
         Type: uint256
         Source: "uint options"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "endTime"
         Type: uint256
         Source: "uint endTime"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "gameFinished"
     Gas costs: 0
     Source: "event gameFinished(uint gameId,uint winningOption, uint256 totalBets, uint256 totalBetsForWinningOption);"
    ParameterList
       Source: "(uint gameId,uint winningOption, uint256 totalBets, uint256 totalBetsForWinningOption)"
      VariableDeclaration "gameId"
         Type: uint256
         Source: "uint gameId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "winningOption"
         Type: uint256
         Source: "uint winningOption"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "totalBets"
         Type: uint256
         Source: "uint256 totalBets"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "totalBetsForWinningOption"
         Type: uint256
         Source: "uint256 totalBetsForWinningOption"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "betAdded"
     Gas costs: 0
     Source: "event betAdded(uint gameId,uint option, address ownerAddress, uint256 value);"
    ParameterList
       Source: "(uint gameId,uint option, address ownerAddress, uint256 value)"
      VariableDeclaration "gameId"
         Type: uint256
         Source: "uint gameId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "option"
         Type: uint256
         Source: "uint option"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "ownerAddress"
         Type: address
         Source: "address ownerAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Redeem"
     Gas costs: 0
     Source: "event Redeem(uint gameId,uint option,bool winner, address ownerAddress, uint256 reward);"
    ParameterList
       Source: "(uint gameId,uint option,bool winner, address ownerAddress, uint256 reward)"
      VariableDeclaration "gameId"
         Type: uint256
         Source: "uint gameId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "option"
         Type: uint256
         Source: "uint option"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "winner"
         Type: bool
         Source: "bool winner"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration "ownerAddress"
         Type: address
         Source: "address ownerAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "reward"
         Type: uint256
         Source: "uint256 reward"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Gas costs: 0
     Source: "event Transfer(address indexed _from, address indexed _recipient, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _recipient, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address indexed _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Gas costs: 0
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  StructDefinition "Option"
     Gas costs: 0
     Source: "struct Option{\r\n        mapping (address=>uint256) status;\r\n    }"
    VariableDeclaration "status"
       Type: mapping(address => uint256)
       Source: "mapping (address=>uint256) status"
      Mapping
         Source: "mapping (address=>uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  StructDefinition "Game"
     Gas costs: 0
     Source: "struct Game{\r\n        betStatus status;\r\n        mapping (uint => uint256) totalBets;\r\n        uint256 total;\r\n        uint endTime;\r\n        uint finishTime;\r\n    }"
    VariableDeclaration "status"
       Type: enum TheMoneyFightToken.betStatus
       Source: "betStatus status"
      UserDefinedTypeName "betStatus"
         Source: "betStatus"
    VariableDeclaration "totalBets"
       Type: mapping(uint256 => uint256)
       Source: "mapping (uint => uint256) totalBets"
      Mapping
         Source: "mapping (uint => uint256)"
        ElementaryTypeName uint
           Source: "uint"
        ElementaryTypeName uint256
           Source: "uint256"
    VariableDeclaration "total"
       Type: uint256
       Source: "uint256 total"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "endTime"
       Type: uint256
       Source: "uint endTime"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "finishTime"
       Type: uint256
       Source: "uint finishTime"
      ElementaryTypeName uint
         Source: "uint"
  StructDefinition "Result"
     Gas costs: 0
     Source: "struct Result{\r\n        uint winningOption;\r\n        uint locktime;\r\n        uint256 betTotal;\r\n        uint256 winningOptionTotal;\r\n    }"
    VariableDeclaration "winningOption"
       Type: uint256
       Source: "uint winningOption"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "locktime"
       Type: uint256
       Source: "uint locktime"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "betTotal"
       Type: uint256
       Source: "uint256 betTotal"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "winningOptionTotal"
       Type: uint256
       Source: "uint256 winningOptionTotal"
      ElementaryTypeName uint256
         Source: "uint256"
  ModifierDefinition "only_owner"
     Source: "modifier only_owner() {\r\n\t\tif (msg.sender != owner) throw;\r\n\t\t_;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n\t\tif (msg.sender != owner) throw;\r\n\t\t_;\r\n\t}"
      IfStatement
         Source: "if (msg.sender != owner) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 1554
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Throw
           Gas costs: 36
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "canRedeem"
     Source: "modifier canRedeem(uint gameId){\r\n\t    if(games[gameId].status != betStatus.Done) throw;\r\n\t    _;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint gameId)"
      VariableDeclaration "gameId"
         Type: uint256
         Source: "uint gameId"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n\t    if(games[gameId].status != betStatus.Done) throw;\r\n\t    _;\r\n\t}"
      IfStatement
         Source: "if(games[gameId].status != betStatus.Done) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 390
           Source: "games[gameId].status != betStatus.Done"
          MemberAccess to member status
             Type: enum TheMoneyFightToken.betStatus
             Source: "games[gameId].status"
            IndexAccess
               Type: struct TheMoneyFightToken.Game storage ref
               Source: "games[gameId]"
              Identifier games
                 Type: mapping(uint256 => struct TheMoneyFightToken.Game storage ref)
                 Source: "games"
              Identifier gameId
                 Type: uint256
                 Source: "gameId"
          MemberAccess to member Done
             Type: enum TheMoneyFightToken.betStatus
             Source: "betStatus.Done"
            Identifier betStatus
               Type: type(enum TheMoneyFightToken.betStatus)
               Source: "betStatus"
        Throw
           Gas costs: 6
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "etherCapNotReached"
     Source: "modifier etherCapNotReached(uint256 _contribution) {\r\n        assert(safeAdd(totalContribution, _contribution) <= cap);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _contribution)"
      VariableDeclaration "_contribution"
         Type: uint256
         Source: "uint256 _contribution"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        assert(safeAdd(totalContribution, _contribution) <= cap);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 439
         Source: "assert(safeAdd(totalContribution, _contribution) <= cap)"
        FunctionCall
           Type: tuple()
           Source: "assert(safeAdd(totalContribution, _contribution) <= cap)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "safeAdd(totalContribution, _contribution) <= cap"
            FunctionCall
               Type: uint256
               Source: "safeAdd(totalContribution, _contribution)"
              Identifier safeAdd
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "safeAdd"
              Identifier totalContribution
                 Type: uint256
                 Source: "totalContribution"
              Identifier _contribution
                 Type: uint256
                 Source: "_contribution"
            Identifier cap
               Type: uint256
               Source: "cap"
      PlaceholderStatement
         Gas costs: 1
         Source: "_"
  FunctionDefinition "canBet" - public
     Source: "function canBet(uint gameId) returns(bool success){\r\n\t    bool running = now < games[gameId].finishTime;\r\n\t    bool statusOk =  games[gameId].status == betStatus.Running;\r\n\t    if(statusOk && !running) {\r\n\t        games[gameId].status = betStatus.Pending; \r\n\t        statusOk = false;\r\n\t    }\r\n\t    return running && statusOk;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint gameId)"
      VariableDeclaration "gameId"
         Type: uint256
         Source: "uint gameId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\t    bool running = now < games[gameId].finishTime;\r\n\t    bool statusOk =  games[gameId].status == betStatus.Running;\r\n\t    if(statusOk && !running) {\r\n\t        games[gameId].status = betStatus.Pending; \r\n\t        statusOk = false;\r\n\t    }\r\n\t    return running && statusOk;\r\n\t}"
      VariableDeclarationStatement
         Gas costs: 306
         Source: "bool running = now < games[gameId].finishTime"
        VariableDeclaration "running"
           Type: bool
           Source: "bool running"
          ElementaryTypeName bool
             Source: "bool"
        BinaryOperation using operator <
           Type: bool
           Source: "now < games[gameId].finishTime"
          Identifier now
             Type: uint256
             Source: "now"
          MemberAccess to member finishTime
             Type: uint256
             Source: "games[gameId].finishTime"
            IndexAccess
               Type: struct TheMoneyFightToken.Game storage ref
               Source: "games[gameId]"
              Identifier games
                 Type: mapping(uint256 => struct TheMoneyFightToken.Game storage ref)
                 Source: "games"
              Identifier gameId
                 Type: uint256
                 Source: "gameId"
      VariableDeclarationStatement
         Gas costs: 395
         Source: "bool statusOk =  games[gameId].status == betStatus.Running"
        VariableDeclaration "statusOk"
           Type: bool
           Source: "bool statusOk"
          ElementaryTypeName bool
             Source: "bool"
        BinaryOperation using operator ==
           Type: bool
           Source: "games[gameId].status == betStatus.Running"
          MemberAccess to member status
             Type: enum TheMoneyFightToken.betStatus
             Source: "games[gameId].status"
            IndexAccess
               Type: struct TheMoneyFightToken.Game storage ref
               Source: "games[gameId]"
              Identifier games
                 Type: mapping(uint256 => struct TheMoneyFightToken.Game storage ref)
                 Source: "games"
              Identifier gameId
                 Type: uint256
                 Source: "gameId"
          MemberAccess to member Running
             Type: enum TheMoneyFightToken.betStatus
             Source: "betStatus.Running"
            Identifier betStatus
               Type: type(enum TheMoneyFightToken.betStatus)
               Source: "betStatus"
      IfStatement
         Source: "if(statusOk && !running) {\r\n\t        games[gameId].status = betStatus.Pending; \r\n\t        statusOk = false;\r\n\t    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 31
           Source: "statusOk && !running"
          Identifier statusOk
             Type: bool
             Source: "statusOk"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!running"
            Identifier running
               Type: bool
               Source: "running"
        Block
           Source: "{\r\n\t        games[gameId].status = betStatus.Pending; \r\n\t        statusOk = false;\r\n\t    }"
          ExpressionStatement
             Gas costs: 20377
             Source: "games[gameId].status = betStatus.Pending"
            Assignment using operator =
               Type: enum TheMoneyFightToken.betStatus
               Source: "games[gameId].status = betStatus.Pending"
              MemberAccess to member status
                 Type: enum TheMoneyFightToken.betStatus
                 Source: "games[gameId].status"
                IndexAccess
                   Type: struct TheMoneyFightToken.Game storage ref
                   Source: "games[gameId]"
                  Identifier games
                     Type: mapping(uint256 => struct TheMoneyFightToken.Game storage ref)
                     Source: "games"
                  Identifier gameId
                     Type: uint256
                     Source: "gameId"
              MemberAccess to member Pending
                 Type: enum TheMoneyFightToken.betStatus
                 Source: "betStatus.Pending"
                Identifier betStatus
                   Type: type(enum TheMoneyFightToken.betStatus)
                   Source: "betStatus"
          ExpressionStatement
             Gas costs: 8
             Source: "statusOk = false"
            Assignment using operator =
               Type: bool
               Source: "statusOk = false"
              Identifier statusOk
                 Type: bool
                 Source: "statusOk"
              Literal, token: false value: false
                 Type: bool
                 Source: "false"
      Return
         Gas costs: 33
         Source: "return running && statusOk"
        BinaryOperation using operator &&
           Type: bool
           Source: "running && statusOk"
          Identifier running
             Type: bool
             Source: "running"
          Identifier statusOk
             Type: bool
             Source: "statusOk"
  FunctionDefinition "safeMul"
     Source: "function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n   }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n   }"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 88
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "safeAdd"
     Source: "function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _x, uint256 _y)"
      VariableDeclaration "_x"
         Type: uint256
         Source: "uint256 _x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_y"
         Type: uint256
         Source: "uint256 _y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 z = _x + _y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "_x + _y"
          Identifier _x
             Type: uint256
             Source: "_x"
          Identifier _y
             Type: uint256
             Source: "_y"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(z >= _x)"
        FunctionCall
           Type: tuple()
           Source: "assert(z >= _x)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "z >= _x"
            Identifier z
               Type: uint256
               Source: "z"
            Identifier _x
               Type: uint256
               Source: "_x"
      Return
         Gas costs: 8
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
  FunctionDefinition "safeDiv"
     Source: "function safeDiv(uint a, uint b) internal returns (uint) {\r\n     assert(b > 0);\r\n     uint c = a / b;\r\n     assert(a == b * c + a % b);\r\n     return c;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n     assert(b > 0);\r\n     uint c = a / b;\r\n     assert(a == b * c + a % b);\r\n     return c;\r\n    }"
      ExpressionStatement
         Gas costs: 29
         Source: "assert(b > 0)"
        FunctionCall
           Type: tuple()
           Source: "assert(b > 0)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >
             Type: bool
             Source: "b > 0"
            Identifier b
               Type: uint256
               Source: "b"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 74
         Source: "assert(a == b * c + a % b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == b * c + a % b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "a == b * c + a % b"
            Identifier a
               Type: uint256
               Source: "a"
            BinaryOperation using operator +
               Type: uint256
               Source: "b * c + a % b"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "b * c"
                Identifier b
                   Type: uint256
                   Source: "b"
                Identifier c
                   Type: uint256
                   Source: "c"
              BinaryOperation using operator %
                 Type: uint256
                 Source: "a % b"
                Identifier a
                   Type: uint256
                   Source: "a"
                Identifier b
                   Type: uint256
                   Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "name" - public - const
     Source: "function name() constant returns (string) { return \"The Money Fight\"; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(string)"
      VariableDeclaration ""
         Type: string memory
         Source: "string"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{ return \"The Money Fight\"; }"
      Return
         Gas costs: [???]
         Source: "return \"The Money Fight\""
        Literal, token: [no token] value: The Money Fight
           Type: literal_string "The Money Fight"
           Source: "\"The Money Fight\""
  FunctionDefinition "symbol" - public - const
     Source: "function symbol() constant returns (string) { return \"MFT\"; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(string)"
      VariableDeclaration ""
         Type: string memory
         Source: "string"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{ return \"MFT\"; }"
      Return
         Gas costs: [???]
         Source: "return \"MFT\""
        Literal, token: [no token] value: MFT
           Type: literal_string "MFT"
           Source: "\"MFT\""
  FunctionDefinition "decimals" - public - const
     Source: "function decimals() constant returns (uint8) { return 18; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint8)"
      VariableDeclaration ""
         Type: uint8
         Source: "uint8"
        ElementaryTypeName uint8
           Source: "uint8"
    Block
       Source: "{ return 18; }"
      Return
         Gas costs: 8
         Source: "return 18"
        Literal, token: [no token] value: 18
           Type: int_const 18
           Source: "18"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{ return balances[_owner]; }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success) {\r\n        // mitigates the ERC20 short address attack\r\n        if(msg.data.length < (2 * 32) + 4) { throw; }\r\n\r\n        if (_value == 0) { return false; }\r\n\r\n        uint256 fromBalance = balances[msg.sender];\r\n\r\n        bool sufficientFunds = fromBalance >= _value;\r\n        bool overflowed = balances[_to] + _value < balances[_to];\r\n        \r\n        if (sufficientFunds && !overflowed) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            \r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        // mitigates the ERC20 short address attack\r\n        if(msg.data.length < (2 * 32) + 4) { throw; }\r\n\r\n        if (_value == 0) { return false; }\r\n\r\n        uint256 fromBalance = balances[msg.sender];\r\n\r\n        bool sufficientFunds = fromBalance >= _value;\r\n        bool overflowed = balances[_to] + _value < balances[_to];\r\n        \r\n        if (sufficientFunds && !overflowed) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            \r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }"
      IfStatement
         Source: "if(msg.data.length < (2 * 32) + 4) { throw; }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 16
           Source: "msg.data.length < (2 * 32) + 4"
          MemberAccess to member length
             Type: uint256
             Source: "msg.data.length"
            MemberAccess to member data
               Type: bytes calldata
               Source: "msg.data"
              Identifier msg
                 Type: msg
                 Source: "msg"
          BinaryOperation using operator +
             Type: int_const 68
             Source: "(2 * 32) + 4"
            TupleExpression
               Type: int_const 64
               Source: "(2 * 32)"
              BinaryOperation using operator *
                 Type: int_const 64
                 Source: "2 * 32"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
                Literal, token: [no token] value: 32
                   Type: int_const 32
                   Source: "32"
            Literal, token: [no token] value: 4
               Type: int_const 4
               Source: "4"
        Block
           Source: "{ throw; }"
          Throw
             Gas costs: 6
             Source: "throw"
      IfStatement
         Source: "if (_value == 0) { return false; }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "_value == 0"
          Identifier _value
             Type: uint256
             Source: "_value"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{ return false; }"
          Return
             Gas costs: 19
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      VariableDeclarationStatement
         Gas costs: 306
         Source: "uint256 fromBalance = balances[msg.sender]"
        VariableDeclaration "fromBalance"
           Type: uint256
           Source: "uint256 fromBalance"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "balances[msg.sender]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      VariableDeclarationStatement
         Gas costs: 20
         Source: "bool sufficientFunds = fromBalance >= _value"
        VariableDeclaration "sufficientFunds"
           Type: bool
           Source: "bool sufficientFunds"
          ElementaryTypeName bool
             Source: "bool"
        BinaryOperation using operator >=
           Type: bool
           Source: "fromBalance >= _value"
          Identifier fromBalance
             Type: uint256
             Source: "fromBalance"
          Identifier _value
             Type: uint256
             Source: "_value"
      VariableDeclarationStatement
         Gas costs: 603
         Source: "bool overflowed = balances[_to] + _value < balances[_to]"
        VariableDeclaration "overflowed"
           Type: bool
           Source: "bool overflowed"
          ElementaryTypeName bool
             Source: "bool"
        BinaryOperation using operator <
           Type: bool
           Source: "balances[_to] + _value < balances[_to]"
          BinaryOperation using operator +
             Type: uint256
             Source: "balances[_to] + _value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
      IfStatement
         Source: "if (sufficientFunds && !overflowed) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            \r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 31
           Source: "sufficientFunds && !overflowed"
          Identifier sufficientFunds
             Type: bool
             Source: "sufficientFunds"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!overflowed"
            Identifier overflowed
               Type: bool
               Source: "overflowed"
        Block
           Source: "{\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            \r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 20328
             Source: "balances[msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20323
             Source: "balances[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balances[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(msg.sender, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(msg.sender, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{ return false; }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        // mitigates the ERC20 short address attack\r\n        if(msg.data.length < (3 * 32) + 4) { throw; }\r\n\r\n        if (_value == 0) { return false; }\r\n        \r\n        uint256 fromBalance = balances[_from];\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n\r\n        bool sufficientFunds = fromBalance <= _value;\r\n        bool sufficientAllowance = allowance <= _value;\r\n        bool overflowed = balances[_to] + _value > balances[_to];\r\n\r\n        if (sufficientFunds && sufficientAllowance && !overflowed) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            \r\n            allowed[_from][msg.sender] -= _value;\r\n            \r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        // mitigates the ERC20 short address attack\r\n        if(msg.data.length < (3 * 32) + 4) { throw; }\r\n\r\n        if (_value == 0) { return false; }\r\n        \r\n        uint256 fromBalance = balances[_from];\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n\r\n        bool sufficientFunds = fromBalance <= _value;\r\n        bool sufficientAllowance = allowance <= _value;\r\n        bool overflowed = balances[_to] + _value > balances[_to];\r\n\r\n        if (sufficientFunds && sufficientAllowance && !overflowed) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            \r\n            allowed[_from][msg.sender] -= _value;\r\n            \r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }"
      IfStatement
         Source: "if(msg.data.length < (3 * 32) + 4) { throw; }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 16
           Source: "msg.data.length < (3 * 32) + 4"
          MemberAccess to member length
             Type: uint256
             Source: "msg.data.length"
            MemberAccess to member data
               Type: bytes calldata
               Source: "msg.data"
              Identifier msg
                 Type: msg
                 Source: "msg"
          BinaryOperation using operator +
             Type: int_const 100
             Source: "(3 * 32) + 4"
            TupleExpression
               Type: int_const 96
               Source: "(3 * 32)"
              BinaryOperation using operator *
                 Type: int_const 96
                 Source: "3 * 32"
                Literal, token: [no token] value: 3
                   Type: int_const 3
                   Source: "3"
                Literal, token: [no token] value: 32
                   Type: int_const 32
                   Source: "32"
            Literal, token: [no token] value: 4
               Type: int_const 4
               Source: "4"
        Block
           Source: "{ throw; }"
          Throw
             Gas costs: 6
             Source: "throw"
      IfStatement
         Source: "if (_value == 0) { return false; }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "_value == 0"
          Identifier _value
             Type: uint256
             Source: "_value"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{ return false; }"
          Return
             Gas costs: 19
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      VariableDeclarationStatement
         Gas costs: 307
         Source: "uint256 fromBalance = balances[_from]"
        VariableDeclaration "fromBalance"
           Type: uint256
           Source: "uint256 fromBalance"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "balances[_from]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _from
             Type: address
             Source: "_from"
      VariableDeclarationStatement
         Gas costs: 390
         Source: "uint256 allowance = allowed[_from][msg.sender]"
        VariableDeclaration "allowance"
           Type: uint256
           Source: "uint256 allowance"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "allowed[_from][msg.sender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_from]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _from
               Type: address
               Source: "_from"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      VariableDeclarationStatement
         Gas costs: 20
         Source: "bool sufficientFunds = fromBalance <= _value"
        VariableDeclaration "sufficientFunds"
           Type: bool
           Source: "bool sufficientFunds"
          ElementaryTypeName bool
             Source: "bool"
        BinaryOperation using operator <=
           Type: bool
           Source: "fromBalance <= _value"
          Identifier fromBalance
             Type: uint256
             Source: "fromBalance"
          Identifier _value
             Type: uint256
             Source: "_value"
      VariableDeclarationStatement
         Gas costs: 20
         Source: "bool sufficientAllowance = allowance <= _value"
        VariableDeclaration "sufficientAllowance"
           Type: bool
           Source: "bool sufficientAllowance"
          ElementaryTypeName bool
             Source: "bool"
        BinaryOperation using operator <=
           Type: bool
           Source: "allowance <= _value"
          Identifier allowance
             Type: uint256
             Source: "allowance"
          Identifier _value
             Type: uint256
             Source: "_value"
      VariableDeclarationStatement
         Gas costs: 603
         Source: "bool overflowed = balances[_to] + _value > balances[_to]"
        VariableDeclaration "overflowed"
           Type: bool
           Source: "bool overflowed"
          ElementaryTypeName bool
             Source: "bool"
        BinaryOperation using operator >
           Type: bool
           Source: "balances[_to] + _value > balances[_to]"
          BinaryOperation using operator +
             Type: uint256
             Source: "balances[_to] + _value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
      IfStatement
         Source: "if (sufficientFunds && sufficientAllowance && !overflowed) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            \r\n            allowed[_from][msg.sender] -= _value;\r\n            \r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 56
           Source: "sufficientFunds && sufficientAllowance && !overflowed"
          BinaryOperation using operator &&
             Type: bool
             Source: "sufficientFunds && sufficientAllowance"
            Identifier sufficientFunds
               Type: bool
               Source: "sufficientFunds"
            Identifier sufficientAllowance
               Type: bool
               Source: "sufficientAllowance"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!overflowed"
            Identifier overflowed
               Type: bool
               Source: "overflowed"
        Block
           Source: "{\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            \r\n            allowed[_from][msg.sender] -= _value;\r\n            \r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 20329
             Source: "balances[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balances[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20323
             Source: "balances[_from] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[_from] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20412
             Source: "allowed[_from][msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "allowed[_from][msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(_from, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(_from, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              Identifier _from
                 Type: address
                 Source: "_from"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{ return false; }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success) {\r\n        // mitigates the ERC20 spend/approval race condition\r\n        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\r\n        \r\n        allowed[msg.sender][_spender] = _value;\r\n        \r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        // mitigates the ERC20 spend/approval race condition\r\n        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\r\n        \r\n        allowed[msg.sender][_spender] = _value;\r\n        \r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
      IfStatement
         Source: "if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 431
           Source: "_value != 0 && allowed[msg.sender][_spender] != 0"
          BinaryOperation using operator !=
             Type: bool
             Source: "_value != 0"
            Identifier _value
               Type: uint256
               Source: "_value"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator !=
             Type: bool
             Source: "allowed[msg.sender][_spender] != 0"
            IndexAccess
               Type: uint256
               Source: "allowed[msg.sender][_spender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[msg.sender]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _spender
                 Type: address
                 Source: "_spender"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{ return false; }"
          Return
             Gas costs: 19
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "createGame" - public
     Source: "function createGame(string name,uint opts,uint endTime) only_owner { \r\n        uint currGame = ++gamesIndex;\r\n        games[currGame] = Game(betStatus.Running, 0 , 0, endTime);\r\n        for(uint i = 0 ; i < opts ; i++ ){\r\n            gameOptions[currGame].push(Option());\r\n        }\r\n        gameStarted(name,currGame,opts,endTime);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string name,uint opts,uint endTime)"
      VariableDeclaration "name"
         Type: string memory
         Source: "string name"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "opts"
         Type: uint256
         Source: "uint opts"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "endTime"
         Type: uint256
         Source: "uint endTime"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "only_owner"
       Gas costs: 0
       Source: "only_owner"
      Identifier only_owner
         Type: modifier ()
         Source: "only_owner"
    Block
       Source: "{ \r\n        uint currGame = ++gamesIndex;\r\n        games[currGame] = Game(betStatus.Running, 0 , 0, endTime);\r\n        for(uint i = 0 ; i < opts ; i++ ){\r\n            gameOptions[currGame].push(Option());\r\n        }\r\n        gameStarted(name,currGame,opts,endTime);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 20237
         Source: "uint currGame = ++gamesIndex"
        VariableDeclaration "currGame"
           Type: uint256
           Source: "uint currGame"
          ElementaryTypeName uint
             Source: "uint"
        UnaryOperation (prefix) ++
           Type: uint256
           Source: "++gamesIndex"
          Identifier gamesIndex
             Type: uint256
             Source: "gamesIndex"
      ExpressionStatement
         Gas costs: [???]
         Source: "games[currGame] = Game(betStatus.Running, 0 , 0, endTime)"
        Assignment using operator =
           Type: struct TheMoneyFightToken.Game storage ref
           Source: "games[currGame] = Game(betStatus.Running, 0 , 0, endTime)"
          IndexAccess
             Type: struct TheMoneyFightToken.Game storage ref
             Source: "games[currGame]"
            Identifier games
               Type: mapping(uint256 => struct TheMoneyFightToken.Game storage ref)
               Source: "games"
            Identifier currGame
               Type: uint256
               Source: "currGame"
          FunctionCall
             Type: struct TheMoneyFightToken.Game memory
             Source: "Game(betStatus.Running, 0 , 0, endTime)"
            Identifier Game
               Type: type(struct TheMoneyFightToken.Game storage pointer)
               Source: "Game"
            MemberAccess to member Running
               Type: enum TheMoneyFightToken.betStatus
               Source: "betStatus.Running"
              Identifier betStatus
                 Type: type(enum TheMoneyFightToken.betStatus)
                 Source: "betStatus"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
            Identifier endTime
               Type: uint256
               Source: "endTime"
      ForStatement
         Source: "for(uint i = 0 ; i < opts ; i++ ){\r\n            gameOptions[currGame].push(Option());\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < opts"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier opts
             Type: uint256
             Source: "opts"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            gameOptions[currGame].push(Option());\r\n        }"
          ExpressionStatement
             Gas costs: 218
             Source: "gameOptions[currGame].push(Option())"
            FunctionCall
               Type: uint256
               Source: "gameOptions[currGame].push(Option())"
              MemberAccess to member push
                 Type: function (struct TheMoneyFightToken.Option storage ref) returns (uint256)
                 Source: "gameOptions[currGame].push"
                IndexAccess
                   Type: struct TheMoneyFightToken.Option storage ref[] storage ref
                   Source: "gameOptions[currGame]"
                  Identifier gameOptions
                     Type: mapping(uint256 => struct TheMoneyFightToken.Option storage ref[] storage ref)
                     Source: "gameOptions"
                  Identifier currGame
                     Type: uint256
                     Source: "currGame"
              FunctionCall
                 Type: struct TheMoneyFightToken.Option memory
                 Source: "Option()"
                Identifier Option
                   Type: type(struct TheMoneyFightToken.Option storage pointer)
                   Source: "Option"
      ExpressionStatement
         Gas costs: [???]
         Source: "gameStarted(name,currGame,opts,endTime)"
        FunctionCall
           Type: tuple()
           Source: "gameStarted(name,currGame,opts,endTime)"
          Identifier gameStarted
             Type: function (string memory,uint256,uint256,uint256)
             Source: "gameStarted"
          Identifier name
             Type: string memory
             Source: "name"
          Identifier currGame
             Type: uint256
             Source: "currGame"
          Identifier opts
             Type: uint256
             Source: "opts"
          Identifier endTime
             Type: uint256
             Source: "endTime"
  FunctionDefinition "predictWinner" - public
     Source: "function predictWinner(uint game, uint option, uint256 _value) {\r\n        Game curr = games[game];\r\n        betStatus status = curr.status;\r\n        uint256 fromBalance = balances[msg.sender];\r\n        bool sufficientFunds =  fromBalance >= _value;\r\n        if (_value > 0 && sufficientFunds && canBet(game)) {\r\n            balances[msg.sender] -= _value;\r\n            gameOptions[game][option].status[msg.sender]= _value;\r\n            curr.totalBets[option] += _value;\r\n            curr.total += _value;\r\n            betAdded(game,option,msg.sender,_value);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint game, uint option, uint256 _value)"
      VariableDeclaration "game"
         Type: uint256
         Source: "uint game"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "option"
         Type: uint256
         Source: "uint option"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        Game curr = games[game];\r\n        betStatus status = curr.status;\r\n        uint256 fromBalance = balances[msg.sender];\r\n        bool sufficientFunds =  fromBalance >= _value;\r\n        if (_value > 0 && sufficientFunds && canBet(game)) {\r\n            balances[msg.sender] -= _value;\r\n            gameOptions[game][option].status[msg.sender]= _value;\r\n            curr.totalBets[option] += _value;\r\n            curr.total += _value;\r\n            betAdded(game,option,msg.sender,_value);\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 95
         Source: "Game curr = games[game]"
        VariableDeclaration "curr"
           Type: struct TheMoneyFightToken.Game storage pointer
           Source: "Game curr"
          UserDefinedTypeName "Game"
             Source: "Game"
        IndexAccess
           Type: struct TheMoneyFightToken.Game storage ref
           Source: "games[game]"
          Identifier games
             Type: mapping(uint256 => struct TheMoneyFightToken.Game storage ref)
             Source: "games"
          Identifier game
             Type: uint256
             Source: "game"
      VariableDeclarationStatement
         Gas costs: 253
         Source: "betStatus status = curr.status"
        VariableDeclaration "status"
           Type: enum TheMoneyFightToken.betStatus
           Source: "betStatus status"
          UserDefinedTypeName "betStatus"
             Source: "betStatus"
        MemberAccess to member status
           Type: enum TheMoneyFightToken.betStatus
           Source: "curr.status"
          Identifier curr
             Type: struct TheMoneyFightToken.Game storage pointer
             Source: "curr"
      VariableDeclarationStatement
         Gas costs: 300
         Source: "uint256 fromBalance = balances[msg.sender]"
        VariableDeclaration "fromBalance"
           Type: uint256
           Source: "uint256 fromBalance"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "balances[msg.sender]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      VariableDeclarationStatement
         Gas costs: 20
         Source: "bool sufficientFunds =  fromBalance >= _value"
        VariableDeclaration "sufficientFunds"
           Type: bool
           Source: "bool sufficientFunds"
          ElementaryTypeName bool
             Source: "bool"
        BinaryOperation using operator >=
           Type: bool
           Source: "fromBalance >= _value"
          Identifier fromBalance
             Type: uint256
             Source: "fromBalance"
          Identifier _value
             Type: uint256
             Source: "_value"
      IfStatement
         Source: "if (_value > 0 && sufficientFunds && canBet(game)) {\r\n            balances[msg.sender] -= _value;\r\n            gameOptions[game][option].status[msg.sender]= _value;\r\n            curr.totalBets[option] += _value;\r\n            curr.total += _value;\r\n            betAdded(game,option,msg.sender,_value);\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 74
           Source: "_value > 0 && sufficientFunds && canBet(game)"
          BinaryOperation using operator &&
             Type: bool
             Source: "_value > 0 && sufficientFunds"
            BinaryOperation using operator >
               Type: bool
               Source: "_value > 0"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Identifier sufficientFunds
               Type: bool
               Source: "sufficientFunds"
          FunctionCall
             Type: bool
             Source: "canBet(game)"
            Identifier canBet
               Type: function (uint256) returns (bool)
               Source: "canBet"
            Identifier game
               Type: uint256
               Source: "game"
        Block
           Source: "{\r\n            balances[msg.sender] -= _value;\r\n            gameOptions[game][option].status[msg.sender]= _value;\r\n            curr.totalBets[option] += _value;\r\n            curr.total += _value;\r\n            betAdded(game,option,msg.sender,_value);\r\n        }"
          ExpressionStatement
             Gas costs: 20328
             Source: "balances[msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20479
             Source: "gameOptions[game][option].status[msg.sender]= _value"
            Assignment using operator =
               Type: uint256
               Source: "gameOptions[game][option].status[msg.sender]= _value"
              IndexAccess
                 Type: uint256
                 Source: "gameOptions[game][option].status[msg.sender]"
                MemberAccess to member status
                   Type: mapping(address => uint256)
                   Source: "gameOptions[game][option].status"
                  IndexAccess
                     Type: struct TheMoneyFightToken.Option storage ref
                     Source: "gameOptions[game][option]"
                    IndexAccess
                       Type: struct TheMoneyFightToken.Option storage ref[] storage ref
                       Source: "gameOptions[game]"
                      Identifier gameOptions
                         Type: mapping(uint256 => struct TheMoneyFightToken.Option storage ref[] storage ref)
                         Source: "gameOptions"
                      Identifier game
                         Type: uint256
                         Source: "game"
                    Identifier option
                       Type: uint256
                       Source: "option"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20317
             Source: "curr.totalBets[option] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "curr.totalBets[option] += _value"
              IndexAccess
                 Type: uint256
                 Source: "curr.totalBets[option]"
                MemberAccess to member totalBets
                   Type: mapping(uint256 => uint256)
                   Source: "curr.totalBets"
                  Identifier curr
                     Type: struct TheMoneyFightToken.Game storage pointer
                     Source: "curr"
                Identifier option
                   Type: uint256
                   Source: "option"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20239
             Source: "curr.total += _value"
            Assignment using operator +=
               Type: uint256
               Source: "curr.total += _value"
              MemberAccess to member total
                 Type: uint256
                 Source: "curr.total"
                Identifier curr
                   Type: struct TheMoneyFightToken.Game storage pointer
                   Source: "curr"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "betAdded(game,option,msg.sender,_value)"
            FunctionCall
               Type: tuple()
               Source: "betAdded(game,option,msg.sender,_value)"
              Identifier betAdded
                 Type: function (uint256,uint256,address,uint256)
                 Source: "betAdded"
              Identifier game
                 Type: uint256
                 Source: "game"
              Identifier option
                 Type: uint256
                 Source: "option"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
  FunctionDefinition "redeem" - public
     Source: "function redeem(uint game, uint256 option) canRedeem(game) {\r\n            bool won = results[game].winningOption == option;\r\n            if(!won){\r\n                uint256 val =gameOptions[game][option].status[msg.sender];\r\n                if(val > 0 && results[game].locktime < now){\r\n                    gameOptions[game][option].status[msg.sender] = 0;\r\n                    balances[msg.sender] += val;\r\n                    Redeem(game,option,false,msg.sender,val);\r\n                }\r\n            } else {\r\n                uint256 total = calculatePrize(msg.sender,game,option);\r\n                if(total > 0){\r\n                    uint256 value = gameOptions[game][option].status[msg.sender];\r\n                    gameOptions[game][option].status[msg.sender] = 0;\r\n                    totalSupply += (total - value);\r\n                    balances[msg.sender] += total;\r\n                    Redeem(game,option,true,msg.sender,total);\r\n                }\r\n            }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint game, uint256 option)"
      VariableDeclaration "game"
         Type: uint256
         Source: "uint game"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "option"
         Type: uint256
         Source: "uint256 option"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "canRedeem"
       Gas costs: 3
       Source: "canRedeem(game)"
      Identifier canRedeem
         Type: modifier (uint256)
         Source: "canRedeem"
      Identifier game
         Type: uint256
         Source: "game"
    Block
       Source: "{\r\n            bool won = results[game].winningOption == option;\r\n            if(!won){\r\n                uint256 val =gameOptions[game][option].status[msg.sender];\r\n                if(val > 0 && results[game].locktime < now){\r\n                    gameOptions[game][option].status[msg.sender] = 0;\r\n                    balances[msg.sender] += val;\r\n                    Redeem(game,option,false,msg.sender,val);\r\n                }\r\n            } else {\r\n                uint256 total = calculatePrize(msg.sender,game,option);\r\n                if(total > 0){\r\n                    uint256 value = gameOptions[game][option].status[msg.sender];\r\n                    gameOptions[game][option].status[msg.sender] = 0;\r\n                    totalSupply += (total - value);\r\n                    balances[msg.sender] += total;\r\n                    Redeem(game,option,true,msg.sender,total);\r\n                }\r\n            }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 307
         Source: "bool won = results[game].winningOption == option"
        VariableDeclaration "won"
           Type: bool
           Source: "bool won"
          ElementaryTypeName bool
             Source: "bool"
        BinaryOperation using operator ==
           Type: bool
           Source: "results[game].winningOption == option"
          MemberAccess to member winningOption
             Type: uint256
             Source: "results[game].winningOption"
            IndexAccess
               Type: struct TheMoneyFightToken.Result storage ref
               Source: "results[game]"
              Identifier results
                 Type: mapping(uint256 => struct TheMoneyFightToken.Result storage ref)
                 Source: "results"
              Identifier game
                 Type: uint256
                 Source: "game"
          Identifier option
             Type: uint256
             Source: "option"
      IfStatement
         Source: "if(!won){\r\n                uint256 val =gameOptions[game][option].status[msg.sender];\r\n                if(val > 0 && results[game].locktime < now){\r\n                    gameOptions[game][option].status[msg.sender] = 0;\r\n                    balances[msg.sender] += val;\r\n                    Redeem(game,option,false,msg.sender,val);\r\n                }\r\n            } else {\r\n                uint256 total = calculatePrize(msg.sender,game,option);\r\n                if(total > 0){\r\n                    uint256 value = gameOptions[game][option].status[msg.sender];\r\n                    gameOptions[game][option].status[msg.sender] = 0;\r\n                    totalSupply += (total - value);\r\n                    balances[msg.sender] += total;\r\n                    Redeem(game,option,true,msg.sender,total);\r\n                }\r\n            }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 6
           Source: "!won"
          Identifier won
             Type: bool
             Source: "won"
        Block
           Source: "{\r\n                uint256 val =gameOptions[game][option].status[msg.sender];\r\n                if(val > 0 && results[game].locktime < now){\r\n                    gameOptions[game][option].status[msg.sender] = 0;\r\n                    balances[msg.sender] += val;\r\n                    Redeem(game,option,false,msg.sender,val);\r\n                }\r\n            }"
          VariableDeclarationStatement
             Gas costs: 682
             Source: "uint256 val =gameOptions[game][option].status[msg.sender]"
            VariableDeclaration "val"
               Type: uint256
               Source: "uint256 val"
              ElementaryTypeName uint256
                 Source: "uint256"
            IndexAccess
               Type: uint256
               Source: "gameOptions[game][option].status[msg.sender]"
              MemberAccess to member status
                 Type: mapping(address => uint256)
                 Source: "gameOptions[game][option].status"
                IndexAccess
                   Type: struct TheMoneyFightToken.Option storage ref
                   Source: "gameOptions[game][option]"
                  IndexAccess
                     Type: struct TheMoneyFightToken.Option storage ref[] storage ref
                     Source: "gameOptions[game]"
                    Identifier gameOptions
                       Type: mapping(uint256 => struct TheMoneyFightToken.Option storage ref[] storage ref)
                       Source: "gameOptions"
                    Identifier game
                       Type: uint256
                       Source: "game"
                  Identifier option
                     Type: uint256
                     Source: "option"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          IfStatement
             Source: "if(val > 0 && results[game].locktime < now){\r\n                    gameOptions[game][option].status[msg.sender] = 0;\r\n                    balances[msg.sender] += val;\r\n                    Redeem(game,option,false,msg.sender,val);\r\n                }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 329
               Source: "val > 0 && results[game].locktime < now"
              BinaryOperation using operator >
                 Type: bool
                 Source: "val > 0"
                Identifier val
                   Type: uint256
                   Source: "val"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              BinaryOperation using operator <
                 Type: bool
                 Source: "results[game].locktime < now"
                MemberAccess to member locktime
                   Type: uint256
                   Source: "results[game].locktime"
                  IndexAccess
                     Type: struct TheMoneyFightToken.Result storage ref
                     Source: "results[game]"
                    Identifier results
                       Type: mapping(uint256 => struct TheMoneyFightToken.Result storage ref)
                       Source: "results"
                    Identifier game
                       Type: uint256
                       Source: "game"
                Identifier now
                   Type: uint256
                   Source: "now"
            Block
               Source: "{\r\n                    gameOptions[game][option].status[msg.sender] = 0;\r\n                    balances[msg.sender] += val;\r\n                    Redeem(game,option,false,msg.sender,val);\r\n                }"
              ExpressionStatement
                 Gas costs: 20485
                 Source: "gameOptions[game][option].status[msg.sender] = 0"
                Assignment using operator =
                   Type: uint256
                   Source: "gameOptions[game][option].status[msg.sender] = 0"
                  IndexAccess
                     Type: uint256
                     Source: "gameOptions[game][option].status[msg.sender]"
                    MemberAccess to member status
                       Type: mapping(address => uint256)
                       Source: "gameOptions[game][option].status"
                      IndexAccess
                         Type: struct TheMoneyFightToken.Option storage ref
                         Source: "gameOptions[game][option]"
                        IndexAccess
                           Type: struct TheMoneyFightToken.Option storage ref[] storage ref
                           Source: "gameOptions[game]"
                          Identifier gameOptions
                             Type: mapping(uint256 => struct TheMoneyFightToken.Option storage ref[] storage ref)
                             Source: "gameOptions"
                          Identifier game
                             Type: uint256
                             Source: "game"
                        Identifier option
                           Type: uint256
                           Source: "option"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              ExpressionStatement
                 Gas costs: 20322
                 Source: "balances[msg.sender] += val"
                Assignment using operator +=
                   Type: uint256
                   Source: "balances[msg.sender] += val"
                  IndexAccess
                     Type: uint256
                     Source: "balances[msg.sender]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                  Identifier val
                     Type: uint256
                     Source: "val"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "Redeem(game,option,false,msg.sender,val)"
                FunctionCall
                   Type: tuple()
                   Source: "Redeem(game,option,false,msg.sender,val)"
                  Identifier Redeem
                     Type: function (uint256,uint256,bool,address,uint256)
                     Source: "Redeem"
                  Identifier game
                     Type: uint256
                     Source: "game"
                  Identifier option
                     Type: uint256
                     Source: "option"
                  Literal, token: false value: false
                     Type: bool
                     Source: "false"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier val
                     Type: uint256
                     Source: "val"
        Block
           Source: "{\r\n                uint256 total = calculatePrize(msg.sender,game,option);\r\n                if(total > 0){\r\n                    uint256 value = gameOptions[game][option].status[msg.sender];\r\n                    gameOptions[game][option].status[msg.sender] = 0;\r\n                    totalSupply += (total - value);\r\n                    balances[msg.sender] += total;\r\n                    Redeem(game,option,true,msg.sender,total);\r\n                }\r\n            }"
          VariableDeclarationStatement
             Gas costs: 20
             Source: "uint256 total = calculatePrize(msg.sender,game,option)"
            VariableDeclaration "total"
               Type: uint256
               Source: "uint256 total"
              ElementaryTypeName uint256
                 Source: "uint256"
            FunctionCall
               Type: uint256
               Source: "calculatePrize(msg.sender,game,option)"
              Identifier calculatePrize
                 Type: function (address,uint256,uint256) returns (uint256)
                 Source: "calculatePrize"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier game
                 Type: uint256
                 Source: "game"
              Identifier option
                 Type: uint256
                 Source: "option"
          IfStatement
             Source: "if(total > 0){\r\n                    uint256 value = gameOptions[game][option].status[msg.sender];\r\n                    gameOptions[game][option].status[msg.sender] = 0;\r\n                    totalSupply += (total - value);\r\n                    balances[msg.sender] += total;\r\n                    Redeem(game,option,true,msg.sender,total);\r\n                }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 9
               Source: "total > 0"
              Identifier total
                 Type: uint256
                 Source: "total"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{\r\n                    uint256 value = gameOptions[game][option].status[msg.sender];\r\n                    gameOptions[game][option].status[msg.sender] = 0;\r\n                    totalSupply += (total - value);\r\n                    balances[msg.sender] += total;\r\n                    Redeem(game,option,true,msg.sender,total);\r\n                }"
              VariableDeclarationStatement
                 Gas costs: 682
                 Source: "uint256 value = gameOptions[game][option].status[msg.sender]"
                VariableDeclaration "value"
                   Type: uint256
                   Source: "uint256 value"
                  ElementaryTypeName uint256
                     Source: "uint256"
                IndexAccess
                   Type: uint256
                   Source: "gameOptions[game][option].status[msg.sender]"
                  MemberAccess to member status
                     Type: mapping(address => uint256)
                     Source: "gameOptions[game][option].status"
                    IndexAccess
                       Type: struct TheMoneyFightToken.Option storage ref
                       Source: "gameOptions[game][option]"
                      IndexAccess
                         Type: struct TheMoneyFightToken.Option storage ref[] storage ref
                         Source: "gameOptions[game]"
                        Identifier gameOptions
                           Type: mapping(uint256 => struct TheMoneyFightToken.Option storage ref[] storage ref)
                           Source: "gameOptions"
                        Identifier game
                           Type: uint256
                           Source: "game"
                      Identifier option
                         Type: uint256
                         Source: "option"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
              ExpressionStatement
                 Gas costs: 20479
                 Source: "gameOptions[game][option].status[msg.sender] = 0"
                Assignment using operator =
                   Type: uint256
                   Source: "gameOptions[game][option].status[msg.sender] = 0"
                  IndexAccess
                     Type: uint256
                     Source: "gameOptions[game][option].status[msg.sender]"
                    MemberAccess to member status
                       Type: mapping(address => uint256)
                       Source: "gameOptions[game][option].status"
                      IndexAccess
                         Type: struct TheMoneyFightToken.Option storage ref
                         Source: "gameOptions[game][option]"
                        IndexAccess
                           Type: struct TheMoneyFightToken.Option storage ref[] storage ref
                           Source: "gameOptions[game]"
                          Identifier gameOptions
                             Type: mapping(uint256 => struct TheMoneyFightToken.Option storage ref[] storage ref)
                             Source: "gameOptions"
                          Identifier game
                             Type: uint256
                             Source: "game"
                        Identifier option
                           Type: uint256
                           Source: "option"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              ExpressionStatement
                 Gas costs: 20239
                 Source: "totalSupply += (total - value)"
                Assignment using operator +=
                   Type: uint256
                   Source: "totalSupply += (total - value)"
                  Identifier totalSupply
                     Type: uint256
                     Source: "totalSupply"
                  TupleExpression
                     Type: uint256
                     Source: "(total - value)"
                    BinaryOperation using operator -
                       Type: uint256
                       Source: "total - value"
                      Identifier total
                         Type: uint256
                         Source: "total"
                      Identifier value
                         Type: uint256
                         Source: "value"
              ExpressionStatement
                 Gas costs: 20322
                 Source: "balances[msg.sender] += total"
                Assignment using operator +=
                   Type: uint256
                   Source: "balances[msg.sender] += total"
                  IndexAccess
                     Type: uint256
                     Source: "balances[msg.sender]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                  Identifier total
                     Type: uint256
                     Source: "total"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "Redeem(game,option,true,msg.sender,total)"
                FunctionCall
                   Type: tuple()
                   Source: "Redeem(game,option,true,msg.sender,total)"
                  Identifier Redeem
                     Type: function (uint256,uint256,bool,address,uint256)
                     Source: "Redeem"
                  Identifier game
                     Type: uint256
                     Source: "game"
                  Identifier option
                     Type: uint256
                     Source: "option"
                  Literal, token: true value: true
                     Type: bool
                     Source: "true"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                  Identifier total
                     Type: uint256
                     Source: "total"
  FunctionDefinition "calculatePrize"
     Source: "function calculatePrize(address sender, uint game,uint option) internal returns (uint256 val){\r\n        uint256 value = gameOptions[game][option].status[sender];\r\n        if(value > 0){\r\n            uint256 total =safeDiv(safeMul(results[game].betTotal,value),results[game].winningOptionTotal);\r\n            return total;\r\n        }\r\n        return 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address sender, uint game,uint option)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "game"
         Type: uint256
         Source: "uint game"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "option"
         Type: uint256
         Source: "uint option"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint256 val)"
      VariableDeclaration "val"
         Type: uint256
         Source: "uint256 val"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        uint256 value = gameOptions[game][option].status[sender];\r\n        if(value > 0){\r\n            uint256 total =safeDiv(safeMul(results[game].betTotal,value),results[game].winningOptionTotal);\r\n            return total;\r\n        }\r\n        return 0;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 683
         Source: "uint256 value = gameOptions[game][option].status[sender]"
        VariableDeclaration "value"
           Type: uint256
           Source: "uint256 value"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "gameOptions[game][option].status[sender]"
          MemberAccess to member status
             Type: mapping(address => uint256)
             Source: "gameOptions[game][option].status"
            IndexAccess
               Type: struct TheMoneyFightToken.Option storage ref
               Source: "gameOptions[game][option]"
              IndexAccess
                 Type: struct TheMoneyFightToken.Option storage ref[] storage ref
                 Source: "gameOptions[game]"
                Identifier gameOptions
                   Type: mapping(uint256 => struct TheMoneyFightToken.Option storage ref[] storage ref)
                   Source: "gameOptions"
                Identifier game
                   Type: uint256
                   Source: "game"
              Identifier option
                 Type: uint256
                 Source: "option"
          Identifier sender
             Type: address
             Source: "sender"
      IfStatement
         Source: "if(value > 0){\r\n            uint256 total =safeDiv(safeMul(results[game].betTotal,value),results[game].winningOptionTotal);\r\n            return total;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 9
           Source: "value > 0"
          Identifier value
             Type: uint256
             Source: "value"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            uint256 total =safeDiv(safeMul(results[game].betTotal,value),results[game].winningOptionTotal);\r\n            return total;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 605
             Source: "uint256 total =safeDiv(safeMul(results[game].betTotal,value),results[game].winningOptionTotal)"
            VariableDeclaration "total"
               Type: uint256
               Source: "uint256 total"
              ElementaryTypeName uint256
                 Source: "uint256"
            FunctionCall
               Type: uint256
               Source: "safeDiv(safeMul(results[game].betTotal,value),results[game].winningOptionTotal)"
              Identifier safeDiv
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "safeDiv"
              FunctionCall
                 Type: uint256
                 Source: "safeMul(results[game].betTotal,value)"
                Identifier safeMul
                   Type: function (uint256,uint256) returns (uint256)
                   Source: "safeMul"
                MemberAccess to member betTotal
                   Type: uint256
                   Source: "results[game].betTotal"
                  IndexAccess
                     Type: struct TheMoneyFightToken.Result storage ref
                     Source: "results[game]"
                    Identifier results
                       Type: mapping(uint256 => struct TheMoneyFightToken.Result storage ref)
                       Source: "results"
                    Identifier game
                       Type: uint256
                       Source: "game"
                Identifier value
                   Type: uint256
                   Source: "value"
              MemberAccess to member winningOptionTotal
                 Type: uint256
                 Source: "results[game].winningOptionTotal"
                IndexAccess
                   Type: struct TheMoneyFightToken.Result storage ref
                   Source: "results[game]"
                  Identifier results
                     Type: mapping(uint256 => struct TheMoneyFightToken.Result storage ref)
                     Source: "results"
                  Identifier game
                     Type: uint256
                     Source: "game"
          Return
             Gas costs: 19
             Source: "return total"
            Identifier total
               Type: uint256
               Source: "total"
      Return
         Gas costs: 8
         Source: "return 0"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
  FunctionDefinition "finishGame" - public
     Source: "function finishGame(uint game, uint winOption) only_owner {\r\n       Game curr = games[game];\r\n       curr.status = betStatus.Done;  \r\n       results[game] = Result(winOption, now + LOSER_LOCK_TIME, curr.total, curr.totalBets[winOption]); \r\n       gameFinished(game, winOption, curr.total, curr.totalBets[winOption]);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint game, uint winOption)"
      VariableDeclaration "game"
         Type: uint256
         Source: "uint game"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "winOption"
         Type: uint256
         Source: "uint winOption"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "only_owner"
       Gas costs: 0
       Source: "only_owner"
      Identifier only_owner
         Type: modifier ()
         Source: "only_owner"
    Block
       Source: "{\r\n       Game curr = games[game];\r\n       curr.status = betStatus.Done;  \r\n       results[game] = Result(winOption, now + LOSER_LOCK_TIME, curr.total, curr.totalBets[winOption]); \r\n       gameFinished(game, winOption, curr.total, curr.totalBets[winOption]);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 95
         Source: "Game curr = games[game]"
        VariableDeclaration "curr"
           Type: struct TheMoneyFightToken.Game storage pointer
           Source: "Game curr"
          UserDefinedTypeName "Game"
             Source: "Game"
        IndexAccess
           Type: struct TheMoneyFightToken.Game storage ref
           Source: "games[game]"
          Identifier games
             Type: mapping(uint256 => struct TheMoneyFightToken.Game storage ref)
             Source: "games"
          Identifier game
             Type: uint256
             Source: "game"
      ExpressionStatement
         Gas costs: 20293
         Source: "curr.status = betStatus.Done"
        Assignment using operator =
           Type: enum TheMoneyFightToken.betStatus
           Source: "curr.status = betStatus.Done"
          MemberAccess to member status
             Type: enum TheMoneyFightToken.betStatus
             Source: "curr.status"
            Identifier curr
               Type: struct TheMoneyFightToken.Game storage pointer
               Source: "curr"
          MemberAccess to member Done
             Type: enum TheMoneyFightToken.betStatus
             Source: "betStatus.Done"
            Identifier betStatus
               Type: type(enum TheMoneyFightToken.betStatus)
               Source: "betStatus"
      ExpressionStatement
         Gas costs: [???]
         Source: "results[game] = Result(winOption, now + LOSER_LOCK_TIME, curr.total, curr.totalBets[winOption])"
        Assignment using operator =
           Type: struct TheMoneyFightToken.Result storage ref
           Source: "results[game] = Result(winOption, now + LOSER_LOCK_TIME, curr.total, curr.totalBets[winOption])"
          IndexAccess
             Type: struct TheMoneyFightToken.Result storage ref
             Source: "results[game]"
            Identifier results
               Type: mapping(uint256 => struct TheMoneyFightToken.Result storage ref)
               Source: "results"
            Identifier game
               Type: uint256
               Source: "game"
          FunctionCall
             Type: struct TheMoneyFightToken.Result memory
             Source: "Result(winOption, now + LOSER_LOCK_TIME, curr.total, curr.totalBets[winOption])"
            Identifier Result
               Type: type(struct TheMoneyFightToken.Result storage pointer)
               Source: "Result"
            Identifier winOption
               Type: uint256
               Source: "winOption"
            BinaryOperation using operator +
               Type: uint256
               Source: "now + LOSER_LOCK_TIME"
              Identifier now
                 Type: uint256
                 Source: "now"
              Identifier LOSER_LOCK_TIME
                 Type: uint256
                 Source: "LOSER_LOCK_TIME"
            MemberAccess to member total
               Type: uint256
               Source: "curr.total"
              Identifier curr
                 Type: struct TheMoneyFightToken.Game storage pointer
                 Source: "curr"
            IndexAccess
               Type: uint256
               Source: "curr.totalBets[winOption]"
              MemberAccess to member totalBets
                 Type: mapping(uint256 => uint256)
                 Source: "curr.totalBets"
                Identifier curr
                   Type: struct TheMoneyFightToken.Game storage pointer
                   Source: "curr"
              Identifier winOption
                 Type: uint256
                 Source: "winOption"
      ExpressionStatement
         Gas costs: [???]
         Source: "gameFinished(game, winOption, curr.total, curr.totalBets[winOption])"
        FunctionCall
           Type: tuple()
           Source: "gameFinished(game, winOption, curr.total, curr.totalBets[winOption])"
          Identifier gameFinished
             Type: function (uint256,uint256,uint256,uint256)
             Source: "gameFinished"
          Identifier game
             Type: uint256
             Source: "game"
          Identifier winOption
             Type: uint256
             Source: "winOption"
          MemberAccess to member total
             Type: uint256
             Source: "curr.total"
            Identifier curr
               Type: struct TheMoneyFightToken.Game storage pointer
               Source: "curr"
          IndexAccess
             Type: uint256
             Source: "curr.totalBets[winOption]"
            MemberAccess to member totalBets
               Type: mapping(uint256 => uint256)
               Source: "curr.totalBets"
              Identifier curr
                 Type: struct TheMoneyFightToken.Game storage pointer
                 Source: "curr"
            Identifier winOption
               Type: uint256
               Source: "winOption"
  FunctionDefinition "drain" - public
     Source: "function drain(uint256 bal) only_owner {\r\n\t\tif (!owner.send(bal)) throw;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint256 bal)"
      VariableDeclaration "bal"
         Type: uint256
         Source: "uint256 bal"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "only_owner"
       Gas costs: 0
       Source: "only_owner"
      Identifier only_owner
         Type: modifier ()
         Source: "only_owner"
    Block
       Source: "{\r\n\t\tif (!owner.send(bal)) throw;\r\n\t}"
      IfStatement
         Source: "if (!owner.send(bal)) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!owner.send(bal)"
          FunctionCall
             Type: bool
             Source: "owner.send(bal)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "owner.send"
              Identifier owner
                 Type: address
                 Source: "owner"
            Identifier bal
               Type: uint256
               Source: "bal"
        Throw
           Gas costs: 6
           Source: "throw"
  FunctionDefinition "getTotalPrediction" - public - const
     Source: "function getTotalPrediction(uint game, uint option) public constant returns (uint256 total,uint256 totalOption){\r\n\t    Game curr = games[game];\r\n\t    return (curr.total, curr.totalBets[option]);\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint game, uint option)"
      VariableDeclaration "game"
         Type: uint256
         Source: "uint game"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "option"
         Type: uint256
         Source: "uint option"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 6
       Source: "(uint256 total,uint256 totalOption)"
      VariableDeclaration "total"
         Type: uint256
         Source: "uint256 total"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "totalOption"
         Type: uint256
         Source: "uint256 totalOption"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n\t    Game curr = games[game];\r\n\t    return (curr.total, curr.totalBets[option]);\r\n\t}"
      VariableDeclarationStatement
         Gas costs: 95
         Source: "Game curr = games[game]"
        VariableDeclaration "curr"
           Type: struct TheMoneyFightToken.Game storage pointer
           Source: "Game curr"
          UserDefinedTypeName "Game"
             Source: "Game"
        IndexAccess
           Type: struct TheMoneyFightToken.Game storage ref
           Source: "games[game]"
          Identifier games
             Type: mapping(uint256 => struct TheMoneyFightToken.Game storage ref)
             Source: "games"
          Identifier game
             Type: uint256
             Source: "game"
      Return
         Gas costs: 506
         Source: "return (curr.total, curr.totalBets[option])"
        TupleExpression
           Type: tuple(uint256,uint256)
           Source: "(curr.total, curr.totalBets[option])"
          MemberAccess to member total
             Type: uint256
             Source: "curr.total"
            Identifier curr
               Type: struct TheMoneyFightToken.Game storage pointer
               Source: "curr"
          IndexAccess
             Type: uint256
             Source: "curr.totalBets[option]"
            MemberAccess to member totalBets
               Type: mapping(uint256 => uint256)
               Source: "curr.totalBets"
              Identifier curr
                 Type: struct TheMoneyFightToken.Game storage pointer
                 Source: "curr"
            Identifier option
               Type: uint256
               Source: "option"
  FunctionDefinition "getPrediction" - public
     Source: "function getPrediction(uint game, uint o) returns (uint256 bet) {\r\n        return gameOptions[game][o].status[msg.sender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint game, uint o)"
      VariableDeclaration "game"
         Type: uint256
         Source: "uint game"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "o"
         Type: uint256
         Source: "uint o"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint256 bet)"
      VariableDeclaration "bet"
         Type: uint256
         Source: "uint256 bet"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return gameOptions[game][o].status[msg.sender];\r\n    }"
      Return
         Gas costs: 679
         Source: "return gameOptions[game][o].status[msg.sender]"
        IndexAccess
           Type: uint256
           Source: "gameOptions[game][o].status[msg.sender]"
          MemberAccess to member status
             Type: mapping(address => uint256)
             Source: "gameOptions[game][o].status"
            IndexAccess
               Type: struct TheMoneyFightToken.Option storage ref
               Source: "gameOptions[game][o]"
              IndexAccess
                 Type: struct TheMoneyFightToken.Option storage ref[] storage ref
                 Source: "gameOptions[game]"
                Identifier gameOptions
                   Type: mapping(uint256 => struct TheMoneyFightToken.Option storage ref[] storage ref)
                   Source: "gameOptions"
                Identifier game
                   Type: uint256
                   Source: "game"
              Identifier o
                 Type: uint256
                 Source: "o"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "withdrawForeignTokens" - public
     Source: "function withdrawForeignTokens(address _tokenContract) only_owner returns (bool) {\r\n        ForeignToken token = ForeignToken(_tokenContract);\r\n        uint256 amount = token.balanceOf(address(this));\r\n        return token.transfer(owner, amount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _tokenContract)"
      VariableDeclaration "_tokenContract"
         Type: address
         Source: "address _tokenContract"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "only_owner"
       Gas costs: 0
       Source: "only_owner"
      Identifier only_owner
         Type: modifier ()
         Source: "only_owner"
    Block
       Source: "{\r\n        ForeignToken token = ForeignToken(_tokenContract);\r\n        uint256 amount = token.balanceOf(address(this));\r\n        return token.transfer(owner, amount);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "ForeignToken token = ForeignToken(_tokenContract)"
        VariableDeclaration "token"
           Type: contract ForeignToken
           Source: "ForeignToken token"
          UserDefinedTypeName "ForeignToken"
             Source: "ForeignToken"
        FunctionCall
           Type: contract ForeignToken
           Source: "ForeignToken(_tokenContract)"
          Identifier ForeignToken
             Type: type(contract ForeignToken)
             Source: "ForeignToken"
          Identifier _tokenContract
             Type: address
             Source: "_tokenContract"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint256 amount = token.balanceOf(address(this))"
        VariableDeclaration "amount"
           Type: uint256
           Source: "uint256 amount"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "token.balanceOf(address(this))"
          MemberAccess to member balanceOf
             Type: function (address) view external returns (uint256)
             Source: "token.balanceOf"
            Identifier token
               Type: contract ForeignToken
               Source: "token"
          FunctionCall
             Type: address
             Source: "address(this)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier this
               Type: contract TheMoneyFightToken
               Source: "this"
      Return
         Gas costs: [???]
         Source: "return token.transfer(owner, amount)"
        FunctionCall
           Type: bool
           Source: "token.transfer(owner, amount)"
          MemberAccess to member transfer
             Type: function (address,uint256) external returns (bool)
             Source: "token.transfer"
            Identifier token
               Type: contract ForeignToken
               Source: "token"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier amount
             Type: uint256
             Source: "amount"
  FunctionDefinition "enablePurchasing" - public
     Source: "function enablePurchasing() only_owner {\r\n        purchasingAllowed = true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "only_owner"
       Gas costs: 0
       Source: "only_owner"
      Identifier only_owner
         Type: modifier ()
         Source: "only_owner"
    Block
       Source: "{\r\n        purchasingAllowed = true;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "purchasingAllowed = true"
        Assignment using operator =
           Type: bool
           Source: "purchasingAllowed = true"
          Identifier purchasingAllowed
             Type: bool
             Source: "purchasingAllowed"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "disablePurchasing" - public
     Source: "function disablePurchasing() only_owner{\r\n        purchasingAllowed = false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "only_owner"
       Gas costs: 0
       Source: "only_owner"
      Identifier only_owner
         Type: modifier ()
         Source: "only_owner"
    Block
       Source: "{\r\n        purchasingAllowed = false;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "purchasingAllowed = false"
        Assignment using operator =
           Type: bool
           Source: "purchasingAllowed = false"
          Identifier purchasingAllowed
             Type: bool
             Source: "purchasingAllowed"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "" - public
     Source: "function() payable etherCapNotReached(msg.value) {\r\n        if (!purchasingAllowed) { throw; }\r\n        \r\n        if (msg.value == 0) { return; }\r\n\r\n        owner.transfer(msg.value);\r\n        totalContribution += msg.value;\r\n\r\n        uint256 tokensIssued = msg.value * 100;\r\n\r\n        totalSupply += tokensIssued;\r\n        balances[msg.sender] += tokensIssued;\r\n        \r\n        Transfer(address(this), msg.sender, tokensIssued);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "etherCapNotReached"
       Gas costs: 2
       Source: "etherCapNotReached(msg.value)"
      Identifier etherCapNotReached
         Type: modifier (uint256)
         Source: "etherCapNotReached"
      MemberAccess to member value
         Type: uint256
         Source: "msg.value"
        Identifier msg
           Type: msg
           Source: "msg"
    Block
       Source: "{\r\n        if (!purchasingAllowed) { throw; }\r\n        \r\n        if (msg.value == 0) { return; }\r\n\r\n        owner.transfer(msg.value);\r\n        totalContribution += msg.value;\r\n\r\n        uint256 tokensIssued = msg.value * 100;\r\n\r\n        totalSupply += tokensIssued;\r\n        balances[msg.sender] += tokensIssued;\r\n        \r\n        Transfer(address(this), msg.sender, tokensIssued);\r\n    }"
      IfStatement
         Source: "if (!purchasingAllowed) { throw; }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 242
           Source: "!purchasingAllowed"
          Identifier purchasingAllowed
             Type: bool
             Source: "purchasingAllowed"
        Block
           Source: "{ throw; }"
          Throw
             Gas costs: 6
             Source: "throw"
      IfStatement
         Source: "if (msg.value == 0) { return; }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 8
           Source: "msg.value == 0"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{ return; }"
          Return
             Gas costs: 11
             Source: "return;"
      ExpressionStatement
         Gas costs: [???]
         Source: "owner.transfer(msg.value)"
        FunctionCall
           Type: tuple()
           Source: "owner.transfer(msg.value)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "owner.transfer"
            Identifier owner
               Type: address
               Source: "owner"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20232
         Source: "totalContribution += msg.value"
        Assignment using operator +=
           Type: uint256
           Source: "totalContribution += msg.value"
          Identifier totalContribution
             Type: uint256
             Source: "totalContribution"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      VariableDeclarationStatement
         Gas costs: 18
         Source: "uint256 tokensIssued = msg.value * 100"
        VariableDeclaration "tokensIssued"
           Type: uint256
           Source: "uint256 tokensIssued"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "msg.value * 100"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 100
             Type: int_const 100
             Source: "100"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply += tokensIssued"
        Assignment using operator +=
           Type: uint256
           Source: "totalSupply += tokensIssued"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier tokensIssued
             Type: uint256
             Source: "tokensIssued"
      ExpressionStatement
         Gas costs: 20328
         Source: "balances[msg.sender] += tokensIssued"
        Assignment using operator +=
           Type: uint256
           Source: "balances[msg.sender] += tokensIssued"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier tokensIssued
             Type: uint256
             Source: "tokensIssued"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(address(this), msg.sender, tokensIssued)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(address(this), msg.sender, tokensIssued)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          FunctionCall
             Type: address
             Source: "address(this)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier this
               Type: contract TheMoneyFightToken
               Source: "this"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier tokensIssued
             Type: uint256
             Source: "tokensIssued"
