Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x2ce0de89daf06d729b4bb6cca8e28e068f2c9f7b.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.0;"
ContractDefinition "TokenInterface"
   Gas costs: 0
   Source: "contract TokenInterface {\r\n\r\n        \r\n    // total amount of tokens\r\n    uint totalSupply;\r\n\r\n    \r\n    /**\r\n     *\r\n     * balanceOf() - constant function check concrete tokens balance  \r\n     *\r\n     *  @param owner - account owner\r\n     *  \r\n     *  @return the value of balance \r\n     */                               \r\n    function balanceOf(address owner) constant returns (uint256 balance);\r\n    \r\n    function transfer(address to, uint256 value) returns (bool success);\r\n\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     *\r\n     * approve() - function approves to a person to spend some tokens from \r\n     *           owner balance. \r\n     *\r\n     *  @param spender - person whom this right been granted.\r\n     *  @param value   - value to spend.\r\n     * \r\n     *  @return true in case of succes, otherwise failure\r\n     * \r\n     */\r\n    function approve(address spender, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     *\r\n     * allowance() - constant function to check how much is \r\n     *               permitted to spend to 3rd person from owner balance\r\n     *\r\n     *  @param owner   - owner of the balance\r\n     *  @param spender - permitted to spend from this balance person \r\n     *  \r\n     *  @return - remaining right to spend \r\n     * \r\n     */\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining);\r\n\r\n    // events notifications\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint totalSupply"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address owner) constant returns (uint256 balance);"
    ParameterList
       Source: "(address owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint256 value) returns (bool success);"
    ParameterList
       Source: "(address to, uint256 value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint256 value) returns (bool success);"
    ParameterList
       Source: "(address from, address to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint256 value) returns (bool success);"
    ParameterList
       Source: "(address spender, uint256 value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) constant returns (uint256 remaining);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint256 value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint256 value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is TokenInterface {\r\n\r\n\r\n    // token ownership\r\n    mapping (address => uint256) balances;\r\n\r\n    // spending permision management\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    \r\n    \r\n    function StandardToken(){\r\n    }\r\n    \r\n    \r\n    /**\r\n     * transfer() - transfer tokens from msg.sender balance \r\n     *              to requested account\r\n     *\r\n     *  @param to    - target address to transfer tokens\r\n     *  @param value - ammount of tokens to transfer\r\n     *\r\n     *  @return - success / failure of the transaction\r\n     */    \r\n    function transfer(address to, uint256 value) returns (bool success) {\r\n        \r\n        \r\n        if (balances[msg.sender] >= value && value > 0) {\r\n\r\n            // do actual tokens transfer       \r\n            balances[msg.sender] -= value;\r\n            balances[to]         += value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            \r\n            return false; \r\n        }\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    /**\r\n     * transferFrom() - \r\n     *\r\n     *  @param from  - \r\n     *  @param to    - \r\n     *  @param value - \r\n     *\r\n     *  @return \r\n     */\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success) {\r\n    \r\n        if ( balances[from] >= value && \r\n             allowed[from][msg.sender] >= value && \r\n             value > 0) {\r\n                                          \r\n    \r\n            // do the actual transfer\r\n            balances[from] -= value;    \r\n            balances[to] =+ value;            \r\n            \r\n\r\n            // addjust the permision, after part of \r\n            // permited to spend value was used\r\n            allowed[from][msg.sender] -= value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(from, to, value);\r\n            return true;\r\n        } else { \r\n            \r\n            return false; \r\n        }\r\n    }\r\n\r\n    \r\n\r\n    \r\n    /**\r\n     *\r\n     * balanceOf() - constant function check concrete tokens balance  \r\n     *\r\n     *  @param owner - account owner\r\n     *  \r\n     *  @return the value of balance \r\n     */                               \r\n    function balanceOf(address owner) constant returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n     *\r\n     * approve() - function approves to a person to spend some tokens from \r\n     *           owner balance. \r\n     *\r\n     *  @param spender - person whom this right been granted.\r\n     *  @param value   - value to spend.\r\n     * \r\n     *  @return true in case of succes, otherwise failure\r\n     * \r\n     */\r\n    function approve(address spender, uint256 value) returns (bool success) {\r\n        \r\n        // now spender can use balance in \r\n        // ammount of value from owner balance\r\n        allowed[msg.sender][spender] = value;\r\n        \r\n        // rise event about the transaction\r\n        Approval(msg.sender, spender, value);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * allowance() - constant function to check how mouch is \r\n     *               permited to spend to 3rd person from owner balance\r\n     *\r\n     *  @param owner   - owner of the balance\r\n     *  @param spender - permited to spend from this balance person \r\n     *  \r\n     *  @return - remaining right to spend \r\n     * \r\n     */\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining) {\r\n      return allowed[owner][spender];\r\n    }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "TokenInterface"
    UserDefinedTypeName "TokenInterface"
       Source: "TokenInterface"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balances"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "StandardToken" - public
     Source: "function StandardToken(){\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Gas costs: 0
       Source: "{\r\n    }"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint256 value) returns (bool success) {\r\n        \r\n        \r\n        if (balances[msg.sender] >= value && value > 0) {\r\n\r\n            // do actual tokens transfer       \r\n            balances[msg.sender] -= value;\r\n            balances[to]         += value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            \r\n            return false; \r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address to, uint256 value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        \r\n        \r\n        if (balances[msg.sender] >= value && value > 0) {\r\n\r\n            // do actual tokens transfer       \r\n            balances[msg.sender] -= value;\r\n            balances[to]         += value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            \r\n            return false; \r\n        }\r\n    }"
      IfStatement
         Source: "if (balances[msg.sender] >= value && value > 0) {\r\n\r\n            // do actual tokens transfer       \r\n            balances[msg.sender] -= value;\r\n            balances[to]         += value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            \r\n            return false; \r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "balances[msg.sender] >= value && value > 0"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier value
               Type: uint256
               Source: "value"
          BinaryOperation using operator >
             Type: bool
             Source: "value > 0"
            Identifier value
               Type: uint256
               Source: "value"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n\r\n            // do actual tokens transfer       \r\n            balances[msg.sender] -= value;\r\n            balances[to]         += value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(msg.sender, to, value);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "balances[msg.sender] -= value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[msg.sender] -= value"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier value
                 Type: uint256
                 Source: "value"
          ExpressionStatement
             Gas costs: 0
             Source: "balances[to]         += value"
            Assignment using operator +=
               Type: uint256
               Source: "balances[to]         += value"
              IndexAccess
                 Type: uint256
                 Source: "balances[to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier to
                   Type: address
                   Source: "to"
              Identifier value
                 Type: uint256
                 Source: "value"
          ExpressionStatement
             Gas costs: 0
             Source: "Transfer(msg.sender, to, value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(msg.sender, to, value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier to
                 Type: address
                 Source: "to"
              Identifier value
                 Type: uint256
                 Source: "value"
          Return
             Gas costs: 0
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{\r\n            \r\n            return false; \r\n        }"
          Return
             Gas costs: 0
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint256 value) returns (bool success) {\r\n    \r\n        if ( balances[from] >= value && \r\n             allowed[from][msg.sender] >= value && \r\n             value > 0) {\r\n                                          \r\n    \r\n            // do the actual transfer\r\n            balances[from] -= value;    \r\n            balances[to] =+ value;            \r\n            \r\n\r\n            // addjust the permision, after part of \r\n            // permited to spend value was used\r\n            allowed[from][msg.sender] -= value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(from, to, value);\r\n            return true;\r\n        } else { \r\n            \r\n            return false; \r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address from, address to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    \r\n        if ( balances[from] >= value && \r\n             allowed[from][msg.sender] >= value && \r\n             value > 0) {\r\n                                          \r\n    \r\n            // do the actual transfer\r\n            balances[from] -= value;    \r\n            balances[to] =+ value;            \r\n            \r\n\r\n            // addjust the permision, after part of \r\n            // permited to spend value was used\r\n            allowed[from][msg.sender] -= value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(from, to, value);\r\n            return true;\r\n        } else { \r\n            \r\n            return false; \r\n        }\r\n    }"
      IfStatement
         Source: "if ( balances[from] >= value && \r\n             allowed[from][msg.sender] >= value && \r\n             value > 0) {\r\n                                          \r\n    \r\n            // do the actual transfer\r\n            balances[from] -= value;    \r\n            balances[to] =+ value;            \r\n            \r\n\r\n            // addjust the permision, after part of \r\n            // permited to spend value was used\r\n            allowed[from][msg.sender] -= value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(from, to, value);\r\n            return true;\r\n        } else { \r\n            \r\n            return false; \r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "balances[from] >= value && \r\n             allowed[from][msg.sender] >= value && \r\n             value > 0"
          BinaryOperation using operator &&
             Type: bool
             Source: "balances[from] >= value && \r\n             allowed[from][msg.sender] >= value"
            BinaryOperation using operator >=
               Type: bool
               Source: "balances[from] >= value"
              IndexAccess
                 Type: uint256
                 Source: "balances[from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier from
                   Type: address
                   Source: "from"
              Identifier value
                 Type: uint256
                 Source: "value"
            BinaryOperation using operator >=
               Type: bool
               Source: "allowed[from][msg.sender] >= value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier from
                     Type: address
                     Source: "from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier value
                 Type: uint256
                 Source: "value"
          BinaryOperation using operator >
             Type: bool
             Source: "value > 0"
            Identifier value
               Type: uint256
               Source: "value"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n                                          \r\n    \r\n            // do the actual transfer\r\n            balances[from] -= value;    \r\n            balances[to] =+ value;            \r\n            \r\n\r\n            // addjust the permision, after part of \r\n            // permited to spend value was used\r\n            allowed[from][msg.sender] -= value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(from, to, value);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "balances[from] -= value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[from] -= value"
              IndexAccess
                 Type: uint256
                 Source: "balances[from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier from
                   Type: address
                   Source: "from"
              Identifier value
                 Type: uint256
                 Source: "value"
          ExpressionStatement
             Gas costs: 0
             Source: "balances[to] =+ value"
            Assignment using operator =
               Type: uint256
               Source: "balances[to] =+ value"
              IndexAccess
                 Type: uint256
                 Source: "balances[to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier to
                   Type: address
                   Source: "to"
              UnaryOperation (prefix) +
                 Type: uint256
                 Source: "+ value"
                Identifier value
                   Type: uint256
                   Source: "value"
          ExpressionStatement
             Gas costs: 0
             Source: "allowed[from][msg.sender] -= value"
            Assignment using operator -=
               Type: uint256
               Source: "allowed[from][msg.sender] -= value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier from
                     Type: address
                     Source: "from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier value
                 Type: uint256
                 Source: "value"
          ExpressionStatement
             Gas costs: 0
             Source: "Transfer(from, to, value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(from, to, value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              Identifier from
                 Type: address
                 Source: "from"
              Identifier to
                 Type: address
                 Source: "to"
              Identifier value
                 Type: uint256
                 Source: "value"
          Return
             Gas costs: 0
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{ \r\n            \r\n            return false; \r\n        }"
          Return
             Gas costs: 0
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address owner) constant returns (uint256 balance) {\r\n        return balances[owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address owner)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balances[owner];\r\n    }"
      Return
         Gas costs: 0
         Source: "return balances[owner]"
        IndexAccess
           Type: uint256
           Source: "balances[owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier owner
             Type: address
             Source: "owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint256 value) returns (bool success) {\r\n        \r\n        // now spender can use balance in \r\n        // ammount of value from owner balance\r\n        allowed[msg.sender][spender] = value;\r\n        \r\n        // rise event about the transaction\r\n        Approval(msg.sender, spender, value);\r\n        \r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address spender, uint256 value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        \r\n        // now spender can use balance in \r\n        // ammount of value from owner balance\r\n        allowed[msg.sender][spender] = value;\r\n        \r\n        // rise event about the transaction\r\n        Approval(msg.sender, spender, value);\r\n        \r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[msg.sender][spender] = value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][spender] = value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier spender
               Type: address
               Source: "spender"
          Identifier value
             Type: uint256
             Source: "value"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(msg.sender, spender, value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, spender, value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier spender
             Type: address
             Source: "spender"
          Identifier value
             Type: uint256
             Source: "value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) constant returns (uint256 remaining) {\r\n      return allowed[owner][spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      return allowed[owner][spender];\r\n    }"
      Return
         Gas costs: 0
         Source: "return allowed[owner][spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[owner][spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier owner
               Type: address
               Source: "owner"
          Identifier spender
             Type: address
             Source: "spender"
ContractDefinition "HackerGold"
   Source: "contract HackerGold is StandardToken {\r\n\r\n    // Name of the token    \r\n    string public name = \"HackerGold\";\r\n\r\n    // Decimal places\r\n    uint8  public decimals = 3;\r\n    // Token abbreviation        \r\n    string public symbol = \"HKG\";\r\n    \r\n    // 1 ether = 200 hkg\r\n    uint BASE_PRICE = 200;\r\n    // 1 ether = 150 hkg\r\n    uint MID_PRICE = 150;\r\n    // 1 ether = 100 hkg\r\n    uint FIN_PRICE = 100;\r\n    // Safety cap\r\n    uint SAFETY_LIMIT = 4000000 ether;\r\n    // Zeros after the point\r\n    uint DECIMAL_ZEROS = 1000;\r\n    \r\n    // Total value in wei\r\n    uint totalValue;\r\n    \r\n    // Address of multisig wallet holding ether from sale\r\n    address wallet;\r\n\r\n    // Structure of sale increase milestones\r\n    struct milestones_struct {\r\n      uint p1;\r\n      uint p2; \r\n      uint p3;\r\n      uint p4;\r\n      uint p5;\r\n      uint p6;\r\n    }\r\n    // Milestones instance\r\n    milestones_struct milestones;\r\n    \r\n    /**\r\n     * Constructor of the contract.\r\n     * \r\n     * Passes address of the account holding the value.\r\n     * HackerGold contract itself does not hold any value\r\n     * \r\n     * @param multisig address of MultiSig wallet which will hold the value\r\n     */\r\n    function HackerGold(address multisig) {\r\n        \r\n        wallet = multisig;\r\n\r\n        // set time periods for sale\r\n        milestones = milestones_struct(\r\n        \r\n          1476972000,  // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\r\n          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \r\n          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \r\n                       //                                Hackathon Starts\r\n          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\r\n          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\r\n          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\r\n        );\r\n                \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Fallback function: called on ether sent.\r\n     * \r\n     * It calls to createHKG function with msg.sender \r\n     * as a value for holder argument\r\n     */\r\n    function () payable {\r\n        createHKG(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Creates HKG tokens.\r\n     * \r\n     * Runs sanity checks including safety cap\r\n     * Then calculates current price by getPrice() function, creates HKG tokens\r\n     * Finally sends a value of transaction to the wallet\r\n     * \r\n     * Note: due to lack of floating point types in Solidity,\r\n     * contract assumes that last 3 digits in tokens amount are stood after the point.\r\n     * It means that if stored HKG balance is 100000, then its real value is 100 HKG\r\n     * \r\n     * @param holder token holder\r\n     */\r\n    function createHKG(address holder) payable {\r\n        \r\n        if (now < milestones.p1) throw;\r\n        if (now >= milestones.p6) throw;\r\n        if (msg.value == 0) throw;\r\n    \r\n        // safety cap\r\n        if (getTotalValue() + msg.value > SAFETY_LIMIT) throw; \r\n    \r\n        uint tokens = msg.value * getPrice() * DECIMAL_ZEROS / 1 ether;\r\n\r\n        totalSupply += tokens;\r\n        balances[holder] += tokens;\r\n        totalValue += msg.value;\r\n        \r\n        if (!wallet.send(msg.value)) throw;\r\n    }\r\n    \r\n    /**\r\n     * Denotes complete price structure during the sale.\r\n     *\r\n     * @return HKG amount per 1 ETH for the current moment in time\r\n     */\r\n    function getPrice() constant returns (uint result) {\r\n        \r\n        if (now < milestones.p1) return 0;\r\n        \r\n        if (now >= milestones.p1 && now < milestones.p2) {\r\n        \r\n            return BASE_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p2 && now < milestones.p3) {\r\n            \r\n            uint days_in = 1 + (now - milestones.p2) / 1 days; \r\n            return BASE_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p3 && now < milestones.p4) {\r\n        \r\n            return MID_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p4 && now < milestones.p5) {\r\n            \r\n            days_in = 1 + (now - milestones.p4) / 1 days; \r\n            return MID_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p5 && now < milestones.p6) {\r\n        \r\n            return FIN_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p6){\r\n\r\n            return 0;\r\n        }\r\n\r\n     }\r\n    \r\n    /**\r\n     * Returns total stored HKG amount.\r\n     * \r\n     * Contract assumes that last 3 digits of this value are behind the decimal place. i.e. 10001 is 10.001\r\n     * Thus, result of this function should be divided by 1000 to get HKG value\r\n     * \r\n     * @return result stored HKG amount\r\n     */\r\n    function getTotalSupply() constant returns (uint result) {\r\n        return totalSupply;\r\n    } \r\n\r\n    /**\r\n     * It is used for test purposes.\r\n     * \r\n     * Returns the result of 'now' statement of Solidity language\r\n     * \r\n     * @return unix timestamp for current moment in time\r\n     */\r\n    function getNow() constant returns (uint result) {\r\n        return now;\r\n    }\r\n\r\n    /**\r\n     * Returns total value passed through the contract\r\n     * \r\n     * @return result total value in wei\r\n     */\r\n    function getTotalValue() constant returns (uint result) {\r\n        return totalValue;  \r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: 0
     Source: "string public name = \"HackerGold\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: HackerGold
       Type: literal_string "HackerGold"
       Source: "\"HackerGold\""
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: 0
     Source: "uint8  public decimals = 3"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 3
       Type: int_const 3
       Source: "3"
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: 0
     Source: "string public symbol = \"HKG\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: HKG
       Type: literal_string "HKG"
       Source: "\"HKG\""
  VariableDeclaration "BASE_PRICE"
     Type: uint256
     Gas costs: 0
     Source: "uint BASE_PRICE = 200"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 200
       Type: int_const 200
       Source: "200"
  VariableDeclaration "MID_PRICE"
     Type: uint256
     Gas costs: 0
     Source: "uint MID_PRICE = 150"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 150
       Type: int_const 150
       Source: "150"
  VariableDeclaration "FIN_PRICE"
     Type: uint256
     Gas costs: 0
     Source: "uint FIN_PRICE = 100"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 100
       Type: int_const 100
       Source: "100"
  VariableDeclaration "SAFETY_LIMIT"
     Type: uint256
     Gas costs: 0
     Source: "uint SAFETY_LIMIT = 4000000 ether"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 4000000
       Type: int_const 4000000000000000000000000
       Source: "4000000 ether"
  VariableDeclaration "DECIMAL_ZEROS"
     Type: uint256
     Gas costs: 0
     Source: "uint DECIMAL_ZEROS = 1000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1000
       Type: int_const 1000
       Source: "1000"
  VariableDeclaration "totalValue"
     Type: uint256
     Gas costs: 0
     Source: "uint totalValue"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "wallet"
     Type: address
     Gas costs: 0
     Source: "address wallet"
    ElementaryTypeName address
       Source: "address"
  StructDefinition "milestones_struct"
     Gas costs: 0
     Source: "struct milestones_struct {\r\n      uint p1;\r\n      uint p2; \r\n      uint p3;\r\n      uint p4;\r\n      uint p5;\r\n      uint p6;\r\n    }"
    VariableDeclaration "p1"
       Type: uint256
       Source: "uint p1"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "p2"
       Type: uint256
       Source: "uint p2"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "p3"
       Type: uint256
       Source: "uint p3"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "p4"
       Type: uint256
       Source: "uint p4"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "p5"
       Type: uint256
       Source: "uint p5"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "p6"
       Type: uint256
       Source: "uint p6"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "milestones"
     Type: struct HackerGold.milestones_struct storage ref
     Gas costs: 0
     Source: "milestones_struct milestones"
    UserDefinedTypeName "milestones_struct"
       Source: "milestones_struct"
  FunctionDefinition "HackerGold" - public
     Source: "function HackerGold(address multisig) {\r\n        \r\n        wallet = multisig;\r\n\r\n        // set time periods for sale\r\n        milestones = milestones_struct(\r\n        \r\n          1476972000,  // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\r\n          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \r\n          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \r\n                       //                                Hackathon Starts\r\n          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\r\n          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\r\n          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\r\n        );\r\n                \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address multisig)"
      VariableDeclaration "multisig"
         Type: address
         Source: "address multisig"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        \r\n        wallet = multisig;\r\n\r\n        // set time periods for sale\r\n        milestones = milestones_struct(\r\n        \r\n          1476972000,  // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\r\n          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \r\n          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \r\n                       //                                Hackathon Starts\r\n          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\r\n          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\r\n          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\r\n        );\r\n                \r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "wallet = multisig"
        Assignment using operator =
           Type: address
           Source: "wallet = multisig"
          Identifier wallet
             Type: address
             Source: "wallet"
          Identifier multisig
             Type: address
             Source: "multisig"
      ExpressionStatement
         Gas costs: 0
         Source: "milestones = milestones_struct(\r\n        \r\n          1476972000,  // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\r\n          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \r\n          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \r\n                       //                                Hackathon Starts\r\n          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\r\n          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\r\n          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\r\n        )"
        Assignment using operator =
           Type: struct HackerGold.milestones_struct storage ref
           Source: "milestones = milestones_struct(\r\n        \r\n          1476972000,  // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\r\n          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \r\n          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \r\n                       //                                Hackathon Starts\r\n          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\r\n          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\r\n          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\r\n        )"
          Identifier milestones
             Type: struct HackerGold.milestones_struct storage ref
             Source: "milestones"
          FunctionCall
             Type: struct HackerGold.milestones_struct memory
             Source: "milestones_struct(\r\n        \r\n          1476972000,  // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\r\n          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \r\n          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \r\n                       //                                Hackathon Starts\r\n          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\r\n          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\r\n          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\r\n        )"
            Identifier milestones_struct
               Type: type(struct HackerGold.milestones_struct storage pointer)
               Source: "milestones_struct"
            Literal, token: [no token] value: 1476972000
               Type: int_const 1476972000
               Source: "1476972000"
            Literal, token: [no token] value: 1478181600
               Type: int_const 1478181600
               Source: "1478181600"
            Literal, token: [no token] value: 1479391200
               Type: int_const 1479391200
               Source: "1479391200"
            Literal, token: [no token] value: 1480600800
               Type: int_const 1480600800
               Source: "1480600800"
            Literal, token: [no token] value: 1481810400
               Type: int_const 1481810400
               Source: "1481810400"
            Literal, token: [no token] value: 1482415200
               Type: int_const 1482415200
               Source: "1482415200"
  FunctionDefinition "" - public
     Source: "function () payable {\r\n        createHKG(msg.sender);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        createHKG(msg.sender);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "createHKG(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "createHKG(msg.sender)"
          Identifier createHKG
             Type: function (address)
             Source: "createHKG"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "createHKG" - public
     Source: "function createHKG(address holder) payable {\r\n        \r\n        if (now < milestones.p1) throw;\r\n        if (now >= milestones.p6) throw;\r\n        if (msg.value == 0) throw;\r\n    \r\n        // safety cap\r\n        if (getTotalValue() + msg.value > SAFETY_LIMIT) throw; \r\n    \r\n        uint tokens = msg.value * getPrice() * DECIMAL_ZEROS / 1 ether;\r\n\r\n        totalSupply += tokens;\r\n        balances[holder] += tokens;\r\n        totalValue += msg.value;\r\n        \r\n        if (!wallet.send(msg.value)) throw;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address holder)"
      VariableDeclaration "holder"
         Type: address
         Source: "address holder"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        \r\n        if (now < milestones.p1) throw;\r\n        if (now >= milestones.p6) throw;\r\n        if (msg.value == 0) throw;\r\n    \r\n        // safety cap\r\n        if (getTotalValue() + msg.value > SAFETY_LIMIT) throw; \r\n    \r\n        uint tokens = msg.value * getPrice() * DECIMAL_ZEROS / 1 ether;\r\n\r\n        totalSupply += tokens;\r\n        balances[holder] += tokens;\r\n        totalValue += msg.value;\r\n        \r\n        if (!wallet.send(msg.value)) throw;\r\n    }"
      IfStatement
         Source: "if (now < milestones.p1) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "now < milestones.p1"
          Identifier now
             Type: uint256
             Source: "now"
          MemberAccess to member p1
             Type: uint256
             Source: "milestones.p1"
            Identifier milestones
               Type: struct HackerGold.milestones_struct storage ref
               Source: "milestones"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (now >= milestones.p6) throw"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 0
           Source: "now >= milestones.p6"
          Identifier now
             Type: uint256
             Source: "now"
          MemberAccess to member p6
             Type: uint256
             Source: "milestones.p6"
            Identifier milestones
               Type: struct HackerGold.milestones_struct storage ref
               Source: "milestones"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (msg.value == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "msg.value == 0"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (getTotalValue() + msg.value > SAFETY_LIMIT) throw"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "getTotalValue() + msg.value > SAFETY_LIMIT"
          BinaryOperation using operator +
             Type: uint256
             Source: "getTotalValue() + msg.value"
            FunctionCall
               Type: uint256
               Source: "getTotalValue()"
              Identifier getTotalValue
                 Type: function () view returns (uint256)
                 Source: "getTotalValue"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier SAFETY_LIMIT
             Type: uint256
             Source: "SAFETY_LIMIT"
        Throw
           Gas costs: 0
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint tokens = msg.value * getPrice() * DECIMAL_ZEROS / 1 ether"
        VariableDeclaration "tokens"
           Type: uint256
           Source: "uint tokens"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "msg.value * getPrice() * DECIMAL_ZEROS / 1 ether"
          BinaryOperation using operator *
             Type: uint256
             Source: "msg.value * getPrice() * DECIMAL_ZEROS"
            BinaryOperation using operator *
               Type: uint256
               Source: "msg.value * getPrice()"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
              FunctionCall
                 Type: uint256
                 Source: "getPrice()"
                Identifier getPrice
                   Type: function () view returns (uint256)
                   Source: "getPrice"
            Identifier DECIMAL_ZEROS
               Type: uint256
               Source: "DECIMAL_ZEROS"
          Literal, token: [no token] value: 1
             Type: int_const 1000000000000000000
             Source: "1 ether"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply += tokens"
        Assignment using operator +=
           Type: uint256
           Source: "totalSupply += tokens"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[holder] += tokens"
        Assignment using operator +=
           Type: uint256
           Source: "balances[holder] += tokens"
          IndexAccess
             Type: uint256
             Source: "balances[holder]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier holder
               Type: address
               Source: "holder"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: 0
         Source: "totalValue += msg.value"
        Assignment using operator +=
           Type: uint256
           Source: "totalValue += msg.value"
          Identifier totalValue
             Type: uint256
             Source: "totalValue"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (!wallet.send(msg.value)) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 0
           Source: "!wallet.send(msg.value)"
          FunctionCall
             Type: bool
             Source: "wallet.send(msg.value)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "wallet.send"
              Identifier wallet
                 Type: address
                 Source: "wallet"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
        Throw
           Gas costs: 0
           Source: "throw"
  FunctionDefinition "getPrice" - public - const
     Source: "function getPrice() constant returns (uint result) {\r\n        \r\n        if (now < milestones.p1) return 0;\r\n        \r\n        if (now >= milestones.p1 && now < milestones.p2) {\r\n        \r\n            return BASE_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p2 && now < milestones.p3) {\r\n            \r\n            uint days_in = 1 + (now - milestones.p2) / 1 days; \r\n            return BASE_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p3 && now < milestones.p4) {\r\n        \r\n            return MID_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p4 && now < milestones.p5) {\r\n            \r\n            days_in = 1 + (now - milestones.p4) / 1 days; \r\n            return MID_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p5 && now < milestones.p6) {\r\n        \r\n            return FIN_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p6){\r\n\r\n            return 0;\r\n        }\r\n\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        \r\n        if (now < milestones.p1) return 0;\r\n        \r\n        if (now >= milestones.p1 && now < milestones.p2) {\r\n        \r\n            return BASE_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p2 && now < milestones.p3) {\r\n            \r\n            uint days_in = 1 + (now - milestones.p2) / 1 days; \r\n            return BASE_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p3 && now < milestones.p4) {\r\n        \r\n            return MID_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p4 && now < milestones.p5) {\r\n            \r\n            days_in = 1 + (now - milestones.p4) / 1 days; \r\n            return MID_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p5 && now < milestones.p6) {\r\n        \r\n            return FIN_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p6){\r\n\r\n            return 0;\r\n        }\r\n\r\n     }"
      IfStatement
         Source: "if (now < milestones.p1) return 0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "now < milestones.p1"
          Identifier now
             Type: uint256
             Source: "now"
          MemberAccess to member p1
             Type: uint256
             Source: "milestones.p1"
            Identifier milestones
               Type: struct HackerGold.milestones_struct storage ref
               Source: "milestones"
        Return
           Gas costs: 0
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      IfStatement
         Source: "if (now >= milestones.p1 && now < milestones.p2) {\r\n        \r\n            return BASE_PRICE;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "now >= milestones.p1 && now < milestones.p2"
          BinaryOperation using operator >=
             Type: bool
             Source: "now >= milestones.p1"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member p1
               Type: uint256
               Source: "milestones.p1"
              Identifier milestones
                 Type: struct HackerGold.milestones_struct storage ref
                 Source: "milestones"
          BinaryOperation using operator <
             Type: bool
             Source: "now < milestones.p2"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member p2
               Type: uint256
               Source: "milestones.p2"
              Identifier milestones
                 Type: struct HackerGold.milestones_struct storage ref
                 Source: "milestones"
        Block
           Source: "{\r\n        \r\n            return BASE_PRICE;\r\n        }"
          Return
             Gas costs: 0
             Source: "return BASE_PRICE"
            Identifier BASE_PRICE
               Type: uint256
               Source: "BASE_PRICE"
      IfStatement
         Source: "if (now >= milestones.p2 && now < milestones.p3) {\r\n            \r\n            uint days_in = 1 + (now - milestones.p2) / 1 days; \r\n            return BASE_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "now >= milestones.p2 && now < milestones.p3"
          BinaryOperation using operator >=
             Type: bool
             Source: "now >= milestones.p2"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member p2
               Type: uint256
               Source: "milestones.p2"
              Identifier milestones
                 Type: struct HackerGold.milestones_struct storage ref
                 Source: "milestones"
          BinaryOperation using operator <
             Type: bool
             Source: "now < milestones.p3"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member p3
               Type: uint256
               Source: "milestones.p3"
              Identifier milestones
                 Type: struct HackerGold.milestones_struct storage ref
                 Source: "milestones"
        Block
           Source: "{\r\n            \r\n            uint days_in = 1 + (now - milestones.p2) / 1 days; \r\n            return BASE_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "uint days_in = 1 + (now - milestones.p2) / 1 days"
            VariableDeclaration "days_in"
               Type: uint256
               Source: "uint days_in"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator +
               Type: uint256
               Source: "1 + (now - milestones.p2) / 1 days"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "(now - milestones.p2) / 1 days"
                TupleExpression
                   Type: uint256
                   Source: "(now - milestones.p2)"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "now - milestones.p2"
                    Identifier now
                       Type: uint256
                       Source: "now"
                    MemberAccess to member p2
                       Type: uint256
                       Source: "milestones.p2"
                      Identifier milestones
                         Type: struct HackerGold.milestones_struct storage ref
                         Source: "milestones"
                Literal, token: [no token] value: 1
                   Type: int_const 86400
                   Source: "1 days"
          Return
             Gas costs: 0
             Source: "return BASE_PRICE - days_in * 25 / 7"
            BinaryOperation using operator -
               Type: uint256
               Source: "BASE_PRICE - days_in * 25 / 7"
              Identifier BASE_PRICE
                 Type: uint256
                 Source: "BASE_PRICE"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "days_in * 25 / 7"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "days_in * 25"
                  Identifier days_in
                     Type: uint256
                     Source: "days_in"
                  Literal, token: [no token] value: 25
                     Type: int_const 25
                     Source: "25"
                Literal, token: [no token] value: 7
                   Type: int_const 7
                   Source: "7"
      IfStatement
         Source: "if (now >= milestones.p3 && now < milestones.p4) {\r\n        \r\n            return MID_PRICE;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "now >= milestones.p3 && now < milestones.p4"
          BinaryOperation using operator >=
             Type: bool
             Source: "now >= milestones.p3"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member p3
               Type: uint256
               Source: "milestones.p3"
              Identifier milestones
                 Type: struct HackerGold.milestones_struct storage ref
                 Source: "milestones"
          BinaryOperation using operator <
             Type: bool
             Source: "now < milestones.p4"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member p4
               Type: uint256
               Source: "milestones.p4"
              Identifier milestones
                 Type: struct HackerGold.milestones_struct storage ref
                 Source: "milestones"
        Block
           Source: "{\r\n        \r\n            return MID_PRICE;\r\n        }"
          Return
             Gas costs: 0
             Source: "return MID_PRICE"
            Identifier MID_PRICE
               Type: uint256
               Source: "MID_PRICE"
      IfStatement
         Source: "if (now >= milestones.p4 && now < milestones.p5) {\r\n            \r\n            days_in = 1 + (now - milestones.p4) / 1 days; \r\n            return MID_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "now >= milestones.p4 && now < milestones.p5"
          BinaryOperation using operator >=
             Type: bool
             Source: "now >= milestones.p4"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member p4
               Type: uint256
               Source: "milestones.p4"
              Identifier milestones
                 Type: struct HackerGold.milestones_struct storage ref
                 Source: "milestones"
          BinaryOperation using operator <
             Type: bool
             Source: "now < milestones.p5"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member p5
               Type: uint256
               Source: "milestones.p5"
              Identifier milestones
                 Type: struct HackerGold.milestones_struct storage ref
                 Source: "milestones"
        Block
           Source: "{\r\n            \r\n            days_in = 1 + (now - milestones.p4) / 1 days; \r\n            return MID_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "days_in = 1 + (now - milestones.p4) / 1 days"
            Assignment using operator =
               Type: uint256
               Source: "days_in = 1 + (now - milestones.p4) / 1 days"
              Identifier days_in
                 Type: uint256
                 Source: "days_in"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "1 + (now - milestones.p4) / 1 days"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "(now - milestones.p4) / 1 days"
                  TupleExpression
                     Type: uint256
                     Source: "(now - milestones.p4)"
                    BinaryOperation using operator -
                       Type: uint256
                       Source: "now - milestones.p4"
                      Identifier now
                         Type: uint256
                         Source: "now"
                      MemberAccess to member p4
                         Type: uint256
                         Source: "milestones.p4"
                        Identifier milestones
                           Type: struct HackerGold.milestones_struct storage ref
                           Source: "milestones"
                  Literal, token: [no token] value: 1
                     Type: int_const 86400
                     Source: "1 days"
          Return
             Gas costs: 0
             Source: "return MID_PRICE - days_in * 25 / 7"
            BinaryOperation using operator -
               Type: uint256
               Source: "MID_PRICE - days_in * 25 / 7"
              Identifier MID_PRICE
                 Type: uint256
                 Source: "MID_PRICE"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "days_in * 25 / 7"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "days_in * 25"
                  Identifier days_in
                     Type: uint256
                     Source: "days_in"
                  Literal, token: [no token] value: 25
                     Type: int_const 25
                     Source: "25"
                Literal, token: [no token] value: 7
                   Type: int_const 7
                   Source: "7"
      IfStatement
         Source: "if (now >= milestones.p5 && now < milestones.p6) {\r\n        \r\n            return FIN_PRICE;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "now >= milestones.p5 && now < milestones.p6"
          BinaryOperation using operator >=
             Type: bool
             Source: "now >= milestones.p5"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member p5
               Type: uint256
               Source: "milestones.p5"
              Identifier milestones
                 Type: struct HackerGold.milestones_struct storage ref
                 Source: "milestones"
          BinaryOperation using operator <
             Type: bool
             Source: "now < milestones.p6"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member p6
               Type: uint256
               Source: "milestones.p6"
              Identifier milestones
                 Type: struct HackerGold.milestones_struct storage ref
                 Source: "milestones"
        Block
           Source: "{\r\n        \r\n            return FIN_PRICE;\r\n        }"
          Return
             Gas costs: 0
             Source: "return FIN_PRICE"
            Identifier FIN_PRICE
               Type: uint256
               Source: "FIN_PRICE"
      IfStatement
         Source: "if (now >= milestones.p6){\r\n\r\n            return 0;\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 0
           Source: "now >= milestones.p6"
          Identifier now
             Type: uint256
             Source: "now"
          MemberAccess to member p6
             Type: uint256
             Source: "milestones.p6"
            Identifier milestones
               Type: struct HackerGold.milestones_struct storage ref
               Source: "milestones"
        Block
           Source: "{\r\n\r\n            return 0;\r\n        }"
          Return
             Gas costs: 0
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "getTotalSupply" - public - const
     Source: "function getTotalSupply() constant returns (uint result) {\r\n        return totalSupply;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return totalSupply;\r\n    }"
      Return
         Gas costs: 0
         Source: "return totalSupply"
        Identifier totalSupply
           Type: uint256
           Source: "totalSupply"
  FunctionDefinition "getNow" - public - const
     Source: "function getNow() constant returns (uint result) {\r\n        return now;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return now;\r\n    }"
      Return
         Gas costs: 0
         Source: "return now"
        Identifier now
           Type: uint256
           Source: "now"
  FunctionDefinition "getTotalValue" - public - const
     Source: "function getTotalValue() constant returns (uint result) {\r\n        return totalValue;  \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return totalValue;  \r\n    }"
      Return
         Gas costs: 0
         Source: "return totalValue"
        Identifier totalValue
           Type: uint256
           Source: "totalValue"
ContractDefinition "DSTContract"
   Source: "contract DSTContract is StandardToken{\r\n\r\n    // Zeros after the point\r\n    uint DECIMAL_ZEROS = 1000;\r\n    // Proposal lifetime\r\n    uint PROPOSAL_LIFETIME = 10 days;\r\n    // Proposal funds threshold, in percents\r\n    uint PROPOSAL_FUNDS_TH = 20;\r\n\r\n    address   executive; \r\n        \r\n    EventInfo eventInfo;\r\n    \r\n    // Indicated where the DST is traded\r\n    address virtualExchangeAddress;\r\n    \r\n    HackerGold hackerGold;\r\n        \r\n    mapping (address => uint256) votingRights;\r\n\r\n\r\n    // 1 - HKG => DST qty; tokens for 1 HKG\r\n    uint hkgPrice;\r\n    \r\n    // 1 - Ether => DST qty; tokens for 1 Ether\r\n    uint etherPrice;\r\n    \r\n    string public name = \"...\";                   \r\n    uint8  public decimals = 3;                 \r\n    string public symbol = \"...\";\r\n    \r\n    bool ableToIssueTokens = true; \r\n    \r\n    uint preferedQtySold;\r\n\r\n    uint collectedHKG; \r\n    uint collectedEther;    \r\n    \r\n    // Proposal of the funds spending\r\n    mapping (bytes32 => Proposal) proposals;\r\n\r\n    enum ProposalCurrency { HKG, ETHER }\r\n    ProposalCurrency enumDeclaration;\r\n                  \r\n       \r\n    struct Proposal{\r\n        \r\n        bytes32 id;\r\n        uint value;\r\n\r\n        string urlDetails;\r\n\r\n        uint votindEndTS;\r\n                \r\n        uint votesObjecting;\r\n        \r\n        address submitter;\r\n        bool redeemed;\r\n\r\n        ProposalCurrency proposalCurrency;\r\n        \r\n        mapping (address => bool) voted;\r\n    }\r\n    uint counterProposals;\r\n    uint timeOfLastProposal;\r\n    \r\n    Proposal[] listProposals;\r\n    \r\n\r\n    /**\r\n     * Impeachment process proposals\r\n     */    \r\n    struct ImpeachmentProposal{\r\n        \r\n        string urlDetails;\r\n        \r\n        address newExecutive;\r\n\r\n        uint votindEndTS;        \r\n        uint votesSupporting;\r\n        \r\n        mapping (address => bool) voted;        \r\n    }\r\n    ImpeachmentProposal lastImpeachmentProposal;\r\n\r\n        \r\n    /**\r\n     * \r\n     *  DSTContract: ctor for DST token and governence contract\r\n     *\r\n     *  @param eventInfoAddr EventInfo: address of object denotes events \r\n     *                                  milestones      \r\n     *  @param hackerGoldAddr HackerGold: address of HackerGold token\r\n     *\r\n     *  @param dstName string: dstName: real name of the team\r\n     *\r\n     *  @param dstSymbol string: 3 letter symbold of the team\r\n     *\r\n     */ \r\n    function DSTContract(EventInfo eventInfoAddr, HackerGold hackerGoldAddr, string dstName, string dstSymbol){\r\n    \r\n      executive   = msg.sender;  \r\n      name        = dstName;\r\n      symbol      = dstSymbol;\r\n\r\n      hackerGold = HackerGold(hackerGoldAddr);\r\n      eventInfo  = EventInfo(eventInfoAddr);\r\n    }\r\n    \r\n\r\n    function() payable\r\n               onlyAfterEnd {\r\n        \r\n        // there is tokens left from hackathon \r\n        if (etherPrice == 0) throw;\r\n        \r\n        uint tokens = msg.value * etherPrice * DECIMAL_ZEROS / (1 ether);\r\n        \r\n        // check if demand of tokens is \r\n        // overflow the supply \r\n        uint retEther = 0;\r\n        if (balances[this] < tokens) {\r\n            \r\n            tokens = balances[this];\r\n            retEther = msg.value - tokens / etherPrice * (1 finney);\r\n        \r\n            // return left ether \r\n            if (!msg.sender.send(retEther)) throw;\r\n        }\r\n        \r\n        \r\n        // do transfer\r\n        balances[msg.sender] += tokens;\r\n        balances[this] -= tokens;\r\n        \r\n        // count collected ether \r\n        collectedEther += msg.value - retEther; \r\n        \r\n        // rise event\r\n        BuyForEtherTransaction(msg.sender, collectedEther, totalSupply, etherPrice, tokens);\r\n        \r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n     * setHKGPrice - set price: 1HKG => DST tokens qty\r\n     *\r\n     *  @param qtyForOneHKG uint: DST tokens for 1 HKG\r\n     * \r\n     */    \r\n     function setHKGPrice(uint qtyForOneHKG) onlyExecutive  {\r\n         \r\n         hkgPrice = qtyForOneHKG;\r\n         PriceHKGChange(qtyForOneHKG, preferedQtySold, totalSupply);\r\n     }\r\n     \r\n     \r\n    \r\n    /**\r\n     * \r\n     * issuePreferedTokens - prefered tokens issued on the hackathon event\r\n     *                       grant special rights\r\n     *\r\n     *  @param qtyForOneHKG uint: price DST tokens for one 1 HKG\r\n     *  @param qtyToEmit uint: new supply of tokens \r\n     * \r\n     */\r\n    function issuePreferedTokens(uint qtyForOneHKG, \r\n                                 uint qtyToEmit) onlyExecutive \r\n                                                 onlyIfAbleToIssueTokens\r\n                                                 onlyBeforeEnd\r\n                                                 onlyAfterTradingStart {\r\n                \r\n        // no issuence is allowed before enlisted on the\r\n        // exchange \r\n        if (virtualExchangeAddress == 0x0) throw;\r\n            \r\n        totalSupply    += qtyToEmit;\r\n        balances[this] += qtyToEmit;\r\n        hkgPrice = qtyForOneHKG;\r\n        \r\n        \r\n        // now spender can use balance in \r\n        // amount of value from owner balance\r\n        allowed[this][virtualExchangeAddress] += qtyToEmit;\r\n        \r\n        // rise event about the transaction\r\n        Approval(this, virtualExchangeAddress, qtyToEmit);\r\n        \r\n        // rise event \r\n        DstTokensIssued(hkgPrice, preferedQtySold, totalSupply, qtyToEmit);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    /**\r\n     * \r\n     * buyForHackerGold - on the hack event this function is available \r\n     *                    the buyer for hacker gold will gain votes to \r\n     *                    influence future proposals on the DST\r\n     *    \r\n     *  @param hkgValue - qty of this DST tokens for 1 HKG     \r\n     * \r\n     */\r\n    function buyForHackerGold(uint hkgValue) onlyBeforeEnd \r\n                                             returns (bool success) {\r\n    \r\n      // validate that the caller is official accelerator HKG Exchange\r\n      if (msg.sender != virtualExchangeAddress) throw;\r\n      \r\n      \r\n      // transfer token \r\n      address sender = tx.origin;\r\n      uint tokensQty = hkgValue * hkgPrice;\r\n\r\n      // gain voting rights\r\n      votingRights[sender] +=tokensQty;\r\n      preferedQtySold += tokensQty;\r\n      collectedHKG += hkgValue;\r\n\r\n      // do actual transfer\r\n      transferFrom(this, \r\n                   virtualExchangeAddress, tokensQty);\r\n      transfer(sender, tokensQty);        \r\n            \r\n      // rise event       \r\n      BuyForHKGTransaction(sender, preferedQtySold, totalSupply, hkgPrice, tokensQty);\r\n        \r\n      return true;\r\n    }\r\n        \r\n    \r\n    /**\r\n     * \r\n     * issueTokens - function will issue tokens after the \r\n     *               event, able to sell for 1 ether \r\n     * \r\n     *  @param qtyForOneEther uint: DST tokens for 1 ETH\r\n     *  @param qtyToEmit uint: new tokens supply\r\n     *\r\n     */\r\n    function issueTokens(uint qtyForOneEther, \r\n                         uint qtyToEmit) onlyAfterEnd \r\n                                         onlyExecutive\r\n                                         onlyIfAbleToIssueTokens {\r\n         \r\n         balances[this] += qtyToEmit;\r\n         etherPrice = qtyForOneEther;\r\n         totalSupply    += qtyToEmit;\r\n         \r\n         // rise event  \r\n         DstTokensIssued(qtyForOneEther, totalSupply, totalSupply, qtyToEmit);\r\n    }\r\n     \r\n    \r\n    /**\r\n     * setEtherPrice - change the token price\r\n     *\r\n     *  @param qtyForOneEther uint: new price - DST tokens for 1 ETH\r\n     */     \r\n    function setEtherPrice(uint qtyForOneEther) onlyAfterEnd\r\n                                                onlyExecutive {\r\n         etherPrice = qtyForOneEther; \r\n\r\n         // rise event for this\r\n         NewEtherPrice(qtyForOneEther);\r\n    }    \r\n    \r\n\r\n    /**\r\n     *  disableTokenIssuance - function will disable any \r\n     *                         option for future token \r\n     *                         issuence\r\n     */\r\n    function disableTokenIssuance() onlyExecutive {\r\n        ableToIssueTokens = false;\r\n        \r\n        DisableTokenIssuance();\r\n    }\r\n\r\n    \r\n    /**\r\n     *  burnRemainToken -  eliminated all available for sale\r\n     *                     tokens. \r\n     */\r\n    function burnRemainToken() onlyExecutive {\r\n    \r\n        totalSupply -= balances[this];\r\n        balances[this] = 0;\r\n        \r\n        // rise event for this\r\n        BurnedAllRemainedTokens();\r\n    }\r\n    \r\n    /**\r\n     *  submitEtherProposal: submit proposal to use part of the \r\n     *                       collected ether funds\r\n     *\r\n     *   @param requestValue uint: value in wei \r\n     *   @param url string: details of the proposal \r\n     */ \r\n    function submitEtherProposal(uint requestValue, string url) onlyAfterEnd \r\n                                                                onlyExecutive returns (bytes32 resultId, bool resultSucces) {       \r\n    \r\n        // ensure there is no more issuence available \r\n        if (ableToIssueTokens) throw;\r\n            \r\n        // ensure there is no more tokens available \r\n        if (balanceOf(this) > 0) throw;\r\n\r\n        // Possible to submit a proposal once 2 weeks \r\n        if (now < (timeOfLastProposal + 2 weeks)) throw;\r\n            \r\n        uint percent = collectedEther / 100;\r\n            \r\n        if (requestValue > PROPOSAL_FUNDS_TH * percent) throw;\r\n\r\n        // if remained value is less than requested gain all.\r\n        if (requestValue > this.balance) \r\n            requestValue = this.balance;    \r\n            \r\n        // set id of the proposal\r\n        // submit proposal to the map\r\n        bytes32 id = sha3(msg.data, now);\r\n        uint timeEnds = now + PROPOSAL_LIFETIME; \r\n            \r\n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.ETHER);\r\n        proposals[id] = newProposal;\r\n        listProposals.push(newProposal);\r\n            \r\n        timeOfLastProposal = now;                        \r\n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\r\n        \r\n        return (id, true);\r\n    }\r\n    \r\n    \r\n     \r\n    /**\r\n     * \r\n     * submitHKGProposal - submit proposal to request for \r\n     *                     partial HKG funds collected \r\n     * \r\n     *  @param requestValue uint: value in HKG to request. \r\n     *  @param url string: url with details on the proposition \r\n     */\r\n    function submitHKGProposal(uint requestValue, string url) onlyAfterEnd\r\n                                                              onlyExecutive returns (bytes32 resultId, bool resultSucces){\r\n        \r\n\r\n        // If there is no 2 months over since the last event.\r\n        // There is no posible to get any HKG. After 2 months\r\n        // all the HKG is available. \r\n        if (now < (eventInfo.getEventEnd() + 8 weeks)) {\r\n            throw;\r\n        }\r\n\r\n        // Possible to submit a proposal once 2 weeks \r\n        if (now < (timeOfLastProposal + 2 weeks)) throw;\r\n\r\n        uint percent = preferedQtySold / 100;\r\n        \r\n        // validate the amount is legit\r\n        // first 5 proposals should be less than 20% \r\n        if (counterProposals <= 5 && \r\n            requestValue     >  PROPOSAL_FUNDS_TH * percent) throw;\r\n                \r\n        // if remained value is less than requested \r\n        // gain all.\r\n        if (requestValue > getHKGOwned()) \r\n            requestValue = getHKGOwned();\r\n        \r\n        \r\n        // set id of the proposal\r\n        // submit proposal to the map\r\n        bytes32 id = sha3(msg.data, now);\r\n        uint timeEnds = now + PROPOSAL_LIFETIME; \r\n        \r\n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.HKG);\r\n        proposals[id] = newProposal;\r\n        listProposals.push(newProposal);\r\n        \r\n        ++counterProposals;\r\n        timeOfLastProposal = now;                \r\n                \r\n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\r\n        \r\n        return (id, true);        \r\n    }  \r\n    \r\n    \r\n    \r\n    /**\r\n     * objectProposal - object previously submitted proposal, \r\n     *                  the objection right is obtained by \r\n     *                  purchasing prefered tokens on time of \r\n     *                  the hackathon.\r\n     * \r\n     *  @param id bytes32 : the id of the proposla to redeem\r\n     */\r\n     function objectProposal(bytes32 id){\r\n         \r\n        Proposal memory proposal = proposals[id];\r\n         \r\n        // check proposal exist \r\n        if (proposals[id].id == 0) throw;\r\n\r\n        // check already redeemed\r\n        if (proposals[id].redeemed) throw;\r\n         \r\n        // ensure objection time\r\n        if (now >= proposals[id].votindEndTS) throw;\r\n         \r\n        // ensure not voted  \r\n        if (proposals[id].voted[msg.sender]) throw;\r\n         \r\n         // submit votes\r\n         uint votes = votingRights[msg.sender];\r\n         proposals[id].votesObjecting += votes;\r\n         \r\n         // mark voted \r\n         proposals[id].voted[msg.sender] = true; \r\n         \r\n         uint idx = getIndexByProposalId(id);\r\n         listProposals[idx] = proposals[id];   \r\n\r\n         ObjectedVote(id, msg.sender, votes);         \r\n     }\r\n     \r\n     \r\n     function getIndexByProposalId(bytes32 id) returns (uint result){\r\n         \r\n         for (uint i = 0; i < listProposals.length; ++i){\r\n             if (id == listProposals[i].id) return i;\r\n         }\r\n     }\r\n    \r\n    \r\n   \r\n    /**\r\n     * redeemProposalFunds - redeem funds requested by prior \r\n     *                       submitted proposal     \r\n     * \r\n     * @param id bytes32: the id of the proposal to redeem\r\n     */\r\n    function redeemProposalFunds(bytes32 id) onlyExecutive {\r\n\r\n        if (proposals[id].id == 0) throw;\r\n        if (proposals[id].submitter != msg.sender) throw;\r\n\r\n        // ensure objection time\r\n        if (now < proposals[id].votindEndTS) throw;\r\n                           \r\n    \r\n            // check already redeemed\r\n        if (proposals[id].redeemed) throw;\r\n\r\n        // check votes objection => 55% of total votes\r\n        uint objectionThreshold = preferedQtySold / 100 * 55;\r\n        if (proposals[id].votesObjecting  > objectionThreshold) throw;\r\n    \r\n    \r\n        if (proposals[id].proposalCurrency == ProposalCurrency.HKG){\r\n            \r\n            // send hacker gold \r\n            hackerGold.transfer(proposals[id].submitter, proposals[id].value);      \r\n                        \r\n        } else {\r\n                        \r\n           // send ether              \r\n           bool success = proposals[id].submitter.send(proposals[id].value); \r\n\r\n           // rise event\r\n           EtherRedeemAccepted(proposals[id].submitter, proposals[id].value);                              \r\n        }\r\n        \r\n        // execute the proposal \r\n        proposals[id].redeemed = true; \r\n    }\r\n    \r\n    \r\n    /**\r\n     *  getAllTheFunds - to ensure there is no deadlock can \r\n     *                   can happen, and no case that voting \r\n     *                   structure will freeze the funds forever\r\n     *                   the startup will be able to get all the\r\n     *                   funds without a proposal required after\r\n     *                   6 months.\r\n     * \r\n     * \r\n     */             \r\n    function getAllTheFunds() onlyExecutive {\r\n        \r\n        // If there is a deadlock in voting participates\r\n        // the funds can be redeemed completelly in 6 months\r\n        if (now < (eventInfo.getEventEnd() + 24 weeks)) {\r\n            throw;\r\n        }  \r\n        \r\n        // all the Ether\r\n        bool success = msg.sender.send(this.balance);        \r\n        \r\n        // all the HKG\r\n        hackerGold.transfer(msg.sender, getHKGOwned());              \r\n    }\r\n    \r\n    \r\n    /**\r\n     * submitImpeachmentProposal - submit request to switch \r\n     *                             executive.\r\n     * \r\n     *  @param urlDetails  - details of the impeachment proposal \r\n     *  @param newExecutive - address of the new executive \r\n     * \r\n     */             \r\n     function submitImpeachmentProposal(string urlDetails, address newExecutive){\r\n         \r\n        // to offer impeachment you should have \r\n        // voting rights\r\n        if (votingRights[msg.sender] == 0) throw;\r\n         \r\n        // the submission of the first impeachment \r\n        // proposal is possible only after 3 months\r\n        // since the hackathon is over\r\n        if (now < (eventInfo.getEventEnd() + 12 weeks)) throw;\r\n        \r\n                \r\n        // check there is 1 months over since last one\r\n        if (lastImpeachmentProposal.votindEndTS != 0 && \r\n            lastImpeachmentProposal.votindEndTS +  2 weeks > now) throw;\r\n\r\n\r\n        // submit impeachment proposal\r\n        // add the votes of the submitter \r\n        // to the proposal right away\r\n        lastImpeachmentProposal = ImpeachmentProposal(urlDetails, newExecutive, now + 2 weeks, votingRights[msg.sender]);\r\n        lastImpeachmentProposal.voted[msg.sender] = true;\r\n         \r\n        // rise event\r\n        ImpeachmentProposed(msg.sender, urlDetails, now + 2 weeks, newExecutive);\r\n     }\r\n    \r\n    \r\n    /**\r\n     * supportImpeachment - vote for impeachment proposal \r\n     *                      that is currently in progress\r\n     *\r\n     */\r\n    function supportImpeachment(){\r\n\r\n        // ensure that support is for exist proposal \r\n        if (lastImpeachmentProposal.newExecutive == 0x0) throw;\r\n    \r\n        // to offer impeachment you should have \r\n        // voting rights\r\n        if (votingRights[msg.sender] == 0) throw;\r\n        \r\n        // check if not voted already \r\n        if (lastImpeachmentProposal.voted[msg.sender]) throw;\r\n        \r\n        // check if not finished the 2 weeks of voting \r\n        if (lastImpeachmentProposal.votindEndTS + 2 weeks <= now) throw;\r\n                \r\n        // support the impeachment\r\n        lastImpeachmentProposal.voted[msg.sender] = true;\r\n        lastImpeachmentProposal.votesSupporting += votingRights[msg.sender];\r\n\r\n        // rise impeachment suppporting event\r\n        ImpeachmentSupport(msg.sender, votingRights[msg.sender]);\r\n        \r\n        // if the vote is over 70% execute the switch \r\n        uint percent = preferedQtySold / 100; \r\n        \r\n        if (lastImpeachmentProposal.votesSupporting >= 70 * percent){\r\n            executive = lastImpeachmentProposal.newExecutive;\r\n            \r\n            // impeachment event\r\n            ImpeachmentAccepted(executive);\r\n        }\r\n        \r\n    } \r\n    \r\n      \r\n    \r\n    // **************************** //\r\n    // *     Constant Getters     * //\r\n    // **************************** //\r\n    \r\n    function votingRightsOf(address _owner) constant returns (uint256 result) {\r\n        result = votingRights[_owner];\r\n    }\r\n    \r\n    function getPreferedQtySold() constant returns (uint result){\r\n        return preferedQtySold;\r\n    }\r\n    \r\n    function setVirtualExchange(address virtualExchangeAddr){\r\n        if (virtualExchangeAddress != 0x0) throw;\r\n        virtualExchangeAddress = virtualExchangeAddr;\r\n    }\r\n\r\n    function getHKGOwned() constant returns (uint result){\r\n        return hackerGold.balanceOf(this);\r\n    }\r\n    \r\n    function getEtherValue() constant returns (uint result){\r\n        return this.balance;\r\n    }\r\n    \r\n    function getExecutive() constant returns (address result){\r\n        return executive;\r\n    }\r\n    \r\n    function getHKGPrice() constant returns (uint result){\r\n        return hkgPrice;\r\n    }\r\n\r\n    function getEtherPrice() constant returns (uint result){\r\n        return etherPrice;\r\n    }\r\n    \r\n    function getDSTName() constant returns(string result){\r\n        return name;\r\n    }    \r\n    \r\n    function getDSTNameBytes() constant returns(bytes32 result){\r\n        return convert(name);\r\n    }    \r\n\r\n    function getDSTSymbol() constant returns(string result){\r\n        return symbol;\r\n    }    \r\n    \r\n    function getDSTSymbolBytes() constant returns(bytes32 result){\r\n        return convert(symbol);\r\n    }    \r\n\r\n    function getAddress() constant returns (address result) {\r\n        return this;\r\n    }\r\n    \r\n    function getTotalSupply() constant returns (uint result) {\r\n        return totalSupply;\r\n    } \r\n        \r\n    function getCollectedEther() constant returns (uint results) {        \r\n        return collectedEther;\r\n    }\r\n    \r\n    function getCounterProposals() constant returns (uint result){\r\n        return counterProposals;\r\n    }\r\n        \r\n    function getProposalIdByIndex(uint i) constant returns (bytes32 result){\r\n        return listProposals[i].id;\r\n    }    \r\n\r\n    function getProposalObjectionByIndex(uint i) constant returns (uint result){\r\n        return listProposals[i].votesObjecting;\r\n    }\r\n\r\n    function getProposalValueByIndex(uint i) constant returns (uint result){\r\n        return listProposals[i].value;\r\n    }                  \r\n    \r\n    function getCurrentImpeachmentUrlDetails() constant returns (string result){\r\n        return lastImpeachmentProposal.urlDetails;\r\n    }\r\n    \r\n    \r\n    function getCurrentImpeachmentVotesSupporting() constant returns (uint result){\r\n        return lastImpeachmentProposal.votesSupporting;\r\n    }\r\n    \r\n    function convert(string key) returns (bytes32 ret) {\r\n            if (bytes(key).length > 32) {\r\n                throw;\r\n            }      \r\n\r\n            assembly {\r\n                ret := mload(add(key, 32))\r\n            }\r\n    }    \r\n    \r\n    \r\n    \r\n    // ********************* //\r\n    // *     Modifiers     * //\r\n    // ********************* //    \r\n \r\n    modifier onlyBeforeEnd() { if (now  >=  eventInfo.getEventEnd()) throw; _; }\r\n    modifier onlyAfterEnd()  { if (now  <   eventInfo.getEventEnd()) throw; _; }\r\n    \r\n    modifier onlyAfterTradingStart()  { if (now  < eventInfo.getTradingStart()) throw; _; }\r\n    \r\n    modifier onlyExecutive()     { if (msg.sender != executive) throw; _; }\r\n                                       \r\n    modifier onlyIfAbleToIssueTokens()  { if (!ableToIssueTokens) throw; _; } \r\n    \r\n\r\n    // ****************** //\r\n    // *     Events     * //\r\n    // ****************** //        \r\n\r\n    \r\n    event PriceHKGChange(uint indexed qtyForOneHKG, uint indexed tokensSold, uint indexed totalSupply);\r\n    event BuyForHKGTransaction(address indexed buyer, uint indexed tokensSold, uint indexed totalSupply, uint qtyForOneHKG, uint tokensAmount);\r\n    event BuyForEtherTransaction(address indexed buyer, uint indexed tokensSold, uint indexed totalSupply, uint qtyForOneEther, uint tokensAmount);\r\n\r\n    event DstTokensIssued(uint indexed qtyForOneHKG, uint indexed tokensSold, uint indexed totalSupply, uint qtyToEmit);\r\n    \r\n    event ProposalRequestSubmitted(bytes32 id, uint value, uint timeEnds, string url, address sender);\r\n    \r\n    event EtherRedeemAccepted(address sender, uint value);\r\n    \r\n    event ObjectedVote(bytes32 id, address voter, uint votes);\r\n    \r\n    event ImpeachmentProposed(address submitter, string urlDetails, uint votindEndTS, address newExecutive);\r\n    event ImpeachmentSupport(address supportter, uint votes);\r\n    \r\n    event ImpeachmentAccepted(address newExecutive);\r\n\r\n    event NewEtherPrice(uint newQtyForOneEther);\r\n    event DisableTokenIssuance();\r\n    \r\n    event BurnedAllRemainedTokens();\r\n    \r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  VariableDeclaration "DECIMAL_ZEROS"
     Type: uint256
     Gas costs: 0
     Source: "uint DECIMAL_ZEROS = 1000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1000
       Type: int_const 1000
       Source: "1000"
  VariableDeclaration "PROPOSAL_LIFETIME"
     Type: uint256
     Gas costs: 0
     Source: "uint PROPOSAL_LIFETIME = 10 days"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 10
       Type: int_const 864000
       Source: "10 days"
  VariableDeclaration "PROPOSAL_FUNDS_TH"
     Type: uint256
     Gas costs: 0
     Source: "uint PROPOSAL_FUNDS_TH = 20"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 20
       Type: int_const 20
       Source: "20"
  VariableDeclaration "executive"
     Type: address
     Gas costs: 0
     Source: "address   executive"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "eventInfo"
     Type: contract EventInfo
     Gas costs: 0
     Source: "EventInfo eventInfo"
    UserDefinedTypeName "EventInfo"
       Source: "EventInfo"
  VariableDeclaration "virtualExchangeAddress"
     Type: address
     Gas costs: 0
     Source: "address virtualExchangeAddress"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "hackerGold"
     Type: contract HackerGold
     Gas costs: 0
     Source: "HackerGold hackerGold"
    UserDefinedTypeName "HackerGold"
       Source: "HackerGold"
  VariableDeclaration "votingRights"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) votingRights"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "hkgPrice"
     Type: uint256
     Gas costs: 0
     Source: "uint hkgPrice"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "etherPrice"
     Type: uint256
     Gas costs: 0
     Source: "uint etherPrice"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: 0
     Source: "string public name = \"...\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: ...
       Type: literal_string "..."
       Source: "\"...\""
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: 0
     Source: "uint8  public decimals = 3"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 3
       Type: int_const 3
       Source: "3"
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: 0
     Source: "string public symbol = \"...\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: ...
       Type: literal_string "..."
       Source: "\"...\""
  VariableDeclaration "ableToIssueTokens"
     Type: bool
     Gas costs: 0
     Source: "bool ableToIssueTokens = true"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: true value: true
       Type: bool
       Source: "true"
  VariableDeclaration "preferedQtySold"
     Type: uint256
     Gas costs: 0
     Source: "uint preferedQtySold"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "collectedHKG"
     Type: uint256
     Gas costs: 0
     Source: "uint collectedHKG"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "collectedEther"
     Type: uint256
     Gas costs: 0
     Source: "uint collectedEther"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "proposals"
     Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
     Gas costs: 0
     Source: "mapping (bytes32 => Proposal) proposals"
    Mapping
       Source: "mapping (bytes32 => Proposal)"
      ElementaryTypeName bytes32
         Source: "bytes32"
      UserDefinedTypeName "Proposal"
         Source: "Proposal"
  EnumDefinition "ProposalCurrency"
    EnumValue "HKG"
    EnumValue "ETHER"
  VariableDeclaration "enumDeclaration"
     Type: enum DSTContract.ProposalCurrency
     Gas costs: 0
     Source: "ProposalCurrency enumDeclaration"
    UserDefinedTypeName "ProposalCurrency"
       Source: "ProposalCurrency"
  StructDefinition "Proposal"
     Gas costs: 0
     Source: "struct Proposal{\r\n        \r\n        bytes32 id;\r\n        uint value;\r\n\r\n        string urlDetails;\r\n\r\n        uint votindEndTS;\r\n                \r\n        uint votesObjecting;\r\n        \r\n        address submitter;\r\n        bool redeemed;\r\n\r\n        ProposalCurrency proposalCurrency;\r\n        \r\n        mapping (address => bool) voted;\r\n    }"
    VariableDeclaration "id"
       Type: bytes32
       Source: "bytes32 id"
      ElementaryTypeName bytes32
         Source: "bytes32"
    VariableDeclaration "value"
       Type: uint256
       Source: "uint value"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "urlDetails"
       Type: string storage pointer
       Source: "string urlDetails"
      ElementaryTypeName string
         Source: "string"
    VariableDeclaration "votindEndTS"
       Type: uint256
       Source: "uint votindEndTS"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "votesObjecting"
       Type: uint256
       Source: "uint votesObjecting"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "submitter"
       Type: address
       Source: "address submitter"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "redeemed"
       Type: bool
       Source: "bool redeemed"
      ElementaryTypeName bool
         Source: "bool"
    VariableDeclaration "proposalCurrency"
       Type: enum DSTContract.ProposalCurrency
       Source: "ProposalCurrency proposalCurrency"
      UserDefinedTypeName "ProposalCurrency"
         Source: "ProposalCurrency"
    VariableDeclaration "voted"
       Type: mapping(address => bool)
       Source: "mapping (address => bool) voted"
      Mapping
         Source: "mapping (address => bool)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName bool
           Source: "bool"
  VariableDeclaration "counterProposals"
     Type: uint256
     Gas costs: 0
     Source: "uint counterProposals"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "timeOfLastProposal"
     Type: uint256
     Gas costs: 0
     Source: "uint timeOfLastProposal"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "listProposals"
     Type: struct DSTContract.Proposal storage ref[] storage ref
     Gas costs: 0
     Source: "Proposal[] listProposals"
    ArrayTypeName
       Source: "Proposal[]"
      UserDefinedTypeName "Proposal"
         Source: "Proposal"
  StructDefinition "ImpeachmentProposal"
     Gas costs: 0
     Source: "struct ImpeachmentProposal{\r\n        \r\n        string urlDetails;\r\n        \r\n        address newExecutive;\r\n\r\n        uint votindEndTS;        \r\n        uint votesSupporting;\r\n        \r\n        mapping (address => bool) voted;        \r\n    }"
    VariableDeclaration "urlDetails"
       Type: string storage pointer
       Source: "string urlDetails"
      ElementaryTypeName string
         Source: "string"
    VariableDeclaration "newExecutive"
       Type: address
       Source: "address newExecutive"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "votindEndTS"
       Type: uint256
       Source: "uint votindEndTS"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "votesSupporting"
       Type: uint256
       Source: "uint votesSupporting"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "voted"
       Type: mapping(address => bool)
       Source: "mapping (address => bool) voted"
      Mapping
         Source: "mapping (address => bool)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName bool
           Source: "bool"
  VariableDeclaration "lastImpeachmentProposal"
     Type: struct DSTContract.ImpeachmentProposal storage ref
     Gas costs: 0
     Source: "ImpeachmentProposal lastImpeachmentProposal"
    UserDefinedTypeName "ImpeachmentProposal"
       Source: "ImpeachmentProposal"
  FunctionDefinition "DSTContract" - public
     Source: "function DSTContract(EventInfo eventInfoAddr, HackerGold hackerGoldAddr, string dstName, string dstSymbol){\r\n    \r\n      executive   = msg.sender;  \r\n      name        = dstName;\r\n      symbol      = dstSymbol;\r\n\r\n      hackerGold = HackerGold(hackerGoldAddr);\r\n      eventInfo  = EventInfo(eventInfoAddr);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(EventInfo eventInfoAddr, HackerGold hackerGoldAddr, string dstName, string dstSymbol)"
      VariableDeclaration "eventInfoAddr"
         Type: contract EventInfo
         Source: "EventInfo eventInfoAddr"
        UserDefinedTypeName "EventInfo"
           Source: "EventInfo"
      VariableDeclaration "hackerGoldAddr"
         Type: contract HackerGold
         Source: "HackerGold hackerGoldAddr"
        UserDefinedTypeName "HackerGold"
           Source: "HackerGold"
      VariableDeclaration "dstName"
         Type: string memory
         Source: "string dstName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "dstSymbol"
         Type: string memory
         Source: "string dstSymbol"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    \r\n      executive   = msg.sender;  \r\n      name        = dstName;\r\n      symbol      = dstSymbol;\r\n\r\n      hackerGold = HackerGold(hackerGoldAddr);\r\n      eventInfo  = EventInfo(eventInfoAddr);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "executive   = msg.sender"
        Assignment using operator =
           Type: address
           Source: "executive   = msg.sender"
          Identifier executive
             Type: address
             Source: "executive"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "name        = dstName"
        Assignment using operator =
           Type: string storage ref
           Source: "name        = dstName"
          Identifier name
             Type: string storage ref
             Source: "name"
          Identifier dstName
             Type: string memory
             Source: "dstName"
      ExpressionStatement
         Gas costs: 0
         Source: "symbol      = dstSymbol"
        Assignment using operator =
           Type: string storage ref
           Source: "symbol      = dstSymbol"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
          Identifier dstSymbol
             Type: string memory
             Source: "dstSymbol"
      ExpressionStatement
         Gas costs: 0
         Source: "hackerGold = HackerGold(hackerGoldAddr)"
        Assignment using operator =
           Type: contract HackerGold
           Source: "hackerGold = HackerGold(hackerGoldAddr)"
          Identifier hackerGold
             Type: contract HackerGold
             Source: "hackerGold"
          FunctionCall
             Type: contract HackerGold
             Source: "HackerGold(hackerGoldAddr)"
            Identifier HackerGold
               Type: type(contract HackerGold)
               Source: "HackerGold"
            Identifier hackerGoldAddr
               Type: contract HackerGold
               Source: "hackerGoldAddr"
      ExpressionStatement
         Gas costs: 0
         Source: "eventInfo  = EventInfo(eventInfoAddr)"
        Assignment using operator =
           Type: contract EventInfo
           Source: "eventInfo  = EventInfo(eventInfoAddr)"
          Identifier eventInfo
             Type: contract EventInfo
             Source: "eventInfo"
          FunctionCall
             Type: contract EventInfo
             Source: "EventInfo(eventInfoAddr)"
            Identifier EventInfo
               Type: type(contract EventInfo)
               Source: "EventInfo"
            Identifier eventInfoAddr
               Type: contract EventInfo
               Source: "eventInfoAddr"
  FunctionDefinition "" - public
     Source: "function() payable\r\n               onlyAfterEnd {\r\n        \r\n        // there is tokens left from hackathon \r\n        if (etherPrice == 0) throw;\r\n        \r\n        uint tokens = msg.value * etherPrice * DECIMAL_ZEROS / (1 ether);\r\n        \r\n        // check if demand of tokens is \r\n        // overflow the supply \r\n        uint retEther = 0;\r\n        if (balances[this] < tokens) {\r\n            \r\n            tokens = balances[this];\r\n            retEther = msg.value - tokens / etherPrice * (1 finney);\r\n        \r\n            // return left ether \r\n            if (!msg.sender.send(retEther)) throw;\r\n        }\r\n        \r\n        \r\n        // do transfer\r\n        balances[msg.sender] += tokens;\r\n        balances[this] -= tokens;\r\n        \r\n        // count collected ether \r\n        collectedEther += msg.value - retEther; \r\n        \r\n        // rise event\r\n        BuyForEtherTransaction(msg.sender, collectedEther, totalSupply, etherPrice, tokens);\r\n        \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAfterEnd"
       Gas costs: 0
       Source: "onlyAfterEnd"
      Identifier onlyAfterEnd
         Type: modifier ()
         Source: "onlyAfterEnd"
    Block
       Source: "{\r\n        \r\n        // there is tokens left from hackathon \r\n        if (etherPrice == 0) throw;\r\n        \r\n        uint tokens = msg.value * etherPrice * DECIMAL_ZEROS / (1 ether);\r\n        \r\n        // check if demand of tokens is \r\n        // overflow the supply \r\n        uint retEther = 0;\r\n        if (balances[this] < tokens) {\r\n            \r\n            tokens = balances[this];\r\n            retEther = msg.value - tokens / etherPrice * (1 finney);\r\n        \r\n            // return left ether \r\n            if (!msg.sender.send(retEther)) throw;\r\n        }\r\n        \r\n        \r\n        // do transfer\r\n        balances[msg.sender] += tokens;\r\n        balances[this] -= tokens;\r\n        \r\n        // count collected ether \r\n        collectedEther += msg.value - retEther; \r\n        \r\n        // rise event\r\n        BuyForEtherTransaction(msg.sender, collectedEther, totalSupply, etherPrice, tokens);\r\n        \r\n    }"
      IfStatement
         Source: "if (etherPrice == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "etherPrice == 0"
          Identifier etherPrice
             Type: uint256
             Source: "etherPrice"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 0
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint tokens = msg.value * etherPrice * DECIMAL_ZEROS / (1 ether)"
        VariableDeclaration "tokens"
           Type: uint256
           Source: "uint tokens"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "msg.value * etherPrice * DECIMAL_ZEROS / (1 ether)"
          BinaryOperation using operator *
             Type: uint256
             Source: "msg.value * etherPrice * DECIMAL_ZEROS"
            BinaryOperation using operator *
               Type: uint256
               Source: "msg.value * etherPrice"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier etherPrice
                 Type: uint256
                 Source: "etherPrice"
            Identifier DECIMAL_ZEROS
               Type: uint256
               Source: "DECIMAL_ZEROS"
          TupleExpression
             Type: int_const 1000000000000000000
             Source: "(1 ether)"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint retEther = 0"
        VariableDeclaration "retEther"
           Type: uint256
           Source: "uint retEther"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      IfStatement
         Source: "if (balances[this] < tokens) {\r\n            \r\n            tokens = balances[this];\r\n            retEther = msg.value - tokens / etherPrice * (1 finney);\r\n        \r\n            // return left ether \r\n            if (!msg.sender.send(retEther)) throw;\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "balances[this] < tokens"
          IndexAccess
             Type: uint256
             Source: "balances[this]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier this
               Type: contract DSTContract
               Source: "this"
          Identifier tokens
             Type: uint256
             Source: "tokens"
        Block
           Source: "{\r\n            \r\n            tokens = balances[this];\r\n            retEther = msg.value - tokens / etherPrice * (1 finney);\r\n        \r\n            // return left ether \r\n            if (!msg.sender.send(retEther)) throw;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "tokens = balances[this]"
            Assignment using operator =
               Type: uint256
               Source: "tokens = balances[this]"
              Identifier tokens
                 Type: uint256
                 Source: "tokens"
              IndexAccess
                 Type: uint256
                 Source: "balances[this]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier this
                   Type: contract DSTContract
                   Source: "this"
          ExpressionStatement
             Gas costs: 0
             Source: "retEther = msg.value - tokens / etherPrice * (1 finney)"
            Assignment using operator =
               Type: uint256
               Source: "retEther = msg.value - tokens / etherPrice * (1 finney)"
              Identifier retEther
                 Type: uint256
                 Source: "retEther"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "msg.value - tokens / etherPrice * (1 finney)"
                MemberAccess to member value
                   Type: uint256
                   Source: "msg.value"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "tokens / etherPrice * (1 finney)"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "tokens / etherPrice"
                    Identifier tokens
                       Type: uint256
                       Source: "tokens"
                    Identifier etherPrice
                       Type: uint256
                       Source: "etherPrice"
                  TupleExpression
                     Type: int_const 1000000000000000
                     Source: "(1 finney)"
                    Literal, token: [no token] value: 1
                       Type: int_const 1000000000000000
                       Source: "1 finney"
          IfStatement
             Source: "if (!msg.sender.send(retEther)) throw"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: 0
               Source: "!msg.sender.send(retEther)"
              FunctionCall
                 Type: bool
                 Source: "msg.sender.send(retEther)"
                MemberAccess to member send
                   Type: function (uint256) returns (bool)
                   Source: "msg.sender.send"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier retEther
                   Type: uint256
                   Source: "retEther"
            Throw
               Gas costs: 0
               Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] += tokens"
        Assignment using operator +=
           Type: uint256
           Source: "balances[msg.sender] += tokens"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[this] -= tokens"
        Assignment using operator -=
           Type: uint256
           Source: "balances[this] -= tokens"
          IndexAccess
             Type: uint256
             Source: "balances[this]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier this
               Type: contract DSTContract
               Source: "this"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: 0
         Source: "collectedEther += msg.value - retEther"
        Assignment using operator +=
           Type: uint256
           Source: "collectedEther += msg.value - retEther"
          Identifier collectedEther
             Type: uint256
             Source: "collectedEther"
          BinaryOperation using operator -
             Type: uint256
             Source: "msg.value - retEther"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier retEther
               Type: uint256
               Source: "retEther"
      ExpressionStatement
         Gas costs: 0
         Source: "BuyForEtherTransaction(msg.sender, collectedEther, totalSupply, etherPrice, tokens)"
        FunctionCall
           Type: tuple()
           Source: "BuyForEtherTransaction(msg.sender, collectedEther, totalSupply, etherPrice, tokens)"
          Identifier BuyForEtherTransaction
             Type: function (address,uint256,uint256,uint256,uint256)
             Source: "BuyForEtherTransaction"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier collectedEther
             Type: uint256
             Source: "collectedEther"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier etherPrice
             Type: uint256
             Source: "etherPrice"
          Identifier tokens
             Type: uint256
             Source: "tokens"
  FunctionDefinition "setHKGPrice" - public
     Source: "function setHKGPrice(uint qtyForOneHKG) onlyExecutive  {\r\n         \r\n         hkgPrice = qtyForOneHKG;\r\n         PriceHKGChange(qtyForOneHKG, preferedQtySold, totalSupply);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint qtyForOneHKG)"
      VariableDeclaration "qtyForOneHKG"
         Type: uint256
         Source: "uint qtyForOneHKG"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyExecutive"
       Gas costs: 0
       Source: "onlyExecutive"
      Identifier onlyExecutive
         Type: modifier ()
         Source: "onlyExecutive"
    Block
       Source: "{\r\n         \r\n         hkgPrice = qtyForOneHKG;\r\n         PriceHKGChange(qtyForOneHKG, preferedQtySold, totalSupply);\r\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "hkgPrice = qtyForOneHKG"
        Assignment using operator =
           Type: uint256
           Source: "hkgPrice = qtyForOneHKG"
          Identifier hkgPrice
             Type: uint256
             Source: "hkgPrice"
          Identifier qtyForOneHKG
             Type: uint256
             Source: "qtyForOneHKG"
      ExpressionStatement
         Gas costs: 0
         Source: "PriceHKGChange(qtyForOneHKG, preferedQtySold, totalSupply)"
        FunctionCall
           Type: tuple()
           Source: "PriceHKGChange(qtyForOneHKG, preferedQtySold, totalSupply)"
          Identifier PriceHKGChange
             Type: function (uint256,uint256,uint256)
             Source: "PriceHKGChange"
          Identifier qtyForOneHKG
             Type: uint256
             Source: "qtyForOneHKG"
          Identifier preferedQtySold
             Type: uint256
             Source: "preferedQtySold"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
  FunctionDefinition "issuePreferedTokens" - public
     Source: "function issuePreferedTokens(uint qtyForOneHKG, \r\n                                 uint qtyToEmit) onlyExecutive \r\n                                                 onlyIfAbleToIssueTokens\r\n                                                 onlyBeforeEnd\r\n                                                 onlyAfterTradingStart {\r\n                \r\n        // no issuence is allowed before enlisted on the\r\n        // exchange \r\n        if (virtualExchangeAddress == 0x0) throw;\r\n            \r\n        totalSupply    += qtyToEmit;\r\n        balances[this] += qtyToEmit;\r\n        hkgPrice = qtyForOneHKG;\r\n        \r\n        \r\n        // now spender can use balance in \r\n        // amount of value from owner balance\r\n        allowed[this][virtualExchangeAddress] += qtyToEmit;\r\n        \r\n        // rise event about the transaction\r\n        Approval(this, virtualExchangeAddress, qtyToEmit);\r\n        \r\n        // rise event \r\n        DstTokensIssued(hkgPrice, preferedQtySold, totalSupply, qtyToEmit);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint qtyForOneHKG, \r\n                                 uint qtyToEmit)"
      VariableDeclaration "qtyForOneHKG"
         Type: uint256
         Source: "uint qtyForOneHKG"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "qtyToEmit"
         Type: uint256
         Source: "uint qtyToEmit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyExecutive"
       Gas costs: 0
       Source: "onlyExecutive"
      Identifier onlyExecutive
         Type: modifier ()
         Source: "onlyExecutive"
    ModifierInvocation "onlyIfAbleToIssueTokens"
       Gas costs: 0
       Source: "onlyIfAbleToIssueTokens"
      Identifier onlyIfAbleToIssueTokens
         Type: modifier ()
         Source: "onlyIfAbleToIssueTokens"
    ModifierInvocation "onlyBeforeEnd"
       Gas costs: 0
       Source: "onlyBeforeEnd"
      Identifier onlyBeforeEnd
         Type: modifier ()
         Source: "onlyBeforeEnd"
    ModifierInvocation "onlyAfterTradingStart"
       Gas costs: 0
       Source: "onlyAfterTradingStart"
      Identifier onlyAfterTradingStart
         Type: modifier ()
         Source: "onlyAfterTradingStart"
    Block
       Source: "{\r\n                \r\n        // no issuence is allowed before enlisted on the\r\n        // exchange \r\n        if (virtualExchangeAddress == 0x0) throw;\r\n            \r\n        totalSupply    += qtyToEmit;\r\n        balances[this] += qtyToEmit;\r\n        hkgPrice = qtyForOneHKG;\r\n        \r\n        \r\n        // now spender can use balance in \r\n        // amount of value from owner balance\r\n        allowed[this][virtualExchangeAddress] += qtyToEmit;\r\n        \r\n        // rise event about the transaction\r\n        Approval(this, virtualExchangeAddress, qtyToEmit);\r\n        \r\n        // rise event \r\n        DstTokensIssued(hkgPrice, preferedQtySold, totalSupply, qtyToEmit);\r\n    }"
      IfStatement
         Source: "if (virtualExchangeAddress == 0x0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "virtualExchangeAddress == 0x0"
          Identifier virtualExchangeAddress
             Type: address
             Source: "virtualExchangeAddress"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
        Throw
           Gas costs: 0
           Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply    += qtyToEmit"
        Assignment using operator +=
           Type: uint256
           Source: "totalSupply    += qtyToEmit"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier qtyToEmit
             Type: uint256
             Source: "qtyToEmit"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[this] += qtyToEmit"
        Assignment using operator +=
           Type: uint256
           Source: "balances[this] += qtyToEmit"
          IndexAccess
             Type: uint256
             Source: "balances[this]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier this
               Type: contract DSTContract
               Source: "this"
          Identifier qtyToEmit
             Type: uint256
             Source: "qtyToEmit"
      ExpressionStatement
         Gas costs: 0
         Source: "hkgPrice = qtyForOneHKG"
        Assignment using operator =
           Type: uint256
           Source: "hkgPrice = qtyForOneHKG"
          Identifier hkgPrice
             Type: uint256
             Source: "hkgPrice"
          Identifier qtyForOneHKG
             Type: uint256
             Source: "qtyForOneHKG"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[this][virtualExchangeAddress] += qtyToEmit"
        Assignment using operator +=
           Type: uint256
           Source: "allowed[this][virtualExchangeAddress] += qtyToEmit"
          IndexAccess
             Type: uint256
             Source: "allowed[this][virtualExchangeAddress]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[this]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier this
                 Type: contract DSTContract
                 Source: "this"
            Identifier virtualExchangeAddress
               Type: address
               Source: "virtualExchangeAddress"
          Identifier qtyToEmit
             Type: uint256
             Source: "qtyToEmit"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(this, virtualExchangeAddress, qtyToEmit)"
        FunctionCall
           Type: tuple()
           Source: "Approval(this, virtualExchangeAddress, qtyToEmit)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          Identifier this
             Type: contract DSTContract
             Source: "this"
          Identifier virtualExchangeAddress
             Type: address
             Source: "virtualExchangeAddress"
          Identifier qtyToEmit
             Type: uint256
             Source: "qtyToEmit"
      ExpressionStatement
         Gas costs: 0
         Source: "DstTokensIssued(hkgPrice, preferedQtySold, totalSupply, qtyToEmit)"
        FunctionCall
           Type: tuple()
           Source: "DstTokensIssued(hkgPrice, preferedQtySold, totalSupply, qtyToEmit)"
          Identifier DstTokensIssued
             Type: function (uint256,uint256,uint256,uint256)
             Source: "DstTokensIssued"
          Identifier hkgPrice
             Type: uint256
             Source: "hkgPrice"
          Identifier preferedQtySold
             Type: uint256
             Source: "preferedQtySold"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier qtyToEmit
             Type: uint256
             Source: "qtyToEmit"
  FunctionDefinition "buyForHackerGold" - public
     Source: "function buyForHackerGold(uint hkgValue) onlyBeforeEnd \r\n                                             returns (bool success) {\r\n    \r\n      // validate that the caller is official accelerator HKG Exchange\r\n      if (msg.sender != virtualExchangeAddress) throw;\r\n      \r\n      \r\n      // transfer token \r\n      address sender = tx.origin;\r\n      uint tokensQty = hkgValue * hkgPrice;\r\n\r\n      // gain voting rights\r\n      votingRights[sender] +=tokensQty;\r\n      preferedQtySold += tokensQty;\r\n      collectedHKG += hkgValue;\r\n\r\n      // do actual transfer\r\n      transferFrom(this, \r\n                   virtualExchangeAddress, tokensQty);\r\n      transfer(sender, tokensQty);        \r\n            \r\n      // rise event       \r\n      BuyForHKGTransaction(sender, preferedQtySold, totalSupply, hkgPrice, tokensQty);\r\n        \r\n      return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint hkgValue)"
      VariableDeclaration "hkgValue"
         Type: uint256
         Source: "uint hkgValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyBeforeEnd"
       Gas costs: 0
       Source: "onlyBeforeEnd"
      Identifier onlyBeforeEnd
         Type: modifier ()
         Source: "onlyBeforeEnd"
    Block
       Source: "{\r\n    \r\n      // validate that the caller is official accelerator HKG Exchange\r\n      if (msg.sender != virtualExchangeAddress) throw;\r\n      \r\n      \r\n      // transfer token \r\n      address sender = tx.origin;\r\n      uint tokensQty = hkgValue * hkgPrice;\r\n\r\n      // gain voting rights\r\n      votingRights[sender] +=tokensQty;\r\n      preferedQtySold += tokensQty;\r\n      collectedHKG += hkgValue;\r\n\r\n      // do actual transfer\r\n      transferFrom(this, \r\n                   virtualExchangeAddress, tokensQty);\r\n      transfer(sender, tokensQty);        \r\n            \r\n      // rise event       \r\n      BuyForHKGTransaction(sender, preferedQtySold, totalSupply, hkgPrice, tokensQty);\r\n        \r\n      return true;\r\n    }"
      IfStatement
         Source: "if (msg.sender != virtualExchangeAddress) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "msg.sender != virtualExchangeAddress"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier virtualExchangeAddress
             Type: address
             Source: "virtualExchangeAddress"
        Throw
           Gas costs: 0
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "address sender = tx.origin"
        VariableDeclaration "sender"
           Type: address
           Source: "address sender"
          ElementaryTypeName address
             Source: "address"
        MemberAccess to member origin
           Type: address
           Source: "tx.origin"
          Identifier tx
             Type: tx
             Source: "tx"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint tokensQty = hkgValue * hkgPrice"
        VariableDeclaration "tokensQty"
           Type: uint256
           Source: "uint tokensQty"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "hkgValue * hkgPrice"
          Identifier hkgValue
             Type: uint256
             Source: "hkgValue"
          Identifier hkgPrice
             Type: uint256
             Source: "hkgPrice"
      ExpressionStatement
         Gas costs: 0
         Source: "votingRights[sender] +=tokensQty"
        Assignment using operator +=
           Type: uint256
           Source: "votingRights[sender] +=tokensQty"
          IndexAccess
             Type: uint256
             Source: "votingRights[sender]"
            Identifier votingRights
               Type: mapping(address => uint256)
               Source: "votingRights"
            Identifier sender
               Type: address
               Source: "sender"
          Identifier tokensQty
             Type: uint256
             Source: "tokensQty"
      ExpressionStatement
         Gas costs: 0
         Source: "preferedQtySold += tokensQty"
        Assignment using operator +=
           Type: uint256
           Source: "preferedQtySold += tokensQty"
          Identifier preferedQtySold
             Type: uint256
             Source: "preferedQtySold"
          Identifier tokensQty
             Type: uint256
             Source: "tokensQty"
      ExpressionStatement
         Gas costs: 0
         Source: "collectedHKG += hkgValue"
        Assignment using operator +=
           Type: uint256
           Source: "collectedHKG += hkgValue"
          Identifier collectedHKG
             Type: uint256
             Source: "collectedHKG"
          Identifier hkgValue
             Type: uint256
             Source: "hkgValue"
      ExpressionStatement
         Gas costs: 0
         Source: "transferFrom(this, \r\n                   virtualExchangeAddress, tokensQty)"
        FunctionCall
           Type: bool
           Source: "transferFrom(this, \r\n                   virtualExchangeAddress, tokensQty)"
          Identifier transferFrom
             Type: function (address,address,uint256) returns (bool)
             Source: "transferFrom"
          Identifier this
             Type: contract DSTContract
             Source: "this"
          Identifier virtualExchangeAddress
             Type: address
             Source: "virtualExchangeAddress"
          Identifier tokensQty
             Type: uint256
             Source: "tokensQty"
      ExpressionStatement
         Gas costs: 0
         Source: "transfer(sender, tokensQty)"
        FunctionCall
           Type: bool
           Source: "transfer(sender, tokensQty)"
          Identifier transfer
             Type: function (address,uint256) returns (bool)
             Source: "transfer"
          Identifier sender
             Type: address
             Source: "sender"
          Identifier tokensQty
             Type: uint256
             Source: "tokensQty"
      ExpressionStatement
         Gas costs: 0
         Source: "BuyForHKGTransaction(sender, preferedQtySold, totalSupply, hkgPrice, tokensQty)"
        FunctionCall
           Type: tuple()
           Source: "BuyForHKGTransaction(sender, preferedQtySold, totalSupply, hkgPrice, tokensQty)"
          Identifier BuyForHKGTransaction
             Type: function (address,uint256,uint256,uint256,uint256)
             Source: "BuyForHKGTransaction"
          Identifier sender
             Type: address
             Source: "sender"
          Identifier preferedQtySold
             Type: uint256
             Source: "preferedQtySold"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier hkgPrice
             Type: uint256
             Source: "hkgPrice"
          Identifier tokensQty
             Type: uint256
             Source: "tokensQty"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "issueTokens" - public
     Source: "function issueTokens(uint qtyForOneEther, \r\n                         uint qtyToEmit) onlyAfterEnd \r\n                                         onlyExecutive\r\n                                         onlyIfAbleToIssueTokens {\r\n         \r\n         balances[this] += qtyToEmit;\r\n         etherPrice = qtyForOneEther;\r\n         totalSupply    += qtyToEmit;\r\n         \r\n         // rise event  \r\n         DstTokensIssued(qtyForOneEther, totalSupply, totalSupply, qtyToEmit);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint qtyForOneEther, \r\n                         uint qtyToEmit)"
      VariableDeclaration "qtyForOneEther"
         Type: uint256
         Source: "uint qtyForOneEther"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "qtyToEmit"
         Type: uint256
         Source: "uint qtyToEmit"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAfterEnd"
       Gas costs: 0
       Source: "onlyAfterEnd"
      Identifier onlyAfterEnd
         Type: modifier ()
         Source: "onlyAfterEnd"
    ModifierInvocation "onlyExecutive"
       Gas costs: 0
       Source: "onlyExecutive"
      Identifier onlyExecutive
         Type: modifier ()
         Source: "onlyExecutive"
    ModifierInvocation "onlyIfAbleToIssueTokens"
       Gas costs: 0
       Source: "onlyIfAbleToIssueTokens"
      Identifier onlyIfAbleToIssueTokens
         Type: modifier ()
         Source: "onlyIfAbleToIssueTokens"
    Block
       Source: "{\r\n         \r\n         balances[this] += qtyToEmit;\r\n         etherPrice = qtyForOneEther;\r\n         totalSupply    += qtyToEmit;\r\n         \r\n         // rise event  \r\n         DstTokensIssued(qtyForOneEther, totalSupply, totalSupply, qtyToEmit);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[this] += qtyToEmit"
        Assignment using operator +=
           Type: uint256
           Source: "balances[this] += qtyToEmit"
          IndexAccess
             Type: uint256
             Source: "balances[this]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier this
               Type: contract DSTContract
               Source: "this"
          Identifier qtyToEmit
             Type: uint256
             Source: "qtyToEmit"
      ExpressionStatement
         Gas costs: 0
         Source: "etherPrice = qtyForOneEther"
        Assignment using operator =
           Type: uint256
           Source: "etherPrice = qtyForOneEther"
          Identifier etherPrice
             Type: uint256
             Source: "etherPrice"
          Identifier qtyForOneEther
             Type: uint256
             Source: "qtyForOneEther"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply    += qtyToEmit"
        Assignment using operator +=
           Type: uint256
           Source: "totalSupply    += qtyToEmit"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier qtyToEmit
             Type: uint256
             Source: "qtyToEmit"
      ExpressionStatement
         Gas costs: 0
         Source: "DstTokensIssued(qtyForOneEther, totalSupply, totalSupply, qtyToEmit)"
        FunctionCall
           Type: tuple()
           Source: "DstTokensIssued(qtyForOneEther, totalSupply, totalSupply, qtyToEmit)"
          Identifier DstTokensIssued
             Type: function (uint256,uint256,uint256,uint256)
             Source: "DstTokensIssued"
          Identifier qtyForOneEther
             Type: uint256
             Source: "qtyForOneEther"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier qtyToEmit
             Type: uint256
             Source: "qtyToEmit"
  FunctionDefinition "setEtherPrice" - public
     Source: "function setEtherPrice(uint qtyForOneEther) onlyAfterEnd\r\n                                                onlyExecutive {\r\n         etherPrice = qtyForOneEther; \r\n\r\n         // rise event for this\r\n         NewEtherPrice(qtyForOneEther);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint qtyForOneEther)"
      VariableDeclaration "qtyForOneEther"
         Type: uint256
         Source: "uint qtyForOneEther"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAfterEnd"
       Gas costs: 0
       Source: "onlyAfterEnd"
      Identifier onlyAfterEnd
         Type: modifier ()
         Source: "onlyAfterEnd"
    ModifierInvocation "onlyExecutive"
       Gas costs: 0
       Source: "onlyExecutive"
      Identifier onlyExecutive
         Type: modifier ()
         Source: "onlyExecutive"
    Block
       Source: "{\r\n         etherPrice = qtyForOneEther; \r\n\r\n         // rise event for this\r\n         NewEtherPrice(qtyForOneEther);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "etherPrice = qtyForOneEther"
        Assignment using operator =
           Type: uint256
           Source: "etherPrice = qtyForOneEther"
          Identifier etherPrice
             Type: uint256
             Source: "etherPrice"
          Identifier qtyForOneEther
             Type: uint256
             Source: "qtyForOneEther"
      ExpressionStatement
         Gas costs: 0
         Source: "NewEtherPrice(qtyForOneEther)"
        FunctionCall
           Type: tuple()
           Source: "NewEtherPrice(qtyForOneEther)"
          Identifier NewEtherPrice
             Type: function (uint256)
             Source: "NewEtherPrice"
          Identifier qtyForOneEther
             Type: uint256
             Source: "qtyForOneEther"
  FunctionDefinition "disableTokenIssuance" - public
     Source: "function disableTokenIssuance() onlyExecutive {\r\n        ableToIssueTokens = false;\r\n        \r\n        DisableTokenIssuance();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyExecutive"
       Gas costs: 0
       Source: "onlyExecutive"
      Identifier onlyExecutive
         Type: modifier ()
         Source: "onlyExecutive"
    Block
       Source: "{\r\n        ableToIssueTokens = false;\r\n        \r\n        DisableTokenIssuance();\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "ableToIssueTokens = false"
        Assignment using operator =
           Type: bool
           Source: "ableToIssueTokens = false"
          Identifier ableToIssueTokens
             Type: bool
             Source: "ableToIssueTokens"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 0
         Source: "DisableTokenIssuance()"
        FunctionCall
           Type: tuple()
           Source: "DisableTokenIssuance()"
          Identifier DisableTokenIssuance
             Type: function ()
             Source: "DisableTokenIssuance"
  FunctionDefinition "burnRemainToken" - public
     Source: "function burnRemainToken() onlyExecutive {\r\n    \r\n        totalSupply -= balances[this];\r\n        balances[this] = 0;\r\n        \r\n        // rise event for this\r\n        BurnedAllRemainedTokens();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyExecutive"
       Gas costs: 0
       Source: "onlyExecutive"
      Identifier onlyExecutive
         Type: modifier ()
         Source: "onlyExecutive"
    Block
       Source: "{\r\n    \r\n        totalSupply -= balances[this];\r\n        balances[this] = 0;\r\n        \r\n        // rise event for this\r\n        BurnedAllRemainedTokens();\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply -= balances[this]"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= balances[this]"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          IndexAccess
             Type: uint256
             Source: "balances[this]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier this
               Type: contract DSTContract
               Source: "this"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[this] = 0"
        Assignment using operator =
           Type: uint256
           Source: "balances[this] = 0"
          IndexAccess
             Type: uint256
             Source: "balances[this]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier this
               Type: contract DSTContract
               Source: "this"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "BurnedAllRemainedTokens()"
        FunctionCall
           Type: tuple()
           Source: "BurnedAllRemainedTokens()"
          Identifier BurnedAllRemainedTokens
             Type: function ()
             Source: "BurnedAllRemainedTokens"
  FunctionDefinition "submitEtherProposal" - public
     Source: "function submitEtherProposal(uint requestValue, string url) onlyAfterEnd \r\n                                                                onlyExecutive returns (bytes32 resultId, bool resultSucces) {       \r\n    \r\n        // ensure there is no more issuence available \r\n        if (ableToIssueTokens) throw;\r\n            \r\n        // ensure there is no more tokens available \r\n        if (balanceOf(this) > 0) throw;\r\n\r\n        // Possible to submit a proposal once 2 weeks \r\n        if (now < (timeOfLastProposal + 2 weeks)) throw;\r\n            \r\n        uint percent = collectedEther / 100;\r\n            \r\n        if (requestValue > PROPOSAL_FUNDS_TH * percent) throw;\r\n\r\n        // if remained value is less than requested gain all.\r\n        if (requestValue > this.balance) \r\n            requestValue = this.balance;    \r\n            \r\n        // set id of the proposal\r\n        // submit proposal to the map\r\n        bytes32 id = sha3(msg.data, now);\r\n        uint timeEnds = now + PROPOSAL_LIFETIME; \r\n            \r\n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.ETHER);\r\n        proposals[id] = newProposal;\r\n        listProposals.push(newProposal);\r\n            \r\n        timeOfLastProposal = now;                        \r\n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\r\n        \r\n        return (id, true);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint requestValue, string url)"
      VariableDeclaration "requestValue"
         Type: uint256
         Source: "uint requestValue"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "url"
         Type: string memory
         Source: "string url"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 resultId, bool resultSucces)"
      VariableDeclaration "resultId"
         Type: bytes32
         Source: "bytes32 resultId"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "resultSucces"
         Type: bool
         Source: "bool resultSucces"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyAfterEnd"
       Gas costs: 0
       Source: "onlyAfterEnd"
      Identifier onlyAfterEnd
         Type: modifier ()
         Source: "onlyAfterEnd"
    ModifierInvocation "onlyExecutive"
       Gas costs: 0
       Source: "onlyExecutive"
      Identifier onlyExecutive
         Type: modifier ()
         Source: "onlyExecutive"
    Block
       Source: "{       \r\n    \r\n        // ensure there is no more issuence available \r\n        if (ableToIssueTokens) throw;\r\n            \r\n        // ensure there is no more tokens available \r\n        if (balanceOf(this) > 0) throw;\r\n\r\n        // Possible to submit a proposal once 2 weeks \r\n        if (now < (timeOfLastProposal + 2 weeks)) throw;\r\n            \r\n        uint percent = collectedEther / 100;\r\n            \r\n        if (requestValue > PROPOSAL_FUNDS_TH * percent) throw;\r\n\r\n        // if remained value is less than requested gain all.\r\n        if (requestValue > this.balance) \r\n            requestValue = this.balance;    \r\n            \r\n        // set id of the proposal\r\n        // submit proposal to the map\r\n        bytes32 id = sha3(msg.data, now);\r\n        uint timeEnds = now + PROPOSAL_LIFETIME; \r\n            \r\n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.ETHER);\r\n        proposals[id] = newProposal;\r\n        listProposals.push(newProposal);\r\n            \r\n        timeOfLastProposal = now;                        \r\n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\r\n        \r\n        return (id, true);\r\n    }"
      IfStatement
         Source: "if (ableToIssueTokens) throw"
        Identifier ableToIssueTokens
           Type: bool
           Gas costs: 0
           Source: "ableToIssueTokens"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (balanceOf(this) > 0) throw"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "balanceOf(this) > 0"
          FunctionCall
             Type: uint256
             Source: "balanceOf(this)"
            Identifier balanceOf
               Type: function (address) view returns (uint256)
               Source: "balanceOf"
            Identifier this
               Type: contract DSTContract
               Source: "this"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (now < (timeOfLastProposal + 2 weeks)) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "now < (timeOfLastProposal + 2 weeks)"
          Identifier now
             Type: uint256
             Source: "now"
          TupleExpression
             Type: uint256
             Source: "(timeOfLastProposal + 2 weeks)"
            BinaryOperation using operator +
               Type: uint256
               Source: "timeOfLastProposal + 2 weeks"
              Identifier timeOfLastProposal
                 Type: uint256
                 Source: "timeOfLastProposal"
              Literal, token: [no token] value: 2
                 Type: int_const 1209600
                 Source: "2 weeks"
        Throw
           Gas costs: 0
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint percent = collectedEther / 100"
        VariableDeclaration "percent"
           Type: uint256
           Source: "uint percent"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "collectedEther / 100"
          Identifier collectedEther
             Type: uint256
             Source: "collectedEther"
          Literal, token: [no token] value: 100
             Type: int_const 100
             Source: "100"
      IfStatement
         Source: "if (requestValue > PROPOSAL_FUNDS_TH * percent) throw"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "requestValue > PROPOSAL_FUNDS_TH * percent"
          Identifier requestValue
             Type: uint256
             Source: "requestValue"
          BinaryOperation using operator *
             Type: uint256
             Source: "PROPOSAL_FUNDS_TH * percent"
            Identifier PROPOSAL_FUNDS_TH
               Type: uint256
               Source: "PROPOSAL_FUNDS_TH"
            Identifier percent
               Type: uint256
               Source: "percent"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (requestValue > this.balance) \r\n            requestValue = this.balance"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "requestValue > this.balance"
          Identifier requestValue
             Type: uint256
             Source: "requestValue"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract DSTContract
               Source: "this"
        ExpressionStatement
           Gas costs: 0
           Source: "requestValue = this.balance"
          Assignment using operator =
             Type: uint256
             Source: "requestValue = this.balance"
            Identifier requestValue
               Type: uint256
               Source: "requestValue"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract DSTContract
                 Source: "this"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 id = sha3(msg.data, now)"
        VariableDeclaration "id"
           Type: bytes32
           Source: "bytes32 id"
          ElementaryTypeName bytes32
             Source: "bytes32"
        FunctionCall
           Type: bytes32
           Source: "sha3(msg.data, now)"
          Identifier sha3
             Type: function () pure returns (bytes32)
             Source: "sha3"
          MemberAccess to member data
             Type: bytes calldata
             Source: "msg.data"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier now
             Type: uint256
             Source: "now"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint timeEnds = now + PROPOSAL_LIFETIME"
        VariableDeclaration "timeEnds"
           Type: uint256
           Source: "uint timeEnds"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "now + PROPOSAL_LIFETIME"
          Identifier now
             Type: uint256
             Source: "now"
          Identifier PROPOSAL_LIFETIME
             Type: uint256
             Source: "PROPOSAL_LIFETIME"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.ETHER)"
        VariableDeclaration "newProposal"
           Type: struct DSTContract.Proposal memory
           Source: "Proposal memory newProposal"
          UserDefinedTypeName "Proposal"
             Source: "Proposal"
        FunctionCall
           Type: struct DSTContract.Proposal memory
           Source: "Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.ETHER)"
          Identifier Proposal
             Type: type(struct DSTContract.Proposal storage pointer)
             Source: "Proposal"
          Identifier id
             Type: bytes32
             Source: "id"
          Identifier requestValue
             Type: uint256
             Source: "requestValue"
          Identifier url
             Type: string memory
             Source: "url"
          Identifier timeEnds
             Type: uint256
             Source: "timeEnds"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: false value: false
             Type: bool
             Source: "false"
          MemberAccess to member ETHER
             Type: enum DSTContract.ProposalCurrency
             Source: "ProposalCurrency.ETHER"
            Identifier ProposalCurrency
               Type: type(enum DSTContract.ProposalCurrency)
               Source: "ProposalCurrency"
      ExpressionStatement
         Gas costs: 0
         Source: "proposals[id] = newProposal"
        Assignment using operator =
           Type: struct DSTContract.Proposal storage ref
           Source: "proposals[id] = newProposal"
          IndexAccess
             Type: struct DSTContract.Proposal storage ref
             Source: "proposals[id]"
            Identifier proposals
               Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
               Source: "proposals"
            Identifier id
               Type: bytes32
               Source: "id"
          Identifier newProposal
             Type: struct DSTContract.Proposal memory
             Source: "newProposal"
      ExpressionStatement
         Gas costs: 0
         Source: "listProposals.push(newProposal)"
        FunctionCall
           Type: uint256
           Source: "listProposals.push(newProposal)"
          MemberAccess to member push
             Type: function (struct DSTContract.Proposal storage ref) returns (uint256)
             Source: "listProposals.push"
            Identifier listProposals
               Type: struct DSTContract.Proposal storage ref[] storage ref
               Source: "listProposals"
          Identifier newProposal
             Type: struct DSTContract.Proposal memory
             Source: "newProposal"
      ExpressionStatement
         Gas costs: 0
         Source: "timeOfLastProposal = now"
        Assignment using operator =
           Type: uint256
           Source: "timeOfLastProposal = now"
          Identifier timeOfLastProposal
             Type: uint256
             Source: "timeOfLastProposal"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 0
         Source: "ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender)"
          Identifier ProposalRequestSubmitted
             Type: function (bytes32,uint256,uint256,string memory,address)
             Source: "ProposalRequestSubmitted"
          Identifier id
             Type: bytes32
             Source: "id"
          Identifier requestValue
             Type: uint256
             Source: "requestValue"
          Identifier timeEnds
             Type: uint256
             Source: "timeEnds"
          Identifier url
             Type: string memory
             Source: "url"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      Return
         Gas costs: 0
         Source: "return (id, true)"
        TupleExpression
           Type: tuple(bytes32,bool)
           Source: "(id, true)"
          Identifier id
             Type: bytes32
             Source: "id"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "submitHKGProposal" - public
     Source: "function submitHKGProposal(uint requestValue, string url) onlyAfterEnd\r\n                                                              onlyExecutive returns (bytes32 resultId, bool resultSucces){\r\n        \r\n\r\n        // If there is no 2 months over since the last event.\r\n        // There is no posible to get any HKG. After 2 months\r\n        // all the HKG is available. \r\n        if (now < (eventInfo.getEventEnd() + 8 weeks)) {\r\n            throw;\r\n        }\r\n\r\n        // Possible to submit a proposal once 2 weeks \r\n        if (now < (timeOfLastProposal + 2 weeks)) throw;\r\n\r\n        uint percent = preferedQtySold / 100;\r\n        \r\n        // validate the amount is legit\r\n        // first 5 proposals should be less than 20% \r\n        if (counterProposals <= 5 && \r\n            requestValue     >  PROPOSAL_FUNDS_TH * percent) throw;\r\n                \r\n        // if remained value is less than requested \r\n        // gain all.\r\n        if (requestValue > getHKGOwned()) \r\n            requestValue = getHKGOwned();\r\n        \r\n        \r\n        // set id of the proposal\r\n        // submit proposal to the map\r\n        bytes32 id = sha3(msg.data, now);\r\n        uint timeEnds = now + PROPOSAL_LIFETIME; \r\n        \r\n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.HKG);\r\n        proposals[id] = newProposal;\r\n        listProposals.push(newProposal);\r\n        \r\n        ++counterProposals;\r\n        timeOfLastProposal = now;                \r\n                \r\n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\r\n        \r\n        return (id, true);        \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint requestValue, string url)"
      VariableDeclaration "requestValue"
         Type: uint256
         Source: "uint requestValue"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "url"
         Type: string memory
         Source: "string url"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 resultId, bool resultSucces)"
      VariableDeclaration "resultId"
         Type: bytes32
         Source: "bytes32 resultId"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "resultSucces"
         Type: bool
         Source: "bool resultSucces"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyAfterEnd"
       Gas costs: 0
       Source: "onlyAfterEnd"
      Identifier onlyAfterEnd
         Type: modifier ()
         Source: "onlyAfterEnd"
    ModifierInvocation "onlyExecutive"
       Gas costs: 0
       Source: "onlyExecutive"
      Identifier onlyExecutive
         Type: modifier ()
         Source: "onlyExecutive"
    Block
       Source: "{\r\n        \r\n\r\n        // If there is no 2 months over since the last event.\r\n        // There is no posible to get any HKG. After 2 months\r\n        // all the HKG is available. \r\n        if (now < (eventInfo.getEventEnd() + 8 weeks)) {\r\n            throw;\r\n        }\r\n\r\n        // Possible to submit a proposal once 2 weeks \r\n        if (now < (timeOfLastProposal + 2 weeks)) throw;\r\n\r\n        uint percent = preferedQtySold / 100;\r\n        \r\n        // validate the amount is legit\r\n        // first 5 proposals should be less than 20% \r\n        if (counterProposals <= 5 && \r\n            requestValue     >  PROPOSAL_FUNDS_TH * percent) throw;\r\n                \r\n        // if remained value is less than requested \r\n        // gain all.\r\n        if (requestValue > getHKGOwned()) \r\n            requestValue = getHKGOwned();\r\n        \r\n        \r\n        // set id of the proposal\r\n        // submit proposal to the map\r\n        bytes32 id = sha3(msg.data, now);\r\n        uint timeEnds = now + PROPOSAL_LIFETIME; \r\n        \r\n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.HKG);\r\n        proposals[id] = newProposal;\r\n        listProposals.push(newProposal);\r\n        \r\n        ++counterProposals;\r\n        timeOfLastProposal = now;                \r\n                \r\n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\r\n        \r\n        return (id, true);        \r\n    }"
      IfStatement
         Source: "if (now < (eventInfo.getEventEnd() + 8 weeks)) {\r\n            throw;\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "now < (eventInfo.getEventEnd() + 8 weeks)"
          Identifier now
             Type: uint256
             Source: "now"
          TupleExpression
             Type: uint256
             Source: "(eventInfo.getEventEnd() + 8 weeks)"
            BinaryOperation using operator +
               Type: uint256
               Source: "eventInfo.getEventEnd() + 8 weeks"
              FunctionCall
                 Type: uint256
                 Source: "eventInfo.getEventEnd()"
                MemberAccess to member getEventEnd
                   Type: function () view external returns (uint256)
                   Source: "eventInfo.getEventEnd"
                  Identifier eventInfo
                     Type: contract EventInfo
                     Source: "eventInfo"
              Literal, token: [no token] value: 8
                 Type: int_const 4838400
                 Source: "8 weeks"
        Block
           Source: "{\r\n            throw;\r\n        }"
          Throw
             Gas costs: 0
             Source: "throw"
      IfStatement
         Source: "if (now < (timeOfLastProposal + 2 weeks)) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "now < (timeOfLastProposal + 2 weeks)"
          Identifier now
             Type: uint256
             Source: "now"
          TupleExpression
             Type: uint256
             Source: "(timeOfLastProposal + 2 weeks)"
            BinaryOperation using operator +
               Type: uint256
               Source: "timeOfLastProposal + 2 weeks"
              Identifier timeOfLastProposal
                 Type: uint256
                 Source: "timeOfLastProposal"
              Literal, token: [no token] value: 2
                 Type: int_const 1209600
                 Source: "2 weeks"
        Throw
           Gas costs: 0
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint percent = preferedQtySold / 100"
        VariableDeclaration "percent"
           Type: uint256
           Source: "uint percent"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "preferedQtySold / 100"
          Identifier preferedQtySold
             Type: uint256
             Source: "preferedQtySold"
          Literal, token: [no token] value: 100
             Type: int_const 100
             Source: "100"
      IfStatement
         Source: "if (counterProposals <= 5 && \r\n            requestValue     >  PROPOSAL_FUNDS_TH * percent) throw"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "counterProposals <= 5 && \r\n            requestValue     >  PROPOSAL_FUNDS_TH * percent"
          BinaryOperation using operator <=
             Type: bool
             Source: "counterProposals <= 5"
            Identifier counterProposals
               Type: uint256
               Source: "counterProposals"
            Literal, token: [no token] value: 5
               Type: int_const 5
               Source: "5"
          BinaryOperation using operator >
             Type: bool
             Source: "requestValue     >  PROPOSAL_FUNDS_TH * percent"
            Identifier requestValue
               Type: uint256
               Source: "requestValue"
            BinaryOperation using operator *
               Type: uint256
               Source: "PROPOSAL_FUNDS_TH * percent"
              Identifier PROPOSAL_FUNDS_TH
                 Type: uint256
                 Source: "PROPOSAL_FUNDS_TH"
              Identifier percent
                 Type: uint256
                 Source: "percent"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (requestValue > getHKGOwned()) \r\n            requestValue = getHKGOwned()"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "requestValue > getHKGOwned()"
          Identifier requestValue
             Type: uint256
             Source: "requestValue"
          FunctionCall
             Type: uint256
             Source: "getHKGOwned()"
            Identifier getHKGOwned
               Type: function () view returns (uint256)
               Source: "getHKGOwned"
        ExpressionStatement
           Gas costs: 0
           Source: "requestValue = getHKGOwned()"
          Assignment using operator =
             Type: uint256
             Source: "requestValue = getHKGOwned()"
            Identifier requestValue
               Type: uint256
               Source: "requestValue"
            FunctionCall
               Type: uint256
               Source: "getHKGOwned()"
              Identifier getHKGOwned
                 Type: function () view returns (uint256)
                 Source: "getHKGOwned"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 id = sha3(msg.data, now)"
        VariableDeclaration "id"
           Type: bytes32
           Source: "bytes32 id"
          ElementaryTypeName bytes32
             Source: "bytes32"
        FunctionCall
           Type: bytes32
           Source: "sha3(msg.data, now)"
          Identifier sha3
             Type: function () pure returns (bytes32)
             Source: "sha3"
          MemberAccess to member data
             Type: bytes calldata
             Source: "msg.data"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier now
             Type: uint256
             Source: "now"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint timeEnds = now + PROPOSAL_LIFETIME"
        VariableDeclaration "timeEnds"
           Type: uint256
           Source: "uint timeEnds"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "now + PROPOSAL_LIFETIME"
          Identifier now
             Type: uint256
             Source: "now"
          Identifier PROPOSAL_LIFETIME
             Type: uint256
             Source: "PROPOSAL_LIFETIME"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.HKG)"
        VariableDeclaration "newProposal"
           Type: struct DSTContract.Proposal memory
           Source: "Proposal memory newProposal"
          UserDefinedTypeName "Proposal"
             Source: "Proposal"
        FunctionCall
           Type: struct DSTContract.Proposal memory
           Source: "Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.HKG)"
          Identifier Proposal
             Type: type(struct DSTContract.Proposal storage pointer)
             Source: "Proposal"
          Identifier id
             Type: bytes32
             Source: "id"
          Identifier requestValue
             Type: uint256
             Source: "requestValue"
          Identifier url
             Type: string memory
             Source: "url"
          Identifier timeEnds
             Type: uint256
             Source: "timeEnds"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: false value: false
             Type: bool
             Source: "false"
          MemberAccess to member HKG
             Type: enum DSTContract.ProposalCurrency
             Source: "ProposalCurrency.HKG"
            Identifier ProposalCurrency
               Type: type(enum DSTContract.ProposalCurrency)
               Source: "ProposalCurrency"
      ExpressionStatement
         Gas costs: 0
         Source: "proposals[id] = newProposal"
        Assignment using operator =
           Type: struct DSTContract.Proposal storage ref
           Source: "proposals[id] = newProposal"
          IndexAccess
             Type: struct DSTContract.Proposal storage ref
             Source: "proposals[id]"
            Identifier proposals
               Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
               Source: "proposals"
            Identifier id
               Type: bytes32
               Source: "id"
          Identifier newProposal
             Type: struct DSTContract.Proposal memory
             Source: "newProposal"
      ExpressionStatement
         Gas costs: 0
         Source: "listProposals.push(newProposal)"
        FunctionCall
           Type: uint256
           Source: "listProposals.push(newProposal)"
          MemberAccess to member push
             Type: function (struct DSTContract.Proposal storage ref) returns (uint256)
             Source: "listProposals.push"
            Identifier listProposals
               Type: struct DSTContract.Proposal storage ref[] storage ref
               Source: "listProposals"
          Identifier newProposal
             Type: struct DSTContract.Proposal memory
             Source: "newProposal"
      ExpressionStatement
         Gas costs: 0
         Source: "++counterProposals"
        UnaryOperation (prefix) ++
           Type: uint256
           Source: "++counterProposals"
          Identifier counterProposals
             Type: uint256
             Source: "counterProposals"
      ExpressionStatement
         Gas costs: 0
         Source: "timeOfLastProposal = now"
        Assignment using operator =
           Type: uint256
           Source: "timeOfLastProposal = now"
          Identifier timeOfLastProposal
             Type: uint256
             Source: "timeOfLastProposal"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 0
         Source: "ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender)"
          Identifier ProposalRequestSubmitted
             Type: function (bytes32,uint256,uint256,string memory,address)
             Source: "ProposalRequestSubmitted"
          Identifier id
             Type: bytes32
             Source: "id"
          Identifier requestValue
             Type: uint256
             Source: "requestValue"
          Identifier timeEnds
             Type: uint256
             Source: "timeEnds"
          Identifier url
             Type: string memory
             Source: "url"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      Return
         Gas costs: 0
         Source: "return (id, true)"
        TupleExpression
           Type: tuple(bytes32,bool)
           Source: "(id, true)"
          Identifier id
             Type: bytes32
             Source: "id"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "objectProposal" - public
     Source: "function objectProposal(bytes32 id){\r\n         \r\n        Proposal memory proposal = proposals[id];\r\n         \r\n        // check proposal exist \r\n        if (proposals[id].id == 0) throw;\r\n\r\n        // check already redeemed\r\n        if (proposals[id].redeemed) throw;\r\n         \r\n        // ensure objection time\r\n        if (now >= proposals[id].votindEndTS) throw;\r\n         \r\n        // ensure not voted  \r\n        if (proposals[id].voted[msg.sender]) throw;\r\n         \r\n         // submit votes\r\n         uint votes = votingRights[msg.sender];\r\n         proposals[id].votesObjecting += votes;\r\n         \r\n         // mark voted \r\n         proposals[id].voted[msg.sender] = true; \r\n         \r\n         uint idx = getIndexByProposalId(id);\r\n         listProposals[idx] = proposals[id];   \r\n\r\n         ObjectedVote(id, msg.sender, votes);         \r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 id)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n         \r\n        Proposal memory proposal = proposals[id];\r\n         \r\n        // check proposal exist \r\n        if (proposals[id].id == 0) throw;\r\n\r\n        // check already redeemed\r\n        if (proposals[id].redeemed) throw;\r\n         \r\n        // ensure objection time\r\n        if (now >= proposals[id].votindEndTS) throw;\r\n         \r\n        // ensure not voted  \r\n        if (proposals[id].voted[msg.sender]) throw;\r\n         \r\n         // submit votes\r\n         uint votes = votingRights[msg.sender];\r\n         proposals[id].votesObjecting += votes;\r\n         \r\n         // mark voted \r\n         proposals[id].voted[msg.sender] = true; \r\n         \r\n         uint idx = getIndexByProposalId(id);\r\n         listProposals[idx] = proposals[id];   \r\n\r\n         ObjectedVote(id, msg.sender, votes);         \r\n     }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "Proposal memory proposal = proposals[id]"
        VariableDeclaration "proposal"
           Type: struct DSTContract.Proposal memory
           Source: "Proposal memory proposal"
          UserDefinedTypeName "Proposal"
             Source: "Proposal"
        IndexAccess
           Type: struct DSTContract.Proposal storage ref
           Source: "proposals[id]"
          Identifier proposals
             Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
             Source: "proposals"
          Identifier id
             Type: bytes32
             Source: "id"
      IfStatement
         Source: "if (proposals[id].id == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "proposals[id].id == 0"
          MemberAccess to member id
             Type: bytes32
             Source: "proposals[id].id"
            IndexAccess
               Type: struct DSTContract.Proposal storage ref
               Source: "proposals[id]"
              Identifier proposals
                 Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                 Source: "proposals"
              Identifier id
                 Type: bytes32
                 Source: "id"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (proposals[id].redeemed) throw"
        MemberAccess to member redeemed
           Type: bool
           Gas costs: 0
           Source: "proposals[id].redeemed"
          IndexAccess
             Type: struct DSTContract.Proposal storage ref
             Source: "proposals[id]"
            Identifier proposals
               Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
               Source: "proposals"
            Identifier id
               Type: bytes32
               Source: "id"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (now >= proposals[id].votindEndTS) throw"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 0
           Source: "now >= proposals[id].votindEndTS"
          Identifier now
             Type: uint256
             Source: "now"
          MemberAccess to member votindEndTS
             Type: uint256
             Source: "proposals[id].votindEndTS"
            IndexAccess
               Type: struct DSTContract.Proposal storage ref
               Source: "proposals[id]"
              Identifier proposals
                 Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                 Source: "proposals"
              Identifier id
                 Type: bytes32
                 Source: "id"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (proposals[id].voted[msg.sender]) throw"
        IndexAccess
           Type: bool
           Gas costs: 0
           Source: "proposals[id].voted[msg.sender]"
          MemberAccess to member voted
             Type: mapping(address => bool)
             Source: "proposals[id].voted"
            IndexAccess
               Type: struct DSTContract.Proposal storage ref
               Source: "proposals[id]"
              Identifier proposals
                 Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                 Source: "proposals"
              Identifier id
                 Type: bytes32
                 Source: "id"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
        Throw
           Gas costs: 0
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint votes = votingRights[msg.sender]"
        VariableDeclaration "votes"
           Type: uint256
           Source: "uint votes"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "votingRights[msg.sender]"
          Identifier votingRights
             Type: mapping(address => uint256)
             Source: "votingRights"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "proposals[id].votesObjecting += votes"
        Assignment using operator +=
           Type: uint256
           Source: "proposals[id].votesObjecting += votes"
          MemberAccess to member votesObjecting
             Type: uint256
             Source: "proposals[id].votesObjecting"
            IndexAccess
               Type: struct DSTContract.Proposal storage ref
               Source: "proposals[id]"
              Identifier proposals
                 Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                 Source: "proposals"
              Identifier id
                 Type: bytes32
                 Source: "id"
          Identifier votes
             Type: uint256
             Source: "votes"
      ExpressionStatement
         Gas costs: 0
         Source: "proposals[id].voted[msg.sender] = true"
        Assignment using operator =
           Type: bool
           Source: "proposals[id].voted[msg.sender] = true"
          IndexAccess
             Type: bool
             Source: "proposals[id].voted[msg.sender]"
            MemberAccess to member voted
               Type: mapping(address => bool)
               Source: "proposals[id].voted"
              IndexAccess
                 Type: struct DSTContract.Proposal storage ref
                 Source: "proposals[id]"
                Identifier proposals
                   Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                   Source: "proposals"
                Identifier id
                   Type: bytes32
                   Source: "id"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint idx = getIndexByProposalId(id)"
        VariableDeclaration "idx"
           Type: uint256
           Source: "uint idx"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "getIndexByProposalId(id)"
          Identifier getIndexByProposalId
             Type: function (bytes32) returns (uint256)
             Source: "getIndexByProposalId"
          Identifier id
             Type: bytes32
             Source: "id"
      ExpressionStatement
         Gas costs: 0
         Source: "listProposals[idx] = proposals[id]"
        Assignment using operator =
           Type: struct DSTContract.Proposal storage ref
           Source: "listProposals[idx] = proposals[id]"
          IndexAccess
             Type: struct DSTContract.Proposal storage ref
             Source: "listProposals[idx]"
            Identifier listProposals
               Type: struct DSTContract.Proposal storage ref[] storage ref
               Source: "listProposals"
            Identifier idx
               Type: uint256
               Source: "idx"
          IndexAccess
             Type: struct DSTContract.Proposal storage ref
             Source: "proposals[id]"
            Identifier proposals
               Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
               Source: "proposals"
            Identifier id
               Type: bytes32
               Source: "id"
      ExpressionStatement
         Gas costs: 0
         Source: "ObjectedVote(id, msg.sender, votes)"
        FunctionCall
           Type: tuple()
           Source: "ObjectedVote(id, msg.sender, votes)"
          Identifier ObjectedVote
             Type: function (bytes32,address,uint256)
             Source: "ObjectedVote"
          Identifier id
             Type: bytes32
             Source: "id"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier votes
             Type: uint256
             Source: "votes"
  FunctionDefinition "getIndexByProposalId" - public
     Source: "function getIndexByProposalId(bytes32 id) returns (uint result){\r\n         \r\n         for (uint i = 0; i < listProposals.length; ++i){\r\n             if (id == listProposals[i].id) return i;\r\n         }\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 id)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n         \r\n         for (uint i = 0; i < listProposals.length; ++i){\r\n             if (id == listProposals[i].id) return i;\r\n         }\r\n     }"
      ForStatement
         Source: "for (uint i = 0; i < listProposals.length; ++i){\r\n             if (id == listProposals[i].id) return i;\r\n         }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < listProposals.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "listProposals.length"
            Identifier listProposals
               Type: struct DSTContract.Proposal storage ref[] storage ref
               Source: "listProposals"
        ExpressionStatement
           Gas costs: 0
           Source: "++i"
          UnaryOperation (prefix) ++
             Type: uint256
             Source: "++i"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n             if (id == listProposals[i].id) return i;\r\n         }"
          IfStatement
             Source: "if (id == listProposals[i].id) return i"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 0
               Source: "id == listProposals[i].id"
              Identifier id
                 Type: bytes32
                 Source: "id"
              MemberAccess to member id
                 Type: bytes32
                 Source: "listProposals[i].id"
                IndexAccess
                   Type: struct DSTContract.Proposal storage ref
                   Source: "listProposals[i]"
                  Identifier listProposals
                     Type: struct DSTContract.Proposal storage ref[] storage ref
                     Source: "listProposals"
                  Identifier i
                     Type: uint256
                     Source: "i"
            Return
               Gas costs: 0
               Source: "return i"
              Identifier i
                 Type: uint256
                 Source: "i"
  FunctionDefinition "redeemProposalFunds" - public
     Source: "function redeemProposalFunds(bytes32 id) onlyExecutive {\r\n\r\n        if (proposals[id].id == 0) throw;\r\n        if (proposals[id].submitter != msg.sender) throw;\r\n\r\n        // ensure objection time\r\n        if (now < proposals[id].votindEndTS) throw;\r\n                           \r\n    \r\n            // check already redeemed\r\n        if (proposals[id].redeemed) throw;\r\n\r\n        // check votes objection => 55% of total votes\r\n        uint objectionThreshold = preferedQtySold / 100 * 55;\r\n        if (proposals[id].votesObjecting  > objectionThreshold) throw;\r\n    \r\n    \r\n        if (proposals[id].proposalCurrency == ProposalCurrency.HKG){\r\n            \r\n            // send hacker gold \r\n            hackerGold.transfer(proposals[id].submitter, proposals[id].value);      \r\n                        \r\n        } else {\r\n                        \r\n           // send ether              \r\n           bool success = proposals[id].submitter.send(proposals[id].value); \r\n\r\n           // rise event\r\n           EtherRedeemAccepted(proposals[id].submitter, proposals[id].value);                              \r\n        }\r\n        \r\n        // execute the proposal \r\n        proposals[id].redeemed = true; \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 id)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyExecutive"
       Gas costs: 0
       Source: "onlyExecutive"
      Identifier onlyExecutive
         Type: modifier ()
         Source: "onlyExecutive"
    Block
       Source: "{\r\n\r\n        if (proposals[id].id == 0) throw;\r\n        if (proposals[id].submitter != msg.sender) throw;\r\n\r\n        // ensure objection time\r\n        if (now < proposals[id].votindEndTS) throw;\r\n                           \r\n    \r\n            // check already redeemed\r\n        if (proposals[id].redeemed) throw;\r\n\r\n        // check votes objection => 55% of total votes\r\n        uint objectionThreshold = preferedQtySold / 100 * 55;\r\n        if (proposals[id].votesObjecting  > objectionThreshold) throw;\r\n    \r\n    \r\n        if (proposals[id].proposalCurrency == ProposalCurrency.HKG){\r\n            \r\n            // send hacker gold \r\n            hackerGold.transfer(proposals[id].submitter, proposals[id].value);      \r\n                        \r\n        } else {\r\n                        \r\n           // send ether              \r\n           bool success = proposals[id].submitter.send(proposals[id].value); \r\n\r\n           // rise event\r\n           EtherRedeemAccepted(proposals[id].submitter, proposals[id].value);                              \r\n        }\r\n        \r\n        // execute the proposal \r\n        proposals[id].redeemed = true; \r\n    }"
      IfStatement
         Source: "if (proposals[id].id == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "proposals[id].id == 0"
          MemberAccess to member id
             Type: bytes32
             Source: "proposals[id].id"
            IndexAccess
               Type: struct DSTContract.Proposal storage ref
               Source: "proposals[id]"
              Identifier proposals
                 Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                 Source: "proposals"
              Identifier id
                 Type: bytes32
                 Source: "id"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (proposals[id].submitter != msg.sender) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "proposals[id].submitter != msg.sender"
          MemberAccess to member submitter
             Type: address
             Source: "proposals[id].submitter"
            IndexAccess
               Type: struct DSTContract.Proposal storage ref
               Source: "proposals[id]"
              Identifier proposals
                 Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                 Source: "proposals"
              Identifier id
                 Type: bytes32
                 Source: "id"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (now < proposals[id].votindEndTS) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "now < proposals[id].votindEndTS"
          Identifier now
             Type: uint256
             Source: "now"
          MemberAccess to member votindEndTS
             Type: uint256
             Source: "proposals[id].votindEndTS"
            IndexAccess
               Type: struct DSTContract.Proposal storage ref
               Source: "proposals[id]"
              Identifier proposals
                 Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                 Source: "proposals"
              Identifier id
                 Type: bytes32
                 Source: "id"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (proposals[id].redeemed) throw"
        MemberAccess to member redeemed
           Type: bool
           Gas costs: 0
           Source: "proposals[id].redeemed"
          IndexAccess
             Type: struct DSTContract.Proposal storage ref
             Source: "proposals[id]"
            Identifier proposals
               Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
               Source: "proposals"
            Identifier id
               Type: bytes32
               Source: "id"
        Throw
           Gas costs: 0
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint objectionThreshold = preferedQtySold / 100 * 55"
        VariableDeclaration "objectionThreshold"
           Type: uint256
           Source: "uint objectionThreshold"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "preferedQtySold / 100 * 55"
          BinaryOperation using operator /
             Type: uint256
             Source: "preferedQtySold / 100"
            Identifier preferedQtySold
               Type: uint256
               Source: "preferedQtySold"
            Literal, token: [no token] value: 100
               Type: int_const 100
               Source: "100"
          Literal, token: [no token] value: 55
             Type: int_const 55
             Source: "55"
      IfStatement
         Source: "if (proposals[id].votesObjecting  > objectionThreshold) throw"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "proposals[id].votesObjecting  > objectionThreshold"
          MemberAccess to member votesObjecting
             Type: uint256
             Source: "proposals[id].votesObjecting"
            IndexAccess
               Type: struct DSTContract.Proposal storage ref
               Source: "proposals[id]"
              Identifier proposals
                 Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                 Source: "proposals"
              Identifier id
                 Type: bytes32
                 Source: "id"
          Identifier objectionThreshold
             Type: uint256
             Source: "objectionThreshold"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (proposals[id].proposalCurrency == ProposalCurrency.HKG){\r\n            \r\n            // send hacker gold \r\n            hackerGold.transfer(proposals[id].submitter, proposals[id].value);      \r\n                        \r\n        } else {\r\n                        \r\n           // send ether              \r\n           bool success = proposals[id].submitter.send(proposals[id].value); \r\n\r\n           // rise event\r\n           EtherRedeemAccepted(proposals[id].submitter, proposals[id].value);                              \r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "proposals[id].proposalCurrency == ProposalCurrency.HKG"
          MemberAccess to member proposalCurrency
             Type: enum DSTContract.ProposalCurrency
             Source: "proposals[id].proposalCurrency"
            IndexAccess
               Type: struct DSTContract.Proposal storage ref
               Source: "proposals[id]"
              Identifier proposals
                 Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                 Source: "proposals"
              Identifier id
                 Type: bytes32
                 Source: "id"
          MemberAccess to member HKG
             Type: enum DSTContract.ProposalCurrency
             Source: "ProposalCurrency.HKG"
            Identifier ProposalCurrency
               Type: type(enum DSTContract.ProposalCurrency)
               Source: "ProposalCurrency"
        Block
           Source: "{\r\n            \r\n            // send hacker gold \r\n            hackerGold.transfer(proposals[id].submitter, proposals[id].value);      \r\n                        \r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "hackerGold.transfer(proposals[id].submitter, proposals[id].value)"
            FunctionCall
               Type: bool
               Source: "hackerGold.transfer(proposals[id].submitter, proposals[id].value)"
              MemberAccess to member transfer
                 Type: function (address,uint256) external returns (bool)
                 Source: "hackerGold.transfer"
                Identifier hackerGold
                   Type: contract HackerGold
                   Source: "hackerGold"
              MemberAccess to member submitter
                 Type: address
                 Source: "proposals[id].submitter"
                IndexAccess
                   Type: struct DSTContract.Proposal storage ref
                   Source: "proposals[id]"
                  Identifier proposals
                     Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                     Source: "proposals"
                  Identifier id
                     Type: bytes32
                     Source: "id"
              MemberAccess to member value
                 Type: uint256
                 Source: "proposals[id].value"
                IndexAccess
                   Type: struct DSTContract.Proposal storage ref
                   Source: "proposals[id]"
                  Identifier proposals
                     Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                     Source: "proposals"
                  Identifier id
                     Type: bytes32
                     Source: "id"
        Block
           Source: "{\r\n                        \r\n           // send ether              \r\n           bool success = proposals[id].submitter.send(proposals[id].value); \r\n\r\n           // rise event\r\n           EtherRedeemAccepted(proposals[id].submitter, proposals[id].value);                              \r\n        }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "bool success = proposals[id].submitter.send(proposals[id].value)"
            VariableDeclaration "success"
               Type: bool
               Source: "bool success"
              ElementaryTypeName bool
                 Source: "bool"
            FunctionCall
               Type: bool
               Source: "proposals[id].submitter.send(proposals[id].value)"
              MemberAccess to member send
                 Type: function (uint256) returns (bool)
                 Source: "proposals[id].submitter.send"
                MemberAccess to member submitter
                   Type: address
                   Source: "proposals[id].submitter"
                  IndexAccess
                     Type: struct DSTContract.Proposal storage ref
                     Source: "proposals[id]"
                    Identifier proposals
                       Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                       Source: "proposals"
                    Identifier id
                       Type: bytes32
                       Source: "id"
              MemberAccess to member value
                 Type: uint256
                 Source: "proposals[id].value"
                IndexAccess
                   Type: struct DSTContract.Proposal storage ref
                   Source: "proposals[id]"
                  Identifier proposals
                     Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                     Source: "proposals"
                  Identifier id
                     Type: bytes32
                     Source: "id"
          ExpressionStatement
             Gas costs: 0
             Source: "EtherRedeemAccepted(proposals[id].submitter, proposals[id].value)"
            FunctionCall
               Type: tuple()
               Source: "EtherRedeemAccepted(proposals[id].submitter, proposals[id].value)"
              Identifier EtherRedeemAccepted
                 Type: function (address,uint256)
                 Source: "EtherRedeemAccepted"
              MemberAccess to member submitter
                 Type: address
                 Source: "proposals[id].submitter"
                IndexAccess
                   Type: struct DSTContract.Proposal storage ref
                   Source: "proposals[id]"
                  Identifier proposals
                     Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                     Source: "proposals"
                  Identifier id
                     Type: bytes32
                     Source: "id"
              MemberAccess to member value
                 Type: uint256
                 Source: "proposals[id].value"
                IndexAccess
                   Type: struct DSTContract.Proposal storage ref
                   Source: "proposals[id]"
                  Identifier proposals
                     Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                     Source: "proposals"
                  Identifier id
                     Type: bytes32
                     Source: "id"
      ExpressionStatement
         Gas costs: 0
         Source: "proposals[id].redeemed = true"
        Assignment using operator =
           Type: bool
           Source: "proposals[id].redeemed = true"
          MemberAccess to member redeemed
             Type: bool
             Source: "proposals[id].redeemed"
            IndexAccess
               Type: struct DSTContract.Proposal storage ref
               Source: "proposals[id]"
              Identifier proposals
                 Type: mapping(bytes32 => struct DSTContract.Proposal storage ref)
                 Source: "proposals"
              Identifier id
                 Type: bytes32
                 Source: "id"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "getAllTheFunds" - public
     Source: "function getAllTheFunds() onlyExecutive {\r\n        \r\n        // If there is a deadlock in voting participates\r\n        // the funds can be redeemed completelly in 6 months\r\n        if (now < (eventInfo.getEventEnd() + 24 weeks)) {\r\n            throw;\r\n        }  \r\n        \r\n        // all the Ether\r\n        bool success = msg.sender.send(this.balance);        \r\n        \r\n        // all the HKG\r\n        hackerGold.transfer(msg.sender, getHKGOwned());              \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyExecutive"
       Gas costs: 0
       Source: "onlyExecutive"
      Identifier onlyExecutive
         Type: modifier ()
         Source: "onlyExecutive"
    Block
       Source: "{\r\n        \r\n        // If there is a deadlock in voting participates\r\n        // the funds can be redeemed completelly in 6 months\r\n        if (now < (eventInfo.getEventEnd() + 24 weeks)) {\r\n            throw;\r\n        }  \r\n        \r\n        // all the Ether\r\n        bool success = msg.sender.send(this.balance);        \r\n        \r\n        // all the HKG\r\n        hackerGold.transfer(msg.sender, getHKGOwned());              \r\n    }"
      IfStatement
         Source: "if (now < (eventInfo.getEventEnd() + 24 weeks)) {\r\n            throw;\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "now < (eventInfo.getEventEnd() + 24 weeks)"
          Identifier now
             Type: uint256
             Source: "now"
          TupleExpression
             Type: uint256
             Source: "(eventInfo.getEventEnd() + 24 weeks)"
            BinaryOperation using operator +
               Type: uint256
               Source: "eventInfo.getEventEnd() + 24 weeks"
              FunctionCall
                 Type: uint256
                 Source: "eventInfo.getEventEnd()"
                MemberAccess to member getEventEnd
                   Type: function () view external returns (uint256)
                   Source: "eventInfo.getEventEnd"
                  Identifier eventInfo
                     Type: contract EventInfo
                     Source: "eventInfo"
              Literal, token: [no token] value: 24
                 Type: int_const 14515200
                 Source: "24 weeks"
        Block
           Source: "{\r\n            throw;\r\n        }"
          Throw
             Gas costs: 0
             Source: "throw"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bool success = msg.sender.send(this.balance)"
        VariableDeclaration "success"
           Type: bool
           Source: "bool success"
          ElementaryTypeName bool
             Source: "bool"
        FunctionCall
           Type: bool
           Source: "msg.sender.send(this.balance)"
          MemberAccess to member send
             Type: function (uint256) returns (bool)
             Source: "msg.sender.send"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract DSTContract
               Source: "this"
      ExpressionStatement
         Gas costs: 0
         Source: "hackerGold.transfer(msg.sender, getHKGOwned())"
        FunctionCall
           Type: bool
           Source: "hackerGold.transfer(msg.sender, getHKGOwned())"
          MemberAccess to member transfer
             Type: function (address,uint256) external returns (bool)
             Source: "hackerGold.transfer"
            Identifier hackerGold
               Type: contract HackerGold
               Source: "hackerGold"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          FunctionCall
             Type: uint256
             Source: "getHKGOwned()"
            Identifier getHKGOwned
               Type: function () view returns (uint256)
               Source: "getHKGOwned"
  FunctionDefinition "submitImpeachmentProposal" - public
     Source: "function submitImpeachmentProposal(string urlDetails, address newExecutive){\r\n         \r\n        // to offer impeachment you should have \r\n        // voting rights\r\n        if (votingRights[msg.sender] == 0) throw;\r\n         \r\n        // the submission of the first impeachment \r\n        // proposal is possible only after 3 months\r\n        // since the hackathon is over\r\n        if (now < (eventInfo.getEventEnd() + 12 weeks)) throw;\r\n        \r\n                \r\n        // check there is 1 months over since last one\r\n        if (lastImpeachmentProposal.votindEndTS != 0 && \r\n            lastImpeachmentProposal.votindEndTS +  2 weeks > now) throw;\r\n\r\n\r\n        // submit impeachment proposal\r\n        // add the votes of the submitter \r\n        // to the proposal right away\r\n        lastImpeachmentProposal = ImpeachmentProposal(urlDetails, newExecutive, now + 2 weeks, votingRights[msg.sender]);\r\n        lastImpeachmentProposal.voted[msg.sender] = true;\r\n         \r\n        // rise event\r\n        ImpeachmentProposed(msg.sender, urlDetails, now + 2 weeks, newExecutive);\r\n     }"
    ParameterList
       Gas costs: 0
       Source: "(string urlDetails, address newExecutive)"
      VariableDeclaration "urlDetails"
         Type: string memory
         Source: "string urlDetails"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "newExecutive"
         Type: address
         Source: "address newExecutive"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n         \r\n        // to offer impeachment you should have \r\n        // voting rights\r\n        if (votingRights[msg.sender] == 0) throw;\r\n         \r\n        // the submission of the first impeachment \r\n        // proposal is possible only after 3 months\r\n        // since the hackathon is over\r\n        if (now < (eventInfo.getEventEnd() + 12 weeks)) throw;\r\n        \r\n                \r\n        // check there is 1 months over since last one\r\n        if (lastImpeachmentProposal.votindEndTS != 0 && \r\n            lastImpeachmentProposal.votindEndTS +  2 weeks > now) throw;\r\n\r\n\r\n        // submit impeachment proposal\r\n        // add the votes of the submitter \r\n        // to the proposal right away\r\n        lastImpeachmentProposal = ImpeachmentProposal(urlDetails, newExecutive, now + 2 weeks, votingRights[msg.sender]);\r\n        lastImpeachmentProposal.voted[msg.sender] = true;\r\n         \r\n        // rise event\r\n        ImpeachmentProposed(msg.sender, urlDetails, now + 2 weeks, newExecutive);\r\n     }"
      IfStatement
         Source: "if (votingRights[msg.sender] == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "votingRights[msg.sender] == 0"
          IndexAccess
             Type: uint256
             Source: "votingRights[msg.sender]"
            Identifier votingRights
               Type: mapping(address => uint256)
               Source: "votingRights"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (now < (eventInfo.getEventEnd() + 12 weeks)) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "now < (eventInfo.getEventEnd() + 12 weeks)"
          Identifier now
             Type: uint256
             Source: "now"
          TupleExpression
             Type: uint256
             Source: "(eventInfo.getEventEnd() + 12 weeks)"
            BinaryOperation using operator +
               Type: uint256
               Source: "eventInfo.getEventEnd() + 12 weeks"
              FunctionCall
                 Type: uint256
                 Source: "eventInfo.getEventEnd()"
                MemberAccess to member getEventEnd
                   Type: function () view external returns (uint256)
                   Source: "eventInfo.getEventEnd"
                  Identifier eventInfo
                     Type: contract EventInfo
                     Source: "eventInfo"
              Literal, token: [no token] value: 12
                 Type: int_const 7257600
                 Source: "12 weeks"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (lastImpeachmentProposal.votindEndTS != 0 && \r\n            lastImpeachmentProposal.votindEndTS +  2 weeks > now) throw"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "lastImpeachmentProposal.votindEndTS != 0 && \r\n            lastImpeachmentProposal.votindEndTS +  2 weeks > now"
          BinaryOperation using operator !=
             Type: bool
             Source: "lastImpeachmentProposal.votindEndTS != 0"
            MemberAccess to member votindEndTS
               Type: uint256
               Source: "lastImpeachmentProposal.votindEndTS"
              Identifier lastImpeachmentProposal
                 Type: struct DSTContract.ImpeachmentProposal storage ref
                 Source: "lastImpeachmentProposal"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator >
             Type: bool
             Source: "lastImpeachmentProposal.votindEndTS +  2 weeks > now"
            BinaryOperation using operator +
               Type: uint256
               Source: "lastImpeachmentProposal.votindEndTS +  2 weeks"
              MemberAccess to member votindEndTS
                 Type: uint256
                 Source: "lastImpeachmentProposal.votindEndTS"
                Identifier lastImpeachmentProposal
                   Type: struct DSTContract.ImpeachmentProposal storage ref
                   Source: "lastImpeachmentProposal"
              Literal, token: [no token] value: 2
                 Type: int_const 1209600
                 Source: "2 weeks"
            Identifier now
               Type: uint256
               Source: "now"
        Throw
           Gas costs: 0
           Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "lastImpeachmentProposal = ImpeachmentProposal(urlDetails, newExecutive, now + 2 weeks, votingRights[msg.sender])"
        Assignment using operator =
           Type: struct DSTContract.ImpeachmentProposal storage ref
           Source: "lastImpeachmentProposal = ImpeachmentProposal(urlDetails, newExecutive, now + 2 weeks, votingRights[msg.sender])"
          Identifier lastImpeachmentProposal
             Type: struct DSTContract.ImpeachmentProposal storage ref
             Source: "lastImpeachmentProposal"
          FunctionCall
             Type: struct DSTContract.ImpeachmentProposal memory
             Source: "ImpeachmentProposal(urlDetails, newExecutive, now + 2 weeks, votingRights[msg.sender])"
            Identifier ImpeachmentProposal
               Type: type(struct DSTContract.ImpeachmentProposal storage pointer)
               Source: "ImpeachmentProposal"
            Identifier urlDetails
               Type: string memory
               Source: "urlDetails"
            Identifier newExecutive
               Type: address
               Source: "newExecutive"
            BinaryOperation using operator +
               Type: uint256
               Source: "now + 2 weeks"
              Identifier now
                 Type: uint256
                 Source: "now"
              Literal, token: [no token] value: 2
                 Type: int_const 1209600
                 Source: "2 weeks"
            IndexAccess
               Type: uint256
               Source: "votingRights[msg.sender]"
              Identifier votingRights
                 Type: mapping(address => uint256)
                 Source: "votingRights"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "lastImpeachmentProposal.voted[msg.sender] = true"
        Assignment using operator =
           Type: bool
           Source: "lastImpeachmentProposal.voted[msg.sender] = true"
          IndexAccess
             Type: bool
             Source: "lastImpeachmentProposal.voted[msg.sender]"
            MemberAccess to member voted
               Type: mapping(address => bool)
               Source: "lastImpeachmentProposal.voted"
              Identifier lastImpeachmentProposal
                 Type: struct DSTContract.ImpeachmentProposal storage ref
                 Source: "lastImpeachmentProposal"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "ImpeachmentProposed(msg.sender, urlDetails, now + 2 weeks, newExecutive)"
        FunctionCall
           Type: tuple()
           Source: "ImpeachmentProposed(msg.sender, urlDetails, now + 2 weeks, newExecutive)"
          Identifier ImpeachmentProposed
             Type: function (address,string memory,uint256,address)
             Source: "ImpeachmentProposed"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier urlDetails
             Type: string memory
             Source: "urlDetails"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + 2 weeks"
            Identifier now
               Type: uint256
               Source: "now"
            Literal, token: [no token] value: 2
               Type: int_const 1209600
               Source: "2 weeks"
          Identifier newExecutive
             Type: address
             Source: "newExecutive"
  FunctionDefinition "supportImpeachment" - public
     Source: "function supportImpeachment(){\r\n\r\n        // ensure that support is for exist proposal \r\n        if (lastImpeachmentProposal.newExecutive == 0x0) throw;\r\n    \r\n        // to offer impeachment you should have \r\n        // voting rights\r\n        if (votingRights[msg.sender] == 0) throw;\r\n        \r\n        // check if not voted already \r\n        if (lastImpeachmentProposal.voted[msg.sender]) throw;\r\n        \r\n        // check if not finished the 2 weeks of voting \r\n        if (lastImpeachmentProposal.votindEndTS + 2 weeks <= now) throw;\r\n                \r\n        // support the impeachment\r\n        lastImpeachmentProposal.voted[msg.sender] = true;\r\n        lastImpeachmentProposal.votesSupporting += votingRights[msg.sender];\r\n\r\n        // rise impeachment suppporting event\r\n        ImpeachmentSupport(msg.sender, votingRights[msg.sender]);\r\n        \r\n        // if the vote is over 70% execute the switch \r\n        uint percent = preferedQtySold / 100; \r\n        \r\n        if (lastImpeachmentProposal.votesSupporting >= 70 * percent){\r\n            executive = lastImpeachmentProposal.newExecutive;\r\n            \r\n            // impeachment event\r\n            ImpeachmentAccepted(executive);\r\n        }\r\n        \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\r\n        // ensure that support is for exist proposal \r\n        if (lastImpeachmentProposal.newExecutive == 0x0) throw;\r\n    \r\n        // to offer impeachment you should have \r\n        // voting rights\r\n        if (votingRights[msg.sender] == 0) throw;\r\n        \r\n        // check if not voted already \r\n        if (lastImpeachmentProposal.voted[msg.sender]) throw;\r\n        \r\n        // check if not finished the 2 weeks of voting \r\n        if (lastImpeachmentProposal.votindEndTS + 2 weeks <= now) throw;\r\n                \r\n        // support the impeachment\r\n        lastImpeachmentProposal.voted[msg.sender] = true;\r\n        lastImpeachmentProposal.votesSupporting += votingRights[msg.sender];\r\n\r\n        // rise impeachment suppporting event\r\n        ImpeachmentSupport(msg.sender, votingRights[msg.sender]);\r\n        \r\n        // if the vote is over 70% execute the switch \r\n        uint percent = preferedQtySold / 100; \r\n        \r\n        if (lastImpeachmentProposal.votesSupporting >= 70 * percent){\r\n            executive = lastImpeachmentProposal.newExecutive;\r\n            \r\n            // impeachment event\r\n            ImpeachmentAccepted(executive);\r\n        }\r\n        \r\n    }"
      IfStatement
         Source: "if (lastImpeachmentProposal.newExecutive == 0x0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "lastImpeachmentProposal.newExecutive == 0x0"
          MemberAccess to member newExecutive
             Type: address
             Source: "lastImpeachmentProposal.newExecutive"
            Identifier lastImpeachmentProposal
               Type: struct DSTContract.ImpeachmentProposal storage ref
               Source: "lastImpeachmentProposal"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (votingRights[msg.sender] == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "votingRights[msg.sender] == 0"
          IndexAccess
             Type: uint256
             Source: "votingRights[msg.sender]"
            Identifier votingRights
               Type: mapping(address => uint256)
               Source: "votingRights"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (lastImpeachmentProposal.voted[msg.sender]) throw"
        IndexAccess
           Type: bool
           Gas costs: 0
           Source: "lastImpeachmentProposal.voted[msg.sender]"
          MemberAccess to member voted
             Type: mapping(address => bool)
             Source: "lastImpeachmentProposal.voted"
            Identifier lastImpeachmentProposal
               Type: struct DSTContract.ImpeachmentProposal storage ref
               Source: "lastImpeachmentProposal"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
        Throw
           Gas costs: 0
           Source: "throw"
      IfStatement
         Source: "if (lastImpeachmentProposal.votindEndTS + 2 weeks <= now) throw"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 0
           Source: "lastImpeachmentProposal.votindEndTS + 2 weeks <= now"
          BinaryOperation using operator +
             Type: uint256
             Source: "lastImpeachmentProposal.votindEndTS + 2 weeks"
            MemberAccess to member votindEndTS
               Type: uint256
               Source: "lastImpeachmentProposal.votindEndTS"
              Identifier lastImpeachmentProposal
                 Type: struct DSTContract.ImpeachmentProposal storage ref
                 Source: "lastImpeachmentProposal"
            Literal, token: [no token] value: 2
               Type: int_const 1209600
               Source: "2 weeks"
          Identifier now
             Type: uint256
             Source: "now"
        Throw
           Gas costs: 0
           Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "lastImpeachmentProposal.voted[msg.sender] = true"
        Assignment using operator =
           Type: bool
           Source: "lastImpeachmentProposal.voted[msg.sender] = true"
          IndexAccess
             Type: bool
             Source: "lastImpeachmentProposal.voted[msg.sender]"
            MemberAccess to member voted
               Type: mapping(address => bool)
               Source: "lastImpeachmentProposal.voted"
              Identifier lastImpeachmentProposal
                 Type: struct DSTContract.ImpeachmentProposal storage ref
                 Source: "lastImpeachmentProposal"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "lastImpeachmentProposal.votesSupporting += votingRights[msg.sender]"
        Assignment using operator +=
           Type: uint256
           Source: "lastImpeachmentProposal.votesSupporting += votingRights[msg.sender]"
          MemberAccess to member votesSupporting
             Type: uint256
             Source: "lastImpeachmentProposal.votesSupporting"
            Identifier lastImpeachmentProposal
               Type: struct DSTContract.ImpeachmentProposal storage ref
               Source: "lastImpeachmentProposal"
          IndexAccess
             Type: uint256
             Source: "votingRights[msg.sender]"
            Identifier votingRights
               Type: mapping(address => uint256)
               Source: "votingRights"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "ImpeachmentSupport(msg.sender, votingRights[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "ImpeachmentSupport(msg.sender, votingRights[msg.sender])"
          Identifier ImpeachmentSupport
             Type: function (address,uint256)
             Source: "ImpeachmentSupport"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          IndexAccess
             Type: uint256
             Source: "votingRights[msg.sender]"
            Identifier votingRights
               Type: mapping(address => uint256)
               Source: "votingRights"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint percent = preferedQtySold / 100"
        VariableDeclaration "percent"
           Type: uint256
           Source: "uint percent"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "preferedQtySold / 100"
          Identifier preferedQtySold
             Type: uint256
             Source: "preferedQtySold"
          Literal, token: [no token] value: 100
             Type: int_const 100
             Source: "100"
      IfStatement
         Source: "if (lastImpeachmentProposal.votesSupporting >= 70 * percent){\r\n            executive = lastImpeachmentProposal.newExecutive;\r\n            \r\n            // impeachment event\r\n            ImpeachmentAccepted(executive);\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 0
           Source: "lastImpeachmentProposal.votesSupporting >= 70 * percent"
          MemberAccess to member votesSupporting
             Type: uint256
             Source: "lastImpeachmentProposal.votesSupporting"
            Identifier lastImpeachmentProposal
               Type: struct DSTContract.ImpeachmentProposal storage ref
               Source: "lastImpeachmentProposal"
          BinaryOperation using operator *
             Type: uint256
             Source: "70 * percent"
            Literal, token: [no token] value: 70
               Type: int_const 70
               Source: "70"
            Identifier percent
               Type: uint256
               Source: "percent"
        Block
           Source: "{\r\n            executive = lastImpeachmentProposal.newExecutive;\r\n            \r\n            // impeachment event\r\n            ImpeachmentAccepted(executive);\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "executive = lastImpeachmentProposal.newExecutive"
            Assignment using operator =
               Type: address
               Source: "executive = lastImpeachmentProposal.newExecutive"
              Identifier executive
                 Type: address
                 Source: "executive"
              MemberAccess to member newExecutive
                 Type: address
                 Source: "lastImpeachmentProposal.newExecutive"
                Identifier lastImpeachmentProposal
                   Type: struct DSTContract.ImpeachmentProposal storage ref
                   Source: "lastImpeachmentProposal"
          ExpressionStatement
             Gas costs: 0
             Source: "ImpeachmentAccepted(executive)"
            FunctionCall
               Type: tuple()
               Source: "ImpeachmentAccepted(executive)"
              Identifier ImpeachmentAccepted
                 Type: function (address)
                 Source: "ImpeachmentAccepted"
              Identifier executive
                 Type: address
                 Source: "executive"
  FunctionDefinition "votingRightsOf" - public - const
     Source: "function votingRightsOf(address _owner) constant returns (uint256 result) {\r\n        result = votingRights[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint256 result"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        result = votingRights[_owner];\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "result = votingRights[_owner]"
        Assignment using operator =
           Type: uint256
           Source: "result = votingRights[_owner]"
          Identifier result
             Type: uint256
             Source: "result"
          IndexAccess
             Type: uint256
             Source: "votingRights[_owner]"
            Identifier votingRights
               Type: mapping(address => uint256)
               Source: "votingRights"
            Identifier _owner
               Type: address
               Source: "_owner"
  FunctionDefinition "getPreferedQtySold" - public - const
     Source: "function getPreferedQtySold() constant returns (uint result){\r\n        return preferedQtySold;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return preferedQtySold;\r\n    }"
      Return
         Gas costs: 0
         Source: "return preferedQtySold"
        Identifier preferedQtySold
           Type: uint256
           Source: "preferedQtySold"
  FunctionDefinition "setVirtualExchange" - public
     Source: "function setVirtualExchange(address virtualExchangeAddr){\r\n        if (virtualExchangeAddress != 0x0) throw;\r\n        virtualExchangeAddress = virtualExchangeAddr;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address virtualExchangeAddr)"
      VariableDeclaration "virtualExchangeAddr"
         Type: address
         Source: "address virtualExchangeAddr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (virtualExchangeAddress != 0x0) throw;\r\n        virtualExchangeAddress = virtualExchangeAddr;\r\n    }"
      IfStatement
         Source: "if (virtualExchangeAddress != 0x0) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "virtualExchangeAddress != 0x0"
          Identifier virtualExchangeAddress
             Type: address
             Source: "virtualExchangeAddress"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
        Throw
           Gas costs: 0
           Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "virtualExchangeAddress = virtualExchangeAddr"
        Assignment using operator =
           Type: address
           Source: "virtualExchangeAddress = virtualExchangeAddr"
          Identifier virtualExchangeAddress
             Type: address
             Source: "virtualExchangeAddress"
          Identifier virtualExchangeAddr
             Type: address
             Source: "virtualExchangeAddr"
  FunctionDefinition "getHKGOwned" - public - const
     Source: "function getHKGOwned() constant returns (uint result){\r\n        return hackerGold.balanceOf(this);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return hackerGold.balanceOf(this);\r\n    }"
      Return
         Gas costs: 0
         Source: "return hackerGold.balanceOf(this)"
        FunctionCall
           Type: uint256
           Source: "hackerGold.balanceOf(this)"
          MemberAccess to member balanceOf
             Type: function (address) view external returns (uint256)
             Source: "hackerGold.balanceOf"
            Identifier hackerGold
               Type: contract HackerGold
               Source: "hackerGold"
          Identifier this
             Type: contract DSTContract
             Source: "this"
  FunctionDefinition "getEtherValue" - public - const
     Source: "function getEtherValue() constant returns (uint result){\r\n        return this.balance;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return this.balance;\r\n    }"
      Return
         Gas costs: 0
         Source: "return this.balance"
        MemberAccess to member balance
           Type: uint256
           Source: "this.balance"
          Identifier this
             Type: contract DSTContract
             Source: "this"
  FunctionDefinition "getExecutive" - public - const
     Source: "function getExecutive() constant returns (address result){\r\n        return executive;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address result)"
      VariableDeclaration "result"
         Type: address
         Source: "address result"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return executive;\r\n    }"
      Return
         Gas costs: 0
         Source: "return executive"
        Identifier executive
           Type: address
           Source: "executive"
  FunctionDefinition "getHKGPrice" - public - const
     Source: "function getHKGPrice() constant returns (uint result){\r\n        return hkgPrice;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return hkgPrice;\r\n    }"
      Return
         Gas costs: 0
         Source: "return hkgPrice"
        Identifier hkgPrice
           Type: uint256
           Source: "hkgPrice"
  FunctionDefinition "getEtherPrice" - public - const
     Source: "function getEtherPrice() constant returns (uint result){\r\n        return etherPrice;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return etherPrice;\r\n    }"
      Return
         Gas costs: 0
         Source: "return etherPrice"
        Identifier etherPrice
           Type: uint256
           Source: "etherPrice"
  FunctionDefinition "getDSTName" - public - const
     Source: "function getDSTName() constant returns(string result){\r\n        return name;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(string result)"
      VariableDeclaration "result"
         Type: string memory
         Source: "string result"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n        return name;\r\n    }"
      Return
         Gas costs: 0
         Source: "return name"
        Identifier name
           Type: string storage ref
           Source: "name"
  FunctionDefinition "getDSTNameBytes" - public - const
     Source: "function getDSTNameBytes() constant returns(bytes32 result){\r\n        return convert(name);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 result)"
      VariableDeclaration "result"
         Type: bytes32
         Source: "bytes32 result"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        return convert(name);\r\n    }"
      Return
         Gas costs: 0
         Source: "return convert(name)"
        FunctionCall
           Type: bytes32
           Source: "convert(name)"
          Identifier convert
             Type: function (string memory) returns (bytes32)
             Source: "convert"
          Identifier name
             Type: string storage ref
             Source: "name"
  FunctionDefinition "getDSTSymbol" - public - const
     Source: "function getDSTSymbol() constant returns(string result){\r\n        return symbol;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(string result)"
      VariableDeclaration "result"
         Type: string memory
         Source: "string result"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n        return symbol;\r\n    }"
      Return
         Gas costs: 0
         Source: "return symbol"
        Identifier symbol
           Type: string storage ref
           Source: "symbol"
  FunctionDefinition "getDSTSymbolBytes" - public - const
     Source: "function getDSTSymbolBytes() constant returns(bytes32 result){\r\n        return convert(symbol);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 result)"
      VariableDeclaration "result"
         Type: bytes32
         Source: "bytes32 result"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        return convert(symbol);\r\n    }"
      Return
         Gas costs: 0
         Source: "return convert(symbol)"
        FunctionCall
           Type: bytes32
           Source: "convert(symbol)"
          Identifier convert
             Type: function (string memory) returns (bytes32)
             Source: "convert"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
  FunctionDefinition "getAddress" - public - const
     Source: "function getAddress() constant returns (address result) {\r\n        return this;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(address result)"
      VariableDeclaration "result"
         Type: address
         Source: "address result"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        return this;\r\n    }"
      Return
         Gas costs: 0
         Source: "return this"
        Identifier this
           Type: contract DSTContract
           Source: "this"
  FunctionDefinition "getTotalSupply" - public - const
     Source: "function getTotalSupply() constant returns (uint result) {\r\n        return totalSupply;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return totalSupply;\r\n    }"
      Return
         Gas costs: 0
         Source: "return totalSupply"
        Identifier totalSupply
           Type: uint256
           Source: "totalSupply"
  FunctionDefinition "getCollectedEther" - public - const
     Source: "function getCollectedEther() constant returns (uint results) {        \r\n        return collectedEther;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint results)"
      VariableDeclaration "results"
         Type: uint256
         Source: "uint results"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{        \r\n        return collectedEther;\r\n    }"
      Return
         Gas costs: 0
         Source: "return collectedEther"
        Identifier collectedEther
           Type: uint256
           Source: "collectedEther"
  FunctionDefinition "getCounterProposals" - public - const
     Source: "function getCounterProposals() constant returns (uint result){\r\n        return counterProposals;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return counterProposals;\r\n    }"
      Return
         Gas costs: 0
         Source: "return counterProposals"
        Identifier counterProposals
           Type: uint256
           Source: "counterProposals"
  FunctionDefinition "getProposalIdByIndex" - public - const
     Source: "function getProposalIdByIndex(uint i) constant returns (bytes32 result){\r\n        return listProposals[i].id;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint i)"
      VariableDeclaration "i"
         Type: uint256
         Source: "uint i"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 result)"
      VariableDeclaration "result"
         Type: bytes32
         Source: "bytes32 result"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n        return listProposals[i].id;\r\n    }"
      Return
         Gas costs: 0
         Source: "return listProposals[i].id"
        MemberAccess to member id
           Type: bytes32
           Source: "listProposals[i].id"
          IndexAccess
             Type: struct DSTContract.Proposal storage ref
             Source: "listProposals[i]"
            Identifier listProposals
               Type: struct DSTContract.Proposal storage ref[] storage ref
               Source: "listProposals"
            Identifier i
               Type: uint256
               Source: "i"
  FunctionDefinition "getProposalObjectionByIndex" - public - const
     Source: "function getProposalObjectionByIndex(uint i) constant returns (uint result){\r\n        return listProposals[i].votesObjecting;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint i)"
      VariableDeclaration "i"
         Type: uint256
         Source: "uint i"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return listProposals[i].votesObjecting;\r\n    }"
      Return
         Gas costs: 0
         Source: "return listProposals[i].votesObjecting"
        MemberAccess to member votesObjecting
           Type: uint256
           Source: "listProposals[i].votesObjecting"
          IndexAccess
             Type: struct DSTContract.Proposal storage ref
             Source: "listProposals[i]"
            Identifier listProposals
               Type: struct DSTContract.Proposal storage ref[] storage ref
               Source: "listProposals"
            Identifier i
               Type: uint256
               Source: "i"
  FunctionDefinition "getProposalValueByIndex" - public - const
     Source: "function getProposalValueByIndex(uint i) constant returns (uint result){\r\n        return listProposals[i].value;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint i)"
      VariableDeclaration "i"
         Type: uint256
         Source: "uint i"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return listProposals[i].value;\r\n    }"
      Return
         Gas costs: 0
         Source: "return listProposals[i].value"
        MemberAccess to member value
           Type: uint256
           Source: "listProposals[i].value"
          IndexAccess
             Type: struct DSTContract.Proposal storage ref
             Source: "listProposals[i]"
            Identifier listProposals
               Type: struct DSTContract.Proposal storage ref[] storage ref
               Source: "listProposals"
            Identifier i
               Type: uint256
               Source: "i"
  FunctionDefinition "getCurrentImpeachmentUrlDetails" - public - const
     Source: "function getCurrentImpeachmentUrlDetails() constant returns (string result){\r\n        return lastImpeachmentProposal.urlDetails;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(string result)"
      VariableDeclaration "result"
         Type: string memory
         Source: "string result"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n        return lastImpeachmentProposal.urlDetails;\r\n    }"
      Return
         Gas costs: 0
         Source: "return lastImpeachmentProposal.urlDetails"
        MemberAccess to member urlDetails
           Type: string storage ref
           Source: "lastImpeachmentProposal.urlDetails"
          Identifier lastImpeachmentProposal
             Type: struct DSTContract.ImpeachmentProposal storage ref
             Source: "lastImpeachmentProposal"
  FunctionDefinition "getCurrentImpeachmentVotesSupporting" - public - const
     Source: "function getCurrentImpeachmentVotesSupporting() constant returns (uint result){\r\n        return lastImpeachmentProposal.votesSupporting;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return lastImpeachmentProposal.votesSupporting;\r\n    }"
      Return
         Gas costs: 0
         Source: "return lastImpeachmentProposal.votesSupporting"
        MemberAccess to member votesSupporting
           Type: uint256
           Source: "lastImpeachmentProposal.votesSupporting"
          Identifier lastImpeachmentProposal
             Type: struct DSTContract.ImpeachmentProposal storage ref
             Source: "lastImpeachmentProposal"
  FunctionDefinition "convert" - public
     Source: "function convert(string key) returns (bytes32 ret) {\r\n            if (bytes(key).length > 32) {\r\n                throw;\r\n            }      \r\n\r\n            assembly {\r\n                ret := mload(add(key, 32))\r\n            }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string key)"
      VariableDeclaration "key"
         Type: string memory
         Source: "string key"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 ret)"
      VariableDeclaration "ret"
         Type: bytes32
         Source: "bytes32 ret"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n            if (bytes(key).length > 32) {\r\n                throw;\r\n            }      \r\n\r\n            assembly {\r\n                ret := mload(add(key, 32))\r\n            }\r\n    }"
      IfStatement
         Source: "if (bytes(key).length > 32) {\r\n                throw;\r\n            }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "bytes(key).length > 32"
          MemberAccess to member length
             Type: uint256
             Source: "bytes(key).length"
            FunctionCall
               Type: bytes memory
               Source: "bytes(key)"
              ElementaryTypeNameExpression bytes
                 Type: type(bytes storage pointer)
                 Source: "bytes"
              Identifier key
                 Type: string memory
                 Source: "key"
          Literal, token: [no token] value: 32
             Type: int_const 32
             Source: "32"
        Block
           Source: "{\r\n                throw;\r\n            }"
          Throw
             Gas costs: 0
             Source: "throw"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {\r\n                ret := mload(add(key, 32))\r\n            }\r\n    }"
  ModifierDefinition "onlyBeforeEnd"
     Source: "modifier onlyBeforeEnd() { if (now  >=  eventInfo.getEventEnd()) throw; _; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ if (now  >=  eventInfo.getEventEnd()) throw; _; }"
      IfStatement
         Source: "if (now  >=  eventInfo.getEventEnd()) throw"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 0
           Source: "now  >=  eventInfo.getEventEnd()"
          Identifier now
             Type: uint256
             Source: "now"
          FunctionCall
             Type: uint256
             Source: "eventInfo.getEventEnd()"
            MemberAccess to member getEventEnd
               Type: function () view external returns (uint256)
               Source: "eventInfo.getEventEnd"
              Identifier eventInfo
                 Type: contract EventInfo
                 Source: "eventInfo"
        Throw
           Gas costs: 0
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyAfterEnd"
     Source: "modifier onlyAfterEnd()  { if (now  <   eventInfo.getEventEnd()) throw; _; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ if (now  <   eventInfo.getEventEnd()) throw; _; }"
      IfStatement
         Source: "if (now  <   eventInfo.getEventEnd()) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "now  <   eventInfo.getEventEnd()"
          Identifier now
             Type: uint256
             Source: "now"
          FunctionCall
             Type: uint256
             Source: "eventInfo.getEventEnd()"
            MemberAccess to member getEventEnd
               Type: function () view external returns (uint256)
               Source: "eventInfo.getEventEnd"
              Identifier eventInfo
                 Type: contract EventInfo
                 Source: "eventInfo"
        Throw
           Gas costs: 0
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyAfterTradingStart"
     Source: "modifier onlyAfterTradingStart()  { if (now  < eventInfo.getTradingStart()) throw; _; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ if (now  < eventInfo.getTradingStart()) throw; _; }"
      IfStatement
         Source: "if (now  < eventInfo.getTradingStart()) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "now  < eventInfo.getTradingStart()"
          Identifier now
             Type: uint256
             Source: "now"
          FunctionCall
             Type: uint256
             Source: "eventInfo.getTradingStart()"
            MemberAccess to member getTradingStart
               Type: function () view external returns (uint256)
               Source: "eventInfo.getTradingStart"
              Identifier eventInfo
                 Type: contract EventInfo
                 Source: "eventInfo"
        Throw
           Gas costs: 0
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyExecutive"
     Source: "modifier onlyExecutive()     { if (msg.sender != executive) throw; _; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ if (msg.sender != executive) throw; _; }"
      IfStatement
         Source: "if (msg.sender != executive) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "msg.sender != executive"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier executive
             Type: address
             Source: "executive"
        Throw
           Gas costs: 0
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyIfAbleToIssueTokens"
     Source: "modifier onlyIfAbleToIssueTokens()  { if (!ableToIssueTokens) throw; _; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ if (!ableToIssueTokens) throw; _; }"
      IfStatement
         Source: "if (!ableToIssueTokens) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 0
           Source: "!ableToIssueTokens"
          Identifier ableToIssueTokens
             Type: bool
             Source: "ableToIssueTokens"
        Throw
           Gas costs: 0
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  EventDefinition "PriceHKGChange"
     Gas costs: 0
     Source: "event PriceHKGChange(uint indexed qtyForOneHKG, uint indexed tokensSold, uint indexed totalSupply);"
    ParameterList
       Source: "(uint indexed qtyForOneHKG, uint indexed tokensSold, uint indexed totalSupply)"
      VariableDeclaration "qtyForOneHKG"
         Type: uint256
         Source: "uint indexed qtyForOneHKG"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "tokensSold"
         Type: uint256
         Source: "uint indexed tokensSold"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "totalSupply"
         Type: uint256
         Source: "uint indexed totalSupply"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "BuyForHKGTransaction"
     Gas costs: 0
     Source: "event BuyForHKGTransaction(address indexed buyer, uint indexed tokensSold, uint indexed totalSupply, uint qtyForOneHKG, uint tokensAmount);"
    ParameterList
       Source: "(address indexed buyer, uint indexed tokensSold, uint indexed totalSupply, uint qtyForOneHKG, uint tokensAmount)"
      VariableDeclaration "buyer"
         Type: address
         Source: "address indexed buyer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "tokensSold"
         Type: uint256
         Source: "uint indexed tokensSold"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "totalSupply"
         Type: uint256
         Source: "uint indexed totalSupply"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "qtyForOneHKG"
         Type: uint256
         Source: "uint qtyForOneHKG"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "tokensAmount"
         Type: uint256
         Source: "uint tokensAmount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "BuyForEtherTransaction"
     Gas costs: 0
     Source: "event BuyForEtherTransaction(address indexed buyer, uint indexed tokensSold, uint indexed totalSupply, uint qtyForOneEther, uint tokensAmount);"
    ParameterList
       Source: "(address indexed buyer, uint indexed tokensSold, uint indexed totalSupply, uint qtyForOneEther, uint tokensAmount)"
      VariableDeclaration "buyer"
         Type: address
         Source: "address indexed buyer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "tokensSold"
         Type: uint256
         Source: "uint indexed tokensSold"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "totalSupply"
         Type: uint256
         Source: "uint indexed totalSupply"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "qtyForOneEther"
         Type: uint256
         Source: "uint qtyForOneEther"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "tokensAmount"
         Type: uint256
         Source: "uint tokensAmount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "DstTokensIssued"
     Gas costs: 0
     Source: "event DstTokensIssued(uint indexed qtyForOneHKG, uint indexed tokensSold, uint indexed totalSupply, uint qtyToEmit);"
    ParameterList
       Source: "(uint indexed qtyForOneHKG, uint indexed tokensSold, uint indexed totalSupply, uint qtyToEmit)"
      VariableDeclaration "qtyForOneHKG"
         Type: uint256
         Source: "uint indexed qtyForOneHKG"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "tokensSold"
         Type: uint256
         Source: "uint indexed tokensSold"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "totalSupply"
         Type: uint256
         Source: "uint indexed totalSupply"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "qtyToEmit"
         Type: uint256
         Source: "uint qtyToEmit"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "ProposalRequestSubmitted"
     Gas costs: 0
     Source: "event ProposalRequestSubmitted(bytes32 id, uint value, uint timeEnds, string url, address sender);"
    ParameterList
       Source: "(bytes32 id, uint value, uint timeEnds, string url, address sender)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "timeEnds"
         Type: uint256
         Source: "uint timeEnds"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "url"
         Type: string memory
         Source: "string url"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "EtherRedeemAccepted"
     Gas costs: 0
     Source: "event EtherRedeemAccepted(address sender, uint value);"
    ParameterList
       Source: "(address sender, uint value)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "ObjectedVote"
     Gas costs: 0
     Source: "event ObjectedVote(bytes32 id, address voter, uint votes);"
    ParameterList
       Source: "(bytes32 id, address voter, uint votes)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "voter"
         Type: address
         Source: "address voter"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "votes"
         Type: uint256
         Source: "uint votes"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "ImpeachmentProposed"
     Gas costs: 0
     Source: "event ImpeachmentProposed(address submitter, string urlDetails, uint votindEndTS, address newExecutive);"
    ParameterList
       Source: "(address submitter, string urlDetails, uint votindEndTS, address newExecutive)"
      VariableDeclaration "submitter"
         Type: address
         Source: "address submitter"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "urlDetails"
         Type: string memory
         Source: "string urlDetails"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "votindEndTS"
         Type: uint256
         Source: "uint votindEndTS"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "newExecutive"
         Type: address
         Source: "address newExecutive"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "ImpeachmentSupport"
     Gas costs: 0
     Source: "event ImpeachmentSupport(address supportter, uint votes);"
    ParameterList
       Source: "(address supportter, uint votes)"
      VariableDeclaration "supportter"
         Type: address
         Source: "address supportter"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "votes"
         Type: uint256
         Source: "uint votes"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "ImpeachmentAccepted"
     Gas costs: 0
     Source: "event ImpeachmentAccepted(address newExecutive);"
    ParameterList
       Source: "(address newExecutive)"
      VariableDeclaration "newExecutive"
         Type: address
         Source: "address newExecutive"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "NewEtherPrice"
     Gas costs: 0
     Source: "event NewEtherPrice(uint newQtyForOneEther);"
    ParameterList
       Source: "(uint newQtyForOneEther)"
      VariableDeclaration "newQtyForOneEther"
         Type: uint256
         Source: "uint newQtyForOneEther"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "DisableTokenIssuance"
     Gas costs: 0
     Source: "event DisableTokenIssuance();"
    ParameterList
       Source: "()"
  EventDefinition "BurnedAllRemainedTokens"
     Gas costs: 0
     Source: "event BurnedAllRemainedTokens();"
    ParameterList
       Source: "()"
ContractDefinition "EventInfo"
   Source: "contract EventInfo{\r\n    \r\n    \r\n    uint constant HACKATHON_5_WEEKS = 60 * 60 * 24 * 7 * 5;\r\n    uint constant T_1_WEEK = 60 * 60 * 24 * 7;\r\n\r\n    uint eventStart = 1479391200; // Thu, 17 Nov 2016 14:00:00 GMT\r\n    uint eventEnd = eventStart + HACKATHON_5_WEEKS;\r\n    \r\n    \r\n    /**\r\n     * getEventStart - return the start of the event time\r\n     */ \r\n    function getEventStart() constant returns (uint result){        \r\n       return eventStart;\r\n    } \r\n    \r\n    /**\r\n     * getEventEnd - return the end of the event time\r\n     */ \r\n    function getEventEnd() constant returns (uint result){        \r\n       return eventEnd;\r\n    } \r\n    \r\n    \r\n    /**\r\n     * getVotingStart - the voting starts 1 week after the \r\n     *                  event starts\r\n     */ \r\n    function getVotingStart() constant returns (uint result){\r\n        return eventStart+ T_1_WEEK;\r\n    }\r\n\r\n    /**\r\n     * getTradingStart - the DST tokens trading starts 1 week \r\n     *                   after the event starts\r\n     */ \r\n    function getTradingStart() constant returns (uint result){\r\n        return eventStart+ T_1_WEEK;\r\n    }\r\n\r\n    /**\r\n     * getNow - helper class to check what time the contract see\r\n     */\r\n    function getNow() constant returns (uint result){        \r\n       return now;\r\n    } \r\n    \r\n}"
  VariableDeclaration "HACKATHON_5_WEEKS"
     Type: uint256
     Gas costs: 0
     Source: "uint constant HACKATHON_5_WEEKS = 60 * 60 * 24 * 7 * 5"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: int_const 3024000
       Source: "60 * 60 * 24 * 7 * 5"
      BinaryOperation using operator *
         Type: int_const 604800
         Source: "60 * 60 * 24 * 7"
        BinaryOperation using operator *
           Type: int_const 86400
           Source: "60 * 60 * 24"
          BinaryOperation using operator *
             Type: int_const 3600
             Source: "60 * 60"
            Literal, token: [no token] value: 60
               Type: int_const 60
               Source: "60"
            Literal, token: [no token] value: 60
               Type: int_const 60
               Source: "60"
          Literal, token: [no token] value: 24
             Type: int_const 24
             Source: "24"
        Literal, token: [no token] value: 7
           Type: int_const 7
           Source: "7"
      Literal, token: [no token] value: 5
         Type: int_const 5
         Source: "5"
  VariableDeclaration "T_1_WEEK"
     Type: uint256
     Gas costs: 6
     Source: "uint constant T_1_WEEK = 60 * 60 * 24 * 7"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator *
       Type: int_const 604800
       Source: "60 * 60 * 24 * 7"
      BinaryOperation using operator *
         Type: int_const 86400
         Source: "60 * 60 * 24"
        BinaryOperation using operator *
           Type: int_const 3600
           Source: "60 * 60"
          Literal, token: [no token] value: 60
             Type: int_const 60
             Source: "60"
          Literal, token: [no token] value: 60
             Type: int_const 60
             Source: "60"
        Literal, token: [no token] value: 24
           Type: int_const 24
           Source: "24"
      Literal, token: [no token] value: 7
         Type: int_const 7
         Source: "7"
  VariableDeclaration "eventStart"
     Type: uint256
     Gas costs: 0
     Source: "uint eventStart = 1479391200"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1479391200
       Type: int_const 1479391200
       Source: "1479391200"
  VariableDeclaration "eventEnd"
     Type: uint256
     Gas costs: 0
     Source: "uint eventEnd = eventStart + HACKATHON_5_WEEKS"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator +
       Type: uint256
       Source: "eventStart + HACKATHON_5_WEEKS"
      Identifier eventStart
         Type: uint256
         Source: "eventStart"
      Identifier HACKATHON_5_WEEKS
         Type: uint256
         Source: "HACKATHON_5_WEEKS"
  FunctionDefinition "getEventStart" - public - const
     Source: "function getEventStart() constant returns (uint result){        \r\n       return eventStart;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{        \r\n       return eventStart;\r\n    }"
      Return
         Gas costs: 208
         Source: "return eventStart"
        Identifier eventStart
           Type: uint256
           Source: "eventStart"
  FunctionDefinition "getEventEnd" - public - const
     Source: "function getEventEnd() constant returns (uint result){        \r\n       return eventEnd;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{        \r\n       return eventEnd;\r\n    }"
      Return
         Gas costs: 208
         Source: "return eventEnd"
        Identifier eventEnd
           Type: uint256
           Source: "eventEnd"
  FunctionDefinition "getVotingStart" - public - const
     Source: "function getVotingStart() constant returns (uint result){\r\n        return eventStart+ T_1_WEEK;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return eventStart+ T_1_WEEK;\r\n    }"
      Return
         Gas costs: 211
         Source: "return eventStart+ T_1_WEEK"
        BinaryOperation using operator +
           Type: uint256
           Source: "eventStart+ T_1_WEEK"
          Identifier eventStart
             Type: uint256
             Source: "eventStart"
          Identifier T_1_WEEK
             Type: uint256
             Source: "T_1_WEEK"
  FunctionDefinition "getTradingStart" - public - const
     Source: "function getTradingStart() constant returns (uint result){\r\n        return eventStart+ T_1_WEEK;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return eventStart+ T_1_WEEK;\r\n    }"
      Return
         Gas costs: 211
         Source: "return eventStart+ T_1_WEEK"
        BinaryOperation using operator +
           Type: uint256
           Source: "eventStart+ T_1_WEEK"
          Identifier eventStart
             Type: uint256
             Source: "eventStart"
          Identifier T_1_WEEK
             Type: uint256
             Source: "T_1_WEEK"
  FunctionDefinition "getNow" - public - const
     Source: "function getNow() constant returns (uint result){        \r\n       return now;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint result"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{        \r\n       return now;\r\n    }"
      Return
         Gas costs: 7
         Source: "return now"
        Identifier now
           Type: uint256
           Source: "now"
