Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x3293cc907fde439b39aedaf1b982785adaff186b.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "mul" - const
     Source: "function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div" - const
     Source: "function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub" - const
     Source: "function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 0
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add" - const
     Source: "function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "ReentryProtected"
   Source: "contract ReentryProtected\r\n{\r\n  // The reentry protection state mutex.\r\n  bool __reMutex;\r\n\r\n  // This modifier can be used on functions with external calls to\r\n  // prevent reentry attacks.\r\n  // Constraints:\r\n  //   Protected functions must have only one point of exit.\r\n  //   Protected functions cannot use the `return` keyword\r\n  //   Protected functions return values must be through return parameters.\r\n  modifier preventReentry() {\r\n    require(!__reMutex);\r\n    __reMutex = true;\r\n    _;\r\n    delete __reMutex;\r\n    return;\r\n  }\r\n\r\n  // This modifier can be applied to public access state mutation functions\r\n  // to protect against reentry if a `preventReentry` function has already\r\n  // set the mutex. This prevents the contract from being reenter under a\r\n  // different memory context which can break state variable integrity.\r\n  modifier noReentry() {\r\n    require(!__reMutex);\r\n    _;\r\n  }\r\n}"
  VariableDeclaration "__reMutex"
     Type: bool
     Gas costs: 0
     Source: "bool __reMutex"
    ElementaryTypeName bool
       Source: "bool"
  ModifierDefinition "preventReentry"
     Source: "modifier preventReentry() {\r\n    require(!__reMutex);\r\n    __reMutex = true;\r\n    _;\r\n    delete __reMutex;\r\n    return;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(!__reMutex);\r\n    __reMutex = true;\r\n    _;\r\n    delete __reMutex;\r\n    return;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!__reMutex)"
        FunctionCall
           Type: tuple()
           Source: "require(!__reMutex)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!__reMutex"
            Identifier __reMutex
               Type: bool
               Source: "__reMutex"
      ExpressionStatement
         Gas costs: 0
         Source: "__reMutex = true"
        Assignment using operator =
           Type: bool
           Source: "__reMutex = true"
          Identifier __reMutex
             Type: bool
             Source: "__reMutex"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
      ExpressionStatement
         Gas costs: 0
         Source: "delete __reMutex"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete __reMutex"
          Identifier __reMutex
             Type: bool
             Source: "__reMutex"
      Return
         Gas costs: 0
         Source: "return;"
  ModifierDefinition "noReentry"
     Source: "modifier noReentry() {\r\n    require(!__reMutex);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(!__reMutex);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 804
         Source: "require(!__reMutex)"
        FunctionCall
           Type: tuple()
           Source: "require(!__reMutex)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!__reMutex"
            Identifier __reMutex
               Type: bool
               Source: "__reMutex"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
ContractDefinition "ERC20Interface"
   Gas costs: 0
   Source: "contract ERC20Interface\r\n{\r\n  /* Structs */\r\n\r\n  /* State Valiables */\r\n\r\n  /* Events */\r\n  // Triggered when tokens are transferred.\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 _value);\r\n\r\n  // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _spender,\r\n    uint256 _value);\r\n\r\n  /* Modifiers */\r\n\r\n  /* Function Abstracts */\r\n\r\n  /// @return The total supply of tokens\r\n  function totalSupply() public constant returns (uint256);\r\n\r\n  /// @param _addr The address of a token holder\r\n  /// @return The amount of tokens held by `_addr`\r\n  function balanceOf(address _addr) public constant returns (uint256);\r\n\r\n  /// @param _owner The address of a token holder\r\n  /// @param _spender the address of a third-party\r\n  /// @return The amount of tokens the `_spender` is allowed to transfer\r\n  function allowance(address _owner, address _spender) public constant\r\n  returns (uint256);\r\n\r\n  /// @notice Send `_amount` of tokens from `msg.sender` to `_to`\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The amount of tokens to transfer\r\n  function transfer(address _to, uint256 _amount) public returns (bool);\r\n\r\n  /// @notice Send `_amount` of tokens from `_from` to `_to` on the condition\r\n  /// it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The amount of tokens to transfer\r\n  function transferFrom(address _from, address _to, uint256 _amount)\r\n  public returns (bool);\r\n\r\n  /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n  /// its behalf\r\n  /// @param _spender The address of the approved spender\r\n  /// @param _amount The amount of tokens to transfer\r\n  function approve(address _spender, uint256 _amount) public returns (bool);\r\n}"
  EventDefinition "Transfer"
     Source: "event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 _value);"
    ParameterList
       Source: "(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(\r\n    address indexed _owner,\r\n    address indexed _spender,\r\n    uint256 _value);"
    ParameterList
       Source: "(\r\n    address indexed _owner,\r\n    address indexed _spender,\r\n    uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() public constant returns (uint256);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _addr) public constant returns (uint256);"
    ParameterList
       Source: "(address _addr)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public constant\r\n  returns (uint256);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _amount) public returns (bool);"
    ParameterList
       Source: "(address _to, uint256 _amount)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _amount)\r\n  public returns (bool);"
    ParameterList
       Source: "(address _from, address _to, uint256 _amount)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _amount) public returns (bool);"
    ParameterList
       Source: "(address _spender, uint256 _amount)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
ContractDefinition "ERC20Token"
   Source: "contract ERC20Token is ReentryProtected, ERC20Interface\r\n{\r\n\r\n  using SafeMath for uint256;\r\n\r\n  /* State */\r\n  // The Total supply of tokens\r\n  uint256 totSupply;\r\n\r\n  \r\n  // Token ownership mapping\r\n  mapping (address => uint256) balance;\r\n\r\n  // Allowances mapping\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n  /* Funtions Public */\r\n\r\n  function ERC20Token()\r\n  {\r\n    // Supply limited to 2^128 rather than 2^256 to prevent potential \r\n    // multiplication overflow\r\n    \r\n    totSupply = 0;\r\n    balance[msg.sender] = totSupply;\r\n  }\r\n\r\n  // Using an explicit getter allows for function overloading    \r\n  function totalSupply()\r\n  public\r\n  constant\r\n  returns (uint256)\r\n  {\r\n    return totSupply;\r\n  }\r\n\r\n\r\n  // Using an explicit getter allows for function overloading    \r\n  function balanceOf(address _addr)\r\n  public\r\n  constant\r\n  returns (uint256)\r\n  {\r\n    return balance[_addr];\r\n  }\r\n\r\n  // Using an explicit getter allows for function overloading    \r\n  function allowance(address _owner, address _spender)\r\n  public\r\n  constant\r\n  returns (uint256 remaining_)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n\r\n  // Send _value amount of tokens to address _to\r\n  // Reentry protection prevents attacks upon the state\r\n  function transfer(address _to, uint256 _value)\r\n  public\r\n  noReentry\r\n  returns (bool)\r\n  {\r\n    return xfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  // Send _value amount of tokens from address _from to address _to\r\n  // Reentry protection prevents attacks upon the state\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n  public\r\n  noReentry\r\n  returns (bool)\r\n  {\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    allowed[_from][msg.sender] -= _value;\r\n    return xfer(_from, _to, _value);\r\n  }\r\n\r\n  // Process a transfer internally.\r\n  function xfer(address _from, address _to, uint256 _value)\r\n  internal\r\n  returns (bool)\r\n  {\r\n    require(_value > 0 && _value <= balance[_from]);\r\n    balance[_from] -= _value;\r\n    balance[_to] += _value;\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  // Approves a third-party spender\r\n  // Reentry protection prevents attacks upon the state\r\n  function approve(address _spender, uint256 _value)\r\n  public\r\n  noReentry\r\n  returns (bool)\r\n  {\r\n    require(balance[msg.sender] != 0);\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ReentryProtected"
    UserDefinedTypeName "ReentryProtected"
       Source: "ReentryProtected"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20Interface"
    UserDefinedTypeName "ERC20Interface"
       Source: "ERC20Interface"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "totSupply"
     Type: uint256
     Gas costs: 0
     Source: "uint256 totSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "balance"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balance"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "ERC20Token" - public
     Source: "function ERC20Token()\r\n  {\r\n    // Supply limited to 2^128 rather than 2^256 to prevent potential \r\n    // multiplication overflow\r\n    \r\n    totSupply = 0;\r\n    balance[msg.sender] = totSupply;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    // Supply limited to 2^128 rather than 2^256 to prevent potential \r\n    // multiplication overflow\r\n    \r\n    totSupply = 0;\r\n    balance[msg.sender] = totSupply;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "totSupply = 0"
        Assignment using operator =
           Type: uint256
           Source: "totSupply = 0"
          Identifier totSupply
             Type: uint256
             Source: "totSupply"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "balance[msg.sender] = totSupply"
        Assignment using operator =
           Type: uint256
           Source: "balance[msg.sender] = totSupply"
          IndexAccess
             Type: uint256
             Source: "balance[msg.sender]"
            Identifier balance
               Type: mapping(address => uint256)
               Source: "balance"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier totSupply
             Type: uint256
             Source: "totSupply"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply()\r\n  public\r\n  constant\r\n  returns (uint256)\r\n  {\r\n    return totSupply;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return totSupply;\r\n  }"
      Return
         Gas costs: 208
         Source: "return totSupply"
        Identifier totSupply
           Type: uint256
           Source: "totSupply"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _addr)\r\n  public\r\n  constant\r\n  returns (uint256)\r\n  {\r\n    return balance[_addr];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _addr)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return balance[_addr];\r\n  }"
      Return
         Gas costs: 304
         Source: "return balance[_addr]"
        IndexAccess
           Type: uint256
           Source: "balance[_addr]"
          Identifier balance
             Type: mapping(address => uint256)
             Source: "balance"
          Identifier _addr
             Type: address
             Source: "_addr"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender)\r\n  public\r\n  constant\r\n  returns (uint256 remaining_)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining_)"
      VariableDeclaration "remaining_"
         Type: uint256
         Source: "uint256 remaining_"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return allowed[_owner][_spender];\r\n  }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value)\r\n  public\r\n  noReentry\r\n  returns (bool)\r\n  {\r\n    return xfer(msg.sender, _to, _value);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "noReentry"
       Gas costs: 0
       Source: "noReentry"
      Identifier noReentry
         Type: modifier ()
         Source: "noReentry"
    Block
       Source: "{\r\n    return xfer(msg.sender, _to, _value);\r\n  }"
      Return
         Gas costs: 28
         Source: "return xfer(msg.sender, _to, _value)"
        FunctionCall
           Type: bool
           Source: "xfer(msg.sender, _to, _value)"
          Identifier xfer
             Type: function (address,address,uint256) returns (bool)
             Source: "xfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value)\r\n  public\r\n  noReentry\r\n  returns (bool)\r\n  {\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    allowed[_from][msg.sender] -= _value;\r\n    return xfer(_from, _to, _value);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "noReentry"
       Gas costs: 0
       Source: "noReentry"
      Identifier noReentry
         Type: modifier ()
         Source: "noReentry"
    Block
       Source: "{\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    allowed[_from][msg.sender] -= _value;\r\n    return xfer(_from, _to, _value);\r\n  }"
      ExpressionStatement
         Gas costs: 423
         Source: "require(_value <= allowed[_from][msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= allowed[_from][msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= allowed[_from][msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "allowed[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[_from]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 20418
         Source: "allowed[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowed[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 18
         Source: "return xfer(_from, _to, _value)"
        FunctionCall
           Type: bool
           Source: "xfer(_from, _to, _value)"
          Identifier xfer
             Type: function (address,address,uint256) returns (bool)
             Source: "xfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "xfer"
     Source: "function xfer(address _from, address _to, uint256 _value)\r\n  internal\r\n  returns (bool)\r\n  {\r\n    require(_value > 0 && _value <= balance[_from]);\r\n    balance[_from] -= _value;\r\n    balance[_to] += _value;\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(_value > 0 && _value <= balance[_from]);\r\n    balance[_from] -= _value;\r\n    balance[_to] += _value;\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 365
         Source: "require(_value > 0 && _value <= balance[_from])"
        FunctionCall
           Type: tuple()
           Source: "require(_value > 0 && _value <= balance[_from])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_value > 0 && _value <= balance[_from]"
            BinaryOperation using operator >
               Type: bool
               Source: "_value > 0"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator <=
               Type: bool
               Source: "_value <= balance[_from]"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              IndexAccess
                 Type: uint256
                 Source: "balance[_from]"
                Identifier balance
                   Type: mapping(address => uint256)
                   Source: "balance"
                Identifier _from
                   Type: address
                   Source: "_from"
      ExpressionStatement
         Gas costs: 20329
         Source: "balance[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balance[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balance[_from]"
            Identifier balance
               Type: mapping(address => uint256)
               Source: "balance"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balance[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balance[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balance[_to]"
            Identifier balance
               Type: mapping(address => uint256)
               Source: "balance"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value)\r\n  public\r\n  noReentry\r\n  returns (bool)\r\n  {\r\n    require(balance[msg.sender] != 0);\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "noReentry"
       Gas costs: 0
       Source: "noReentry"
      Identifier noReentry
         Type: modifier ()
         Source: "noReentry"
    Block
       Source: "{\r\n    require(balance[msg.sender] != 0);\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 333
         Source: "require(balance[msg.sender] != 0)"
        FunctionCall
           Type: tuple()
           Source: "require(balance[msg.sender] != 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "balance[msg.sender] != 0"
            IndexAccess
               Type: uint256
               Source: "balance[msg.sender]"
              Identifier balance
                 Type: mapping(address => uint256)
                 Source: "balance"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
ContractDefinition "Ownable"
   Source: "contract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n   function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n   modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n   function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));      \r\n    owner = newOwner;\r\n  }\r\n\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "Ownable" - public
     Source: "function Ownable() {\r\n    owner = msg.sender;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    owner = msg.sender;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 846
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));      \r\n    owner = newOwner;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(newOwner != address(0));      \r\n    owner = newOwner;\r\n  }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(newOwner != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(newOwner != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "newOwner != address(0)"
            Identifier newOwner
               Type: address
               Source: "newOwner"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
ContractDefinition "MintableToken"
   Source: "contract MintableToken is ERC20Token, Ownable {\r\n  using SafeMath for uint256;\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will recieve the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n   function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\r\n    totSupply = totSupply.add(_amount);\r\n    balance[_to] = balance[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(0x0, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n    /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n   function finishMinting() onlyOwner returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20Token"
    UserDefinedTypeName "ERC20Token"
       Source: "ERC20Token"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  EventDefinition "Mint"
     Gas costs: 0
     Source: "event Mint(address indexed to, uint256 amount);"
    ParameterList
       Source: "(address indexed to, uint256 amount)"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "MintFinished"
     Gas costs: 0
     Source: "event MintFinished();"
    ParameterList
       Source: "()"
  VariableDeclaration "mintingFinished"
     Type: bool
     Gas costs: [???]
     Source: "bool public mintingFinished = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  ModifierDefinition "canMint"
     Source: "modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(!mintingFinished);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 318
         Source: "require(!mintingFinished)"
        FunctionCall
           Type: tuple()
           Source: "require(!mintingFinished)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!mintingFinished"
            Identifier mintingFinished
               Type: bool
               Source: "mintingFinished"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "mint" - public
     Source: "function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\r\n    totSupply = totSupply.add(_amount);\r\n    balance[_to] = balance[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(0x0, _to, _amount);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _amount)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "canMint"
       Gas costs: 0
       Source: "canMint"
      Identifier canMint
         Type: modifier ()
         Source: "canMint"
    Block
       Source: "{\r\n    totSupply = totSupply.add(_amount);\r\n    balance[_to] = balance[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(0x0, _to, _amount);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 20247
         Source: "totSupply = totSupply.add(_amount)"
        Assignment using operator =
           Type: uint256
           Source: "totSupply = totSupply.add(_amount)"
          Identifier totSupply
             Type: uint256
             Source: "totSupply"
          FunctionCall
             Type: uint256
             Source: "totSupply.add(_amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "totSupply.add"
              Identifier totSupply
                 Type: uint256
                 Source: "totSupply"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 20439
         Source: "balance[_to] = balance[_to].add(_amount)"
        Assignment using operator =
           Type: uint256
           Source: "balance[_to] = balance[_to].add(_amount)"
          IndexAccess
             Type: uint256
             Source: "balance[_to]"
            Identifier balance
               Type: mapping(address => uint256)
               Source: "balance"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balance[_to].add(_amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) view returns (uint256)
               Source: "balance[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balance[_to]"
                Identifier balance
                   Type: mapping(address => uint256)
                   Source: "balance"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Mint(_to, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Mint(_to, _amount)"
          Identifier Mint
             Type: function (address,uint256)
             Source: "Mint"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(0x0, _to, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(0x0, _to, _amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "finishMinting" - public
     Source: "function finishMinting() onlyOwner returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 20317
         Source: "mintingFinished = true"
        Assignment using operator =
           Type: bool
           Source: "mintingFinished = true"
          Identifier mintingFinished
             Type: bool
             Source: "mintingFinished"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 786
         Source: "MintFinished()"
        FunctionCall
           Type: tuple()
           Source: "MintFinished()"
          Identifier MintFinished
             Type: function ()
             Source: "MintFinished"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
ContractDefinition "TriaToken_v2"
   Gas costs: [???]
   Source: "contract TriaToken_v2 is MintableToken {\r\n\r\n  string public constant name = \"TriaToken\";\r\n  string public constant symbol = \"TRIA\";\r\n  uint256 public constant decimals = 10;\r\n}"
  InheritanceSpecifier
     Source: "MintableToken"
    UserDefinedTypeName "MintableToken"
       Source: "MintableToken"
  VariableDeclaration "name"
     Type: string memory
     Source: "string public constant name = \"TriaToken\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: TriaToken
       Type: literal_string "TriaToken"
       Source: "\"TriaToken\""
  VariableDeclaration "symbol"
     Type: string memory
     Source: "string public constant symbol = \"TRIA\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: TRIA
       Type: literal_string "TRIA"
       Source: "\"TRIA\""
  VariableDeclaration "decimals"
     Type: uint256
     Source: "uint256 public constant decimals = 10"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 10
       Type: int_const 10
       Source: "10"
