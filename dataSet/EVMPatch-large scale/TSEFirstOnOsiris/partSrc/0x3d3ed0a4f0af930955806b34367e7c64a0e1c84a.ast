Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x3d3ed0a4f0af930955806b34367e7c64a0e1c84a.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "ERC20"
   Gas costs: 0
   Source: "contract ERC20 {\r\n\t//Sets events and functions for ERC20 token\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\tevent Transfer(address indexed _from, address indexed _to, uint _value);\r\n\t\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n\tfunction approve(address _spender, uint _value) returns (bool success);\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n}"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint remaining"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint _value) returns (bool success);"
    ParameterList
       Source: "(address _spender, uint _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint balance"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value) returns (bool success);"
    ParameterList
       Source: "(address _to, uint _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value) returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
ContractDefinition "Owned"
   Source: "contract Owned {\r\n\t//Public variable\r\n    address public owner;\r\n\r\n\t//Sets contract creator as the owner\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\t\r\n\t//Sets onlyOwner modifier for specified functions\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\t//Allows for transfer of contract ownership\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "Owned" - public
     Source: "function Owned() {\r\n        owner = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 1692
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        owner = newOwner;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n    function add(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }  \r\n\r\n    function div(uint256 a, uint256 b) internal returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n  \r\n    function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n}"
  FunctionDefinition "add"
     Source: "function add(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div"
     Source: "function div(uint256 a, uint256 b) internal returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "max64" - const
     Source: "function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint64 a, uint64 b)"
      VariableDeclaration "a"
         Type: uint64
         Source: "uint64 a"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "b"
         Type: uint64
         Source: "uint64 b"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 0
       Source: "(uint64)"
      VariableDeclaration ""
         Type: uint64
         Source: "uint64"
        ElementaryTypeName uint64
           Source: "uint64"
    Block
       Source: "{\r\n        return a >= b ? a : b;\r\n    }"
      Return
         Gas costs: 0
         Source: "return a >= b ? a : b"
        Conditional
           Type: uint64
           Source: "a >= b ? a : b"
          BinaryOperation using operator >=
             Type: bool
             Source: "a >= b"
            Identifier a
               Type: uint64
               Source: "a"
            Identifier b
               Type: uint64
               Source: "b"
          Identifier a
             Type: uint64
             Source: "a"
          Identifier b
             Type: uint64
             Source: "b"
  FunctionDefinition "max256" - const
     Source: "function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return a >= b ? a : b;\r\n    }"
      Return
         Gas costs: 0
         Source: "return a >= b ? a : b"
        Conditional
           Type: uint256
           Source: "a >= b ? a : b"
          BinaryOperation using operator >=
             Type: bool
             Source: "a >= b"
            Identifier a
               Type: uint256
               Source: "a"
            Identifier b
               Type: uint256
               Source: "b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "min64" - const
     Source: "function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a < b ? a : b;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint64 a, uint64 b)"
      VariableDeclaration "a"
         Type: uint64
         Source: "uint64 a"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "b"
         Type: uint64
         Source: "uint64 b"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 0
       Source: "(uint64)"
      VariableDeclaration ""
         Type: uint64
         Source: "uint64"
        ElementaryTypeName uint64
           Source: "uint64"
    Block
       Source: "{\r\n        return a < b ? a : b;\r\n    }"
      Return
         Gas costs: 0
         Source: "return a < b ? a : b"
        Conditional
           Type: uint64
           Source: "a < b ? a : b"
          BinaryOperation using operator <
             Type: bool
             Source: "a < b"
            Identifier a
               Type: uint64
               Source: "a"
            Identifier b
               Type: uint64
               Source: "b"
          Identifier a
             Type: uint64
             Source: "a"
          Identifier b
             Type: uint64
             Source: "b"
  FunctionDefinition "min256" - const
     Source: "function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a < b ? a : b;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return a < b ? a : b;\r\n    }"
      Return
         Gas costs: 0
         Source: "return a < b ? a : b"
        Conditional
           Type: uint256
           Source: "a < b ? a : b"
          BinaryOperation using operator <
             Type: bool
             Source: "a < b"
            Identifier a
               Type: uint256
               Source: "a"
            Identifier b
               Type: uint256
               Source: "b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "mul"
     Source: "function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 88
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub"
     Source: "function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        assert(b <= a);\r\n        return a - b;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 0
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
ContractDefinition "ASStoken"
   Source: "contract ASStoken is ERC20, Owned {\r\n    //Applies SafeMath library to uint256 operations \r\n    using SafeMath for uint256;\r\n\r\n\t//Public variables\r\n\tstring public name; \r\n\tstring public symbol; \r\n\tuint256 public decimals;  \r\n    uint256 public initialSupply; \r\n\tuint256 public totalSupply; \r\n\r\n    //Variables\r\n    uint256 multiplier; \r\n\t\r\n\t//Creates arrays for balances\r\n    mapping (address => uint256) balance;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    //Creates modifier to prevent short address attack\r\n    modifier onlyPayloadSize(uint size) {\r\n        if(msg.data.length < size + 4) revert();\r\n        _;\r\n    }\r\n\r\n\t//Constructor\r\n\tfunction ASStoken(string tokenName, string tokenSymbol, uint8 decimalUnits, uint256 decimalMultiplier, uint256 initialAmount) {\r\n\t\tname = tokenName; \r\n\t\tsymbol = tokenSymbol; \r\n\t\tdecimals = decimalUnits; \r\n        multiplier = decimalMultiplier; \r\n        initialSupply = initialAmount; \r\n\t\ttotalSupply = initialSupply;  \r\n\t}\r\n\t\r\n\t//Provides the remaining balance of approved tokens from function approve \r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n\t//Allows for a certain amount of tokens to be spent on behalf of the account owner\r\n    function approve(address _spender, uint256 _value) returns (bool success) { \r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\t//Returns the account balance \r\n    function balanceOf(address _owner) constant returns (uint256 remainingBalance) {\r\n        return balance[_owner];\r\n    }\r\n\r\n    //Allows contract owner to mint new tokens, prevents numerical overflow\r\n\tfunction mintToken(address target, uint256 mintedAmount) onlyOwner returns (bool success) {\r\n\t\trequire(mintedAmount > 0); \r\n        uint256 addTokens = mintedAmount; \r\n\t\tbalance[target] += addTokens;\r\n\t\ttotalSupply += addTokens;\r\n\t\tTransfer(0, target, addTokens);\r\n\t\treturn true; \r\n\t}\r\n\r\n\t//Sends tokens from sender's account\r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n        if ((balance[msg.sender] >= _value) && (balance[_to] + _value > balance[_to])) {\r\n            balance[msg.sender] -= _value;\r\n            balance[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n\t\t\treturn false; \r\n\t\t}\r\n    }\r\n\t\r\n\t//Transfers tokens from an approved account \r\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool success) {\r\n        if ((balance[_from] >= _value) && (allowed[_from][msg.sender] >= _value) && (balance[_to] + _value > balance[_to])) {\r\n            balance[_to] += _value;\r\n            balance[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { \r\n\t\t\treturn false; \r\n\t\t}\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Owned"
    UserDefinedTypeName "Owned"
       Source: "Owned"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public name"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public symbol"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "decimals"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public decimals"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "initialSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public initialSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "totalSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "multiplier"
     Type: uint256
     Gas costs: 0
     Source: "uint256 multiplier"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "balance"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balance"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  ModifierDefinition "onlyPayloadSize"
     Source: "modifier onlyPayloadSize(uint size) {\r\n        if(msg.data.length < size + 4) revert();\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint size)"
      VariableDeclaration "size"
         Type: uint256
         Source: "uint size"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if(msg.data.length < size + 4) revert();\r\n        _;\r\n    }"
      IfStatement
         Source: "if(msg.data.length < size + 4) revert()"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 44
           Source: "msg.data.length < size + 4"
          MemberAccess to member length
             Type: uint256
             Source: "msg.data.length"
            MemberAccess to member data
               Type: bytes calldata
               Source: "msg.data"
              Identifier msg
                 Type: msg
                 Source: "msg"
          BinaryOperation using operator +
             Type: uint256
             Source: "size + 4"
            Identifier size
               Type: uint256
               Source: "size"
            Literal, token: [no token] value: 4
               Type: int_const 4
               Source: "4"
        ExpressionStatement
           Gas costs: 12
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      PlaceholderStatement
         Gas costs: 2
         Source: "_"
  FunctionDefinition "ASStoken" - public
     Source: "function ASStoken(string tokenName, string tokenSymbol, uint8 decimalUnits, uint256 decimalMultiplier, uint256 initialAmount) {\r\n\t\tname = tokenName; \r\n\t\tsymbol = tokenSymbol; \r\n\t\tdecimals = decimalUnits; \r\n        multiplier = decimalMultiplier; \r\n        initialSupply = initialAmount; \r\n\t\ttotalSupply = initialSupply;  \r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(string tokenName, string tokenSymbol, uint8 decimalUnits, uint256 decimalMultiplier, uint256 initialAmount)"
      VariableDeclaration "tokenName"
         Type: string memory
         Source: "string tokenName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "tokenSymbol"
         Type: string memory
         Source: "string tokenSymbol"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "decimalUnits"
         Type: uint8
         Source: "uint8 decimalUnits"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "decimalMultiplier"
         Type: uint256
         Source: "uint256 decimalMultiplier"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "initialAmount"
         Type: uint256
         Source: "uint256 initialAmount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tname = tokenName; \r\n\t\tsymbol = tokenSymbol; \r\n\t\tdecimals = decimalUnits; \r\n        multiplier = decimalMultiplier; \r\n        initialSupply = initialAmount; \r\n\t\ttotalSupply = initialSupply;  \r\n\t}"
      ExpressionStatement
         Gas costs: 0
         Source: "name = tokenName"
        Assignment using operator =
           Type: string storage ref
           Source: "name = tokenName"
          Identifier name
             Type: string storage ref
             Source: "name"
          Identifier tokenName
             Type: string memory
             Source: "tokenName"
      ExpressionStatement
         Gas costs: 0
         Source: "symbol = tokenSymbol"
        Assignment using operator =
           Type: string storage ref
           Source: "symbol = tokenSymbol"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
          Identifier tokenSymbol
             Type: string memory
             Source: "tokenSymbol"
      ExpressionStatement
         Gas costs: 0
         Source: "decimals = decimalUnits"
        Assignment using operator =
           Type: uint256
           Source: "decimals = decimalUnits"
          Identifier decimals
             Type: uint256
             Source: "decimals"
          Identifier decimalUnits
             Type: uint8
             Source: "decimalUnits"
      ExpressionStatement
         Gas costs: 0
         Source: "multiplier = decimalMultiplier"
        Assignment using operator =
           Type: uint256
           Source: "multiplier = decimalMultiplier"
          Identifier multiplier
             Type: uint256
             Source: "multiplier"
          Identifier decimalMultiplier
             Type: uint256
             Source: "decimalMultiplier"
      ExpressionStatement
         Gas costs: 0
         Source: "initialSupply = initialAmount"
        Assignment using operator =
           Type: uint256
           Source: "initialSupply = initialAmount"
          Identifier initialSupply
             Type: uint256
             Source: "initialSupply"
          Identifier initialAmount
             Type: uint256
             Source: "initialAmount"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = initialSupply"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = initialSupply"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier initialSupply
             Type: uint256
             Source: "initialSupply"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success) { \r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{ \r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 remainingBalance) {\r\n        return balance[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remainingBalance)"
      VariableDeclaration "remainingBalance"
         Type: uint256
         Source: "uint256 remainingBalance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balance[_owner];\r\n    }"
      Return
         Gas costs: 304
         Source: "return balance[_owner]"
        IndexAccess
           Type: uint256
           Source: "balance[_owner]"
          Identifier balance
             Type: mapping(address => uint256)
             Source: "balance"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "mintToken" - public
     Source: "function mintToken(address target, uint256 mintedAmount) onlyOwner returns (bool success) {\r\n\t\trequire(mintedAmount > 0); \r\n        uint256 addTokens = mintedAmount; \r\n\t\tbalance[target] += addTokens;\r\n\t\ttotalSupply += addTokens;\r\n\t\tTransfer(0, target, addTokens);\r\n\t\treturn true; \r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address target, uint256 mintedAmount)"
      VariableDeclaration "target"
         Type: address
         Source: "address target"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "mintedAmount"
         Type: uint256
         Source: "uint256 mintedAmount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n\t\trequire(mintedAmount > 0); \r\n        uint256 addTokens = mintedAmount; \r\n\t\tbalance[target] += addTokens;\r\n\t\ttotalSupply += addTokens;\r\n\t\tTransfer(0, target, addTokens);\r\n\t\treturn true; \r\n\t}"
      ExpressionStatement
         Gas costs: 35
         Source: "require(mintedAmount > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(mintedAmount > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "mintedAmount > 0"
            Identifier mintedAmount
               Type: uint256
               Source: "mintedAmount"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint256 addTokens = mintedAmount"
        VariableDeclaration "addTokens"
           Type: uint256
           Source: "uint256 addTokens"
          ElementaryTypeName uint256
             Source: "uint256"
        Identifier mintedAmount
           Type: uint256
           Source: "mintedAmount"
      ExpressionStatement
         Gas costs: 20329
         Source: "balance[target] += addTokens"
        Assignment using operator +=
           Type: uint256
           Source: "balance[target] += addTokens"
          IndexAccess
             Type: uint256
             Source: "balance[target]"
            Identifier balance
               Type: mapping(address => uint256)
               Source: "balance"
            Identifier target
               Type: address
               Source: "target"
          Identifier addTokens
             Type: uint256
             Source: "addTokens"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply += addTokens"
        Assignment using operator +=
           Type: uint256
           Source: "totalSupply += addTokens"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier addTokens
             Type: uint256
             Source: "addTokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(0, target, addTokens)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(0, target, addTokens)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Identifier target
             Type: address
             Source: "target"
          Identifier addTokens
             Type: uint256
             Source: "addTokens"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n        if ((balance[msg.sender] >= _value) && (balance[_to] + _value > balance[_to])) {\r\n            balance[msg.sender] -= _value;\r\n            balance[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n\t\t\treturn false; \r\n\t\t}\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 3
       Source: "onlyPayloadSize(2 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 64
         Source: "2 * 32"
        Literal, token: [no token] value: 2
           Type: int_const 2
           Source: "2"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n        if ((balance[msg.sender] >= _value) && (balance[_to] + _value > balance[_to])) {\r\n            balance[msg.sender] -= _value;\r\n            balance[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n\t\t\treturn false; \r\n\t\t}\r\n    }"
      IfStatement
         Source: "if ((balance[msg.sender] >= _value) && (balance[_to] + _value > balance[_to])) {\r\n            balance[msg.sender] -= _value;\r\n            balance[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n\t\t\treturn false; \r\n\t\t}"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 930
           Source: "(balance[msg.sender] >= _value) && (balance[_to] + _value > balance[_to])"
          TupleExpression
             Type: bool
             Source: "(balance[msg.sender] >= _value)"
            BinaryOperation using operator >=
               Type: bool
               Source: "balance[msg.sender] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "balance[msg.sender]"
                Identifier balance
                   Type: mapping(address => uint256)
                   Source: "balance"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          TupleExpression
             Type: bool
             Source: "(balance[_to] + _value > balance[_to])"
            BinaryOperation using operator >
               Type: bool
               Source: "balance[_to] + _value > balance[_to]"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "balance[_to] + _value"
                IndexAccess
                   Type: uint256
                   Source: "balance[_to]"
                  Identifier balance
                     Type: mapping(address => uint256)
                     Source: "balance"
                  Identifier _to
                     Type: address
                     Source: "_to"
                Identifier _value
                   Type: uint256
                   Source: "_value"
              IndexAccess
                 Type: uint256
                 Source: "balance[_to]"
                Identifier balance
                   Type: mapping(address => uint256)
                   Source: "balance"
                Identifier _to
                   Type: address
                   Source: "_to"
        Block
           Source: "{\r\n            balance[msg.sender] -= _value;\r\n            balance[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 20328
             Source: "balance[msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balance[msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balance[msg.sender]"
                Identifier balance
                   Type: mapping(address => uint256)
                   Source: "balance"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20323
             Source: "balance[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balance[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balance[_to]"
                Identifier balance
                   Type: mapping(address => uint256)
                   Source: "balance"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(msg.sender, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(msg.sender, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{ \r\n\t\t\treturn false; \r\n\t\t}"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool success) {\r\n        if ((balance[_from] >= _value) && (allowed[_from][msg.sender] >= _value) && (balance[_to] + _value > balance[_to])) {\r\n            balance[_to] += _value;\r\n            balance[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { \r\n\t\t\treturn false; \r\n\t\t}\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyPayloadSize"
       Gas costs: 3
       Source: "onlyPayloadSize(3 * 32)"
      Identifier onlyPayloadSize
         Type: modifier (uint256)
         Source: "onlyPayloadSize"
      BinaryOperation using operator *
         Type: int_const 96
         Source: "3 * 32"
        Literal, token: [no token] value: 3
           Type: int_const 3
           Source: "3"
        Literal, token: [no token] value: 32
           Type: int_const 32
           Source: "32"
    Block
       Source: "{\r\n        if ((balance[_from] >= _value) && (allowed[_from][msg.sender] >= _value) && (balance[_to] + _value > balance[_to])) {\r\n            balance[_to] += _value;\r\n            balance[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { \r\n\t\t\treturn false; \r\n\t\t}\r\n    }"
      IfStatement
         Source: "if ((balance[_from] >= _value) && (allowed[_from][msg.sender] >= _value) && (balance[_to] + _value > balance[_to])) {\r\n            balance[_to] += _value;\r\n            balance[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { \r\n\t\t\treturn false; \r\n\t\t}"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 1350
           Source: "(balance[_from] >= _value) && (allowed[_from][msg.sender] >= _value) && (balance[_to] + _value > balance[_to])"
          BinaryOperation using operator &&
             Type: bool
             Source: "(balance[_from] >= _value) && (allowed[_from][msg.sender] >= _value)"
            TupleExpression
               Type: bool
               Source: "(balance[_from] >= _value)"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "balance[_from] >= _value"
                IndexAccess
                   Type: uint256
                   Source: "balance[_from]"
                  Identifier balance
                     Type: mapping(address => uint256)
                     Source: "balance"
                  Identifier _from
                     Type: address
                     Source: "_from"
                Identifier _value
                   Type: uint256
                   Source: "_value"
            TupleExpression
               Type: bool
               Source: "(allowed[_from][msg.sender] >= _value)"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "allowed[_from][msg.sender] >= _value"
                IndexAccess
                   Type: uint256
                   Source: "allowed[_from][msg.sender]"
                  IndexAccess
                     Type: mapping(address => uint256)
                     Source: "allowed[_from]"
                    Identifier allowed
                       Type: mapping(address => mapping(address => uint256))
                       Source: "allowed"
                    Identifier _from
                       Type: address
                       Source: "_from"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _value
                   Type: uint256
                   Source: "_value"
          TupleExpression
             Type: bool
             Source: "(balance[_to] + _value > balance[_to])"
            BinaryOperation using operator >
               Type: bool
               Source: "balance[_to] + _value > balance[_to]"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "balance[_to] + _value"
                IndexAccess
                   Type: uint256
                   Source: "balance[_to]"
                  Identifier balance
                     Type: mapping(address => uint256)
                     Source: "balance"
                  Identifier _to
                     Type: address
                     Source: "_to"
                Identifier _value
                   Type: uint256
                   Source: "_value"
              IndexAccess
                 Type: uint256
                 Source: "balance[_to]"
                Identifier balance
                   Type: mapping(address => uint256)
                   Source: "balance"
                Identifier _to
                   Type: address
                   Source: "_to"
        Block
           Source: "{\r\n            balance[_to] += _value;\r\n            balance[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 20329
             Source: "balance[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balance[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balance[_to]"
                Identifier balance
                   Type: mapping(address => uint256)
                   Source: "balance"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20323
             Source: "balance[_from] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balance[_from] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balance[_from]"
                Identifier balance
                   Type: mapping(address => uint256)
                   Source: "balance"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20412
             Source: "allowed[_from][msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "allowed[_from][msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(_from, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(_from, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              Identifier _from
                 Type: address
                 Source: "_from"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{ \r\n\t\t\treturn false; \r\n\t\t}"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
ContractDefinition "ASStokenICO"
   Source: "contract ASStokenICO is Owned, ASStoken {\r\n    //Applies SafeMath library to uint256 operations \r\n    using SafeMath for uint256;\r\n\r\n    //Public Variables\r\n    address public multiSigWallet;                  \r\n    uint256 public amountRaised; \r\n    uint256 public deadline; \r\n    uint256 public hardcap; \r\n    uint256 public price;                            \r\n\r\n    //Variables\r\n    bool crowdsaleClosed = true;                    \r\n    string tokenName = \"ASStoken\"; \r\n    string tokenSymbol = \"ASS\"; \r\n    uint256 initialTokens = 150000000000; \r\n    uint256 multiplier = 10000; \r\n    uint8 decimalUnits = 4;  \r\n\r\n    \r\n\r\n   \t//Initializes the token\r\n\tfunction ASStokenICO(address beneficiaryAccount) \r\n    \tASStoken(tokenName, tokenSymbol, decimalUnits, multiplier, initialTokens) {\r\n            balance[msg.sender] = initialTokens;     \r\n            Transfer(0, msg.sender, initialTokens);    \r\n            multiSigWallet = beneficiaryAccount;        \r\n            hardcap = 55000000;    \r\n            hardcap = hardcap.mul(multiplier); \r\n            setPrice(40000); \r\n    }\r\n\r\n    //Fallback function creates tokens and sends to investor when crowdsale is open\r\n    function () payable {\r\n        require(!crowdsaleClosed \r\n            && (now < deadline) \r\n            && (totalSupply.add(msg.value.mul(getPrice()).mul(multiplier).div(1 ether)) <= hardcap)); \r\n        address recipient = msg.sender; \r\n        amountRaised = amountRaised.add(msg.value.div(1 ether)); \r\n        uint256 tokens = msg.value.mul(getPrice()).mul(multiplier).div(1 ether);\r\n        totalSupply = totalSupply.add(tokens);\r\n        balance[recipient] = balance[recipient].add(tokens);\r\n        require(multiSigWallet.send(msg.value)); \r\n        Transfer(0, recipient, tokens);\r\n    }   \r\n\r\n    //Returns the current price of the token for the crowdsale\r\n    function getPrice() returns (uint256 result) {\r\n        return price;\r\n    }\r\n\r\n    //Sets the multisig wallet for a crowdsale\r\n    function setMultiSigWallet(address wallet) onlyOwner returns (bool success) {\r\n        multiSigWallet = wallet; \r\n        return true; \r\n    }\r\n\r\n    //Sets the token price \r\n    function setPrice(uint256 newPriceperEther) onlyOwner returns (uint256) {\r\n        require(newPriceperEther > 0); \r\n        price = newPriceperEther; \r\n        return price; \r\n    }\r\n\r\n    //Allows owner to start the crowdsale from the time of execution until a specified deadline\r\n    function startSale(uint256 lengthOfSale) onlyOwner returns (bool success) {\r\n        deadline = now + lengthOfSale * 1 days; \r\n        crowdsaleClosed = false; \r\n        return true; \r\n    }\r\n\r\n    //Allows owner to stop the crowdsale immediately\r\n    function stopSale() onlyOwner returns (bool success) {\r\n        deadline = now; \r\n        crowdsaleClosed = true;\r\n        return true; \r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Owned"
    UserDefinedTypeName "Owned"
       Source: "Owned"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ASStoken"
    UserDefinedTypeName "ASStoken"
       Source: "ASStoken"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "multiSigWallet"
     Type: address
     Gas costs: [???]
     Source: "address public multiSigWallet"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "amountRaised"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public amountRaised"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "deadline"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public deadline"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "hardcap"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public hardcap"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "price"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public price"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "crowdsaleClosed"
     Type: bool
     Gas costs: 0
     Source: "bool crowdsaleClosed = true"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: true value: true
       Type: bool
       Source: "true"
  VariableDeclaration "tokenName"
     Type: string storage ref
     Gas costs: 0
     Source: "string tokenName = \"ASStoken\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: ASStoken
       Type: literal_string "ASStoken"
       Source: "\"ASStoken\""
  VariableDeclaration "tokenSymbol"
     Type: string storage ref
     Gas costs: 0
     Source: "string tokenSymbol = \"ASS\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: ASS
       Type: literal_string "ASS"
       Source: "\"ASS\""
  VariableDeclaration "initialTokens"
     Type: uint256
     Gas costs: 0
     Source: "uint256 initialTokens = 150000000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 150000000000
       Type: int_const 150000000000
       Source: "150000000000"
  VariableDeclaration "multiplier"
     Type: uint256
     Gas costs: 0
     Source: "uint256 multiplier = 10000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 10000
       Type: int_const 10000
       Source: "10000"
  VariableDeclaration "decimalUnits"
     Type: uint8
     Gas costs: 0
     Source: "uint8 decimalUnits = 4"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 4
       Type: int_const 4
       Source: "4"
  FunctionDefinition "ASStokenICO" - public
     Source: "function ASStokenICO(address beneficiaryAccount) \r\n    \tASStoken(tokenName, tokenSymbol, decimalUnits, multiplier, initialTokens) {\r\n            balance[msg.sender] = initialTokens;     \r\n            Transfer(0, msg.sender, initialTokens);    \r\n            multiSigWallet = beneficiaryAccount;        \r\n            hardcap = 55000000;    \r\n            hardcap = hardcap.mul(multiplier); \r\n            setPrice(40000); \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address beneficiaryAccount)"
      VariableDeclaration "beneficiaryAccount"
         Type: address
         Source: "address beneficiaryAccount"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ASStoken"
       Gas costs: 0
       Source: "ASStoken(tokenName, tokenSymbol, decimalUnits, multiplier, initialTokens)"
      Identifier ASStoken
         Type: type(contract ASStoken)
         Source: "ASStoken"
      Identifier tokenName
         Type: string storage ref
         Source: "tokenName"
      Identifier tokenSymbol
         Type: string storage ref
         Source: "tokenSymbol"
      Identifier decimalUnits
         Type: uint8
         Source: "decimalUnits"
      Identifier multiplier
         Type: uint256
         Source: "multiplier"
      Identifier initialTokens
         Type: uint256
         Source: "initialTokens"
    Block
       Source: "{\r\n            balance[msg.sender] = initialTokens;     \r\n            Transfer(0, msg.sender, initialTokens);    \r\n            multiSigWallet = beneficiaryAccount;        \r\n            hardcap = 55000000;    \r\n            hardcap = hardcap.mul(multiplier); \r\n            setPrice(40000); \r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "balance[msg.sender] = initialTokens"
        Assignment using operator =
           Type: uint256
           Source: "balance[msg.sender] = initialTokens"
          IndexAccess
             Type: uint256
             Source: "balance[msg.sender]"
            Identifier balance
               Type: mapping(address => uint256)
               Source: "balance"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier initialTokens
             Type: uint256
             Source: "initialTokens"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(0, msg.sender, initialTokens)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(0, msg.sender, initialTokens)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier initialTokens
             Type: uint256
             Source: "initialTokens"
      ExpressionStatement
         Gas costs: 0
         Source: "multiSigWallet = beneficiaryAccount"
        Assignment using operator =
           Type: address
           Source: "multiSigWallet = beneficiaryAccount"
          Identifier multiSigWallet
             Type: address
             Source: "multiSigWallet"
          Identifier beneficiaryAccount
             Type: address
             Source: "beneficiaryAccount"
      ExpressionStatement
         Gas costs: 0
         Source: "hardcap = 55000000"
        Assignment using operator =
           Type: uint256
           Source: "hardcap = 55000000"
          Identifier hardcap
             Type: uint256
             Source: "hardcap"
          Literal, token: [no token] value: 55000000
             Type: int_const 55000000
             Source: "55000000"
      ExpressionStatement
         Gas costs: 0
         Source: "hardcap = hardcap.mul(multiplier)"
        Assignment using operator =
           Type: uint256
           Source: "hardcap = hardcap.mul(multiplier)"
          Identifier hardcap
             Type: uint256
             Source: "hardcap"
          FunctionCall
             Type: uint256
             Source: "hardcap.mul(multiplier)"
            MemberAccess to member mul
               Type: function (uint256,uint256) returns (uint256)
               Source: "hardcap.mul"
              Identifier hardcap
                 Type: uint256
                 Source: "hardcap"
            Identifier multiplier
               Type: uint256
               Source: "multiplier"
      ExpressionStatement
         Gas costs: 0
         Source: "setPrice(40000)"
        FunctionCall
           Type: uint256
           Source: "setPrice(40000)"
          Identifier setPrice
             Type: function (uint256) returns (uint256)
             Source: "setPrice"
          Literal, token: [no token] value: 40000
             Type: int_const 40000
             Source: "40000"
  FunctionDefinition "" - public
     Source: "function () payable {\r\n        require(!crowdsaleClosed \r\n            && (now < deadline) \r\n            && (totalSupply.add(msg.value.mul(getPrice()).mul(multiplier).div(1 ether)) <= hardcap)); \r\n        address recipient = msg.sender; \r\n        amountRaised = amountRaised.add(msg.value.div(1 ether)); \r\n        uint256 tokens = msg.value.mul(getPrice()).mul(multiplier).div(1 ether);\r\n        totalSupply = totalSupply.add(tokens);\r\n        balance[recipient] = balance[recipient].add(tokens);\r\n        require(multiSigWallet.send(msg.value)); \r\n        Transfer(0, recipient, tokens);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(!crowdsaleClosed \r\n            && (now < deadline) \r\n            && (totalSupply.add(msg.value.mul(getPrice()).mul(multiplier).div(1 ether)) <= hardcap)); \r\n        address recipient = msg.sender; \r\n        amountRaised = amountRaised.add(msg.value.div(1 ether)); \r\n        uint256 tokens = msg.value.mul(getPrice()).mul(multiplier).div(1 ether);\r\n        totalSupply = totalSupply.add(tokens);\r\n        balance[recipient] = balance[recipient].add(tokens);\r\n        require(multiSigWallet.send(msg.value)); \r\n        Transfer(0, recipient, tokens);\r\n    }"
      ExpressionStatement
         Gas costs: 1275
         Source: "require(!crowdsaleClosed \r\n            && (now < deadline) \r\n            && (totalSupply.add(msg.value.mul(getPrice()).mul(multiplier).div(1 ether)) <= hardcap))"
        FunctionCall
           Type: tuple()
           Source: "require(!crowdsaleClosed \r\n            && (now < deadline) \r\n            && (totalSupply.add(msg.value.mul(getPrice()).mul(multiplier).div(1 ether)) <= hardcap))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "!crowdsaleClosed \r\n            && (now < deadline) \r\n            && (totalSupply.add(msg.value.mul(getPrice()).mul(multiplier).div(1 ether)) <= hardcap)"
            BinaryOperation using operator &&
               Type: bool
               Source: "!crowdsaleClosed \r\n            && (now < deadline)"
              UnaryOperation (prefix) !
                 Type: bool
                 Source: "!crowdsaleClosed"
                Identifier crowdsaleClosed
                   Type: bool
                   Source: "crowdsaleClosed"
              TupleExpression
                 Type: bool
                 Source: "(now < deadline)"
                BinaryOperation using operator <
                   Type: bool
                   Source: "now < deadline"
                  Identifier now
                     Type: uint256
                     Source: "now"
                  Identifier deadline
                     Type: uint256
                     Source: "deadline"
            TupleExpression
               Type: bool
               Source: "(totalSupply.add(msg.value.mul(getPrice()).mul(multiplier).div(1 ether)) <= hardcap)"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "totalSupply.add(msg.value.mul(getPrice()).mul(multiplier).div(1 ether)) <= hardcap"
                FunctionCall
                   Type: uint256
                   Source: "totalSupply.add(msg.value.mul(getPrice()).mul(multiplier).div(1 ether))"
                  MemberAccess to member add
                     Type: function (uint256,uint256) returns (uint256)
                     Source: "totalSupply.add"
                    Identifier totalSupply
                       Type: uint256
                       Source: "totalSupply"
                  FunctionCall
                     Type: uint256
                     Source: "msg.value.mul(getPrice()).mul(multiplier).div(1 ether)"
                    MemberAccess to member div
                       Type: function (uint256,uint256) returns (uint256)
                       Source: "msg.value.mul(getPrice()).mul(multiplier).div"
                      FunctionCall
                         Type: uint256
                         Source: "msg.value.mul(getPrice()).mul(multiplier)"
                        MemberAccess to member mul
                           Type: function (uint256,uint256) returns (uint256)
                           Source: "msg.value.mul(getPrice()).mul"
                          FunctionCall
                             Type: uint256
                             Source: "msg.value.mul(getPrice())"
                            MemberAccess to member mul
                               Type: function (uint256,uint256) returns (uint256)
                               Source: "msg.value.mul"
                              MemberAccess to member value
                                 Type: uint256
                                 Source: "msg.value"
                                Identifier msg
                                   Type: msg
                                   Source: "msg"
                            FunctionCall
                               Type: uint256
                               Source: "getPrice()"
                              Identifier getPrice
                                 Type: function () returns (uint256)
                                 Source: "getPrice"
                        Identifier multiplier
                           Type: uint256
                           Source: "multiplier"
                    Literal, token: [no token] value: 1
                       Type: int_const 1000000000000000000
                       Source: "1 ether"
                Identifier hardcap
                   Type: uint256
                   Source: "hardcap"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "address recipient = msg.sender"
        VariableDeclaration "recipient"
           Type: address
           Source: "address recipient"
          ElementaryTypeName address
             Source: "address"
        MemberAccess to member sender
           Type: address
           Source: "msg.sender"
          Identifier msg
             Type: msg
             Source: "msg"
      ExpressionStatement
         Gas costs: 20279
         Source: "amountRaised = amountRaised.add(msg.value.div(1 ether))"
        Assignment using operator =
           Type: uint256
           Source: "amountRaised = amountRaised.add(msg.value.div(1 ether))"
          Identifier amountRaised
             Type: uint256
             Source: "amountRaised"
          FunctionCall
             Type: uint256
             Source: "amountRaised.add(msg.value.div(1 ether))"
            MemberAccess to member add
               Type: function (uint256,uint256) returns (uint256)
               Source: "amountRaised.add"
              Identifier amountRaised
                 Type: uint256
                 Source: "amountRaised"
            FunctionCall
               Type: uint256
               Source: "msg.value.div(1 ether)"
              MemberAccess to member div
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "msg.value.div"
                MemberAccess to member value
                   Type: uint256
                   Source: "msg.value"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: [no token] value: 1
                 Type: int_const 1000000000000000000
                 Source: "1 ether"
      VariableDeclarationStatement
         Gas costs: 310
         Source: "uint256 tokens = msg.value.mul(getPrice()).mul(multiplier).div(1 ether)"
        VariableDeclaration "tokens"
           Type: uint256
           Source: "uint256 tokens"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "msg.value.mul(getPrice()).mul(multiplier).div(1 ether)"
          MemberAccess to member div
             Type: function (uint256,uint256) returns (uint256)
             Source: "msg.value.mul(getPrice()).mul(multiplier).div"
            FunctionCall
               Type: uint256
               Source: "msg.value.mul(getPrice()).mul(multiplier)"
              MemberAccess to member mul
                 Type: function (uint256,uint256) returns (uint256)
                 Source: "msg.value.mul(getPrice()).mul"
                FunctionCall
                   Type: uint256
                   Source: "msg.value.mul(getPrice())"
                  MemberAccess to member mul
                     Type: function (uint256,uint256) returns (uint256)
                     Source: "msg.value.mul"
                    MemberAccess to member value
                       Type: uint256
                       Source: "msg.value"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                  FunctionCall
                     Type: uint256
                     Source: "getPrice()"
                    Identifier getPrice
                       Type: function () returns (uint256)
                       Source: "getPrice"
              Identifier multiplier
                 Type: uint256
                 Source: "multiplier"
          Literal, token: [no token] value: 1
             Type: int_const 1000000000000000000
             Source: "1 ether"
      ExpressionStatement
         Gas costs: 20247
         Source: "totalSupply = totalSupply.add(tokens)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = totalSupply.add(tokens)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "totalSupply.add(tokens)"
            MemberAccess to member add
               Type: function (uint256,uint256) returns (uint256)
               Source: "totalSupply.add"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
            Identifier tokens
               Type: uint256
               Source: "tokens"
      ExpressionStatement
         Gas costs: 20439
         Source: "balance[recipient] = balance[recipient].add(tokens)"
        Assignment using operator =
           Type: uint256
           Source: "balance[recipient] = balance[recipient].add(tokens)"
          IndexAccess
             Type: uint256
             Source: "balance[recipient]"
            Identifier balance
               Type: mapping(address => uint256)
               Source: "balance"
            Identifier recipient
               Type: address
               Source: "recipient"
          FunctionCall
             Type: uint256
             Source: "balance[recipient].add(tokens)"
            MemberAccess to member add
               Type: function (uint256,uint256) returns (uint256)
               Source: "balance[recipient].add"
              IndexAccess
                 Type: uint256
                 Source: "balance[recipient]"
                Identifier balance
                   Type: mapping(address => uint256)
                   Source: "balance"
                Identifier recipient
                   Type: address
                   Source: "recipient"
            Identifier tokens
               Type: uint256
               Source: "tokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(multiSigWallet.send(msg.value))"
        FunctionCall
           Type: tuple()
           Source: "require(multiSigWallet.send(msg.value))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "multiSigWallet.send(msg.value)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "multiSigWallet.send"
              Identifier multiSigWallet
                 Type: address
                 Source: "multiSigWallet"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(0, recipient, tokens)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(0, recipient, tokens)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Identifier recipient
             Type: address
             Source: "recipient"
          Identifier tokens
             Type: uint256
             Source: "tokens"
  FunctionDefinition "getPrice" - public
     Source: "function getPrice() returns (uint256 result) {\r\n        return price;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256 result)"
      VariableDeclaration "result"
         Type: uint256
         Source: "uint256 result"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return price;\r\n    }"
      Return
         Gas costs: 208
         Source: "return price"
        Identifier price
           Type: uint256
           Source: "price"
  FunctionDefinition "setMultiSigWallet" - public
     Source: "function setMultiSigWallet(address wallet) onlyOwner returns (bool success) {\r\n        multiSigWallet = wallet; \r\n        return true; \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address wallet)"
      VariableDeclaration "wallet"
         Type: address
         Source: "address wallet"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        multiSigWallet = wallet; \r\n        return true; \r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "multiSigWallet = wallet"
        Assignment using operator =
           Type: address
           Source: "multiSigWallet = wallet"
          Identifier multiSigWallet
             Type: address
             Source: "multiSigWallet"
          Identifier wallet
             Type: address
             Source: "wallet"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "setPrice" - public
     Source: "function setPrice(uint256 newPriceperEther) onlyOwner returns (uint256) {\r\n        require(newPriceperEther > 0); \r\n        price = newPriceperEther; \r\n        return price; \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 newPriceperEther)"
      VariableDeclaration "newPriceperEther"
         Type: uint256
         Source: "uint256 newPriceperEther"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(newPriceperEther > 0); \r\n        price = newPriceperEther; \r\n        return price; \r\n    }"
      ExpressionStatement
         Gas costs: 35
         Source: "require(newPriceperEther > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(newPriceperEther > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "newPriceperEther > 0"
            Identifier newPriceperEther
               Type: uint256
               Source: "newPriceperEther"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20014
         Source: "price = newPriceperEther"
        Assignment using operator =
           Type: uint256
           Source: "price = newPriceperEther"
          Identifier price
             Type: uint256
             Source: "price"
          Identifier newPriceperEther
             Type: uint256
             Source: "newPriceperEther"
      Return
         Gas costs: 208
         Source: "return price"
        Identifier price
           Type: uint256
           Source: "price"
  FunctionDefinition "startSale" - public
     Source: "function startSale(uint256 lengthOfSale) onlyOwner returns (bool success) {\r\n        deadline = now + lengthOfSale * 1 days; \r\n        crowdsaleClosed = false; \r\n        return true; \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 lengthOfSale)"
      VariableDeclaration "lengthOfSale"
         Type: uint256
         Source: "uint256 lengthOfSale"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        deadline = now + lengthOfSale * 1 days; \r\n        crowdsaleClosed = false; \r\n        return true; \r\n    }"
      ExpressionStatement
         Gas costs: 20027
         Source: "deadline = now + lengthOfSale * 1 days"
        Assignment using operator =
           Type: uint256
           Source: "deadline = now + lengthOfSale * 1 days"
          Identifier deadline
             Type: uint256
             Source: "deadline"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + lengthOfSale * 1 days"
            Identifier now
               Type: uint256
               Source: "now"
            BinaryOperation using operator *
               Type: uint256
               Source: "lengthOfSale * 1 days"
              Identifier lengthOfSale
                 Type: uint256
                 Source: "lengthOfSale"
              Literal, token: [no token] value: 1
                 Type: int_const 86400
                 Source: "1 days"
      ExpressionStatement
         Gas costs: 20267
         Source: "crowdsaleClosed = false"
        Assignment using operator =
           Type: bool
           Source: "crowdsaleClosed = false"
          Identifier crowdsaleClosed
             Type: bool
             Source: "crowdsaleClosed"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "stopSale" - public
     Source: "function stopSale() onlyOwner returns (bool success) {\r\n        deadline = now; \r\n        crowdsaleClosed = true;\r\n        return true; \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        deadline = now; \r\n        crowdsaleClosed = true;\r\n        return true; \r\n    }"
      ExpressionStatement
         Gas costs: 20013
         Source: "deadline = now"
        Assignment using operator =
           Type: uint256
           Source: "deadline = now"
          Identifier deadline
             Type: uint256
             Source: "deadline"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 20267
         Source: "crowdsaleClosed = true"
        Assignment using operator =
           Type: bool
           Source: "crowdsaleClosed = true"
          Identifier crowdsaleClosed
             Type: bool
             Source: "crowdsaleClosed"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
