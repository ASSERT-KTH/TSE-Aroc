Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x4523351ffb38850978e4e36250bfb452ba4a1241.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "Token"
   Gas costs: [???]
   Source: "contract Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "SafeMath"
   Source: "contract SafeMath {\r\n\r\n    /* function assert(bool assertion) internal { */\r\n    /*   if (!assertion) { */\r\n    /*     throw; */\r\n    /*   } */\r\n    /* }      // assert no longer needed once solidity is on 0.4.10 */\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }\r\n\r\n}"
  FunctionDefinition "safeAdd"
     Source: "function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 z = x + y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "x + y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
      ExpressionStatement
         Gas costs: 0
         Source: "assert((z >= x) && (z >= y))"
        FunctionCall
           Type: tuple()
           Source: "assert((z >= x) && (z >= y))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator &&
             Type: bool
             Source: "(z >= x) && (z >= y)"
            TupleExpression
               Type: bool
               Source: "(z >= x)"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "z >= x"
                Identifier z
                   Type: uint256
                   Source: "z"
                Identifier x
                   Type: uint256
                   Source: "x"
            TupleExpression
               Type: bool
               Source: "(z >= y)"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "z >= y"
                Identifier z
                   Type: uint256
                   Source: "z"
                Identifier y
                   Type: uint256
                   Source: "y"
      Return
         Gas costs: 0
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
  FunctionDefinition "safeSubtract"
     Source: "function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(x >= y)"
        FunctionCall
           Type: tuple()
           Source: "assert(x >= y)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "x >= y"
            Identifier x
               Type: uint256
               Source: "x"
            Identifier y
               Type: uint256
               Source: "y"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 z = x - y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator -
           Type: uint256
           Source: "x - y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
      Return
         Gas costs: 0
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
  FunctionDefinition "safeMult"
     Source: "function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint256 z = x * y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "x * y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
      ExpressionStatement
         Gas costs: 88
         Source: "assert((x == 0)||(z/x == y))"
        FunctionCall
           Type: tuple()
           Source: "assert((x == 0)||(z/x == y))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "(x == 0)||(z/x == y)"
            TupleExpression
               Type: bool
               Source: "(x == 0)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "x == 0"
                Identifier x
                   Type: uint256
                   Source: "x"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            TupleExpression
               Type: bool
               Source: "(z/x == y)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "z/x == y"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "z/x"
                  Identifier z
                     Type: uint256
                     Source: "z"
                  Identifier x
                     Type: uint256
                     Source: "x"
                Identifier y
                   Type: uint256
                   Source: "y"
      Return
         Gas costs: 8
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Token"
    UserDefinedTypeName "Token"
       Source: "Token"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }"
      IfStatement
         Source: "if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 338
           Source: "balances[msg.sender] >= _value && _value > 0"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
          BinaryOperation using operator >
             Type: bool
             Source: "_value > 0"
            Identifier _value
               Type: uint256
               Source: "_value"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 20328
             Source: "balances[msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20323
             Source: "balances[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balances[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(msg.sender, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(msg.sender, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{ return false; }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }"
      IfStatement
         Source: "if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 758
           Source: "balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0"
          BinaryOperation using operator &&
             Type: bool
             Source: "balances[_from] >= _value && allowed[_from][msg.sender] >= _value"
            BinaryOperation using operator >=
               Type: bool
               Source: "balances[_from] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            BinaryOperation using operator >=
               Type: bool
               Source: "allowed[_from][msg.sender] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          BinaryOperation using operator >
             Type: bool
             Source: "_value > 0"
            Identifier _value
               Type: uint256
               Source: "_value"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 20329
             Source: "balances[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balances[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20323
             Source: "balances[_from] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[_from] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20412
             Source: "allowed[_from][msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "allowed[_from][msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(_from, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(_from, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              Identifier _from
                 Type: address
                 Source: "_from"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{ return false; }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balances[_owner];\r\n    }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balances"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "Dil"
   Source: "contract Dil is StandardToken, SafeMath {\r\n\r\n    // metadata\r\n    string public constant name = \"\u0926\u093f\u0932\"; // Heart in Devnagari Script Hindi Language\r\n    string public constant symbol = \"\u2764\ufe0f\"; // Red heart emoji\r\n    uint256 public constant decimals = 0; // Whole tokens only\r\n    string public version = \"1.0\";\r\n\r\n    // important addresses\r\n    address public depositAddress;      // deposit address for ETH for ICO owner\r\n\r\n    // crowdsale params\r\n    bool public isFinalized;            // true when ICO finalized and successful\r\n    uint256 public targetEth;           // target ETH to raise\r\n    uint256 public fundingStartBlock;   // when to start allowing funding\r\n    uint256 public fundingEndBlock;     // when to stop allowing funding\r\n    \r\n    // events\r\n    event CreateDil(string _name);\r\n    event Contribute(address _sender, uint256 _value);\r\n    event FinalizeSale(address _sender);\r\n    event RefundContribution(address _sender, uint256 _value);\r\n    event ClaimTokens(address _sender, uint256 _value);\r\n\r\n    // calculated values\r\n    mapping (address => uint256) contributions;    // ETH contributed per address\r\n    uint256 contributed;      // total ETH contributed\r\n\r\n    // constructor\r\n    function Dil(){\r\n        isFinalized = false;\r\n        totalSupply = 1000000000; // 100 Crore total supply\r\n        targetEth = 1000 * 1000000000000000000; // Raising 1000 ETHER\r\n        depositAddress = 0xA94B12c128e7BA4ae59309763368FaCDD8Fb4E23; // Multiple Computer Co.\r\n        fundingStartBlock = 3999999;\r\n        fundingEndBlock = 4200000;\r\n        // log\r\n        CreateDil(name);}\r\n\r\n    /// Accepts ETH from a contributor\r\n    function contribute() payable external {\r\n        if (block.number < fundingStartBlock) throw;    // not yet begun?\r\n        if (block.number > fundingEndBlock) throw;      // already ended?\r\n        if (msg.value == 0) throw;                  // no ETH sent in?\r\n\r\n        // Add to contributions\r\n        contributions[msg.sender] += msg.value;\r\n        contributed += msg.value;\r\n        \r\n        // log\r\n        Contribute(msg.sender, msg.value);  // logs contribution\r\n    }\r\n\r\n    /// Finalizes the funding and sends the ETH to deposit address\r\n    function finalizeFunding() external {\r\n        if (isFinalized) throw;                       // already succeeded?\r\n        if (msg.sender != depositAddress) throw;      // wrong sender?\r\n        if (block.number <= fundingEndBlock) throw;   // not yet finished?\r\n        if (contributed < targetEth) throw;             // not enough raised?\r\n        \r\n        isFinalized = true;\r\n\r\n        // send to deposit address\r\n        if (!depositAddress.send(targetEth)) throw;\r\n        \r\n        // log\r\n        FinalizeSale(msg.sender);\r\n    }\r\n    \r\n    /// Allows contributors to claim their tokens and/or a refund. If funding failed then they get back all their Ether, otherwise they get back any excess Ether\r\n    function claimTokensAndRefund() external {\r\n        if (0 == contributions[msg.sender]) throw;    // must have previously contributed\r\n        if (block.number < fundingEndBlock) throw;    // not yet done?\r\n      \r\n        // if not enough funding\r\n        if (contributed < targetEth) {\r\n            // refund my full contribution\r\n            if (!msg.sender.send(contributions[msg.sender])) throw;\r\n            RefundContribution(msg.sender, contributions[msg.sender]);\r\n        } else {\r\n            // calculate how many tokens I get\r\n            balances[msg.sender] = safeMult(totalSupply, contributions[msg.sender]) / contributed;\r\n            // refund excess ETH\r\n            if (!msg.sender.send(contributions[msg.sender] - (safeMult(targetEth, contributions[msg.sender]) / contributed))) throw;\r\n            ClaimTokens(msg.sender, balances[msg.sender]);\r\n      }\r\n      \r\n      contributions[msg.sender] = 0;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  VariableDeclaration "name"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant name = \"\u0926\u093f\u0932\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: दिल
       Type: literal_string "दिल"
       Source: "\"\u0926\u093f\u0932\""
  VariableDeclaration "symbol"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant symbol = \"\u2764\ufe0f\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: ❤️
       Type: literal_string "❤️"
       Source: "\"\u2764\ufe0f\""
  VariableDeclaration "decimals"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant decimals = 0"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "version"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public version = \"1.0\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: 1.0
       Type: literal_string "1.0"
       Source: "\"1.0\""
  VariableDeclaration "depositAddress"
     Type: address
     Gas costs: [???]
     Source: "address public depositAddress"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "isFinalized"
     Type: bool
     Gas costs: [???]
     Source: "bool public isFinalized"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "targetEth"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public targetEth"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "fundingStartBlock"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public fundingStartBlock"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "fundingEndBlock"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public fundingEndBlock"
    ElementaryTypeName uint256
       Source: "uint256"
  EventDefinition "CreateDil"
     Gas costs: 0
     Source: "event CreateDil(string _name);"
    ParameterList
       Source: "(string _name)"
      VariableDeclaration "_name"
         Type: string memory
         Source: "string _name"
        ElementaryTypeName string
           Source: "string"
  EventDefinition "Contribute"
     Gas costs: 0
     Source: "event Contribute(address _sender, uint256 _value);"
    ParameterList
       Source: "(address _sender, uint256 _value)"
      VariableDeclaration "_sender"
         Type: address
         Source: "address _sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "FinalizeSale"
     Gas costs: 0
     Source: "event FinalizeSale(address _sender);"
    ParameterList
       Source: "(address _sender)"
      VariableDeclaration "_sender"
         Type: address
         Source: "address _sender"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "RefundContribution"
     Gas costs: 0
     Source: "event RefundContribution(address _sender, uint256 _value);"
    ParameterList
       Source: "(address _sender, uint256 _value)"
      VariableDeclaration "_sender"
         Type: address
         Source: "address _sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "ClaimTokens"
     Gas costs: 0
     Source: "event ClaimTokens(address _sender, uint256 _value);"
    ParameterList
       Source: "(address _sender, uint256 _value)"
      VariableDeclaration "_sender"
         Type: address
         Source: "address _sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "contributions"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) contributions"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "contributed"
     Type: uint256
     Gas costs: 0
     Source: "uint256 contributed"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "Dil" - public
     Source: "function Dil(){\r\n        isFinalized = false;\r\n        totalSupply = 1000000000; // 100 Crore total supply\r\n        targetEth = 1000 * 1000000000000000000; // Raising 1000 ETHER\r\n        depositAddress = 0xA94B12c128e7BA4ae59309763368FaCDD8Fb4E23; // Multiple Computer Co.\r\n        fundingStartBlock = 3999999;\r\n        fundingEndBlock = 4200000;\r\n        // log\r\n        CreateDil(name);}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        isFinalized = false;\r\n        totalSupply = 1000000000; // 100 Crore total supply\r\n        targetEth = 1000 * 1000000000000000000; // Raising 1000 ETHER\r\n        depositAddress = 0xA94B12c128e7BA4ae59309763368FaCDD8Fb4E23; // Multiple Computer Co.\r\n        fundingStartBlock = 3999999;\r\n        fundingEndBlock = 4200000;\r\n        // log\r\n        CreateDil(name);}"
      ExpressionStatement
         Gas costs: 0
         Source: "isFinalized = false"
        Assignment using operator =
           Type: bool
           Source: "isFinalized = false"
          Identifier isFinalized
             Type: bool
             Source: "isFinalized"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = 1000000000"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = 1000000000"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Literal, token: [no token] value: 1000000000
             Type: int_const 1000000000
             Source: "1000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "targetEth = 1000 * 1000000000000000000"
        Assignment using operator =
           Type: uint256
           Source: "targetEth = 1000 * 1000000000000000000"
          Identifier targetEth
             Type: uint256
             Source: "targetEth"
          BinaryOperation using operator *
             Type: int_const 1000000000000000000000
             Source: "1000 * 1000000000000000000"
            Literal, token: [no token] value: 1000
               Type: int_const 1000
               Source: "1000"
            Literal, token: [no token] value: 1000000000000000000
               Type: int_const 1000000000000000000
               Source: "1000000000000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "depositAddress = 0xA94B12c128e7BA4ae59309763368FaCDD8Fb4E23"
        Assignment using operator =
           Type: address
           Source: "depositAddress = 0xA94B12c128e7BA4ae59309763368FaCDD8Fb4E23"
          Identifier depositAddress
             Type: address
             Source: "depositAddress"
          Literal, token: [no token] value: 0xA94B12c128e7BA4ae59309763368FaCDD8Fb4E23
             Type: address
             Source: "0xA94B12c128e7BA4ae59309763368FaCDD8Fb4E23"
      ExpressionStatement
         Gas costs: 0
         Source: "fundingStartBlock = 3999999"
        Assignment using operator =
           Type: uint256
           Source: "fundingStartBlock = 3999999"
          Identifier fundingStartBlock
             Type: uint256
             Source: "fundingStartBlock"
          Literal, token: [no token] value: 3999999
             Type: int_const 3999999
             Source: "3999999"
      ExpressionStatement
         Gas costs: 0
         Source: "fundingEndBlock = 4200000"
        Assignment using operator =
           Type: uint256
           Source: "fundingEndBlock = 4200000"
          Identifier fundingEndBlock
             Type: uint256
             Source: "fundingEndBlock"
          Literal, token: [no token] value: 4200000
             Type: int_const 4200000
             Source: "4200000"
      ExpressionStatement
         Gas costs: 0
         Source: "CreateDil(name)"
        FunctionCall
           Type: tuple()
           Source: "CreateDil(name)"
          Identifier CreateDil
             Type: function (string memory)
             Source: "CreateDil"
          Identifier name
             Type: string memory
             Source: "name"
  FunctionDefinition "contribute" - public
     Source: "function contribute() payable external {\r\n        if (block.number < fundingStartBlock) throw;    // not yet begun?\r\n        if (block.number > fundingEndBlock) throw;      // already ended?\r\n        if (msg.value == 0) throw;                  // no ETH sent in?\r\n\r\n        // Add to contributions\r\n        contributions[msg.sender] += msg.value;\r\n        contributed += msg.value;\r\n        \r\n        // log\r\n        Contribute(msg.sender, msg.value);  // logs contribution\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (block.number < fundingStartBlock) throw;    // not yet begun?\r\n        if (block.number > fundingEndBlock) throw;      // already ended?\r\n        if (msg.value == 0) throw;                  // no ETH sent in?\r\n\r\n        // Add to contributions\r\n        contributions[msg.sender] += msg.value;\r\n        contributed += msg.value;\r\n        \r\n        // log\r\n        Contribute(msg.sender, msg.value);  // logs contribution\r\n    }"
      IfStatement
         Source: "if (block.number < fundingStartBlock) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 208
           Source: "block.number < fundingStartBlock"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          Identifier fundingStartBlock
             Type: uint256
             Source: "fundingStartBlock"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (block.number > fundingEndBlock) throw"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 208
           Source: "block.number > fundingEndBlock"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          Identifier fundingEndBlock
             Type: uint256
             Source: "fundingEndBlock"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (msg.value == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 8
           Source: "msg.value == 0"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20327
         Source: "contributions[msg.sender] += msg.value"
        Assignment using operator +=
           Type: uint256
           Source: "contributions[msg.sender] += msg.value"
          IndexAccess
             Type: uint256
             Source: "contributions[msg.sender]"
            Identifier contributions
               Type: mapping(address => uint256)
               Source: "contributions"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20232
         Source: "contributed += msg.value"
        Assignment using operator +=
           Type: uint256
           Source: "contributed += msg.value"
          Identifier contributed
             Type: uint256
             Source: "contributed"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: [???]
         Source: "Contribute(msg.sender, msg.value)"
        FunctionCall
           Type: tuple()
           Source: "Contribute(msg.sender, msg.value)"
          Identifier Contribute
             Type: function (address,uint256)
             Source: "Contribute"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "finalizeFunding" - public
     Source: "function finalizeFunding() external {\r\n        if (isFinalized) throw;                       // already succeeded?\r\n        if (msg.sender != depositAddress) throw;      // wrong sender?\r\n        if (block.number <= fundingEndBlock) throw;   // not yet finished?\r\n        if (contributed < targetEth) throw;             // not enough raised?\r\n        \r\n        isFinalized = true;\r\n\r\n        // send to deposit address\r\n        if (!depositAddress.send(targetEth)) throw;\r\n        \r\n        // log\r\n        FinalizeSale(msg.sender);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (isFinalized) throw;                       // already succeeded?\r\n        if (msg.sender != depositAddress) throw;      // wrong sender?\r\n        if (block.number <= fundingEndBlock) throw;   // not yet finished?\r\n        if (contributed < targetEth) throw;             // not enough raised?\r\n        \r\n        isFinalized = true;\r\n\r\n        // send to deposit address\r\n        if (!depositAddress.send(targetEth)) throw;\r\n        \r\n        // log\r\n        FinalizeSale(msg.sender);\r\n    }"
      IfStatement
         Source: "if (isFinalized) throw"
        Identifier isFinalized
           Type: bool
           Gas costs: 289
           Source: "isFinalized"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (msg.sender != depositAddress) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != depositAddress"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier depositAddress
             Type: address
             Source: "depositAddress"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (block.number <= fundingEndBlock) throw"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 211
           Source: "block.number <= fundingEndBlock"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          Identifier fundingEndBlock
             Type: uint256
             Source: "fundingEndBlock"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (contributed < targetEth) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 409
           Source: "contributed < targetEth"
          Identifier contributed
             Type: uint256
             Source: "contributed"
          Identifier targetEth
             Type: uint256
             Source: "targetEth"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20317
         Source: "isFinalized = true"
        Assignment using operator =
           Type: bool
           Source: "isFinalized = true"
          Identifier isFinalized
             Type: bool
             Source: "isFinalized"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      IfStatement
         Source: "if (!depositAddress.send(targetEth)) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!depositAddress.send(targetEth)"
          FunctionCall
             Type: bool
             Source: "depositAddress.send(targetEth)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "depositAddress.send"
              Identifier depositAddress
                 Type: address
                 Source: "depositAddress"
            Identifier targetEth
               Type: uint256
               Source: "targetEth"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: [???]
         Source: "FinalizeSale(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "FinalizeSale(msg.sender)"
          Identifier FinalizeSale
             Type: function (address)
             Source: "FinalizeSale"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "claimTokensAndRefund" - public
     Source: "function claimTokensAndRefund() external {\r\n        if (0 == contributions[msg.sender]) throw;    // must have previously contributed\r\n        if (block.number < fundingEndBlock) throw;    // not yet done?\r\n      \r\n        // if not enough funding\r\n        if (contributed < targetEth) {\r\n            // refund my full contribution\r\n            if (!msg.sender.send(contributions[msg.sender])) throw;\r\n            RefundContribution(msg.sender, contributions[msg.sender]);\r\n        } else {\r\n            // calculate how many tokens I get\r\n            balances[msg.sender] = safeMult(totalSupply, contributions[msg.sender]) / contributed;\r\n            // refund excess ETH\r\n            if (!msg.sender.send(contributions[msg.sender] - (safeMult(targetEth, contributions[msg.sender]) / contributed))) throw;\r\n            ClaimTokens(msg.sender, balances[msg.sender]);\r\n      }\r\n      \r\n      contributions[msg.sender] = 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (0 == contributions[msg.sender]) throw;    // must have previously contributed\r\n        if (block.number < fundingEndBlock) throw;    // not yet done?\r\n      \r\n        // if not enough funding\r\n        if (contributed < targetEth) {\r\n            // refund my full contribution\r\n            if (!msg.sender.send(contributions[msg.sender])) throw;\r\n            RefundContribution(msg.sender, contributions[msg.sender]);\r\n        } else {\r\n            // calculate how many tokens I get\r\n            balances[msg.sender] = safeMult(totalSupply, contributions[msg.sender]) / contributed;\r\n            // refund excess ETH\r\n            if (!msg.sender.send(contributions[msg.sender] - (safeMult(targetEth, contributions[msg.sender]) / contributed))) throw;\r\n            ClaimTokens(msg.sender, balances[msg.sender]);\r\n      }\r\n      \r\n      contributions[msg.sender] = 0;\r\n    }"
      IfStatement
         Source: "if (0 == contributions[msg.sender]) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 304
           Source: "0 == contributions[msg.sender]"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          IndexAccess
             Type: uint256
             Source: "contributions[msg.sender]"
            Identifier contributions
               Type: mapping(address => uint256)
               Source: "contributions"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (block.number < fundingEndBlock) throw"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 208
           Source: "block.number < fundingEndBlock"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          Identifier fundingEndBlock
             Type: uint256
             Source: "fundingEndBlock"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (contributed < targetEth) {\r\n            // refund my full contribution\r\n            if (!msg.sender.send(contributions[msg.sender])) throw;\r\n            RefundContribution(msg.sender, contributions[msg.sender]);\r\n        } else {\r\n            // calculate how many tokens I get\r\n            balances[msg.sender] = safeMult(totalSupply, contributions[msg.sender]) / contributed;\r\n            // refund excess ETH\r\n            if (!msg.sender.send(contributions[msg.sender] - (safeMult(targetEth, contributions[msg.sender]) / contributed))) throw;\r\n            ClaimTokens(msg.sender, balances[msg.sender]);\r\n      }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 409
           Source: "contributed < targetEth"
          Identifier contributed
             Type: uint256
             Source: "contributed"
          Identifier targetEth
             Type: uint256
             Source: "targetEth"
        Block
           Source: "{\r\n            // refund my full contribution\r\n            if (!msg.sender.send(contributions[msg.sender])) throw;\r\n            RefundContribution(msg.sender, contributions[msg.sender]);\r\n        }"
          IfStatement
             Source: "if (!msg.sender.send(contributions[msg.sender])) throw"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: [???]
               Source: "!msg.sender.send(contributions[msg.sender])"
              FunctionCall
                 Type: bool
                 Source: "msg.sender.send(contributions[msg.sender])"
                MemberAccess to member send
                   Type: function (uint256) returns (bool)
                   Source: "msg.sender.send"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                IndexAccess
                   Type: uint256
                   Source: "contributions[msg.sender]"
                  Identifier contributions
                     Type: mapping(address => uint256)
                     Source: "contributions"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
            Throw
               Gas costs: 6
               Source: "throw"
          ExpressionStatement
             Gas costs: [???]
             Source: "RefundContribution(msg.sender, contributions[msg.sender])"
            FunctionCall
               Type: tuple()
               Source: "RefundContribution(msg.sender, contributions[msg.sender])"
              Identifier RefundContribution
                 Type: function (address,uint256)
                 Source: "RefundContribution"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              IndexAccess
                 Type: uint256
                 Source: "contributions[msg.sender]"
                Identifier contributions
                   Type: mapping(address => uint256)
                   Source: "contributions"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
        Block
           Source: "{\r\n            // calculate how many tokens I get\r\n            balances[msg.sender] = safeMult(totalSupply, contributions[msg.sender]) / contributed;\r\n            // refund excess ETH\r\n            if (!msg.sender.send(contributions[msg.sender] - (safeMult(targetEth, contributions[msg.sender]) / contributed))) throw;\r\n            ClaimTokens(msg.sender, balances[msg.sender]);\r\n      }"
          ExpressionStatement
             Gas costs: 20842
             Source: "balances[msg.sender] = safeMult(totalSupply, contributions[msg.sender]) / contributed"
            Assignment using operator =
               Type: uint256
               Source: "balances[msg.sender] = safeMult(totalSupply, contributions[msg.sender]) / contributed"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "safeMult(totalSupply, contributions[msg.sender]) / contributed"
                FunctionCall
                   Type: uint256
                   Source: "safeMult(totalSupply, contributions[msg.sender])"
                  Identifier safeMult
                     Type: function (uint256,uint256) returns (uint256)
                     Source: "safeMult"
                  Identifier totalSupply
                     Type: uint256
                     Source: "totalSupply"
                  IndexAccess
                     Type: uint256
                     Source: "contributions[msg.sender]"
                    Identifier contributions
                       Type: mapping(address => uint256)
                       Source: "contributions"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                Identifier contributed
                   Type: uint256
                   Source: "contributed"
          IfStatement
             Source: "if (!msg.sender.send(contributions[msg.sender] - (safeMult(targetEth, contributions[msg.sender]) / contributed))) throw"
            UnaryOperation (prefix) !
               Type: bool
               Gas costs: [???]
               Source: "!msg.sender.send(contributions[msg.sender] - (safeMult(targetEth, contributions[msg.sender]) / contributed))"
              FunctionCall
                 Type: bool
                 Source: "msg.sender.send(contributions[msg.sender] - (safeMult(targetEth, contributions[msg.sender]) / contributed))"
                MemberAccess to member send
                   Type: function (uint256) returns (bool)
                   Source: "msg.sender.send"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "contributions[msg.sender] - (safeMult(targetEth, contributions[msg.sender]) / contributed)"
                  IndexAccess
                     Type: uint256
                     Source: "contributions[msg.sender]"
                    Identifier contributions
                       Type: mapping(address => uint256)
                       Source: "contributions"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                  TupleExpression
                     Type: uint256
                     Source: "(safeMult(targetEth, contributions[msg.sender]) / contributed)"
                    BinaryOperation using operator /
                       Type: uint256
                       Source: "safeMult(targetEth, contributions[msg.sender]) / contributed"
                      FunctionCall
                         Type: uint256
                         Source: "safeMult(targetEth, contributions[msg.sender])"
                        Identifier safeMult
                           Type: function (uint256,uint256) returns (uint256)
                           Source: "safeMult"
                        Identifier targetEth
                           Type: uint256
                           Source: "targetEth"
                        IndexAccess
                           Type: uint256
                           Source: "contributions[msg.sender]"
                          Identifier contributions
                             Type: mapping(address => uint256)
                             Source: "contributions"
                          MemberAccess to member sender
                             Type: address
                             Source: "msg.sender"
                            Identifier msg
                               Type: msg
                               Source: "msg"
                      Identifier contributed
                         Type: uint256
                         Source: "contributed"
            Throw
               Gas costs: 6
               Source: "throw"
          ExpressionStatement
             Gas costs: [???]
             Source: "ClaimTokens(msg.sender, balances[msg.sender])"
            FunctionCall
               Type: tuple()
               Source: "ClaimTokens(msg.sender, balances[msg.sender])"
              Identifier ClaimTokens
                 Type: function (address,uint256)
                 Source: "ClaimTokens"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
      ExpressionStatement
         Gas costs: 5109
         Source: "contributions[msg.sender] = 0"
        Assignment using operator =
           Type: uint256
           Source: "contributions[msg.sender] = 0"
          IndexAccess
             Type: uint256
             Source: "contributions[msg.sender]"
            Identifier contributions
               Type: mapping(address => uint256)
               Source: "contributions"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
