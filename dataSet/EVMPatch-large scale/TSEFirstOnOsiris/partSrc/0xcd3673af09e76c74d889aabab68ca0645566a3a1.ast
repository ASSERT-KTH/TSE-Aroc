Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xcd3673af09e76c74d889aabab68ca0645566a3a1.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "owned"
   Source: "contract owned {\r\n    address public owner;\r\n \r\n    function owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "owned" - public
     Source: "function owned() public {\r\n        owner = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 564
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        owner = newOwner;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
ContractDefinition "tokenRecipient"
   Gas costs: 0
   Source: "interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }"
  FunctionDefinition "receiveApproval" - public
     Source: "function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;"
    ParameterList
       Source: "(address _from, uint256 _value, address _token, bytes _extraData)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: ""
ContractDefinition "CandyCoin"
   Source: "contract CandyCoin is owned {\r\n    // Public variables of the token\r\n    string public name = \"Unicorn Candy Coin\";\r\n    string public symbol = \"Candy\";\r\n    uint8 public decimals = 18;\r\n    // 18 decimals is the strongly suggested default, avoid changing it\r\n    uint256 public totalSupply = 12000000000000000000000000;\r\n    address public crowdsaleContract;\r\n\r\n    uint sendingBanPeriod = 1519776000;           // 28.02.2018\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n    \r\n    modifier canSend() {\r\n        require ( msg.sender == owner ||  now > sendingBanPeriod || msg.sender == crowdsaleContract);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Constrctor function\r\n     */\r\n    function CandyCoin(\r\n    ) public {\r\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\r\n    }\r\n    \r\n    function setCrowdsaleContract(address contractAddress) onlyOwner {\r\n        crowdsaleContract = contractAddress;\r\n    }\r\n     \r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balanceOf[_from] >= _value);\r\n        // Check for overflows\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        // Subtract from the sender\r\n        balanceOf[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public canSend {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` in behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public canSend returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "owned"
    UserDefinedTypeName "owned"
       Source: "owned"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: 0
     Source: "string public name = \"Unicorn Candy Coin\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Unicorn Candy Coin
       Type: literal_string "Unicorn Candy Coin"
       Source: "\"Unicorn Candy Coin\""
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: 0
     Source: "string public symbol = \"Candy\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Candy
       Type: literal_string "Candy"
       Source: "\"Candy\""
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: 0
     Source: "uint8 public decimals = 18"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "totalSupply"
     Type: uint256
     Gas costs: 0
     Source: "uint256 public totalSupply = 12000000000000000000000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 12000000000000000000000000
       Type: int_const 12000000000000000000000000
       Source: "12000000000000000000000000"
  VariableDeclaration "crowdsaleContract"
     Type: address
     Gas costs: 0
     Source: "address public crowdsaleContract"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "sendingBanPeriod"
     Type: uint256
     Gas costs: 0
     Source: "uint sendingBanPeriod = 1519776000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1519776000
       Type: int_const 1519776000
       Source: "1519776000"
  VariableDeclaration "balanceOf"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) public balanceOf"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowance"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) public allowance"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Gas costs: 0
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Burn"
     Gas costs: 0
     Source: "event Burn(address indexed from, uint256 value);"
    ParameterList
       Source: "(address indexed from, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  ModifierDefinition "canSend"
     Source: "modifier canSend() {\r\n        require ( msg.sender == owner ||  now > sendingBanPeriod || msg.sender == crowdsaleContract);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require ( msg.sender == owner ||  now > sendingBanPeriod || msg.sender == crowdsaleContract);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require ( msg.sender == owner ||  now > sendingBanPeriod || msg.sender == crowdsaleContract)"
        FunctionCall
           Type: tuple()
           Source: "require ( msg.sender == owner ||  now > sendingBanPeriod || msg.sender == crowdsaleContract)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "msg.sender == owner ||  now > sendingBanPeriod || msg.sender == crowdsaleContract"
            BinaryOperation using operator ||
               Type: bool
               Source: "msg.sender == owner ||  now > sendingBanPeriod"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "msg.sender == owner"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Identifier owner
                   Type: address
                   Source: "owner"
              BinaryOperation using operator >
                 Type: bool
                 Source: "now > sendingBanPeriod"
                Identifier now
                   Type: uint256
                   Source: "now"
                Identifier sendingBanPeriod
                   Type: uint256
                   Source: "sendingBanPeriod"
            BinaryOperation using operator ==
               Type: bool
               Source: "msg.sender == crowdsaleContract"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier crowdsaleContract
                 Type: address
                 Source: "crowdsaleContract"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "CandyCoin" - public
     Source: "function CandyCoin(\r\n    ) public {\r\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n    )"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "balanceOf[msg.sender] = totalSupply"
        Assignment using operator =
           Type: uint256
           Source: "balanceOf[msg.sender] = totalSupply"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
  FunctionDefinition "setCrowdsaleContract" - public
     Source: "function setCrowdsaleContract(address contractAddress) onlyOwner {\r\n        crowdsaleContract = contractAddress;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address contractAddress)"
      VariableDeclaration "contractAddress"
         Type: address
         Source: "address contractAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        crowdsaleContract = contractAddress;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "crowdsaleContract = contractAddress"
        Assignment using operator =
           Type: address
           Source: "crowdsaleContract = contractAddress"
          Identifier crowdsaleContract
             Type: address
             Source: "crowdsaleContract"
          Identifier contractAddress
             Type: address
             Source: "contractAddress"
  FunctionDefinition "_transfer"
     Source: "function _transfer(address _from, address _to, uint _value) internal {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balanceOf[_from] >= _value);\r\n        // Check for overflows\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        // Subtract from the sender\r\n        balanceOf[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balanceOf[_from] >= _value);\r\n        // Check for overflows\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        // Subtract from the sender\r\n        balanceOf[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_to != 0x0)"
        FunctionCall
           Type: tuple()
           Source: "require(_to != 0x0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != 0x0"
            Identifier _to
               Type: address
               Source: "_to"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balanceOf[_from] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balanceOf[_from] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balanceOf[_from] >= _value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_from]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balanceOf[_to] + _value > balanceOf[_to])"
        FunctionCall
           Type: tuple()
           Source: "require(balanceOf[_to] + _value > balanceOf[_to])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balanceOf[_to] + _value > balanceOf[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balanceOf[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[_to]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_to]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _to
                 Type: address
                 Source: "_to"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint previousBalances = balanceOf[_from] + balanceOf[_to]"
        VariableDeclaration "previousBalances"
           Type: uint256
           Source: "uint previousBalances"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "balanceOf[_from] + balanceOf[_to]"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_from]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _from
               Type: address
               Source: "_from"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_to]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _to
               Type: address
               Source: "_to"
      ExpressionStatement
         Gas costs: 0
         Source: "balanceOf[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_from]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balanceOf[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_to]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(balanceOf[_from] + balanceOf[_to] == previousBalances)"
        FunctionCall
           Type: tuple()
           Source: "assert(balanceOf[_from] + balanceOf[_to] == previousBalances)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "balanceOf[_from] + balanceOf[_to] == previousBalances"
            BinaryOperation using operator +
               Type: uint256
               Source: "balanceOf[_from] + balanceOf[_to]"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[_from]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                Identifier _from
                   Type: address
                   Source: "_from"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[_to]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier previousBalances
               Type: uint256
               Source: "previousBalances"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public canSend {\r\n        _transfer(msg.sender, _to, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "canSend"
       Gas costs: 0
       Source: "canSend"
      Identifier canSend
         Type: modifier ()
         Source: "canSend"
    Block
       Source: "{\r\n        _transfer(msg.sender, _to, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "_transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "_transfer(msg.sender, _to, _value)"
          Identifier _transfer
             Type: function (address,address,uint256)
             Source: "_transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public canSend returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "canSend"
       Gas costs: 0
       Source: "canSend"
      Identifier canSend
         Type: modifier ()
         Source: "canSend"
    Block
       Source: "{\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_value <= allowance[_from][msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= allowance[_from][msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= allowance[_from][msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "allowance[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowance[_from]"
                Identifier allowance
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowance"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "allowance[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowance[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowance[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowance[_from]"
              Identifier allowance
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowance"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "_transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "_transfer(_from, _to, _value)"
          Identifier _transfer
             Type: function (address,address,uint256)
             Source: "_transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "allowance[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowance[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowance[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowance[msg.sender]"
              Identifier allowance
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowance"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approveAndCall" - public
     Source: "function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value, bytes _extraData)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "tokenRecipient spender = tokenRecipient(_spender)"
        VariableDeclaration "spender"
           Type: contract tokenRecipient
           Source: "tokenRecipient spender"
          UserDefinedTypeName "tokenRecipient"
             Source: "tokenRecipient"
        FunctionCall
           Type: contract tokenRecipient
           Source: "tokenRecipient(_spender)"
          Identifier tokenRecipient
             Type: type(contract tokenRecipient)
             Source: "tokenRecipient"
          Identifier _spender
             Type: address
             Source: "_spender"
      IfStatement
         Source: "if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 0
           Source: "approve(_spender, _value)"
          Identifier approve
             Type: function (address,uint256) returns (bool)
             Source: "approve"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
        Block
           Source: "{\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "spender.receiveApproval(msg.sender, _value, this, _extraData)"
            FunctionCall
               Type: tuple()
               Source: "spender.receiveApproval(msg.sender, _value, this, _extraData)"
              MemberAccess to member receiveApproval
                 Type: function (address,uint256,address,bytes memory) external
                 Source: "spender.receiveApproval"
                Identifier spender
                   Type: contract tokenRecipient
                   Source: "spender"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier this
                 Type: contract CandyCoin
                 Source: "this"
              Identifier _extraData
                 Type: bytes memory
                 Source: "_extraData"
          Return
             Gas costs: 0
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
  FunctionDefinition "burn" - public
     Source: "function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _value)"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balanceOf[msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balanceOf[msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balanceOf[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[msg.sender]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balanceOf[msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= _value"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Burn(msg.sender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Burn(msg.sender, _value)"
          Identifier Burn
             Type: function (address,uint256)
             Source: "Burn"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "burnFrom" - public
     Source: "function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balanceOf[_from] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balanceOf[_from] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balanceOf[_from] >= _value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_from]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_value <= allowance[_from][msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= allowance[_from][msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= allowance[_from][msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "allowance[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowance[_from]"
                Identifier allowance
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowance"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "balanceOf[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_from]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "allowance[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowance[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowance[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowance[_from]"
              Identifier allowance
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowance"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= _value"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Burn(_from, _value)"
        FunctionCall
           Type: tuple()
           Source: "Burn(_from, _value)"
          Identifier Burn
             Type: function (address,uint256)
             Source: "Burn"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
ContractDefinition "CandySale"
   Source: "contract CandySale is owned {\r\n    \r\n    address public teamWallet = address(0x7Bd19c5Fa45c5631Aa7EFE2Bf8Aa6c220272694F);\r\n\r\n    uint public fundingGoal;\r\n    uint public amountRaised;\r\n    // sale periods\r\n    uint public beginTime = now;\r\n    uint public stage2BeginTime = 1517529600;   // 2.02.2018 \r\n    uint public stage3BeginTime = 1518393600;   // 12.02.2018\r\n    uint public stage4BeginTime = 1519257600;   // 22.02.2018 \r\n    uint public endTime = 1519776000;           // 28.02.2018\r\n\r\n    CandyCoin public tokenReward;\r\n\r\n    event FundTransfer(address backer, uint amount, bool isContribution);\r\n\r\n    /**\r\n     * Constrctor function\r\n     *\r\n     * Setup the owner\r\n     */\r\n    function CandySale(\r\n        CandyCoin addressOfTokenUsedAsReward\r\n    ) {\r\n        tokenReward = addressOfTokenUsedAsReward;\r\n    }\r\n    \r\n    // withdraw tokens from contract\r\n    function withdrawTokens() onlyOwner {\r\n        tokenReward.transfer(msg.sender, tokenReward.balanceOf(this));\r\n        FundTransfer(msg.sender, tokenReward.balanceOf(this), false);\r\n    }\r\n\r\n    function currentPrice() constant returns (uint) {\r\n        if ( now <= stage2BeginTime ) return 100 szabo;\r\n        if ( now > stage2BeginTime && now <= stage3BeginTime) return 500 szabo;\r\n        if ( now > stage3BeginTime && now <= stage4BeginTime) return 1000 szabo;\r\n        if ( now > stage4BeginTime ) return 1500 szabo;\r\n    }\r\n    \r\n    // low level token purchase function\r\n    function buyTokens(address beneficiary) payable {\r\n        require(msg.value > 0);\r\n        uint amount = msg.value;\r\n        amountRaised += amount;\r\n        tokenReward.transfer(beneficiary, amount*1000000000000000000/currentPrice());\r\n        FundTransfer(beneficiary, amount, true);\r\n        teamWallet.transfer(msg.value);\r\n\r\n    }\r\n\r\n    /**\r\n     * Fallback function\r\n     *\r\n     * The function without name is the default function that is called whenever anyone sends funds to a contract\r\n     */\r\n    function () payable onlyCrowdsalePeriod {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    modifier onlyCrowdsalePeriod() { \r\n        require ( now >= beginTime && now <= endTime ) ;\r\n        _; \r\n    }\r\n\r\n    \r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "owned"
    UserDefinedTypeName "owned"
       Source: "owned"
  VariableDeclaration "teamWallet"
     Type: address
     Gas costs: [???]
     Source: "address public teamWallet = address(0x7Bd19c5Fa45c5631Aa7EFE2Bf8Aa6c220272694F)"
    ElementaryTypeName address
       Source: "address"
    FunctionCall
       Type: address
       Source: "address(0x7Bd19c5Fa45c5631Aa7EFE2Bf8Aa6c220272694F)"
      ElementaryTypeNameExpression address
         Type: type(address)
         Source: "address"
      Literal, token: [no token] value: 0x7Bd19c5Fa45c5631Aa7EFE2Bf8Aa6c220272694F
         Type: address
         Source: "0x7Bd19c5Fa45c5631Aa7EFE2Bf8Aa6c220272694F"
  VariableDeclaration "fundingGoal"
     Type: uint256
     Gas costs: [???]
     Source: "uint public fundingGoal"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "amountRaised"
     Type: uint256
     Gas costs: [???]
     Source: "uint public amountRaised"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "beginTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint public beginTime = now"
    ElementaryTypeName uint
       Source: "uint"
    Identifier now
       Type: uint256
       Source: "now"
  VariableDeclaration "stage2BeginTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint public stage2BeginTime = 1517529600"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1517529600
       Type: int_const 1517529600
       Source: "1517529600"
  VariableDeclaration "stage3BeginTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint public stage3BeginTime = 1518393600"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1518393600
       Type: int_const 1518393600
       Source: "1518393600"
  VariableDeclaration "stage4BeginTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint public stage4BeginTime = 1519257600"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1519257600
       Type: int_const 1519257600
       Source: "1519257600"
  VariableDeclaration "endTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint public endTime = 1519776000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1519776000
       Type: int_const 1519776000
       Source: "1519776000"
  VariableDeclaration "tokenReward"
     Type: contract CandyCoin
     Gas costs: [???]
     Source: "CandyCoin public tokenReward"
    UserDefinedTypeName "CandyCoin"
       Source: "CandyCoin"
  EventDefinition "FundTransfer"
     Gas costs: 0
     Source: "event FundTransfer(address backer, uint amount, bool isContribution);"
    ParameterList
       Source: "(address backer, uint amount, bool isContribution)"
      VariableDeclaration "backer"
         Type: address
         Source: "address backer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "isContribution"
         Type: bool
         Source: "bool isContribution"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "CandySale" - public
     Source: "function CandySale(\r\n        CandyCoin addressOfTokenUsedAsReward\r\n    ) {\r\n        tokenReward = addressOfTokenUsedAsReward;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        CandyCoin addressOfTokenUsedAsReward\r\n    )"
      VariableDeclaration "addressOfTokenUsedAsReward"
         Type: contract CandyCoin
         Source: "CandyCoin addressOfTokenUsedAsReward"
        UserDefinedTypeName "CandyCoin"
           Source: "CandyCoin"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        tokenReward = addressOfTokenUsedAsReward;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenReward = addressOfTokenUsedAsReward"
        Assignment using operator =
           Type: contract CandyCoin
           Source: "tokenReward = addressOfTokenUsedAsReward"
          Identifier tokenReward
             Type: contract CandyCoin
             Source: "tokenReward"
          Identifier addressOfTokenUsedAsReward
             Type: contract CandyCoin
             Source: "addressOfTokenUsedAsReward"
  FunctionDefinition "withdrawTokens" - public
     Source: "function withdrawTokens() onlyOwner {\r\n        tokenReward.transfer(msg.sender, tokenReward.balanceOf(this));\r\n        FundTransfer(msg.sender, tokenReward.balanceOf(this), false);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        tokenReward.transfer(msg.sender, tokenReward.balanceOf(this));\r\n        FundTransfer(msg.sender, tokenReward.balanceOf(this), false);\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "tokenReward.transfer(msg.sender, tokenReward.balanceOf(this))"
        FunctionCall
           Type: tuple()
           Source: "tokenReward.transfer(msg.sender, tokenReward.balanceOf(this))"
          MemberAccess to member transfer
             Type: function (address,uint256) external
             Source: "tokenReward.transfer"
            Identifier tokenReward
               Type: contract CandyCoin
               Source: "tokenReward"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          FunctionCall
             Type: uint256
             Source: "tokenReward.balanceOf(this)"
            MemberAccess to member balanceOf
               Type: function (address) view external returns (uint256)
               Source: "tokenReward.balanceOf"
              Identifier tokenReward
                 Type: contract CandyCoin
                 Source: "tokenReward"
            Identifier this
               Type: contract CandySale
               Source: "this"
      ExpressionStatement
         Gas costs: [???]
         Source: "FundTransfer(msg.sender, tokenReward.balanceOf(this), false)"
        FunctionCall
           Type: tuple()
           Source: "FundTransfer(msg.sender, tokenReward.balanceOf(this), false)"
          Identifier FundTransfer
             Type: function (address,uint256,bool)
             Source: "FundTransfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          FunctionCall
             Type: uint256
             Source: "tokenReward.balanceOf(this)"
            MemberAccess to member balanceOf
               Type: function (address) view external returns (uint256)
               Source: "tokenReward.balanceOf"
              Identifier tokenReward
                 Type: contract CandyCoin
                 Source: "tokenReward"
            Identifier this
               Type: contract CandySale
               Source: "this"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "currentPrice" - public - const
     Source: "function currentPrice() constant returns (uint) {\r\n        if ( now <= stage2BeginTime ) return 100 szabo;\r\n        if ( now > stage2BeginTime && now <= stage3BeginTime) return 500 szabo;\r\n        if ( now > stage3BeginTime && now <= stage4BeginTime) return 1000 szabo;\r\n        if ( now > stage4BeginTime ) return 1500 szabo;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        if ( now <= stage2BeginTime ) return 100 szabo;\r\n        if ( now > stage2BeginTime && now <= stage3BeginTime) return 500 szabo;\r\n        if ( now > stage3BeginTime && now <= stage4BeginTime) return 1000 szabo;\r\n        if ( now > stage4BeginTime ) return 1500 szabo;\r\n    }"
      IfStatement
         Source: "if ( now <= stage2BeginTime ) return 100 szabo"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 211
           Source: "now <= stage2BeginTime"
          Identifier now
             Type: uint256
             Source: "now"
          Identifier stage2BeginTime
             Type: uint256
             Source: "stage2BeginTime"
        Return
           Gas costs: 19
           Source: "return 100 szabo"
          Literal, token: [no token] value: 100
             Type: int_const 100000000000000
             Source: "100 szabo"
      IfStatement
         Source: "if ( now > stage2BeginTime && now <= stage3BeginTime) return 500 szabo"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 441
           Source: "now > stage2BeginTime && now <= stage3BeginTime"
          BinaryOperation using operator >
             Type: bool
             Source: "now > stage2BeginTime"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier stage2BeginTime
               Type: uint256
               Source: "stage2BeginTime"
          BinaryOperation using operator <=
             Type: bool
             Source: "now <= stage3BeginTime"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier stage3BeginTime
               Type: uint256
               Source: "stage3BeginTime"
        Return
           Gas costs: 19
           Source: "return 500 szabo"
          Literal, token: [no token] value: 500
             Type: int_const 500000000000000
             Source: "500 szabo"
      IfStatement
         Source: "if ( now > stage3BeginTime && now <= stage4BeginTime) return 1000 szabo"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 441
           Source: "now > stage3BeginTime && now <= stage4BeginTime"
          BinaryOperation using operator >
             Type: bool
             Source: "now > stage3BeginTime"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier stage3BeginTime
               Type: uint256
               Source: "stage3BeginTime"
          BinaryOperation using operator <=
             Type: bool
             Source: "now <= stage4BeginTime"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier stage4BeginTime
               Type: uint256
               Source: "stage4BeginTime"
        Return
           Gas costs: 19
           Source: "return 1000 szabo"
          Literal, token: [no token] value: 1000
             Type: int_const 1000000000000000
             Source: "1000 szabo"
      IfStatement
         Source: "if ( now > stage4BeginTime ) return 1500 szabo"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 208
           Source: "now > stage4BeginTime"
          Identifier now
             Type: uint256
             Source: "now"
          Identifier stage4BeginTime
             Type: uint256
             Source: "stage4BeginTime"
        Return
           Gas costs: 19
           Source: "return 1500 szabo"
          Literal, token: [no token] value: 1500
             Type: int_const 1500000000000000
             Source: "1500 szabo"
  FunctionDefinition "buyTokens" - public
     Source: "function buyTokens(address beneficiary) payable {\r\n        require(msg.value > 0);\r\n        uint amount = msg.value;\r\n        amountRaised += amount;\r\n        tokenReward.transfer(beneficiary, amount*1000000000000000000/currentPrice());\r\n        FundTransfer(beneficiary, amount, true);\r\n        teamWallet.transfer(msg.value);\r\n\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address beneficiary)"
      VariableDeclaration "beneficiary"
         Type: address
         Source: "address beneficiary"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(msg.value > 0);\r\n        uint amount = msg.value;\r\n        amountRaised += amount;\r\n        tokenReward.transfer(beneficiary, amount*1000000000000000000/currentPrice());\r\n        FundTransfer(beneficiary, amount, true);\r\n        teamWallet.transfer(msg.value);\r\n\r\n    }"
      ExpressionStatement
         Gas costs: 34
         Source: "require(msg.value > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "msg.value > 0"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint amount = msg.value"
        VariableDeclaration "amount"
           Type: uint256
           Source: "uint amount"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member value
           Type: uint256
           Source: "msg.value"
          Identifier msg
             Type: msg
             Source: "msg"
      ExpressionStatement
         Gas costs: 20233
         Source: "amountRaised += amount"
        Assignment using operator +=
           Type: uint256
           Source: "amountRaised += amount"
          Identifier amountRaised
             Type: uint256
             Source: "amountRaised"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "tokenReward.transfer(beneficiary, amount*1000000000000000000/currentPrice())"
        FunctionCall
           Type: tuple()
           Source: "tokenReward.transfer(beneficiary, amount*1000000000000000000/currentPrice())"
          MemberAccess to member transfer
             Type: function (address,uint256) external
             Source: "tokenReward.transfer"
            Identifier tokenReward
               Type: contract CandyCoin
               Source: "tokenReward"
          Identifier beneficiary
             Type: address
             Source: "beneficiary"
          BinaryOperation using operator /
             Type: uint256
             Source: "amount*1000000000000000000/currentPrice()"
            BinaryOperation using operator *
               Type: uint256
               Source: "amount*1000000000000000000"
              Identifier amount
                 Type: uint256
                 Source: "amount"
              Literal, token: [no token] value: 1000000000000000000
                 Type: int_const 1000000000000000000
                 Source: "1000000000000000000"
            FunctionCall
               Type: uint256
               Source: "currentPrice()"
              Identifier currentPrice
                 Type: function () view returns (uint256)
                 Source: "currentPrice"
      ExpressionStatement
         Gas costs: [???]
         Source: "FundTransfer(beneficiary, amount, true)"
        FunctionCall
           Type: tuple()
           Source: "FundTransfer(beneficiary, amount, true)"
          Identifier FundTransfer
             Type: function (address,uint256,bool)
             Source: "FundTransfer"
          Identifier beneficiary
             Type: address
             Source: "beneficiary"
          Identifier amount
             Type: uint256
             Source: "amount"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: [???]
         Source: "teamWallet.transfer(msg.value)"
        FunctionCall
           Type: tuple()
           Source: "teamWallet.transfer(msg.value)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "teamWallet.transfer"
            Identifier teamWallet
               Type: address
               Source: "teamWallet"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "" - public
     Source: "function () payable onlyCrowdsalePeriod {\r\n        buyTokens(msg.sender);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyCrowdsalePeriod"
       Gas costs: 0
       Source: "onlyCrowdsalePeriod"
      Identifier onlyCrowdsalePeriod
         Type: modifier ()
         Source: "onlyCrowdsalePeriod"
    Block
       Source: "{\r\n        buyTokens(msg.sender);\r\n    }"
      ExpressionStatement
         Gas costs: 17
         Source: "buyTokens(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "buyTokens(msg.sender)"
          Identifier buyTokens
             Type: function (address)
             Source: "buyTokens"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyCrowdsalePeriod"
     Source: "modifier onlyCrowdsalePeriod() { \r\n        require ( now >= beginTime && now <= endTime ) ;\r\n        _; \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{ \r\n        require ( now >= beginTime && now <= endTime ) ;\r\n        _; \r\n    }"
      ExpressionStatement
         Gas costs: 470
         Source: "require ( now >= beginTime && now <= endTime )"
        FunctionCall
           Type: tuple()
           Source: "require ( now >= beginTime && now <= endTime )"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "now >= beginTime && now <= endTime"
            BinaryOperation using operator >=
               Type: bool
               Source: "now >= beginTime"
              Identifier now
                 Type: uint256
                 Source: "now"
              Identifier beginTime
                 Type: uint256
                 Source: "beginTime"
            BinaryOperation using operator <=
               Type: bool
               Source: "now <= endTime"
              Identifier now
                 Type: uint256
                 Source: "now"
              Identifier endTime
                 Type: uint256
                 Source: "endTime"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
