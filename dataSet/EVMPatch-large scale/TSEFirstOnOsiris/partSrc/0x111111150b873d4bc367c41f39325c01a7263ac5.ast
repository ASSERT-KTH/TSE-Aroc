Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x111111150b873d4bc367c41f39325c01a7263ac5.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "mul"
     Source: "function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 88
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div"
     Source: "function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub"
     Source: "function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add"
     Source: "function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "Ownable"
   Source: "contract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  EventDefinition "OwnershipTransferred"
     Gas costs: 0
     Source: "event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);"
    ParameterList
       Source: "(address indexed previousOwner, address indexed newOwner)"
      VariableDeclaration "previousOwner"
         Type: address
         Source: "address indexed previousOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address indexed newOwner"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "Ownable" - public
     Source: "function Ownable() public {\r\n    owner = msg.sender;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    owner = msg.sender;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 1410
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(newOwner != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(newOwner != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "newOwner != address(0)"
            Identifier newOwner
               Type: address
               Source: "newOwner"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 1790
         Source: "OwnershipTransferred(owner, newOwner)"
        FunctionCall
           Type: tuple()
           Source: "OwnershipTransferred(owner, newOwner)"
          Identifier OwnershipTransferred
             Type: function (address,address)
             Source: "OwnershipTransferred"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
ContractDefinition "Destructible"
   Source: "contract Destructible is Ownable {\r\n\r\n  function Destructible() public payable { }\r\n\r\n  /**\r\n   * @dev Transfers the current balance to the owner and terminates the contract.\r\n   */\r\n  function destroy() onlyOwner public {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  function destroyAndSend(address _recipient) onlyOwner public {\r\n    selfdestruct(_recipient);\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  FunctionDefinition "Destructible" - public
     Source: "function Destructible() public payable { }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Gas costs: 0
       Source: "{ }"
  FunctionDefinition "destroy" - public
     Source: "function destroy() onlyOwner public {\r\n    selfdestruct(owner);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    selfdestruct(owner);\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "selfdestruct(owner)"
        FunctionCall
           Type: tuple()
           Source: "selfdestruct(owner)"
          Identifier selfdestruct
             Type: function (address)
             Source: "selfdestruct"
          Identifier owner
             Type: address
             Source: "owner"
  FunctionDefinition "destroyAndSend" - public
     Source: "function destroyAndSend(address _recipient) onlyOwner public {\r\n    selfdestruct(_recipient);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _recipient)"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    selfdestruct(_recipient);\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "selfdestruct(_recipient)"
        FunctionCall
           Type: tuple()
           Source: "selfdestruct(_recipient)"
          Identifier selfdestruct
             Type: function (address)
             Source: "selfdestruct"
          Identifier _recipient
             Type: address
             Source: "_recipient"
ContractDefinition "Pausable"
   Source: "contract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  EventDefinition "Pause"
     Gas costs: 0
     Source: "event Pause();"
    ParameterList
       Source: "()"
  EventDefinition "Unpause"
     Gas costs: 0
     Source: "event Unpause();"
    ParameterList
       Source: "()"
  VariableDeclaration "paused"
     Type: bool
     Gas costs: 0
     Source: "bool public paused = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  ModifierDefinition "whenNotPaused"
     Source: "modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(!paused);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!paused)"
        FunctionCall
           Type: tuple()
           Source: "require(!paused)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!paused"
            Identifier paused
               Type: bool
               Source: "paused"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "whenPaused"
     Source: "modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(paused);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(paused)"
        FunctionCall
           Type: tuple()
           Source: "require(paused)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier paused
             Type: bool
             Source: "paused"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "pause" - public
     Source: "function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "whenNotPaused"
       Gas costs: 0
       Source: "whenNotPaused"
      Identifier whenNotPaused
         Type: modifier ()
         Source: "whenNotPaused"
    Block
       Source: "{\r\n    paused = true;\r\n    Pause();\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "paused = true"
        Assignment using operator =
           Type: bool
           Source: "paused = true"
          Identifier paused
             Type: bool
             Source: "paused"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "Pause()"
        FunctionCall
           Type: tuple()
           Source: "Pause()"
          Identifier Pause
             Type: function ()
             Source: "Pause"
  FunctionDefinition "unpause" - public
     Source: "function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "whenPaused"
       Gas costs: 0
       Source: "whenPaused"
      Identifier whenPaused
         Type: modifier ()
         Source: "whenPaused"
    Block
       Source: "{\r\n    paused = false;\r\n    Unpause();\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "paused = false"
        Assignment using operator =
           Type: bool
           Source: "paused = false"
          Identifier paused
             Type: bool
             Source: "paused"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 0
         Source: "Unpause()"
        FunctionCall
           Type: tuple()
           Source: "Unpause()"
          Identifier Unpause
             Type: function ()
             Source: "Unpause"
ContractDefinition "ERC20Basic"
   Gas costs: 0
   Source: "contract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) public constant returns (uint256);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address to, uint256 value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "ERC20"
   Gas costs: 0
   Source: "contract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
  InheritanceSpecifier
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) public constant returns (uint256);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address from, address to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address spender, uint256 value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint256 value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint256 value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "BasicToken"
   Source: "contract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) balances"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_to != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_to != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != address(0)"
            Identifier _to
               Type: address
               Source: "_to"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "balances[msg.sender].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return balances[_owner];\r\n  }"
      Return
         Gas costs: 0
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue) public\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue) public\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  InheritanceSpecifier
     Gas costs: 0
     Source: "BasicToken"
    UserDefinedTypeName "BasicToken"
       Source: "BasicToken"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(_to != address(0));\r\n\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_to != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_to != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != address(0)"
            Identifier _to
               Type: address
               Source: "_to"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 _allowance = allowed[_from][msg.sender]"
        VariableDeclaration "_allowance"
           Type: uint256
           Source: "uint256 _allowance"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "allowed[_from][msg.sender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_from]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _from
               Type: address
               Source: "_from"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_from] = balances[_from].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_from] = balances[_from].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "balances[_from].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[_from].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[_from][msg.sender] = _allowance.sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[_from][msg.sender] = _allowance.sub(_value)"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "_allowance.sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_allowance.sub"
              Identifier _allowance
                 Type: uint256
                 Source: "_allowance"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return allowed[_owner][_spender];\r\n  }"
      Return
         Gas costs: 0
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  FunctionDefinition "increaseApproval" - public
     Source: "function increaseApproval (address _spender, uint _addedValue) public\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _addedValue)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_addedValue"
         Type: uint256
         Source: "uint _addedValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          FunctionCall
             Type: uint256
             Source: "allowed[msg.sender][_spender].add(_addedValue)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "allowed[msg.sender][_spender].add"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
            Identifier _addedValue
               Type: uint256
               Source: "_addedValue"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "decreaseApproval" - public
     Source: "function decreaseApproval (address _spender, uint _subtractedValue) public\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _subtractedValue)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_subtractedValue"
         Type: uint256
         Source: "uint _subtractedValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint oldValue = allowed[msg.sender][_spender]"
        VariableDeclaration "oldValue"
           Type: uint256
           Source: "uint oldValue"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "allowed[msg.sender][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[msg.sender]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
      IfStatement
         Source: "if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "_subtractedValue > oldValue"
          Identifier _subtractedValue
             Type: uint256
             Source: "_subtractedValue"
          Identifier oldValue
             Type: uint256
             Source: "oldValue"
        Block
           Source: "{\r\n      allowed[msg.sender][_spender] = 0;\r\n    }"
          ExpressionStatement
             Gas costs: 0
             Source: "allowed[msg.sender][_spender] = 0"
            Assignment using operator =
               Type: uint256
               Source: "allowed[msg.sender][_spender] = 0"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }"
          ExpressionStatement
             Gas costs: 0
             Source: "allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)"
            Assignment using operator =
               Type: uint256
               Source: "allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
              FunctionCall
                 Type: uint256
                 Source: "oldValue.sub(_subtractedValue)"
                MemberAccess to member sub
                   Type: function (uint256,uint256) pure returns (uint256)
                   Source: "oldValue.sub"
                  Identifier oldValue
                     Type: uint256
                     Source: "oldValue"
                Identifier _subtractedValue
                   Type: uint256
                   Source: "_subtractedValue"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
ContractDefinition "MintableToken"
   Source: "contract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(0x0, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner public returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  EventDefinition "Mint"
     Gas costs: 0
     Source: "event Mint(address indexed to, uint256 amount);"
    ParameterList
       Source: "(address indexed to, uint256 amount)"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "MintFinished"
     Gas costs: 0
     Source: "event MintFinished();"
    ParameterList
       Source: "()"
  VariableDeclaration "mintingFinished"
     Type: bool
     Gas costs: 0
     Source: "bool public mintingFinished = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  ModifierDefinition "canMint"
     Source: "modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(!mintingFinished);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(!mintingFinished)"
        FunctionCall
           Type: tuple()
           Source: "require(!mintingFinished)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!mintingFinished"
            Identifier mintingFinished
               Type: bool
               Source: "mintingFinished"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "mint" - public
     Source: "function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(0x0, _to, _amount);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _amount)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint256 _amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    ModifierInvocation "canMint"
       Gas costs: 0
       Source: "canMint"
      Identifier canMint
         Type: modifier ()
         Source: "canMint"
    Block
       Source: "{\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(0x0, _to, _amount);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = totalSupply.add(_amount)"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = totalSupply.add(_amount)"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          FunctionCall
             Type: uint256
             Source: "totalSupply.add(_amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "totalSupply.add"
              Identifier totalSupply
                 Type: uint256
                 Source: "totalSupply"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] = balances[_to].add(_amount)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_amount)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 0
         Source: "Mint(_to, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Mint(_to, _amount)"
          Identifier Mint
             Type: function (address,uint256)
             Source: "Mint"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(0x0, _to, _amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(0x0, _to, _amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Literal, token: [no token] value: 0x0
             Type: int_const 0
             Source: "0x0"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _amount
             Type: uint256
             Source: "_amount"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "finishMinting" - public
     Source: "function finishMinting() onlyOwner public returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "mintingFinished = true"
        Assignment using operator =
           Type: bool
           Source: "mintingFinished = true"
          Identifier mintingFinished
             Type: bool
             Source: "mintingFinished"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "MintFinished()"
        FunctionCall
           Type: tuple()
           Source: "MintFinished()"
          Identifier MintFinished
             Type: function ()
             Source: "MintFinished"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
ContractDefinition "PausableToken"
   Source: "contract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\r\n    return super.increaseApproval(_spender, _addedValue);\r\n  }\r\n\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\r\n    return super.decreaseApproval(_spender, _subtractedValue);\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Pausable"
    UserDefinedTypeName "Pausable"
       Source: "Pausable"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transfer(_to, _value);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "whenNotPaused"
       Gas costs: 0
       Source: "whenNotPaused"
      Identifier whenNotPaused
         Type: modifier ()
         Source: "whenNotPaused"
    Block
       Source: "{\r\n    return super.transfer(_to, _value);\r\n  }"
      Return
         Gas costs: 0
         Source: "return super.transfer(_to, _value)"
        FunctionCall
           Type: bool
           Source: "super.transfer(_to, _value)"
          MemberAccess to member transfer
             Type: function (address,uint256) returns (bool)
             Source: "super.transfer"
            Identifier super
               Type: contract super PausableToken
               Source: "super"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "whenNotPaused"
       Gas costs: 0
       Source: "whenNotPaused"
      Identifier whenNotPaused
         Type: modifier ()
         Source: "whenNotPaused"
    Block
       Source: "{\r\n    return super.transferFrom(_from, _to, _value);\r\n  }"
      Return
         Gas costs: 0
         Source: "return super.transferFrom(_from, _to, _value)"
        FunctionCall
           Type: bool
           Source: "super.transferFrom(_from, _to, _value)"
          MemberAccess to member transferFrom
             Type: function (address,address,uint256) returns (bool)
             Source: "super.transferFrom"
            Identifier super
               Type: contract super PausableToken
               Source: "super"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.approve(_spender, _value);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "whenNotPaused"
       Gas costs: 0
       Source: "whenNotPaused"
      Identifier whenNotPaused
         Type: modifier ()
         Source: "whenNotPaused"
    Block
       Source: "{\r\n    return super.approve(_spender, _value);\r\n  }"
      Return
         Gas costs: 0
         Source: "return super.approve(_spender, _value)"
        FunctionCall
           Type: bool
           Source: "super.approve(_spender, _value)"
          MemberAccess to member approve
             Type: function (address,uint256) returns (bool)
             Source: "super.approve"
            Identifier super
               Type: contract super PausableToken
               Source: "super"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "increaseApproval" - public
     Source: "function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\r\n    return super.increaseApproval(_spender, _addedValue);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _addedValue)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_addedValue"
         Type: uint256
         Source: "uint _addedValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "whenNotPaused"
       Gas costs: 0
       Source: "whenNotPaused"
      Identifier whenNotPaused
         Type: modifier ()
         Source: "whenNotPaused"
    Block
       Source: "{\r\n    return super.increaseApproval(_spender, _addedValue);\r\n  }"
      Return
         Gas costs: 0
         Source: "return super.increaseApproval(_spender, _addedValue)"
        FunctionCall
           Type: bool
           Source: "super.increaseApproval(_spender, _addedValue)"
          MemberAccess to member increaseApproval
             Type: function (address,uint256) returns (bool)
             Source: "super.increaseApproval"
            Identifier super
               Type: contract super PausableToken
               Source: "super"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _addedValue
             Type: uint256
             Source: "_addedValue"
  FunctionDefinition "decreaseApproval" - public
     Source: "function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\r\n    return super.decreaseApproval(_spender, _subtractedValue);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _subtractedValue)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_subtractedValue"
         Type: uint256
         Source: "uint _subtractedValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "whenNotPaused"
       Gas costs: 0
       Source: "whenNotPaused"
      Identifier whenNotPaused
         Type: modifier ()
         Source: "whenNotPaused"
    Block
       Source: "{\r\n    return super.decreaseApproval(_spender, _subtractedValue);\r\n  }"
      Return
         Gas costs: 0
         Source: "return super.decreaseApproval(_spender, _subtractedValue)"
        FunctionCall
           Type: bool
           Source: "super.decreaseApproval(_spender, _subtractedValue)"
          MemberAccess to member decreaseApproval
             Type: function (address,uint256) returns (bool)
             Source: "super.decreaseApproval"
            Identifier super
               Type: contract super PausableToken
               Source: "super"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _subtractedValue
             Type: uint256
             Source: "_subtractedValue"
ContractDefinition "VanityToken"
   Gas costs: 0
   Source: "contract VanityToken is MintableToken, PausableToken {\r\n\r\n    // Metadata\r\n    string public constant symbol = \"VIP\";\r\n    string public constant name = \"VipCoin\";\r\n    uint8 public constant decimals = 18;\r\n    string public constant version = \"1.0\";\r\n\r\n}"
  InheritanceSpecifier
     Source: "MintableToken"
    UserDefinedTypeName "MintableToken"
       Source: "MintableToken"
  InheritanceSpecifier
     Source: "PausableToken"
    UserDefinedTypeName "PausableToken"
       Source: "PausableToken"
  VariableDeclaration "symbol"
     Type: string memory
     Source: "string public constant symbol = \"VIP\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: VIP
       Type: literal_string "VIP"
       Source: "\"VIP\""
  VariableDeclaration "name"
     Type: string memory
     Source: "string public constant name = \"VipCoin\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: VipCoin
       Type: literal_string "VipCoin"
       Source: "\"VipCoin\""
  VariableDeclaration "decimals"
     Type: uint8
     Source: "uint8 public constant decimals = 18"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "version"
     Type: string memory
     Source: "string public constant version = \"1.0\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: 1.0
       Type: literal_string "1.0"
       Source: "\"1.0\""
ContractDefinition "VanityCrowdsale"
   Source: "contract VanityCrowdsale is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // Constants\r\n\r\n    uint256 public constant TOKEN_RATE = 1000; // 1 ETH = 1000 VPL\r\n    uint256 public constant OWNER_TOKENS_PERCENT = 100; // 1:1\r\n\r\n    // Variables\r\n\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n    address public ownerWallet;\r\n    \r\n    mapping(address => uint) public registeredInDay;\r\n    address[] public participants;\r\n    uint256 public totalUsdAmount;\r\n    uint256 public bonusMultiplier;\r\n    \r\n    VanityToken public token;\r\n    bool public finalized;\r\n    bool public distributed;\r\n    uint256 public distributedCount;\r\n    uint256 public distributedTokens;\r\n    \r\n    // Events\r\n\r\n    event Finalized();\r\n    event Distributed();\r\n    \r\n    // Constructor and accessors\r\n\r\n    function VanityCrowdsale(uint256 _startTime, uint256 _endTime, address _ownerWallet) public {\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        ownerWallet = _ownerWallet;\r\n\r\n        token = new VanityToken();\r\n        token.pause();\r\n    }\r\n\r\n    function registered(address wallet) public constant returns(bool) {\r\n        return registeredInDay[wallet] > 0;\r\n    }\r\n\r\n    function participantsCount() public constant returns(uint) {\r\n        return participants.length;\r\n    }\r\n\r\n    function setOwnerWallet(address _ownerWallet) public onlyOwner {\r\n        require(_ownerWallet != address(0));\r\n        ownerWallet = _ownerWallet;\r\n    }\r\n\r\n    function computeTotalEthAmount() public constant returns(uint256) {\r\n        uint256 total = 0;\r\n        for (uint i = 0; i < participants.length; i++) {\r\n            address participant = participants[distributedCount + i];\r\n            total += participant.balance;\r\n        }\r\n        return total;\r\n    }\r\n\r\n    function setTotalUsdAmount(uint256 _totalUsdAmount) public onlyOwner {\r\n        totalUsdAmount = _totalUsdAmount;\r\n\r\n        if (totalUsdAmount > 10000000) {\r\n            bonusMultiplier = 20;\r\n        } else if (totalUsdAmount > 5000000) {\r\n            bonusMultiplier = 15;\r\n        } else if (totalUsdAmount > 1000000) {\r\n            bonusMultiplier = 10;\r\n        } else if (totalUsdAmount > 100000) {\r\n            bonusMultiplier = 5;\r\n        } else if (totalUsdAmount > 10000) {\r\n            bonusMultiplier = 2;\r\n        } else if (totalUsdAmount == 0) {\r\n            bonusMultiplier = 1;\r\n        }\r\n    }\r\n\r\n    // Participants methods\r\n\r\n    function () public payable {\r\n        registerParticipant();\r\n    }\r\n\r\n    function registerParticipant() public payable {\r\n        require(!finalized);\r\n        require(startTime <= now && now <= endTime);\r\n        require(registeredInDay[msg.sender] == 0);\r\n\r\n        registeredInDay[msg.sender] = 1 + now.sub(startTime).div(24*60*60);\r\n        participants.push(msg.sender);\r\n        if (msg.value > 0) {\r\n            // No money => No need to handle recirsive calls\r\n            msg.sender.transfer(msg.value);\r\n        }\r\n    }\r\n\r\n    // Owner methods\r\n\r\n    function finalize() public onlyOwner {\r\n        require(!finalized);\r\n        require(now > endTime);\r\n\r\n        finalized = true;\r\n        Finalized();\r\n    }\r\n\r\n    function participantBonus(address participant) public constant returns(uint) {\r\n        uint day = registeredInDay[participant];\r\n        require(day > 0);\r\n\r\n        uint bonus = 0;\r\n        if (day <= 1) {\r\n            bonus = 6;\r\n        } else if (day <= 3) {\r\n            bonus = 5;\r\n        } else if (day <= 7) {\r\n            bonus = 4;\r\n        } else if (day <= 10) {\r\n            bonus = 3;\r\n        } else if (day <= 14) {\r\n            bonus = 2;\r\n        } else if (day <= 21) {\r\n            bonus = 1;\r\n        }\r\n\r\n        return bonus.mul(bonusMultiplier);\r\n    }\r\n\r\n    function distribute(uint count) public onlyOwner {\r\n        require(finalized && !distributed);\r\n        require(count > 0 && distributedCount + count <= participants.length);\r\n        \r\n        for (uint i = 0; i < count; i++) {\r\n            address participant = participants[distributedCount + i];\r\n            uint256 bonus = participantBonus(participant);\r\n            uint256 tokens = participant.balance.mul(TOKEN_RATE).mul(100 + bonus).div(100);\r\n            token.mint(participant, tokens);\r\n            distributedTokens += tokens;\r\n        }\r\n        distributedCount += count;\r\n\r\n        if (distributedCount == participants.length) {\r\n            uint256 ownerTokens = distributedTokens.mul(OWNER_TOKENS_PERCENT).div(100);\r\n            token.mint(ownerWallet, ownerTokens);\r\n            token.finishMinting();\r\n            token.unpause();\r\n            distributed = true;\r\n            Distributed();\r\n        }\r\n    }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "TOKEN_RATE"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant TOKEN_RATE = 1000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 1000
       Type: int_const 1000
       Source: "1000"
  VariableDeclaration "OWNER_TOKENS_PERCENT"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant OWNER_TOKENS_PERCENT = 100"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 100
       Type: int_const 100
       Source: "100"
  VariableDeclaration "startTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public startTime"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "endTime"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public endTime"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "ownerWallet"
     Type: address
     Gas costs: [???]
     Source: "address public ownerWallet"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "registeredInDay"
     Type: mapping(address => uint256)
     Gas costs: [???]
     Source: "mapping(address => uint) public registeredInDay"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "participants"
     Type: address[] storage ref
     Gas costs: [???]
     Source: "address[] public participants"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "totalUsdAmount"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public totalUsdAmount"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "bonusMultiplier"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public bonusMultiplier"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "token"
     Type: contract VanityToken
     Gas costs: [???]
     Source: "VanityToken public token"
    UserDefinedTypeName "VanityToken"
       Source: "VanityToken"
  VariableDeclaration "finalized"
     Type: bool
     Gas costs: [???]
     Source: "bool public finalized"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "distributed"
     Type: bool
     Gas costs: [???]
     Source: "bool public distributed"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "distributedCount"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public distributedCount"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "distributedTokens"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public distributedTokens"
    ElementaryTypeName uint256
       Source: "uint256"
  EventDefinition "Finalized"
     Gas costs: 0
     Source: "event Finalized();"
    ParameterList
       Source: "()"
  EventDefinition "Distributed"
     Gas costs: 0
     Source: "event Distributed();"
    ParameterList
       Source: "()"
  FunctionDefinition "VanityCrowdsale" - public
     Source: "function VanityCrowdsale(uint256 _startTime, uint256 _endTime, address _ownerWallet) public {\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        ownerWallet = _ownerWallet;\r\n\r\n        token = new VanityToken();\r\n        token.pause();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _startTime, uint256 _endTime, address _ownerWallet)"
      VariableDeclaration "_startTime"
         Type: uint256
         Source: "uint256 _startTime"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_endTime"
         Type: uint256
         Source: "uint256 _endTime"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_ownerWallet"
         Type: address
         Source: "address _ownerWallet"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        ownerWallet = _ownerWallet;\r\n\r\n        token = new VanityToken();\r\n        token.pause();\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "startTime = _startTime"
        Assignment using operator =
           Type: uint256
           Source: "startTime = _startTime"
          Identifier startTime
             Type: uint256
             Source: "startTime"
          Identifier _startTime
             Type: uint256
             Source: "_startTime"
      ExpressionStatement
         Gas costs: 0
         Source: "endTime = _endTime"
        Assignment using operator =
           Type: uint256
           Source: "endTime = _endTime"
          Identifier endTime
             Type: uint256
             Source: "endTime"
          Identifier _endTime
             Type: uint256
             Source: "_endTime"
      ExpressionStatement
         Gas costs: 0
         Source: "ownerWallet = _ownerWallet"
        Assignment using operator =
           Type: address
           Source: "ownerWallet = _ownerWallet"
          Identifier ownerWallet
             Type: address
             Source: "ownerWallet"
          Identifier _ownerWallet
             Type: address
             Source: "_ownerWallet"
      ExpressionStatement
         Gas costs: 0
         Source: "token = new VanityToken()"
        Assignment using operator =
           Type: contract VanityToken
           Source: "token = new VanityToken()"
          Identifier token
             Type: contract VanityToken
             Source: "token"
          FunctionCall
             Type: contract VanityToken
             Source: "new VanityToken()"
            NewExpression
               Type: function () returns (contract VanityToken)
               Source: "new VanityToken"
              UserDefinedTypeName "VanityToken"
                 Source: "VanityToken"
      ExpressionStatement
         Gas costs: 0
         Source: "token.pause()"
        FunctionCall
           Type: tuple()
           Source: "token.pause()"
          MemberAccess to member pause
             Type: function () external
             Source: "token.pause"
            Identifier token
               Type: contract VanityToken
               Source: "token"
  FunctionDefinition "registered" - public - const
     Source: "function registered(address wallet) public constant returns(bool) {\r\n        return registeredInDay[wallet] > 0;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address wallet)"
      VariableDeclaration "wallet"
         Type: address
         Source: "address wallet"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        return registeredInDay[wallet] > 0;\r\n    }"
      Return
         Gas costs: 310
         Source: "return registeredInDay[wallet] > 0"
        BinaryOperation using operator >
           Type: bool
           Source: "registeredInDay[wallet] > 0"
          IndexAccess
             Type: uint256
             Source: "registeredInDay[wallet]"
            Identifier registeredInDay
               Type: mapping(address => uint256)
               Source: "registeredInDay"
            Identifier wallet
               Type: address
               Source: "wallet"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "participantsCount" - public - const
     Source: "function participantsCount() public constant returns(uint) {\r\n        return participants.length;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return participants.length;\r\n    }"
      Return
         Gas costs: 216
         Source: "return participants.length"
        MemberAccess to member length
           Type: uint256
           Source: "participants.length"
          Identifier participants
             Type: address[] storage ref
             Source: "participants"
  FunctionDefinition "setOwnerWallet" - public
     Source: "function setOwnerWallet(address _ownerWallet) public onlyOwner {\r\n        require(_ownerWallet != address(0));\r\n        ownerWallet = _ownerWallet;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _ownerWallet)"
      VariableDeclaration "_ownerWallet"
         Type: address
         Source: "address _ownerWallet"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(_ownerWallet != address(0));\r\n        ownerWallet = _ownerWallet;\r\n    }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(_ownerWallet != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_ownerWallet != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_ownerWallet != address(0)"
            Identifier _ownerWallet
               Type: address
               Source: "_ownerWallet"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 20267
         Source: "ownerWallet = _ownerWallet"
        Assignment using operator =
           Type: address
           Source: "ownerWallet = _ownerWallet"
          Identifier ownerWallet
             Type: address
             Source: "ownerWallet"
          Identifier _ownerWallet
             Type: address
             Source: "_ownerWallet"
  FunctionDefinition "computeTotalEthAmount" - public - const
     Source: "function computeTotalEthAmount() public constant returns(uint256) {\r\n        uint256 total = 0;\r\n        for (uint i = 0; i < participants.length; i++) {\r\n            address participant = participants[distributedCount + i];\r\n            total += participant.balance;\r\n        }\r\n        return total;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        uint256 total = 0;\r\n        for (uint i = 0; i < participants.length; i++) {\r\n            address participant = participants[distributedCount + i];\r\n            total += participant.balance;\r\n        }\r\n        return total;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint256 total = 0"
        VariableDeclaration "total"
           Type: uint256
           Source: "uint256 total"
          ElementaryTypeName uint256
             Source: "uint256"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for (uint i = 0; i < participants.length; i++) {\r\n            address participant = participants[distributedCount + i];\r\n            total += participant.balance;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 217
           Source: "i < participants.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "participants.length"
            Identifier participants
               Type: address[] storage ref
               Source: "participants"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            address participant = participants[distributedCount + i];\r\n            total += participant.balance;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 742
             Source: "address participant = participants[distributedCount + i]"
            VariableDeclaration "participant"
               Type: address
               Source: "address participant"
              ElementaryTypeName address
                 Source: "address"
            IndexAccess
               Type: address
               Source: "participants[distributedCount + i]"
              Identifier participants
                 Type: address[] storage ref
                 Source: "participants"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "distributedCount + i"
                Identifier distributedCount
                   Type: uint256
                   Source: "distributedCount"
                Identifier i
                   Type: uint256
                   Source: "i"
          ExpressionStatement
             Gas costs: 420
             Source: "total += participant.balance"
            Assignment using operator +=
               Type: uint256
               Source: "total += participant.balance"
              Identifier total
                 Type: uint256
                 Source: "total"
              MemberAccess to member balance
                 Type: uint256
                 Source: "participant.balance"
                Identifier participant
                   Type: address
                   Source: "participant"
      Return
         Gas costs: 8
         Source: "return total"
        Identifier total
           Type: uint256
           Source: "total"
  FunctionDefinition "setTotalUsdAmount" - public
     Source: "function setTotalUsdAmount(uint256 _totalUsdAmount) public onlyOwner {\r\n        totalUsdAmount = _totalUsdAmount;\r\n\r\n        if (totalUsdAmount > 10000000) {\r\n            bonusMultiplier = 20;\r\n        } else if (totalUsdAmount > 5000000) {\r\n            bonusMultiplier = 15;\r\n        } else if (totalUsdAmount > 1000000) {\r\n            bonusMultiplier = 10;\r\n        } else if (totalUsdAmount > 100000) {\r\n            bonusMultiplier = 5;\r\n        } else if (totalUsdAmount > 10000) {\r\n            bonusMultiplier = 2;\r\n        } else if (totalUsdAmount == 0) {\r\n            bonusMultiplier = 1;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _totalUsdAmount)"
      VariableDeclaration "_totalUsdAmount"
         Type: uint256
         Source: "uint256 _totalUsdAmount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        totalUsdAmount = _totalUsdAmount;\r\n\r\n        if (totalUsdAmount > 10000000) {\r\n            bonusMultiplier = 20;\r\n        } else if (totalUsdAmount > 5000000) {\r\n            bonusMultiplier = 15;\r\n        } else if (totalUsdAmount > 1000000) {\r\n            bonusMultiplier = 10;\r\n        } else if (totalUsdAmount > 100000) {\r\n            bonusMultiplier = 5;\r\n        } else if (totalUsdAmount > 10000) {\r\n            bonusMultiplier = 2;\r\n        } else if (totalUsdAmount == 0) {\r\n            bonusMultiplier = 1;\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 20014
         Source: "totalUsdAmount = _totalUsdAmount"
        Assignment using operator =
           Type: uint256
           Source: "totalUsdAmount = _totalUsdAmount"
          Identifier totalUsdAmount
             Type: uint256
             Source: "totalUsdAmount"
          Identifier _totalUsdAmount
             Type: uint256
             Source: "_totalUsdAmount"
      IfStatement
         Source: "if (totalUsdAmount > 10000000) {\r\n            bonusMultiplier = 20;\r\n        } else if (totalUsdAmount > 5000000) {\r\n            bonusMultiplier = 15;\r\n        } else if (totalUsdAmount > 1000000) {\r\n            bonusMultiplier = 10;\r\n        } else if (totalUsdAmount > 100000) {\r\n            bonusMultiplier = 5;\r\n        } else if (totalUsdAmount > 10000) {\r\n            bonusMultiplier = 2;\r\n        } else if (totalUsdAmount == 0) {\r\n            bonusMultiplier = 1;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "totalUsdAmount > 10000000"
          Identifier totalUsdAmount
             Type: uint256
             Source: "totalUsdAmount"
          Literal, token: [no token] value: 10000000
             Type: int_const 10000000
             Source: "10000000"
        Block
           Source: "{\r\n            bonusMultiplier = 20;\r\n        }"
          ExpressionStatement
             Gas costs: 20014
             Source: "bonusMultiplier = 20"
            Assignment using operator =
               Type: uint256
               Source: "bonusMultiplier = 20"
              Identifier bonusMultiplier
                 Type: uint256
                 Source: "bonusMultiplier"
              Literal, token: [no token] value: 20
                 Type: int_const 20
                 Source: "20"
        IfStatement
           Source: "if (totalUsdAmount > 5000000) {\r\n            bonusMultiplier = 15;\r\n        } else if (totalUsdAmount > 1000000) {\r\n            bonusMultiplier = 10;\r\n        } else if (totalUsdAmount > 100000) {\r\n            bonusMultiplier = 5;\r\n        } else if (totalUsdAmount > 10000) {\r\n            bonusMultiplier = 2;\r\n        } else if (totalUsdAmount == 0) {\r\n            bonusMultiplier = 1;\r\n        }"
          BinaryOperation using operator >
             Type: bool
             Gas costs: 209
             Source: "totalUsdAmount > 5000000"
            Identifier totalUsdAmount
               Type: uint256
               Source: "totalUsdAmount"
            Literal, token: [no token] value: 5000000
               Type: int_const 5000000
               Source: "5000000"
          Block
             Source: "{\r\n            bonusMultiplier = 15;\r\n        }"
            ExpressionStatement
               Gas costs: 20014
               Source: "bonusMultiplier = 15"
              Assignment using operator =
                 Type: uint256
                 Source: "bonusMultiplier = 15"
                Identifier bonusMultiplier
                   Type: uint256
                   Source: "bonusMultiplier"
                Literal, token: [no token] value: 15
                   Type: int_const 15
                   Source: "15"
          IfStatement
             Source: "if (totalUsdAmount > 1000000) {\r\n            bonusMultiplier = 10;\r\n        } else if (totalUsdAmount > 100000) {\r\n            bonusMultiplier = 5;\r\n        } else if (totalUsdAmount > 10000) {\r\n            bonusMultiplier = 2;\r\n        } else if (totalUsdAmount == 0) {\r\n            bonusMultiplier = 1;\r\n        }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 209
               Source: "totalUsdAmount > 1000000"
              Identifier totalUsdAmount
                 Type: uint256
                 Source: "totalUsdAmount"
              Literal, token: [no token] value: 1000000
                 Type: int_const 1000000
                 Source: "1000000"
            Block
               Source: "{\r\n            bonusMultiplier = 10;\r\n        }"
              ExpressionStatement
                 Gas costs: 20014
                 Source: "bonusMultiplier = 10"
                Assignment using operator =
                   Type: uint256
                   Source: "bonusMultiplier = 10"
                  Identifier bonusMultiplier
                     Type: uint256
                     Source: "bonusMultiplier"
                  Literal, token: [no token] value: 10
                     Type: int_const 10
                     Source: "10"
            IfStatement
               Source: "if (totalUsdAmount > 100000) {\r\n            bonusMultiplier = 5;\r\n        } else if (totalUsdAmount > 10000) {\r\n            bonusMultiplier = 2;\r\n        } else if (totalUsdAmount == 0) {\r\n            bonusMultiplier = 1;\r\n        }"
              BinaryOperation using operator >
                 Type: bool
                 Gas costs: 209
                 Source: "totalUsdAmount > 100000"
                Identifier totalUsdAmount
                   Type: uint256
                   Source: "totalUsdAmount"
                Literal, token: [no token] value: 100000
                   Type: int_const 100000
                   Source: "100000"
              Block
                 Source: "{\r\n            bonusMultiplier = 5;\r\n        }"
                ExpressionStatement
                   Gas costs: 20014
                   Source: "bonusMultiplier = 5"
                  Assignment using operator =
                     Type: uint256
                     Source: "bonusMultiplier = 5"
                    Identifier bonusMultiplier
                       Type: uint256
                       Source: "bonusMultiplier"
                    Literal, token: [no token] value: 5
                       Type: int_const 5
                       Source: "5"
              IfStatement
                 Source: "if (totalUsdAmount > 10000) {\r\n            bonusMultiplier = 2;\r\n        } else if (totalUsdAmount == 0) {\r\n            bonusMultiplier = 1;\r\n        }"
                BinaryOperation using operator >
                   Type: bool
                   Gas costs: 209
                   Source: "totalUsdAmount > 10000"
                  Identifier totalUsdAmount
                     Type: uint256
                     Source: "totalUsdAmount"
                  Literal, token: [no token] value: 10000
                     Type: int_const 10000
                     Source: "10000"
                Block
                   Source: "{\r\n            bonusMultiplier = 2;\r\n        }"
                  ExpressionStatement
                     Gas costs: 20014
                     Source: "bonusMultiplier = 2"
                    Assignment using operator =
                       Type: uint256
                       Source: "bonusMultiplier = 2"
                      Identifier bonusMultiplier
                         Type: uint256
                         Source: "bonusMultiplier"
                      Literal, token: [no token] value: 2
                         Type: int_const 2
                         Source: "2"
                IfStatement
                   Source: "if (totalUsdAmount == 0) {\r\n            bonusMultiplier = 1;\r\n        }"
                  BinaryOperation using operator ==
                     Type: bool
                     Gas costs: 209
                     Source: "totalUsdAmount == 0"
                    Identifier totalUsdAmount
                       Type: uint256
                       Source: "totalUsdAmount"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                  Block
                     Source: "{\r\n            bonusMultiplier = 1;\r\n        }"
                    ExpressionStatement
                       Gas costs: 20014
                       Source: "bonusMultiplier = 1"
                      Assignment using operator =
                         Type: uint256
                         Source: "bonusMultiplier = 1"
                        Identifier bonusMultiplier
                           Type: uint256
                           Source: "bonusMultiplier"
                        Literal, token: [no token] value: 1
                           Type: int_const 1
                           Source: "1"
  FunctionDefinition "" - public
     Source: "function () public payable {\r\n        registerParticipant();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        registerParticipant();\r\n    }"
      ExpressionStatement
         Gas costs: 4
         Source: "registerParticipant()"
        FunctionCall
           Type: tuple()
           Source: "registerParticipant()"
          Identifier registerParticipant
             Type: function ()
             Source: "registerParticipant"
  FunctionDefinition "registerParticipant" - public
     Source: "function registerParticipant() public payable {\r\n        require(!finalized);\r\n        require(startTime <= now && now <= endTime);\r\n        require(registeredInDay[msg.sender] == 0);\r\n\r\n        registeredInDay[msg.sender] = 1 + now.sub(startTime).div(24*60*60);\r\n        participants.push(msg.sender);\r\n        if (msg.value > 0) {\r\n            // No money => No need to handle recirsive calls\r\n            msg.sender.transfer(msg.value);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(!finalized);\r\n        require(startTime <= now && now <= endTime);\r\n        require(registeredInDay[msg.sender] == 0);\r\n\r\n        registeredInDay[msg.sender] = 1 + now.sub(startTime).div(24*60*60);\r\n        participants.push(msg.sender);\r\n        if (msg.value > 0) {\r\n            // No money => No need to handle recirsive calls\r\n            msg.sender.transfer(msg.value);\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 318
         Source: "require(!finalized)"
        FunctionCall
           Type: tuple()
           Source: "require(!finalized)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!finalized"
            Identifier finalized
               Type: bool
               Source: "finalized"
      ExpressionStatement
         Gas costs: 470
         Source: "require(startTime <= now && now <= endTime)"
        FunctionCall
           Type: tuple()
           Source: "require(startTime <= now && now <= endTime)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "startTime <= now && now <= endTime"
            BinaryOperation using operator <=
               Type: bool
               Source: "startTime <= now"
              Identifier startTime
                 Type: uint256
                 Source: "startTime"
              Identifier now
                 Type: uint256
                 Source: "now"
            BinaryOperation using operator <=
               Type: bool
               Source: "now <= endTime"
              Identifier now
                 Type: uint256
                 Source: "now"
              Identifier endTime
                 Type: uint256
                 Source: "endTime"
      ExpressionStatement
         Gas costs: 330
         Source: "require(registeredInDay[msg.sender] == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(registeredInDay[msg.sender] == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "registeredInDay[msg.sender] == 0"
            IndexAccess
               Type: uint256
               Source: "registeredInDay[msg.sender]"
              Identifier registeredInDay
                 Type: mapping(address => uint256)
                 Source: "registeredInDay"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20380
         Source: "registeredInDay[msg.sender] = 1 + now.sub(startTime).div(24*60*60)"
        Assignment using operator =
           Type: uint256
           Source: "registeredInDay[msg.sender] = 1 + now.sub(startTime).div(24*60*60)"
          IndexAccess
             Type: uint256
             Source: "registeredInDay[msg.sender]"
            Identifier registeredInDay
               Type: mapping(address => uint256)
               Source: "registeredInDay"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          BinaryOperation using operator +
             Type: uint256
             Source: "1 + now.sub(startTime).div(24*60*60)"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
            FunctionCall
               Type: uint256
               Source: "now.sub(startTime).div(24*60*60)"
              MemberAccess to member div
                 Type: function (uint256,uint256) pure returns (uint256)
                 Source: "now.sub(startTime).div"
                FunctionCall
                   Type: uint256
                   Source: "now.sub(startTime)"
                  MemberAccess to member sub
                     Type: function (uint256,uint256) pure returns (uint256)
                     Source: "now.sub"
                    Identifier now
                       Type: uint256
                       Source: "now"
                  Identifier startTime
                     Type: uint256
                     Source: "startTime"
              BinaryOperation using operator *
                 Type: int_const 86400
                 Source: "24*60*60"
                BinaryOperation using operator *
                   Type: int_const 1440
                   Source: "24*60"
                  Literal, token: [no token] value: 24
                     Type: int_const 24
                     Source: "24"
                  Literal, token: [no token] value: 60
                     Type: int_const 60
                     Source: "60"
                Literal, token: [no token] value: 60
                   Type: int_const 60
                   Source: "60"
      ExpressionStatement
         Gas costs: 20361
         Source: "participants.push(msg.sender)"
        FunctionCall
           Type: uint256
           Source: "participants.push(msg.sender)"
          MemberAccess to member push
             Type: function (address) returns (uint256)
             Source: "participants.push"
            Identifier participants
               Type: address[] storage ref
               Source: "participants"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (msg.value > 0) {\r\n            // No money => No need to handle recirsive calls\r\n            msg.sender.transfer(msg.value);\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 8
           Source: "msg.value > 0"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            // No money => No need to handle recirsive calls\r\n            msg.sender.transfer(msg.value);\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.transfer(msg.value)"
            FunctionCall
               Type: tuple()
               Source: "msg.sender.transfer(msg.value)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "msg.sender.transfer"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
  FunctionDefinition "finalize" - public
     Source: "function finalize() public onlyOwner {\r\n        require(!finalized);\r\n        require(now > endTime);\r\n\r\n        finalized = true;\r\n        Finalized();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(!finalized);\r\n        require(now > endTime);\r\n\r\n        finalized = true;\r\n        Finalized();\r\n    }"
      ExpressionStatement
         Gas costs: 318
         Source: "require(!finalized)"
        FunctionCall
           Type: tuple()
           Source: "require(!finalized)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!finalized"
            Identifier finalized
               Type: bool
               Source: "finalized"
      ExpressionStatement
         Gas costs: 234
         Source: "require(now > endTime)"
        FunctionCall
           Type: tuple()
           Source: "require(now > endTime)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "now > endTime"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier endTime
               Type: uint256
               Source: "endTime"
      ExpressionStatement
         Gas costs: 20317
         Source: "finalized = true"
        Assignment using operator =
           Type: bool
           Source: "finalized = true"
          Identifier finalized
             Type: bool
             Source: "finalized"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 786
         Source: "Finalized()"
        FunctionCall
           Type: tuple()
           Source: "Finalized()"
          Identifier Finalized
             Type: function ()
             Source: "Finalized"
  FunctionDefinition "participantBonus" - public - const
     Source: "function participantBonus(address participant) public constant returns(uint) {\r\n        uint day = registeredInDay[participant];\r\n        require(day > 0);\r\n\r\n        uint bonus = 0;\r\n        if (day <= 1) {\r\n            bonus = 6;\r\n        } else if (day <= 3) {\r\n            bonus = 5;\r\n        } else if (day <= 7) {\r\n            bonus = 4;\r\n        } else if (day <= 10) {\r\n            bonus = 3;\r\n        } else if (day <= 14) {\r\n            bonus = 2;\r\n        } else if (day <= 21) {\r\n            bonus = 1;\r\n        }\r\n\r\n        return bonus.mul(bonusMultiplier);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address participant)"
      VariableDeclaration "participant"
         Type: address
         Source: "address participant"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        uint day = registeredInDay[participant];\r\n        require(day > 0);\r\n\r\n        uint bonus = 0;\r\n        if (day <= 1) {\r\n            bonus = 6;\r\n        } else if (day <= 3) {\r\n            bonus = 5;\r\n        } else if (day <= 7) {\r\n            bonus = 4;\r\n        } else if (day <= 10) {\r\n            bonus = 3;\r\n        } else if (day <= 14) {\r\n            bonus = 2;\r\n        } else if (day <= 21) {\r\n            bonus = 1;\r\n        }\r\n\r\n        return bonus.mul(bonusMultiplier);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 307
         Source: "uint day = registeredInDay[participant]"
        VariableDeclaration "day"
           Type: uint256
           Source: "uint day"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "registeredInDay[participant]"
          Identifier registeredInDay
             Type: mapping(address => uint256)
             Source: "registeredInDay"
          Identifier participant
             Type: address
             Source: "participant"
      ExpressionStatement
         Gas costs: 35
         Source: "require(day > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(day > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "day > 0"
            Identifier day
               Type: uint256
               Source: "day"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint bonus = 0"
        VariableDeclaration "bonus"
           Type: uint256
           Source: "uint bonus"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      IfStatement
         Source: "if (day <= 1) {\r\n            bonus = 6;\r\n        } else if (day <= 3) {\r\n            bonus = 5;\r\n        } else if (day <= 7) {\r\n            bonus = 4;\r\n        } else if (day <= 10) {\r\n            bonus = 3;\r\n        } else if (day <= 14) {\r\n            bonus = 2;\r\n        } else if (day <= 21) {\r\n            bonus = 1;\r\n        }"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 12
           Source: "day <= 1"
          Identifier day
             Type: uint256
             Source: "day"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        Block
           Source: "{\r\n            bonus = 6;\r\n        }"
          ExpressionStatement
             Gas costs: 8
             Source: "bonus = 6"
            Assignment using operator =
               Type: uint256
               Source: "bonus = 6"
              Identifier bonus
                 Type: uint256
                 Source: "bonus"
              Literal, token: [no token] value: 6
                 Type: int_const 6
                 Source: "6"
        IfStatement
           Source: "if (day <= 3) {\r\n            bonus = 5;\r\n        } else if (day <= 7) {\r\n            bonus = 4;\r\n        } else if (day <= 10) {\r\n            bonus = 3;\r\n        } else if (day <= 14) {\r\n            bonus = 2;\r\n        } else if (day <= 21) {\r\n            bonus = 1;\r\n        }"
          BinaryOperation using operator <=
             Type: bool
             Gas costs: 12
             Source: "day <= 3"
            Identifier day
               Type: uint256
               Source: "day"
            Literal, token: [no token] value: 3
               Type: int_const 3
               Source: "3"
          Block
             Source: "{\r\n            bonus = 5;\r\n        }"
            ExpressionStatement
               Gas costs: 8
               Source: "bonus = 5"
              Assignment using operator =
                 Type: uint256
                 Source: "bonus = 5"
                Identifier bonus
                   Type: uint256
                   Source: "bonus"
                Literal, token: [no token] value: 5
                   Type: int_const 5
                   Source: "5"
          IfStatement
             Source: "if (day <= 7) {\r\n            bonus = 4;\r\n        } else if (day <= 10) {\r\n            bonus = 3;\r\n        } else if (day <= 14) {\r\n            bonus = 2;\r\n        } else if (day <= 21) {\r\n            bonus = 1;\r\n        }"
            BinaryOperation using operator <=
               Type: bool
               Gas costs: 12
               Source: "day <= 7"
              Identifier day
                 Type: uint256
                 Source: "day"
              Literal, token: [no token] value: 7
                 Type: int_const 7
                 Source: "7"
            Block
               Source: "{\r\n            bonus = 4;\r\n        }"
              ExpressionStatement
                 Gas costs: 8
                 Source: "bonus = 4"
                Assignment using operator =
                   Type: uint256
                   Source: "bonus = 4"
                  Identifier bonus
                     Type: uint256
                     Source: "bonus"
                  Literal, token: [no token] value: 4
                     Type: int_const 4
                     Source: "4"
            IfStatement
               Source: "if (day <= 10) {\r\n            bonus = 3;\r\n        } else if (day <= 14) {\r\n            bonus = 2;\r\n        } else if (day <= 21) {\r\n            bonus = 1;\r\n        }"
              BinaryOperation using operator <=
                 Type: bool
                 Gas costs: 12
                 Source: "day <= 10"
                Identifier day
                   Type: uint256
                   Source: "day"
                Literal, token: [no token] value: 10
                   Type: int_const 10
                   Source: "10"
              Block
                 Source: "{\r\n            bonus = 3;\r\n        }"
                ExpressionStatement
                   Gas costs: 8
                   Source: "bonus = 3"
                  Assignment using operator =
                     Type: uint256
                     Source: "bonus = 3"
                    Identifier bonus
                       Type: uint256
                       Source: "bonus"
                    Literal, token: [no token] value: 3
                       Type: int_const 3
                       Source: "3"
              IfStatement
                 Source: "if (day <= 14) {\r\n            bonus = 2;\r\n        } else if (day <= 21) {\r\n            bonus = 1;\r\n        }"
                BinaryOperation using operator <=
                   Type: bool
                   Gas costs: 12
                   Source: "day <= 14"
                  Identifier day
                     Type: uint256
                     Source: "day"
                  Literal, token: [no token] value: 14
                     Type: int_const 14
                     Source: "14"
                Block
                   Source: "{\r\n            bonus = 2;\r\n        }"
                  ExpressionStatement
                     Gas costs: 8
                     Source: "bonus = 2"
                    Assignment using operator =
                       Type: uint256
                       Source: "bonus = 2"
                      Identifier bonus
                         Type: uint256
                         Source: "bonus"
                      Literal, token: [no token] value: 2
                         Type: int_const 2
                         Source: "2"
                IfStatement
                   Source: "if (day <= 21) {\r\n            bonus = 1;\r\n        }"
                  BinaryOperation using operator <=
                     Type: bool
                     Gas costs: 12
                     Source: "day <= 21"
                    Identifier day
                       Type: uint256
                       Source: "day"
                    Literal, token: [no token] value: 21
                       Type: int_const 21
                       Source: "21"
                  Block
                     Source: "{\r\n            bonus = 1;\r\n        }"
                    ExpressionStatement
                       Gas costs: 8
                       Source: "bonus = 1"
                      Assignment using operator =
                         Type: uint256
                         Source: "bonus = 1"
                        Identifier bonus
                           Type: uint256
                           Source: "bonus"
                        Literal, token: [no token] value: 1
                           Type: int_const 1
                           Source: "1"
      Return
         Gas costs: 241
         Source: "return bonus.mul(bonusMultiplier)"
        FunctionCall
           Type: uint256
           Source: "bonus.mul(bonusMultiplier)"
          MemberAccess to member mul
             Type: function (uint256,uint256) pure returns (uint256)
             Source: "bonus.mul"
            Identifier bonus
               Type: uint256
               Source: "bonus"
          Identifier bonusMultiplier
             Type: uint256
             Source: "bonusMultiplier"
  FunctionDefinition "distribute" - public
     Source: "function distribute(uint count) public onlyOwner {\r\n        require(finalized && !distributed);\r\n        require(count > 0 && distributedCount + count <= participants.length);\r\n        \r\n        for (uint i = 0; i < count; i++) {\r\n            address participant = participants[distributedCount + i];\r\n            uint256 bonus = participantBonus(participant);\r\n            uint256 tokens = participant.balance.mul(TOKEN_RATE).mul(100 + bonus).div(100);\r\n            token.mint(participant, tokens);\r\n            distributedTokens += tokens;\r\n        }\r\n        distributedCount += count;\r\n\r\n        if (distributedCount == participants.length) {\r\n            uint256 ownerTokens = distributedTokens.mul(OWNER_TOKENS_PERCENT).div(100);\r\n            token.mint(ownerWallet, ownerTokens);\r\n            token.finishMinting();\r\n            token.unpause();\r\n            distributed = true;\r\n            Distributed();\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint count)"
      VariableDeclaration "count"
         Type: uint256
         Source: "uint count"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        require(finalized && !distributed);\r\n        require(count > 0 && distributedCount + count <= participants.length);\r\n        \r\n        for (uint i = 0; i < count; i++) {\r\n            address participant = participants[distributedCount + i];\r\n            uint256 bonus = participantBonus(participant);\r\n            uint256 tokens = participant.balance.mul(TOKEN_RATE).mul(100 + bonus).div(100);\r\n            token.mint(participant, tokens);\r\n            distributedTokens += tokens;\r\n        }\r\n        distributedCount += count;\r\n\r\n        if (distributedCount == participants.length) {\r\n            uint256 ownerTokens = distributedTokens.mul(OWNER_TOKENS_PERCENT).div(100);\r\n            token.mint(ownerWallet, ownerTokens);\r\n            token.finishMinting();\r\n            token.unpause();\r\n            distributed = true;\r\n            Distributed();\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 629
         Source: "require(finalized && !distributed)"
        FunctionCall
           Type: tuple()
           Source: "require(finalized && !distributed)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "finalized && !distributed"
            Identifier finalized
               Type: bool
               Source: "finalized"
            UnaryOperation (prefix) !
               Type: bool
               Source: "!distributed"
              Identifier distributed
                 Type: bool
                 Source: "distributed"
      ExpressionStatement
         Gas costs: 483
         Source: "require(count > 0 && distributedCount + count <= participants.length)"
        FunctionCall
           Type: tuple()
           Source: "require(count > 0 && distributedCount + count <= participants.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "count > 0 && distributedCount + count <= participants.length"
            BinaryOperation using operator >
               Type: bool
               Source: "count > 0"
              Identifier count
                 Type: uint256
                 Source: "count"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator <=
               Type: bool
               Source: "distributedCount + count <= participants.length"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "distributedCount + count"
                Identifier distributedCount
                   Type: uint256
                   Source: "distributedCount"
                Identifier count
                   Type: uint256
                   Source: "count"
              MemberAccess to member length
                 Type: uint256
                 Source: "participants.length"
                Identifier participants
                   Type: address[] storage ref
                   Source: "participants"
      ForStatement
         Source: "for (uint i = 0; i < count; i++) {\r\n            address participant = participants[distributedCount + i];\r\n            uint256 bonus = participantBonus(participant);\r\n            uint256 tokens = participant.balance.mul(TOKEN_RATE).mul(100 + bonus).div(100);\r\n            token.mint(participant, tokens);\r\n            distributedTokens += tokens;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < count"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier count
             Type: uint256
             Source: "count"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            address participant = participants[distributedCount + i];\r\n            uint256 bonus = participantBonus(participant);\r\n            uint256 tokens = participant.balance.mul(TOKEN_RATE).mul(100 + bonus).div(100);\r\n            token.mint(participant, tokens);\r\n            distributedTokens += tokens;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 742
             Source: "address participant = participants[distributedCount + i]"
            VariableDeclaration "participant"
               Type: address
               Source: "address participant"
              ElementaryTypeName address
                 Source: "address"
            IndexAccess
               Type: address
               Source: "participants[distributedCount + i]"
              Identifier participants
                 Type: address[] storage ref
                 Source: "participants"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "distributedCount + i"
                Identifier distributedCount
                   Type: uint256
                   Source: "distributedCount"
                Identifier i
                   Type: uint256
                   Source: "i"
          VariableDeclarationStatement
             Gas costs: 26
             Source: "uint256 bonus = participantBonus(participant)"
            VariableDeclaration "bonus"
               Type: uint256
               Source: "uint256 bonus"
              ElementaryTypeName uint256
                 Source: "uint256"
            FunctionCall
               Type: uint256
               Source: "participantBonus(participant)"
              Identifier participantBonus
                 Type: function (address) view returns (uint256)
                 Source: "participantBonus"
              Identifier participant
                 Type: address
                 Source: "participant"
          VariableDeclarationStatement
             Gas costs: 519
             Source: "uint256 tokens = participant.balance.mul(TOKEN_RATE).mul(100 + bonus).div(100)"
            VariableDeclaration "tokens"
               Type: uint256
               Source: "uint256 tokens"
              ElementaryTypeName uint256
                 Source: "uint256"
            FunctionCall
               Type: uint256
               Source: "participant.balance.mul(TOKEN_RATE).mul(100 + bonus).div(100)"
              MemberAccess to member div
                 Type: function (uint256,uint256) pure returns (uint256)
                 Source: "participant.balance.mul(TOKEN_RATE).mul(100 + bonus).div"
                FunctionCall
                   Type: uint256
                   Source: "participant.balance.mul(TOKEN_RATE).mul(100 + bonus)"
                  MemberAccess to member mul
                     Type: function (uint256,uint256) pure returns (uint256)
                     Source: "participant.balance.mul(TOKEN_RATE).mul"
                    FunctionCall
                       Type: uint256
                       Source: "participant.balance.mul(TOKEN_RATE)"
                      MemberAccess to member mul
                         Type: function (uint256,uint256) pure returns (uint256)
                         Source: "participant.balance.mul"
                        MemberAccess to member balance
                           Type: uint256
                           Source: "participant.balance"
                          Identifier participant
                             Type: address
                             Source: "participant"
                      Identifier TOKEN_RATE
                         Type: uint256
                         Source: "TOKEN_RATE"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "100 + bonus"
                    Literal, token: [no token] value: 100
                       Type: int_const 100
                       Source: "100"
                    Identifier bonus
                       Type: uint256
                       Source: "bonus"
              Literal, token: [no token] value: 100
                 Type: int_const 100
                 Source: "100"
          ExpressionStatement
             Gas costs: [???]
             Source: "token.mint(participant, tokens)"
            FunctionCall
               Type: bool
               Source: "token.mint(participant, tokens)"
              MemberAccess to member mint
                 Type: function (address,uint256) external returns (bool)
                 Source: "token.mint"
                Identifier token
                   Type: contract VanityToken
                   Source: "token"
              Identifier participant
                 Type: address
                 Source: "participant"
              Identifier tokens
                 Type: uint256
                 Source: "tokens"
          ExpressionStatement
             Gas costs: 20233
             Source: "distributedTokens += tokens"
            Assignment using operator +=
               Type: uint256
               Source: "distributedTokens += tokens"
              Identifier distributedTokens
                 Type: uint256
                 Source: "distributedTokens"
              Identifier tokens
                 Type: uint256
                 Source: "tokens"
      ExpressionStatement
         Gas costs: 20233
         Source: "distributedCount += count"
        Assignment using operator +=
           Type: uint256
           Source: "distributedCount += count"
          Identifier distributedCount
             Type: uint256
             Source: "distributedCount"
          Identifier count
             Type: uint256
             Source: "count"
      IfStatement
         Source: "if (distributedCount == participants.length) {\r\n            uint256 ownerTokens = distributedTokens.mul(OWNER_TOKENS_PERCENT).div(100);\r\n            token.mint(ownerWallet, ownerTokens);\r\n            token.finishMinting();\r\n            token.unpause();\r\n            distributed = true;\r\n            Distributed();\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 417
           Source: "distributedCount == participants.length"
          Identifier distributedCount
             Type: uint256
             Source: "distributedCount"
          MemberAccess to member length
             Type: uint256
             Source: "participants.length"
            Identifier participants
               Type: address[] storage ref
               Source: "participants"
        Block
           Source: "{\r\n            uint256 ownerTokens = distributedTokens.mul(OWNER_TOKENS_PERCENT).div(100);\r\n            token.mint(ownerWallet, ownerTokens);\r\n            token.finishMinting();\r\n            token.unpause();\r\n            distributed = true;\r\n            Distributed();\r\n        }"
          VariableDeclarationStatement
             Gas costs: 274
             Source: "uint256 ownerTokens = distributedTokens.mul(OWNER_TOKENS_PERCENT).div(100)"
            VariableDeclaration "ownerTokens"
               Type: uint256
               Source: "uint256 ownerTokens"
              ElementaryTypeName uint256
                 Source: "uint256"
            FunctionCall
               Type: uint256
               Source: "distributedTokens.mul(OWNER_TOKENS_PERCENT).div(100)"
              MemberAccess to member div
                 Type: function (uint256,uint256) pure returns (uint256)
                 Source: "distributedTokens.mul(OWNER_TOKENS_PERCENT).div"
                FunctionCall
                   Type: uint256
                   Source: "distributedTokens.mul(OWNER_TOKENS_PERCENT)"
                  MemberAccess to member mul
                     Type: function (uint256,uint256) pure returns (uint256)
                     Source: "distributedTokens.mul"
                    Identifier distributedTokens
                       Type: uint256
                       Source: "distributedTokens"
                  Identifier OWNER_TOKENS_PERCENT
                     Type: uint256
                     Source: "OWNER_TOKENS_PERCENT"
              Literal, token: [no token] value: 100
                 Type: int_const 100
                 Source: "100"
          ExpressionStatement
             Gas costs: [???]
             Source: "token.mint(ownerWallet, ownerTokens)"
            FunctionCall
               Type: bool
               Source: "token.mint(ownerWallet, ownerTokens)"
              MemberAccess to member mint
                 Type: function (address,uint256) external returns (bool)
                 Source: "token.mint"
                Identifier token
                   Type: contract VanityToken
                   Source: "token"
              Identifier ownerWallet
                 Type: address
                 Source: "ownerWallet"
              Identifier ownerTokens
                 Type: uint256
                 Source: "ownerTokens"
          ExpressionStatement
             Gas costs: [???]
             Source: "token.finishMinting()"
            FunctionCall
               Type: bool
               Source: "token.finishMinting()"
              MemberAccess to member finishMinting
                 Type: function () external returns (bool)
                 Source: "token.finishMinting"
                Identifier token
                   Type: contract VanityToken
                   Source: "token"
          ExpressionStatement
             Gas costs: [???]
             Source: "token.unpause()"
            FunctionCall
               Type: tuple()
               Source: "token.unpause()"
              MemberAccess to member unpause
                 Type: function () external
                 Source: "token.unpause"
                Identifier token
                   Type: contract VanityToken
                   Source: "token"
          ExpressionStatement
             Gas costs: 20317
             Source: "distributed = true"
            Assignment using operator =
               Type: bool
               Source: "distributed = true"
              Identifier distributed
                 Type: bool
                 Source: "distributed"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
          ExpressionStatement
             Gas costs: 786
             Source: "Distributed()"
            FunctionCall
               Type: tuple()
               Source: "Distributed()"
              Identifier Distributed
                 Type: function ()
                 Source: "Distributed"
