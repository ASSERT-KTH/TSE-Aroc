Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x95daaab98046846bf4b2853e23cba236fa394a31.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.16;"
ContractDefinition "SafeMath"
   Source: "contract SafeMath {\r\n\r\n    /* function assert(bool assertion) internal { */\r\n    /*   if (!assertion) { */\r\n    /*     throw; */\r\n    /*   } */\r\n    /* }      // assert no longer needed once solidity is on 0.4.10 */\r\n\r\n    function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }\r\n\r\n}"
  FunctionDefinition "safeAdd"
     Source: "function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 z = x + y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "x + y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
      ExpressionStatement
         Gas costs: 0
         Source: "assert((z >= x) && (z >= y))"
        FunctionCall
           Type: tuple()
           Source: "assert((z >= x) && (z >= y))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator &&
             Type: bool
             Source: "(z >= x) && (z >= y)"
            TupleExpression
               Type: bool
               Source: "(z >= x)"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "z >= x"
                Identifier z
                   Type: uint256
                   Source: "z"
                Identifier x
                   Type: uint256
                   Source: "x"
            TupleExpression
               Type: bool
               Source: "(z >= y)"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "z >= y"
                Identifier z
                   Type: uint256
                   Source: "z"
                Identifier y
                   Type: uint256
                   Source: "y"
      Return
         Gas costs: 0
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
  FunctionDefinition "safeSubtract"
     Source: "function safeSubtract(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(x >= y)"
        FunctionCall
           Type: tuple()
           Source: "assert(x >= y)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "x >= y"
            Identifier x
               Type: uint256
               Source: "x"
            Identifier y
               Type: uint256
               Source: "y"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 z = x - y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator -
           Type: uint256
           Source: "x - y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
      Return
         Gas costs: 0
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
  FunctionDefinition "safeMult"
     Source: "function safeMult(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 x, uint256 y)"
      VariableDeclaration "x"
         Type: uint256
         Source: "uint256 x"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "y"
         Type: uint256
         Source: "uint256 y"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint256 z = x * y"
        VariableDeclaration "z"
           Type: uint256
           Source: "uint256 z"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "x * y"
          Identifier x
             Type: uint256
             Source: "x"
          Identifier y
             Type: uint256
             Source: "y"
      ExpressionStatement
         Gas costs: 0
         Source: "assert((x == 0)||(z/x == y))"
        FunctionCall
           Type: tuple()
           Source: "assert((x == 0)||(z/x == y))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "(x == 0)||(z/x == y)"
            TupleExpression
               Type: bool
               Source: "(x == 0)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "x == 0"
                Identifier x
                   Type: uint256
                   Source: "x"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            TupleExpression
               Type: bool
               Source: "(z/x == y)"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "z/x == y"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "z/x"
                  Identifier z
                     Type: uint256
                     Source: "z"
                  Identifier x
                     Type: uint256
                     Source: "x"
                Identifier y
                   Type: uint256
                   Source: "y"
      Return
         Gas costs: 0
         Source: "return z"
        Identifier z
           Type: uint256
           Source: "z"
ContractDefinition "BasicAccessControl"
   Source: "contract BasicAccessControl {\r\n    address public owner;\r\n    // address[] public moderators;\r\n    uint16 public totalModerators = 0;\r\n    mapping (address => bool) public moderators;\r\n    bool public isMaintaining = true;\r\n\r\n    function BasicAccessControl() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyModerators() {\r\n        require(msg.sender == owner || moderators[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier isActive {\r\n        require(!isMaintaining);\r\n        _;\r\n    }\r\n\r\n    function ChangeOwner(address _newOwner) onlyOwner public {\r\n        if (_newOwner != address(0)) {\r\n            owner = _newOwner;\r\n        }\r\n    }\r\n\r\n\r\n    function AddModerator(address _newModerator) onlyOwner public {\r\n        if (moderators[_newModerator] == false) {\r\n            moderators[_newModerator] = true;\r\n            totalModerators += 1;\r\n        }\r\n    }\r\n    \r\n    function RemoveModerator(address _oldModerator) onlyOwner public {\r\n        if (moderators[_oldModerator] == true) {\r\n            moderators[_oldModerator] = false;\r\n            totalModerators -= 1;\r\n        }\r\n    }\r\n\r\n    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\r\n        isMaintaining = _isMaintaining;\r\n    }\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "totalModerators"
     Type: uint16
     Gas costs: [???]
     Source: "uint16 public totalModerators = 0"
    ElementaryTypeName uint16
       Source: "uint16"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "moderators"
     Type: mapping(address => bool)
     Gas costs: [???]
     Source: "mapping (address => bool) public moderators"
    Mapping
       Source: "mapping (address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "isMaintaining"
     Type: bool
     Gas costs: [???]
     Source: "bool public isMaintaining = true"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: true value: true
       Type: bool
       Source: "true"
  FunctionDefinition "BasicAccessControl" - public
     Source: "function BasicAccessControl() public {\r\n        owner = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 1410
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyModerators"
     Source: "modifier onlyModerators() {\r\n        require(msg.sender == owner || moderators[msg.sender] == true);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n        require(msg.sender == owner || moderators[msg.sender] == true);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 1306
         Source: "require(msg.sender == owner || moderators[msg.sender] == true)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner || moderators[msg.sender] == true)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "msg.sender == owner || moderators[msg.sender] == true"
            BinaryOperation using operator ==
               Type: bool
               Source: "msg.sender == owner"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier owner
                 Type: address
                 Source: "owner"
            BinaryOperation using operator ==
               Type: bool
               Source: "moderators[msg.sender] == true"
              IndexAccess
                 Type: bool
                 Source: "moderators[msg.sender]"
                Identifier moderators
                   Type: mapping(address => bool)
                   Source: "moderators"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "isActive"
     Source: "modifier isActive {\r\n        require(!isMaintaining);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(!isMaintaining);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 804
         Source: "require(!isMaintaining)"
        FunctionCall
           Type: tuple()
           Source: "require(!isMaintaining)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!isMaintaining"
            Identifier isMaintaining
               Type: bool
               Source: "isMaintaining"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "ChangeOwner" - public
     Source: "function ChangeOwner(address _newOwner) onlyOwner public {\r\n        if (_newOwner != address(0)) {\r\n            owner = _newOwner;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _newOwner)"
      VariableDeclaration "_newOwner"
         Type: address
         Source: "address _newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        if (_newOwner != address(0)) {\r\n            owner = _newOwner;\r\n        }\r\n    }"
      IfStatement
         Source: "if (_newOwner != address(0)) {\r\n            owner = _newOwner;\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 24
           Source: "_newOwner != address(0)"
          Identifier _newOwner
             Type: address
             Source: "_newOwner"
          FunctionCall
             Type: address
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            owner = _newOwner;\r\n        }"
          ExpressionStatement
             Gas costs: 20267
             Source: "owner = _newOwner"
            Assignment using operator =
               Type: address
               Source: "owner = _newOwner"
              Identifier owner
                 Type: address
                 Source: "owner"
              Identifier _newOwner
                 Type: address
                 Source: "_newOwner"
  FunctionDefinition "AddModerator" - public
     Source: "function AddModerator(address _newModerator) onlyOwner public {\r\n        if (moderators[_newModerator] == false) {\r\n            moderators[_newModerator] = true;\r\n            totalModerators += 1;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _newModerator)"
      VariableDeclaration "_newModerator"
         Type: address
         Source: "address _newModerator"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        if (moderators[_newModerator] == false) {\r\n            moderators[_newModerator] = true;\r\n            totalModerators += 1;\r\n        }\r\n    }"
      IfStatement
         Source: "if (moderators[_newModerator] == false) {\r\n            moderators[_newModerator] = true;\r\n            totalModerators += 1;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 353
           Source: "moderators[_newModerator] == false"
          IndexAccess
             Type: bool
             Source: "moderators[_newModerator]"
            Identifier moderators
               Type: mapping(address => bool)
               Source: "moderators"
            Identifier _newModerator
               Type: address
               Source: "_newModerator"
          Literal, token: false value: false
             Type: bool
             Source: "false"
        Block
           Source: "{\r\n            moderators[_newModerator] = true;\r\n            totalModerators += 1;\r\n        }"
          ExpressionStatement
             Gas costs: 20363
             Source: "moderators[_newModerator] = true"
            Assignment using operator =
               Type: bool
               Source: "moderators[_newModerator] = true"
              IndexAccess
                 Type: bool
                 Source: "moderators[_newModerator]"
                Identifier moderators
                   Type: mapping(address => bool)
                   Source: "moderators"
                Identifier _newModerator
                   Type: address
                   Source: "_newModerator"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
          ExpressionStatement
             Gas costs: 20617
             Source: "totalModerators += 1"
            Assignment using operator +=
               Type: uint16
               Source: "totalModerators += 1"
              Identifier totalModerators
                 Type: uint16
                 Source: "totalModerators"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
  FunctionDefinition "RemoveModerator" - public
     Source: "function RemoveModerator(address _oldModerator) onlyOwner public {\r\n        if (moderators[_oldModerator] == true) {\r\n            moderators[_oldModerator] = false;\r\n            totalModerators -= 1;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _oldModerator)"
      VariableDeclaration "_oldModerator"
         Type: address
         Source: "address _oldModerator"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        if (moderators[_oldModerator] == true) {\r\n            moderators[_oldModerator] = false;\r\n            totalModerators -= 1;\r\n        }\r\n    }"
      IfStatement
         Source: "if (moderators[_oldModerator] == true) {\r\n            moderators[_oldModerator] = false;\r\n            totalModerators -= 1;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 353
           Source: "moderators[_oldModerator] == true"
          IndexAccess
             Type: bool
             Source: "moderators[_oldModerator]"
            Identifier moderators
               Type: mapping(address => bool)
               Source: "moderators"
            Identifier _oldModerator
               Type: address
               Source: "_oldModerator"
          Literal, token: true value: true
             Type: bool
             Source: "true"
        Block
           Source: "{\r\n            moderators[_oldModerator] = false;\r\n            totalModerators -= 1;\r\n        }"
          ExpressionStatement
             Gas costs: 20363
             Source: "moderators[_oldModerator] = false"
            Assignment using operator =
               Type: bool
               Source: "moderators[_oldModerator] = false"
              IndexAccess
                 Type: bool
                 Source: "moderators[_oldModerator]"
                Identifier moderators
                   Type: mapping(address => bool)
                   Source: "moderators"
                Identifier _oldModerator
                   Type: address
                   Source: "_oldModerator"
              Literal, token: false value: false
                 Type: bool
                 Source: "false"
          ExpressionStatement
             Gas costs: 20617
             Source: "totalModerators -= 1"
            Assignment using operator -=
               Type: uint16
               Source: "totalModerators -= 1"
              Identifier totalModerators
                 Type: uint16
                 Source: "totalModerators"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
  FunctionDefinition "UpdateMaintaining" - public
     Source: "function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\r\n        isMaintaining = _isMaintaining;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(bool _isMaintaining)"
      VariableDeclaration "_isMaintaining"
         Type: bool
         Source: "bool _isMaintaining"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        isMaintaining = _isMaintaining;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "isMaintaining = _isMaintaining"
        Assignment using operator =
           Type: bool
           Source: "isMaintaining = _isMaintaining"
          Identifier isMaintaining
             Type: bool
             Source: "isMaintaining"
          Identifier _isMaintaining
             Type: bool
             Source: "_isMaintaining"
ContractDefinition "TokenRecipient"
   Gas costs: 0
   Source: "interface TokenRecipient { \r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; \r\n}"
  FunctionDefinition "receiveApproval" - public
     Source: "function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;"
    ParameterList
       Source: "(address _from, uint256 _value, address _token, bytes _extraData)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: ""
ContractDefinition "TokenERC20"
   Source: "contract TokenERC20 {\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != 0x0);\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true; \r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        TokenRecipient spender = TokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);\r\n        balanceOf[msg.sender] -= _value;\r\n        totalSupply -= _value;\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        balanceOf[_from] -= _value;\r\n        allowance[_from][msg.sender] -= _value;\r\n        totalSupply -= _value;\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "balanceOf"
     Type: mapping(address => uint256)
     Gas costs: [???]
     Source: "mapping (address => uint256) public balanceOf"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowance"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: [???]
     Source: "mapping (address => mapping (address => uint256)) public allowance"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Gas costs: 0
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Burn"
     Gas costs: 0
     Source: "event Burn(address indexed from, uint256 value);"
    ParameterList
       Source: "(address indexed from, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "_transfer"
     Source: "function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != 0x0);\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(_to != 0x0);\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_to != 0x0)"
        FunctionCall
           Type: tuple()
           Source: "require(_to != 0x0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != 0x0"
            Identifier _to
               Type: address
               Source: "_to"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balanceOf[_from] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balanceOf[_from] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balanceOf[_from] >= _value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_from]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balanceOf[_to] + _value > balanceOf[_to])"
        FunctionCall
           Type: tuple()
           Source: "require(balanceOf[_to] + _value > balanceOf[_to])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balanceOf[_to] + _value > balanceOf[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balanceOf[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[_to]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_to]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _to
                 Type: address
                 Source: "_to"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint previousBalances = balanceOf[_from] + balanceOf[_to]"
        VariableDeclaration "previousBalances"
           Type: uint256
           Source: "uint previousBalances"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "balanceOf[_from] + balanceOf[_to]"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_from]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _from
               Type: address
               Source: "_from"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_to]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _to
               Type: address
               Source: "_to"
      ExpressionStatement
         Gas costs: 0
         Source: "balanceOf[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_from]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balanceOf[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_to]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(balanceOf[_from] + balanceOf[_to] == previousBalances)"
        FunctionCall
           Type: tuple()
           Source: "assert(balanceOf[_from] + balanceOf[_to] == previousBalances)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "balanceOf[_from] + balanceOf[_to] == previousBalances"
            BinaryOperation using operator +
               Type: uint256
               Source: "balanceOf[_from] + balanceOf[_to]"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[_from]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                Identifier _from
                   Type: address
                   Source: "_from"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[_to]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier previousBalances
               Type: uint256
               Source: "previousBalances"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public {\r\n        _transfer(msg.sender, _to, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        _transfer(msg.sender, _to, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 12
         Source: "_transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "_transfer(msg.sender, _to, _value)"
          Identifier _transfer
             Type: function (address,address,uint256)
             Source: "_transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true; \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true; \r\n    }"
      ExpressionStatement
         Gas costs: 423
         Source: "require(_value <= allowance[_from][msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= allowance[_from][msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= allowance[_from][msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "allowance[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowance[_from]"
                Identifier allowance
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowance"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 20418
         Source: "allowance[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowance[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowance[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowance[_from]"
              Identifier allowance
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowance"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 24
         Source: "_transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "_transfer(_from, _to, _value)"
          Identifier _transfer
             Type: function (address,address,uint256)
             Source: "_transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowance[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowance[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowance[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowance[msg.sender]"
              Identifier allowance
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowance"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approveAndCall" - public
     Source: "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        TokenRecipient spender = TokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value, bytes _extraData)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        TokenRecipient spender = TokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "TokenRecipient spender = TokenRecipient(_spender)"
        VariableDeclaration "spender"
           Type: contract TokenRecipient
           Source: "TokenRecipient spender"
          UserDefinedTypeName "TokenRecipient"
             Source: "TokenRecipient"
        FunctionCall
           Type: contract TokenRecipient
           Source: "TokenRecipient(_spender)"
          Identifier TokenRecipient
             Type: type(contract TokenRecipient)
             Source: "TokenRecipient"
          Identifier _spender
             Type: address
             Source: "_spender"
      IfStatement
         Source: "if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 21
           Source: "approve(_spender, _value)"
          Identifier approve
             Type: function (address,uint256) returns (bool)
             Source: "approve"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
        Block
           Source: "{\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "spender.receiveApproval(msg.sender, _value, this, _extraData)"
            FunctionCall
               Type: tuple()
               Source: "spender.receiveApproval(msg.sender, _value, this, _extraData)"
              MemberAccess to member receiveApproval
                 Type: function (address,uint256,address,bytes memory) external
                 Source: "spender.receiveApproval"
                Identifier spender
                   Type: contract TokenRecipient
                   Source: "spender"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier this
                 Type: contract TokenERC20
                 Source: "this"
              Identifier _extraData
                 Type: bytes memory
                 Source: "_extraData"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
  FunctionDefinition "burn" - public
     Source: "function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);\r\n        balanceOf[msg.sender] -= _value;\r\n        totalSupply -= _value;\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _value)"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require(balanceOf[msg.sender] >= _value);\r\n        balanceOf[msg.sender] -= _value;\r\n        totalSupply -= _value;\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 333
         Source: "require(balanceOf[msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balanceOf[msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balanceOf[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[msg.sender]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20328
         Source: "balanceOf[msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= _value"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Burn(msg.sender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Burn(msg.sender, _value)"
          Identifier Burn
             Type: function (address,uint256)
             Source: "Burn"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "burnFrom" - public
     Source: "function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        balanceOf[_from] -= _value;\r\n        allowance[_from][msg.sender] -= _value;\r\n        totalSupply -= _value;\r\n        Burn(_from, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require(balanceOf[_from] >= _value);\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        balanceOf[_from] -= _value;\r\n        allowance[_from][msg.sender] -= _value;\r\n        totalSupply -= _value;\r\n        Burn(_from, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 334
         Source: "require(balanceOf[_from] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balanceOf[_from] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balanceOf[_from] >= _value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_from]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 423
         Source: "require(_value <= allowance[_from][msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= allowance[_from][msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= allowance[_from][msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "allowance[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowance[_from]"
                Identifier allowance
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowance"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 20329
         Source: "balanceOf[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_from]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20412
         Source: "allowance[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowance[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowance[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowance[_from]"
              Identifier allowance
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowance"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= _value"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Burn(_from, _value)"
        FunctionCall
           Type: tuple()
           Source: "Burn(_from, _value)"
          Identifier Burn
             Type: function (address,uint256)
             Source: "Burn"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
ContractDefinition "PaymentInterface"
   Gas costs: 0
   Source: "contract PaymentInterface {\r\n    function createCastle(address _trainer, uint _tokens, string _name, uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3) public returns(uint);\r\n    function catchMonster(address _trainer, uint _tokens, uint32 _classId, string _name) public returns(uint);\r\n    function payService(address _trainer, uint _tokens, uint32 _type, string _text, uint64 _param1, uint64 _param2, uint64 _param3, uint64 _param4, uint64 _param5, uint64 _param6) public returns(uint);\r\n}"
  FunctionDefinition "createCastle" - public
     Source: "function createCastle(address _trainer, uint _tokens, string _name, uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3) public returns(uint);"
    ParameterList
       Source: "(address _trainer, uint _tokens, string _name, uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3)"
      VariableDeclaration "_trainer"
         Type: address
         Source: "address _trainer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_name"
         Type: string memory
         Source: "string _name"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_a1"
         Type: uint64
         Source: "uint64 _a1"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_a2"
         Type: uint64
         Source: "uint64 _a2"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_a3"
         Type: uint64
         Source: "uint64 _a3"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_s1"
         Type: uint64
         Source: "uint64 _s1"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_s2"
         Type: uint64
         Source: "uint64 _s2"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_s3"
         Type: uint64
         Source: "uint64 _s3"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "catchMonster" - public
     Source: "function catchMonster(address _trainer, uint _tokens, uint32 _classId, string _name) public returns(uint);"
    ParameterList
       Source: "(address _trainer, uint _tokens, uint32 _classId, string _name)"
      VariableDeclaration "_trainer"
         Type: address
         Source: "address _trainer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_classId"
         Type: uint32
         Source: "uint32 _classId"
        ElementaryTypeName uint32
           Source: "uint32"
      VariableDeclaration "_name"
         Type: string memory
         Source: "string _name"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "payService" - public
     Source: "function payService(address _trainer, uint _tokens, uint32 _type, string _text, uint64 _param1, uint64 _param2, uint64 _param3, uint64 _param4, uint64 _param5, uint64 _param6) public returns(uint);"
    ParameterList
       Source: "(address _trainer, uint _tokens, uint32 _type, string _text, uint64 _param1, uint64 _param2, uint64 _param3, uint64 _param4, uint64 _param5, uint64 _param6)"
      VariableDeclaration "_trainer"
         Type: address
         Source: "address _trainer"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_type"
         Type: uint32
         Source: "uint32 _type"
        ElementaryTypeName uint32
           Source: "uint32"
      VariableDeclaration "_text"
         Type: string memory
         Source: "string _text"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_param1"
         Type: uint64
         Source: "uint64 _param1"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_param2"
         Type: uint64
         Source: "uint64 _param2"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_param3"
         Type: uint64
         Source: "uint64 _param3"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_param4"
         Type: uint64
         Source: "uint64 _param4"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_param5"
         Type: uint64
         Source: "uint64 _param5"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_param6"
         Type: uint64
         Source: "uint64 _param6"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "EtheremonToken"
   Source: "contract EtheremonToken is BasicAccessControl, TokenERC20 {\r\n    // metadata\r\n    string public constant name = \"EtheremonToken\";\r\n    string public constant symbol = \"EMONT\";\r\n    uint256 public constant decimals = 8;\r\n    string public version = \"1.0\";\r\n    \r\n    // deposit address\r\n    address public inGameRewardAddress;\r\n    address public userGrowPoolAddress;\r\n    address public developerAddress;\r\n    \r\n    // Etheremon payment\r\n    address public paymentContract;\r\n    \r\n    // for future feature\r\n    uint256 public sellPrice;\r\n    uint256 public buyPrice;\r\n    bool public trading = false;\r\n    mapping (address => bool) public frozenAccount;\r\n    event FrozenFunds(address target, bool frozen);\r\n    \r\n    modifier isTrading {\r\n        require(trading == true || msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier requirePaymentContract {\r\n        require(paymentContract != address(0));\r\n        _;        \r\n    }\r\n    \r\n    function () payable public {}\r\n\r\n    // constructor    \r\n    function EtheremonToken(address _inGameRewardAddress, address _userGrowPoolAddress, address _developerAddress, address _paymentContract) public {\r\n        require(_inGameRewardAddress != address(0));\r\n        require(_userGrowPoolAddress != address(0));\r\n        require(_developerAddress != address(0));\r\n        inGameRewardAddress = _inGameRewardAddress;\r\n        userGrowPoolAddress = _userGrowPoolAddress;\r\n        developerAddress = _developerAddress;\r\n\r\n        balanceOf[inGameRewardAddress] = 14000000 * 10**uint(decimals);\r\n        balanceOf[userGrowPoolAddress] = 5000000 * 10**uint(decimals);\r\n        balanceOf[developerAddress] = 1000000 * 10**uint(decimals);\r\n        totalSupply = balanceOf[inGameRewardAddress] + balanceOf[userGrowPoolAddress] + balanceOf[developerAddress];\r\n        paymentContract = _paymentContract;\r\n    }\r\n    \r\n    // moderators\r\n    function setAddress(address _inGameRewardAddress, address _userGrowPoolAddress, address _developerAddress, address _paymentContract) onlyModerators external {\r\n        inGameRewardAddress = _inGameRewardAddress;\r\n        userGrowPoolAddress = _userGrowPoolAddress;\r\n        developerAddress = _developerAddress;\r\n        paymentContract = _paymentContract;\r\n    }\r\n    \r\n    // public\r\n    function withdrawEther(address _sendTo, uint _amount) onlyModerators external {\r\n        if (_amount > this.balance) {\r\n            revert();\r\n        }\r\n        _sendTo.transfer(_amount);\r\n    }\r\n    \r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require (_to != 0x0);\r\n        require (balanceOf[_from] >= _value);\r\n        require (balanceOf[_to] + _value > balanceOf[_to]);\r\n        require(!frozenAccount[_from]);\r\n        require(!frozenAccount[_to]);\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n    }\r\n    \r\n    function freezeAccount(address _target, bool _freeze) onlyOwner public {\r\n        frozenAccount[_target] = _freeze;\r\n        FrozenFunds(_target, _freeze);\r\n    }\r\n    \r\n    function buy() payable isTrading public {\r\n        uint amount = msg.value / buyPrice;\r\n        _transfer(this, msg.sender, amount);\r\n    }\r\n\r\n    function sell(uint256 amount) isTrading public {\r\n        require(this.balance >= amount * sellPrice);\r\n        _transfer(msg.sender, this, amount);\r\n        msg.sender.transfer(amount * sellPrice);\r\n    }\r\n    \r\n    // Etheremon \r\n    function createCastle(uint _tokens, string _name, uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3) isActive requirePaymentContract external {\r\n        if (_tokens > balanceOf[msg.sender])\r\n            revert();\r\n        PaymentInterface payment = PaymentInterface(paymentContract);\r\n        uint deductedTokens = payment.createCastle(msg.sender, _tokens, _name, _a1, _a2, _a3, _s1, _s2, _s3);\r\n        if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert();\r\n        _transfer(msg.sender, inGameRewardAddress, deductedTokens);\r\n    }\r\n    \r\n    function catchMonster(uint _tokens, uint32 _classId, string _name) isActive requirePaymentContract external {\r\n        if (_tokens > balanceOf[msg.sender])\r\n            revert();\r\n        PaymentInterface payment = PaymentInterface(paymentContract);\r\n        uint deductedTokens = payment.catchMonster(msg.sender, _tokens, _classId, _name);\r\n        if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert();\r\n        _transfer(msg.sender, inGameRewardAddress, deductedTokens);\r\n    }\r\n    \r\n    function payService(uint _tokens, uint32 _type, string _text, uint64 _param1, uint64 _param2, uint64 _param3, uint64 _param4, uint64 _param5, uint64 _param6) isActive requirePaymentContract external {\r\n        if (_tokens > balanceOf[msg.sender])\r\n            revert();\r\n        PaymentInterface payment = PaymentInterface(paymentContract);\r\n        uint deductedTokens = payment.payService(msg.sender, _tokens, _type, _text, _param1, _param2, _param3, _param4, _param5, _param6);\r\n        if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert();\r\n        _transfer(msg.sender, inGameRewardAddress, deductedTokens);\r\n    }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "BasicAccessControl"
    UserDefinedTypeName "BasicAccessControl"
       Source: "BasicAccessControl"
  InheritanceSpecifier
     Gas costs: 0
     Source: "TokenERC20"
    UserDefinedTypeName "TokenERC20"
       Source: "TokenERC20"
  VariableDeclaration "name"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant name = \"EtheremonToken\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: EtheremonToken
       Type: literal_string "EtheremonToken"
       Source: "\"EtheremonToken\""
  VariableDeclaration "symbol"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant symbol = \"EMONT\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: EMONT
       Type: literal_string "EMONT"
       Source: "\"EMONT\""
  VariableDeclaration "decimals"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant decimals = 8"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 8
       Type: int_const 8
       Source: "8"
  VariableDeclaration "version"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public version = \"1.0\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: 1.0
       Type: literal_string "1.0"
       Source: "\"1.0\""
  VariableDeclaration "inGameRewardAddress"
     Type: address
     Gas costs: [???]
     Source: "address public inGameRewardAddress"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "userGrowPoolAddress"
     Type: address
     Gas costs: [???]
     Source: "address public userGrowPoolAddress"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "developerAddress"
     Type: address
     Gas costs: [???]
     Source: "address public developerAddress"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "paymentContract"
     Type: address
     Gas costs: [???]
     Source: "address public paymentContract"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "sellPrice"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public sellPrice"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "buyPrice"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public buyPrice"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "trading"
     Type: bool
     Gas costs: [???]
     Source: "bool public trading = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "frozenAccount"
     Type: mapping(address => bool)
     Gas costs: [???]
     Source: "mapping (address => bool) public frozenAccount"
    Mapping
       Source: "mapping (address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  EventDefinition "FrozenFunds"
     Gas costs: 0
     Source: "event FrozenFunds(address target, bool frozen);"
    ParameterList
       Source: "(address target, bool frozen)"
      VariableDeclaration "target"
         Type: address
         Source: "address target"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "frozen"
         Type: bool
         Source: "bool frozen"
        ElementaryTypeName bool
           Source: "bool"
  ModifierDefinition "isTrading"
     Source: "modifier isTrading {\r\n        require(trading == true || msg.sender == owner);\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(trading == true || msg.sender == owner);\r\n        _;\r\n    }"
      ExpressionStatement
         Gas costs: 1116
         Source: "require(trading == true || msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(trading == true || msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "trading == true || msg.sender == owner"
            BinaryOperation using operator ==
               Type: bool
               Source: "trading == true"
              Identifier trading
                 Type: bool
                 Source: "trading"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
            BinaryOperation using operator ==
               Type: bool
               Source: "msg.sender == owner"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier owner
                 Type: address
                 Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "requirePaymentContract"
     Source: "modifier requirePaymentContract {\r\n        require(paymentContract != address(0));\r\n        _;        \r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(paymentContract != address(0));\r\n        _;        \r\n    }"
      ExpressionStatement
         Gas costs: 858
         Source: "require(paymentContract != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(paymentContract != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "paymentContract != address(0)"
            Identifier paymentContract
               Type: address
               Source: "paymentContract"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "" - public
     Source: "function () payable public {}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "EtheremonToken" - public
     Source: "function EtheremonToken(address _inGameRewardAddress, address _userGrowPoolAddress, address _developerAddress, address _paymentContract) public {\r\n        require(_inGameRewardAddress != address(0));\r\n        require(_userGrowPoolAddress != address(0));\r\n        require(_developerAddress != address(0));\r\n        inGameRewardAddress = _inGameRewardAddress;\r\n        userGrowPoolAddress = _userGrowPoolAddress;\r\n        developerAddress = _developerAddress;\r\n\r\n        balanceOf[inGameRewardAddress] = 14000000 * 10**uint(decimals);\r\n        balanceOf[userGrowPoolAddress] = 5000000 * 10**uint(decimals);\r\n        balanceOf[developerAddress] = 1000000 * 10**uint(decimals);\r\n        totalSupply = balanceOf[inGameRewardAddress] + balanceOf[userGrowPoolAddress] + balanceOf[developerAddress];\r\n        paymentContract = _paymentContract;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _inGameRewardAddress, address _userGrowPoolAddress, address _developerAddress, address _paymentContract)"
      VariableDeclaration "_inGameRewardAddress"
         Type: address
         Source: "address _inGameRewardAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_userGrowPoolAddress"
         Type: address
         Source: "address _userGrowPoolAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_developerAddress"
         Type: address
         Source: "address _developerAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_paymentContract"
         Type: address
         Source: "address _paymentContract"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(_inGameRewardAddress != address(0));\r\n        require(_userGrowPoolAddress != address(0));\r\n        require(_developerAddress != address(0));\r\n        inGameRewardAddress = _inGameRewardAddress;\r\n        userGrowPoolAddress = _userGrowPoolAddress;\r\n        developerAddress = _developerAddress;\r\n\r\n        balanceOf[inGameRewardAddress] = 14000000 * 10**uint(decimals);\r\n        balanceOf[userGrowPoolAddress] = 5000000 * 10**uint(decimals);\r\n        balanceOf[developerAddress] = 1000000 * 10**uint(decimals);\r\n        totalSupply = balanceOf[inGameRewardAddress] + balanceOf[userGrowPoolAddress] + balanceOf[developerAddress];\r\n        paymentContract = _paymentContract;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_inGameRewardAddress != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_inGameRewardAddress != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_inGameRewardAddress != address(0)"
            Identifier _inGameRewardAddress
               Type: address
               Source: "_inGameRewardAddress"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_userGrowPoolAddress != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_userGrowPoolAddress != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_userGrowPoolAddress != address(0)"
            Identifier _userGrowPoolAddress
               Type: address
               Source: "_userGrowPoolAddress"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_developerAddress != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_developerAddress != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_developerAddress != address(0)"
            Identifier _developerAddress
               Type: address
               Source: "_developerAddress"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "inGameRewardAddress = _inGameRewardAddress"
        Assignment using operator =
           Type: address
           Source: "inGameRewardAddress = _inGameRewardAddress"
          Identifier inGameRewardAddress
             Type: address
             Source: "inGameRewardAddress"
          Identifier _inGameRewardAddress
             Type: address
             Source: "_inGameRewardAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "userGrowPoolAddress = _userGrowPoolAddress"
        Assignment using operator =
           Type: address
           Source: "userGrowPoolAddress = _userGrowPoolAddress"
          Identifier userGrowPoolAddress
             Type: address
             Source: "userGrowPoolAddress"
          Identifier _userGrowPoolAddress
             Type: address
             Source: "_userGrowPoolAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "developerAddress = _developerAddress"
        Assignment using operator =
           Type: address
           Source: "developerAddress = _developerAddress"
          Identifier developerAddress
             Type: address
             Source: "developerAddress"
          Identifier _developerAddress
             Type: address
             Source: "_developerAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "balanceOf[inGameRewardAddress] = 14000000 * 10**uint(decimals)"
        Assignment using operator =
           Type: uint256
           Source: "balanceOf[inGameRewardAddress] = 14000000 * 10**uint(decimals)"
          IndexAccess
             Type: uint256
             Source: "balanceOf[inGameRewardAddress]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier inGameRewardAddress
               Type: address
               Source: "inGameRewardAddress"
          BinaryOperation using operator *
             Type: uint256
             Source: "14000000 * 10**uint(decimals)"
            Literal, token: [no token] value: 14000000
               Type: int_const 14000000
               Source: "14000000"
            BinaryOperation using operator **
               Type: uint256
               Source: "10**uint(decimals)"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              FunctionCall
                 Type: uint256
                 Source: "uint(decimals)"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                Identifier decimals
                   Type: uint256
                   Source: "decimals"
      ExpressionStatement
         Gas costs: 0
         Source: "balanceOf[userGrowPoolAddress] = 5000000 * 10**uint(decimals)"
        Assignment using operator =
           Type: uint256
           Source: "balanceOf[userGrowPoolAddress] = 5000000 * 10**uint(decimals)"
          IndexAccess
             Type: uint256
             Source: "balanceOf[userGrowPoolAddress]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier userGrowPoolAddress
               Type: address
               Source: "userGrowPoolAddress"
          BinaryOperation using operator *
             Type: uint256
             Source: "5000000 * 10**uint(decimals)"
            Literal, token: [no token] value: 5000000
               Type: int_const 5000000
               Source: "5000000"
            BinaryOperation using operator **
               Type: uint256
               Source: "10**uint(decimals)"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              FunctionCall
                 Type: uint256
                 Source: "uint(decimals)"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                Identifier decimals
                   Type: uint256
                   Source: "decimals"
      ExpressionStatement
         Gas costs: 0
         Source: "balanceOf[developerAddress] = 1000000 * 10**uint(decimals)"
        Assignment using operator =
           Type: uint256
           Source: "balanceOf[developerAddress] = 1000000 * 10**uint(decimals)"
          IndexAccess
             Type: uint256
             Source: "balanceOf[developerAddress]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier developerAddress
               Type: address
               Source: "developerAddress"
          BinaryOperation using operator *
             Type: uint256
             Source: "1000000 * 10**uint(decimals)"
            Literal, token: [no token] value: 1000000
               Type: int_const 1000000
               Source: "1000000"
            BinaryOperation using operator **
               Type: uint256
               Source: "10**uint(decimals)"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              FunctionCall
                 Type: uint256
                 Source: "uint(decimals)"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                Identifier decimals
                   Type: uint256
                   Source: "decimals"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = balanceOf[inGameRewardAddress] + balanceOf[userGrowPoolAddress] + balanceOf[developerAddress]"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = balanceOf[inGameRewardAddress] + balanceOf[userGrowPoolAddress] + balanceOf[developerAddress]"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          BinaryOperation using operator +
             Type: uint256
             Source: "balanceOf[inGameRewardAddress] + balanceOf[userGrowPoolAddress] + balanceOf[developerAddress]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balanceOf[inGameRewardAddress] + balanceOf[userGrowPoolAddress]"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[inGameRewardAddress]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                Identifier inGameRewardAddress
                   Type: address
                   Source: "inGameRewardAddress"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[userGrowPoolAddress]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                Identifier userGrowPoolAddress
                   Type: address
                   Source: "userGrowPoolAddress"
            IndexAccess
               Type: uint256
               Source: "balanceOf[developerAddress]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier developerAddress
                 Type: address
                 Source: "developerAddress"
      ExpressionStatement
         Gas costs: 0
         Source: "paymentContract = _paymentContract"
        Assignment using operator =
           Type: address
           Source: "paymentContract = _paymentContract"
          Identifier paymentContract
             Type: address
             Source: "paymentContract"
          Identifier _paymentContract
             Type: address
             Source: "_paymentContract"
  FunctionDefinition "setAddress" - public
     Source: "function setAddress(address _inGameRewardAddress, address _userGrowPoolAddress, address _developerAddress, address _paymentContract) onlyModerators external {\r\n        inGameRewardAddress = _inGameRewardAddress;\r\n        userGrowPoolAddress = _userGrowPoolAddress;\r\n        developerAddress = _developerAddress;\r\n        paymentContract = _paymentContract;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _inGameRewardAddress, address _userGrowPoolAddress, address _developerAddress, address _paymentContract)"
      VariableDeclaration "_inGameRewardAddress"
         Type: address
         Source: "address _inGameRewardAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_userGrowPoolAddress"
         Type: address
         Source: "address _userGrowPoolAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_developerAddress"
         Type: address
         Source: "address _developerAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_paymentContract"
         Type: address
         Source: "address _paymentContract"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyModerators"
       Gas costs: 0
       Source: "onlyModerators"
      Identifier onlyModerators
         Type: modifier ()
         Source: "onlyModerators"
    Block
       Source: "{\r\n        inGameRewardAddress = _inGameRewardAddress;\r\n        userGrowPoolAddress = _userGrowPoolAddress;\r\n        developerAddress = _developerAddress;\r\n        paymentContract = _paymentContract;\r\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "inGameRewardAddress = _inGameRewardAddress"
        Assignment using operator =
           Type: address
           Source: "inGameRewardAddress = _inGameRewardAddress"
          Identifier inGameRewardAddress
             Type: address
             Source: "inGameRewardAddress"
          Identifier _inGameRewardAddress
             Type: address
             Source: "_inGameRewardAddress"
      ExpressionStatement
         Gas costs: 20267
         Source: "userGrowPoolAddress = _userGrowPoolAddress"
        Assignment using operator =
           Type: address
           Source: "userGrowPoolAddress = _userGrowPoolAddress"
          Identifier userGrowPoolAddress
             Type: address
             Source: "userGrowPoolAddress"
          Identifier _userGrowPoolAddress
             Type: address
             Source: "_userGrowPoolAddress"
      ExpressionStatement
         Gas costs: 20267
         Source: "developerAddress = _developerAddress"
        Assignment using operator =
           Type: address
           Source: "developerAddress = _developerAddress"
          Identifier developerAddress
             Type: address
             Source: "developerAddress"
          Identifier _developerAddress
             Type: address
             Source: "_developerAddress"
      ExpressionStatement
         Gas costs: 20267
         Source: "paymentContract = _paymentContract"
        Assignment using operator =
           Type: address
           Source: "paymentContract = _paymentContract"
          Identifier paymentContract
             Type: address
             Source: "paymentContract"
          Identifier _paymentContract
             Type: address
             Source: "_paymentContract"
  FunctionDefinition "withdrawEther" - public
     Source: "function withdrawEther(address _sendTo, uint _amount) onlyModerators external {\r\n        if (_amount > this.balance) {\r\n            revert();\r\n        }\r\n        _sendTo.transfer(_amount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _sendTo, uint _amount)"
      VariableDeclaration "_sendTo"
         Type: address
         Source: "address _sendTo"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyModerators"
       Gas costs: 0
       Source: "onlyModerators"
      Identifier onlyModerators
         Type: modifier ()
         Source: "onlyModerators"
    Block
       Source: "{\r\n        if (_amount > this.balance) {\r\n            revert();\r\n        }\r\n        _sendTo.transfer(_amount);\r\n    }"
      IfStatement
         Source: "if (_amount > this.balance) {\r\n            revert();\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 414
           Source: "_amount > this.balance"
          Identifier _amount
             Type: uint256
             Source: "_amount"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract EtheremonToken
               Source: "this"
        Block
           Source: "{\r\n            revert();\r\n        }"
          ExpressionStatement
             Gas costs: 6
             Source: "revert()"
            FunctionCall
               Type: tuple()
               Source: "revert()"
              Identifier revert
                 Type: function () pure
                 Source: "revert"
      ExpressionStatement
         Gas costs: [???]
         Source: "_sendTo.transfer(_amount)"
        FunctionCall
           Type: tuple()
           Source: "_sendTo.transfer(_amount)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "_sendTo.transfer"
            Identifier _sendTo
               Type: address
               Source: "_sendTo"
          Identifier _amount
             Type: uint256
             Source: "_amount"
  FunctionDefinition "_transfer"
     Source: "function _transfer(address _from, address _to, uint _value) internal {\r\n        require (_to != 0x0);\r\n        require (balanceOf[_from] >= _value);\r\n        require (balanceOf[_to] + _value > balanceOf[_to]);\r\n        require(!frozenAccount[_from]);\r\n        require(!frozenAccount[_to]);\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require (_to != 0x0);\r\n        require (balanceOf[_from] >= _value);\r\n        require (balanceOf[_to] + _value > balanceOf[_to]);\r\n        require(!frozenAccount[_from]);\r\n        require(!frozenAccount[_to]);\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n    }"
      ExpressionStatement
         Gas costs: 44
         Source: "require (_to != 0x0)"
        FunctionCall
           Type: tuple()
           Source: "require (_to != 0x0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != 0x0"
            Identifier _to
               Type: address
               Source: "_to"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      ExpressionStatement
         Gas costs: 334
         Source: "require (balanceOf[_from] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require (balanceOf[_from] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balanceOf[_from] >= _value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_from]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 627
         Source: "require (balanceOf[_to] + _value > balanceOf[_to])"
        FunctionCall
           Type: tuple()
           Source: "require (balanceOf[_to] + _value > balanceOf[_to])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balanceOf[_to] + _value > balanceOf[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balanceOf[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[_to]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_to]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _to
                 Type: address
                 Source: "_to"
      ExpressionStatement
         Gas costs: 364
         Source: "require(!frozenAccount[_from])"
        FunctionCall
           Type: tuple()
           Source: "require(!frozenAccount[_from])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!frozenAccount[_from]"
            IndexAccess
               Type: bool
               Source: "frozenAccount[_from]"
              Identifier frozenAccount
                 Type: mapping(address => bool)
                 Source: "frozenAccount"
              Identifier _from
                 Type: address
                 Source: "_from"
      ExpressionStatement
         Gas costs: 364
         Source: "require(!frozenAccount[_to])"
        FunctionCall
           Type: tuple()
           Source: "require(!frozenAccount[_to])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!frozenAccount[_to]"
            IndexAccess
               Type: bool
               Source: "frozenAccount[_to]"
              Identifier frozenAccount
                 Type: mapping(address => bool)
                 Source: "frozenAccount"
              Identifier _to
                 Type: address
                 Source: "_to"
      ExpressionStatement
         Gas costs: 20329
         Source: "balanceOf[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_from]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balanceOf[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_to]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "freezeAccount" - public
     Source: "function freezeAccount(address _target, bool _freeze) onlyOwner public {\r\n        frozenAccount[_target] = _freeze;\r\n        FrozenFunds(_target, _freeze);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _target, bool _freeze)"
      VariableDeclaration "_target"
         Type: address
         Source: "address _target"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_freeze"
         Type: bool
         Source: "bool _freeze"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        frozenAccount[_target] = _freeze;\r\n        FrozenFunds(_target, _freeze);\r\n    }"
      ExpressionStatement
         Gas costs: 20363
         Source: "frozenAccount[_target] = _freeze"
        Assignment using operator =
           Type: bool
           Source: "frozenAccount[_target] = _freeze"
          IndexAccess
             Type: bool
             Source: "frozenAccount[_target]"
            Identifier frozenAccount
               Type: mapping(address => bool)
               Source: "frozenAccount"
            Identifier _target
               Type: address
               Source: "_target"
          Identifier _freeze
             Type: bool
             Source: "_freeze"
      ExpressionStatement
         Gas costs: [???]
         Source: "FrozenFunds(_target, _freeze)"
        FunctionCall
           Type: tuple()
           Source: "FrozenFunds(_target, _freeze)"
          Identifier FrozenFunds
             Type: function (address,bool)
             Source: "FrozenFunds"
          Identifier _target
             Type: address
             Source: "_target"
          Identifier _freeze
             Type: bool
             Source: "_freeze"
  FunctionDefinition "buy" - public
     Source: "function buy() payable isTrading public {\r\n        uint amount = msg.value / buyPrice;\r\n        _transfer(this, msg.sender, amount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "isTrading"
       Gas costs: 0
       Source: "isTrading"
      Identifier isTrading
         Type: modifier ()
         Source: "isTrading"
    Block
       Source: "{\r\n        uint amount = msg.value / buyPrice;\r\n        _transfer(this, msg.sender, amount);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 241
         Source: "uint amount = msg.value / buyPrice"
        VariableDeclaration "amount"
           Type: uint256
           Source: "uint amount"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "msg.value / buyPrice"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier buyPrice
             Type: uint256
             Source: "buyPrice"
      ExpressionStatement
         Gas costs: 22
         Source: "_transfer(this, msg.sender, amount)"
        FunctionCall
           Type: tuple()
           Source: "_transfer(this, msg.sender, amount)"
          Identifier _transfer
             Type: function (address,address,uint256)
             Source: "_transfer"
          Identifier this
             Type: contract EtheremonToken
             Source: "this"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier amount
             Type: uint256
             Source: "amount"
  FunctionDefinition "sell" - public
     Source: "function sell(uint256 amount) isTrading public {\r\n        require(this.balance >= amount * sellPrice);\r\n        _transfer(msg.sender, this, amount);\r\n        msg.sender.transfer(amount * sellPrice);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "isTrading"
       Gas costs: 0
       Source: "isTrading"
      Identifier isTrading
         Type: modifier ()
         Source: "isTrading"
    Block
       Source: "{\r\n        require(this.balance >= amount * sellPrice);\r\n        _transfer(msg.sender, this, amount);\r\n        msg.sender.transfer(amount * sellPrice);\r\n    }"
      ExpressionStatement
         Gas costs: 651
         Source: "require(this.balance >= amount * sellPrice)"
        FunctionCall
           Type: tuple()
           Source: "require(this.balance >= amount * sellPrice)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "this.balance >= amount * sellPrice"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract EtheremonToken
                 Source: "this"
            BinaryOperation using operator *
               Type: uint256
               Source: "amount * sellPrice"
              Identifier amount
                 Type: uint256
                 Source: "amount"
              Identifier sellPrice
                 Type: uint256
                 Source: "sellPrice"
      ExpressionStatement
         Gas costs: 22
         Source: "_transfer(msg.sender, this, amount)"
        FunctionCall
           Type: tuple()
           Source: "_transfer(msg.sender, this, amount)"
          Identifier _transfer
             Type: function (address,address,uint256)
             Source: "_transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier this
             Type: contract EtheremonToken
             Source: "this"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "msg.sender.transfer(amount * sellPrice)"
        FunctionCall
           Type: tuple()
           Source: "msg.sender.transfer(amount * sellPrice)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "msg.sender.transfer"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          BinaryOperation using operator *
             Type: uint256
             Source: "amount * sellPrice"
            Identifier amount
               Type: uint256
               Source: "amount"
            Identifier sellPrice
               Type: uint256
               Source: "sellPrice"
  FunctionDefinition "createCastle" - public
     Source: "function createCastle(uint _tokens, string _name, uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3) isActive requirePaymentContract external {\r\n        if (_tokens > balanceOf[msg.sender])\r\n            revert();\r\n        PaymentInterface payment = PaymentInterface(paymentContract);\r\n        uint deductedTokens = payment.createCastle(msg.sender, _tokens, _name, _a1, _a2, _a3, _s1, _s2, _s3);\r\n        if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert();\r\n        _transfer(msg.sender, inGameRewardAddress, deductedTokens);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _tokens, string _name, uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3)"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_name"
         Type: string calldata
         Source: "string _name"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_a1"
         Type: uint64
         Source: "uint64 _a1"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_a2"
         Type: uint64
         Source: "uint64 _a2"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_a3"
         Type: uint64
         Source: "uint64 _a3"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_s1"
         Type: uint64
         Source: "uint64 _s1"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_s2"
         Type: uint64
         Source: "uint64 _s2"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_s3"
         Type: uint64
         Source: "uint64 _s3"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "isActive"
       Gas costs: 0
       Source: "isActive"
      Identifier isActive
         Type: modifier ()
         Source: "isActive"
    ModifierInvocation "requirePaymentContract"
       Gas costs: 0
       Source: "requirePaymentContract"
      Identifier requirePaymentContract
         Type: modifier ()
         Source: "requirePaymentContract"
    Block
       Source: "{\r\n        if (_tokens > balanceOf[msg.sender])\r\n            revert();\r\n        PaymentInterface payment = PaymentInterface(paymentContract);\r\n        uint deductedTokens = payment.createCastle(msg.sender, _tokens, _name, _a1, _a2, _a3, _s1, _s2, _s3);\r\n        if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert();\r\n        _transfer(msg.sender, inGameRewardAddress, deductedTokens);\r\n    }"
      IfStatement
         Source: "if (_tokens > balanceOf[msg.sender])\r\n            revert()"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 304
           Source: "_tokens > balanceOf[msg.sender]"
          Identifier _tokens
             Type: uint256
             Source: "_tokens"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      VariableDeclarationStatement
         Gas costs: 247
         Source: "PaymentInterface payment = PaymentInterface(paymentContract)"
        VariableDeclaration "payment"
           Type: contract PaymentInterface
           Source: "PaymentInterface payment"
          UserDefinedTypeName "PaymentInterface"
             Source: "PaymentInterface"
        FunctionCall
           Type: contract PaymentInterface
           Source: "PaymentInterface(paymentContract)"
          Identifier PaymentInterface
             Type: type(contract PaymentInterface)
             Source: "PaymentInterface"
          Identifier paymentContract
             Type: address
             Source: "paymentContract"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint deductedTokens = payment.createCastle(msg.sender, _tokens, _name, _a1, _a2, _a3, _s1, _s2, _s3)"
        VariableDeclaration "deductedTokens"
           Type: uint256
           Source: "uint deductedTokens"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "payment.createCastle(msg.sender, _tokens, _name, _a1, _a2, _a3, _s1, _s2, _s3)"
          MemberAccess to member createCastle
             Type: function (address,uint256,string memory,uint64,uint64,uint64,uint64,uint64,uint64) external returns (uint256)
             Source: "payment.createCastle"
            Identifier payment
               Type: contract PaymentInterface
               Source: "payment"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _tokens
             Type: uint256
             Source: "_tokens"
          Identifier _name
             Type: string calldata
             Source: "_name"
          Identifier _a1
             Type: uint64
             Source: "_a1"
          Identifier _a2
             Type: uint64
             Source: "_a2"
          Identifier _a3
             Type: uint64
             Source: "_a3"
          Identifier _s1
             Type: uint64
             Source: "_s1"
          Identifier _s2
             Type: uint64
             Source: "_s2"
          Identifier _s3
             Type: uint64
             Source: "_s3"
      IfStatement
         Source: "if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert()"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 37
           Source: "deductedTokens == 0 || deductedTokens > _tokens"
          BinaryOperation using operator ==
             Type: bool
             Source: "deductedTokens == 0"
            Identifier deductedTokens
               Type: uint256
               Source: "deductedTokens"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator >
             Type: bool
             Source: "deductedTokens > _tokens"
            Identifier deductedTokens
               Type: uint256
               Source: "deductedTokens"
            Identifier _tokens
               Type: uint256
               Source: "_tokens"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 259
         Source: "_transfer(msg.sender, inGameRewardAddress, deductedTokens)"
        FunctionCall
           Type: tuple()
           Source: "_transfer(msg.sender, inGameRewardAddress, deductedTokens)"
          Identifier _transfer
             Type: function (address,address,uint256)
             Source: "_transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier inGameRewardAddress
             Type: address
             Source: "inGameRewardAddress"
          Identifier deductedTokens
             Type: uint256
             Source: "deductedTokens"
  FunctionDefinition "catchMonster" - public
     Source: "function catchMonster(uint _tokens, uint32 _classId, string _name) isActive requirePaymentContract external {\r\n        if (_tokens > balanceOf[msg.sender])\r\n            revert();\r\n        PaymentInterface payment = PaymentInterface(paymentContract);\r\n        uint deductedTokens = payment.catchMonster(msg.sender, _tokens, _classId, _name);\r\n        if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert();\r\n        _transfer(msg.sender, inGameRewardAddress, deductedTokens);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _tokens, uint32 _classId, string _name)"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_classId"
         Type: uint32
         Source: "uint32 _classId"
        ElementaryTypeName uint32
           Source: "uint32"
      VariableDeclaration "_name"
         Type: string calldata
         Source: "string _name"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "isActive"
       Gas costs: 0
       Source: "isActive"
      Identifier isActive
         Type: modifier ()
         Source: "isActive"
    ModifierInvocation "requirePaymentContract"
       Gas costs: 0
       Source: "requirePaymentContract"
      Identifier requirePaymentContract
         Type: modifier ()
         Source: "requirePaymentContract"
    Block
       Source: "{\r\n        if (_tokens > balanceOf[msg.sender])\r\n            revert();\r\n        PaymentInterface payment = PaymentInterface(paymentContract);\r\n        uint deductedTokens = payment.catchMonster(msg.sender, _tokens, _classId, _name);\r\n        if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert();\r\n        _transfer(msg.sender, inGameRewardAddress, deductedTokens);\r\n    }"
      IfStatement
         Source: "if (_tokens > balanceOf[msg.sender])\r\n            revert()"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 304
           Source: "_tokens > balanceOf[msg.sender]"
          Identifier _tokens
             Type: uint256
             Source: "_tokens"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      VariableDeclarationStatement
         Gas costs: 247
         Source: "PaymentInterface payment = PaymentInterface(paymentContract)"
        VariableDeclaration "payment"
           Type: contract PaymentInterface
           Source: "PaymentInterface payment"
          UserDefinedTypeName "PaymentInterface"
             Source: "PaymentInterface"
        FunctionCall
           Type: contract PaymentInterface
           Source: "PaymentInterface(paymentContract)"
          Identifier PaymentInterface
             Type: type(contract PaymentInterface)
             Source: "PaymentInterface"
          Identifier paymentContract
             Type: address
             Source: "paymentContract"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint deductedTokens = payment.catchMonster(msg.sender, _tokens, _classId, _name)"
        VariableDeclaration "deductedTokens"
           Type: uint256
           Source: "uint deductedTokens"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "payment.catchMonster(msg.sender, _tokens, _classId, _name)"
          MemberAccess to member catchMonster
             Type: function (address,uint256,uint32,string memory) external returns (uint256)
             Source: "payment.catchMonster"
            Identifier payment
               Type: contract PaymentInterface
               Source: "payment"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _tokens
             Type: uint256
             Source: "_tokens"
          Identifier _classId
             Type: uint32
             Source: "_classId"
          Identifier _name
             Type: string calldata
             Source: "_name"
      IfStatement
         Source: "if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert()"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 37
           Source: "deductedTokens == 0 || deductedTokens > _tokens"
          BinaryOperation using operator ==
             Type: bool
             Source: "deductedTokens == 0"
            Identifier deductedTokens
               Type: uint256
               Source: "deductedTokens"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator >
             Type: bool
             Source: "deductedTokens > _tokens"
            Identifier deductedTokens
               Type: uint256
               Source: "deductedTokens"
            Identifier _tokens
               Type: uint256
               Source: "_tokens"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 259
         Source: "_transfer(msg.sender, inGameRewardAddress, deductedTokens)"
        FunctionCall
           Type: tuple()
           Source: "_transfer(msg.sender, inGameRewardAddress, deductedTokens)"
          Identifier _transfer
             Type: function (address,address,uint256)
             Source: "_transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier inGameRewardAddress
             Type: address
             Source: "inGameRewardAddress"
          Identifier deductedTokens
             Type: uint256
             Source: "deductedTokens"
  FunctionDefinition "payService" - public
     Source: "function payService(uint _tokens, uint32 _type, string _text, uint64 _param1, uint64 _param2, uint64 _param3, uint64 _param4, uint64 _param5, uint64 _param6) isActive requirePaymentContract external {\r\n        if (_tokens > balanceOf[msg.sender])\r\n            revert();\r\n        PaymentInterface payment = PaymentInterface(paymentContract);\r\n        uint deductedTokens = payment.payService(msg.sender, _tokens, _type, _text, _param1, _param2, _param3, _param4, _param5, _param6);\r\n        if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert();\r\n        _transfer(msg.sender, inGameRewardAddress, deductedTokens);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint _tokens, uint32 _type, string _text, uint64 _param1, uint64 _param2, uint64 _param3, uint64 _param4, uint64 _param5, uint64 _param6)"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_type"
         Type: uint32
         Source: "uint32 _type"
        ElementaryTypeName uint32
           Source: "uint32"
      VariableDeclaration "_text"
         Type: string calldata
         Source: "string _text"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_param1"
         Type: uint64
         Source: "uint64 _param1"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_param2"
         Type: uint64
         Source: "uint64 _param2"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_param3"
         Type: uint64
         Source: "uint64 _param3"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_param4"
         Type: uint64
         Source: "uint64 _param4"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_param5"
         Type: uint64
         Source: "uint64 _param5"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "_param6"
         Type: uint64
         Source: "uint64 _param6"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "isActive"
       Gas costs: 0
       Source: "isActive"
      Identifier isActive
         Type: modifier ()
         Source: "isActive"
    ModifierInvocation "requirePaymentContract"
       Gas costs: 0
       Source: "requirePaymentContract"
      Identifier requirePaymentContract
         Type: modifier ()
         Source: "requirePaymentContract"
    Block
       Source: "{\r\n        if (_tokens > balanceOf[msg.sender])\r\n            revert();\r\n        PaymentInterface payment = PaymentInterface(paymentContract);\r\n        uint deductedTokens = payment.payService(msg.sender, _tokens, _type, _text, _param1, _param2, _param3, _param4, _param5, _param6);\r\n        if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert();\r\n        _transfer(msg.sender, inGameRewardAddress, deductedTokens);\r\n    }"
      IfStatement
         Source: "if (_tokens > balanceOf[msg.sender])\r\n            revert()"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 304
           Source: "_tokens > balanceOf[msg.sender]"
          Identifier _tokens
             Type: uint256
             Source: "_tokens"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      VariableDeclarationStatement
         Gas costs: 247
         Source: "PaymentInterface payment = PaymentInterface(paymentContract)"
        VariableDeclaration "payment"
           Type: contract PaymentInterface
           Source: "PaymentInterface payment"
          UserDefinedTypeName "PaymentInterface"
             Source: "PaymentInterface"
        FunctionCall
           Type: contract PaymentInterface
           Source: "PaymentInterface(paymentContract)"
          Identifier PaymentInterface
             Type: type(contract PaymentInterface)
             Source: "PaymentInterface"
          Identifier paymentContract
             Type: address
             Source: "paymentContract"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint deductedTokens = payment.payService(msg.sender, _tokens, _type, _text, _param1, _param2, _param3, _param4, _param5, _param6)"
        VariableDeclaration "deductedTokens"
           Type: uint256
           Source: "uint deductedTokens"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "payment.payService(msg.sender, _tokens, _type, _text, _param1, _param2, _param3, _param4, _param5, _param6)"
          MemberAccess to member payService
             Type: function (address,uint256,uint32,string memory,uint64,uint64,uint64,uint64,uint64,uint64) external returns (uint256)
             Source: "payment.payService"
            Identifier payment
               Type: contract PaymentInterface
               Source: "payment"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _tokens
             Type: uint256
             Source: "_tokens"
          Identifier _type
             Type: uint32
             Source: "_type"
          Identifier _text
             Type: string calldata
             Source: "_text"
          Identifier _param1
             Type: uint64
             Source: "_param1"
          Identifier _param2
             Type: uint64
             Source: "_param2"
          Identifier _param3
             Type: uint64
             Source: "_param3"
          Identifier _param4
             Type: uint64
             Source: "_param4"
          Identifier _param5
             Type: uint64
             Source: "_param5"
          Identifier _param6
             Type: uint64
             Source: "_param6"
      IfStatement
         Source: "if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert()"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 37
           Source: "deductedTokens == 0 || deductedTokens > _tokens"
          BinaryOperation using operator ==
             Type: bool
             Source: "deductedTokens == 0"
            Identifier deductedTokens
               Type: uint256
               Source: "deductedTokens"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator >
             Type: bool
             Source: "deductedTokens > _tokens"
            Identifier deductedTokens
               Type: uint256
               Source: "deductedTokens"
            Identifier _tokens
               Type: uint256
               Source: "_tokens"
        ExpressionStatement
           Gas costs: 6
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      ExpressionStatement
         Gas costs: 259
         Source: "_transfer(msg.sender, inGameRewardAddress, deductedTokens)"
        FunctionCall
           Type: tuple()
           Source: "_transfer(msg.sender, inGameRewardAddress, deductedTokens)"
          Identifier _transfer
             Type: function (address,address,uint256)
             Source: "_transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier inGameRewardAddress
             Type: address
             Source: "inGameRewardAddress"
          Identifier deductedTokens
             Type: uint256
             Source: "deductedTokens"
