Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x555636dbc591d418ea9aabfd6abcce57740d14ac.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.15;"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "mul"
     Source: "function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }"
      IfStatement
         Source: "if (a == 0) {\r\n      return 0;\r\n    }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "a == 0"
          Identifier a
             Type: uint256
             Source: "a"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n      return 0;\r\n    }"
          Return
             Gas costs: 19
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 60
         Source: "assert(c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "c / a == b"
            BinaryOperation using operator /
               Type: uint256
               Source: "c / a"
              Identifier c
                 Type: uint256
                 Source: "c"
              Identifier a
                 Type: uint256
                 Source: "a"
            Identifier b
               Type: uint256
               Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div"
     Source: "function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub"
     Source: "function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add"
     Source: "function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "Token"
   Gas costs: 0
   Source: "contract Token {\r\n\r\n    //uint256 public totalSupply;\r\n    function totalSupply() constant returns (uint256 supply);\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    \r\n    //function transfer(address to, uint value, bytes data) returns (bool ok);\r\n    \r\n    //function transferFrom(address from, address to, uint value, bytes data) returns (bool ok);\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() constant returns (uint256 supply);"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256 supply)"
      VariableDeclaration "supply"
         Type: uint256
         Source: "uint256 supply"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success);"
    ParameterList
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "ERC223Receiver"
   Gas costs: 0
   Source: "contract ERC223Receiver {\r\n  function tokenFallback(address _sender, address _origin, uint _value, bytes _data) returns (bool ok);\r\n}"
  FunctionDefinition "tokenFallback" - public
     Source: "function tokenFallback(address _sender, address _origin, uint _value, bytes _data) returns (bool ok);"
    ParameterList
       Source: "(address _sender, address _origin, uint _value, bytes _data)"
      VariableDeclaration "_sender"
         Type: address
         Source: "address _sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_origin"
         Type: address
         Source: "address _origin"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is Token {\r\n    uint256 _totalSupply;\r\n    \r\n    function totalSupply() constant returns (uint256 totalSupply) {\r\n        totalSupply = _totalSupply;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            last_seen[msg.sender] = now;\r\n            last_seen[_to] = now;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            last_seen[_from] = now;\r\n            last_seen[_to] = now;\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    function lastSeen(address _owner) constant internal returns (uint256 balance) {\r\n        return last_seen[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        last_seen[msg.sender] = now;\r\n        last_seen[_spender] = now;\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    mapping (address => uint256) last_seen;\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Token"
    UserDefinedTypeName "Token"
       Source: "Token"
  VariableDeclaration "_totalSupply"
     Type: uint256
     Gas costs: 0
     Source: "uint256 _totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() constant returns (uint256 totalSupply) {\r\n        totalSupply = _totalSupply;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256 totalSupply)"
      VariableDeclaration "totalSupply"
         Type: uint256
         Source: "uint256 totalSupply"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        totalSupply = _totalSupply;\r\n    }"
      ExpressionStatement
         Gas costs: 208
         Source: "totalSupply = _totalSupply"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = _totalSupply"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _totalSupply
             Type: uint256
             Source: "_totalSupply"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            last_seen[msg.sender] = now;\r\n            last_seen[_to] = now;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            last_seen[msg.sender] = now;\r\n            last_seen[_to] = now;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }"
      IfStatement
         Source: "if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            last_seen[msg.sender] = now;\r\n            last_seen[_to] = now;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 338
           Source: "balances[msg.sender] >= _value && _value > 0"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
          BinaryOperation using operator >
             Type: bool
             Source: "_value > 0"
            Identifier _value
               Type: uint256
               Source: "_value"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            last_seen[msg.sender] = now;\r\n            last_seen[_to] = now;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 20328
             Source: "balances[msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20323
             Source: "balances[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balances[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20102
             Source: "last_seen[msg.sender] = now"
            Assignment using operator =
               Type: uint256
               Source: "last_seen[msg.sender] = now"
              IndexAccess
                 Type: uint256
                 Source: "last_seen[msg.sender]"
                Identifier last_seen
                   Type: mapping(address => uint256)
                   Source: "last_seen"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier now
                 Type: uint256
                 Source: "now"
          ExpressionStatement
             Gas costs: 20103
             Source: "last_seen[_to] = now"
            Assignment using operator =
               Type: uint256
               Source: "last_seen[_to] = now"
              IndexAccess
                 Type: uint256
                 Source: "last_seen[_to]"
                Identifier last_seen
                   Type: mapping(address => uint256)
                   Source: "last_seen"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier now
                 Type: uint256
                 Source: "now"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(msg.sender, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(msg.sender, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{ return false; }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            last_seen[_from] = now;\r\n            last_seen[_to] = now;\r\n            return true;\r\n        } else { return false; }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            last_seen[_from] = now;\r\n            last_seen[_to] = now;\r\n            return true;\r\n        } else { return false; }\r\n    }"
      IfStatement
         Source: "if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            last_seen[_from] = now;\r\n            last_seen[_to] = now;\r\n            return true;\r\n        } else { return false; }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 758
           Source: "balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0"
          BinaryOperation using operator &&
             Type: bool
             Source: "balances[_from] >= _value && allowed[_from][msg.sender] >= _value"
            BinaryOperation using operator >=
               Type: bool
               Source: "balances[_from] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            BinaryOperation using operator >=
               Type: bool
               Source: "allowed[_from][msg.sender] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          BinaryOperation using operator >
             Type: bool
             Source: "_value > 0"
            Identifier _value
               Type: uint256
               Source: "_value"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            last_seen[_from] = now;\r\n            last_seen[_to] = now;\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 20329
             Source: "balances[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balances[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20323
             Source: "balances[_from] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[_from] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20412
             Source: "allowed[_from][msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "allowed[_from][msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(_from, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(_from, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              Identifier _from
                 Type: address
                 Source: "_from"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20103
             Source: "last_seen[_from] = now"
            Assignment using operator =
               Type: uint256
               Source: "last_seen[_from] = now"
              IndexAccess
                 Type: uint256
                 Source: "last_seen[_from]"
                Identifier last_seen
                   Type: mapping(address => uint256)
                   Source: "last_seen"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier now
                 Type: uint256
                 Source: "now"
          ExpressionStatement
             Gas costs: 20103
             Source: "last_seen[_to] = now"
            Assignment using operator =
               Type: uint256
               Source: "last_seen[_to] = now"
              IndexAccess
                 Type: uint256
                 Source: "last_seen[_to]"
                Identifier last_seen
                   Type: mapping(address => uint256)
                   Source: "last_seen"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier now
                 Type: uint256
                 Source: "now"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{ return false; }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return balances[_owner];\r\n    }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "lastSeen" - const
     Source: "function lastSeen(address _owner) constant internal returns (uint256 balance) {\r\n        return last_seen[_owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return last_seen[_owner];\r\n    }"
      Return
         Gas costs: 0
         Source: "return last_seen[_owner]"
        IndexAccess
           Type: uint256
           Source: "last_seen[_owner]"
          Identifier last_seen
             Type: mapping(address => uint256)
             Source: "last_seen"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        last_seen[msg.sender] = now;\r\n        last_seen[_spender] = now;\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        last_seen[msg.sender] = now;\r\n        last_seen[_spender] = now;\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20102
         Source: "last_seen[msg.sender] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[msg.sender] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[msg.sender]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 20103
         Source: "last_seen[_spender] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[_spender] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[_spender]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier now
             Type: uint256
             Source: "now"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      return allowed[_owner][_spender];\r\n    }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balances"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "last_seen"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) last_seen"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
ContractDefinition "Ownable"
   Source: "contract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n  \r\n  function getOwner() view public returns (address){\r\n    return owner;\r\n  }\r\n  \r\n\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  EventDefinition "OwnershipTransferred"
     Gas costs: 0
     Source: "event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);"
    ParameterList
       Source: "(address indexed previousOwner, address indexed newOwner)"
      VariableDeclaration "previousOwner"
         Type: address
         Source: "address indexed previousOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address indexed newOwner"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "Ownable" - public
     Source: "function Ownable() public {\r\n    owner = msg.sender;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    owner = msg.sender;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 846
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(newOwner != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(newOwner != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "newOwner != address(0)"
            Identifier newOwner
               Type: address
               Source: "newOwner"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 1790
         Source: "OwnershipTransferred(owner, newOwner)"
        FunctionCall
           Type: tuple()
           Source: "OwnershipTransferred(owner, newOwner)"
          Identifier OwnershipTransferred
             Type: function (address,address)
             Source: "OwnershipTransferred"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
  FunctionDefinition "getOwner" - public - const
     Source: "function getOwner() view public returns (address){\r\n    return owner;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n    return owner;\r\n  }"
      Return
         Gas costs: 244
         Source: "return owner"
        Identifier owner
           Type: address
           Source: "owner"
ContractDefinition "Standard223Receiver"
   Source: "contract Standard223Receiver is ERC223Receiver {\r\n  Tkn tkn;\r\n\r\n  struct Tkn {\r\n    address addr;\r\n    address sender;\r\n    address origin;\r\n    uint256 value;\r\n    bytes data;\r\n    bytes4 sig;\r\n  }\r\n\r\n  function tokenFallback(address _sender, address _origin, uint _value, bytes _data) returns (bool ok) {\r\n    //if (!supportsToken(msg.sender)) return false;\r\n\r\n    // Problem: This will do a sstore which is expensive gas wise. Find a way to keep it in memory.\r\n    tkn = Tkn(msg.sender, _sender, _origin, _value, _data, getSig(_data));\r\n    __isTokenFallback = true;\r\n    if (!address(this).delegatecall(_data)) return false;\r\n\r\n    // avoid doing an overwrite to .token, which would be more expensive\r\n    // makes accessing .tkn values outside tokenPayable functions unsafe\r\n    __isTokenFallback = false;\r\n\r\n    return true;\r\n  }\r\n\r\n  function getSig(bytes _data) private returns (bytes4 sig) {\r\n    uint l = _data.length < 4 ? _data.length : 4;\r\n    for (uint i = 0; i < l; i++) {\r\n      sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (l - 1 - i))));\r\n    }\r\n  }\r\n\r\n  bool __isTokenFallback;\r\n\r\n  modifier tokenPayable {\r\n    if (!__isTokenFallback) throw;\r\n    _;\r\n  }\r\n\r\n  //function supportsToken(address token) returns (bool);\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC223Receiver"
    UserDefinedTypeName "ERC223Receiver"
       Source: "ERC223Receiver"
  VariableDeclaration "tkn"
     Type: struct Standard223Receiver.Tkn storage ref
     Gas costs: 0
     Source: "Tkn tkn"
    UserDefinedTypeName "Tkn"
       Source: "Tkn"
  StructDefinition "Tkn"
     Gas costs: 0
     Source: "struct Tkn {\r\n    address addr;\r\n    address sender;\r\n    address origin;\r\n    uint256 value;\r\n    bytes data;\r\n    bytes4 sig;\r\n  }"
    VariableDeclaration "addr"
       Type: address
       Source: "address addr"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "sender"
       Type: address
       Source: "address sender"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "origin"
       Type: address
       Source: "address origin"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "value"
       Type: uint256
       Source: "uint256 value"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "data"
       Type: bytes storage pointer
       Source: "bytes data"
      ElementaryTypeName bytes
         Source: "bytes"
    VariableDeclaration "sig"
       Type: bytes4
       Source: "bytes4 sig"
      ElementaryTypeName bytes4
         Source: "bytes4"
  FunctionDefinition "tokenFallback" - public
     Source: "function tokenFallback(address _sender, address _origin, uint _value, bytes _data) returns (bool ok) {\r\n    //if (!supportsToken(msg.sender)) return false;\r\n\r\n    // Problem: This will do a sstore which is expensive gas wise. Find a way to keep it in memory.\r\n    tkn = Tkn(msg.sender, _sender, _origin, _value, _data, getSig(_data));\r\n    __isTokenFallback = true;\r\n    if (!address(this).delegatecall(_data)) return false;\r\n\r\n    // avoid doing an overwrite to .token, which would be more expensive\r\n    // makes accessing .tkn values outside tokenPayable functions unsafe\r\n    __isTokenFallback = false;\r\n\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _sender, address _origin, uint _value, bytes _data)"
      VariableDeclaration "_sender"
         Type: address
         Source: "address _sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_origin"
         Type: address
         Source: "address _origin"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    //if (!supportsToken(msg.sender)) return false;\r\n\r\n    // Problem: This will do a sstore which is expensive gas wise. Find a way to keep it in memory.\r\n    tkn = Tkn(msg.sender, _sender, _origin, _value, _data, getSig(_data));\r\n    __isTokenFallback = true;\r\n    if (!address(this).delegatecall(_data)) return false;\r\n\r\n    // avoid doing an overwrite to .token, which would be more expensive\r\n    // makes accessing .tkn values outside tokenPayable functions unsafe\r\n    __isTokenFallback = false;\r\n\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: [???]
         Source: "tkn = Tkn(msg.sender, _sender, _origin, _value, _data, getSig(_data))"
        Assignment using operator =
           Type: struct Standard223Receiver.Tkn storage ref
           Source: "tkn = Tkn(msg.sender, _sender, _origin, _value, _data, getSig(_data))"
          Identifier tkn
             Type: struct Standard223Receiver.Tkn storage ref
             Source: "tkn"
          FunctionCall
             Type: struct Standard223Receiver.Tkn memory
             Source: "Tkn(msg.sender, _sender, _origin, _value, _data, getSig(_data))"
            Identifier Tkn
               Type: type(struct Standard223Receiver.Tkn storage pointer)
               Source: "Tkn"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier _sender
               Type: address
               Source: "_sender"
            Identifier _origin
               Type: address
               Source: "_origin"
            Identifier _value
               Type: uint256
               Source: "_value"
            Identifier _data
               Type: bytes memory
               Source: "_data"
            FunctionCall
               Type: bytes4
               Source: "getSig(_data)"
              Identifier getSig
                 Type: function (bytes memory) returns (bytes4)
                 Source: "getSig"
              Identifier _data
                 Type: bytes memory
                 Source: "_data"
      ExpressionStatement
         Gas costs: 20267
         Source: "__isTokenFallback = true"
        Assignment using operator =
           Type: bool
           Source: "__isTokenFallback = true"
          Identifier __isTokenFallback
             Type: bool
             Source: "__isTokenFallback"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      IfStatement
         Source: "if (!address(this).delegatecall(_data)) return false"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!address(this).delegatecall(_data)"
          FunctionCall
             Type: bool
             Source: "address(this).delegatecall(_data)"
            MemberAccess to member delegatecall
               Type: function () returns (bool)
               Source: "address(this).delegatecall"
              FunctionCall
                 Type: address
                 Source: "address(this)"
                ElementaryTypeNameExpression address
                   Type: type(address)
                   Source: "address"
                Identifier this
                   Type: contract Standard223Receiver
                   Source: "this"
            Identifier _data
               Type: bytes memory
               Source: "_data"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 20267
         Source: "__isTokenFallback = false"
        Assignment using operator =
           Type: bool
           Source: "__isTokenFallback = false"
          Identifier __isTokenFallback
             Type: bool
             Source: "__isTokenFallback"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "getSig"
     Source: "function getSig(bytes _data) private returns (bytes4 sig) {\r\n    uint l = _data.length < 4 ? _data.length : 4;\r\n    for (uint i = 0; i < l; i++) {\r\n      sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (l - 1 - i))));\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes _data)"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bytes4 sig)"
      VariableDeclaration "sig"
         Type: bytes4
         Source: "bytes4 sig"
        ElementaryTypeName bytes4
           Source: "bytes4"
    Block
       Source: "{\r\n    uint l = _data.length < 4 ? _data.length : 4;\r\n    for (uint i = 0; i < l; i++) {\r\n      sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (l - 1 - i))));\r\n    }\r\n  }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint l = _data.length < 4 ? _data.length : 4"
        VariableDeclaration "l"
           Type: uint256
           Source: "uint l"
          ElementaryTypeName uint
             Source: "uint"
        Conditional
           Type: uint256
           Source: "_data.length < 4 ? _data.length : 4"
          BinaryOperation using operator <
             Type: bool
             Source: "_data.length < 4"
            MemberAccess to member length
               Type: uint256
               Source: "_data.length"
              Identifier _data
                 Type: bytes memory
                 Source: "_data"
            Literal, token: [no token] value: 4
               Type: int_const 4
               Source: "4"
          MemberAccess to member length
             Type: uint256
             Source: "_data.length"
            Identifier _data
               Type: bytes memory
               Source: "_data"
          Literal, token: [no token] value: 4
             Type: int_const 4
             Source: "4"
      ForStatement
         Source: "for (uint i = 0; i < l; i++) {\r\n      sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (l - 1 - i))));\r\n    }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < l"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier l
             Type: uint256
             Source: "l"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n      sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (l - 1 - i))));\r\n    }"
          ExpressionStatement
             Gas costs: [???]
             Source: "sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (l - 1 - i))))"
            Assignment using operator =
               Type: bytes4
               Source: "sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (l - 1 - i))))"
              Identifier sig
                 Type: bytes4
                 Source: "sig"
              FunctionCall
                 Type: bytes4
                 Source: "bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (l - 1 - i))))"
                ElementaryTypeNameExpression bytes4
                   Type: type(bytes4)
                   Source: "bytes4"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "uint(sig) + uint(_data[i]) * (2 ** (8 * (l - 1 - i)))"
                  FunctionCall
                     Type: uint256
                     Source: "uint(sig)"
                    ElementaryTypeNameExpression uint
                       Type: type(uint256)
                       Source: "uint"
                    Identifier sig
                       Type: bytes4
                       Source: "sig"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "uint(_data[i]) * (2 ** (8 * (l - 1 - i)))"
                    FunctionCall
                       Type: uint256
                       Source: "uint(_data[i])"
                      ElementaryTypeNameExpression uint
                         Type: type(uint256)
                         Source: "uint"
                      IndexAccess
                         Type: bytes1
                         Source: "_data[i]"
                        Identifier _data
                           Type: bytes memory
                           Source: "_data"
                        Identifier i
                           Type: uint256
                           Source: "i"
                    TupleExpression
                       Type: uint256
                       Source: "(2 ** (8 * (l - 1 - i)))"
                      BinaryOperation using operator **
                         Type: uint256
                         Source: "2 ** (8 * (l - 1 - i))"
                        Literal, token: [no token] value: 2
                           Type: int_const 2
                           Source: "2"
                        TupleExpression
                           Type: uint256
                           Source: "(8 * (l - 1 - i))"
                          BinaryOperation using operator *
                             Type: uint256
                             Source: "8 * (l - 1 - i)"
                            Literal, token: [no token] value: 8
                               Type: int_const 8
                               Source: "8"
                            TupleExpression
                               Type: uint256
                               Source: "(l - 1 - i)"
                              BinaryOperation using operator -
                                 Type: uint256
                                 Source: "l - 1 - i"
                                BinaryOperation using operator -
                                   Type: uint256
                                   Source: "l - 1"
                                  Identifier l
                                     Type: uint256
                                     Source: "l"
                                  Literal, token: [no token] value: 1
                                     Type: int_const 1
                                     Source: "1"
                                Identifier i
                                   Type: uint256
                                   Source: "i"
  VariableDeclaration "__isTokenFallback"
     Type: bool
     Gas costs: 0
     Source: "bool __isTokenFallback"
    ElementaryTypeName bool
       Source: "bool"
  ModifierDefinition "tokenPayable"
     Source: "modifier tokenPayable {\r\n    if (!__isTokenFallback) throw;\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    if (!__isTokenFallback) throw;\r\n    _;\r\n  }"
      IfStatement
         Source: "if (!__isTokenFallback) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 0
           Source: "!__isTokenFallback"
          Identifier __isTokenFallback
             Type: bool
             Source: "__isTokenFallback"
        Throw
           Gas costs: 0
           Source: "throw"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
ContractDefinition "Standard223Token"
   Source: "contract Standard223Token is StandardToken {\r\n  //function that is called when a user or another contract wants to transfer funds\r\n  function transfer(address _to, uint _value, bytes _data) returns (bool success) {\r\n    //filtering if the target is a contract with bytecode inside it\r\n    if (!super.transfer(_to, _value)) throw; // do a normal token transfer\r\n    if (isContract(_to)) return contractFallback(msg.sender, _to, _value, _data);\r\n    last_seen[msg.sender] = now;\r\n    last_seen[_to] = now;\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value, bytes _data) returns (bool success) {\r\n    if (!super.transferFrom(_from, _to, _value)) throw; // do a normal token transfer\r\n    if (isContract(_to)) return contractFallback(_from, _to, _value, _data);\r\n    last_seen[_from] = now;\r\n    last_seen[_to] = now;\r\n    return true;\r\n  }\r\n\r\n  //function transfer(address _to, uint _value) returns (bool success) {\r\n    //return transfer(_to, _value, new bytes(0));\r\n  //}\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    return transferFrom(_from, _to, _value, new bytes(0));\r\n    last_seen[_from] = now;\r\n    last_seen[_to] = now;\r\n  }\r\n\r\n  //function that is called when transaction target is a contract\r\n  function contractFallback(address _origin, address _to, uint _value, bytes _data) private returns (bool success) {\r\n    ERC223Receiver reciever = ERC223Receiver(_to);\r\n    return reciever.tokenFallback(msg.sender, _origin, _value, _data);\r\n  }\r\n\r\n  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n  function isContract(address _addr) private returns (bool is_contract) {\r\n    // retrieve the size of the code on target address, this needs assembly\r\n    uint length;\r\n    assembly { length := extcodesize(_addr) }\r\n    return length > 0;\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value, bytes _data) returns (bool success) {\r\n    //filtering if the target is a contract with bytecode inside it\r\n    if (!super.transfer(_to, _value)) throw; // do a normal token transfer\r\n    if (isContract(_to)) return contractFallback(msg.sender, _to, _value, _data);\r\n    last_seen[msg.sender] = now;\r\n    last_seen[_to] = now;\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value, bytes _data)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    //filtering if the target is a contract with bytecode inside it\r\n    if (!super.transfer(_to, _value)) throw; // do a normal token transfer\r\n    if (isContract(_to)) return contractFallback(msg.sender, _to, _value, _data);\r\n    last_seen[msg.sender] = now;\r\n    last_seen[_to] = now;\r\n    return true;\r\n  }"
      IfStatement
         Source: "if (!super.transfer(_to, _value)) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 24
           Source: "!super.transfer(_to, _value)"
          FunctionCall
             Type: bool
             Source: "super.transfer(_to, _value)"
            MemberAccess to member transfer
               Type: function (address,uint256) returns (bool)
               Source: "super.transfer"
              Identifier super
                 Type: contract super Standard223Token
                 Source: "super"
            Identifier _to
               Type: address
               Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (isContract(_to)) return contractFallback(msg.sender, _to, _value, _data)"
        FunctionCall
           Type: bool
           Gas costs: 18
           Source: "isContract(_to)"
          Identifier isContract
             Type: function (address) returns (bool)
             Source: "isContract"
          Identifier _to
             Type: address
             Source: "_to"
        Return
           Gas costs: 42
           Source: "return contractFallback(msg.sender, _to, _value, _data)"
          FunctionCall
             Type: bool
             Source: "contractFallback(msg.sender, _to, _value, _data)"
            Identifier contractFallback
               Type: function (address,address,uint256,bytes memory) returns (bool)
               Source: "contractFallback"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier _to
               Type: address
               Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
            Identifier _data
               Type: bytes memory
               Source: "_data"
      ExpressionStatement
         Gas costs: 20108
         Source: "last_seen[msg.sender] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[msg.sender] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[msg.sender]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 20103
         Source: "last_seen[_to] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[_to] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[_to]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier now
             Type: uint256
             Source: "now"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value, bytes _data) returns (bool success) {\r\n    if (!super.transferFrom(_from, _to, _value)) throw; // do a normal token transfer\r\n    if (isContract(_to)) return contractFallback(_from, _to, _value, _data);\r\n    last_seen[_from] = now;\r\n    last_seen[_to] = now;\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _value, bytes _data)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    if (!super.transferFrom(_from, _to, _value)) throw; // do a normal token transfer\r\n    if (isContract(_to)) return contractFallback(_from, _to, _value, _data);\r\n    last_seen[_from] = now;\r\n    last_seen[_to] = now;\r\n    return true;\r\n  }"
      IfStatement
         Source: "if (!super.transferFrom(_from, _to, _value)) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 16
           Source: "!super.transferFrom(_from, _to, _value)"
          FunctionCall
             Type: bool
             Source: "super.transferFrom(_from, _to, _value)"
            MemberAccess to member transferFrom
               Type: function (address,address,uint256) returns (bool)
               Source: "super.transferFrom"
              Identifier super
                 Type: contract super Standard223Token
                 Source: "super"
            Identifier _from
               Type: address
               Source: "_from"
            Identifier _to
               Type: address
               Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (isContract(_to)) return contractFallback(_from, _to, _value, _data)"
        FunctionCall
           Type: bool
           Gas costs: 7
           Source: "isContract(_to)"
          Identifier isContract
             Type: function (address) returns (bool)
             Source: "isContract"
          Identifier _to
             Type: address
             Source: "_to"
        Return
           Gas costs: 32
           Source: "return contractFallback(_from, _to, _value, _data)"
          FunctionCall
             Type: bool
             Source: "contractFallback(_from, _to, _value, _data)"
            Identifier contractFallback
               Type: function (address,address,uint256,bytes memory) returns (bool)
               Source: "contractFallback"
            Identifier _from
               Type: address
               Source: "_from"
            Identifier _to
               Type: address
               Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
            Identifier _data
               Type: bytes memory
               Source: "_data"
      ExpressionStatement
         Gas costs: 20109
         Source: "last_seen[_from] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[_from] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[_from]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 20103
         Source: "last_seen[_to] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[_to] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[_to]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier now
             Type: uint256
             Source: "now"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    return transferFrom(_from, _to, _value, new bytes(0));\r\n    last_seen[_from] = now;\r\n    last_seen[_to] = now;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    return transferFrom(_from, _to, _value, new bytes(0));\r\n    last_seen[_from] = now;\r\n    last_seen[_to] = now;\r\n  }"
      Return
         Gas costs: [???]
         Source: "return transferFrom(_from, _to, _value, new bytes(0))"
        FunctionCall
           Type: bool
           Source: "transferFrom(_from, _to, _value, new bytes(0))"
          Identifier transferFrom
             Type: function (address,address,uint256,bytes memory) returns (bool)
             Source: "transferFrom"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
          FunctionCall
             Type: bytes memory
             Source: "new bytes(0)"
            NewExpression
               Type: function (uint256) pure returns (bytes memory)
               Source: "new bytes"
              ElementaryTypeName bytes
                 Source: "bytes"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "last_seen[_from] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[_from] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[_from]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 0
         Source: "last_seen[_to] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[_to] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[_to]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier now
             Type: uint256
             Source: "now"
  FunctionDefinition "contractFallback"
     Source: "function contractFallback(address _origin, address _to, uint _value, bytes _data) private returns (bool success) {\r\n    ERC223Receiver reciever = ERC223Receiver(_to);\r\n    return reciever.tokenFallback(msg.sender, _origin, _value, _data);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _origin, address _to, uint _value, bytes _data)"
      VariableDeclaration "_origin"
         Type: address
         Source: "address _origin"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    ERC223Receiver reciever = ERC223Receiver(_to);\r\n    return reciever.tokenFallback(msg.sender, _origin, _value, _data);\r\n  }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "ERC223Receiver reciever = ERC223Receiver(_to)"
        VariableDeclaration "reciever"
           Type: contract ERC223Receiver
           Source: "ERC223Receiver reciever"
          UserDefinedTypeName "ERC223Receiver"
             Source: "ERC223Receiver"
        FunctionCall
           Type: contract ERC223Receiver
           Source: "ERC223Receiver(_to)"
          Identifier ERC223Receiver
             Type: type(contract ERC223Receiver)
             Source: "ERC223Receiver"
          Identifier _to
             Type: address
             Source: "_to"
      Return
         Gas costs: [???]
         Source: "return reciever.tokenFallback(msg.sender, _origin, _value, _data)"
        FunctionCall
           Type: bool
           Source: "reciever.tokenFallback(msg.sender, _origin, _value, _data)"
          MemberAccess to member tokenFallback
             Type: function (address,address,uint256,bytes memory) external returns (bool)
             Source: "reciever.tokenFallback"
            Identifier reciever
               Type: contract ERC223Receiver
               Source: "reciever"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _origin
             Type: address
             Source: "_origin"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier _data
             Type: bytes memory
             Source: "_data"
  FunctionDefinition "isContract"
     Source: "function isContract(address _addr) private returns (bool is_contract) {\r\n    // retrieve the size of the code on target address, this needs assembly\r\n    uint length;\r\n    assembly { length := extcodesize(_addr) }\r\n    return length > 0;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _addr)"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool is_contract)"
      VariableDeclaration "is_contract"
         Type: bool
         Source: "bool is_contract"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    // retrieve the size of the code on target address, this needs assembly\r\n    uint length;\r\n    assembly { length := extcodesize(_addr) }\r\n    return length > 0;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint length"
        VariableDeclaration "length"
           Type: uint256
           Source: "uint length"
          ElementaryTypeName uint
             Source: "uint"
      InlineAssembly
         Gas costs: 0
         Source: "assembly { length := extcodesize(_addr) }\r\n    return"
      Return
         Gas costs: 14
         Source: "return length > 0"
        BinaryOperation using operator >
           Type: bool
           Source: "length > 0"
          Identifier length
             Type: uint256
             Source: "length"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
ContractDefinition "Ciphs"
   Source: "contract Ciphs is Standard223Receiver, Standard223Token, Ownable {\r\n\r\n  using SafeMath for uint256;\r\n  \r\n  string public constant name = \"Ciphs\";\r\n  string public constant symbol = \"CIPHS\";\r\n  uint8 public constant decimals = 18;\r\n\r\n  uint256 public rate = 1000000;\r\n  bool propose = false;\r\n  uint256 prosposal_time = 0;\r\n  uint256 raisedAmount = 0;\r\n  uint256 public constant INITIAL_SUPPLY = 7000000e18;\r\n  uint256 public constant MAX_SUPPLY = 860000000000e18;\r\n  //uint256 public totalSupply;\r\n  address[] investors;\r\n  \r\n  uint256 up = 0;\r\n  uint256 down = 0;\r\n\r\n  mapping(address => uint256) votes;\r\n  mapping (address => mapping (address => uint256)) public trackable;\r\n  mapping (address => mapping (uint => uint256)) public trackable_record;\r\n  \r\n  mapping (address => uint256) public bannable;\r\n  mapping (address => uint256) internal support_ban;\r\n  mapping (address => uint256) internal against_ban;\r\n\r\n  //event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  //event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event BoughtTokens(address indexed to, uint256 value);\r\n  event Votes(address indexed owner, uint256 value);\r\n  event Burn(address indexed burner, uint256 value);\r\n  event Mint(uint256 value);\r\n\r\n  \r\n  function Ciphs() public {\r\n    _totalSupply = INITIAL_SUPPLY;\r\n    balances[msg.sender] = INITIAL_SUPPLY;\r\n  }\r\n\r\n\r\n  function initialize_proposal() public {\r\n\r\n    if(propose) throw;\r\n    propose = true;\r\n    prosposal_time = now;\r\n\r\n  }\r\n  \r\n  function is_proposal_supported() public returns (bool) {\r\n    if(!propose) throw;\r\n    if(down.mul(4) < up)\r\n    {\r\n        return false;\r\n    }else{\r\n        return true;\r\n    }\r\n  }\r\n\r\n  modifier canMint() {\r\n    if(propose && is_proposal_supported() && now > prosposal_time.add(7 * 1 days))\r\n    _;\r\n    else\r\n    throw;\r\n  }\r\n  \r\n  function distribute_token()\r\n  {\r\n       uint256 investors_num = investors.length;\r\n       uint256 amount = (1000000e18-1000)/investors_num;\r\n       for(var i = 0; i < investors_num; i++)\r\n       {\r\n           if(last_seen[investors[i]].add(90 * 1 days) > now)\r\n           {\r\n                balances[investors[i]] += amount;\r\n                last_seen[investors[i]] = now;\r\n            }\r\n       }\r\n    }\r\n\r\n\r\n  function mint() /*canMint*/ public returns (bool) {\r\n    \r\n    if(propose && now >= prosposal_time.add(7 * 1 days)){\r\n        uint256 _amount = 1000000e18;\r\n        _totalSupply = _totalSupply.add(_amount);\r\n        if(_totalSupply <= MAX_SUPPLY && is_proposal_supported())\r\n        {\r\n            balances[owner] = balances[owner].add(1000);\r\n            //Transfer(address(0), _to, _amount);\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            distribute_token();\r\n            Mint(_amount);\r\n            return true;\r\n        }else{\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            //return true;\r\n        }\r\n        \r\n    }\r\n    last_seen[msg.sender] = now;\r\n    //return false;\r\n  }\r\n\r\n  function support_proposal() public returns (bool) {\r\n    if(!propose || votes[msg.sender] == 1) throw;\r\n    //first check balance to be more than 10 Ciphs\r\n    if(balances[msg.sender] > 100e18)\r\n    {\r\n        //only vote once\r\n        votes[msg.sender] = 1;\r\n        up++;\r\n        mint();\r\n        Votes(msg.sender, 1);\r\n        return true;\r\n\r\n    }else\r\n    {\r\n        //no sufficient funds to carry out voting consensus\r\n        return false;\r\n    }\r\n  }\r\n\r\n  function against_proposal() public returns (bool) {\r\n    if(!propose || votes[msg.sender] == 1) throw;\r\n    //first check balance to be more than 10 Ciphs\r\n    if(balances[msg.sender] > 100e18)\r\n    {\r\n        //only vote once\r\n        votes[msg.sender] = 1;\r\n        down++;\r\n        mint();\r\n        Votes(msg.sender, 1);\r\n        return true;\r\n\r\n    }else\r\n    {\r\n        //no sufficient funds to carry out voting consensus\r\n        return false;\r\n    }\r\n  }\r\n  \r\n  function ban_account(address _bannable_address) internal{\r\n        if(balances[_bannable_address] > 0)\r\n        {\r\n          transferFrom(_bannable_address, owner, balances[_bannable_address]);\r\n        }\r\n        delete balances[_bannable_address];\r\n        \r\n        uint256 investors_num = investors.length;\r\n        for(var i = 0; i < investors_num; i++)\r\n        {\r\n            if(investors[i] == _bannable_address){\r\n                delete investors[i];\r\n            }\r\n        }\r\n      //delete investors[];\r\n  }\r\n  \r\n  function ban_check(address _bannable_address) internal\r\n  {\r\n    last_seen[msg.sender] = now;\r\n    //uint256 time_diff = now.sub(bannable[_bannable_address]); \r\n    if(now.sub(bannable[_bannable_address]) > 0.5 * 1 days)\r\n    {\r\n        if(against_ban[_bannable_address].mul(4) < support_ban[_bannable_address])\r\n        {\r\n            ban_account(_bannable_address);\r\n        }\r\n    }\r\n  }\r\n  \r\n  function initialize_bannable(address _bannable_address) public {\r\n    bannable[_bannable_address] = now;\r\n    last_seen[msg.sender] = now;\r\n  }\r\n  \r\n  function support_ban_of(address _bannable_address) public\r\n  {\r\n    require(bannable[_bannable_address] > 0);\r\n    support_ban[_bannable_address] = support_ban[_bannable_address].add(1);\r\n    ban_check(_bannable_address);\r\n  }\r\n  \r\n  function against_ban_of(address _bannable_address) public\r\n  {\r\n    require(bannable[_bannable_address] > 0);\r\n    against_ban[_bannable_address] = against_ban[_bannable_address].add(1);\r\n    ban_check(_bannable_address);\r\n  }\r\n\r\n  function track(address _trackable) public returns (bool) {\r\n    // \"trackable added, vote like or dislike using the address registered with the trackable\";\r\n    trackable[_trackable][msg.sender] = 1;\r\n    last_seen[msg.sender] = now;\r\n    return true;\r\n  }\r\n\r\n  function like_trackable(address _trackable) public returns (bool) {\r\n    last_seen[msg.sender] = now;\r\n    if(trackable[_trackable][msg.sender] != 1)\r\n    {\r\n        trackable[_trackable][msg.sender] = 1;\r\n        trackable_record[_trackable][1] = trackable_record[_trackable][1] + 1;\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function dislike_trackable(address _trackable) public returns (bool) {\r\n    last_seen[msg.sender] = now;\r\n    if(trackable[_trackable][msg.sender] != 1)\r\n    {\r\n        trackable[_trackable][msg.sender] = 1;\r\n        trackable_record[_trackable][2] = trackable_record[_trackable][2] + 1;\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function trackable_likes(address _trackable) public returns (uint256) {\r\n    uint256 num = 0;\r\n    //if(trackable[_trackable])\r\n    //{\r\n\r\n        num = trackable_record[_trackable][1];\r\n\r\n    //}\r\n    return num;\r\n  }\r\n\r\n  function trackable_dislikes(address _trackable) public returns (uint256) {\r\n    uint256 num = 0;\r\n    num = trackable_record[_trackable][2];\r\n    return num;\r\n  }\r\n    \r\n  function () public payable {\r\n\r\n    buyTokens();\r\n\r\n  }\r\n  \r\n  \r\n  function buyTokens() public payable {\r\n      \r\n    //require(propose);\r\n    \r\n    uint256 weiAmount = msg.value;\r\n    uint256 tokens = weiAmount.mul(getRate());\r\n    \r\n    tokens = tokens.div(1 ether);\r\n    \r\n    BoughtTokens(msg.sender, tokens);\r\n\r\n    balances[msg.sender] = balances[msg.sender].add(tokens);\r\n    balances[owner] = balances[owner].sub(tokens);\r\n    _totalSupply.sub(tokens);\r\n\r\n    raisedAmount = raisedAmount.add(msg.value);\r\n    \r\n    investors.push(msg.sender) -1;\r\n    \r\n    last_seen[msg.sender] = now;\r\n    //owner.transfer(msg.value);\r\n  }\r\n  \r\n  function getInvestors() view public returns (address[]){\r\n      return investors;\r\n  }\r\n\r\n  \r\n  function setRate(uint256 _rate) public onlyOwner{\r\n      rate = _rate;\r\n  }\r\n  \r\n  function getRate() public constant returns (uint256){\r\n      \r\n      return rate;\r\n      \r\n  }\r\n\r\n  function burn(uint256 _value) public {\r\n        require(_value > 0);\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        _totalSupply = _totalSupply.sub(_value);\r\n        Burn(msg.sender, _value);\r\n        last_seen[msg.sender] = now;\r\n  }\r\n  \r\n  function destroy() public onlyOwner {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Standard223Receiver"
    UserDefinedTypeName "Standard223Receiver"
       Source: "Standard223Receiver"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Standard223Token"
    UserDefinedTypeName "Standard223Token"
       Source: "Standard223Token"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "name"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant name = \"Ciphs\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Ciphs
       Type: literal_string "Ciphs"
       Source: "\"Ciphs\""
  VariableDeclaration "symbol"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant symbol = \"CIPHS\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: CIPHS
       Type: literal_string "CIPHS"
       Source: "\"CIPHS\""
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: [???]
     Source: "uint8 public constant decimals = 18"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "rate"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public rate = 1000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 1000000
       Type: int_const 1000000
       Source: "1000000"
  VariableDeclaration "propose"
     Type: bool
     Gas costs: 0
     Source: "bool propose = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "prosposal_time"
     Type: uint256
     Gas costs: 0
     Source: "uint256 prosposal_time = 0"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "raisedAmount"
     Type: uint256
     Gas costs: 0
     Source: "uint256 raisedAmount = 0"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "INITIAL_SUPPLY"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant INITIAL_SUPPLY = 7000000e18"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 7000000e18
       Type: int_const 7000000000000000000000000
       Source: "7000000e18"
  VariableDeclaration "MAX_SUPPLY"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant MAX_SUPPLY = 860000000000e18"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 860000000000e18
       Type: int_const 860000000000000000000000000000
       Source: "860000000000e18"
  VariableDeclaration "investors"
     Type: address[] storage ref
     Gas costs: 0
     Source: "address[] investors"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "up"
     Type: uint256
     Gas costs: 0
     Source: "uint256 up = 0"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "down"
     Type: uint256
     Gas costs: 0
     Source: "uint256 down = 0"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "votes"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) votes"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "trackable"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: [???]
     Source: "mapping (address => mapping (address => uint256)) public trackable"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "trackable_record"
     Type: mapping(address => mapping(uint256 => uint256))
     Gas costs: [???]
     Source: "mapping (address => mapping (uint => uint256)) public trackable_record"
    Mapping
       Source: "mapping (address => mapping (uint => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (uint => uint256)"
        ElementaryTypeName uint
           Source: "uint"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "bannable"
     Type: mapping(address => uint256)
     Gas costs: [???]
     Source: "mapping (address => uint256) public bannable"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "support_ban"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) internal support_ban"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "against_ban"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) internal against_ban"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  EventDefinition "BoughtTokens"
     Gas costs: 0
     Source: "event BoughtTokens(address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed to, uint256 value)"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Votes"
     Gas costs: 0
     Source: "event Votes(address indexed owner, uint256 value);"
    ParameterList
       Source: "(address indexed owner, uint256 value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Burn"
     Gas costs: 0
     Source: "event Burn(address indexed burner, uint256 value);"
    ParameterList
       Source: "(address indexed burner, uint256 value)"
      VariableDeclaration "burner"
         Type: address
         Source: "address indexed burner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Mint"
     Gas costs: 0
     Source: "event Mint(uint256 value);"
    ParameterList
       Source: "(uint256 value)"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "Ciphs" - public
     Source: "function Ciphs() public {\r\n    _totalSupply = INITIAL_SUPPLY;\r\n    balances[msg.sender] = INITIAL_SUPPLY;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    _totalSupply = INITIAL_SUPPLY;\r\n    balances[msg.sender] = INITIAL_SUPPLY;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "_totalSupply = INITIAL_SUPPLY"
        Assignment using operator =
           Type: uint256
           Source: "_totalSupply = INITIAL_SUPPLY"
          Identifier _totalSupply
             Type: uint256
             Source: "_totalSupply"
          Identifier INITIAL_SUPPLY
             Type: uint256
             Source: "INITIAL_SUPPLY"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] = INITIAL_SUPPLY"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = INITIAL_SUPPLY"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier INITIAL_SUPPLY
             Type: uint256
             Source: "INITIAL_SUPPLY"
  FunctionDefinition "initialize_proposal" - public
     Source: "function initialize_proposal() public {\r\n\r\n    if(propose) throw;\r\n    propose = true;\r\n    prosposal_time = now;\r\n\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\r\n    if(propose) throw;\r\n    propose = true;\r\n    prosposal_time = now;\r\n\r\n  }"
      IfStatement
         Source: "if(propose) throw"
        Identifier propose
           Type: bool
           Gas costs: 239
           Source: "propose"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20267
         Source: "propose = true"
        Assignment using operator =
           Type: bool
           Source: "propose = true"
          Identifier propose
             Type: bool
             Source: "propose"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 20013
         Source: "prosposal_time = now"
        Assignment using operator =
           Type: uint256
           Source: "prosposal_time = now"
          Identifier prosposal_time
             Type: uint256
             Source: "prosposal_time"
          Identifier now
             Type: uint256
             Source: "now"
  FunctionDefinition "is_proposal_supported" - public
     Source: "function is_proposal_supported() public returns (bool) {\r\n    if(!propose) throw;\r\n    if(down.mul(4) < up)\r\n    {\r\n        return false;\r\n    }else{\r\n        return true;\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    if(!propose) throw;\r\n    if(down.mul(4) < up)\r\n    {\r\n        return false;\r\n    }else{\r\n        return true;\r\n    }\r\n  }"
      IfStatement
         Source: "if(!propose) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 242
           Source: "!propose"
          Identifier propose
             Type: bool
             Source: "propose"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if(down.mul(4) < up)\r\n    {\r\n        return false;\r\n    }else{\r\n        return true;\r\n    }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 442
           Source: "down.mul(4) < up"
          FunctionCall
             Type: uint256
             Source: "down.mul(4)"
            MemberAccess to member mul
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "down.mul"
              Identifier down
                 Type: uint256
                 Source: "down"
            Literal, token: [no token] value: 4
               Type: int_const 4
               Source: "4"
          Identifier up
             Type: uint256
             Source: "up"
        Block
           Source: "{\r\n        return false;\r\n    }"
          Return
             Gas costs: 19
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
        Block
           Source: "{\r\n        return true;\r\n    }"
          Return
             Gas costs: 8
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
  ModifierDefinition "canMint"
     Source: "modifier canMint() {\r\n    if(propose && is_proposal_supported() && now > prosposal_time.add(7 * 1 days))\r\n    _;\r\n    else\r\n    throw;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    if(propose && is_proposal_supported() && now > prosposal_time.add(7 * 1 days))\r\n    _;\r\n    else\r\n    throw;\r\n  }"
      IfStatement
         Source: "if(propose && is_proposal_supported() && now > prosposal_time.add(7 * 1 days))\r\n    _;\r\n    else\r\n    throw"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "propose && is_proposal_supported() && now > prosposal_time.add(7 * 1 days)"
          BinaryOperation using operator &&
             Type: bool
             Source: "propose && is_proposal_supported()"
            Identifier propose
               Type: bool
               Source: "propose"
            FunctionCall
               Type: bool
               Source: "is_proposal_supported()"
              Identifier is_proposal_supported
                 Type: function () returns (bool)
                 Source: "is_proposal_supported"
          BinaryOperation using operator >
             Type: bool
             Source: "now > prosposal_time.add(7 * 1 days)"
            Identifier now
               Type: uint256
               Source: "now"
            FunctionCall
               Type: uint256
               Source: "prosposal_time.add(7 * 1 days)"
              MemberAccess to member add
                 Type: function (uint256,uint256) pure returns (uint256)
                 Source: "prosposal_time.add"
                Identifier prosposal_time
                   Type: uint256
                   Source: "prosposal_time"
              BinaryOperation using operator *
                 Type: int_const 604800
                 Source: "7 * 1 days"
                Literal, token: [no token] value: 7
                   Type: int_const 7
                   Source: "7"
                Literal, token: [no token] value: 1
                   Type: int_const 86400
                   Source: "1 days"
        PlaceholderStatement
           Gas costs: 0
           Source: "_"
        Throw
           Gas costs: 0
           Source: "throw"
  FunctionDefinition "distribute_token" - public
     Source: "function distribute_token()\r\n  {\r\n       uint256 investors_num = investors.length;\r\n       uint256 amount = (1000000e18-1000)/investors_num;\r\n       for(var i = 0; i < investors_num; i++)\r\n       {\r\n           if(last_seen[investors[i]].add(90 * 1 days) > now)\r\n           {\r\n                balances[investors[i]] += amount;\r\n                last_seen[investors[i]] = now;\r\n            }\r\n       }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n       uint256 investors_num = investors.length;\r\n       uint256 amount = (1000000e18-1000)/investors_num;\r\n       for(var i = 0; i < investors_num; i++)\r\n       {\r\n           if(last_seen[investors[i]].add(90 * 1 days) > now)\r\n           {\r\n                balances[investors[i]] += amount;\r\n                last_seen[investors[i]] = now;\r\n            }\r\n       }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 219
         Source: "uint256 investors_num = investors.length"
        VariableDeclaration "investors_num"
           Type: uint256
           Source: "uint256 investors_num"
          ElementaryTypeName uint256
             Source: "uint256"
        MemberAccess to member length
           Type: uint256
           Source: "investors.length"
          Identifier investors
             Type: address[] storage ref
             Source: "investors"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint256 amount = (1000000e18-1000)/investors_num"
        VariableDeclaration "amount"
           Type: uint256
           Source: "uint256 amount"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "(1000000e18-1000)/investors_num"
          TupleExpression
             Type: int_const 999999999999999999999000
             Source: "(1000000e18-1000)"
            BinaryOperation using operator -
               Type: int_const 999999999999999999999000
               Source: "1000000e18-1000"
              Literal, token: [no token] value: 1000000e18
                 Type: int_const 1000000000000000000000000
                 Source: "1000000e18"
              Literal, token: [no token] value: 1000
                 Type: int_const 1000
                 Source: "1000"
          Identifier investors_num
             Type: uint256
             Source: "investors_num"
      ForStatement
         Source: "for(var i = 0; i < investors_num; i++)\r\n       {\r\n           if(last_seen[investors[i]].add(90 * 1 days) > now)\r\n           {\r\n                balances[investors[i]] += amount;\r\n                last_seen[investors[i]] = now;\r\n            }\r\n       }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "var i = 0"
          VariableDeclaration "i"
             Type: uint8
             Source: "var i"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 15
           Source: "i < investors_num"
          Identifier i
             Type: uint8
             Source: "i"
          Identifier investors_num
             Type: uint256
             Source: "investors_num"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint8
             Source: "i++"
            Identifier i
               Type: uint8
               Source: "i"
        Block
           Source: "{\r\n           if(last_seen[investors[i]].add(90 * 1 days) > now)\r\n           {\r\n                balances[investors[i]] += amount;\r\n                last_seen[investors[i]] = now;\r\n            }\r\n       }"
          IfStatement
             Source: "if(last_seen[investors[i]].add(90 * 1 days) > now)\r\n           {\r\n                balances[investors[i]] += amount;\r\n                last_seen[investors[i]] = now;\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: [???]
               Source: "last_seen[investors[i]].add(90 * 1 days) > now"
              FunctionCall
                 Type: uint256
                 Source: "last_seen[investors[i]].add(90 * 1 days)"
                MemberAccess to member add
                   Type: function (uint256,uint256) pure returns (uint256)
                   Source: "last_seen[investors[i]].add"
                  IndexAccess
                     Type: uint256
                     Source: "last_seen[investors[i]]"
                    Identifier last_seen
                       Type: mapping(address => uint256)
                       Source: "last_seen"
                    IndexAccess
                       Type: address
                       Source: "investors[i]"
                      Identifier investors
                         Type: address[] storage ref
                         Source: "investors"
                      Identifier i
                         Type: uint8
                         Source: "i"
                BinaryOperation using operator *
                   Type: int_const 7776000
                   Source: "90 * 1 days"
                  Literal, token: [no token] value: 90
                     Type: int_const 90
                     Source: "90"
                  Literal, token: [no token] value: 1
                     Type: int_const 86400
                     Source: "1 days"
              Identifier now
                 Type: uint256
                 Source: "now"
            Block
               Source: "{\r\n                balances[investors[i]] += amount;\r\n                last_seen[investors[i]] = now;\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "balances[investors[i]] += amount"
                Assignment using operator +=
                   Type: uint256
                   Source: "balances[investors[i]] += amount"
                  IndexAccess
                     Type: uint256
                     Source: "balances[investors[i]]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    IndexAccess
                       Type: address
                       Source: "investors[i]"
                      Identifier investors
                         Type: address[] storage ref
                         Source: "investors"
                      Identifier i
                         Type: uint8
                         Source: "i"
                  Identifier amount
                     Type: uint256
                     Source: "amount"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "last_seen[investors[i]] = now"
                Assignment using operator =
                   Type: uint256
                   Source: "last_seen[investors[i]] = now"
                  IndexAccess
                     Type: uint256
                     Source: "last_seen[investors[i]]"
                    Identifier last_seen
                       Type: mapping(address => uint256)
                       Source: "last_seen"
                    IndexAccess
                       Type: address
                       Source: "investors[i]"
                      Identifier investors
                         Type: address[] storage ref
                         Source: "investors"
                      Identifier i
                         Type: uint8
                         Source: "i"
                  Identifier now
                     Type: uint256
                     Source: "now"
  FunctionDefinition "mint" - public
     Source: "function mint() /*canMint*/ public returns (bool) {\r\n    \r\n    if(propose && now >= prosposal_time.add(7 * 1 days)){\r\n        uint256 _amount = 1000000e18;\r\n        _totalSupply = _totalSupply.add(_amount);\r\n        if(_totalSupply <= MAX_SUPPLY && is_proposal_supported())\r\n        {\r\n            balances[owner] = balances[owner].add(1000);\r\n            //Transfer(address(0), _to, _amount);\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            distribute_token();\r\n            Mint(_amount);\r\n            return true;\r\n        }else{\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            //return true;\r\n        }\r\n        \r\n    }\r\n    last_seen[msg.sender] = now;\r\n    //return false;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    \r\n    if(propose && now >= prosposal_time.add(7 * 1 days)){\r\n        uint256 _amount = 1000000e18;\r\n        _totalSupply = _totalSupply.add(_amount);\r\n        if(_totalSupply <= MAX_SUPPLY && is_proposal_supported())\r\n        {\r\n            balances[owner] = balances[owner].add(1000);\r\n            //Transfer(address(0), _to, _amount);\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            distribute_token();\r\n            Mint(_amount);\r\n            return true;\r\n        }else{\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            //return true;\r\n        }\r\n        \r\n    }\r\n    last_seen[msg.sender] = now;\r\n    //return false;\r\n  }"
      IfStatement
         Source: "if(propose && now >= prosposal_time.add(7 * 1 days)){\r\n        uint256 _amount = 1000000e18;\r\n        _totalSupply = _totalSupply.add(_amount);\r\n        if(_totalSupply <= MAX_SUPPLY && is_proposal_supported())\r\n        {\r\n            balances[owner] = balances[owner].add(1000);\r\n            //Transfer(address(0), _to, _amount);\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            distribute_token();\r\n            Mint(_amount);\r\n            return true;\r\n        }else{\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            //return true;\r\n        }\r\n        \r\n    }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 505
           Source: "propose && now >= prosposal_time.add(7 * 1 days)"
          Identifier propose
             Type: bool
             Source: "propose"
          BinaryOperation using operator >=
             Type: bool
             Source: "now >= prosposal_time.add(7 * 1 days)"
            Identifier now
               Type: uint256
               Source: "now"
            FunctionCall
               Type: uint256
               Source: "prosposal_time.add(7 * 1 days)"
              MemberAccess to member add
                 Type: function (uint256,uint256) pure returns (uint256)
                 Source: "prosposal_time.add"
                Identifier prosposal_time
                   Type: uint256
                   Source: "prosposal_time"
              BinaryOperation using operator *
                 Type: int_const 604800
                 Source: "7 * 1 days"
                Literal, token: [no token] value: 7
                   Type: int_const 7
                   Source: "7"
                Literal, token: [no token] value: 1
                   Type: int_const 86400
                   Source: "1 days"
        Block
           Source: "{\r\n        uint256 _amount = 1000000e18;\r\n        _totalSupply = _totalSupply.add(_amount);\r\n        if(_totalSupply <= MAX_SUPPLY && is_proposal_supported())\r\n        {\r\n            balances[owner] = balances[owner].add(1000);\r\n            //Transfer(address(0), _to, _amount);\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            distribute_token();\r\n            Mint(_amount);\r\n            return true;\r\n        }else{\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            //return true;\r\n        }\r\n        \r\n    }"
          VariableDeclarationStatement
             Gas costs: 11
             Source: "uint256 _amount = 1000000e18"
            VariableDeclaration "_amount"
               Type: uint256
               Source: "uint256 _amount"
              ElementaryTypeName uint256
                 Source: "uint256"
            Literal, token: [no token] value: 1000000e18
               Type: int_const 1000000000000000000000000
               Source: "1000000e18"
          ExpressionStatement
             Gas costs: 20247
             Source: "_totalSupply = _totalSupply.add(_amount)"
            Assignment using operator =
               Type: uint256
               Source: "_totalSupply = _totalSupply.add(_amount)"
              Identifier _totalSupply
                 Type: uint256
                 Source: "_totalSupply"
              FunctionCall
                 Type: uint256
                 Source: "_totalSupply.add(_amount)"
                MemberAccess to member add
                   Type: function (uint256,uint256) pure returns (uint256)
                   Source: "_totalSupply.add"
                  Identifier _totalSupply
                     Type: uint256
                     Source: "_totalSupply"
                Identifier _amount
                   Type: uint256
                   Source: "_amount"
          IfStatement
             Source: "if(_totalSupply <= MAX_SUPPLY && is_proposal_supported())\r\n        {\r\n            balances[owner] = balances[owner].add(1000);\r\n            //Transfer(address(0), _to, _amount);\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            distribute_token();\r\n            Mint(_amount);\r\n            return true;\r\n        }else{\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            //return true;\r\n        }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 246
               Source: "_totalSupply <= MAX_SUPPLY && is_proposal_supported()"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "_totalSupply <= MAX_SUPPLY"
                Identifier _totalSupply
                   Type: uint256
                   Source: "_totalSupply"
                Identifier MAX_SUPPLY
                   Type: uint256
                   Source: "MAX_SUPPLY"
              FunctionCall
                 Type: bool
                 Source: "is_proposal_supported()"
                Identifier is_proposal_supported
                   Type: function () returns (bool)
                   Source: "is_proposal_supported"
            Block
               Source: "{\r\n            balances[owner] = balances[owner].add(1000);\r\n            //Transfer(address(0), _to, _amount);\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            distribute_token();\r\n            Mint(_amount);\r\n            return true;\r\n        }"
              ExpressionStatement
                 Gas costs: 20911
                 Source: "balances[owner] = balances[owner].add(1000)"
                Assignment using operator =
                   Type: uint256
                   Source: "balances[owner] = balances[owner].add(1000)"
                  IndexAccess
                     Type: uint256
                     Source: "balances[owner]"
                    Identifier balances
                       Type: mapping(address => uint256)
                       Source: "balances"
                    Identifier owner
                       Type: address
                       Source: "owner"
                  FunctionCall
                     Type: uint256
                     Source: "balances[owner].add(1000)"
                    MemberAccess to member add
                       Type: function (uint256,uint256) pure returns (uint256)
                       Source: "balances[owner].add"
                      IndexAccess
                         Type: uint256
                         Source: "balances[owner]"
                        Identifier balances
                           Type: mapping(address => uint256)
                           Source: "balances"
                        Identifier owner
                           Type: address
                           Source: "owner"
                    Literal, token: [no token] value: 1000
                       Type: int_const 1000
                       Source: "1000"
              ExpressionStatement
                 Gas costs: 20267
                 Source: "propose = false"
                Assignment using operator =
                   Type: bool
                   Source: "propose = false"
                  Identifier propose
                     Type: bool
                     Source: "propose"
                  Literal, token: false value: false
                     Type: bool
                     Source: "false"
              ExpressionStatement
                 Gas costs: 5014
                 Source: "prosposal_time = 0"
                Assignment using operator =
                   Type: uint256
                   Source: "prosposal_time = 0"
                  Identifier prosposal_time
                     Type: uint256
                     Source: "prosposal_time"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              ExpressionStatement
                 Gas costs: 5014
                 Source: "up = 0"
                Assignment using operator =
                   Type: uint256
                   Source: "up = 0"
                  Identifier up
                     Type: uint256
                     Source: "up"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              ExpressionStatement
                 Gas costs: 5014
                 Source: "down = 0"
                Assignment using operator =
                   Type: uint256
                   Source: "down = 0"
                  Identifier down
                     Type: uint256
                     Source: "down"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              ExpressionStatement
                 Gas costs: 15
                 Source: "distribute_token()"
                FunctionCall
                   Type: tuple()
                   Source: "distribute_token()"
                  Identifier distribute_token
                     Type: function ()
                     Source: "distribute_token"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "Mint(_amount)"
                FunctionCall
                   Type: tuple()
                   Source: "Mint(_amount)"
                  Identifier Mint
                     Type: function (uint256)
                     Source: "Mint"
                  Identifier _amount
                     Type: uint256
                     Source: "_amount"
              Return
                 Gas costs: 19
                 Source: "return true"
                Literal, token: true value: true
                   Type: bool
                   Source: "true"
            Block
               Source: "{\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            //return true;\r\n        }"
              ExpressionStatement
                 Gas costs: 20267
                 Source: "propose = false"
                Assignment using operator =
                   Type: bool
                   Source: "propose = false"
                  Identifier propose
                     Type: bool
                     Source: "propose"
                  Literal, token: false value: false
                     Type: bool
                     Source: "false"
              ExpressionStatement
                 Gas costs: 5014
                 Source: "prosposal_time = 0"
                Assignment using operator =
                   Type: uint256
                   Source: "prosposal_time = 0"
                  Identifier prosposal_time
                     Type: uint256
                     Source: "prosposal_time"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              ExpressionStatement
                 Gas costs: 5014
                 Source: "up = 0"
                Assignment using operator =
                   Type: uint256
                   Source: "up = 0"
                  Identifier up
                     Type: uint256
                     Source: "up"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              ExpressionStatement
                 Gas costs: 5014
                 Source: "down = 0"
                Assignment using operator =
                   Type: uint256
                   Source: "down = 0"
                  Identifier down
                     Type: uint256
                     Source: "down"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
      ExpressionStatement
         Gas costs: 20108
         Source: "last_seen[msg.sender] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[msg.sender] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[msg.sender]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier now
             Type: uint256
             Source: "now"
  FunctionDefinition "support_proposal" - public
     Source: "function support_proposal() public returns (bool) {\r\n    if(!propose || votes[msg.sender] == 1) throw;\r\n    //first check balance to be more than 10 Ciphs\r\n    if(balances[msg.sender] > 100e18)\r\n    {\r\n        //only vote once\r\n        votes[msg.sender] = 1;\r\n        up++;\r\n        mint();\r\n        Votes(msg.sender, 1);\r\n        return true;\r\n\r\n    }else\r\n    {\r\n        //no sufficient funds to carry out voting consensus\r\n        return false;\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    if(!propose || votes[msg.sender] == 1) throw;\r\n    //first check balance to be more than 10 Ciphs\r\n    if(balances[msg.sender] > 100e18)\r\n    {\r\n        //only vote once\r\n        votes[msg.sender] = 1;\r\n        up++;\r\n        mint();\r\n        Votes(msg.sender, 1);\r\n        return true;\r\n\r\n    }else\r\n    {\r\n        //no sufficient funds to carry out voting consensus\r\n        return false;\r\n    }\r\n  }"
      IfStatement
         Source: "if(!propose || votes[msg.sender] == 1) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 565
           Source: "!propose || votes[msg.sender] == 1"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!propose"
            Identifier propose
               Type: bool
               Source: "propose"
          BinaryOperation using operator ==
             Type: bool
             Source: "votes[msg.sender] == 1"
            IndexAccess
               Type: uint256
               Source: "votes[msg.sender]"
              Identifier votes
                 Type: mapping(address => uint256)
                 Source: "votes"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if(balances[msg.sender] > 100e18)\r\n    {\r\n        //only vote once\r\n        votes[msg.sender] = 1;\r\n        up++;\r\n        mint();\r\n        Votes(msg.sender, 1);\r\n        return true;\r\n\r\n    }else\r\n    {\r\n        //no sufficient funds to carry out voting consensus\r\n        return false;\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 304
           Source: "balances[msg.sender] > 100e18"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 100e18
             Type: int_const 100000000000000000000
             Source: "100e18"
        Block
           Source: "{\r\n        //only vote once\r\n        votes[msg.sender] = 1;\r\n        up++;\r\n        mint();\r\n        Votes(msg.sender, 1);\r\n        return true;\r\n\r\n    }"
          ExpressionStatement
             Gas costs: 20109
             Source: "votes[msg.sender] = 1"
            Assignment using operator =
               Type: uint256
               Source: "votes[msg.sender] = 1"
              IndexAccess
                 Type: uint256
                 Source: "votes[msg.sender]"
                Identifier votes
                   Type: mapping(address => uint256)
                   Source: "votes"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          ExpressionStatement
             Gas costs: 20237
             Source: "up++"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "up++"
              Identifier up
                 Type: uint256
                 Source: "up"
          ExpressionStatement
             Gas costs: 17
             Source: "mint()"
            FunctionCall
               Type: bool
               Source: "mint()"
              Identifier mint
                 Type: function () returns (bool)
                 Source: "mint"
          ExpressionStatement
             Gas costs: [???]
             Source: "Votes(msg.sender, 1)"
            FunctionCall
               Type: tuple()
               Source: "Votes(msg.sender, 1)"
              Identifier Votes
                 Type: function (address,uint256)
                 Source: "Votes"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{\r\n        //no sufficient funds to carry out voting consensus\r\n        return false;\r\n    }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "against_proposal" - public
     Source: "function against_proposal() public returns (bool) {\r\n    if(!propose || votes[msg.sender] == 1) throw;\r\n    //first check balance to be more than 10 Ciphs\r\n    if(balances[msg.sender] > 100e18)\r\n    {\r\n        //only vote once\r\n        votes[msg.sender] = 1;\r\n        down++;\r\n        mint();\r\n        Votes(msg.sender, 1);\r\n        return true;\r\n\r\n    }else\r\n    {\r\n        //no sufficient funds to carry out voting consensus\r\n        return false;\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    if(!propose || votes[msg.sender] == 1) throw;\r\n    //first check balance to be more than 10 Ciphs\r\n    if(balances[msg.sender] > 100e18)\r\n    {\r\n        //only vote once\r\n        votes[msg.sender] = 1;\r\n        down++;\r\n        mint();\r\n        Votes(msg.sender, 1);\r\n        return true;\r\n\r\n    }else\r\n    {\r\n        //no sufficient funds to carry out voting consensus\r\n        return false;\r\n    }\r\n  }"
      IfStatement
         Source: "if(!propose || votes[msg.sender] == 1) throw"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 565
           Source: "!propose || votes[msg.sender] == 1"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!propose"
            Identifier propose
               Type: bool
               Source: "propose"
          BinaryOperation using operator ==
             Type: bool
             Source: "votes[msg.sender] == 1"
            IndexAccess
               Type: uint256
               Source: "votes[msg.sender]"
              Identifier votes
                 Type: mapping(address => uint256)
                 Source: "votes"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if(balances[msg.sender] > 100e18)\r\n    {\r\n        //only vote once\r\n        votes[msg.sender] = 1;\r\n        down++;\r\n        mint();\r\n        Votes(msg.sender, 1);\r\n        return true;\r\n\r\n    }else\r\n    {\r\n        //no sufficient funds to carry out voting consensus\r\n        return false;\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 304
           Source: "balances[msg.sender] > 100e18"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 100e18
             Type: int_const 100000000000000000000
             Source: "100e18"
        Block
           Source: "{\r\n        //only vote once\r\n        votes[msg.sender] = 1;\r\n        down++;\r\n        mint();\r\n        Votes(msg.sender, 1);\r\n        return true;\r\n\r\n    }"
          ExpressionStatement
             Gas costs: 20109
             Source: "votes[msg.sender] = 1"
            Assignment using operator =
               Type: uint256
               Source: "votes[msg.sender] = 1"
              IndexAccess
                 Type: uint256
                 Source: "votes[msg.sender]"
                Identifier votes
                   Type: mapping(address => uint256)
                   Source: "votes"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          ExpressionStatement
             Gas costs: 20237
             Source: "down++"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "down++"
              Identifier down
                 Type: uint256
                 Source: "down"
          ExpressionStatement
             Gas costs: 17
             Source: "mint()"
            FunctionCall
               Type: bool
               Source: "mint()"
              Identifier mint
                 Type: function () returns (bool)
                 Source: "mint"
          ExpressionStatement
             Gas costs: [???]
             Source: "Votes(msg.sender, 1)"
            FunctionCall
               Type: tuple()
               Source: "Votes(msg.sender, 1)"
              Identifier Votes
                 Type: function (address,uint256)
                 Source: "Votes"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{\r\n        //no sufficient funds to carry out voting consensus\r\n        return false;\r\n    }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "ban_account"
     Source: "function ban_account(address _bannable_address) internal{\r\n        if(balances[_bannable_address] > 0)\r\n        {\r\n          transferFrom(_bannable_address, owner, balances[_bannable_address]);\r\n        }\r\n        delete balances[_bannable_address];\r\n        \r\n        uint256 investors_num = investors.length;\r\n        for(var i = 0; i < investors_num; i++)\r\n        {\r\n            if(investors[i] == _bannable_address){\r\n                delete investors[i];\r\n            }\r\n        }\r\n      //delete investors[];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _bannable_address)"
      VariableDeclaration "_bannable_address"
         Type: address
         Source: "address _bannable_address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if(balances[_bannable_address] > 0)\r\n        {\r\n          transferFrom(_bannable_address, owner, balances[_bannable_address]);\r\n        }\r\n        delete balances[_bannable_address];\r\n        \r\n        uint256 investors_num = investors.length;\r\n        for(var i = 0; i < investors_num; i++)\r\n        {\r\n            if(investors[i] == _bannable_address){\r\n                delete investors[i];\r\n            }\r\n        }\r\n      //delete investors[];\r\n  }"
      IfStatement
         Source: "if(balances[_bannable_address] > 0)\r\n        {\r\n          transferFrom(_bannable_address, owner, balances[_bannable_address]);\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 305
           Source: "balances[_bannable_address] > 0"
          IndexAccess
             Type: uint256
             Source: "balances[_bannable_address]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _bannable_address
               Type: address
               Source: "_bannable_address"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n          transferFrom(_bannable_address, owner, balances[_bannable_address]);\r\n        }"
          ExpressionStatement
             Gas costs: 558
             Source: "transferFrom(_bannable_address, owner, balances[_bannable_address])"
            FunctionCall
               Type: bool
               Source: "transferFrom(_bannable_address, owner, balances[_bannable_address])"
              Identifier transferFrom
                 Type: function (address,address,uint256) returns (bool)
                 Source: "transferFrom"
              Identifier _bannable_address
                 Type: address
                 Source: "_bannable_address"
              Identifier owner
                 Type: address
                 Source: "owner"
              IndexAccess
                 Type: uint256
                 Source: "balances[_bannable_address]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _bannable_address
                   Type: address
                   Source: "_bannable_address"
      ExpressionStatement
         Gas costs: 5105
         Source: "delete balances[_bannable_address]"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete balances[_bannable_address]"
          IndexAccess
             Type: uint256
             Source: "balances[_bannable_address]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _bannable_address
               Type: address
               Source: "_bannable_address"
      VariableDeclarationStatement
         Gas costs: 219
         Source: "uint256 investors_num = investors.length"
        VariableDeclaration "investors_num"
           Type: uint256
           Source: "uint256 investors_num"
          ElementaryTypeName uint256
             Source: "uint256"
        MemberAccess to member length
           Type: uint256
           Source: "investors.length"
          Identifier investors
             Type: address[] storage ref
             Source: "investors"
      ForStatement
         Source: "for(var i = 0; i < investors_num; i++)\r\n        {\r\n            if(investors[i] == _bannable_address){\r\n                delete investors[i];\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "var i = 0"
          VariableDeclaration "i"
             Type: uint8
             Source: "var i"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 15
           Source: "i < investors_num"
          Identifier i
             Type: uint8
             Source: "i"
          Identifier investors_num
             Type: uint256
             Source: "investors_num"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint8
             Source: "i++"
            Identifier i
               Type: uint8
               Source: "i"
        Block
           Source: "{\r\n            if(investors[i] == _bannable_address){\r\n                delete investors[i];\r\n            }\r\n        }"
          IfStatement
             Source: "if(investors[i] == _bannable_address){\r\n                delete investors[i];\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Gas costs: 552
               Source: "investors[i] == _bannable_address"
              IndexAccess
                 Type: address
                 Source: "investors[i]"
                Identifier investors
                   Type: address[] storage ref
                   Source: "investors"
                Identifier i
                   Type: uint8
                   Source: "i"
              Identifier _bannable_address
                 Type: address
                 Source: "_bannable_address"
            Block
               Source: "{\r\n                delete investors[i];\r\n            }"
              ExpressionStatement
                 Gas costs: 20537
                 Source: "delete investors[i]"
                UnaryOperation (prefix) delete
                   Type: tuple()
                   Source: "delete investors[i]"
                  IndexAccess
                     Type: address
                     Source: "investors[i]"
                    Identifier investors
                       Type: address[] storage ref
                       Source: "investors"
                    Identifier i
                       Type: uint8
                       Source: "i"
  FunctionDefinition "ban_check"
     Source: "function ban_check(address _bannable_address) internal\r\n  {\r\n    last_seen[msg.sender] = now;\r\n    //uint256 time_diff = now.sub(bannable[_bannable_address]); \r\n    if(now.sub(bannable[_bannable_address]) > 0.5 * 1 days)\r\n    {\r\n        if(against_ban[_bannable_address].mul(4) < support_ban[_bannable_address])\r\n        {\r\n            ban_account(_bannable_address);\r\n        }\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _bannable_address)"
      VariableDeclaration "_bannable_address"
         Type: address
         Source: "address _bannable_address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    last_seen[msg.sender] = now;\r\n    //uint256 time_diff = now.sub(bannable[_bannable_address]); \r\n    if(now.sub(bannable[_bannable_address]) > 0.5 * 1 days)\r\n    {\r\n        if(against_ban[_bannable_address].mul(4) < support_ban[_bannable_address])\r\n        {\r\n            ban_account(_bannable_address);\r\n        }\r\n    }\r\n  }"
      ExpressionStatement
         Gas costs: 20108
         Source: "last_seen[msg.sender] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[msg.sender] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[msg.sender]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier now
             Type: uint256
             Source: "now"
      IfStatement
         Source: "if(now.sub(bannable[_bannable_address]) > 0.5 * 1 days)\r\n    {\r\n        if(against_ban[_bannable_address].mul(4) < support_ban[_bannable_address])\r\n        {\r\n            ban_account(_bannable_address);\r\n        }\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 331
           Source: "now.sub(bannable[_bannable_address]) > 0.5 * 1 days"
          FunctionCall
             Type: uint256
             Source: "now.sub(bannable[_bannable_address])"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "now.sub"
              Identifier now
                 Type: uint256
                 Source: "now"
            IndexAccess
               Type: uint256
               Source: "bannable[_bannable_address]"
              Identifier bannable
                 Type: mapping(address => uint256)
                 Source: "bannable"
              Identifier _bannable_address
                 Type: address
                 Source: "_bannable_address"
          BinaryOperation using operator *
             Type: int_const 43200
             Source: "0.5 * 1 days"
            Literal, token: [no token] value: 0.5
               Type: rational_const 1 / 2
               Source: "0.5"
            Literal, token: [no token] value: 1
               Type: int_const 86400
               Source: "1 days"
        Block
           Source: "{\r\n        if(against_ban[_bannable_address].mul(4) < support_ban[_bannable_address])\r\n        {\r\n            ban_account(_bannable_address);\r\n        }\r\n    }"
          IfStatement
             Source: "if(against_ban[_bannable_address].mul(4) < support_ban[_bannable_address])\r\n        {\r\n            ban_account(_bannable_address);\r\n        }"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 628
               Source: "against_ban[_bannable_address].mul(4) < support_ban[_bannable_address]"
              FunctionCall
                 Type: uint256
                 Source: "against_ban[_bannable_address].mul(4)"
                MemberAccess to member mul
                   Type: function (uint256,uint256) pure returns (uint256)
                   Source: "against_ban[_bannable_address].mul"
                  IndexAccess
                     Type: uint256
                     Source: "against_ban[_bannable_address]"
                    Identifier against_ban
                       Type: mapping(address => uint256)
                       Source: "against_ban"
                    Identifier _bannable_address
                       Type: address
                       Source: "_bannable_address"
                Literal, token: [no token] value: 4
                   Type: int_const 4
                   Source: "4"
              IndexAccess
                 Type: uint256
                 Source: "support_ban[_bannable_address]"
                Identifier support_ban
                   Type: mapping(address => uint256)
                   Source: "support_ban"
                Identifier _bannable_address
                   Type: address
                   Source: "_bannable_address"
            Block
               Source: "{\r\n            ban_account(_bannable_address);\r\n        }"
              ExpressionStatement
                 Gas costs: 7
                 Source: "ban_account(_bannable_address)"
                FunctionCall
                   Type: tuple()
                   Source: "ban_account(_bannable_address)"
                  Identifier ban_account
                     Type: function (address)
                     Source: "ban_account"
                  Identifier _bannable_address
                     Type: address
                     Source: "_bannable_address"
  FunctionDefinition "initialize_bannable" - public
     Source: "function initialize_bannable(address _bannable_address) public {\r\n    bannable[_bannable_address] = now;\r\n    last_seen[msg.sender] = now;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _bannable_address)"
      VariableDeclaration "_bannable_address"
         Type: address
         Source: "address _bannable_address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    bannable[_bannable_address] = now;\r\n    last_seen[msg.sender] = now;\r\n  }"
      ExpressionStatement
         Gas costs: 20109
         Source: "bannable[_bannable_address] = now"
        Assignment using operator =
           Type: uint256
           Source: "bannable[_bannable_address] = now"
          IndexAccess
             Type: uint256
             Source: "bannable[_bannable_address]"
            Identifier bannable
               Type: mapping(address => uint256)
               Source: "bannable"
            Identifier _bannable_address
               Type: address
               Source: "_bannable_address"
          Identifier now
             Type: uint256
             Source: "now"
      ExpressionStatement
         Gas costs: 20102
         Source: "last_seen[msg.sender] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[msg.sender] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[msg.sender]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier now
             Type: uint256
             Source: "now"
  FunctionDefinition "support_ban_of" - public
     Source: "function support_ban_of(address _bannable_address) public\r\n  {\r\n    require(bannable[_bannable_address] > 0);\r\n    support_ban[_bannable_address] = support_ban[_bannable_address].add(1);\r\n    ban_check(_bannable_address);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _bannable_address)"
      VariableDeclaration "_bannable_address"
         Type: address
         Source: "address _bannable_address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    require(bannable[_bannable_address] > 0);\r\n    support_ban[_bannable_address] = support_ban[_bannable_address].add(1);\r\n    ban_check(_bannable_address);\r\n  }"
      ExpressionStatement
         Gas costs: 331
         Source: "require(bannable[_bannable_address] > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(bannable[_bannable_address] > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "bannable[_bannable_address] > 0"
            IndexAccess
               Type: uint256
               Source: "bannable[_bannable_address]"
              Identifier bannable
                 Type: mapping(address => uint256)
                 Source: "bannable"
              Identifier _bannable_address
                 Type: address
                 Source: "_bannable_address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20439
         Source: "support_ban[_bannable_address] = support_ban[_bannable_address].add(1)"
        Assignment using operator =
           Type: uint256
           Source: "support_ban[_bannable_address] = support_ban[_bannable_address].add(1)"
          IndexAccess
             Type: uint256
             Source: "support_ban[_bannable_address]"
            Identifier support_ban
               Type: mapping(address => uint256)
               Source: "support_ban"
            Identifier _bannable_address
               Type: address
               Source: "_bannable_address"
          FunctionCall
             Type: uint256
             Source: "support_ban[_bannable_address].add(1)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "support_ban[_bannable_address].add"
              IndexAccess
                 Type: uint256
                 Source: "support_ban[_bannable_address]"
                Identifier support_ban
                   Type: mapping(address => uint256)
                   Source: "support_ban"
                Identifier _bannable_address
                   Type: address
                   Source: "_bannable_address"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: 7
         Source: "ban_check(_bannable_address)"
        FunctionCall
           Type: tuple()
           Source: "ban_check(_bannable_address)"
          Identifier ban_check
             Type: function (address)
             Source: "ban_check"
          Identifier _bannable_address
             Type: address
             Source: "_bannable_address"
  FunctionDefinition "against_ban_of" - public
     Source: "function against_ban_of(address _bannable_address) public\r\n  {\r\n    require(bannable[_bannable_address] > 0);\r\n    against_ban[_bannable_address] = against_ban[_bannable_address].add(1);\r\n    ban_check(_bannable_address);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _bannable_address)"
      VariableDeclaration "_bannable_address"
         Type: address
         Source: "address _bannable_address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    require(bannable[_bannable_address] > 0);\r\n    against_ban[_bannable_address] = against_ban[_bannable_address].add(1);\r\n    ban_check(_bannable_address);\r\n  }"
      ExpressionStatement
         Gas costs: 331
         Source: "require(bannable[_bannable_address] > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(bannable[_bannable_address] > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "bannable[_bannable_address] > 0"
            IndexAccess
               Type: uint256
               Source: "bannable[_bannable_address]"
              Identifier bannable
                 Type: mapping(address => uint256)
                 Source: "bannable"
              Identifier _bannable_address
                 Type: address
                 Source: "_bannable_address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 20439
         Source: "against_ban[_bannable_address] = against_ban[_bannable_address].add(1)"
        Assignment using operator =
           Type: uint256
           Source: "against_ban[_bannable_address] = against_ban[_bannable_address].add(1)"
          IndexAccess
             Type: uint256
             Source: "against_ban[_bannable_address]"
            Identifier against_ban
               Type: mapping(address => uint256)
               Source: "against_ban"
            Identifier _bannable_address
               Type: address
               Source: "_bannable_address"
          FunctionCall
             Type: uint256
             Source: "against_ban[_bannable_address].add(1)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "against_ban[_bannable_address].add"
              IndexAccess
                 Type: uint256
                 Source: "against_ban[_bannable_address]"
                Identifier against_ban
                   Type: mapping(address => uint256)
                   Source: "against_ban"
                Identifier _bannable_address
                   Type: address
                   Source: "_bannable_address"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: 18
         Source: "ban_check(_bannable_address)"
        FunctionCall
           Type: tuple()
           Source: "ban_check(_bannable_address)"
          Identifier ban_check
             Type: function (address)
             Source: "ban_check"
          Identifier _bannable_address
             Type: address
             Source: "_bannable_address"
  FunctionDefinition "track" - public
     Source: "function track(address _trackable) public returns (bool) {\r\n    // \"trackable added, vote like or dislike using the address registered with the trackable\";\r\n    trackable[_trackable][msg.sender] = 1;\r\n    last_seen[msg.sender] = now;\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _trackable)"
      VariableDeclaration "_trackable"
         Type: address
         Source: "address _trackable"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    // \"trackable added, vote like or dislike using the address registered with the trackable\";\r\n    trackable[_trackable][msg.sender] = 1;\r\n    last_seen[msg.sender] = now;\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 20199
         Source: "trackable[_trackable][msg.sender] = 1"
        Assignment using operator =
           Type: uint256
           Source: "trackable[_trackable][msg.sender] = 1"
          IndexAccess
             Type: uint256
             Source: "trackable[_trackable][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "trackable[_trackable]"
              Identifier trackable
                 Type: mapping(address => mapping(address => uint256))
                 Source: "trackable"
              Identifier _trackable
                 Type: address
                 Source: "_trackable"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Gas costs: 20102
         Source: "last_seen[msg.sender] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[msg.sender] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[msg.sender]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier now
             Type: uint256
             Source: "now"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "like_trackable" - public
     Source: "function like_trackable(address _trackable) public returns (bool) {\r\n    last_seen[msg.sender] = now;\r\n    if(trackable[_trackable][msg.sender] != 1)\r\n    {\r\n        trackable[_trackable][msg.sender] = 1;\r\n        trackable_record[_trackable][1] = trackable_record[_trackable][1] + 1;\r\n        return true;\r\n    }\r\n    return false;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _trackable)"
      VariableDeclaration "_trackable"
         Type: address
         Source: "address _trackable"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    last_seen[msg.sender] = now;\r\n    if(trackable[_trackable][msg.sender] != 1)\r\n    {\r\n        trackable[_trackable][msg.sender] = 1;\r\n        trackable_record[_trackable][1] = trackable_record[_trackable][1] + 1;\r\n        return true;\r\n    }\r\n    return false;\r\n  }"
      ExpressionStatement
         Gas costs: 20108
         Source: "last_seen[msg.sender] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[msg.sender] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[msg.sender]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier now
             Type: uint256
             Source: "now"
      IfStatement
         Source: "if(trackable[_trackable][msg.sender] != 1)\r\n    {\r\n        trackable[_trackable][msg.sender] = 1;\r\n        trackable_record[_trackable][1] = trackable_record[_trackable][1] + 1;\r\n        return true;\r\n    }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 391
           Source: "trackable[_trackable][msg.sender] != 1"
          IndexAccess
             Type: uint256
             Source: "trackable[_trackable][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "trackable[_trackable]"
              Identifier trackable
                 Type: mapping(address => mapping(address => uint256))
                 Source: "trackable"
              Identifier _trackable
                 Type: address
                 Source: "_trackable"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        Block
           Source: "{\r\n        trackable[_trackable][msg.sender] = 1;\r\n        trackable_record[_trackable][1] = trackable_record[_trackable][1] + 1;\r\n        return true;\r\n    }"
          ExpressionStatement
             Gas costs: 20199
             Source: "trackable[_trackable][msg.sender] = 1"
            Assignment using operator =
               Type: uint256
               Source: "trackable[_trackable][msg.sender] = 1"
              IndexAccess
                 Type: uint256
                 Source: "trackable[_trackable][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "trackable[_trackable]"
                  Identifier trackable
                     Type: mapping(address => mapping(address => uint256))
                     Source: "trackable"
                  Identifier _trackable
                     Type: address
                     Source: "_trackable"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          ExpressionStatement
             Gas costs: 20556
             Source: "trackable_record[_trackable][1] = trackable_record[_trackable][1] + 1"
            Assignment using operator =
               Type: uint256
               Source: "trackable_record[_trackable][1] = trackable_record[_trackable][1] + 1"
              IndexAccess
                 Type: uint256
                 Source: "trackable_record[_trackable][1]"
                IndexAccess
                   Type: mapping(uint256 => uint256)
                   Source: "trackable_record[_trackable]"
                  Identifier trackable_record
                     Type: mapping(address => mapping(uint256 => uint256))
                     Source: "trackable_record"
                  Identifier _trackable
                     Type: address
                     Source: "_trackable"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "trackable_record[_trackable][1] + 1"
                IndexAccess
                   Type: uint256
                   Source: "trackable_record[_trackable][1]"
                  IndexAccess
                     Type: mapping(uint256 => uint256)
                     Source: "trackable_record[_trackable]"
                    Identifier trackable_record
                       Type: mapping(address => mapping(uint256 => uint256))
                       Source: "trackable_record"
                    Identifier _trackable
                       Type: address
                       Source: "_trackable"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      Return
         Gas costs: 8
         Source: "return false"
        Literal, token: false value: false
           Type: bool
           Source: "false"
  FunctionDefinition "dislike_trackable" - public
     Source: "function dislike_trackable(address _trackable) public returns (bool) {\r\n    last_seen[msg.sender] = now;\r\n    if(trackable[_trackable][msg.sender] != 1)\r\n    {\r\n        trackable[_trackable][msg.sender] = 1;\r\n        trackable_record[_trackable][2] = trackable_record[_trackable][2] + 1;\r\n        return true;\r\n    }\r\n    return false;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _trackable)"
      VariableDeclaration "_trackable"
         Type: address
         Source: "address _trackable"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    last_seen[msg.sender] = now;\r\n    if(trackable[_trackable][msg.sender] != 1)\r\n    {\r\n        trackable[_trackable][msg.sender] = 1;\r\n        trackable_record[_trackable][2] = trackable_record[_trackable][2] + 1;\r\n        return true;\r\n    }\r\n    return false;\r\n  }"
      ExpressionStatement
         Gas costs: 20108
         Source: "last_seen[msg.sender] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[msg.sender] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[msg.sender]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier now
             Type: uint256
             Source: "now"
      IfStatement
         Source: "if(trackable[_trackable][msg.sender] != 1)\r\n    {\r\n        trackable[_trackable][msg.sender] = 1;\r\n        trackable_record[_trackable][2] = trackable_record[_trackable][2] + 1;\r\n        return true;\r\n    }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 391
           Source: "trackable[_trackable][msg.sender] != 1"
          IndexAccess
             Type: uint256
             Source: "trackable[_trackable][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "trackable[_trackable]"
              Identifier trackable
                 Type: mapping(address => mapping(address => uint256))
                 Source: "trackable"
              Identifier _trackable
                 Type: address
                 Source: "_trackable"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        Block
           Source: "{\r\n        trackable[_trackable][msg.sender] = 1;\r\n        trackable_record[_trackable][2] = trackable_record[_trackable][2] + 1;\r\n        return true;\r\n    }"
          ExpressionStatement
             Gas costs: 20199
             Source: "trackable[_trackable][msg.sender] = 1"
            Assignment using operator =
               Type: uint256
               Source: "trackable[_trackable][msg.sender] = 1"
              IndexAccess
                 Type: uint256
                 Source: "trackable[_trackable][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "trackable[_trackable]"
                  Identifier trackable
                     Type: mapping(address => mapping(address => uint256))
                     Source: "trackable"
                  Identifier _trackable
                     Type: address
                     Source: "_trackable"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          ExpressionStatement
             Gas costs: 20556
             Source: "trackable_record[_trackable][2] = trackable_record[_trackable][2] + 1"
            Assignment using operator =
               Type: uint256
               Source: "trackable_record[_trackable][2] = trackable_record[_trackable][2] + 1"
              IndexAccess
                 Type: uint256
                 Source: "trackable_record[_trackable][2]"
                IndexAccess
                   Type: mapping(uint256 => uint256)
                   Source: "trackable_record[_trackable]"
                  Identifier trackable_record
                     Type: mapping(address => mapping(uint256 => uint256))
                     Source: "trackable_record"
                  Identifier _trackable
                     Type: address
                     Source: "_trackable"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "trackable_record[_trackable][2] + 1"
                IndexAccess
                   Type: uint256
                   Source: "trackable_record[_trackable][2]"
                  IndexAccess
                     Type: mapping(uint256 => uint256)
                     Source: "trackable_record[_trackable]"
                    Identifier trackable_record
                       Type: mapping(address => mapping(uint256 => uint256))
                       Source: "trackable_record"
                    Identifier _trackable
                       Type: address
                       Source: "_trackable"
                  Literal, token: [no token] value: 2
                     Type: int_const 2
                     Source: "2"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      Return
         Gas costs: 8
         Source: "return false"
        Literal, token: false value: false
           Type: bool
           Source: "false"
  FunctionDefinition "trackable_likes" - public
     Source: "function trackable_likes(address _trackable) public returns (uint256) {\r\n    uint256 num = 0;\r\n    //if(trackable[_trackable])\r\n    //{\r\n\r\n        num = trackable_record[_trackable][1];\r\n\r\n    //}\r\n    return num;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _trackable)"
      VariableDeclaration "_trackable"
         Type: address
         Source: "address _trackable"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 num = 0;\r\n    //if(trackable[_trackable])\r\n    //{\r\n\r\n        num = trackable_record[_trackable][1];\r\n\r\n    //}\r\n    return num;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint256 num = 0"
        VariableDeclaration "num"
           Type: uint256
           Source: "uint256 num"
          ElementaryTypeName uint256
             Source: "uint256"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ExpressionStatement
         Gas costs: 382
         Source: "num = trackable_record[_trackable][1]"
        Assignment using operator =
           Type: uint256
           Source: "num = trackable_record[_trackable][1]"
          Identifier num
             Type: uint256
             Source: "num"
          IndexAccess
             Type: uint256
             Source: "trackable_record[_trackable][1]"
            IndexAccess
               Type: mapping(uint256 => uint256)
               Source: "trackable_record[_trackable]"
              Identifier trackable_record
                 Type: mapping(address => mapping(uint256 => uint256))
                 Source: "trackable_record"
              Identifier _trackable
                 Type: address
                 Source: "_trackable"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      Return
         Gas costs: 8
         Source: "return num"
        Identifier num
           Type: uint256
           Source: "num"
  FunctionDefinition "trackable_dislikes" - public
     Source: "function trackable_dislikes(address _trackable) public returns (uint256) {\r\n    uint256 num = 0;\r\n    num = trackable_record[_trackable][2];\r\n    return num;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _trackable)"
      VariableDeclaration "_trackable"
         Type: address
         Source: "address _trackable"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 num = 0;\r\n    num = trackable_record[_trackable][2];\r\n    return num;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint256 num = 0"
        VariableDeclaration "num"
           Type: uint256
           Source: "uint256 num"
          ElementaryTypeName uint256
             Source: "uint256"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ExpressionStatement
         Gas costs: 382
         Source: "num = trackable_record[_trackable][2]"
        Assignment using operator =
           Type: uint256
           Source: "num = trackable_record[_trackable][2]"
          Identifier num
             Type: uint256
             Source: "num"
          IndexAccess
             Type: uint256
             Source: "trackable_record[_trackable][2]"
            IndexAccess
               Type: mapping(uint256 => uint256)
               Source: "trackable_record[_trackable]"
              Identifier trackable_record
                 Type: mapping(address => mapping(uint256 => uint256))
                 Source: "trackable_record"
              Identifier _trackable
                 Type: address
                 Source: "_trackable"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
      Return
         Gas costs: 8
         Source: "return num"
        Identifier num
           Type: uint256
           Source: "num"
  FunctionDefinition "" - public
     Source: "function () public payable {\r\n\r\n    buyTokens();\r\n\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\r\n    buyTokens();\r\n\r\n  }"
      ExpressionStatement
         Gas costs: 4
         Source: "buyTokens()"
        FunctionCall
           Type: tuple()
           Source: "buyTokens()"
          Identifier buyTokens
             Type: function ()
             Source: "buyTokens"
  FunctionDefinition "buyTokens" - public
     Source: "function buyTokens() public payable {\r\n      \r\n    //require(propose);\r\n    \r\n    uint256 weiAmount = msg.value;\r\n    uint256 tokens = weiAmount.mul(getRate());\r\n    \r\n    tokens = tokens.div(1 ether);\r\n    \r\n    BoughtTokens(msg.sender, tokens);\r\n\r\n    balances[msg.sender] = balances[msg.sender].add(tokens);\r\n    balances[owner] = balances[owner].sub(tokens);\r\n    _totalSupply.sub(tokens);\r\n\r\n    raisedAmount = raisedAmount.add(msg.value);\r\n    \r\n    investors.push(msg.sender) -1;\r\n    \r\n    last_seen[msg.sender] = now;\r\n    //owner.transfer(msg.value);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n      \r\n    //require(propose);\r\n    \r\n    uint256 weiAmount = msg.value;\r\n    uint256 tokens = weiAmount.mul(getRate());\r\n    \r\n    tokens = tokens.div(1 ether);\r\n    \r\n    BoughtTokens(msg.sender, tokens);\r\n\r\n    balances[msg.sender] = balances[msg.sender].add(tokens);\r\n    balances[owner] = balances[owner].sub(tokens);\r\n    _totalSupply.sub(tokens);\r\n\r\n    raisedAmount = raisedAmount.add(msg.value);\r\n    \r\n    investors.push(msg.sender) -1;\r\n    \r\n    last_seen[msg.sender] = now;\r\n    //owner.transfer(msg.value);\r\n  }"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint256 weiAmount = msg.value"
        VariableDeclaration "weiAmount"
           Type: uint256
           Source: "uint256 weiAmount"
          ElementaryTypeName uint256
             Source: "uint256"
        MemberAccess to member value
           Type: uint256
           Source: "msg.value"
          Identifier msg
             Type: msg
             Source: "msg"
      VariableDeclarationStatement
         Gas costs: 45
         Source: "uint256 tokens = weiAmount.mul(getRate())"
        VariableDeclaration "tokens"
           Type: uint256
           Source: "uint256 tokens"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "weiAmount.mul(getRate())"
          MemberAccess to member mul
             Type: function (uint256,uint256) pure returns (uint256)
             Source: "weiAmount.mul"
            Identifier weiAmount
               Type: uint256
               Source: "weiAmount"
          FunctionCall
             Type: uint256
             Source: "getRate()"
            Identifier getRate
               Type: function () view returns (uint256)
               Source: "getRate"
      ExpressionStatement
         Gas costs: 41
         Source: "tokens = tokens.div(1 ether)"
        Assignment using operator =
           Type: uint256
           Source: "tokens = tokens.div(1 ether)"
          Identifier tokens
             Type: uint256
             Source: "tokens"
          FunctionCall
             Type: uint256
             Source: "tokens.div(1 ether)"
            MemberAccess to member div
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "tokens.div"
              Identifier tokens
                 Type: uint256
                 Source: "tokens"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
      ExpressionStatement
         Gas costs: [???]
         Source: "BoughtTokens(msg.sender, tokens)"
        FunctionCall
           Type: tuple()
           Source: "BoughtTokens(msg.sender, tokens)"
          Identifier BoughtTokens
             Type: function (address,uint256)
             Source: "BoughtTokens"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: 20431
         Source: "balances[msg.sender] = balances[msg.sender].add(tokens)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = balances[msg.sender].add(tokens)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "balances[msg.sender].add(tokens)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[msg.sender].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier tokens
               Type: uint256
               Source: "tokens"
      ExpressionStatement
         Gas costs: 20905
         Source: "balances[owner] = balances[owner].sub(tokens)"
        Assignment using operator =
           Type: uint256
           Source: "balances[owner] = balances[owner].sub(tokens)"
          IndexAccess
             Type: uint256
             Source: "balances[owner]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier owner
               Type: address
               Source: "owner"
          FunctionCall
             Type: uint256
             Source: "balances[owner].sub(tokens)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[owner].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[owner]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier owner
                   Type: address
                   Source: "owner"
            Identifier tokens
               Type: uint256
               Source: "tokens"
      ExpressionStatement
         Gas costs: 238
         Source: "_totalSupply.sub(tokens)"
        FunctionCall
           Type: uint256
           Source: "_totalSupply.sub(tokens)"
          MemberAccess to member sub
             Type: function (uint256,uint256) pure returns (uint256)
             Source: "_totalSupply.sub"
            Identifier _totalSupply
               Type: uint256
               Source: "_totalSupply"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: 20246
         Source: "raisedAmount = raisedAmount.add(msg.value)"
        Assignment using operator =
           Type: uint256
           Source: "raisedAmount = raisedAmount.add(msg.value)"
          Identifier raisedAmount
             Type: uint256
             Source: "raisedAmount"
          FunctionCall
             Type: uint256
             Source: "raisedAmount.add(msg.value)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "raisedAmount.add"
              Identifier raisedAmount
                 Type: uint256
                 Source: "raisedAmount"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 20369
         Source: "investors.push(msg.sender) -1"
        BinaryOperation using operator -
           Type: uint256
           Source: "investors.push(msg.sender) -1"
          FunctionCall
             Type: uint256
             Source: "investors.push(msg.sender)"
            MemberAccess to member push
               Type: function (address) returns (uint256)
               Source: "investors.push"
              Identifier investors
                 Type: address[] storage ref
                 Source: "investors"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Gas costs: 20105
         Source: "last_seen[msg.sender] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[msg.sender] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[msg.sender]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier now
             Type: uint256
             Source: "now"
  FunctionDefinition "getInvestors" - public - const
     Source: "function getInvestors() view public returns (address[]){\r\n      return investors;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(address[])"
      VariableDeclaration ""
         Type: address[] memory
         Source: "address[]"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\r\n      return investors;\r\n  }"
      Return
         Gas costs: [???]
         Source: "return investors"
        Identifier investors
           Type: address[] storage ref
           Source: "investors"
  FunctionDefinition "setRate" - public
     Source: "function setRate(uint256 _rate) public onlyOwner{\r\n      rate = _rate;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _rate)"
      VariableDeclaration "_rate"
         Type: uint256
         Source: "uint256 _rate"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n      rate = _rate;\r\n  }"
      ExpressionStatement
         Gas costs: 20014
         Source: "rate = _rate"
        Assignment using operator =
           Type: uint256
           Source: "rate = _rate"
          Identifier rate
             Type: uint256
             Source: "rate"
          Identifier _rate
             Type: uint256
             Source: "_rate"
  FunctionDefinition "getRate" - public - const
     Source: "function getRate() public constant returns (uint256){\r\n      \r\n      return rate;\r\n      \r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n      \r\n      return rate;\r\n      \r\n  }"
      Return
         Gas costs: 208
         Source: "return rate"
        Identifier rate
           Type: uint256
           Source: "rate"
  FunctionDefinition "burn" - public
     Source: "function burn(uint256 _value) public {\r\n        require(_value > 0);\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        _totalSupply = _totalSupply.sub(_value);\r\n        Burn(msg.sender, _value);\r\n        last_seen[msg.sender] = now;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _value)"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require(_value > 0);\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        _totalSupply = _totalSupply.sub(_value);\r\n        Burn(msg.sender, _value);\r\n        last_seen[msg.sender] = now;\r\n  }"
      ExpressionStatement
         Gas costs: 35
         Source: "require(_value > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_value > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "_value > 0"
            Identifier _value
               Type: uint256
               Source: "_value"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "address burner = msg.sender"
        VariableDeclaration "burner"
           Type: address
           Source: "address burner"
          ElementaryTypeName address
             Source: "address"
        MemberAccess to member sender
           Type: address
           Source: "msg.sender"
          Identifier msg
             Type: msg
             Source: "msg"
      ExpressionStatement
         Gas costs: 20439
         Source: "balances[burner] = balances[burner].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[burner] = balances[burner].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[burner]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier burner
               Type: address
               Source: "burner"
          FunctionCall
             Type: uint256
             Source: "balances[burner].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[burner].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[burner]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier burner
                   Type: address
                   Source: "burner"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20247
         Source: "_totalSupply = _totalSupply.sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "_totalSupply = _totalSupply.sub(_value)"
          Identifier _totalSupply
             Type: uint256
             Source: "_totalSupply"
          FunctionCall
             Type: uint256
             Source: "_totalSupply.sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_totalSupply.sub"
              Identifier _totalSupply
                 Type: uint256
                 Source: "_totalSupply"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Burn(msg.sender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Burn(msg.sender, _value)"
          Identifier Burn
             Type: function (address,uint256)
             Source: "Burn"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20102
         Source: "last_seen[msg.sender] = now"
        Assignment using operator =
           Type: uint256
           Source: "last_seen[msg.sender] = now"
          IndexAccess
             Type: uint256
             Source: "last_seen[msg.sender]"
            Identifier last_seen
               Type: mapping(address => uint256)
               Source: "last_seen"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier now
             Type: uint256
             Source: "now"
  FunctionDefinition "destroy" - public
     Source: "function destroy() public onlyOwner {\r\n    selfdestruct(owner);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    selfdestruct(owner);\r\n  }"
      ExpressionStatement
         Gas costs: 30245
         Source: "selfdestruct(owner)"
        FunctionCall
           Type: tuple()
           Source: "selfdestruct(owner)"
          Identifier selfdestruct
             Type: function (address)
             Source: "selfdestruct"
          Identifier owner
             Type: address
             Source: "owner"
