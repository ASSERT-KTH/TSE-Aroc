Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xa45d88c06a8643fb53f9c9923162403852bf3592.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "mul"
     Source: "function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 88
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div"
     Source: "function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub"
     Source: "function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add"
     Source: "function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "Ownable"
   Source: "contract Ownable {\r\n  address public owner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  EventDefinition "OwnershipTransferred"
     Gas costs: 0
     Source: "event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);"
    ParameterList
       Source: "(address indexed previousOwner, address indexed newOwner)"
      VariableDeclaration "previousOwner"
         Type: address
         Source: "address indexed previousOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address indexed newOwner"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "Ownable" - public
     Source: "function Ownable() public {\r\n    owner = msg.sender;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    owner = msg.sender;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 846
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(newOwner != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(newOwner != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "newOwner != address(0)"
            Identifier newOwner
               Type: address
               Source: "newOwner"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "OwnershipTransferred(owner, newOwner)"
        FunctionCall
           Type: tuple()
           Source: "OwnershipTransferred(owner, newOwner)"
          Identifier OwnershipTransferred
             Type: function (address,address)
             Source: "OwnershipTransferred"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
ContractDefinition "ERC20Basic"
   Gas costs: [???]
   Source: "contract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant public returns (uint256);\r\n  function transfer(address to, uint256 value) internal returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) constant public returns (uint256);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer"
     Source: "function transfer(address to, uint256 value) internal returns (bool);"
    ParameterList
       Source: "(address to, uint256 value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "BasicToken"
   Source: "contract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) tokenBalances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) internal returns (bool) {\r\n    //TRANSFER Functionality has been disabled as we wanted to make the token non-tradable\r\n    //and we are nice people so we don't want anyone to not get their payout :)\r\n    return false;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant public returns (uint256 balance) {\r\n    return tokenBalances[_owner];\r\n  }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "tokenBalances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) tokenBalances"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  FunctionDefinition "transfer"
     Source: "function transfer(address _to, uint256 _value) internal returns (bool) {\r\n    //TRANSFER Functionality has been disabled as we wanted to make the token non-tradable\r\n    //and we are nice people so we don't want anyone to not get their payout :)\r\n    return false;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    //TRANSFER Functionality has been disabled as we wanted to make the token non-tradable\r\n    //and we are nice people so we don't want anyone to not get their payout :)\r\n    return false;\r\n  }"
      Return
         Gas costs: 0
         Source: "return false"
        Literal, token: false value: false
           Type: bool
           Source: "false"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant public returns (uint256 balance) {\r\n    return tokenBalances[_owner];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return tokenBalances[_owner];\r\n  }"
      Return
         Gas costs: 304
         Source: "return tokenBalances[_owner]"
        IndexAccess
           Type: uint256
           Source: "tokenBalances[_owner]"
          Identifier tokenBalances
             Type: mapping(address => uint256)
             Source: "tokenBalances"
          Identifier _owner
             Type: address
             Source: "_owner"
ContractDefinition "HareemMinePoolToken"
   Source: "contract HareemMinePoolToken is BasicToken, Ownable {\r\n\r\n   using SafeMath for uint256;\r\n   string public constant name = \"HareemMinePool\";\r\n   string public constant symbol = \"HMP\";\r\n   uint256 public constant decimals = 18;\r\n\r\n   uint256 constant INITIAL_SUPPLY = 1000 * (10 ** uint256(decimals));\r\n   uint256 public sellPrice = 0.35 * 10 ** 18;  \r\n   uint256 public buyPrice = 0.25 * 10 ** 18; \r\n  \r\n   string public constant COLLATERAL_HELD = \"1000 ETH\";\r\n   uint payout_worth = 0;\r\n   \r\n   event Debug(string message, uint256 num);\r\n   \r\n   mapping(address => uint256) amountLeftToBePaid;\r\n   mapping(address => uint256) partialAmtToBePaid;\r\n   \r\n   address[] listAddr;\r\n   \r\n   //Client addresses\r\n   address ethStore = 0x66Ef84EE378B07012FE44Df83b64Ea2Ae35fD09b;   \r\n   address exchange = 0x093af86909F7E2135aD764e9cB384Ed7311799d3;\r\n   \r\n   uint perTokenPayout = 0;\r\n   uint tokenToTakeBack = 0;\r\n   \r\n   event addr(string message, address sender);\r\n   event logString(string message);\r\n   \r\n   // fallback function can be used to buy tokens\r\n    function () public payable {\r\n    buy(msg.sender);\r\n    }\r\n  \r\n    /**\r\n    * @dev Contructor that gives msg.sender all of existing tokens.\r\n    */\r\n    function HareemMinePoolToken() public {\r\n    owner = ethStore;\r\n    totalSupply = INITIAL_SUPPLY;\r\n    tokenBalances[owner] = INITIAL_SUPPLY;\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        transferOwnership(newOwner);\r\n    }\r\n\r\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public onlyOwner {\r\n        sellPrice = newSellPrice * 10 ** 3;\r\n        buyPrice = newBuyPrice * 10 ** 3; \r\n    }\r\n  \r\n    function payoutWorth(address beneficiary) constant public returns (uint amount) {\r\n        amount = amountLeftToBePaid[beneficiary];\r\n    }\r\n    \r\n    function tokensLeft() public view returns (uint amount) {\r\n        amount = tokenBalances[owner];\r\n    }\r\n    \r\n    function payoutLeft() internal constant returns (uint amount) {\r\n        for (uint i=0;i<listAddr.length;i++)\r\n        {\r\n            amount = amount + amountLeftToBePaid[listAddr[i]];\r\n        }\r\n        return amount;\r\n    }\r\n    function doPayout() payable public onlyOwner{\r\n      uint payLeft = payoutLeft();\r\n      uint cashBack = msg.value;\r\n      require (payLeft>0 && cashBack <=payLeft);\r\n      uint soldTokens = totalSupply.sub(tokenBalances[owner]);\r\n      cashBack = cashBack.mul(10**18);\r\n      perTokenPayout =cashBack.div(soldTokens);\r\n      tokenToTakeBack = perTokenPayout.mul(10**18);\r\n      tokenToTakeBack = tokenToTakeBack.div(sellPrice);\r\n      makePayments();\r\n    }\r\n    \r\n    function makePayments() internal {\r\n        uint exchangeAmount;\r\n        uint customerAmt;\r\n        for (uint i=0;i<listAddr.length;i++)\r\n        {\r\n            uint payAmt = amountLeftToBePaid[listAddr[i]];\r\n            if (payAmt >0)\r\n            {\r\n                uint tokensHeld = payAmt.mul(10**18);\r\n                tokensHeld = tokensHeld.div(sellPrice); // shouldnt this be buyprice?\r\n                \r\n                if (tokensHeld >0)\r\n                {\r\n                    uint sendMoney = tokensHeld.mul(perTokenPayout);\r\n                    sendMoney = sendMoney.div(10**decimals);\r\n                    uint takeBackTokens = tokenToTakeBack.mul(tokensHeld);\r\n                    takeBackTokens = takeBackTokens.div(10**decimals);\r\n                    (exchangeAmount,customerAmt) = getExchangeAndEthStoreAmount(sendMoney); \r\n                    exchange.transfer(exchangeAmount);\r\n                    listAddr[i].transfer(customerAmt);\r\n                    amountLeftToBePaid[listAddr[i]] = amountLeftToBePaid[listAddr[i]].sub(sendMoney);\r\n                    tokenBalances[listAddr[i]] = tokenBalances[listAddr[i]].sub(takeBackTokens);\r\n                    tokenBalances[owner] = tokenBalances[owner].add(takeBackTokens);\r\n                    Transfer(listAddr[i],owner, takeBackTokens); \r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function buy(address beneficiary) payable public returns (uint amount) {\r\n        require (msg.value.div(buyPrice) >= 1);   \r\n        uint exchangeAmount;\r\n        uint ethStoreAmt;\r\n        (exchangeAmount,ethStoreAmt) = getExchangeAndEthStoreAmount(msg.value); \r\n        ethStore.transfer(ethStoreAmt);    \r\n        exchange.transfer(exchangeAmount);\r\n        //uint tempBuyPrice = buyPrice.mul(10**decimals);\r\n        amount = msg.value.div(buyPrice);                    // calculates the amount\r\n        amount = amount.mul(10**decimals);\r\n        require(tokenBalances[owner] >= amount);               // checks if it has enough to sell\r\n        tokenBalances[beneficiary] = tokenBalances[beneficiary].add(amount);                  // adds the amount to buyer's balance\r\n        tokenBalances[owner] = tokenBalances[owner].sub(amount);                        // subtracts amount from seller's balance\r\n        \r\n        uint earlierBalance =  amountLeftToBePaid[beneficiary];\r\n        uint amountToBePaid = amount.mul(sellPrice);\r\n        amountToBePaid = amountToBePaid.div(10**18);\r\n        amountLeftToBePaid[beneficiary] = amountToBePaid.add(earlierBalance);   //input how much has to be paid out to the customer later on\r\n        Transfer(owner, beneficiary, amount);\r\n        if (earlierBalance == 0) \r\n            listAddr.push(beneficiary);\r\n        return amount;                                    // ends function and returns\r\n    }\r\n   \r\n   function getExchangeAndEthStoreAmount(uint value) internal pure returns (uint exchangeAmt, uint ethStoreAmt) {\r\n       exchangeAmt = value.div(100);    //since 1% means divide by 100\r\n       ethStoreAmt = value - exchangeAmt;   //the rest would be eth store amount\r\n   }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "BasicToken"
    UserDefinedTypeName "BasicToken"
       Source: "BasicToken"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "name"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant name = \"HareemMinePool\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: HareemMinePool
       Type: literal_string "HareemMinePool"
       Source: "\"HareemMinePool\""
  VariableDeclaration "symbol"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant symbol = \"HMP\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: HMP
       Type: literal_string "HMP"
       Source: "\"HMP\""
  VariableDeclaration "decimals"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant decimals = 18"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "INITIAL_SUPPLY"
     Type: uint256
     Gas costs: 0
     Source: "uint256 constant INITIAL_SUPPLY = 1000 * (10 ** uint256(decimals))"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator *
       Type: uint256
       Source: "1000 * (10 ** uint256(decimals))"
      Literal, token: [no token] value: 1000
         Type: int_const 1000
         Source: "1000"
      TupleExpression
         Type: uint256
         Source: "(10 ** uint256(decimals))"
        BinaryOperation using operator **
           Type: uint256
           Source: "10 ** uint256(decimals)"
          Literal, token: [no token] value: 10
             Type: int_const 10
             Source: "10"
          FunctionCall
             Type: uint256
             Source: "uint256(decimals)"
            ElementaryTypeNameExpression uint256
               Type: type(uint256)
               Source: "uint256"
            Identifier decimals
               Type: uint256
               Source: "decimals"
  VariableDeclaration "sellPrice"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public sellPrice = 0.35 * 10 ** 18"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator *
       Type: int_const 350000000000000000
       Source: "0.35 * 10 ** 18"
      Literal, token: [no token] value: 0.35
         Type: rational_const 7 / 20
         Source: "0.35"
      BinaryOperation using operator **
         Type: int_const 1000000000000000000
         Source: "10 ** 18"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Literal, token: [no token] value: 18
           Type: int_const 18
           Source: "18"
  VariableDeclaration "buyPrice"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public buyPrice = 0.25 * 10 ** 18"
    ElementaryTypeName uint256
       Source: "uint256"
    BinaryOperation using operator *
       Type: int_const 250000000000000000
       Source: "0.25 * 10 ** 18"
      Literal, token: [no token] value: 0.25
         Type: rational_const 1 / 4
         Source: "0.25"
      BinaryOperation using operator **
         Type: int_const 1000000000000000000
         Source: "10 ** 18"
        Literal, token: [no token] value: 10
           Type: int_const 10
           Source: "10"
        Literal, token: [no token] value: 18
           Type: int_const 18
           Source: "18"
  VariableDeclaration "COLLATERAL_HELD"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant COLLATERAL_HELD = \"1000 ETH\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: 1000 ETH
       Type: literal_string "1000 ETH"
       Source: "\"1000 ETH\""
  VariableDeclaration "payout_worth"
     Type: uint256
     Gas costs: 0
     Source: "uint payout_worth = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  EventDefinition "Debug"
     Gas costs: 0
     Source: "event Debug(string message, uint256 num);"
    ParameterList
       Source: "(string message, uint256 num)"
      VariableDeclaration "message"
         Type: string memory
         Source: "string message"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "num"
         Type: uint256
         Source: "uint256 num"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "amountLeftToBePaid"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) amountLeftToBePaid"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "partialAmtToBePaid"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) partialAmtToBePaid"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "listAddr"
     Type: address[] storage ref
     Gas costs: 0
     Source: "address[] listAddr"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "ethStore"
     Type: address
     Gas costs: 0
     Source: "address ethStore = 0x66Ef84EE378B07012FE44Df83b64Ea2Ae35fD09b"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x66Ef84EE378B07012FE44Df83b64Ea2Ae35fD09b
       Type: address
       Source: "0x66Ef84EE378B07012FE44Df83b64Ea2Ae35fD09b"
  VariableDeclaration "exchange"
     Type: address
     Gas costs: 0
     Source: "address exchange = 0x093af86909F7E2135aD764e9cB384Ed7311799d3"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x093af86909F7E2135aD764e9cB384Ed7311799d3
       Type: address
       Source: "0x093af86909F7E2135aD764e9cB384Ed7311799d3"
  VariableDeclaration "perTokenPayout"
     Type: uint256
     Gas costs: 0
     Source: "uint perTokenPayout = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "tokenToTakeBack"
     Type: uint256
     Gas costs: 0
     Source: "uint tokenToTakeBack = 0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  EventDefinition "addr"
     Gas costs: 0
     Source: "event addr(string message, address sender);"
    ParameterList
       Source: "(string message, address sender)"
      VariableDeclaration "message"
         Type: string memory
         Source: "string message"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "logString"
     Gas costs: 0
     Source: "event logString(string message);"
    ParameterList
       Source: "(string message)"
      VariableDeclaration "message"
         Type: string memory
         Source: "string message"
        ElementaryTypeName string
           Source: "string"
  FunctionDefinition "" - public
     Source: "function () public payable {\r\n    buy(msg.sender);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    buy(msg.sender);\r\n    }"
      ExpressionStatement
         Gas costs: 8
         Source: "buy(msg.sender)"
        FunctionCall
           Type: uint256
           Source: "buy(msg.sender)"
          Identifier buy
             Type: function (address) returns (uint256)
             Source: "buy"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "HareemMinePoolToken" - public
     Source: "function HareemMinePoolToken() public {\r\n    owner = ethStore;\r\n    totalSupply = INITIAL_SUPPLY;\r\n    tokenBalances[owner] = INITIAL_SUPPLY;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    owner = ethStore;\r\n    totalSupply = INITIAL_SUPPLY;\r\n    tokenBalances[owner] = INITIAL_SUPPLY;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = ethStore"
        Assignment using operator =
           Type: address
           Source: "owner = ethStore"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier ethStore
             Type: address
             Source: "ethStore"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = INITIAL_SUPPLY"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = INITIAL_SUPPLY"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier INITIAL_SUPPLY
             Type: uint256
             Source: "INITIAL_SUPPLY"
      ExpressionStatement
         Gas costs: 0
         Source: "tokenBalances[owner] = INITIAL_SUPPLY"
        Assignment using operator =
           Type: uint256
           Source: "tokenBalances[owner] = INITIAL_SUPPLY"
          IndexAccess
             Type: uint256
             Source: "tokenBalances[owner]"
            Identifier tokenBalances
               Type: mapping(address => uint256)
               Source: "tokenBalances"
            Identifier owner
               Type: address
               Source: "owner"
          Identifier INITIAL_SUPPLY
             Type: uint256
             Source: "INITIAL_SUPPLY"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) public onlyOwner {\r\n        transferOwnership(newOwner);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        transferOwnership(newOwner);\r\n    }"
      ExpressionStatement
         Gas costs: 18
         Source: "transferOwnership(newOwner)"
        FunctionCall
           Type: tuple()
           Source: "transferOwnership(newOwner)"
          Identifier transferOwnership
             Type: function (address)
             Source: "transferOwnership"
          Identifier newOwner
             Type: address
             Source: "newOwner"
  FunctionDefinition "setPrices" - public
     Source: "function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public onlyOwner {\r\n        sellPrice = newSellPrice * 10 ** 3;\r\n        buyPrice = newBuyPrice * 10 ** 3; \r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 newSellPrice, uint256 newBuyPrice)"
      VariableDeclaration "newSellPrice"
         Type: uint256
         Source: "uint256 newSellPrice"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "newBuyPrice"
         Type: uint256
         Source: "uint256 newBuyPrice"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        sellPrice = newSellPrice * 10 ** 3;\r\n        buyPrice = newBuyPrice * 10 ** 3; \r\n    }"
      ExpressionStatement
         Gas costs: 20022
         Source: "sellPrice = newSellPrice * 10 ** 3"
        Assignment using operator =
           Type: uint256
           Source: "sellPrice = newSellPrice * 10 ** 3"
          Identifier sellPrice
             Type: uint256
             Source: "sellPrice"
          BinaryOperation using operator *
             Type: uint256
             Source: "newSellPrice * 10 ** 3"
            Identifier newSellPrice
               Type: uint256
               Source: "newSellPrice"
            BinaryOperation using operator **
               Type: int_const 1000
               Source: "10 ** 3"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Literal, token: [no token] value: 3
                 Type: int_const 3
                 Source: "3"
      ExpressionStatement
         Gas costs: 20022
         Source: "buyPrice = newBuyPrice * 10 ** 3"
        Assignment using operator =
           Type: uint256
           Source: "buyPrice = newBuyPrice * 10 ** 3"
          Identifier buyPrice
             Type: uint256
             Source: "buyPrice"
          BinaryOperation using operator *
             Type: uint256
             Source: "newBuyPrice * 10 ** 3"
            Identifier newBuyPrice
               Type: uint256
               Source: "newBuyPrice"
            BinaryOperation using operator **
               Type: int_const 1000
               Source: "10 ** 3"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Literal, token: [no token] value: 3
                 Type: int_const 3
                 Source: "3"
  FunctionDefinition "payoutWorth" - public - const
     Source: "function payoutWorth(address beneficiary) constant public returns (uint amount) {\r\n        amount = amountLeftToBePaid[beneficiary];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address beneficiary)"
      VariableDeclaration "beneficiary"
         Type: address
         Source: "address beneficiary"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        amount = amountLeftToBePaid[beneficiary];\r\n    }"
      ExpressionStatement
         Gas costs: 304
         Source: "amount = amountLeftToBePaid[beneficiary]"
        Assignment using operator =
           Type: uint256
           Source: "amount = amountLeftToBePaid[beneficiary]"
          Identifier amount
             Type: uint256
             Source: "amount"
          IndexAccess
             Type: uint256
             Source: "amountLeftToBePaid[beneficiary]"
            Identifier amountLeftToBePaid
               Type: mapping(address => uint256)
               Source: "amountLeftToBePaid"
            Identifier beneficiary
               Type: address
               Source: "beneficiary"
  FunctionDefinition "tokensLeft" - public - const
     Source: "function tokensLeft() public view returns (uint amount) {\r\n        amount = tokenBalances[owner];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        amount = tokenBalances[owner];\r\n    }"
      ExpressionStatement
         Gas costs: 540
         Source: "amount = tokenBalances[owner]"
        Assignment using operator =
           Type: uint256
           Source: "amount = tokenBalances[owner]"
          Identifier amount
             Type: uint256
             Source: "amount"
          IndexAccess
             Type: uint256
             Source: "tokenBalances[owner]"
            Identifier tokenBalances
               Type: mapping(address => uint256)
               Source: "tokenBalances"
            Identifier owner
               Type: address
               Source: "owner"
  FunctionDefinition "payoutLeft" - const
     Source: "function payoutLeft() internal constant returns (uint amount) {\r\n        for (uint i=0;i<listAddr.length;i++)\r\n        {\r\n            amount = amount + amountLeftToBePaid[listAddr[i]];\r\n        }\r\n        return amount;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        for (uint i=0;i<listAddr.length;i++)\r\n        {\r\n            amount = amount + amountLeftToBePaid[listAddr[i]];\r\n        }\r\n        return amount;\r\n    }"
      ForStatement
         Source: "for (uint i=0;i<listAddr.length;i++)\r\n        {\r\n            amount = amount + amountLeftToBePaid[listAddr[i]];\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 217
           Source: "i<listAddr.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "listAddr.length"
            Identifier listAddr
               Type: address[] storage ref
               Source: "listAddr"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            amount = amount + amountLeftToBePaid[listAddr[i]];\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "amount = amount + amountLeftToBePaid[listAddr[i]]"
            Assignment using operator =
               Type: uint256
               Source: "amount = amount + amountLeftToBePaid[listAddr[i]]"
              Identifier amount
                 Type: uint256
                 Source: "amount"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "amount + amountLeftToBePaid[listAddr[i]]"
                Identifier amount
                   Type: uint256
                   Source: "amount"
                IndexAccess
                   Type: uint256
                   Source: "amountLeftToBePaid[listAddr[i]]"
                  Identifier amountLeftToBePaid
                     Type: mapping(address => uint256)
                     Source: "amountLeftToBePaid"
                  IndexAccess
                     Type: address
                     Source: "listAddr[i]"
                    Identifier listAddr
                       Type: address[] storage ref
                       Source: "listAddr"
                    Identifier i
                       Type: uint256
                       Source: "i"
      Return
         Gas costs: 8
         Source: "return amount"
        Identifier amount
           Type: uint256
           Source: "amount"
  FunctionDefinition "doPayout" - public
     Source: "function doPayout() payable public onlyOwner{\r\n      uint payLeft = payoutLeft();\r\n      uint cashBack = msg.value;\r\n      require (payLeft>0 && cashBack <=payLeft);\r\n      uint soldTokens = totalSupply.sub(tokenBalances[owner]);\r\n      cashBack = cashBack.mul(10**18);\r\n      perTokenPayout =cashBack.div(soldTokens);\r\n      tokenToTakeBack = perTokenPayout.mul(10**18);\r\n      tokenToTakeBack = tokenToTakeBack.div(sellPrice);\r\n      makePayments();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n      uint payLeft = payoutLeft();\r\n      uint cashBack = msg.value;\r\n      require (payLeft>0 && cashBack <=payLeft);\r\n      uint soldTokens = totalSupply.sub(tokenBalances[owner]);\r\n      cashBack = cashBack.mul(10**18);\r\n      perTokenPayout =cashBack.div(soldTokens);\r\n      tokenToTakeBack = perTokenPayout.mul(10**18);\r\n      tokenToTakeBack = tokenToTakeBack.div(sellPrice);\r\n      makePayments();\r\n    }"
      VariableDeclarationStatement
         Gas costs: 12
         Source: "uint payLeft = payoutLeft()"
        VariableDeclaration "payLeft"
           Type: uint256
           Source: "uint payLeft"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "payoutLeft()"
          Identifier payoutLeft
             Type: function () view returns (uint256)
             Source: "payoutLeft"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint cashBack = msg.value"
        VariableDeclaration "cashBack"
           Type: uint256
           Source: "uint cashBack"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member value
           Type: uint256
           Source: "msg.value"
          Identifier msg
             Type: msg
             Source: "msg"
      ExpressionStatement
         Gas costs: 69
         Source: "require (payLeft>0 && cashBack <=payLeft)"
        FunctionCall
           Type: tuple()
           Source: "require (payLeft>0 && cashBack <=payLeft)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "payLeft>0 && cashBack <=payLeft"
            BinaryOperation using operator >
               Type: bool
               Source: "payLeft>0"
              Identifier payLeft
                 Type: uint256
                 Source: "payLeft"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator <=
               Type: bool
               Source: "cashBack <=payLeft"
              Identifier cashBack
                 Type: uint256
                 Source: "cashBack"
              Identifier payLeft
                 Type: uint256
                 Source: "payLeft"
      VariableDeclarationStatement
         Gas costs: 776
         Source: "uint soldTokens = totalSupply.sub(tokenBalances[owner])"
        VariableDeclaration "soldTokens"
           Type: uint256
           Source: "uint soldTokens"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "totalSupply.sub(tokenBalances[owner])"
          MemberAccess to member sub
             Type: function (uint256,uint256) pure returns (uint256)
             Source: "totalSupply.sub"
            Identifier totalSupply
               Type: uint256
               Source: "totalSupply"
          IndexAccess
             Type: uint256
             Source: "tokenBalances[owner]"
            Identifier tokenBalances
               Type: mapping(address => uint256)
               Source: "tokenBalances"
            Identifier owner
               Type: address
               Source: "owner"
      ExpressionStatement
         Gas costs: 41
         Source: "cashBack = cashBack.mul(10**18)"
        Assignment using operator =
           Type: uint256
           Source: "cashBack = cashBack.mul(10**18)"
          Identifier cashBack
             Type: uint256
             Source: "cashBack"
          FunctionCall
             Type: uint256
             Source: "cashBack.mul(10**18)"
            MemberAccess to member mul
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "cashBack.mul"
              Identifier cashBack
                 Type: uint256
                 Source: "cashBack"
            BinaryOperation using operator **
               Type: int_const 1000000000000000000
               Source: "10**18"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Literal, token: [no token] value: 18
                 Type: int_const 18
                 Source: "18"
      ExpressionStatement
         Gas costs: 20047
         Source: "perTokenPayout =cashBack.div(soldTokens)"
        Assignment using operator =
           Type: uint256
           Source: "perTokenPayout =cashBack.div(soldTokens)"
          Identifier perTokenPayout
             Type: uint256
             Source: "perTokenPayout"
          FunctionCall
             Type: uint256
             Source: "cashBack.div(soldTokens)"
            MemberAccess to member div
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "cashBack.div"
              Identifier cashBack
                 Type: uint256
                 Source: "cashBack"
            Identifier soldTokens
               Type: uint256
               Source: "soldTokens"
      ExpressionStatement
         Gas costs: 20247
         Source: "tokenToTakeBack = perTokenPayout.mul(10**18)"
        Assignment using operator =
           Type: uint256
           Source: "tokenToTakeBack = perTokenPayout.mul(10**18)"
          Identifier tokenToTakeBack
             Type: uint256
             Source: "tokenToTakeBack"
          FunctionCall
             Type: uint256
             Source: "perTokenPayout.mul(10**18)"
            MemberAccess to member mul
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "perTokenPayout.mul"
              Identifier perTokenPayout
                 Type: uint256
                 Source: "perTokenPayout"
            BinaryOperation using operator **
               Type: int_const 1000000000000000000
               Source: "10**18"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Literal, token: [no token] value: 18
                 Type: int_const 18
                 Source: "18"
      ExpressionStatement
         Gas costs: 20447
         Source: "tokenToTakeBack = tokenToTakeBack.div(sellPrice)"
        Assignment using operator =
           Type: uint256
           Source: "tokenToTakeBack = tokenToTakeBack.div(sellPrice)"
          Identifier tokenToTakeBack
             Type: uint256
             Source: "tokenToTakeBack"
          FunctionCall
             Type: uint256
             Source: "tokenToTakeBack.div(sellPrice)"
            MemberAccess to member div
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "tokenToTakeBack.div"
              Identifier tokenToTakeBack
                 Type: uint256
                 Source: "tokenToTakeBack"
            Identifier sellPrice
               Type: uint256
               Source: "sellPrice"
      ExpressionStatement
         Gas costs: 4
         Source: "makePayments()"
        FunctionCall
           Type: tuple()
           Source: "makePayments()"
          Identifier makePayments
             Type: function ()
             Source: "makePayments"
  FunctionDefinition "makePayments"
     Source: "function makePayments() internal {\r\n        uint exchangeAmount;\r\n        uint customerAmt;\r\n        for (uint i=0;i<listAddr.length;i++)\r\n        {\r\n            uint payAmt = amountLeftToBePaid[listAddr[i]];\r\n            if (payAmt >0)\r\n            {\r\n                uint tokensHeld = payAmt.mul(10**18);\r\n                tokensHeld = tokensHeld.div(sellPrice); // shouldnt this be buyprice?\r\n                \r\n                if (tokensHeld >0)\r\n                {\r\n                    uint sendMoney = tokensHeld.mul(perTokenPayout);\r\n                    sendMoney = sendMoney.div(10**decimals);\r\n                    uint takeBackTokens = tokenToTakeBack.mul(tokensHeld);\r\n                    takeBackTokens = takeBackTokens.div(10**decimals);\r\n                    (exchangeAmount,customerAmt) = getExchangeAndEthStoreAmount(sendMoney); \r\n                    exchange.transfer(exchangeAmount);\r\n                    listAddr[i].transfer(customerAmt);\r\n                    amountLeftToBePaid[listAddr[i]] = amountLeftToBePaid[listAddr[i]].sub(sendMoney);\r\n                    tokenBalances[listAddr[i]] = tokenBalances[listAddr[i]].sub(takeBackTokens);\r\n                    tokenBalances[owner] = tokenBalances[owner].add(takeBackTokens);\r\n                    Transfer(listAddr[i],owner, takeBackTokens); \r\n                }\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint exchangeAmount;\r\n        uint customerAmt;\r\n        for (uint i=0;i<listAddr.length;i++)\r\n        {\r\n            uint payAmt = amountLeftToBePaid[listAddr[i]];\r\n            if (payAmt >0)\r\n            {\r\n                uint tokensHeld = payAmt.mul(10**18);\r\n                tokensHeld = tokensHeld.div(sellPrice); // shouldnt this be buyprice?\r\n                \r\n                if (tokensHeld >0)\r\n                {\r\n                    uint sendMoney = tokensHeld.mul(perTokenPayout);\r\n                    sendMoney = sendMoney.div(10**decimals);\r\n                    uint takeBackTokens = tokenToTakeBack.mul(tokensHeld);\r\n                    takeBackTokens = takeBackTokens.div(10**decimals);\r\n                    (exchangeAmount,customerAmt) = getExchangeAndEthStoreAmount(sendMoney); \r\n                    exchange.transfer(exchangeAmount);\r\n                    listAddr[i].transfer(customerAmt);\r\n                    amountLeftToBePaid[listAddr[i]] = amountLeftToBePaid[listAddr[i]].sub(sendMoney);\r\n                    tokenBalances[listAddr[i]] = tokenBalances[listAddr[i]].sub(takeBackTokens);\r\n                    tokenBalances[owner] = tokenBalances[owner].add(takeBackTokens);\r\n                    Transfer(listAddr[i],owner, takeBackTokens); \r\n                }\r\n            }\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint exchangeAmount"
        VariableDeclaration "exchangeAmount"
           Type: uint256
           Source: "uint exchangeAmount"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint customerAmt"
        VariableDeclaration "customerAmt"
           Type: uint256
           Source: "uint customerAmt"
          ElementaryTypeName uint
             Source: "uint"
      ForStatement
         Source: "for (uint i=0;i<listAddr.length;i++)\r\n        {\r\n            uint payAmt = amountLeftToBePaid[listAddr[i]];\r\n            if (payAmt >0)\r\n            {\r\n                uint tokensHeld = payAmt.mul(10**18);\r\n                tokensHeld = tokensHeld.div(sellPrice); // shouldnt this be buyprice?\r\n                \r\n                if (tokensHeld >0)\r\n                {\r\n                    uint sendMoney = tokensHeld.mul(perTokenPayout);\r\n                    sendMoney = sendMoney.div(10**decimals);\r\n                    uint takeBackTokens = tokenToTakeBack.mul(tokensHeld);\r\n                    takeBackTokens = takeBackTokens.div(10**decimals);\r\n                    (exchangeAmount,customerAmt) = getExchangeAndEthStoreAmount(sendMoney); \r\n                    exchange.transfer(exchangeAmount);\r\n                    listAddr[i].transfer(customerAmt);\r\n                    amountLeftToBePaid[listAddr[i]] = amountLeftToBePaid[listAddr[i]].sub(sendMoney);\r\n                    tokenBalances[listAddr[i]] = tokenBalances[listAddr[i]].sub(takeBackTokens);\r\n                    tokenBalances[owner] = tokenBalances[owner].add(takeBackTokens);\r\n                    Transfer(listAddr[i],owner, takeBackTokens); \r\n                }\r\n            }\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 217
           Source: "i<listAddr.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "listAddr.length"
            Identifier listAddr
               Type: address[] storage ref
               Source: "listAddr"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            uint payAmt = amountLeftToBePaid[listAddr[i]];\r\n            if (payAmt >0)\r\n            {\r\n                uint tokensHeld = payAmt.mul(10**18);\r\n                tokensHeld = tokensHeld.div(sellPrice); // shouldnt this be buyprice?\r\n                \r\n                if (tokensHeld >0)\r\n                {\r\n                    uint sendMoney = tokensHeld.mul(perTokenPayout);\r\n                    sendMoney = sendMoney.div(10**decimals);\r\n                    uint takeBackTokens = tokenToTakeBack.mul(tokensHeld);\r\n                    takeBackTokens = takeBackTokens.div(10**decimals);\r\n                    (exchangeAmount,customerAmt) = getExchangeAndEthStoreAmount(sendMoney); \r\n                    exchange.transfer(exchangeAmount);\r\n                    listAddr[i].transfer(customerAmt);\r\n                    amountLeftToBePaid[listAddr[i]] = amountLeftToBePaid[listAddr[i]].sub(sendMoney);\r\n                    tokenBalances[listAddr[i]] = tokenBalances[listAddr[i]].sub(takeBackTokens);\r\n                    tokenBalances[owner] = tokenBalances[owner].add(takeBackTokens);\r\n                    Transfer(listAddr[i],owner, takeBackTokens); \r\n                }\r\n            }\r\n        }"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "uint payAmt = amountLeftToBePaid[listAddr[i]]"
            VariableDeclaration "payAmt"
               Type: uint256
               Source: "uint payAmt"
              ElementaryTypeName uint
                 Source: "uint"
            IndexAccess
               Type: uint256
               Source: "amountLeftToBePaid[listAddr[i]]"
              Identifier amountLeftToBePaid
                 Type: mapping(address => uint256)
                 Source: "amountLeftToBePaid"
              IndexAccess
                 Type: address
                 Source: "listAddr[i]"
                Identifier listAddr
                   Type: address[] storage ref
                   Source: "listAddr"
                Identifier i
                   Type: uint256
                   Source: "i"
          IfStatement
             Source: "if (payAmt >0)\r\n            {\r\n                uint tokensHeld = payAmt.mul(10**18);\r\n                tokensHeld = tokensHeld.div(sellPrice); // shouldnt this be buyprice?\r\n                \r\n                if (tokensHeld >0)\r\n                {\r\n                    uint sendMoney = tokensHeld.mul(perTokenPayout);\r\n                    sendMoney = sendMoney.div(10**decimals);\r\n                    uint takeBackTokens = tokenToTakeBack.mul(tokensHeld);\r\n                    takeBackTokens = takeBackTokens.div(10**decimals);\r\n                    (exchangeAmount,customerAmt) = getExchangeAndEthStoreAmount(sendMoney); \r\n                    exchange.transfer(exchangeAmount);\r\n                    listAddr[i].transfer(customerAmt);\r\n                    amountLeftToBePaid[listAddr[i]] = amountLeftToBePaid[listAddr[i]].sub(sendMoney);\r\n                    tokenBalances[listAddr[i]] = tokenBalances[listAddr[i]].sub(takeBackTokens);\r\n                    tokenBalances[owner] = tokenBalances[owner].add(takeBackTokens);\r\n                    Transfer(listAddr[i],owner, takeBackTokens); \r\n                }\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 9
               Source: "payAmt >0"
              Identifier payAmt
                 Type: uint256
                 Source: "payAmt"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{\r\n                uint tokensHeld = payAmt.mul(10**18);\r\n                tokensHeld = tokensHeld.div(sellPrice); // shouldnt this be buyprice?\r\n                \r\n                if (tokensHeld >0)\r\n                {\r\n                    uint sendMoney = tokensHeld.mul(perTokenPayout);\r\n                    sendMoney = sendMoney.div(10**decimals);\r\n                    uint takeBackTokens = tokenToTakeBack.mul(tokensHeld);\r\n                    takeBackTokens = takeBackTokens.div(10**decimals);\r\n                    (exchangeAmount,customerAmt) = getExchangeAndEthStoreAmount(sendMoney); \r\n                    exchange.transfer(exchangeAmount);\r\n                    listAddr[i].transfer(customerAmt);\r\n                    amountLeftToBePaid[listAddr[i]] = amountLeftToBePaid[listAddr[i]].sub(sendMoney);\r\n                    tokenBalances[listAddr[i]] = tokenBalances[listAddr[i]].sub(takeBackTokens);\r\n                    tokenBalances[owner] = tokenBalances[owner].add(takeBackTokens);\r\n                    Transfer(listAddr[i],owner, takeBackTokens); \r\n                }\r\n            }"
              VariableDeclarationStatement
                 Gas costs: 44
                 Source: "uint tokensHeld = payAmt.mul(10**18)"
                VariableDeclaration "tokensHeld"
                   Type: uint256
                   Source: "uint tokensHeld"
                  ElementaryTypeName uint
                     Source: "uint"
                FunctionCall
                   Type: uint256
                   Source: "payAmt.mul(10**18)"
                  MemberAccess to member mul
                     Type: function (uint256,uint256) pure returns (uint256)
                     Source: "payAmt.mul"
                    Identifier payAmt
                       Type: uint256
                       Source: "payAmt"
                  BinaryOperation using operator **
                     Type: int_const 1000000000000000000
                     Source: "10**18"
                    Literal, token: [no token] value: 10
                       Type: int_const 10
                       Source: "10"
                    Literal, token: [no token] value: 18
                       Type: int_const 18
                       Source: "18"
              ExpressionStatement
                 Gas costs: 241
                 Source: "tokensHeld = tokensHeld.div(sellPrice)"
                Assignment using operator =
                   Type: uint256
                   Source: "tokensHeld = tokensHeld.div(sellPrice)"
                  Identifier tokensHeld
                     Type: uint256
                     Source: "tokensHeld"
                  FunctionCall
                     Type: uint256
                     Source: "tokensHeld.div(sellPrice)"
                    MemberAccess to member div
                       Type: function (uint256,uint256) pure returns (uint256)
                       Source: "tokensHeld.div"
                      Identifier tokensHeld
                         Type: uint256
                         Source: "tokensHeld"
                    Identifier sellPrice
                       Type: uint256
                       Source: "sellPrice"
              IfStatement
                 Source: "if (tokensHeld >0)\r\n                {\r\n                    uint sendMoney = tokensHeld.mul(perTokenPayout);\r\n                    sendMoney = sendMoney.div(10**decimals);\r\n                    uint takeBackTokens = tokenToTakeBack.mul(tokensHeld);\r\n                    takeBackTokens = takeBackTokens.div(10**decimals);\r\n                    (exchangeAmount,customerAmt) = getExchangeAndEthStoreAmount(sendMoney); \r\n                    exchange.transfer(exchangeAmount);\r\n                    listAddr[i].transfer(customerAmt);\r\n                    amountLeftToBePaid[listAddr[i]] = amountLeftToBePaid[listAddr[i]].sub(sendMoney);\r\n                    tokenBalances[listAddr[i]] = tokenBalances[listAddr[i]].sub(takeBackTokens);\r\n                    tokenBalances[owner] = tokenBalances[owner].add(takeBackTokens);\r\n                    Transfer(listAddr[i],owner, takeBackTokens); \r\n                }"
                BinaryOperation using operator >
                   Type: bool
                   Gas costs: 9
                   Source: "tokensHeld >0"
                  Identifier tokensHeld
                     Type: uint256
                     Source: "tokensHeld"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                Block
                   Source: "{\r\n                    uint sendMoney = tokensHeld.mul(perTokenPayout);\r\n                    sendMoney = sendMoney.div(10**decimals);\r\n                    uint takeBackTokens = tokenToTakeBack.mul(tokensHeld);\r\n                    takeBackTokens = takeBackTokens.div(10**decimals);\r\n                    (exchangeAmount,customerAmt) = getExchangeAndEthStoreAmount(sendMoney); \r\n                    exchange.transfer(exchangeAmount);\r\n                    listAddr[i].transfer(customerAmt);\r\n                    amountLeftToBePaid[listAddr[i]] = amountLeftToBePaid[listAddr[i]].sub(sendMoney);\r\n                    tokenBalances[listAddr[i]] = tokenBalances[listAddr[i]].sub(takeBackTokens);\r\n                    tokenBalances[owner] = tokenBalances[owner].add(takeBackTokens);\r\n                    Transfer(listAddr[i],owner, takeBackTokens); \r\n                }"
                  VariableDeclarationStatement
                     Gas costs: 244
                     Source: "uint sendMoney = tokensHeld.mul(perTokenPayout)"
                    VariableDeclaration "sendMoney"
                       Type: uint256
                       Source: "uint sendMoney"
                      ElementaryTypeName uint
                         Source: "uint"
                    FunctionCall
                       Type: uint256
                       Source: "tokensHeld.mul(perTokenPayout)"
                      MemberAccess to member mul
                         Type: function (uint256,uint256) pure returns (uint256)
                         Source: "tokensHeld.mul"
                        Identifier tokensHeld
                           Type: uint256
                           Source: "tokensHeld"
                      Identifier perTokenPayout
                         Type: uint256
                         Source: "perTokenPayout"
                  ExpressionStatement
                     Gas costs: 101
                     Source: "sendMoney = sendMoney.div(10**decimals)"
                    Assignment using operator =
                       Type: uint256
                       Source: "sendMoney = sendMoney.div(10**decimals)"
                      Identifier sendMoney
                         Type: uint256
                         Source: "sendMoney"
                      FunctionCall
                         Type: uint256
                         Source: "sendMoney.div(10**decimals)"
                        MemberAccess to member div
                           Type: function (uint256,uint256) pure returns (uint256)
                           Source: "sendMoney.div"
                          Identifier sendMoney
                             Type: uint256
                             Source: "sendMoney"
                        BinaryOperation using operator **
                           Type: uint256
                           Source: "10**decimals"
                          Literal, token: [no token] value: 10
                             Type: int_const 10
                             Source: "10"
                          Identifier decimals
                             Type: uint256
                             Source: "decimals"
                  VariableDeclarationStatement
                     Gas costs: 244
                     Source: "uint takeBackTokens = tokenToTakeBack.mul(tokensHeld)"
                    VariableDeclaration "takeBackTokens"
                       Type: uint256
                       Source: "uint takeBackTokens"
                      ElementaryTypeName uint
                         Source: "uint"
                    FunctionCall
                       Type: uint256
                       Source: "tokenToTakeBack.mul(tokensHeld)"
                      MemberAccess to member mul
                         Type: function (uint256,uint256) pure returns (uint256)
                         Source: "tokenToTakeBack.mul"
                        Identifier tokenToTakeBack
                           Type: uint256
                           Source: "tokenToTakeBack"
                      Identifier tokensHeld
                         Type: uint256
                         Source: "tokensHeld"
                  ExpressionStatement
                     Gas costs: 101
                     Source: "takeBackTokens = takeBackTokens.div(10**decimals)"
                    Assignment using operator =
                       Type: uint256
                       Source: "takeBackTokens = takeBackTokens.div(10**decimals)"
                      Identifier takeBackTokens
                         Type: uint256
                         Source: "takeBackTokens"
                      FunctionCall
                         Type: uint256
                         Source: "takeBackTokens.div(10**decimals)"
                        MemberAccess to member div
                           Type: function (uint256,uint256) pure returns (uint256)
                           Source: "takeBackTokens.div"
                          Identifier takeBackTokens
                             Type: uint256
                             Source: "takeBackTokens"
                        BinaryOperation using operator **
                           Type: uint256
                           Source: "10**decimals"
                          Literal, token: [no token] value: 10
                             Type: int_const 10
                             Source: "10"
                          Identifier decimals
                             Type: uint256
                             Source: "decimals"
                  ExpressionStatement
                     Gas costs: 38
                     Source: "(exchangeAmount,customerAmt) = getExchangeAndEthStoreAmount(sendMoney)"
                    Assignment using operator =
                       Type: tuple()
                       Source: "(exchangeAmount,customerAmt) = getExchangeAndEthStoreAmount(sendMoney)"
                      TupleExpression
                         Type: tuple(uint256,uint256)
                         Source: "(exchangeAmount,customerAmt)"
                        Identifier exchangeAmount
                           Type: uint256
                           Source: "exchangeAmount"
                        Identifier customerAmt
                           Type: uint256
                           Source: "customerAmt"
                      FunctionCall
                         Type: tuple(uint256,uint256)
                         Source: "getExchangeAndEthStoreAmount(sendMoney)"
                        Identifier getExchangeAndEthStoreAmount
                           Type: function (uint256) pure returns (uint256,uint256)
                           Source: "getExchangeAndEthStoreAmount"
                        Identifier sendMoney
                           Type: uint256
                           Source: "sendMoney"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "exchange.transfer(exchangeAmount)"
                    FunctionCall
                       Type: tuple()
                       Source: "exchange.transfer(exchangeAmount)"
                      MemberAccess to member transfer
                         Type: function (uint256)
                         Source: "exchange.transfer"
                        Identifier exchange
                           Type: address
                           Source: "exchange"
                      Identifier exchangeAmount
                         Type: uint256
                         Source: "exchangeAmount"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "listAddr[i].transfer(customerAmt)"
                    FunctionCall
                       Type: tuple()
                       Source: "listAddr[i].transfer(customerAmt)"
                      MemberAccess to member transfer
                         Type: function (uint256)
                         Source: "listAddr[i].transfer"
                        IndexAccess
                           Type: address
                           Source: "listAddr[i]"
                          Identifier listAddr
                             Type: address[] storage ref
                             Source: "listAddr"
                          Identifier i
                             Type: uint256
                             Source: "i"
                      Identifier customerAmt
                         Type: uint256
                         Source: "customerAmt"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "amountLeftToBePaid[listAddr[i]] = amountLeftToBePaid[listAddr[i]].sub(sendMoney)"
                    Assignment using operator =
                       Type: uint256
                       Source: "amountLeftToBePaid[listAddr[i]] = amountLeftToBePaid[listAddr[i]].sub(sendMoney)"
                      IndexAccess
                         Type: uint256
                         Source: "amountLeftToBePaid[listAddr[i]]"
                        Identifier amountLeftToBePaid
                           Type: mapping(address => uint256)
                           Source: "amountLeftToBePaid"
                        IndexAccess
                           Type: address
                           Source: "listAddr[i]"
                          Identifier listAddr
                             Type: address[] storage ref
                             Source: "listAddr"
                          Identifier i
                             Type: uint256
                             Source: "i"
                      FunctionCall
                         Type: uint256
                         Source: "amountLeftToBePaid[listAddr[i]].sub(sendMoney)"
                        MemberAccess to member sub
                           Type: function (uint256,uint256) pure returns (uint256)
                           Source: "amountLeftToBePaid[listAddr[i]].sub"
                          IndexAccess
                             Type: uint256
                             Source: "amountLeftToBePaid[listAddr[i]]"
                            Identifier amountLeftToBePaid
                               Type: mapping(address => uint256)
                               Source: "amountLeftToBePaid"
                            IndexAccess
                               Type: address
                               Source: "listAddr[i]"
                              Identifier listAddr
                                 Type: address[] storage ref
                                 Source: "listAddr"
                              Identifier i
                                 Type: uint256
                                 Source: "i"
                        Identifier sendMoney
                           Type: uint256
                           Source: "sendMoney"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "tokenBalances[listAddr[i]] = tokenBalances[listAddr[i]].sub(takeBackTokens)"
                    Assignment using operator =
                       Type: uint256
                       Source: "tokenBalances[listAddr[i]] = tokenBalances[listAddr[i]].sub(takeBackTokens)"
                      IndexAccess
                         Type: uint256
                         Source: "tokenBalances[listAddr[i]]"
                        Identifier tokenBalances
                           Type: mapping(address => uint256)
                           Source: "tokenBalances"
                        IndexAccess
                           Type: address
                           Source: "listAddr[i]"
                          Identifier listAddr
                             Type: address[] storage ref
                             Source: "listAddr"
                          Identifier i
                             Type: uint256
                             Source: "i"
                      FunctionCall
                         Type: uint256
                         Source: "tokenBalances[listAddr[i]].sub(takeBackTokens)"
                        MemberAccess to member sub
                           Type: function (uint256,uint256) pure returns (uint256)
                           Source: "tokenBalances[listAddr[i]].sub"
                          IndexAccess
                             Type: uint256
                             Source: "tokenBalances[listAddr[i]]"
                            Identifier tokenBalances
                               Type: mapping(address => uint256)
                               Source: "tokenBalances"
                            IndexAccess
                               Type: address
                               Source: "listAddr[i]"
                              Identifier listAddr
                                 Type: address[] storage ref
                                 Source: "listAddr"
                              Identifier i
                                 Type: uint256
                                 Source: "i"
                        Identifier takeBackTokens
                           Type: uint256
                           Source: "takeBackTokens"
                  ExpressionStatement
                     Gas costs: 20908
                     Source: "tokenBalances[owner] = tokenBalances[owner].add(takeBackTokens)"
                    Assignment using operator =
                       Type: uint256
                       Source: "tokenBalances[owner] = tokenBalances[owner].add(takeBackTokens)"
                      IndexAccess
                         Type: uint256
                         Source: "tokenBalances[owner]"
                        Identifier tokenBalances
                           Type: mapping(address => uint256)
                           Source: "tokenBalances"
                        Identifier owner
                           Type: address
                           Source: "owner"
                      FunctionCall
                         Type: uint256
                         Source: "tokenBalances[owner].add(takeBackTokens)"
                        MemberAccess to member add
                           Type: function (uint256,uint256) pure returns (uint256)
                           Source: "tokenBalances[owner].add"
                          IndexAccess
                             Type: uint256
                             Source: "tokenBalances[owner]"
                            Identifier tokenBalances
                               Type: mapping(address => uint256)
                               Source: "tokenBalances"
                            Identifier owner
                               Type: address
                               Source: "owner"
                        Identifier takeBackTokens
                           Type: uint256
                           Source: "takeBackTokens"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "Transfer(listAddr[i],owner, takeBackTokens)"
                    FunctionCall
                       Type: tuple()
                       Source: "Transfer(listAddr[i],owner, takeBackTokens)"
                      Identifier Transfer
                         Type: function (address,address,uint256)
                         Source: "Transfer"
                      IndexAccess
                         Type: address
                         Source: "listAddr[i]"
                        Identifier listAddr
                           Type: address[] storage ref
                           Source: "listAddr"
                        Identifier i
                           Type: uint256
                           Source: "i"
                      Identifier owner
                         Type: address
                         Source: "owner"
                      Identifier takeBackTokens
                         Type: uint256
                         Source: "takeBackTokens"
  FunctionDefinition "buy" - public
     Source: "function buy(address beneficiary) payable public returns (uint amount) {\r\n        require (msg.value.div(buyPrice) >= 1);   \r\n        uint exchangeAmount;\r\n        uint ethStoreAmt;\r\n        (exchangeAmount,ethStoreAmt) = getExchangeAndEthStoreAmount(msg.value); \r\n        ethStore.transfer(ethStoreAmt);    \r\n        exchange.transfer(exchangeAmount);\r\n        //uint tempBuyPrice = buyPrice.mul(10**decimals);\r\n        amount = msg.value.div(buyPrice);                    // calculates the amount\r\n        amount = amount.mul(10**decimals);\r\n        require(tokenBalances[owner] >= amount);               // checks if it has enough to sell\r\n        tokenBalances[beneficiary] = tokenBalances[beneficiary].add(amount);                  // adds the amount to buyer's balance\r\n        tokenBalances[owner] = tokenBalances[owner].sub(amount);                        // subtracts amount from seller's balance\r\n        \r\n        uint earlierBalance =  amountLeftToBePaid[beneficiary];\r\n        uint amountToBePaid = amount.mul(sellPrice);\r\n        amountToBePaid = amountToBePaid.div(10**18);\r\n        amountLeftToBePaid[beneficiary] = amountToBePaid.add(earlierBalance);   //input how much has to be paid out to the customer later on\r\n        Transfer(owner, beneficiary, amount);\r\n        if (earlierBalance == 0) \r\n            listAddr.push(beneficiary);\r\n        return amount;                                    // ends function and returns\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address beneficiary)"
      VariableDeclaration "beneficiary"
         Type: address
         Source: "address beneficiary"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require (msg.value.div(buyPrice) >= 1);   \r\n        uint exchangeAmount;\r\n        uint ethStoreAmt;\r\n        (exchangeAmount,ethStoreAmt) = getExchangeAndEthStoreAmount(msg.value); \r\n        ethStore.transfer(ethStoreAmt);    \r\n        exchange.transfer(exchangeAmount);\r\n        //uint tempBuyPrice = buyPrice.mul(10**decimals);\r\n        amount = msg.value.div(buyPrice);                    // calculates the amount\r\n        amount = amount.mul(10**decimals);\r\n        require(tokenBalances[owner] >= amount);               // checks if it has enough to sell\r\n        tokenBalances[beneficiary] = tokenBalances[beneficiary].add(amount);                  // adds the amount to buyer's balance\r\n        tokenBalances[owner] = tokenBalances[owner].sub(amount);                        // subtracts amount from seller's balance\r\n        \r\n        uint earlierBalance =  amountLeftToBePaid[beneficiary];\r\n        uint amountToBePaid = amount.mul(sellPrice);\r\n        amountToBePaid = amountToBePaid.div(10**18);\r\n        amountLeftToBePaid[beneficiary] = amountToBePaid.add(earlierBalance);   //input how much has to be paid out to the customer later on\r\n        Transfer(owner, beneficiary, amount);\r\n        if (earlierBalance == 0) \r\n            listAddr.push(beneficiary);\r\n        return amount;                                    // ends function and returns\r\n    }"
      ExpressionStatement
         Gas costs: 270
         Source: "require (msg.value.div(buyPrice) >= 1)"
        FunctionCall
           Type: tuple()
           Source: "require (msg.value.div(buyPrice) >= 1)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.value.div(buyPrice) >= 1"
            FunctionCall
               Type: uint256
               Source: "msg.value.div(buyPrice)"
              MemberAccess to member div
                 Type: function (uint256,uint256) pure returns (uint256)
                 Source: "msg.value.div"
                MemberAccess to member value
                   Type: uint256
                   Source: "msg.value"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier buyPrice
                 Type: uint256
                 Source: "buyPrice"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint exchangeAmount"
        VariableDeclaration "exchangeAmount"
           Type: uint256
           Source: "uint exchangeAmount"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint ethStoreAmt"
        VariableDeclaration "ethStoreAmt"
           Type: uint256
           Source: "uint ethStoreAmt"
          ElementaryTypeName uint
             Source: "uint"
      ExpressionStatement
         Gas costs: 26
         Source: "(exchangeAmount,ethStoreAmt) = getExchangeAndEthStoreAmount(msg.value)"
        Assignment using operator =
           Type: tuple()
           Source: "(exchangeAmount,ethStoreAmt) = getExchangeAndEthStoreAmount(msg.value)"
          TupleExpression
             Type: tuple(uint256,uint256)
             Source: "(exchangeAmount,ethStoreAmt)"
            Identifier exchangeAmount
               Type: uint256
               Source: "exchangeAmount"
            Identifier ethStoreAmt
               Type: uint256
               Source: "ethStoreAmt"
          FunctionCall
             Type: tuple(uint256,uint256)
             Source: "getExchangeAndEthStoreAmount(msg.value)"
            Identifier getExchangeAndEthStoreAmount
               Type: function (uint256) pure returns (uint256,uint256)
               Source: "getExchangeAndEthStoreAmount"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: [???]
         Source: "ethStore.transfer(ethStoreAmt)"
        FunctionCall
           Type: tuple()
           Source: "ethStore.transfer(ethStoreAmt)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "ethStore.transfer"
            Identifier ethStore
               Type: address
               Source: "ethStore"
          Identifier ethStoreAmt
             Type: uint256
             Source: "ethStoreAmt"
      ExpressionStatement
         Gas costs: [???]
         Source: "exchange.transfer(exchangeAmount)"
        FunctionCall
           Type: tuple()
           Source: "exchange.transfer(exchangeAmount)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "exchange.transfer"
            Identifier exchange
               Type: address
               Source: "exchange"
          Identifier exchangeAmount
             Type: uint256
             Source: "exchangeAmount"
      ExpressionStatement
         Gas costs: 240
         Source: "amount = msg.value.div(buyPrice)"
        Assignment using operator =
           Type: uint256
           Source: "amount = msg.value.div(buyPrice)"
          Identifier amount
             Type: uint256
             Source: "amount"
          FunctionCall
             Type: uint256
             Source: "msg.value.div(buyPrice)"
            MemberAccess to member div
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "msg.value.div"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier buyPrice
               Type: uint256
               Source: "buyPrice"
      ExpressionStatement
         Gas costs: 101
         Source: "amount = amount.mul(10**decimals)"
        Assignment using operator =
           Type: uint256
           Source: "amount = amount.mul(10**decimals)"
          Identifier amount
             Type: uint256
             Source: "amount"
          FunctionCall
             Type: uint256
             Source: "amount.mul(10**decimals)"
            MemberAccess to member mul
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "amount.mul"
              Identifier amount
                 Type: uint256
                 Source: "amount"
            BinaryOperation using operator **
               Type: uint256
               Source: "10**decimals"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Identifier decimals
                 Type: uint256
                 Source: "decimals"
      ExpressionStatement
         Gas costs: 570
         Source: "require(tokenBalances[owner] >= amount)"
        FunctionCall
           Type: tuple()
           Source: "require(tokenBalances[owner] >= amount)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "tokenBalances[owner] >= amount"
            IndexAccess
               Type: uint256
               Source: "tokenBalances[owner]"
              Identifier tokenBalances
                 Type: mapping(address => uint256)
                 Source: "tokenBalances"
              Identifier owner
                 Type: address
                 Source: "owner"
            Identifier amount
               Type: uint256
               Source: "amount"
      ExpressionStatement
         Gas costs: 20439
         Source: "tokenBalances[beneficiary] = tokenBalances[beneficiary].add(amount)"
        Assignment using operator =
           Type: uint256
           Source: "tokenBalances[beneficiary] = tokenBalances[beneficiary].add(amount)"
          IndexAccess
             Type: uint256
             Source: "tokenBalances[beneficiary]"
            Identifier tokenBalances
               Type: mapping(address => uint256)
               Source: "tokenBalances"
            Identifier beneficiary
               Type: address
               Source: "beneficiary"
          FunctionCall
             Type: uint256
             Source: "tokenBalances[beneficiary].add(amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "tokenBalances[beneficiary].add"
              IndexAccess
                 Type: uint256
                 Source: "tokenBalances[beneficiary]"
                Identifier tokenBalances
                   Type: mapping(address => uint256)
                   Source: "tokenBalances"
                Identifier beneficiary
                   Type: address
                   Source: "beneficiary"
            Identifier amount
               Type: uint256
               Source: "amount"
      ExpressionStatement
         Gas costs: 20905
         Source: "tokenBalances[owner] = tokenBalances[owner].sub(amount)"
        Assignment using operator =
           Type: uint256
           Source: "tokenBalances[owner] = tokenBalances[owner].sub(amount)"
          IndexAccess
             Type: uint256
             Source: "tokenBalances[owner]"
            Identifier tokenBalances
               Type: mapping(address => uint256)
               Source: "tokenBalances"
            Identifier owner
               Type: address
               Source: "owner"
          FunctionCall
             Type: uint256
             Source: "tokenBalances[owner].sub(amount)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "tokenBalances[owner].sub"
              IndexAccess
                 Type: uint256
                 Source: "tokenBalances[owner]"
                Identifier tokenBalances
                   Type: mapping(address => uint256)
                   Source: "tokenBalances"
                Identifier owner
                   Type: address
                   Source: "owner"
            Identifier amount
               Type: uint256
               Source: "amount"
      VariableDeclarationStatement
         Gas costs: 301
         Source: "uint earlierBalance =  amountLeftToBePaid[beneficiary]"
        VariableDeclaration "earlierBalance"
           Type: uint256
           Source: "uint earlierBalance"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "amountLeftToBePaid[beneficiary]"
          Identifier amountLeftToBePaid
             Type: mapping(address => uint256)
             Source: "amountLeftToBePaid"
          Identifier beneficiary
             Type: address
             Source: "beneficiary"
      VariableDeclarationStatement
         Gas costs: 244
         Source: "uint amountToBePaid = amount.mul(sellPrice)"
        VariableDeclaration "amountToBePaid"
           Type: uint256
           Source: "uint amountToBePaid"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "amount.mul(sellPrice)"
          MemberAccess to member mul
             Type: function (uint256,uint256) pure returns (uint256)
             Source: "amount.mul"
            Identifier amount
               Type: uint256
               Source: "amount"
          Identifier sellPrice
             Type: uint256
             Source: "sellPrice"
      ExpressionStatement
         Gas costs: 41
         Source: "amountToBePaid = amountToBePaid.div(10**18)"
        Assignment using operator =
           Type: uint256
           Source: "amountToBePaid = amountToBePaid.div(10**18)"
          Identifier amountToBePaid
             Type: uint256
             Source: "amountToBePaid"
          FunctionCall
             Type: uint256
             Source: "amountToBePaid.div(10**18)"
            MemberAccess to member div
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "amountToBePaid.div"
              Identifier amountToBePaid
                 Type: uint256
                 Source: "amountToBePaid"
            BinaryOperation using operator **
               Type: int_const 1000000000000000000
               Source: "10**18"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
              Literal, token: [no token] value: 18
                 Type: int_const 18
                 Source: "18"
      ExpressionStatement
         Gas costs: 20143
         Source: "amountLeftToBePaid[beneficiary] = amountToBePaid.add(earlierBalance)"
        Assignment using operator =
           Type: uint256
           Source: "amountLeftToBePaid[beneficiary] = amountToBePaid.add(earlierBalance)"
          IndexAccess
             Type: uint256
             Source: "amountLeftToBePaid[beneficiary]"
            Identifier amountLeftToBePaid
               Type: mapping(address => uint256)
               Source: "amountLeftToBePaid"
            Identifier beneficiary
               Type: address
               Source: "beneficiary"
          FunctionCall
             Type: uint256
             Source: "amountToBePaid.add(earlierBalance)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "amountToBePaid.add"
              Identifier amountToBePaid
                 Type: uint256
                 Source: "amountToBePaid"
            Identifier earlierBalance
               Type: uint256
               Source: "earlierBalance"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(owner, beneficiary, amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(owner, beneficiary, amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier beneficiary
             Type: address
             Source: "beneficiary"
          Identifier amount
             Type: uint256
             Source: "amount"
      IfStatement
         Source: "if (earlierBalance == 0) \r\n            listAddr.push(beneficiary)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "earlierBalance == 0"
          Identifier earlierBalance
             Type: uint256
             Source: "earlierBalance"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 20365
           Source: "listAddr.push(beneficiary)"
          FunctionCall
             Type: uint256
             Source: "listAddr.push(beneficiary)"
            MemberAccess to member push
               Type: function (address) returns (uint256)
               Source: "listAddr.push"
              Identifier listAddr
                 Type: address[] storage ref
                 Source: "listAddr"
            Identifier beneficiary
               Type: address
               Source: "beneficiary"
      Return
         Gas costs: 8
         Source: "return amount"
        Identifier amount
           Type: uint256
           Source: "amount"
  FunctionDefinition "getExchangeAndEthStoreAmount"
     Source: "function getExchangeAndEthStoreAmount(uint value) internal pure returns (uint exchangeAmt, uint ethStoreAmt) {\r\n       exchangeAmt = value.div(100);    //since 1% means divide by 100\r\n       ethStoreAmt = value - exchangeAmt;   //the rest would be eth store amount\r\n   }"
    ParameterList
       Gas costs: 0
       Source: "(uint value)"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 6
       Source: "(uint exchangeAmt, uint ethStoreAmt)"
      VariableDeclaration "exchangeAmt"
         Type: uint256
         Source: "uint exchangeAmt"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "ethStoreAmt"
         Type: uint256
         Source: "uint ethStoreAmt"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n       exchangeAmt = value.div(100);    //since 1% means divide by 100\r\n       ethStoreAmt = value - exchangeAmt;   //the rest would be eth store amount\r\n   }"
      ExpressionStatement
         Gas costs: 41
         Source: "exchangeAmt = value.div(100)"
        Assignment using operator =
           Type: uint256
           Source: "exchangeAmt = value.div(100)"
          Identifier exchangeAmt
             Type: uint256
             Source: "exchangeAmt"
          FunctionCall
             Type: uint256
             Source: "value.div(100)"
            MemberAccess to member div
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "value.div"
              Identifier value
                 Type: uint256
                 Source: "value"
            Literal, token: [no token] value: 100
               Type: int_const 100
               Source: "100"
      ExpressionStatement
         Gas costs: 14
         Source: "ethStoreAmt = value - exchangeAmt"
        Assignment using operator =
           Type: uint256
           Source: "ethStoreAmt = value - exchangeAmt"
          Identifier ethStoreAmt
             Type: uint256
             Source: "ethStoreAmt"
          BinaryOperation using operator -
             Type: uint256
             Source: "value - exchangeAmt"
            Identifier value
               Type: uint256
               Source: "value"
            Identifier exchangeAmt
               Type: uint256
               Source: "exchangeAmt"
