Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0x163c90d093109dccaa0efb55410b105eeb9fa02d.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.13;"
ContractDefinition "AbstractENS"
   Gas costs: 0
   Source: "contract AbstractENS{\r\n    function owner(bytes32 node) constant returns(address);\r\n    function setOwner(bytes32 node, address owner);\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner);\r\n}"
  FunctionDefinition "owner" - public - const
     Source: "function owner(bytes32 node) constant returns(address);"
    ParameterList
       Source: "(bytes32 node)"
      VariableDeclaration "node"
         Type: bytes32
         Source: "bytes32 node"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "setOwner" - public
     Source: "function setOwner(bytes32 node, address owner);"
    ParameterList
       Source: "(bytes32 node, address owner)"
      VariableDeclaration "node"
         Type: bytes32
         Source: "bytes32 node"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: ""
  FunctionDefinition "setSubnodeOwner" - public
     Source: "function setSubnodeOwner(bytes32 node, bytes32 label, address owner);"
    ParameterList
       Source: "(bytes32 node, bytes32 label, address owner)"
      VariableDeclaration "node"
         Type: bytes32
         Source: "bytes32 node"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "label"
         Type: bytes32
         Source: "bytes32 label"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: ""
ContractDefinition "Registrar"
   Gas costs: 0
   Source: "contract Registrar {\r\n  function transfer(bytes32 _hash, address newOwner);\r\n  function entries(bytes32 _hash) constant returns (uint, Deed, uint, uint, uint);\r\n}"
  FunctionDefinition "transfer" - public
     Source: "function transfer(bytes32 _hash, address newOwner);"
    ParameterList
       Source: "(bytes32 _hash, address newOwner)"
      VariableDeclaration "_hash"
         Type: bytes32
         Source: "bytes32 _hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: ""
  FunctionDefinition "entries" - public - const
     Source: "function entries(bytes32 _hash) constant returns (uint, Deed, uint, uint, uint);"
    ParameterList
       Source: "(bytes32 _hash)"
      VariableDeclaration "_hash"
         Type: bytes32
         Source: "bytes32 _hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Source: "(uint, Deed, uint, uint, uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: contract Deed
         Source: "Deed"
        UserDefinedTypeName "Deed"
           Source: "Deed"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "Deed"
   Gas costs: 0
   Source: "contract Deed {\r\n  address public owner;\r\n  address public previousOwner;\r\n}"
  VariableDeclaration "owner"
     Type: address
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "previousOwner"
     Type: address
     Source: "address public previousOwner"
    ElementaryTypeName address
       Source: "address"
ContractDefinition "subdomainSale"
   Source: "contract subdomainSale{\r\n  AbstractENS ens = AbstractENS(0x314159265dD8dbb310642f98f50C066173C1259b);\r\n  Registrar registrar = Registrar(0x6090A6e47849629b7245Dfa1Ca21D94cd15878Ef);  \r\n  address admin = 0x8301Fb8945760Fa2B3C669e8F420B8795Dc03766;\r\n\r\n  struct Domain{\r\n    address originalOwner;\r\n    uint commitPeriod;\r\n    uint regPeriod;\r\n    bool subSale;\r\n    uint subPrice;\r\n    uint subExpiry;\r\n  }\r\n\r\n  mapping(bytes32=>Domain) records;\r\n\r\n  modifier deed_check(bytes32 label){\r\n     Deed deed;\r\n     (,deed,,,) = registrar.entries(label); \r\n     if(deed.owner() != address(this)) throw;\r\n     _;\r\n  }\r\n \r\n  modifier prevOwn_check(bytes32 label){\r\n    Deed deed;\r\n     (,deed,,,) = registrar.entries(label); \r\n     if(deed.previousOwner() != msg.sender) throw;\r\n     _;\r\n  }\r\n\r\n  modifier ens_check(bytes32 node){\r\n    if(ens.owner(node) != address(this)) throw;\r\n    _;\r\n  }\r\n\r\n\r\n  modifier recorded_owner(bytes32 node){\r\n    if (records[node].originalOwner != msg.sender) throw;\r\n    _;\r\n  }\r\n\r\n  function subdomainSale() {}\r\n\r\n  function listSubName(bytes32 label,bytes32 node,uint commit, uint price,uint expiry) prevOwn_check(label) deed_check(label) ens_check(node){\r\n    require(records[node].subSale == false); \r\n\r\n    records[node].originalOwner=msg.sender;\r\n    records[node].subSale=true;\r\n    records[node].subPrice=price;\r\n    records[node].subExpiry=expiry;\r\n    records[node].commitPeriod=now + commit + 86400;\r\n  }\r\n\r\n  function unlistSubName(bytes32 label,bytes32 node) recorded_owner(node) ens_check(node) deed_check(label){\r\n    require(records[node].subSale == true); \r\n    require(records[node].commitPeriod <= now);    \r\n\r\n    ens.setOwner(node,records[node].originalOwner);\r\n    registrar.transfer(label,records[node].originalOwner);\r\n\r\n    records[node].originalOwner=address(0x0);\r\n    records[node].subSale=false;\r\n    records[node].subPrice = 0;\r\n    records[node].subExpiry = 0;\r\n    records[node].commitPeriod=0;\r\n  }\r\n\r\n  function nodeCheck(bytes32 node) returns(address){\r\n    return ens.owner(node);\r\n  }\r\n\r\n  function subRegistrationPeriod(bytes32 node) returns(uint){\r\n    return records[node].subExpiry;\r\n  }\r\n\r\n  function checkSubAvailability(bytes32 node) returns(bool){\r\n    return records[node].subSale;\r\n  }\r\n\r\n  function checkSubPrice(bytes32 node) returns(uint){\r\n    return records[node].subPrice;\r\n  }\r\n\r\n  function checkCommitPeriod(bytes32 node) returns(uint){\r\n    return records[node].commitPeriod;\r\n  }\r\n\r\n  function checkRegPeriod(bytes32 node) returns(uint){\r\n    return records[node].regPeriod;\r\n  }\r\n\r\n  function subBuy(bytes32 ensName,bytes32 subNode,address newOwner) payable ens_check(ensName) {\r\n    require( (records[ensName].subExpiry + now + 5) < records[ensName].commitPeriod );\r\n    require(records[ensName].subSale == true);\r\n    require(msg.value >= records[ensName].subPrice);\r\n    \r\n    var newNode = sha3(ensName,subNode);\r\n    require(records[newNode].regPeriod < now);\r\n\r\n    uint fee = msg.value/20;\r\n    uint netPrice = msg.value - fee;\r\n\r\n    admin.transfer(fee);\r\n    records[ensName].originalOwner.transfer(netPrice);\r\n\r\n    records[newNode].regPeriod = now + records[ensName].subExpiry;\r\n    records[newNode].subSale = false;\r\n    records[newNode].subPrice = 0;\r\n    records[newNode].subExpiry = 0;\r\n    records[newNode].commitPeriod=0;\r\n\r\n    ens.setSubnodeOwner(ensName,subNode,newOwner);\r\n  }\r\n\r\n function() payable{\r\n    admin.transfer(msg.value);\r\n  }\r\n\r\n}"
  VariableDeclaration "ens"
     Type: contract AbstractENS
     Gas costs: 0
     Source: "AbstractENS ens = AbstractENS(0x314159265dD8dbb310642f98f50C066173C1259b)"
    UserDefinedTypeName "AbstractENS"
       Source: "AbstractENS"
    FunctionCall
       Type: contract AbstractENS
       Source: "AbstractENS(0x314159265dD8dbb310642f98f50C066173C1259b)"
      Identifier AbstractENS
         Type: type(contract AbstractENS)
         Source: "AbstractENS"
      Literal, token: [no token] value: 0x314159265dD8dbb310642f98f50C066173C1259b
         Type: address
         Source: "0x314159265dD8dbb310642f98f50C066173C1259b"
  VariableDeclaration "registrar"
     Type: contract Registrar
     Gas costs: 0
     Source: "Registrar registrar = Registrar(0x6090A6e47849629b7245Dfa1Ca21D94cd15878Ef)"
    UserDefinedTypeName "Registrar"
       Source: "Registrar"
    FunctionCall
       Type: contract Registrar
       Source: "Registrar(0x6090A6e47849629b7245Dfa1Ca21D94cd15878Ef)"
      Identifier Registrar
         Type: type(contract Registrar)
         Source: "Registrar"
      Literal, token: [no token] value: 0x6090A6e47849629b7245Dfa1Ca21D94cd15878Ef
         Type: address
         Source: "0x6090A6e47849629b7245Dfa1Ca21D94cd15878Ef"
  VariableDeclaration "admin"
     Type: address
     Gas costs: 0
     Source: "address admin = 0x8301Fb8945760Fa2B3C669e8F420B8795Dc03766"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x8301Fb8945760Fa2B3C669e8F420B8795Dc03766
       Type: address
       Source: "0x8301Fb8945760Fa2B3C669e8F420B8795Dc03766"
  StructDefinition "Domain"
     Gas costs: 0
     Source: "struct Domain{\r\n    address originalOwner;\r\n    uint commitPeriod;\r\n    uint regPeriod;\r\n    bool subSale;\r\n    uint subPrice;\r\n    uint subExpiry;\r\n  }"
    VariableDeclaration "originalOwner"
       Type: address
       Source: "address originalOwner"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "commitPeriod"
       Type: uint256
       Source: "uint commitPeriod"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "regPeriod"
       Type: uint256
       Source: "uint regPeriod"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "subSale"
       Type: bool
       Source: "bool subSale"
      ElementaryTypeName bool
         Source: "bool"
    VariableDeclaration "subPrice"
       Type: uint256
       Source: "uint subPrice"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "subExpiry"
       Type: uint256
       Source: "uint subExpiry"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "records"
     Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
     Gas costs: 0
     Source: "mapping(bytes32=>Domain) records"
    Mapping
       Source: "mapping(bytes32=>Domain)"
      ElementaryTypeName bytes32
         Source: "bytes32"
      UserDefinedTypeName "Domain"
         Source: "Domain"
  ModifierDefinition "deed_check"
     Source: "modifier deed_check(bytes32 label){\r\n     Deed deed;\r\n     (,deed,,,) = registrar.entries(label); \r\n     if(deed.owner() != address(this)) throw;\r\n     _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 label)"
      VariableDeclaration "label"
         Type: bytes32
         Source: "bytes32 label"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n     Deed deed;\r\n     (,deed,,,) = registrar.entries(label); \r\n     if(deed.owner() != address(this)) throw;\r\n     _;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 6
         Source: "Deed deed"
        VariableDeclaration "deed"
           Type: contract Deed
           Source: "Deed deed"
          UserDefinedTypeName "Deed"
             Source: "Deed"
      ExpressionStatement
         Gas costs: [???]
         Source: "(,deed,,,) = registrar.entries(label)"
        Assignment using operator =
           Type: tuple()
           Source: "(,deed,,,) = registrar.entries(label)"
          TupleExpression
             Type: tuple(,contract Deed,,,)
             Source: "(,deed,,,)"
            Identifier deed
               Type: contract Deed
               Source: "deed"
          FunctionCall
             Type: tuple(uint256,contract Deed,uint256,uint256,uint256)
             Source: "registrar.entries(label)"
            MemberAccess to member entries
               Type: function (bytes32) view external returns (uint256,contract Deed,uint256,uint256,uint256)
               Source: "registrar.entries"
              Identifier registrar
                 Type: contract Registrar
                 Source: "registrar"
            Identifier label
               Type: bytes32
               Source: "label"
      IfStatement
         Source: "if(deed.owner() != address(this)) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: [???]
           Source: "deed.owner() != address(this)"
          FunctionCall
             Type: address
             Source: "deed.owner()"
            MemberAccess to member owner
               Type: function () view external returns (address)
               Source: "deed.owner"
              Identifier deed
                 Type: contract Deed
                 Source: "deed"
          FunctionCall
             Type: address
             Source: "address(this)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier this
               Type: contract subdomainSale
               Source: "this"
        Throw
           Gas costs: 12
           Source: "throw"
      PlaceholderStatement
         Gas costs: 2
         Source: "_"
  ModifierDefinition "prevOwn_check"
     Source: "modifier prevOwn_check(bytes32 label){\r\n    Deed deed;\r\n     (,deed,,,) = registrar.entries(label); \r\n     if(deed.previousOwner() != msg.sender) throw;\r\n     _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 label)"
      VariableDeclaration "label"
         Type: bytes32
         Source: "bytes32 label"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n    Deed deed;\r\n     (,deed,,,) = registrar.entries(label); \r\n     if(deed.previousOwner() != msg.sender) throw;\r\n     _;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "Deed deed"
        VariableDeclaration "deed"
           Type: contract Deed
           Source: "Deed deed"
          UserDefinedTypeName "Deed"
             Source: "Deed"
      ExpressionStatement
         Gas costs: [???]
         Source: "(,deed,,,) = registrar.entries(label)"
        Assignment using operator =
           Type: tuple()
           Source: "(,deed,,,) = registrar.entries(label)"
          TupleExpression
             Type: tuple(,contract Deed,,,)
             Source: "(,deed,,,)"
            Identifier deed
               Type: contract Deed
               Source: "deed"
          FunctionCall
             Type: tuple(uint256,contract Deed,uint256,uint256,uint256)
             Source: "registrar.entries(label)"
            MemberAccess to member entries
               Type: function (bytes32) view external returns (uint256,contract Deed,uint256,uint256,uint256)
               Source: "registrar.entries"
              Identifier registrar
                 Type: contract Registrar
                 Source: "registrar"
            Identifier label
               Type: bytes32
               Source: "label"
      IfStatement
         Source: "if(deed.previousOwner() != msg.sender) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: [???]
           Source: "deed.previousOwner() != msg.sender"
          FunctionCall
             Type: address
             Source: "deed.previousOwner()"
            MemberAccess to member previousOwner
               Type: function () view external returns (address)
               Source: "deed.previousOwner"
              Identifier deed
                 Type: contract Deed
                 Source: "deed"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
        Throw
           Gas costs: 6
           Source: "throw"
      PlaceholderStatement
         Gas costs: 4
         Source: "_"
  ModifierDefinition "ens_check"
     Source: "modifier ens_check(bytes32 node){\r\n    if(ens.owner(node) != address(this)) throw;\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 node)"
      VariableDeclaration "node"
         Type: bytes32
         Source: "bytes32 node"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n    if(ens.owner(node) != address(this)) throw;\r\n    _;\r\n  }"
      IfStatement
         Source: "if(ens.owner(node) != address(this)) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: [???]
           Source: "ens.owner(node) != address(this)"
          FunctionCall
             Type: address
             Source: "ens.owner(node)"
            MemberAccess to member owner
               Type: function (bytes32) view external returns (address)
               Source: "ens.owner"
              Identifier ens
                 Type: contract AbstractENS
                 Source: "ens"
            Identifier node
               Type: bytes32
               Source: "node"
          FunctionCall
             Type: address
             Source: "address(this)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier this
               Type: contract subdomainSale
               Source: "this"
        Throw
           Gas costs: 18
           Source: "throw"
      PlaceholderStatement
         Gas costs: 4
         Source: "_"
  ModifierDefinition "recorded_owner"
     Source: "modifier recorded_owner(bytes32 node){\r\n    if (records[node].originalOwner != msg.sender) throw;\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 node)"
      VariableDeclaration "node"
         Type: bytes32
         Source: "bytes32 node"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\r\n    if (records[node].originalOwner != msg.sender) throw;\r\n    _;\r\n  }"
      IfStatement
         Source: "if (records[node].originalOwner != msg.sender) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 367
           Source: "records[node].originalOwner != msg.sender"
          MemberAccess to member originalOwner
             Type: address
             Source: "records[node].originalOwner"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[node]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier node
                 Type: bytes32
                 Source: "node"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
        Throw
           Gas costs: 6
           Source: "throw"
      PlaceholderStatement
         Gas costs: 2
         Source: "_"
  FunctionDefinition "subdomainSale" - public
     Source: "function subdomainSale() {}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "listSubName" - public
     Source: "function listSubName(bytes32 label,bytes32 node,uint commit, uint price,uint expiry) prevOwn_check(label) deed_check(label) ens_check(node){\r\n    require(records[node].subSale == false); \r\n\r\n    records[node].originalOwner=msg.sender;\r\n    records[node].subSale=true;\r\n    records[node].subPrice=price;\r\n    records[node].subExpiry=expiry;\r\n    records[node].commitPeriod=now + commit + 86400;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 label,bytes32 node,uint commit, uint price,uint expiry)"
      VariableDeclaration "label"
         Type: bytes32
         Source: "bytes32 label"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "node"
         Type: bytes32
         Source: "bytes32 node"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "commit"
         Type: uint256
         Source: "uint commit"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "price"
         Type: uint256
         Source: "uint price"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "expiry"
         Type: uint256
         Source: "uint expiry"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "prevOwn_check"
       Gas costs: 3
       Source: "prevOwn_check(label)"
      Identifier prevOwn_check
         Type: modifier (bytes32)
         Source: "prevOwn_check"
      Identifier label
         Type: bytes32
         Source: "label"
    ModifierInvocation "deed_check"
       Gas costs: 3
       Source: "deed_check(label)"
      Identifier deed_check
         Type: modifier (bytes32)
         Source: "deed_check"
      Identifier label
         Type: bytes32
         Source: "label"
    ModifierInvocation "ens_check"
       Gas costs: 3
       Source: "ens_check(node)"
      Identifier ens_check
         Type: modifier (bytes32)
         Source: "ens_check"
      Identifier node
         Type: bytes32
         Source: "node"
    Block
       Source: "{\r\n    require(records[node].subSale == false); \r\n\r\n    records[node].originalOwner=msg.sender;\r\n    records[node].subSale=true;\r\n    records[node].subPrice=price;\r\n    records[node].subExpiry=expiry;\r\n    records[node].commitPeriod=now + commit + 86400;\r\n  }"
      ExpressionStatement
         Gas costs: 391
         Source: "require(records[node].subSale == false)"
        FunctionCall
           Type: tuple()
           Source: "require(records[node].subSale == false)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "records[node].subSale == false"
            MemberAccess to member subSale
               Type: bool
               Source: "records[node].subSale"
              IndexAccess
                 Type: struct subdomainSale.Domain storage ref
                 Source: "records[node]"
                Identifier records
                   Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                   Source: "records"
                Identifier node
                   Type: bytes32
                   Source: "node"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      ExpressionStatement
         Gas costs: 20374
         Source: "records[node].originalOwner=msg.sender"
        Assignment using operator =
           Type: address
           Source: "records[node].originalOwner=msg.sender"
          MemberAccess to member originalOwner
             Type: address
             Source: "records[node].originalOwner"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[node]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier node
                 Type: bytes32
                 Source: "node"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20369
         Source: "records[node].subSale=true"
        Assignment using operator =
           Type: bool
           Source: "records[node].subSale=true"
          MemberAccess to member subSale
             Type: bool
             Source: "records[node].subSale"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[node]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier node
                 Type: bytes32
                 Source: "node"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 20116
         Source: "records[node].subPrice=price"
        Assignment using operator =
           Type: uint256
           Source: "records[node].subPrice=price"
          MemberAccess to member subPrice
             Type: uint256
             Source: "records[node].subPrice"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[node]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier node
                 Type: bytes32
                 Source: "node"
          Identifier price
             Type: uint256
             Source: "price"
      ExpressionStatement
         Gas costs: 20116
         Source: "records[node].subExpiry=expiry"
        Assignment using operator =
           Type: uint256
           Source: "records[node].subExpiry=expiry"
          MemberAccess to member subExpiry
             Type: uint256
             Source: "records[node].subExpiry"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[node]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier node
                 Type: bytes32
                 Source: "node"
          Identifier expiry
             Type: uint256
             Source: "expiry"
      ExpressionStatement
         Gas costs: 20127
         Source: "records[node].commitPeriod=now + commit + 86400"
        Assignment using operator =
           Type: uint256
           Source: "records[node].commitPeriod=now + commit + 86400"
          MemberAccess to member commitPeriod
             Type: uint256
             Source: "records[node].commitPeriod"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[node]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier node
                 Type: bytes32
                 Source: "node"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + commit + 86400"
            BinaryOperation using operator +
               Type: uint256
               Source: "now + commit"
              Identifier now
                 Type: uint256
                 Source: "now"
              Identifier commit
                 Type: uint256
                 Source: "commit"
            Literal, token: [no token] value: 86400
               Type: int_const 86400
               Source: "86400"
  FunctionDefinition "unlistSubName" - public
     Source: "function unlistSubName(bytes32 label,bytes32 node) recorded_owner(node) ens_check(node) deed_check(label){\r\n    require(records[node].subSale == true); \r\n    require(records[node].commitPeriod <= now);    \r\n\r\n    ens.setOwner(node,records[node].originalOwner);\r\n    registrar.transfer(label,records[node].originalOwner);\r\n\r\n    records[node].originalOwner=address(0x0);\r\n    records[node].subSale=false;\r\n    records[node].subPrice = 0;\r\n    records[node].subExpiry = 0;\r\n    records[node].commitPeriod=0;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 label,bytes32 node)"
      VariableDeclaration "label"
         Type: bytes32
         Source: "bytes32 label"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "node"
         Type: bytes32
         Source: "bytes32 node"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "recorded_owner"
       Gas costs: 3
       Source: "recorded_owner(node)"
      Identifier recorded_owner
         Type: modifier (bytes32)
         Source: "recorded_owner"
      Identifier node
         Type: bytes32
         Source: "node"
    ModifierInvocation "ens_check"
       Gas costs: 3
       Source: "ens_check(node)"
      Identifier ens_check
         Type: modifier (bytes32)
         Source: "ens_check"
      Identifier node
         Type: bytes32
         Source: "node"
    ModifierInvocation "deed_check"
       Gas costs: 3
       Source: "deed_check(label)"
      Identifier deed_check
         Type: modifier (bytes32)
         Source: "deed_check"
      Identifier label
         Type: bytes32
         Source: "label"
    Block
       Source: "{\r\n    require(records[node].subSale == true); \r\n    require(records[node].commitPeriod <= now);    \r\n\r\n    ens.setOwner(node,records[node].originalOwner);\r\n    registrar.transfer(label,records[node].originalOwner);\r\n\r\n    records[node].originalOwner=address(0x0);\r\n    records[node].subSale=false;\r\n    records[node].subPrice = 0;\r\n    records[node].subExpiry = 0;\r\n    records[node].commitPeriod=0;\r\n  }"
      ExpressionStatement
         Gas costs: 391
         Source: "require(records[node].subSale == true)"
        FunctionCall
           Type: tuple()
           Source: "require(records[node].subSale == true)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "records[node].subSale == true"
            MemberAccess to member subSale
               Type: bool
               Source: "records[node].subSale"
              IndexAccess
                 Type: struct subdomainSale.Domain storage ref
                 Source: "records[node]"
                Identifier records
                   Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                   Source: "records"
                Identifier node
                   Type: bytes32
                   Source: "node"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      ExpressionStatement
         Gas costs: 345
         Source: "require(records[node].commitPeriod <= now)"
        FunctionCall
           Type: tuple()
           Source: "require(records[node].commitPeriod <= now)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "records[node].commitPeriod <= now"
            MemberAccess to member commitPeriod
               Type: uint256
               Source: "records[node].commitPeriod"
              IndexAccess
                 Type: struct subdomainSale.Domain storage ref
                 Source: "records[node]"
                Identifier records
                   Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                   Source: "records"
                Identifier node
                   Type: bytes32
                   Source: "node"
            Identifier now
               Type: uint256
               Source: "now"
      ExpressionStatement
         Gas costs: [???]
         Source: "ens.setOwner(node,records[node].originalOwner)"
        FunctionCall
           Type: tuple()
           Source: "ens.setOwner(node,records[node].originalOwner)"
          MemberAccess to member setOwner
             Type: function (bytes32,address) external
             Source: "ens.setOwner"
            Identifier ens
               Type: contract AbstractENS
               Source: "ens"
          Identifier node
             Type: bytes32
             Source: "node"
          MemberAccess to member originalOwner
             Type: address
             Source: "records[node].originalOwner"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[node]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier node
                 Type: bytes32
                 Source: "node"
      ExpressionStatement
         Gas costs: [???]
         Source: "registrar.transfer(label,records[node].originalOwner)"
        FunctionCall
           Type: tuple()
           Source: "registrar.transfer(label,records[node].originalOwner)"
          MemberAccess to member transfer
             Type: function (bytes32,address) external
             Source: "registrar.transfer"
            Identifier registrar
               Type: contract Registrar
               Source: "registrar"
          Identifier label
             Type: bytes32
             Source: "label"
          MemberAccess to member originalOwner
             Type: address
             Source: "records[node].originalOwner"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[node]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier node
                 Type: bytes32
                 Source: "node"
      ExpressionStatement
         Gas costs: 20375
         Source: "records[node].originalOwner=address(0x0)"
        Assignment using operator =
           Type: address
           Source: "records[node].originalOwner=address(0x0)"
          MemberAccess to member originalOwner
             Type: address
             Source: "records[node].originalOwner"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[node]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier node
                 Type: bytes32
                 Source: "node"
          FunctionCall
             Type: address
             Source: "address(0x0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      ExpressionStatement
         Gas costs: 20369
         Source: "records[node].subSale=false"
        Assignment using operator =
           Type: bool
           Source: "records[node].subSale=false"
          MemberAccess to member subSale
             Type: bool
             Source: "records[node].subSale"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[node]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier node
                 Type: bytes32
                 Source: "node"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 5116
         Source: "records[node].subPrice = 0"
        Assignment using operator =
           Type: uint256
           Source: "records[node].subPrice = 0"
          MemberAccess to member subPrice
             Type: uint256
             Source: "records[node].subPrice"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[node]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier node
                 Type: bytes32
                 Source: "node"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 5116
         Source: "records[node].subExpiry = 0"
        Assignment using operator =
           Type: uint256
           Source: "records[node].subExpiry = 0"
          MemberAccess to member subExpiry
             Type: uint256
             Source: "records[node].subExpiry"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[node]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier node
                 Type: bytes32
                 Source: "node"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 5116
         Source: "records[node].commitPeriod=0"
        Assignment using operator =
           Type: uint256
           Source: "records[node].commitPeriod=0"
          MemberAccess to member commitPeriod
             Type: uint256
             Source: "records[node].commitPeriod"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[node]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier node
                 Type: bytes32
                 Source: "node"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "nodeCheck" - public
     Source: "function nodeCheck(bytes32 node) returns(address){\r\n    return ens.owner(node);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 node)"
      VariableDeclaration "node"
         Type: bytes32
         Source: "bytes32 node"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n    return ens.owner(node);\r\n  }"
      Return
         Gas costs: [???]
         Source: "return ens.owner(node)"
        FunctionCall
           Type: address
           Source: "ens.owner(node)"
          MemberAccess to member owner
             Type: function (bytes32) view external returns (address)
             Source: "ens.owner"
            Identifier ens
               Type: contract AbstractENS
               Source: "ens"
          Identifier node
             Type: bytes32
             Source: "node"
  FunctionDefinition "subRegistrationPeriod" - public
     Source: "function subRegistrationPeriod(bytes32 node) returns(uint){\r\n    return records[node].subExpiry;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 node)"
      VariableDeclaration "node"
         Type: bytes32
         Source: "bytes32 node"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return records[node].subExpiry;\r\n  }"
      Return
         Gas costs: 316
         Source: "return records[node].subExpiry"
        MemberAccess to member subExpiry
           Type: uint256
           Source: "records[node].subExpiry"
          IndexAccess
             Type: struct subdomainSale.Domain storage ref
             Source: "records[node]"
            Identifier records
               Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
               Source: "records"
            Identifier node
               Type: bytes32
               Source: "node"
  FunctionDefinition "checkSubAvailability" - public
     Source: "function checkSubAvailability(bytes32 node) returns(bool){\r\n    return records[node].subSale;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 node)"
      VariableDeclaration "node"
         Type: bytes32
         Source: "bytes32 node"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    return records[node].subSale;\r\n  }"
      Return
         Gas costs: 352
         Source: "return records[node].subSale"
        MemberAccess to member subSale
           Type: bool
           Source: "records[node].subSale"
          IndexAccess
             Type: struct subdomainSale.Domain storage ref
             Source: "records[node]"
            Identifier records
               Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
               Source: "records"
            Identifier node
               Type: bytes32
               Source: "node"
  FunctionDefinition "checkSubPrice" - public
     Source: "function checkSubPrice(bytes32 node) returns(uint){\r\n    return records[node].subPrice;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 node)"
      VariableDeclaration "node"
         Type: bytes32
         Source: "bytes32 node"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return records[node].subPrice;\r\n  }"
      Return
         Gas costs: 316
         Source: "return records[node].subPrice"
        MemberAccess to member subPrice
           Type: uint256
           Source: "records[node].subPrice"
          IndexAccess
             Type: struct subdomainSale.Domain storage ref
             Source: "records[node]"
            Identifier records
               Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
               Source: "records"
            Identifier node
               Type: bytes32
               Source: "node"
  FunctionDefinition "checkCommitPeriod" - public
     Source: "function checkCommitPeriod(bytes32 node) returns(uint){\r\n    return records[node].commitPeriod;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 node)"
      VariableDeclaration "node"
         Type: bytes32
         Source: "bytes32 node"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return records[node].commitPeriod;\r\n  }"
      Return
         Gas costs: 316
         Source: "return records[node].commitPeriod"
        MemberAccess to member commitPeriod
           Type: uint256
           Source: "records[node].commitPeriod"
          IndexAccess
             Type: struct subdomainSale.Domain storage ref
             Source: "records[node]"
            Identifier records
               Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
               Source: "records"
            Identifier node
               Type: bytes32
               Source: "node"
  FunctionDefinition "checkRegPeriod" - public
     Source: "function checkRegPeriod(bytes32 node) returns(uint){\r\n    return records[node].regPeriod;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 node)"
      VariableDeclaration "node"
         Type: bytes32
         Source: "bytes32 node"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return records[node].regPeriod;\r\n  }"
      Return
         Gas costs: 316
         Source: "return records[node].regPeriod"
        MemberAccess to member regPeriod
           Type: uint256
           Source: "records[node].regPeriod"
          IndexAccess
             Type: struct subdomainSale.Domain storage ref
             Source: "records[node]"
            Identifier records
               Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
               Source: "records"
            Identifier node
               Type: bytes32
               Source: "node"
  FunctionDefinition "subBuy" - public
     Source: "function subBuy(bytes32 ensName,bytes32 subNode,address newOwner) payable ens_check(ensName) {\r\n    require( (records[ensName].subExpiry + now + 5) < records[ensName].commitPeriod );\r\n    require(records[ensName].subSale == true);\r\n    require(msg.value >= records[ensName].subPrice);\r\n    \r\n    var newNode = sha3(ensName,subNode);\r\n    require(records[newNode].regPeriod < now);\r\n\r\n    uint fee = msg.value/20;\r\n    uint netPrice = msg.value - fee;\r\n\r\n    admin.transfer(fee);\r\n    records[ensName].originalOwner.transfer(netPrice);\r\n\r\n    records[newNode].regPeriod = now + records[ensName].subExpiry;\r\n    records[newNode].subSale = false;\r\n    records[newNode].subPrice = 0;\r\n    records[newNode].subExpiry = 0;\r\n    records[newNode].commitPeriod=0;\r\n\r\n    ens.setSubnodeOwner(ensName,subNode,newOwner);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 ensName,bytes32 subNode,address newOwner)"
      VariableDeclaration "ensName"
         Type: bytes32
         Source: "bytes32 ensName"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "subNode"
         Type: bytes32
         Source: "bytes32 subNode"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "ens_check"
       Gas costs: 3
       Source: "ens_check(ensName)"
      Identifier ens_check
         Type: modifier (bytes32)
         Source: "ens_check"
      Identifier ensName
         Type: bytes32
         Source: "ensName"
    Block
       Source: "{\r\n    require( (records[ensName].subExpiry + now + 5) < records[ensName].commitPeriod );\r\n    require(records[ensName].subSale == true);\r\n    require(msg.value >= records[ensName].subPrice);\r\n    \r\n    var newNode = sha3(ensName,subNode);\r\n    require(records[newNode].regPeriod < now);\r\n\r\n    uint fee = msg.value/20;\r\n    uint netPrice = msg.value - fee;\r\n\r\n    admin.transfer(fee);\r\n    records[ensName].originalOwner.transfer(netPrice);\r\n\r\n    records[newNode].regPeriod = now + records[ensName].subExpiry;\r\n    records[newNode].subSale = false;\r\n    records[newNode].subPrice = 0;\r\n    records[newNode].subExpiry = 0;\r\n    records[newNode].commitPeriod=0;\r\n\r\n    ens.setSubnodeOwner(ensName,subNode,newOwner);\r\n  }"
      ExpressionStatement
         Gas costs: 656
         Source: "require( (records[ensName].subExpiry + now + 5) < records[ensName].commitPeriod )"
        FunctionCall
           Type: tuple()
           Source: "require( (records[ensName].subExpiry + now + 5) < records[ensName].commitPeriod )"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "(records[ensName].subExpiry + now + 5) < records[ensName].commitPeriod"
            TupleExpression
               Type: uint256
               Source: "(records[ensName].subExpiry + now + 5)"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "records[ensName].subExpiry + now + 5"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "records[ensName].subExpiry + now"
                  MemberAccess to member subExpiry
                     Type: uint256
                     Source: "records[ensName].subExpiry"
                    IndexAccess
                       Type: struct subdomainSale.Domain storage ref
                       Source: "records[ensName]"
                      Identifier records
                         Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                         Source: "records"
                      Identifier ensName
                         Type: bytes32
                         Source: "ensName"
                  Identifier now
                     Type: uint256
                     Source: "now"
                Literal, token: [no token] value: 5
                   Type: int_const 5
                   Source: "5"
            MemberAccess to member commitPeriod
               Type: uint256
               Source: "records[ensName].commitPeriod"
              IndexAccess
                 Type: struct subdomainSale.Domain storage ref
                 Source: "records[ensName]"
                Identifier records
                   Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                   Source: "records"
                Identifier ensName
                   Type: bytes32
                   Source: "ensName"
      ExpressionStatement
         Gas costs: 391
         Source: "require(records[ensName].subSale == true)"
        FunctionCall
           Type: tuple()
           Source: "require(records[ensName].subSale == true)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "records[ensName].subSale == true"
            MemberAccess to member subSale
               Type: bool
               Source: "records[ensName].subSale"
              IndexAccess
                 Type: struct subdomainSale.Domain storage ref
                 Source: "records[ensName]"
                Identifier records
                   Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                   Source: "records"
                Identifier ensName
                   Type: bytes32
                   Source: "ensName"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      ExpressionStatement
         Gas costs: 345
         Source: "require(msg.value >= records[ensName].subPrice)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value >= records[ensName].subPrice)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.value >= records[ensName].subPrice"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            MemberAccess to member subPrice
               Type: uint256
               Source: "records[ensName].subPrice"
              IndexAccess
                 Type: struct subdomainSale.Domain storage ref
                 Source: "records[ensName]"
                Identifier records
                   Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                   Source: "records"
                Identifier ensName
                   Type: bytes32
                   Source: "ensName"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "var newNode = sha3(ensName,subNode)"
        VariableDeclaration "newNode"
           Type: bytes32
           Source: "var newNode"
        FunctionCall
           Type: bytes32
           Source: "sha3(ensName,subNode)"
          Identifier sha3
             Type: function () pure returns (bytes32)
             Source: "sha3"
          Identifier ensName
             Type: bytes32
             Source: "ensName"
          Identifier subNode
             Type: bytes32
             Source: "subNode"
      ExpressionStatement
         Gas costs: 336
         Source: "require(records[newNode].regPeriod < now)"
        FunctionCall
           Type: tuple()
           Source: "require(records[newNode].regPeriod < now)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "records[newNode].regPeriod < now"
            MemberAccess to member regPeriod
               Type: uint256
               Source: "records[newNode].regPeriod"
              IndexAccess
                 Type: struct subdomainSale.Domain storage ref
                 Source: "records[newNode]"
                Identifier records
                   Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                   Source: "records"
                Identifier newNode
                   Type: bytes32
                   Source: "newNode"
            Identifier now
               Type: uint256
               Source: "now"
      VariableDeclarationStatement
         Gas costs: 41
         Source: "uint fee = msg.value/20"
        VariableDeclaration "fee"
           Type: uint256
           Source: "uint fee"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "msg.value/20"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 20
             Type: int_const 20
             Source: "20"
      VariableDeclarationStatement
         Gas costs: 16
         Source: "uint netPrice = msg.value - fee"
        VariableDeclaration "netPrice"
           Type: uint256
           Source: "uint netPrice"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator -
           Type: uint256
           Source: "msg.value - fee"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier fee
             Type: uint256
             Source: "fee"
      ExpressionStatement
         Gas costs: [???]
         Source: "admin.transfer(fee)"
        FunctionCall
           Type: tuple()
           Source: "admin.transfer(fee)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "admin.transfer"
            Identifier admin
               Type: address
               Source: "admin"
          Identifier fee
             Type: uint256
             Source: "fee"
      ExpressionStatement
         Gas costs: [???]
         Source: "records[ensName].originalOwner.transfer(netPrice)"
        FunctionCall
           Type: tuple()
           Source: "records[ensName].originalOwner.transfer(netPrice)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "records[ensName].originalOwner.transfer"
            MemberAccess to member originalOwner
               Type: address
               Source: "records[ensName].originalOwner"
              IndexAccess
                 Type: struct subdomainSale.Domain storage ref
                 Source: "records[ensName]"
                Identifier records
                   Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                   Source: "records"
                Identifier ensName
                   Type: bytes32
                   Source: "ensName"
          Identifier netPrice
             Type: uint256
             Source: "netPrice"
      ExpressionStatement
         Gas costs: 20429
         Source: "records[newNode].regPeriod = now + records[ensName].subExpiry"
        Assignment using operator =
           Type: uint256
           Source: "records[newNode].regPeriod = now + records[ensName].subExpiry"
          MemberAccess to member regPeriod
             Type: uint256
             Source: "records[newNode].regPeriod"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[newNode]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier newNode
                 Type: bytes32
                 Source: "newNode"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + records[ensName].subExpiry"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member subExpiry
               Type: uint256
               Source: "records[ensName].subExpiry"
              IndexAccess
                 Type: struct subdomainSale.Domain storage ref
                 Source: "records[ensName]"
                Identifier records
                   Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                   Source: "records"
                Identifier ensName
                   Type: bytes32
                   Source: "ensName"
      ExpressionStatement
         Gas costs: 20369
         Source: "records[newNode].subSale = false"
        Assignment using operator =
           Type: bool
           Source: "records[newNode].subSale = false"
          MemberAccess to member subSale
             Type: bool
             Source: "records[newNode].subSale"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[newNode]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier newNode
                 Type: bytes32
                 Source: "newNode"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 5116
         Source: "records[newNode].subPrice = 0"
        Assignment using operator =
           Type: uint256
           Source: "records[newNode].subPrice = 0"
          MemberAccess to member subPrice
             Type: uint256
             Source: "records[newNode].subPrice"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[newNode]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier newNode
                 Type: bytes32
                 Source: "newNode"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 5116
         Source: "records[newNode].subExpiry = 0"
        Assignment using operator =
           Type: uint256
           Source: "records[newNode].subExpiry = 0"
          MemberAccess to member subExpiry
             Type: uint256
             Source: "records[newNode].subExpiry"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[newNode]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier newNode
                 Type: bytes32
                 Source: "newNode"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 5116
         Source: "records[newNode].commitPeriod=0"
        Assignment using operator =
           Type: uint256
           Source: "records[newNode].commitPeriod=0"
          MemberAccess to member commitPeriod
             Type: uint256
             Source: "records[newNode].commitPeriod"
            IndexAccess
               Type: struct subdomainSale.Domain storage ref
               Source: "records[newNode]"
              Identifier records
                 Type: mapping(bytes32 => struct subdomainSale.Domain storage ref)
                 Source: "records"
              Identifier newNode
                 Type: bytes32
                 Source: "newNode"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "ens.setSubnodeOwner(ensName,subNode,newOwner)"
        FunctionCall
           Type: tuple()
           Source: "ens.setSubnodeOwner(ensName,subNode,newOwner)"
          MemberAccess to member setSubnodeOwner
             Type: function (bytes32,bytes32,address) external
             Source: "ens.setSubnodeOwner"
            Identifier ens
               Type: contract AbstractENS
               Source: "ens"
          Identifier ensName
             Type: bytes32
             Source: "ensName"
          Identifier subNode
             Type: bytes32
             Source: "subNode"
          Identifier newOwner
             Type: address
             Source: "newOwner"
  FunctionDefinition "" - public
     Source: "function() payable{\r\n    admin.transfer(msg.value);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    admin.transfer(msg.value);\r\n  }"
      ExpressionStatement
         Gas costs: [???]
         Source: "admin.transfer(msg.value)"
        FunctionCall
           Type: tuple()
           Source: "admin.transfer(msg.value)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "admin.transfer"
            Identifier admin
               Type: address
               Source: "admin"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
