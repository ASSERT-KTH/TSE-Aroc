Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xbf0bd228e20002034ec913df972682e490403617.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.13;"
ContractDefinition "owned"
   Source: "contract owned {\r\n    address public owner;\r\n\r\n    function owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) revert();\r\n        _;\r\n    }\r\n\r\n    \r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  FunctionDefinition "owned" - public
     Source: "function owned() {\r\n        owner = msg.sender;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        owner = msg.sender;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner {\r\n        if (msg.sender != owner) revert();\r\n        _;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (msg.sender != owner) revert();\r\n        _;\r\n    }"
      IfStatement
         Source: "if (msg.sender != owner) revert()"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 518
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        ExpressionStatement
           Gas costs: 12
           Source: "revert()"
          FunctionCall
             Type: tuple()
             Source: "revert()"
            Identifier revert
               Type: function () pure
               Source: "revert"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
ContractDefinition "token"
   Source: "contract token {\r\n    /* Public variables of the token */\r\n    string public standard = 'BixCoin 0.1';\r\n    string public name;                                 //Name of the coin\r\n    string public symbol;                               //Symbol of the coin\r\n    uint8  public decimals;                              // No of decimal places (to use no 128, you have to write 12800)\r\n\r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function token(\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol\r\n        ) {\r\n        name = tokenName;                                   // Set the name for display purposes\r\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\r\n        decimals = decimalUnits;                            // Amount of decimals for display purposes\r\n    }\r\n\r\n    \r\n\r\n    /* This unnamed function is called whenever someone tries to send ether to it */\r\n    function () {\r\n        revert();     // Prevents accidental sending of ether\r\n    }\r\n}"
  VariableDeclaration "standard"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public standard = 'BixCoin 0.1'"
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: BixCoin 0.1
       Type: literal_string "BixCoin 0.1"
       Source: "'BixCoin 0.1'"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public name"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public symbol"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: [???]
     Source: "uint8  public decimals"
    ElementaryTypeName uint8
       Source: "uint8"
  VariableDeclaration "balanceOf"
     Type: mapping(address => uint256)
     Gas costs: [???]
     Source: "mapping (address => uint256) public balanceOf"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  EventDefinition "Transfer"
     Gas costs: 0
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "token" - public
     Source: "function token(\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol\r\n        ) {\r\n        name = tokenName;                                   // Set the name for display purposes\r\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\r\n        decimals = decimalUnits;                            // Amount of decimals for display purposes\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol\r\n        )"
      VariableDeclaration "tokenName"
         Type: string memory
         Source: "string tokenName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "decimalUnits"
         Type: uint8
         Source: "uint8 decimalUnits"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "tokenSymbol"
         Type: string memory
         Source: "string tokenSymbol"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        name = tokenName;                                   // Set the name for display purposes\r\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\r\n        decimals = decimalUnits;                            // Amount of decimals for display purposes\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "name = tokenName"
        Assignment using operator =
           Type: string storage ref
           Source: "name = tokenName"
          Identifier name
             Type: string storage ref
             Source: "name"
          Identifier tokenName
             Type: string memory
             Source: "tokenName"
      ExpressionStatement
         Gas costs: 0
         Source: "symbol = tokenSymbol"
        Assignment using operator =
           Type: string storage ref
           Source: "symbol = tokenSymbol"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
          Identifier tokenSymbol
             Type: string memory
             Source: "tokenSymbol"
      ExpressionStatement
         Gas costs: 0
         Source: "decimals = decimalUnits"
        Assignment using operator =
           Type: uint8
           Source: "decimals = decimalUnits"
          Identifier decimals
             Type: uint8
             Source: "decimals"
          Identifier decimalUnits
             Type: uint8
             Source: "decimalUnits"
  FunctionDefinition "" - public
     Source: "function () {\r\n        revert();     // Prevents accidental sending of ether\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        revert();     // Prevents accidental sending of ether\r\n    }"
      ExpressionStatement
         Gas costs: 6
         Source: "revert()"
        FunctionCall
           Type: tuple()
           Source: "revert()"
          Identifier revert
             Type: function () pure
             Source: "revert"
ContractDefinition "ProgressiveToken"
   Source: "contract ProgressiveToken is owned, token {\r\n    uint256 public constant totalSupply=2100000000000;          // the amount of total coins avilable.\r\n    uint256 public reward;                                    // reward given to miner.\r\n    uint256 internal coinBirthTime=now;                       // the time when contract is created.\r\n    uint256 public currentSupply;                           // the count of coins currently avilable.\r\n    uint256 internal initialSupply;                           // initial number of tokens.\r\n    uint256 public sellPrice;                                 // price of coin wrt ether at time of selling coins\r\n    uint256 public buyPrice;                                  // price of coin wrt ether at time of buying coins\r\n    \r\n   mapping  (uint256 => uint256) rewardArray;                  //create an array with all reward values.\r\n   \r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function ProgressiveToken(\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        uint256 initialSupply,\r\n        uint256 sellPrice,\r\n        uint256 buyPrice,\r\n        address centralMinter                                  \r\n    ) token ( tokenName, decimalUnits, tokenSymbol) {\r\n        if(centralMinter != 0 ) owner = centralMinter;    // Sets the owner as specified (if centralMinter is not specified the owner is \r\n                                                          // msg.sender)\r\n        balanceOf[owner] = initialSupply;                // Give the owner all initial tokens\r\n\tsetPrices(sellPrice,buyPrice);                   // sets sell and buy price.\r\n        currentSupply=initialSupply;                     //updating current supply.\r\n        reward=837139;                                  //initialising reward with initial reward as per calculation.\r\n        for(uint256 i=0;i<20;i++){                       // storing rewardValues in an array.\r\n            rewardArray[i]=reward;\r\n            reward=reward/2;\r\n        }\r\n        reward=getReward(now);\r\n    }\r\n    \r\n    \r\n    \r\n  \r\n   /* Calculates value of reward at given time */\r\n    function getReward (uint currentTime) constant returns (uint256) {\r\n        uint elapsedTimeInSeconds = currentTime - coinBirthTime;         //calculating timealpsed after generation of coin in seconds.\r\n        uint elapsedTimeinMonths= elapsedTimeInSeconds/(30*24*60*60);    //calculating timealpsed after generation of coin\r\n        uint period=elapsedTimeinMonths/3;                               // Period of 3 months elapsed after coin was generated.\r\n        return rewardArray[period];                                      // returning current reward as per period of 3 monts elapsed.\r\n    }\r\n\r\n    function updateCurrentSupply() private {\r\n        currentSupply+=reward;\r\n    }\r\n\r\n   \r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) {\r\n        require (balanceOf[msg.sender] > _value) ;                          // Check if the sender has enough balance\r\n        require (balanceOf[_to] + _value > balanceOf[_to]);                // Check for overflows\r\n        reward=getReward(now);                                              //Calculate current Reward.\r\n        require(currentSupply + reward < totalSupply );                    //check for totalSupply.\r\n        balanceOf[msg.sender] -= _value;                                    // Subtract from the sender\r\n        balanceOf[_to] += _value;                                           // Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value);                                  // Notify anyone listening that this transfer took  \r\n        updateCurrentSupply();\r\n        balanceOf[block.coinbase] += reward;\r\n    }\r\n\r\n\r\n\r\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\r\n            require(currentSupply + mintedAmount < totalSupply);             // check for total supply.\r\n            currentSupply+=(mintedAmount);                                   //updating currentSupply.\r\n            balanceOf[target] += mintedAmount;                               //adding balance to recipient.\r\n            Transfer(0, owner, mintedAmount);\r\n            Transfer(owner, target, mintedAmount);\r\n    }\r\n\r\n\r\n\r\n\r\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {\r\n        sellPrice = newSellPrice;          //initialising sellPrice so that sell price becomes value of coins in Wei\r\n        buyPrice = newBuyPrice;            //initialising buyPrice so that buy price becomes value of coins in Wei\r\n    }\r\n    \r\n   function buy() payable returns (uint amount){\r\n        amount = msg.value / buyPrice;                     // calculates the amount\r\n        require (balanceOf[this] > amount);               // checks if it has enough to sell\r\n        reward=getReward(now);                             //calculating current reward.\r\n        require(currentSupply + reward < totalSupply );   // check for totalSupply\r\n        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance\r\n        balanceOf[this] -= amount;                         // subtracts amount from seller's balance\r\n        balanceOf[block.coinbase]+=reward;                 // rewards the miner\r\n        updateCurrentSupply();                             //update the current supply.\r\n        Transfer(this, msg.sender, amount);                // execute an event reflecting the change\r\n        return amount;                                     // ends function and returns\r\n    }\r\n\r\n    function sell(uint amount) returns (uint revenue){\r\n        require (balanceOf[msg.sender] > amount );        // checks if the sender has enough to sell\r\n        reward=getReward(now);                             //calculating current reward.\r\n        require(currentSupply + reward < totalSupply );   // check for totalSupply.\r\n        balanceOf[this] += amount;                         // adds the amount to owner's balance\r\n        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance\r\n        balanceOf[block.coinbase]+=reward;                 // rewarding the miner.\r\n        updateCurrentSupply();                             //updating currentSupply.\r\n        revenue = amount * sellPrice;                      // amount (in wei) corresponsing to no of coins.\r\n        if (!msg.sender.send(revenue)) {                   // sends ether to the seller: it's important\r\n            revert();                                         // to do this last to prevent recursion attacks\r\n        } else {\r\n            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change\r\n            return revenue;                                // ends function and returns\r\n        }\r\n    }\r\n\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "owned"
    UserDefinedTypeName "owned"
       Source: "owned"
  InheritanceSpecifier
     Gas costs: 0
     Source: "token"
    UserDefinedTypeName "token"
       Source: "token"
  VariableDeclaration "totalSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant totalSupply=2100000000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 2100000000000
       Type: int_const 2100000000000
       Source: "2100000000000"
  VariableDeclaration "reward"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public reward"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "coinBirthTime"
     Type: uint256
     Gas costs: 0
     Source: "uint256 internal coinBirthTime=now"
    ElementaryTypeName uint256
       Source: "uint256"
    Identifier now
       Type: uint256
       Source: "now"
  VariableDeclaration "currentSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public currentSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "initialSupply"
     Type: uint256
     Gas costs: 0
     Source: "uint256 internal initialSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "sellPrice"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public sellPrice"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "buyPrice"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public buyPrice"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "rewardArray"
     Type: mapping(uint256 => uint256)
     Gas costs: 0
     Source: "mapping  (uint256 => uint256) rewardArray"
    Mapping
       Source: "mapping  (uint256 => uint256)"
      ElementaryTypeName uint256
         Source: "uint256"
      ElementaryTypeName uint256
         Source: "uint256"
  FunctionDefinition "ProgressiveToken" - public
     Source: "function ProgressiveToken(\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        uint256 initialSupply,\r\n        uint256 sellPrice,\r\n        uint256 buyPrice,\r\n        address centralMinter                                  \r\n    ) token ( tokenName, decimalUnits, tokenSymbol) {\r\n        if(centralMinter != 0 ) owner = centralMinter;    // Sets the owner as specified (if centralMinter is not specified the owner is \r\n                                                          // msg.sender)\r\n        balanceOf[owner] = initialSupply;                // Give the owner all initial tokens\r\n\tsetPrices(sellPrice,buyPrice);                   // sets sell and buy price.\r\n        currentSupply=initialSupply;                     //updating current supply.\r\n        reward=837139;                                  //initialising reward with initial reward as per calculation.\r\n        for(uint256 i=0;i<20;i++){                       // storing rewardValues in an array.\r\n            rewardArray[i]=reward;\r\n            reward=reward/2;\r\n        }\r\n        reward=getReward(now);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        uint256 initialSupply,\r\n        uint256 sellPrice,\r\n        uint256 buyPrice,\r\n        address centralMinter                                  \r\n    )"
      VariableDeclaration "tokenName"
         Type: string memory
         Source: "string tokenName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "decimalUnits"
         Type: uint8
         Source: "uint8 decimalUnits"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "tokenSymbol"
         Type: string memory
         Source: "string tokenSymbol"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "initialSupply"
         Type: uint256
         Source: "uint256 initialSupply"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "sellPrice"
         Type: uint256
         Source: "uint256 sellPrice"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "buyPrice"
         Type: uint256
         Source: "uint256 buyPrice"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "centralMinter"
         Type: address
         Source: "address centralMinter"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "token"
       Gas costs: 0
       Source: "token ( tokenName, decimalUnits, tokenSymbol)"
      Identifier token
         Type: type(contract token)
         Source: "token"
      Identifier tokenName
         Type: string memory
         Source: "tokenName"
      Identifier decimalUnits
         Type: uint8
         Source: "decimalUnits"
      Identifier tokenSymbol
         Type: string memory
         Source: "tokenSymbol"
    Block
       Source: "{\r\n        if(centralMinter != 0 ) owner = centralMinter;    // Sets the owner as specified (if centralMinter is not specified the owner is \r\n                                                          // msg.sender)\r\n        balanceOf[owner] = initialSupply;                // Give the owner all initial tokens\r\n\tsetPrices(sellPrice,buyPrice);                   // sets sell and buy price.\r\n        currentSupply=initialSupply;                     //updating current supply.\r\n        reward=837139;                                  //initialising reward with initial reward as per calculation.\r\n        for(uint256 i=0;i<20;i++){                       // storing rewardValues in an array.\r\n            rewardArray[i]=reward;\r\n            reward=reward/2;\r\n        }\r\n        reward=getReward(now);\r\n    }"
      IfStatement
         Source: "if(centralMinter != 0 ) owner = centralMinter"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "centralMinter != 0"
          Identifier centralMinter
             Type: address
             Source: "centralMinter"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 0
           Source: "owner = centralMinter"
          Assignment using operator =
             Type: address
             Source: "owner = centralMinter"
            Identifier owner
               Type: address
               Source: "owner"
            Identifier centralMinter
               Type: address
               Source: "centralMinter"
      ExpressionStatement
         Gas costs: 0
         Source: "balanceOf[owner] = initialSupply"
        Assignment using operator =
           Type: uint256
           Source: "balanceOf[owner] = initialSupply"
          IndexAccess
             Type: uint256
             Source: "balanceOf[owner]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier owner
               Type: address
               Source: "owner"
          Identifier initialSupply
             Type: uint256
             Source: "initialSupply"
      ExpressionStatement
         Gas costs: 0
         Source: "setPrices(sellPrice,buyPrice)"
        FunctionCall
           Type: tuple()
           Source: "setPrices(sellPrice,buyPrice)"
          Identifier setPrices
             Type: function (uint256,uint256)
             Source: "setPrices"
          Identifier sellPrice
             Type: uint256
             Source: "sellPrice"
          Identifier buyPrice
             Type: uint256
             Source: "buyPrice"
      ExpressionStatement
         Gas costs: 0
         Source: "currentSupply=initialSupply"
        Assignment using operator =
           Type: uint256
           Source: "currentSupply=initialSupply"
          Identifier currentSupply
             Type: uint256
             Source: "currentSupply"
          Identifier initialSupply
             Type: uint256
             Source: "initialSupply"
      ExpressionStatement
         Gas costs: 0
         Source: "reward=837139"
        Assignment using operator =
           Type: uint256
           Source: "reward=837139"
          Identifier reward
             Type: uint256
             Source: "reward"
          Literal, token: [no token] value: 837139
             Type: int_const 837139
             Source: "837139"
      ForStatement
         Source: "for(uint256 i=0;i<20;i++){                       // storing rewardValues in an array.\r\n            rewardArray[i]=reward;\r\n            reward=reward/2;\r\n        }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint256 i=0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint256 i"
            ElementaryTypeName uint256
               Source: "uint256"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i<20"
          Identifier i
             Type: uint256
             Source: "i"
          Literal, token: [no token] value: 20
             Type: int_const 20
             Source: "20"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{                       // storing rewardValues in an array.\r\n            rewardArray[i]=reward;\r\n            reward=reward/2;\r\n        }"
          ExpressionStatement
             Gas costs: 0
             Source: "rewardArray[i]=reward"
            Assignment using operator =
               Type: uint256
               Source: "rewardArray[i]=reward"
              IndexAccess
                 Type: uint256
                 Source: "rewardArray[i]"
                Identifier rewardArray
                   Type: mapping(uint256 => uint256)
                   Source: "rewardArray"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier reward
                 Type: uint256
                 Source: "reward"
          ExpressionStatement
             Gas costs: 0
             Source: "reward=reward/2"
            Assignment using operator =
               Type: uint256
               Source: "reward=reward/2"
              Identifier reward
                 Type: uint256
                 Source: "reward"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "reward/2"
                Identifier reward
                   Type: uint256
                   Source: "reward"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
      ExpressionStatement
         Gas costs: 0
         Source: "reward=getReward(now)"
        Assignment using operator =
           Type: uint256
           Source: "reward=getReward(now)"
          Identifier reward
             Type: uint256
             Source: "reward"
          FunctionCall
             Type: uint256
             Source: "getReward(now)"
            Identifier getReward
               Type: function (uint256) view returns (uint256)
               Source: "getReward"
            Identifier now
               Type: uint256
               Source: "now"
  FunctionDefinition "getReward" - public - const
     Source: "function getReward (uint currentTime) constant returns (uint256) {\r\n        uint elapsedTimeInSeconds = currentTime - coinBirthTime;         //calculating timealpsed after generation of coin in seconds.\r\n        uint elapsedTimeinMonths= elapsedTimeInSeconds/(30*24*60*60);    //calculating timealpsed after generation of coin\r\n        uint period=elapsedTimeinMonths/3;                               // Period of 3 months elapsed after coin was generated.\r\n        return rewardArray[period];                                      // returning current reward as per period of 3 monts elapsed.\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint currentTime)"
      VariableDeclaration "currentTime"
         Type: uint256
         Source: "uint currentTime"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        uint elapsedTimeInSeconds = currentTime - coinBirthTime;         //calculating timealpsed after generation of coin in seconds.\r\n        uint elapsedTimeinMonths= elapsedTimeInSeconds/(30*24*60*60);    //calculating timealpsed after generation of coin\r\n        uint period=elapsedTimeinMonths/3;                               // Period of 3 months elapsed after coin was generated.\r\n        return rewardArray[period];                                      // returning current reward as per period of 3 monts elapsed.\r\n    }"
      VariableDeclarationStatement
         Gas costs: 217
         Source: "uint elapsedTimeInSeconds = currentTime - coinBirthTime"
        VariableDeclaration "elapsedTimeInSeconds"
           Type: uint256
           Source: "uint elapsedTimeInSeconds"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator -
           Type: uint256
           Source: "currentTime - coinBirthTime"
          Identifier currentTime
             Type: uint256
             Source: "currentTime"
          Identifier coinBirthTime
             Type: uint256
             Source: "coinBirthTime"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint elapsedTimeinMonths= elapsedTimeInSeconds/(30*24*60*60)"
        VariableDeclaration "elapsedTimeinMonths"
           Type: uint256
           Source: "uint elapsedTimeinMonths"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "elapsedTimeInSeconds/(30*24*60*60)"
          Identifier elapsedTimeInSeconds
             Type: uint256
             Source: "elapsedTimeInSeconds"
          TupleExpression
             Type: int_const 2592000
             Source: "(30*24*60*60)"
            BinaryOperation using operator *
               Type: int_const 2592000
               Source: "30*24*60*60"
              BinaryOperation using operator *
                 Type: int_const 43200
                 Source: "30*24*60"
                BinaryOperation using operator *
                   Type: int_const 720
                   Source: "30*24"
                  Literal, token: [no token] value: 30
                     Type: int_const 30
                     Source: "30"
                  Literal, token: [no token] value: 24
                     Type: int_const 24
                     Source: "24"
                Literal, token: [no token] value: 60
                   Type: int_const 60
                   Source: "60"
              Literal, token: [no token] value: 60
                 Type: int_const 60
                 Source: "60"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint period=elapsedTimeinMonths/3"
        VariableDeclaration "period"
           Type: uint256
           Source: "uint period"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "elapsedTimeinMonths/3"
          Identifier elapsedTimeinMonths
             Type: uint256
             Source: "elapsedTimeinMonths"
          Literal, token: [no token] value: 3
             Type: int_const 3
             Source: "3"
      Return
         Gas costs: 292
         Source: "return rewardArray[period]"
        IndexAccess
           Type: uint256
           Source: "rewardArray[period]"
          Identifier rewardArray
             Type: mapping(uint256 => uint256)
             Source: "rewardArray"
          Identifier period
             Type: uint256
             Source: "period"
  FunctionDefinition "updateCurrentSupply"
     Source: "function updateCurrentSupply() private {\r\n        currentSupply+=reward;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        currentSupply+=reward;\r\n    }"
      ExpressionStatement
         Gas costs: 20433
         Source: "currentSupply+=reward"
        Assignment using operator +=
           Type: uint256
           Source: "currentSupply+=reward"
          Identifier currentSupply
             Type: uint256
             Source: "currentSupply"
          Identifier reward
             Type: uint256
             Source: "reward"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) {\r\n        require (balanceOf[msg.sender] > _value) ;                          // Check if the sender has enough balance\r\n        require (balanceOf[_to] + _value > balanceOf[_to]);                // Check for overflows\r\n        reward=getReward(now);                                              //Calculate current Reward.\r\n        require(currentSupply + reward < totalSupply );                    //check for totalSupply.\r\n        balanceOf[msg.sender] -= _value;                                    // Subtract from the sender\r\n        balanceOf[_to] += _value;                                           // Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value);                                  // Notify anyone listening that this transfer took  \r\n        updateCurrentSupply();\r\n        balanceOf[block.coinbase] += reward;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        require (balanceOf[msg.sender] > _value) ;                          // Check if the sender has enough balance\r\n        require (balanceOf[_to] + _value > balanceOf[_to]);                // Check for overflows\r\n        reward=getReward(now);                                              //Calculate current Reward.\r\n        require(currentSupply + reward < totalSupply );                    //check for totalSupply.\r\n        balanceOf[msg.sender] -= _value;                                    // Subtract from the sender\r\n        balanceOf[_to] += _value;                                           // Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value);                                  // Notify anyone listening that this transfer took  \r\n        updateCurrentSupply();\r\n        balanceOf[block.coinbase] += reward;\r\n    }"
      ExpressionStatement
         Gas costs: 330
         Source: "require (balanceOf[msg.sender] > _value)"
        FunctionCall
           Type: tuple()
           Source: "require (balanceOf[msg.sender] > _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balanceOf[msg.sender] > _value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[msg.sender]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 627
         Source: "require (balanceOf[_to] + _value > balanceOf[_to])"
        FunctionCall
           Type: tuple()
           Source: "require (balanceOf[_to] + _value > balanceOf[_to])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balanceOf[_to] + _value > balanceOf[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balanceOf[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balanceOf[_to]"
                Identifier balanceOf
                   Type: mapping(address => uint256)
                   Source: "balanceOf"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balanceOf[_to]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier _to
                 Type: address
                 Source: "_to"
      ExpressionStatement
         Gas costs: 20028
         Source: "reward=getReward(now)"
        Assignment using operator =
           Type: uint256
           Source: "reward=getReward(now)"
          Identifier reward
             Type: uint256
             Source: "reward"
          FunctionCall
             Type: uint256
             Source: "getReward(now)"
            Identifier getReward
               Type: function (uint256) view returns (uint256)
               Source: "getReward"
            Identifier now
               Type: uint256
               Source: "now"
      ExpressionStatement
         Gas costs: 438
         Source: "require(currentSupply + reward < totalSupply )"
        FunctionCall
           Type: tuple()
           Source: "require(currentSupply + reward < totalSupply )"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "currentSupply + reward < totalSupply"
            BinaryOperation using operator +
               Type: uint256
               Source: "currentSupply + reward"
              Identifier currentSupply
                 Type: uint256
                 Source: "currentSupply"
              Identifier reward
                 Type: uint256
                 Source: "reward"
            Identifier totalSupply
               Type: uint256
               Source: "totalSupply"
      ExpressionStatement
         Gas costs: 20328
         Source: "balanceOf[msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20323
         Source: "balanceOf[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balanceOf[_to]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 15
         Source: "updateCurrentSupply()"
        FunctionCall
           Type: tuple()
           Source: "updateCurrentSupply()"
          Identifier updateCurrentSupply
             Type: function ()
             Source: "updateCurrentSupply"
      ExpressionStatement
         Gas costs: 20528
         Source: "balanceOf[block.coinbase] += reward"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[block.coinbase] += reward"
          IndexAccess
             Type: uint256
             Source: "balanceOf[block.coinbase]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member coinbase
               Type: address
               Source: "block.coinbase"
              Identifier block
                 Type: block
                 Source: "block"
          Identifier reward
             Type: uint256
             Source: "reward"
  FunctionDefinition "mintToken" - public
     Source: "function mintToken(address target, uint256 mintedAmount) onlyOwner {\r\n            require(currentSupply + mintedAmount < totalSupply);             // check for total supply.\r\n            currentSupply+=(mintedAmount);                                   //updating currentSupply.\r\n            balanceOf[target] += mintedAmount;                               //adding balance to recipient.\r\n            Transfer(0, owner, mintedAmount);\r\n            Transfer(owner, target, mintedAmount);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address target, uint256 mintedAmount)"
      VariableDeclaration "target"
         Type: address
         Source: "address target"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "mintedAmount"
         Type: uint256
         Source: "uint256 mintedAmount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n            require(currentSupply + mintedAmount < totalSupply);             // check for total supply.\r\n            currentSupply+=(mintedAmount);                                   //updating currentSupply.\r\n            balanceOf[target] += mintedAmount;                               //adding balance to recipient.\r\n            Transfer(0, owner, mintedAmount);\r\n            Transfer(owner, target, mintedAmount);\r\n    }"
      ExpressionStatement
         Gas costs: 238
         Source: "require(currentSupply + mintedAmount < totalSupply)"
        FunctionCall
           Type: tuple()
           Source: "require(currentSupply + mintedAmount < totalSupply)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "currentSupply + mintedAmount < totalSupply"
            BinaryOperation using operator +
               Type: uint256
               Source: "currentSupply + mintedAmount"
              Identifier currentSupply
                 Type: uint256
                 Source: "currentSupply"
              Identifier mintedAmount
                 Type: uint256
                 Source: "mintedAmount"
            Identifier totalSupply
               Type: uint256
               Source: "totalSupply"
      ExpressionStatement
         Gas costs: 20233
         Source: "currentSupply+=(mintedAmount)"
        Assignment using operator +=
           Type: uint256
           Source: "currentSupply+=(mintedAmount)"
          Identifier currentSupply
             Type: uint256
             Source: "currentSupply"
          TupleExpression
             Type: uint256
             Source: "(mintedAmount)"
            Identifier mintedAmount
               Type: uint256
               Source: "mintedAmount"
      ExpressionStatement
         Gas costs: 20329
         Source: "balanceOf[target] += mintedAmount"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[target] += mintedAmount"
          IndexAccess
             Type: uint256
             Source: "balanceOf[target]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier target
               Type: address
               Source: "target"
          Identifier mintedAmount
             Type: uint256
             Source: "mintedAmount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(0, owner, mintedAmount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(0, owner, mintedAmount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier mintedAmount
             Type: uint256
             Source: "mintedAmount"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(owner, target, mintedAmount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(owner, target, mintedAmount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier target
             Type: address
             Source: "target"
          Identifier mintedAmount
             Type: uint256
             Source: "mintedAmount"
  FunctionDefinition "setPrices" - public
     Source: "function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {\r\n        sellPrice = newSellPrice;          //initialising sellPrice so that sell price becomes value of coins in Wei\r\n        buyPrice = newBuyPrice;            //initialising buyPrice so that buy price becomes value of coins in Wei\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 newSellPrice, uint256 newBuyPrice)"
      VariableDeclaration "newSellPrice"
         Type: uint256
         Source: "uint256 newSellPrice"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "newBuyPrice"
         Type: uint256
         Source: "uint256 newBuyPrice"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n        sellPrice = newSellPrice;          //initialising sellPrice so that sell price becomes value of coins in Wei\r\n        buyPrice = newBuyPrice;            //initialising buyPrice so that buy price becomes value of coins in Wei\r\n    }"
      ExpressionStatement
         Gas costs: 20014
         Source: "sellPrice = newSellPrice"
        Assignment using operator =
           Type: uint256
           Source: "sellPrice = newSellPrice"
          Identifier sellPrice
             Type: uint256
             Source: "sellPrice"
          Identifier newSellPrice
             Type: uint256
             Source: "newSellPrice"
      ExpressionStatement
         Gas costs: 20014
         Source: "buyPrice = newBuyPrice"
        Assignment using operator =
           Type: uint256
           Source: "buyPrice = newBuyPrice"
          Identifier buyPrice
             Type: uint256
             Source: "buyPrice"
          Identifier newBuyPrice
             Type: uint256
             Source: "newBuyPrice"
  FunctionDefinition "buy" - public
     Source: "function buy() payable returns (uint amount){\r\n        amount = msg.value / buyPrice;                     // calculates the amount\r\n        require (balanceOf[this] > amount);               // checks if it has enough to sell\r\n        reward=getReward(now);                             //calculating current reward.\r\n        require(currentSupply + reward < totalSupply );   // check for totalSupply\r\n        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance\r\n        balanceOf[this] -= amount;                         // subtracts amount from seller's balance\r\n        balanceOf[block.coinbase]+=reward;                 // rewards the miner\r\n        updateCurrentSupply();                             //update the current supply.\r\n        Transfer(this, msg.sender, amount);                // execute an event reflecting the change\r\n        return amount;                                     // ends function and returns\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        amount = msg.value / buyPrice;                     // calculates the amount\r\n        require (balanceOf[this] > amount);               // checks if it has enough to sell\r\n        reward=getReward(now);                             //calculating current reward.\r\n        require(currentSupply + reward < totalSupply );   // check for totalSupply\r\n        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance\r\n        balanceOf[this] -= amount;                         // subtracts amount from seller's balance\r\n        balanceOf[block.coinbase]+=reward;                 // rewards the miner\r\n        updateCurrentSupply();                             //update the current supply.\r\n        Transfer(this, msg.sender, amount);                // execute an event reflecting the change\r\n        return amount;                                     // ends function and returns\r\n    }"
      ExpressionStatement
         Gas costs: 238
         Source: "amount = msg.value / buyPrice"
        Assignment using operator =
           Type: uint256
           Source: "amount = msg.value / buyPrice"
          Identifier amount
             Type: uint256
             Source: "amount"
          BinaryOperation using operator /
             Type: uint256
             Source: "msg.value / buyPrice"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier buyPrice
               Type: uint256
               Source: "buyPrice"
      ExpressionStatement
         Gas costs: 330
         Source: "require (balanceOf[this] > amount)"
        FunctionCall
           Type: tuple()
           Source: "require (balanceOf[this] > amount)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balanceOf[this] > amount"
            IndexAccess
               Type: uint256
               Source: "balanceOf[this]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              Identifier this
                 Type: contract ProgressiveToken
                 Source: "this"
            Identifier amount
               Type: uint256
               Source: "amount"
      ExpressionStatement
         Gas costs: 20028
         Source: "reward=getReward(now)"
        Assignment using operator =
           Type: uint256
           Source: "reward=getReward(now)"
          Identifier reward
             Type: uint256
             Source: "reward"
          FunctionCall
             Type: uint256
             Source: "getReward(now)"
            Identifier getReward
               Type: function (uint256) view returns (uint256)
               Source: "getReward"
            Identifier now
               Type: uint256
               Source: "now"
      ExpressionStatement
         Gas costs: 438
         Source: "require(currentSupply + reward < totalSupply )"
        FunctionCall
           Type: tuple()
           Source: "require(currentSupply + reward < totalSupply )"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "currentSupply + reward < totalSupply"
            BinaryOperation using operator +
               Type: uint256
               Source: "currentSupply + reward"
              Identifier currentSupply
                 Type: uint256
                 Source: "currentSupply"
              Identifier reward
                 Type: uint256
                 Source: "reward"
            Identifier totalSupply
               Type: uint256
               Source: "totalSupply"
      ExpressionStatement
         Gas costs: 20328
         Source: "balanceOf[msg.sender] += amount"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[msg.sender] += amount"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Gas costs: 20322
         Source: "balanceOf[this] -= amount"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[this] -= amount"
          IndexAccess
             Type: uint256
             Source: "balanceOf[this]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier this
               Type: contract ProgressiveToken
               Source: "this"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Gas costs: 20522
         Source: "balanceOf[block.coinbase]+=reward"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[block.coinbase]+=reward"
          IndexAccess
             Type: uint256
             Source: "balanceOf[block.coinbase]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member coinbase
               Type: address
               Source: "block.coinbase"
              Identifier block
                 Type: block
                 Source: "block"
          Identifier reward
             Type: uint256
             Source: "reward"
      ExpressionStatement
         Gas costs: 4
         Source: "updateCurrentSupply()"
        FunctionCall
           Type: tuple()
           Source: "updateCurrentSupply()"
          Identifier updateCurrentSupply
             Type: function ()
             Source: "updateCurrentSupply"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(this, msg.sender, amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(this, msg.sender, amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier this
             Type: contract ProgressiveToken
             Source: "this"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier amount
             Type: uint256
             Source: "amount"
      Return
         Gas costs: 8
         Source: "return amount"
        Identifier amount
           Type: uint256
           Source: "amount"
  FunctionDefinition "sell" - public
     Source: "function sell(uint amount) returns (uint revenue){\r\n        require (balanceOf[msg.sender] > amount );        // checks if the sender has enough to sell\r\n        reward=getReward(now);                             //calculating current reward.\r\n        require(currentSupply + reward < totalSupply );   // check for totalSupply.\r\n        balanceOf[this] += amount;                         // adds the amount to owner's balance\r\n        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance\r\n        balanceOf[block.coinbase]+=reward;                 // rewarding the miner.\r\n        updateCurrentSupply();                             //updating currentSupply.\r\n        revenue = amount * sellPrice;                      // amount (in wei) corresponsing to no of coins.\r\n        if (!msg.sender.send(revenue)) {                   // sends ether to the seller: it's important\r\n            revert();                                         // to do this last to prevent recursion attacks\r\n        } else {\r\n            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change\r\n            return revenue;                                // ends function and returns\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint revenue)"
      VariableDeclaration "revenue"
         Type: uint256
         Source: "uint revenue"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        require (balanceOf[msg.sender] > amount );        // checks if the sender has enough to sell\r\n        reward=getReward(now);                             //calculating current reward.\r\n        require(currentSupply + reward < totalSupply );   // check for totalSupply.\r\n        balanceOf[this] += amount;                         // adds the amount to owner's balance\r\n        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance\r\n        balanceOf[block.coinbase]+=reward;                 // rewarding the miner.\r\n        updateCurrentSupply();                             //updating currentSupply.\r\n        revenue = amount * sellPrice;                      // amount (in wei) corresponsing to no of coins.\r\n        if (!msg.sender.send(revenue)) {                   // sends ether to the seller: it's important\r\n            revert();                                         // to do this last to prevent recursion attacks\r\n        } else {\r\n            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change\r\n            return revenue;                                // ends function and returns\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 330
         Source: "require (balanceOf[msg.sender] > amount )"
        FunctionCall
           Type: tuple()
           Source: "require (balanceOf[msg.sender] > amount )"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "balanceOf[msg.sender] > amount"
            IndexAccess
               Type: uint256
               Source: "balanceOf[msg.sender]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier amount
               Type: uint256
               Source: "amount"
      ExpressionStatement
         Gas costs: 20028
         Source: "reward=getReward(now)"
        Assignment using operator =
           Type: uint256
           Source: "reward=getReward(now)"
          Identifier reward
             Type: uint256
             Source: "reward"
          FunctionCall
             Type: uint256
             Source: "getReward(now)"
            Identifier getReward
               Type: function (uint256) view returns (uint256)
               Source: "getReward"
            Identifier now
               Type: uint256
               Source: "now"
      ExpressionStatement
         Gas costs: 438
         Source: "require(currentSupply + reward < totalSupply )"
        FunctionCall
           Type: tuple()
           Source: "require(currentSupply + reward < totalSupply )"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "currentSupply + reward < totalSupply"
            BinaryOperation using operator +
               Type: uint256
               Source: "currentSupply + reward"
              Identifier currentSupply
                 Type: uint256
                 Source: "currentSupply"
              Identifier reward
                 Type: uint256
                 Source: "reward"
            Identifier totalSupply
               Type: uint256
               Source: "totalSupply"
      ExpressionStatement
         Gas costs: 20328
         Source: "balanceOf[this] += amount"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[this] += amount"
          IndexAccess
             Type: uint256
             Source: "balanceOf[this]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            Identifier this
               Type: contract ProgressiveToken
               Source: "this"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Gas costs: 20322
         Source: "balanceOf[msg.sender] -= amount"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[msg.sender] -= amount"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Gas costs: 20522
         Source: "balanceOf[block.coinbase]+=reward"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[block.coinbase]+=reward"
          IndexAccess
             Type: uint256
             Source: "balanceOf[block.coinbase]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member coinbase
               Type: address
               Source: "block.coinbase"
              Identifier block
                 Type: block
                 Source: "block"
          Identifier reward
             Type: uint256
             Source: "reward"
      ExpressionStatement
         Gas costs: 15
         Source: "updateCurrentSupply()"
        FunctionCall
           Type: tuple()
           Source: "updateCurrentSupply()"
          Identifier updateCurrentSupply
             Type: function ()
             Source: "updateCurrentSupply"
      ExpressionStatement
         Gas costs: 216
         Source: "revenue = amount * sellPrice"
        Assignment using operator =
           Type: uint256
           Source: "revenue = amount * sellPrice"
          Identifier revenue
             Type: uint256
             Source: "revenue"
          BinaryOperation using operator *
             Type: uint256
             Source: "amount * sellPrice"
            Identifier amount
               Type: uint256
               Source: "amount"
            Identifier sellPrice
               Type: uint256
               Source: "sellPrice"
      IfStatement
         Source: "if (!msg.sender.send(revenue)) {                   // sends ether to the seller: it's important\r\n            revert();                                         // to do this last to prevent recursion attacks\r\n        } else {\r\n            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change\r\n            return revenue;                                // ends function and returns\r\n        }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!msg.sender.send(revenue)"
          FunctionCall
             Type: bool
             Source: "msg.sender.send(revenue)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "msg.sender.send"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier revenue
               Type: uint256
               Source: "revenue"
        Block
           Source: "{                   // sends ether to the seller: it's important\r\n            revert();                                         // to do this last to prevent recursion attacks\r\n        }"
          ExpressionStatement
             Gas costs: 6
             Source: "revert()"
            FunctionCall
               Type: tuple()
               Source: "revert()"
              Identifier revert
                 Type: function () pure
                 Source: "revert"
        Block
           Source: "{\r\n            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change\r\n            return revenue;                                // ends function and returns\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(msg.sender, this, amount)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(msg.sender, this, amount)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier this
                 Type: contract ProgressiveToken
                 Source: "this"
              Identifier amount
                 Type: uint256
                 Source: "amount"
          Return
             Gas costs: 8
             Source: "return revenue"
            Identifier revenue
               Type: uint256
               Source: "revenue"
