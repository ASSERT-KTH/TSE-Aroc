Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xf97e0a5b616dffc913e72455fde9ea8bbe946a2b.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.18;"
ContractDefinition "GeneScience"
   Source: "contract GeneScience {\r\n    bool public isGeneScience = true;\r\n\r\n    uint256 internal constant maskLast8Bits = uint256(0xff);\r\n    uint256 internal constant maskFirst248Bits = uint256(~0xff);\r\n\r\n    function GeneScience() public {}\r\n\r\n    /// @dev given a characteristic and 2 genes (unsorted) - returns > 0 if the genes ascended, that's the value\r\n    /// @param trait1 any trait of that characteristic\r\n    /// @param trait2 any trait of that characteristic\r\n    /// @param rand is expected to be a 3 bits number (0~7)\r\n    /// @return -1 if didnt match any ascention, OR a number from 0 to 30 for the ascended trait\r\n    function _ascend(uint8 trait1, uint8 trait2, uint256 rand) internal pure returns(uint8 ascension) {\r\n        ascension = 0;\r\n\r\n        uint8 smallT = trait1;\r\n        uint8 bigT = trait2;\r\n\r\n        if (smallT > bigT) {\r\n            bigT = trait1;\r\n            smallT = trait2;\r\n        }\r\n\r\n        // https://github.com/axiomzen/cryptokitties/issues/244\r\n        if ((bigT - smallT == 1) && smallT % 2 == 0) {\r\n\r\n            // The rand argument is expected to be a random number 0-7.\r\n            // 1st and 2nd tier: 1/4 chance (rand is 0 or 1)\r\n            // 3rd and 4th tier: 1/8 chance (rand is 0)\r\n\r\n            // must be at least this much to ascend\r\n            uint256 maxRand;\r\n            if (smallT < 23) maxRand = 1;\r\n            else maxRand = 0;\r\n\r\n            if (rand <= maxRand ) {\r\n                ascension = (smallT / 2) + 16;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev given a number get a slice of any bits, at certain offset\r\n    /// @param _n a number to be sliced\r\n    /// @param _nbits how many bits long is the new number\r\n    /// @param _offset how many bits to skip\r\n    function _sliceNumber(uint256 _n, uint256 _nbits, uint256 _offset) private pure returns (uint256) {\r\n        // mask is made by shifting left an offset number of times\r\n        uint256 mask = uint256((2**_nbits) - 1) << _offset;\r\n        // AND n with mask, and trim to max of _nbits bits\r\n        return uint256((_n & mask) >> _offset);\r\n    }\r\n\r\n    /// @dev Get a 5 bit slice from an input as a number\r\n    /// @param _input bits, encoded as uint\r\n    /// @param _slot from 0 to 50\r\n    function _get5Bits(uint256 _input, uint256 _slot) internal pure returns(uint8) {\r\n        return uint8(_sliceNumber(_input, uint256(5), _slot * 5));\r\n    }\r\n\r\n    /// @dev Parse a kitten gene and returns all of 12 \"trait stack\" that makes the characteristics\r\n    /// @param _genes kitten gene\r\n    /// @return the 48 traits that composes the genetic code, logically divided in stacks of 4, where only the first trait of each stack may express\r\n    function decode(uint256 _genes) public pure returns(uint8[]) {\r\n        uint8[] memory traits = new uint8[](48);\r\n        uint256 i;\r\n        for(i = 0; i < 48; i++) {\r\n            traits[i] = _get5Bits(_genes, i);\r\n        }\r\n        return traits;\r\n    }\r\n\r\n    /// @dev Given an array of traits return the number that represent genes\r\n    function encode(uint8[] _traits) public pure returns (uint256 _genes) {\r\n        _genes = 0;\r\n        for(uint256 i = 0; i < 48; i++) {\r\n            _genes = _genes << 5;\r\n            // bitwise OR trait with _genes\r\n            _genes = _genes | _traits[47 - i];\r\n        }\r\n        return _genes;\r\n    }\r\n\r\n    /// @dev return the expressing traits\r\n    /// @param _genes the long number expressing cat genes\r\n    function expressingTraits(uint256 _genes) public pure returns(uint8[12]) {\r\n        uint8[12] memory express;\r\n        for(uint256 i = 0; i < 12; i++) {\r\n            express[i] = _get5Bits(_genes, i * 4);\r\n        }\r\n        return express;\r\n    }\r\n\r\n    /// @dev the function as defined in the breeding contract - as defined in CK bible\r\n    function mixGenes(uint256 _genes1, uint256 _genes2, uint256 _targetBlock) public returns (uint256) {\r\n        require(block.number > _targetBlock);\r\n\r\n        // Try to grab the hash of the \"target block\". This should be available the vast\r\n        // majority of the time (it will only fail if no-one calls giveBirth() within 256\r\n        // blocks of the target block, which is about 40 minutes. Since anyone can call\r\n        // giveBirth() and they are rewarded with ether if it succeeds, this is quite unlikely.)\r\n        uint256 randomN = uint256(block.blockhash(_targetBlock));\r\n\r\n        if (randomN == 0) {\r\n            // We don't want to completely bail if the target block is no-longer available,\r\n            // nor do we want to just use the current block's hash (since it could allow a\r\n            // caller to game the random result). Compute the most recent block that has the\r\n            // the same value modulo 256 as the target block. The hash for this block will\r\n            // still be available, and \u2013 while it can still change as time passes \u2013 it will\r\n            // only change every 40 minutes. Again, someone is very likely to jump in with\r\n            // the giveBirth() call before it can cycle too many times.\r\n            _targetBlock = (block.number & maskFirst248Bits) + (_targetBlock & maskLast8Bits);\r\n\r\n            // The computation above could result in a block LARGER than the current block,\r\n            // if so, subtract 256.\r\n            if (_targetBlock >= block.number) _targetBlock -= 256;\r\n\r\n            randomN = uint256(block.blockhash(_targetBlock));\r\n\r\n            // DEBUG ONLY\r\n            // assert(block.number != _targetBlock);\r\n            // assert((block.number - _targetBlock) <= 256);\r\n            // assert(randomN != 0);\r\n        }\r\n\r\n        // generate 256 bits of random, using as much entropy as we can from\r\n        // sources that can't change between calls.\r\n        randomN = uint256(keccak256(randomN, _genes1, _genes2, _targetBlock));\r\n        uint256 randomIndex = 0;\r\n\r\n        uint8[] memory genes1Array = decode(_genes1);\r\n        uint8[] memory genes2Array = decode(_genes2);\r\n        // All traits that will belong to baby\r\n        uint8[] memory babyArray = new uint8[](48);\r\n        // A pointer to the trait we are dealing with currently\r\n        uint256 traitPos;\r\n        // Trait swap value holder\r\n        uint8 swap;\r\n        // iterate all 12 characteristics\r\n        for(uint256 i = 0; i < 12; i++) {\r\n            // pick 4 traits for characteristic i\r\n            uint256 j;\r\n            // store the current random value\r\n            uint256 rand;\r\n            for(j = 3; j >= 1; j--) {\r\n                traitPos = (i * 4) + j;\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                // 1/4 of a chance of gene swapping forward towards expressing.\r\n                if (rand == 0) {\r\n                    // do it for parent 1\r\n                    swap = genes1Array[traitPos];\r\n                    genes1Array[traitPos] = genes1Array[traitPos - 1];\r\n                    genes1Array[traitPos - 1] = swap;\r\n\r\n                }\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                if (rand == 0) {\r\n                    // do it for parent 2\r\n                    swap = genes2Array[traitPos];\r\n                    genes2Array[traitPos] = genes2Array[traitPos - 1];\r\n                    genes2Array[traitPos - 1] = swap;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        // DEBUG ONLY - We should have used 72 2-bit slices above for the swapping\r\n        // which will have consumed 144 bits.\r\n        // assert(randomIndex == 144);\r\n\r\n        // We have 256 - 144 = 112 bits of randomness left at this point. We will use up to\r\n        // four bits for the first slot of each trait (three for the possible ascension, one\r\n        // to pick between mom and dad if the ascension fails, for a total of 48 bits. The other\r\n        // traits use one bit to pick between parents (36 gene pairs, 36 genes), leaving us\r\n        // well within our entropy budget.\r\n\r\n        // done shuffling parent genes, now let's decide on choosing trait and if ascending.\r\n        // NOTE: Ascensions ONLY happen in the \"top slot\" of each characteristic. This saves\r\n        //  gas and also ensures ascensions only happen when they're visible.\r\n        for(traitPos = 0; traitPos < 48; traitPos++) {\r\n\r\n            // See if this trait pair should ascend\r\n            uint8 ascendedTrait = 0;\r\n\r\n            // There are two checks here. The first is straightforward, only the trait\r\n            // in the first slot can ascend. The first slot is zero mod 4.\r\n            //\r\n            // The second check is more subtle: Only values that are one apart can ascend,\r\n            // which is what we check inside the _ascend method. However, this simple mask\r\n            // and compare is very cheap (9 gas) and will filter out about half of the\r\n            // non-ascending pairs without a function call.\r\n            //\r\n            // The comparison itself just checks that one value is even, and the other\r\n            // is odd.\r\n            if ((traitPos % 4 == 0) && (genes1Array[traitPos] & 1) != (genes2Array[traitPos] & 1)) {\r\n                rand = _sliceNumber(randomN, 3, randomIndex);\r\n                randomIndex += 3;\r\n\r\n                ascendedTrait = _ascend(genes1Array[traitPos], genes2Array[traitPos], rand);\r\n            }\r\n\r\n            if (ascendedTrait > 0) {\r\n                babyArray[traitPos] = uint8(ascendedTrait);\r\n            } else {\r\n                // did not ascend, pick one of the parent's traits for the baby\r\n                // We use the top bit of rand for this (the bottom three bits were used\r\n                // to check for the ascension itself).\r\n                rand = _sliceNumber(randomN, 1, randomIndex);\r\n                randomIndex += 1;\r\n\r\n                if (rand == 0) {\r\n                    babyArray[traitPos] = uint8(genes1Array[traitPos]);\r\n                } else {\r\n                    babyArray[traitPos] = uint8(genes2Array[traitPos]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return encode(babyArray);\r\n    }\r\n}"
  VariableDeclaration "isGeneScience"
     Type: bool
     Gas costs: [???]
     Source: "bool public isGeneScience = true"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: true value: true
       Type: bool
       Source: "true"
  VariableDeclaration "maskLast8Bits"
     Type: uint256
     Gas costs: 3
     Source: "uint256 internal constant maskLast8Bits = uint256(0xff)"
    ElementaryTypeName uint256
       Source: "uint256"
    FunctionCall
       Type: uint256
       Source: "uint256(0xff)"
      ElementaryTypeNameExpression uint256
         Type: type(uint256)
         Source: "uint256"
      Literal, token: [no token] value: 0xff
         Type: int_const 255
         Source: "0xff"
  VariableDeclaration "maskFirst248Bits"
     Type: uint256
     Gas costs: 3
     Source: "uint256 internal constant maskFirst248Bits = uint256(~0xff)"
    ElementaryTypeName uint256
       Source: "uint256"
    FunctionCall
       Type: uint256
       Source: "uint256(~0xff)"
      ElementaryTypeNameExpression uint256
         Type: type(uint256)
         Source: "uint256"
      UnaryOperation (prefix) ~
         Type: int_const -256
         Source: "~0xff"
        Literal, token: [no token] value: 0xff
           Type: int_const 255
           Source: "0xff"
  FunctionDefinition "GeneScience" - public
     Source: "function GeneScience() public {}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "_ascend"
     Source: "function _ascend(uint8 trait1, uint8 trait2, uint256 rand) internal pure returns(uint8 ascension) {\r\n        ascension = 0;\r\n\r\n        uint8 smallT = trait1;\r\n        uint8 bigT = trait2;\r\n\r\n        if (smallT > bigT) {\r\n            bigT = trait1;\r\n            smallT = trait2;\r\n        }\r\n\r\n        // https://github.com/axiomzen/cryptokitties/issues/244\r\n        if ((bigT - smallT == 1) && smallT % 2 == 0) {\r\n\r\n            // The rand argument is expected to be a random number 0-7.\r\n            // 1st and 2nd tier: 1/4 chance (rand is 0 or 1)\r\n            // 3rd and 4th tier: 1/8 chance (rand is 0)\r\n\r\n            // must be at least this much to ascend\r\n            uint256 maxRand;\r\n            if (smallT < 23) maxRand = 1;\r\n            else maxRand = 0;\r\n\r\n            if (rand <= maxRand ) {\r\n                ascension = (smallT / 2) + 16;\r\n            }\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint8 trait1, uint8 trait2, uint256 rand)"
      VariableDeclaration "trait1"
         Type: uint8
         Source: "uint8 trait1"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "trait2"
         Type: uint8
         Source: "uint8 trait2"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "rand"
         Type: uint256
         Source: "uint256 rand"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint8 ascension)"
      VariableDeclaration "ascension"
         Type: uint8
         Source: "uint8 ascension"
        ElementaryTypeName uint8
           Source: "uint8"
    Block
       Source: "{\r\n        ascension = 0;\r\n\r\n        uint8 smallT = trait1;\r\n        uint8 bigT = trait2;\r\n\r\n        if (smallT > bigT) {\r\n            bigT = trait1;\r\n            smallT = trait2;\r\n        }\r\n\r\n        // https://github.com/axiomzen/cryptokitties/issues/244\r\n        if ((bigT - smallT == 1) && smallT % 2 == 0) {\r\n\r\n            // The rand argument is expected to be a random number 0-7.\r\n            // 1st and 2nd tier: 1/4 chance (rand is 0 or 1)\r\n            // 3rd and 4th tier: 1/8 chance (rand is 0)\r\n\r\n            // must be at least this much to ascend\r\n            uint256 maxRand;\r\n            if (smallT < 23) maxRand = 1;\r\n            else maxRand = 0;\r\n\r\n            if (rand <= maxRand ) {\r\n                ascension = (smallT / 2) + 16;\r\n            }\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 8
         Source: "ascension = 0"
        Assignment using operator =
           Type: uint8
           Source: "ascension = 0"
          Identifier ascension
             Type: uint8
             Source: "ascension"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint8 smallT = trait1"
        VariableDeclaration "smallT"
           Type: uint8
           Source: "uint8 smallT"
          ElementaryTypeName uint8
             Source: "uint8"
        Identifier trait1
           Type: uint8
           Source: "trait1"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint8 bigT = trait2"
        VariableDeclaration "bigT"
           Type: uint8
           Source: "uint8 bigT"
          ElementaryTypeName uint8
             Source: "uint8"
        Identifier trait2
           Type: uint8
           Source: "trait2"
      IfStatement
         Source: "if (smallT > bigT) {\r\n            bigT = trait1;\r\n            smallT = trait2;\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 21
           Source: "smallT > bigT"
          Identifier smallT
             Type: uint8
             Source: "smallT"
          Identifier bigT
             Type: uint8
             Source: "bigT"
        Block
           Source: "{\r\n            bigT = trait1;\r\n            smallT = trait2;\r\n        }"
          ExpressionStatement
             Gas costs: 8
             Source: "bigT = trait1"
            Assignment using operator =
               Type: uint8
               Source: "bigT = trait1"
              Identifier bigT
                 Type: uint8
                 Source: "bigT"
              Identifier trait1
                 Type: uint8
                 Source: "trait1"
          ExpressionStatement
             Gas costs: 8
             Source: "smallT = trait2"
            Assignment using operator =
               Type: uint8
               Source: "smallT = trait2"
              Identifier smallT
                 Type: uint8
                 Source: "smallT"
              Identifier trait2
                 Type: uint8
                 Source: "trait2"
      IfStatement
         Source: "if ((bigT - smallT == 1) && smallT % 2 == 0) {\r\n\r\n            // The rand argument is expected to be a random number 0-7.\r\n            // 1st and 2nd tier: 1/4 chance (rand is 0 or 1)\r\n            // 3rd and 4th tier: 1/8 chance (rand is 0)\r\n\r\n            // must be at least this much to ascend\r\n            uint256 maxRand;\r\n            if (smallT < 23) maxRand = 1;\r\n            else maxRand = 0;\r\n\r\n            if (rand <= maxRand ) {\r\n                ascension = (smallT / 2) + 16;\r\n            }\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 95
           Source: "(bigT - smallT == 1) && smallT % 2 == 0"
          TupleExpression
             Type: bool
             Source: "(bigT - smallT == 1)"
            BinaryOperation using operator ==
               Type: bool
               Source: "bigT - smallT == 1"
              BinaryOperation using operator -
                 Type: uint8
                 Source: "bigT - smallT"
                Identifier bigT
                   Type: uint8
                   Source: "bigT"
                Identifier smallT
                   Type: uint8
                   Source: "smallT"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          BinaryOperation using operator ==
             Type: bool
             Source: "smallT % 2 == 0"
            BinaryOperation using operator %
               Type: uint8
               Source: "smallT % 2"
              Identifier smallT
                 Type: uint8
                 Source: "smallT"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n\r\n            // The rand argument is expected to be a random number 0-7.\r\n            // 1st and 2nd tier: 1/4 chance (rand is 0 or 1)\r\n            // 3rd and 4th tier: 1/8 chance (rand is 0)\r\n\r\n            // must be at least this much to ascend\r\n            uint256 maxRand;\r\n            if (smallT < 23) maxRand = 1;\r\n            else maxRand = 0;\r\n\r\n            if (rand <= maxRand ) {\r\n                ascension = (smallT / 2) + 16;\r\n            }\r\n        }"
          VariableDeclarationStatement
             Gas costs: 3
             Source: "uint256 maxRand"
            VariableDeclaration "maxRand"
               Type: uint256
               Source: "uint256 maxRand"
              ElementaryTypeName uint256
                 Source: "uint256"
          IfStatement
             Source: "if (smallT < 23) maxRand = 1;\r\n            else maxRand = 0"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 15
               Source: "smallT < 23"
              Identifier smallT
                 Type: uint8
                 Source: "smallT"
              Literal, token: [no token] value: 23
                 Type: int_const 23
                 Source: "23"
            ExpressionStatement
               Gas costs: 8
               Source: "maxRand = 1"
              Assignment using operator =
                 Type: uint256
                 Source: "maxRand = 1"
                Identifier maxRand
                   Type: uint256
                   Source: "maxRand"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
            ExpressionStatement
               Gas costs: 8
               Source: "maxRand = 0"
              Assignment using operator =
                 Type: uint256
                 Source: "maxRand = 0"
                Identifier maxRand
                   Type: uint256
                   Source: "maxRand"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
          IfStatement
             Source: "if (rand <= maxRand ) {\r\n                ascension = (smallT / 2) + 16;\r\n            }"
            BinaryOperation using operator <=
               Type: bool
               Gas costs: 12
               Source: "rand <= maxRand"
              Identifier rand
                 Type: uint256
                 Source: "rand"
              Identifier maxRand
                 Type: uint256
                 Source: "maxRand"
            Block
               Source: "{\r\n                ascension = (smallT / 2) + 16;\r\n            }"
              ExpressionStatement
                 Gas costs: 51
                 Source: "ascension = (smallT / 2) + 16"
                Assignment using operator =
                   Type: uint8
                   Source: "ascension = (smallT / 2) + 16"
                  Identifier ascension
                     Type: uint8
                     Source: "ascension"
                  BinaryOperation using operator +
                     Type: uint8
                     Source: "(smallT / 2) + 16"
                    TupleExpression
                       Type: uint8
                       Source: "(smallT / 2)"
                      BinaryOperation using operator /
                         Type: uint8
                         Source: "smallT / 2"
                        Identifier smallT
                           Type: uint8
                           Source: "smallT"
                        Literal, token: [no token] value: 2
                           Type: int_const 2
                           Source: "2"
                    Literal, token: [no token] value: 16
                       Type: int_const 16
                       Source: "16"
  FunctionDefinition "_sliceNumber"
     Source: "function _sliceNumber(uint256 _n, uint256 _nbits, uint256 _offset) private pure returns (uint256) {\r\n        // mask is made by shifting left an offset number of times\r\n        uint256 mask = uint256((2**_nbits) - 1) << _offset;\r\n        // AND n with mask, and trim to max of _nbits bits\r\n        return uint256((_n & mask) >> _offset);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _n, uint256 _nbits, uint256 _offset)"
      VariableDeclaration "_n"
         Type: uint256
         Source: "uint256 _n"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_nbits"
         Type: uint256
         Source: "uint256 _nbits"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_offset"
         Type: uint256
         Source: "uint256 _offset"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        // mask is made by shifting left an offset number of times\r\n        uint256 mask = uint256((2**_nbits) - 1) << _offset;\r\n        // AND n with mask, and trim to max of _nbits bits\r\n        return uint256((_n & mask) >> _offset);\r\n    }"
      VariableDeclarationStatement
         Gas costs: 3254
         Source: "uint256 mask = uint256((2**_nbits) - 1) << _offset"
        VariableDeclaration "mask"
           Type: uint256
           Source: "uint256 mask"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator <<
           Type: uint256
           Source: "uint256((2**_nbits) - 1) << _offset"
          FunctionCall
             Type: uint256
             Source: "uint256((2**_nbits) - 1)"
            ElementaryTypeNameExpression uint256
               Type: type(uint256)
               Source: "uint256"
            BinaryOperation using operator -
               Type: uint256
               Source: "(2**_nbits) - 1"
              TupleExpression
                 Type: uint256
                 Source: "(2**_nbits)"
                BinaryOperation using operator **
                   Type: uint256
                   Source: "2**_nbits"
                  Literal, token: [no token] value: 2
                     Type: int_const 2
                     Source: "2"
                  Identifier _nbits
                     Type: uint256
                     Source: "_nbits"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          Identifier _offset
             Type: uint256
             Source: "_offset"
      Return
         Gas costs: 1641
         Source: "return uint256((_n & mask) >> _offset)"
        FunctionCall
           Type: uint256
           Source: "uint256((_n & mask) >> _offset)"
          ElementaryTypeNameExpression uint256
             Type: type(uint256)
             Source: "uint256"
          BinaryOperation using operator >>
             Type: uint256
             Source: "(_n & mask) >> _offset"
            TupleExpression
               Type: uint256
               Source: "(_n & mask)"
              BinaryOperation using operator &
                 Type: uint256
                 Source: "_n & mask"
                Identifier _n
                   Type: uint256
                   Source: "_n"
                Identifier mask
                   Type: uint256
                   Source: "mask"
            Identifier _offset
               Type: uint256
               Source: "_offset"
  FunctionDefinition "_get5Bits"
     Source: "function _get5Bits(uint256 _input, uint256 _slot) internal pure returns(uint8) {\r\n        return uint8(_sliceNumber(_input, uint256(5), _slot * 5));\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _input, uint256 _slot)"
      VariableDeclaration "_input"
         Type: uint256
         Source: "uint256 _input"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_slot"
         Type: uint256
         Source: "uint256 _slot"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint8)"
      VariableDeclaration ""
         Type: uint8
         Source: "uint8"
        ElementaryTypeName uint8
           Source: "uint8"
    Block
       Source: "{\r\n        return uint8(_sliceNumber(_input, uint256(5), _slot * 5));\r\n    }"
      Return
         Gas costs: 37
         Source: "return uint8(_sliceNumber(_input, uint256(5), _slot * 5))"
        FunctionCall
           Type: uint8
           Source: "uint8(_sliceNumber(_input, uint256(5), _slot * 5))"
          ElementaryTypeNameExpression uint8
             Type: type(uint8)
             Source: "uint8"
          FunctionCall
             Type: uint256
             Source: "_sliceNumber(_input, uint256(5), _slot * 5)"
            Identifier _sliceNumber
               Type: function (uint256,uint256,uint256) pure returns (uint256)
               Source: "_sliceNumber"
            Identifier _input
               Type: uint256
               Source: "_input"
            FunctionCall
               Type: uint256
               Source: "uint256(5)"
              ElementaryTypeNameExpression uint256
                 Type: type(uint256)
                 Source: "uint256"
              Literal, token: [no token] value: 5
                 Type: int_const 5
                 Source: "5"
            BinaryOperation using operator *
               Type: uint256
               Source: "_slot * 5"
              Identifier _slot
                 Type: uint256
                 Source: "_slot"
              Literal, token: [no token] value: 5
                 Type: int_const 5
                 Source: "5"
  FunctionDefinition "decode" - public
     Source: "function decode(uint256 _genes) public pure returns(uint8[]) {\r\n        uint8[] memory traits = new uint8[](48);\r\n        uint256 i;\r\n        for(i = 0; i < 48; i++) {\r\n            traits[i] = _get5Bits(_genes, i);\r\n        }\r\n        return traits;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _genes)"
      VariableDeclaration "_genes"
         Type: uint256
         Source: "uint256 _genes"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint8[])"
      VariableDeclaration ""
         Type: uint8[] memory
         Source: "uint8[]"
        ArrayTypeName
           Source: "uint8[]"
          ElementaryTypeName uint8
             Source: "uint8"
    Block
       Source: "{\r\n        uint8[] memory traits = new uint8[](48);\r\n        uint256 i;\r\n        for(i = 0; i < 48; i++) {\r\n            traits[i] = _get5Bits(_genes, i);\r\n        }\r\n        return traits;\r\n    }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint8[] memory traits = new uint8[](48)"
        VariableDeclaration "traits"
           Type: uint8[] memory
           Source: "uint8[] memory traits"
          ArrayTypeName
             Source: "uint8[]"
            ElementaryTypeName uint8
               Source: "uint8"
        FunctionCall
           Type: uint8[] memory
           Source: "new uint8[](48)"
          NewExpression
             Type: function (uint256) pure returns (uint8[] memory)
             Source: "new uint8[]"
            ArrayTypeName
               Source: "uint8[]"
              ElementaryTypeName uint8
                 Source: "uint8"
          Literal, token: [no token] value: 48
             Type: int_const 48
             Source: "48"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint256 i"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint256 i"
          ElementaryTypeName uint256
             Source: "uint256"
      ForStatement
         Source: "for(i = 0; i < 48; i++) {\r\n            traits[i] = _get5Bits(_genes, i);\r\n        }"
        ExpressionStatement
           Gas costs: 8
           Source: "i = 0"
          Assignment using operator =
             Type: uint256
             Source: "i = 0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < 48"
          Identifier i
             Type: uint256
             Source: "i"
          Literal, token: [no token] value: 48
             Type: int_const 48
             Source: "48"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            traits[i] = _get5Bits(_genes, i);\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "traits[i] = _get5Bits(_genes, i)"
            Assignment using operator =
               Type: uint8
               Source: "traits[i] = _get5Bits(_genes, i)"
              IndexAccess
                 Type: uint8
                 Source: "traits[i]"
                Identifier traits
                   Type: uint8[] memory
                   Source: "traits"
                Identifier i
                   Type: uint256
                   Source: "i"
              FunctionCall
                 Type: uint8
                 Source: "_get5Bits(_genes, i)"
                Identifier _get5Bits
                   Type: function (uint256,uint256) pure returns (uint8)
                   Source: "_get5Bits"
                Identifier _genes
                   Type: uint256
                   Source: "_genes"
                Identifier i
                   Type: uint256
                   Source: "i"
      Return
         Gas costs: 8
         Source: "return traits"
        Identifier traits
           Type: uint8[] memory
           Source: "traits"
  FunctionDefinition "encode" - public
     Source: "function encode(uint8[] _traits) public pure returns (uint256 _genes) {\r\n        _genes = 0;\r\n        for(uint256 i = 0; i < 48; i++) {\r\n            _genes = _genes << 5;\r\n            // bitwise OR trait with _genes\r\n            _genes = _genes | _traits[47 - i];\r\n        }\r\n        return _genes;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint8[] _traits)"
      VariableDeclaration "_traits"
         Type: uint8[] memory
         Source: "uint8[] _traits"
        ArrayTypeName
           Source: "uint8[]"
          ElementaryTypeName uint8
             Source: "uint8"
    ParameterList
       Gas costs: 3
       Source: "(uint256 _genes)"
      VariableDeclaration "_genes"
         Type: uint256
         Source: "uint256 _genes"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        _genes = 0;\r\n        for(uint256 i = 0; i < 48; i++) {\r\n            _genes = _genes << 5;\r\n            // bitwise OR trait with _genes\r\n            _genes = _genes | _traits[47 - i];\r\n        }\r\n        return _genes;\r\n    }"
      ExpressionStatement
         Gas costs: 8
         Source: "_genes = 0"
        Assignment using operator =
           Type: uint256
           Source: "_genes = 0"
          Identifier _genes
             Type: uint256
             Source: "_genes"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ForStatement
         Source: "for(uint256 i = 0; i < 48; i++) {\r\n            _genes = _genes << 5;\r\n            // bitwise OR trait with _genes\r\n            _genes = _genes | _traits[47 - i];\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint256 i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint256 i"
            ElementaryTypeName uint256
               Source: "uint256"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < 48"
          Identifier i
             Type: uint256
             Source: "i"
          Literal, token: [no token] value: 48
             Type: int_const 48
             Source: "48"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            _genes = _genes << 5;\r\n            // bitwise OR trait with _genes\r\n            _genes = _genes | _traits[47 - i];\r\n        }"
          ExpressionStatement
             Gas costs: 82
             Source: "_genes = _genes << 5"
            Assignment using operator =
               Type: uint256
               Source: "_genes = _genes << 5"
              Identifier _genes
                 Type: uint256
                 Source: "_genes"
              BinaryOperation using operator <<
                 Type: uint256
                 Source: "_genes << 5"
                Identifier _genes
                   Type: uint256
                   Source: "_genes"
                Literal, token: [no token] value: 5
                   Type: int_const 5
                   Source: "5"
          ExpressionStatement
             Gas costs: [???]
             Source: "_genes = _genes | _traits[47 - i]"
            Assignment using operator =
               Type: uint256
               Source: "_genes = _genes | _traits[47 - i]"
              Identifier _genes
                 Type: uint256
                 Source: "_genes"
              BinaryOperation using operator |
                 Type: uint256
                 Source: "_genes | _traits[47 - i]"
                Identifier _genes
                   Type: uint256
                   Source: "_genes"
                IndexAccess
                   Type: uint8
                   Source: "_traits[47 - i]"
                  Identifier _traits
                     Type: uint8[] memory
                     Source: "_traits"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "47 - i"
                    Literal, token: [no token] value: 47
                       Type: int_const 47
                       Source: "47"
                    Identifier i
                       Type: uint256
                       Source: "i"
      Return
         Gas costs: 8
         Source: "return _genes"
        Identifier _genes
           Type: uint256
           Source: "_genes"
  FunctionDefinition "expressingTraits" - public
     Source: "function expressingTraits(uint256 _genes) public pure returns(uint8[12]) {\r\n        uint8[12] memory express;\r\n        for(uint256 i = 0; i < 12; i++) {\r\n            express[i] = _get5Bits(_genes, i * 4);\r\n        }\r\n        return express;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _genes)"
      VariableDeclaration "_genes"
         Type: uint256
         Source: "uint256 _genes"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 4
       Source: "(uint8[12])"
      VariableDeclaration ""
         Type: uint8[12] memory
         Source: "uint8[12]"
        ArrayTypeName
           Source: "uint8[12]"
          ElementaryTypeName uint8
             Source: "uint8"
          Literal, token: [no token] value: 12
             Type unknown.
             Source: "12"
    Block
       Source: "{\r\n        uint8[12] memory express;\r\n        for(uint256 i = 0; i < 12; i++) {\r\n            express[i] = _get5Bits(_genes, i * 4);\r\n        }\r\n        return express;\r\n    }"
      VariableDeclarationStatement
         Gas costs: 15
         Source: "uint8[12] memory express"
        VariableDeclaration "express"
           Type: uint8[12] memory
           Source: "uint8[12] memory express"
          ArrayTypeName
             Source: "uint8[12]"
            ElementaryTypeName uint8
               Source: "uint8"
            Literal, token: [no token] value: 12
               Type unknown.
               Source: "12"
      ForStatement
         Source: "for(uint256 i = 0; i < 12; i++) {\r\n            express[i] = _get5Bits(_genes, i * 4);\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint256 i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint256 i"
            ElementaryTypeName uint256
               Source: "uint256"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < 12"
          Identifier i
             Type: uint256
             Source: "i"
          Literal, token: [no token] value: 12
             Type: int_const 12
             Source: "12"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            express[i] = _get5Bits(_genes, i * 4);\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "express[i] = _get5Bits(_genes, i * 4)"
            Assignment using operator =
               Type: uint8
               Source: "express[i] = _get5Bits(_genes, i * 4)"
              IndexAccess
                 Type: uint8
                 Source: "express[i]"
                Identifier express
                   Type: uint8[12] memory
                   Source: "express"
                Identifier i
                   Type: uint256
                   Source: "i"
              FunctionCall
                 Type: uint8
                 Source: "_get5Bits(_genes, i * 4)"
                Identifier _get5Bits
                   Type: function (uint256,uint256) pure returns (uint8)
                   Source: "_get5Bits"
                Identifier _genes
                   Type: uint256
                   Source: "_genes"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "i * 4"
                  Identifier i
                     Type: uint256
                     Source: "i"
                  Literal, token: [no token] value: 4
                     Type: int_const 4
                     Source: "4"
      Return
         Gas costs: 8
         Source: "return express"
        Identifier express
           Type: uint8[12] memory
           Source: "express"
  FunctionDefinition "mixGenes" - public
     Source: "function mixGenes(uint256 _genes1, uint256 _genes2, uint256 _targetBlock) public returns (uint256) {\r\n        require(block.number > _targetBlock);\r\n\r\n        // Try to grab the hash of the \"target block\". This should be available the vast\r\n        // majority of the time (it will only fail if no-one calls giveBirth() within 256\r\n        // blocks of the target block, which is about 40 minutes. Since anyone can call\r\n        // giveBirth() and they are rewarded with ether if it succeeds, this is quite unlikely.)\r\n        uint256 randomN = uint256(block.blockhash(_targetBlock));\r\n\r\n        if (randomN == 0) {\r\n            // We don't want to completely bail if the target block is no-longer available,\r\n            // nor do we want to just use the current block's hash (since it could allow a\r\n            // caller to game the random result). Compute the most recent block that has the\r\n            // the same value modulo 256 as the target block. The hash for this block will\r\n            // still be available, and \u2013 while it can still change as time passes \u2013 it will\r\n            // only change every 40 minutes. Again, someone is very likely to jump in with\r\n            // the giveBirth() call before it can cycle too many times.\r\n            _targetBlock = (block.number & maskFirst248Bits) + (_targetBlock & maskLast8Bits);\r\n\r\n            // The computation above could result in a block LARGER than the current block,\r\n            // if so, subtract 256.\r\n            if (_targetBlock >= block.number) _targetBlock -= 256;\r\n\r\n            randomN = uint256(block.blockhash(_targetBlock));\r\n\r\n            // DEBUG ONLY\r\n            // assert(block.number != _targetBlock);\r\n            // assert((block.number - _targetBlock) <= 256);\r\n            // assert(randomN != 0);\r\n        }\r\n\r\n        // generate 256 bits of random, using as much entropy as we can from\r\n        // sources that can't change between calls.\r\n        randomN = uint256(keccak256(randomN, _genes1, _genes2, _targetBlock));\r\n        uint256 randomIndex = 0;\r\n\r\n        uint8[] memory genes1Array = decode(_genes1);\r\n        uint8[] memory genes2Array = decode(_genes2);\r\n        // All traits that will belong to baby\r\n        uint8[] memory babyArray = new uint8[](48);\r\n        // A pointer to the trait we are dealing with currently\r\n        uint256 traitPos;\r\n        // Trait swap value holder\r\n        uint8 swap;\r\n        // iterate all 12 characteristics\r\n        for(uint256 i = 0; i < 12; i++) {\r\n            // pick 4 traits for characteristic i\r\n            uint256 j;\r\n            // store the current random value\r\n            uint256 rand;\r\n            for(j = 3; j >= 1; j--) {\r\n                traitPos = (i * 4) + j;\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                // 1/4 of a chance of gene swapping forward towards expressing.\r\n                if (rand == 0) {\r\n                    // do it for parent 1\r\n                    swap = genes1Array[traitPos];\r\n                    genes1Array[traitPos] = genes1Array[traitPos - 1];\r\n                    genes1Array[traitPos - 1] = swap;\r\n\r\n                }\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                if (rand == 0) {\r\n                    // do it for parent 2\r\n                    swap = genes2Array[traitPos];\r\n                    genes2Array[traitPos] = genes2Array[traitPos - 1];\r\n                    genes2Array[traitPos - 1] = swap;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        // DEBUG ONLY - We should have used 72 2-bit slices above for the swapping\r\n        // which will have consumed 144 bits.\r\n        // assert(randomIndex == 144);\r\n\r\n        // We have 256 - 144 = 112 bits of randomness left at this point. We will use up to\r\n        // four bits for the first slot of each trait (three for the possible ascension, one\r\n        // to pick between mom and dad if the ascension fails, for a total of 48 bits. The other\r\n        // traits use one bit to pick between parents (36 gene pairs, 36 genes), leaving us\r\n        // well within our entropy budget.\r\n\r\n        // done shuffling parent genes, now let's decide on choosing trait and if ascending.\r\n        // NOTE: Ascensions ONLY happen in the \"top slot\" of each characteristic. This saves\r\n        //  gas and also ensures ascensions only happen when they're visible.\r\n        for(traitPos = 0; traitPos < 48; traitPos++) {\r\n\r\n            // See if this trait pair should ascend\r\n            uint8 ascendedTrait = 0;\r\n\r\n            // There are two checks here. The first is straightforward, only the trait\r\n            // in the first slot can ascend. The first slot is zero mod 4.\r\n            //\r\n            // The second check is more subtle: Only values that are one apart can ascend,\r\n            // which is what we check inside the _ascend method. However, this simple mask\r\n            // and compare is very cheap (9 gas) and will filter out about half of the\r\n            // non-ascending pairs without a function call.\r\n            //\r\n            // The comparison itself just checks that one value is even, and the other\r\n            // is odd.\r\n            if ((traitPos % 4 == 0) && (genes1Array[traitPos] & 1) != (genes2Array[traitPos] & 1)) {\r\n                rand = _sliceNumber(randomN, 3, randomIndex);\r\n                randomIndex += 3;\r\n\r\n                ascendedTrait = _ascend(genes1Array[traitPos], genes2Array[traitPos], rand);\r\n            }\r\n\r\n            if (ascendedTrait > 0) {\r\n                babyArray[traitPos] = uint8(ascendedTrait);\r\n            } else {\r\n                // did not ascend, pick one of the parent's traits for the baby\r\n                // We use the top bit of rand for this (the bottom three bits were used\r\n                // to check for the ascension itself).\r\n                rand = _sliceNumber(randomN, 1, randomIndex);\r\n                randomIndex += 1;\r\n\r\n                if (rand == 0) {\r\n                    babyArray[traitPos] = uint8(genes1Array[traitPos]);\r\n                } else {\r\n                    babyArray[traitPos] = uint8(genes2Array[traitPos]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return encode(babyArray);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _genes1, uint256 _genes2, uint256 _targetBlock)"
      VariableDeclaration "_genes1"
         Type: uint256
         Source: "uint256 _genes1"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_genes2"
         Type: uint256
         Source: "uint256 _genes2"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_targetBlock"
         Type: uint256
         Source: "uint256 _targetBlock"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        require(block.number > _targetBlock);\r\n\r\n        // Try to grab the hash of the \"target block\". This should be available the vast\r\n        // majority of the time (it will only fail if no-one calls giveBirth() within 256\r\n        // blocks of the target block, which is about 40 minutes. Since anyone can call\r\n        // giveBirth() and they are rewarded with ether if it succeeds, this is quite unlikely.)\r\n        uint256 randomN = uint256(block.blockhash(_targetBlock));\r\n\r\n        if (randomN == 0) {\r\n            // We don't want to completely bail if the target block is no-longer available,\r\n            // nor do we want to just use the current block's hash (since it could allow a\r\n            // caller to game the random result). Compute the most recent block that has the\r\n            // the same value modulo 256 as the target block. The hash for this block will\r\n            // still be available, and \u2013 while it can still change as time passes \u2013 it will\r\n            // only change every 40 minutes. Again, someone is very likely to jump in with\r\n            // the giveBirth() call before it can cycle too many times.\r\n            _targetBlock = (block.number & maskFirst248Bits) + (_targetBlock & maskLast8Bits);\r\n\r\n            // The computation above could result in a block LARGER than the current block,\r\n            // if so, subtract 256.\r\n            if (_targetBlock >= block.number) _targetBlock -= 256;\r\n\r\n            randomN = uint256(block.blockhash(_targetBlock));\r\n\r\n            // DEBUG ONLY\r\n            // assert(block.number != _targetBlock);\r\n            // assert((block.number - _targetBlock) <= 256);\r\n            // assert(randomN != 0);\r\n        }\r\n\r\n        // generate 256 bits of random, using as much entropy as we can from\r\n        // sources that can't change between calls.\r\n        randomN = uint256(keccak256(randomN, _genes1, _genes2, _targetBlock));\r\n        uint256 randomIndex = 0;\r\n\r\n        uint8[] memory genes1Array = decode(_genes1);\r\n        uint8[] memory genes2Array = decode(_genes2);\r\n        // All traits that will belong to baby\r\n        uint8[] memory babyArray = new uint8[](48);\r\n        // A pointer to the trait we are dealing with currently\r\n        uint256 traitPos;\r\n        // Trait swap value holder\r\n        uint8 swap;\r\n        // iterate all 12 characteristics\r\n        for(uint256 i = 0; i < 12; i++) {\r\n            // pick 4 traits for characteristic i\r\n            uint256 j;\r\n            // store the current random value\r\n            uint256 rand;\r\n            for(j = 3; j >= 1; j--) {\r\n                traitPos = (i * 4) + j;\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                // 1/4 of a chance of gene swapping forward towards expressing.\r\n                if (rand == 0) {\r\n                    // do it for parent 1\r\n                    swap = genes1Array[traitPos];\r\n                    genes1Array[traitPos] = genes1Array[traitPos - 1];\r\n                    genes1Array[traitPos - 1] = swap;\r\n\r\n                }\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                if (rand == 0) {\r\n                    // do it for parent 2\r\n                    swap = genes2Array[traitPos];\r\n                    genes2Array[traitPos] = genes2Array[traitPos - 1];\r\n                    genes2Array[traitPos - 1] = swap;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        // DEBUG ONLY - We should have used 72 2-bit slices above for the swapping\r\n        // which will have consumed 144 bits.\r\n        // assert(randomIndex == 144);\r\n\r\n        // We have 256 - 144 = 112 bits of randomness left at this point. We will use up to\r\n        // four bits for the first slot of each trait (three for the possible ascension, one\r\n        // to pick between mom and dad if the ascension fails, for a total of 48 bits. The other\r\n        // traits use one bit to pick between parents (36 gene pairs, 36 genes), leaving us\r\n        // well within our entropy budget.\r\n\r\n        // done shuffling parent genes, now let's decide on choosing trait and if ascending.\r\n        // NOTE: Ascensions ONLY happen in the \"top slot\" of each characteristic. This saves\r\n        //  gas and also ensures ascensions only happen when they're visible.\r\n        for(traitPos = 0; traitPos < 48; traitPos++) {\r\n\r\n            // See if this trait pair should ascend\r\n            uint8 ascendedTrait = 0;\r\n\r\n            // There are two checks here. The first is straightforward, only the trait\r\n            // in the first slot can ascend. The first slot is zero mod 4.\r\n            //\r\n            // The second check is more subtle: Only values that are one apart can ascend,\r\n            // which is what we check inside the _ascend method. However, this simple mask\r\n            // and compare is very cheap (9 gas) and will filter out about half of the\r\n            // non-ascending pairs without a function call.\r\n            //\r\n            // The comparison itself just checks that one value is even, and the other\r\n            // is odd.\r\n            if ((traitPos % 4 == 0) && (genes1Array[traitPos] & 1) != (genes2Array[traitPos] & 1)) {\r\n                rand = _sliceNumber(randomN, 3, randomIndex);\r\n                randomIndex += 3;\r\n\r\n                ascendedTrait = _ascend(genes1Array[traitPos], genes2Array[traitPos], rand);\r\n            }\r\n\r\n            if (ascendedTrait > 0) {\r\n                babyArray[traitPos] = uint8(ascendedTrait);\r\n            } else {\r\n                // did not ascend, pick one of the parent's traits for the baby\r\n                // We use the top bit of rand for this (the bottom three bits were used\r\n                // to check for the ascension itself).\r\n                rand = _sliceNumber(randomN, 1, randomIndex);\r\n                randomIndex += 1;\r\n\r\n                if (rand == 0) {\r\n                    babyArray[traitPos] = uint8(genes1Array[traitPos]);\r\n                } else {\r\n                    babyArray[traitPos] = uint8(genes2Array[traitPos]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return encode(babyArray);\r\n    }"
      ExpressionStatement
         Gas costs: 34
         Source: "require(block.number > _targetBlock)"
        FunctionCall
           Type: tuple()
           Source: "require(block.number > _targetBlock)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "block.number > _targetBlock"
            MemberAccess to member number
               Type: uint256
               Source: "block.number"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier _targetBlock
               Type: uint256
               Source: "_targetBlock"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint256 randomN = uint256(block.blockhash(_targetBlock))"
        VariableDeclaration "randomN"
           Type: uint256
           Source: "uint256 randomN"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "uint256(block.blockhash(_targetBlock))"
          ElementaryTypeNameExpression uint256
             Type: type(uint256)
             Source: "uint256"
          FunctionCall
             Type: bytes32
             Source: "block.blockhash(_targetBlock)"
            MemberAccess to member blockhash
               Type: function (uint256) view returns (bytes32)
               Source: "block.blockhash"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier _targetBlock
               Type: uint256
               Source: "_targetBlock"
      IfStatement
         Source: "if (randomN == 0) {\r\n            // We don't want to completely bail if the target block is no-longer available,\r\n            // nor do we want to just use the current block's hash (since it could allow a\r\n            // caller to game the random result). Compute the most recent block that has the\r\n            // the same value modulo 256 as the target block. The hash for this block will\r\n            // still be available, and \u2013 while it can still change as time passes \u2013 it will\r\n            // only change every 40 minutes. Again, someone is very likely to jump in with\r\n            // the giveBirth() call before it can cycle too many times.\r\n            _targetBlock = (block.number & maskFirst248Bits) + (_targetBlock & maskLast8Bits);\r\n\r\n            // The computation above could result in a block LARGER than the current block,\r\n            // if so, subtract 256.\r\n            if (_targetBlock >= block.number) _targetBlock -= 256;\r\n\r\n            randomN = uint256(block.blockhash(_targetBlock));\r\n\r\n            // DEBUG ONLY\r\n            // assert(block.number != _targetBlock);\r\n            // assert((block.number - _targetBlock) <= 256);\r\n            // assert(randomN != 0);\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "randomN == 0"
          Identifier randomN
             Type: uint256
             Source: "randomN"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            // We don't want to completely bail if the target block is no-longer available,\r\n            // nor do we want to just use the current block's hash (since it could allow a\r\n            // caller to game the random result). Compute the most recent block that has the\r\n            // the same value modulo 256 as the target block. The hash for this block will\r\n            // still be available, and \u2013 while it can still change as time passes \u2013 it will\r\n            // only change every 40 minutes. Again, someone is very likely to jump in with\r\n            // the giveBirth() call before it can cycle too many times.\r\n            _targetBlock = (block.number & maskFirst248Bits) + (_targetBlock & maskLast8Bits);\r\n\r\n            // The computation above could result in a block LARGER than the current block,\r\n            // if so, subtract 256.\r\n            if (_targetBlock >= block.number) _targetBlock -= 256;\r\n\r\n            randomN = uint256(block.blockhash(_targetBlock));\r\n\r\n            // DEBUG ONLY\r\n            // assert(block.number != _targetBlock);\r\n            // assert((block.number - _targetBlock) <= 256);\r\n            // assert(randomN != 0);\r\n        }"
          ExpressionStatement
             Gas costs: 19
             Source: "_targetBlock = (block.number & maskFirst248Bits) + (_targetBlock & maskLast8Bits)"
            Assignment using operator =
               Type: uint256
               Source: "_targetBlock = (block.number & maskFirst248Bits) + (_targetBlock & maskLast8Bits)"
              Identifier _targetBlock
                 Type: uint256
                 Source: "_targetBlock"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "(block.number & maskFirst248Bits) + (_targetBlock & maskLast8Bits)"
                TupleExpression
                   Type: uint256
                   Source: "(block.number & maskFirst248Bits)"
                  BinaryOperation using operator &
                     Type: uint256
                     Source: "block.number & maskFirst248Bits"
                    MemberAccess to member number
                       Type: uint256
                       Source: "block.number"
                      Identifier block
                         Type: block
                         Source: "block"
                    Identifier maskFirst248Bits
                       Type: uint256
                       Source: "maskFirst248Bits"
                TupleExpression
                   Type: uint256
                   Source: "(_targetBlock & maskLast8Bits)"
                  BinaryOperation using operator &
                     Type: uint256
                     Source: "_targetBlock & maskLast8Bits"
                    Identifier _targetBlock
                       Type: uint256
                       Source: "_targetBlock"
                    Identifier maskLast8Bits
                       Type: uint256
                       Source: "maskLast8Bits"
          IfStatement
             Source: "if (_targetBlock >= block.number) _targetBlock -= 256"
            BinaryOperation using operator >=
               Type: bool
               Gas costs: 11
               Source: "_targetBlock >= block.number"
              Identifier _targetBlock
                 Type: uint256
                 Source: "_targetBlock"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
            ExpressionStatement
               Gas costs: 14
               Source: "_targetBlock -= 256"
              Assignment using operator -=
                 Type: uint256
                 Source: "_targetBlock -= 256"
                Identifier _targetBlock
                   Type: uint256
                   Source: "_targetBlock"
                Literal, token: [no token] value: 256
                   Type: int_const 256
                   Source: "256"
          ExpressionStatement
             Gas costs: 39
             Source: "randomN = uint256(block.blockhash(_targetBlock))"
            Assignment using operator =
               Type: uint256
               Source: "randomN = uint256(block.blockhash(_targetBlock))"
              Identifier randomN
                 Type: uint256
                 Source: "randomN"
              FunctionCall
                 Type: uint256
                 Source: "uint256(block.blockhash(_targetBlock))"
                ElementaryTypeNameExpression uint256
                   Type: type(uint256)
                   Source: "uint256"
                FunctionCall
                   Type: bytes32
                   Source: "block.blockhash(_targetBlock)"
                  MemberAccess to member blockhash
                     Type: function (uint256) view returns (bytes32)
                     Source: "block.blockhash"
                    Identifier block
                       Type: block
                       Source: "block"
                  Identifier _targetBlock
                     Type: uint256
                     Source: "_targetBlock"
      ExpressionStatement
         Gas costs: [???]
         Source: "randomN = uint256(keccak256(randomN, _genes1, _genes2, _targetBlock))"
        Assignment using operator =
           Type: uint256
           Source: "randomN = uint256(keccak256(randomN, _genes1, _genes2, _targetBlock))"
          Identifier randomN
             Type: uint256
             Source: "randomN"
          FunctionCall
             Type: uint256
             Source: "uint256(keccak256(randomN, _genes1, _genes2, _targetBlock))"
            ElementaryTypeNameExpression uint256
               Type: type(uint256)
               Source: "uint256"
            FunctionCall
               Type: bytes32
               Source: "keccak256(randomN, _genes1, _genes2, _targetBlock)"
              Identifier keccak256
                 Type: function () pure returns (bytes32)
                 Source: "keccak256"
              Identifier randomN
                 Type: uint256
                 Source: "randomN"
              Identifier _genes1
                 Type: uint256
                 Source: "_genes1"
              Identifier _genes2
                 Type: uint256
                 Source: "_genes2"
              Identifier _targetBlock
                 Type: uint256
                 Source: "_targetBlock"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint256 randomIndex = 0"
        VariableDeclaration "randomIndex"
           Type: uint256
           Source: "uint256 randomIndex"
          ElementaryTypeName uint256
             Source: "uint256"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint8[] memory genes1Array = decode(_genes1)"
        VariableDeclaration "genes1Array"
           Type: uint8[] memory
           Source: "uint8[] memory genes1Array"
          ArrayTypeName
             Source: "uint8[]"
            ElementaryTypeName uint8
               Source: "uint8"
        FunctionCall
           Type: uint8[] memory
           Source: "decode(_genes1)"
          Identifier decode
             Type: function (uint256) pure returns (uint8[] memory)
             Source: "decode"
          Identifier _genes1
             Type: uint256
             Source: "_genes1"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "uint8[] memory genes2Array = decode(_genes2)"
        VariableDeclaration "genes2Array"
           Type: uint8[] memory
           Source: "uint8[] memory genes2Array"
          ArrayTypeName
             Source: "uint8[]"
            ElementaryTypeName uint8
               Source: "uint8"
        FunctionCall
           Type: uint8[] memory
           Source: "decode(_genes2)"
          Identifier decode
             Type: function (uint256) pure returns (uint8[] memory)
             Source: "decode"
          Identifier _genes2
             Type: uint256
             Source: "_genes2"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "uint8[] memory babyArray = new uint8[](48)"
        VariableDeclaration "babyArray"
           Type: uint8[] memory
           Source: "uint8[] memory babyArray"
          ArrayTypeName
             Source: "uint8[]"
            ElementaryTypeName uint8
               Source: "uint8"
        FunctionCall
           Type: uint8[] memory
           Source: "new uint8[](48)"
          NewExpression
             Type: function (uint256) pure returns (uint8[] memory)
             Source: "new uint8[]"
            ArrayTypeName
               Source: "uint8[]"
              ElementaryTypeName uint8
                 Source: "uint8"
          Literal, token: [no token] value: 48
             Type: int_const 48
             Source: "48"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint256 traitPos"
        VariableDeclaration "traitPos"
           Type: uint256
           Source: "uint256 traitPos"
          ElementaryTypeName uint256
             Source: "uint256"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint8 swap"
        VariableDeclaration "swap"
           Type: uint8
           Source: "uint8 swap"
          ElementaryTypeName uint8
             Source: "uint8"
      ForStatement
         Source: "for(uint256 i = 0; i < 12; i++) {\r\n            // pick 4 traits for characteristic i\r\n            uint256 j;\r\n            // store the current random value\r\n            uint256 rand;\r\n            for(j = 3; j >= 1; j--) {\r\n                traitPos = (i * 4) + j;\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                // 1/4 of a chance of gene swapping forward towards expressing.\r\n                if (rand == 0) {\r\n                    // do it for parent 1\r\n                    swap = genes1Array[traitPos];\r\n                    genes1Array[traitPos] = genes1Array[traitPos - 1];\r\n                    genes1Array[traitPos - 1] = swap;\r\n\r\n                }\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                if (rand == 0) {\r\n                    // do it for parent 2\r\n                    swap = genes2Array[traitPos];\r\n                    genes2Array[traitPos] = genes2Array[traitPos - 1];\r\n                    genes2Array[traitPos - 1] = swap;\r\n                }\r\n            }\r\n\r\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint256 i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint256 i"
            ElementaryTypeName uint256
               Source: "uint256"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "i < 12"
          Identifier i
             Type: uint256
             Source: "i"
          Literal, token: [no token] value: 12
             Type: int_const 12
             Source: "12"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            // pick 4 traits for characteristic i\r\n            uint256 j;\r\n            // store the current random value\r\n            uint256 rand;\r\n            for(j = 3; j >= 1; j--) {\r\n                traitPos = (i * 4) + j;\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                // 1/4 of a chance of gene swapping forward towards expressing.\r\n                if (rand == 0) {\r\n                    // do it for parent 1\r\n                    swap = genes1Array[traitPos];\r\n                    genes1Array[traitPos] = genes1Array[traitPos - 1];\r\n                    genes1Array[traitPos - 1] = swap;\r\n\r\n                }\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                if (rand == 0) {\r\n                    // do it for parent 2\r\n                    swap = genes2Array[traitPos];\r\n                    genes2Array[traitPos] = genes2Array[traitPos - 1];\r\n                    genes2Array[traitPos - 1] = swap;\r\n                }\r\n            }\r\n\r\n        }"
          VariableDeclarationStatement
             Gas costs: 3
             Source: "uint256 j"
            VariableDeclaration "j"
               Type: uint256
               Source: "uint256 j"
              ElementaryTypeName uint256
                 Source: "uint256"
          VariableDeclarationStatement
             Gas costs: 3
             Source: "uint256 rand"
            VariableDeclaration "rand"
               Type: uint256
               Source: "uint256 rand"
              ElementaryTypeName uint256
                 Source: "uint256"
          ForStatement
             Source: "for(j = 3; j >= 1; j--) {\r\n                traitPos = (i * 4) + j;\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                // 1/4 of a chance of gene swapping forward towards expressing.\r\n                if (rand == 0) {\r\n                    // do it for parent 1\r\n                    swap = genes1Array[traitPos];\r\n                    genes1Array[traitPos] = genes1Array[traitPos - 1];\r\n                    genes1Array[traitPos - 1] = swap;\r\n\r\n                }\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                if (rand == 0) {\r\n                    // do it for parent 2\r\n                    swap = genes2Array[traitPos];\r\n                    genes2Array[traitPos] = genes2Array[traitPos - 1];\r\n                    genes2Array[traitPos - 1] = swap;\r\n                }\r\n            }"
            ExpressionStatement
               Gas costs: 8
               Source: "j = 3"
              Assignment using operator =
                 Type: uint256
                 Source: "j = 3"
                Identifier j
                   Type: uint256
                   Source: "j"
                Literal, token: [no token] value: 3
                   Type: int_const 3
                   Source: "3"
            BinaryOperation using operator >=
               Type: bool
               Gas costs: 12
               Source: "j >= 1"
              Identifier j
                 Type: uint256
                 Source: "j"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            ExpressionStatement
               Gas costs: 22
               Source: "j--"
              UnaryOperation (postfix) --
                 Type: uint256
                 Source: "j--"
                Identifier j
                   Type: uint256
                   Source: "j"
            Block
               Source: "{\r\n                traitPos = (i * 4) + j;\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                // 1/4 of a chance of gene swapping forward towards expressing.\r\n                if (rand == 0) {\r\n                    // do it for parent 1\r\n                    swap = genes1Array[traitPos];\r\n                    genes1Array[traitPos] = genes1Array[traitPos - 1];\r\n                    genes1Array[traitPos - 1] = swap;\r\n\r\n                }\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                if (rand == 0) {\r\n                    // do it for parent 2\r\n                    swap = genes2Array[traitPos];\r\n                    genes2Array[traitPos] = genes2Array[traitPos - 1];\r\n                    genes2Array[traitPos - 1] = swap;\r\n                }\r\n            }"
              ExpressionStatement
                 Gas costs: 22
                 Source: "traitPos = (i * 4) + j"
                Assignment using operator =
                   Type: uint256
                   Source: "traitPos = (i * 4) + j"
                  Identifier traitPos
                     Type: uint256
                     Source: "traitPos"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "(i * 4) + j"
                    TupleExpression
                       Type: uint256
                       Source: "(i * 4)"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "i * 4"
                        Identifier i
                           Type: uint256
                           Source: "i"
                        Literal, token: [no token] value: 4
                           Type: int_const 4
                           Source: "4"
                    Identifier j
                       Type: uint256
                       Source: "j"
              ExpressionStatement
                 Gas costs: 29
                 Source: "rand = _sliceNumber(randomN, 2, randomIndex)"
                Assignment using operator =
                   Type: uint256
                   Source: "rand = _sliceNumber(randomN, 2, randomIndex)"
                  Identifier rand
                     Type: uint256
                     Source: "rand"
                  FunctionCall
                     Type: uint256
                     Source: "_sliceNumber(randomN, 2, randomIndex)"
                    Identifier _sliceNumber
                       Type: function (uint256,uint256,uint256) pure returns (uint256)
                       Source: "_sliceNumber"
                    Identifier randomN
                       Type: uint256
                       Source: "randomN"
                    Literal, token: [no token] value: 2
                       Type: int_const 2
                       Source: "2"
                    Identifier randomIndex
                       Type: uint256
                       Source: "randomIndex"
              ExpressionStatement
                 Gas costs: 14
                 Source: "randomIndex += 2"
                Assignment using operator +=
                   Type: uint256
                   Source: "randomIndex += 2"
                  Identifier randomIndex
                     Type: uint256
                     Source: "randomIndex"
                  Literal, token: [no token] value: 2
                     Type: int_const 2
                     Source: "2"
              IfStatement
                 Source: "if (rand == 0) {\r\n                    // do it for parent 1\r\n                    swap = genes1Array[traitPos];\r\n                    genes1Array[traitPos] = genes1Array[traitPos - 1];\r\n                    genes1Array[traitPos - 1] = swap;\r\n\r\n                }"
                BinaryOperation using operator ==
                   Type: bool
                   Gas costs: 9
                   Source: "rand == 0"
                  Identifier rand
                     Type: uint256
                     Source: "rand"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                Block
                   Source: "{\r\n                    // do it for parent 1\r\n                    swap = genes1Array[traitPos];\r\n                    genes1Array[traitPos] = genes1Array[traitPos - 1];\r\n                    genes1Array[traitPos - 1] = swap;\r\n\r\n                }"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "swap = genes1Array[traitPos]"
                    Assignment using operator =
                       Type: uint8
                       Source: "swap = genes1Array[traitPos]"
                      Identifier swap
                         Type: uint8
                         Source: "swap"
                      IndexAccess
                         Type: uint8
                         Source: "genes1Array[traitPos]"
                        Identifier genes1Array
                           Type: uint8[] memory
                           Source: "genes1Array"
                        Identifier traitPos
                           Type: uint256
                           Source: "traitPos"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "genes1Array[traitPos] = genes1Array[traitPos - 1]"
                    Assignment using operator =
                       Type: uint8
                       Source: "genes1Array[traitPos] = genes1Array[traitPos - 1]"
                      IndexAccess
                         Type: uint8
                         Source: "genes1Array[traitPos]"
                        Identifier genes1Array
                           Type: uint8[] memory
                           Source: "genes1Array"
                        Identifier traitPos
                           Type: uint256
                           Source: "traitPos"
                      IndexAccess
                         Type: uint8
                         Source: "genes1Array[traitPos - 1]"
                        Identifier genes1Array
                           Type: uint8[] memory
                           Source: "genes1Array"
                        BinaryOperation using operator -
                           Type: uint256
                           Source: "traitPos - 1"
                          Identifier traitPos
                             Type: uint256
                             Source: "traitPos"
                          Literal, token: [no token] value: 1
                             Type: int_const 1
                             Source: "1"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "genes1Array[traitPos - 1] = swap"
                    Assignment using operator =
                       Type: uint8
                       Source: "genes1Array[traitPos - 1] = swap"
                      IndexAccess
                         Type: uint8
                         Source: "genes1Array[traitPos - 1]"
                        Identifier genes1Array
                           Type: uint8[] memory
                           Source: "genes1Array"
                        BinaryOperation using operator -
                           Type: uint256
                           Source: "traitPos - 1"
                          Identifier traitPos
                             Type: uint256
                             Source: "traitPos"
                          Literal, token: [no token] value: 1
                             Type: int_const 1
                             Source: "1"
                      Identifier swap
                         Type: uint8
                         Source: "swap"
              ExpressionStatement
                 Gas costs: 18
                 Source: "rand = _sliceNumber(randomN, 2, randomIndex)"
                Assignment using operator =
                   Type: uint256
                   Source: "rand = _sliceNumber(randomN, 2, randomIndex)"
                  Identifier rand
                     Type: uint256
                     Source: "rand"
                  FunctionCall
                     Type: uint256
                     Source: "_sliceNumber(randomN, 2, randomIndex)"
                    Identifier _sliceNumber
                       Type: function (uint256,uint256,uint256) pure returns (uint256)
                       Source: "_sliceNumber"
                    Identifier randomN
                       Type: uint256
                       Source: "randomN"
                    Literal, token: [no token] value: 2
                       Type: int_const 2
                       Source: "2"
                    Identifier randomIndex
                       Type: uint256
                       Source: "randomIndex"
              ExpressionStatement
                 Gas costs: 14
                 Source: "randomIndex += 2"
                Assignment using operator +=
                   Type: uint256
                   Source: "randomIndex += 2"
                  Identifier randomIndex
                     Type: uint256
                     Source: "randomIndex"
                  Literal, token: [no token] value: 2
                     Type: int_const 2
                     Source: "2"
              IfStatement
                 Source: "if (rand == 0) {\r\n                    // do it for parent 2\r\n                    swap = genes2Array[traitPos];\r\n                    genes2Array[traitPos] = genes2Array[traitPos - 1];\r\n                    genes2Array[traitPos - 1] = swap;\r\n                }"
                BinaryOperation using operator ==
                   Type: bool
                   Gas costs: 9
                   Source: "rand == 0"
                  Identifier rand
                     Type: uint256
                     Source: "rand"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                Block
                   Source: "{\r\n                    // do it for parent 2\r\n                    swap = genes2Array[traitPos];\r\n                    genes2Array[traitPos] = genes2Array[traitPos - 1];\r\n                    genes2Array[traitPos - 1] = swap;\r\n                }"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "swap = genes2Array[traitPos]"
                    Assignment using operator =
                       Type: uint8
                       Source: "swap = genes2Array[traitPos]"
                      Identifier swap
                         Type: uint8
                         Source: "swap"
                      IndexAccess
                         Type: uint8
                         Source: "genes2Array[traitPos]"
                        Identifier genes2Array
                           Type: uint8[] memory
                           Source: "genes2Array"
                        Identifier traitPos
                           Type: uint256
                           Source: "traitPos"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "genes2Array[traitPos] = genes2Array[traitPos - 1]"
                    Assignment using operator =
                       Type: uint8
                       Source: "genes2Array[traitPos] = genes2Array[traitPos - 1]"
                      IndexAccess
                         Type: uint8
                         Source: "genes2Array[traitPos]"
                        Identifier genes2Array
                           Type: uint8[] memory
                           Source: "genes2Array"
                        Identifier traitPos
                           Type: uint256
                           Source: "traitPos"
                      IndexAccess
                         Type: uint8
                         Source: "genes2Array[traitPos - 1]"
                        Identifier genes2Array
                           Type: uint8[] memory
                           Source: "genes2Array"
                        BinaryOperation using operator -
                           Type: uint256
                           Source: "traitPos - 1"
                          Identifier traitPos
                             Type: uint256
                             Source: "traitPos"
                          Literal, token: [no token] value: 1
                             Type: int_const 1
                             Source: "1"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "genes2Array[traitPos - 1] = swap"
                    Assignment using operator =
                       Type: uint8
                       Source: "genes2Array[traitPos - 1] = swap"
                      IndexAccess
                         Type: uint8
                         Source: "genes2Array[traitPos - 1]"
                        Identifier genes2Array
                           Type: uint8[] memory
                           Source: "genes2Array"
                        BinaryOperation using operator -
                           Type: uint256
                           Source: "traitPos - 1"
                          Identifier traitPos
                             Type: uint256
                             Source: "traitPos"
                          Literal, token: [no token] value: 1
                             Type: int_const 1
                             Source: "1"
                      Identifier swap
                         Type: uint8
                         Source: "swap"
      ForStatement
         Source: "for(traitPos = 0; traitPos < 48; traitPos++) {\r\n\r\n            // See if this trait pair should ascend\r\n            uint8 ascendedTrait = 0;\r\n\r\n            // There are two checks here. The first is straightforward, only the trait\r\n            // in the first slot can ascend. The first slot is zero mod 4.\r\n            //\r\n            // The second check is more subtle: Only values that are one apart can ascend,\r\n            // which is what we check inside the _ascend method. However, this simple mask\r\n            // and compare is very cheap (9 gas) and will filter out about half of the\r\n            // non-ascending pairs without a function call.\r\n            //\r\n            // The comparison itself just checks that one value is even, and the other\r\n            // is odd.\r\n            if ((traitPos % 4 == 0) && (genes1Array[traitPos] & 1) != (genes2Array[traitPos] & 1)) {\r\n                rand = _sliceNumber(randomN, 3, randomIndex);\r\n                randomIndex += 3;\r\n\r\n                ascendedTrait = _ascend(genes1Array[traitPos], genes2Array[traitPos], rand);\r\n            }\r\n\r\n            if (ascendedTrait > 0) {\r\n                babyArray[traitPos] = uint8(ascendedTrait);\r\n            } else {\r\n                // did not ascend, pick one of the parent's traits for the baby\r\n                // We use the top bit of rand for this (the bottom three bits were used\r\n                // to check for the ascension itself).\r\n                rand = _sliceNumber(randomN, 1, randomIndex);\r\n                randomIndex += 1;\r\n\r\n                if (rand == 0) {\r\n                    babyArray[traitPos] = uint8(genes1Array[traitPos]);\r\n                } else {\r\n                    babyArray[traitPos] = uint8(genes2Array[traitPos]);\r\n                }\r\n            }\r\n        }"
        ExpressionStatement
           Gas costs: 8
           Source: "traitPos = 0"
          Assignment using operator =
             Type: uint256
             Source: "traitPos = 0"
            Identifier traitPos
               Type: uint256
               Source: "traitPos"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "traitPos < 48"
          Identifier traitPos
             Type: uint256
             Source: "traitPos"
          Literal, token: [no token] value: 48
             Type: int_const 48
             Source: "48"
        ExpressionStatement
           Gas costs: 19
           Source: "traitPos++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "traitPos++"
            Identifier traitPos
               Type: uint256
               Source: "traitPos"
        Block
           Source: "{\r\n\r\n            // See if this trait pair should ascend\r\n            uint8 ascendedTrait = 0;\r\n\r\n            // There are two checks here. The first is straightforward, only the trait\r\n            // in the first slot can ascend. The first slot is zero mod 4.\r\n            //\r\n            // The second check is more subtle: Only values that are one apart can ascend,\r\n            // which is what we check inside the _ascend method. However, this simple mask\r\n            // and compare is very cheap (9 gas) and will filter out about half of the\r\n            // non-ascending pairs without a function call.\r\n            //\r\n            // The comparison itself just checks that one value is even, and the other\r\n            // is odd.\r\n            if ((traitPos % 4 == 0) && (genes1Array[traitPos] & 1) != (genes2Array[traitPos] & 1)) {\r\n                rand = _sliceNumber(randomN, 3, randomIndex);\r\n                randomIndex += 3;\r\n\r\n                ascendedTrait = _ascend(genes1Array[traitPos], genes2Array[traitPos], rand);\r\n            }\r\n\r\n            if (ascendedTrait > 0) {\r\n                babyArray[traitPos] = uint8(ascendedTrait);\r\n            } else {\r\n                // did not ascend, pick one of the parent's traits for the baby\r\n                // We use the top bit of rand for this (the bottom three bits were used\r\n                // to check for the ascension itself).\r\n                rand = _sliceNumber(randomN, 1, randomIndex);\r\n                randomIndex += 1;\r\n\r\n                if (rand == 0) {\r\n                    babyArray[traitPos] = uint8(genes1Array[traitPos]);\r\n                } else {\r\n                    babyArray[traitPos] = uint8(genes2Array[traitPos]);\r\n                }\r\n            }\r\n        }"
          VariableDeclarationStatement
             Gas costs: 11
             Source: "uint8 ascendedTrait = 0"
            VariableDeclaration "ascendedTrait"
               Type: uint8
               Source: "uint8 ascendedTrait"
              ElementaryTypeName uint8
                 Source: "uint8"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IfStatement
             Source: "if ((traitPos % 4 == 0) && (genes1Array[traitPos] & 1) != (genes2Array[traitPos] & 1)) {\r\n                rand = _sliceNumber(randomN, 3, randomIndex);\r\n                randomIndex += 3;\r\n\r\n                ascendedTrait = _ascend(genes1Array[traitPos], genes2Array[traitPos], rand);\r\n            }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: [???]
               Source: "(traitPos % 4 == 0) && (genes1Array[traitPos] & 1) != (genes2Array[traitPos] & 1)"
              TupleExpression
                 Type: bool
                 Source: "(traitPos % 4 == 0)"
                BinaryOperation using operator ==
                   Type: bool
                   Source: "traitPos % 4 == 0"
                  BinaryOperation using operator %
                     Type: uint256
                     Source: "traitPos % 4"
                    Identifier traitPos
                       Type: uint256
                       Source: "traitPos"
                    Literal, token: [no token] value: 4
                       Type: int_const 4
                       Source: "4"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              BinaryOperation using operator !=
                 Type: bool
                 Source: "(genes1Array[traitPos] & 1) != (genes2Array[traitPos] & 1)"
                TupleExpression
                   Type: uint8
                   Source: "(genes1Array[traitPos] & 1)"
                  BinaryOperation using operator &
                     Type: uint8
                     Source: "genes1Array[traitPos] & 1"
                    IndexAccess
                       Type: uint8
                       Source: "genes1Array[traitPos]"
                      Identifier genes1Array
                         Type: uint8[] memory
                         Source: "genes1Array"
                      Identifier traitPos
                         Type: uint256
                         Source: "traitPos"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
                TupleExpression
                   Type: uint8
                   Source: "(genes2Array[traitPos] & 1)"
                  BinaryOperation using operator &
                     Type: uint8
                     Source: "genes2Array[traitPos] & 1"
                    IndexAccess
                       Type: uint8
                       Source: "genes2Array[traitPos]"
                      Identifier genes2Array
                         Type: uint8[] memory
                         Source: "genes2Array"
                      Identifier traitPos
                         Type: uint256
                         Source: "traitPos"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
            Block
               Source: "{\r\n                rand = _sliceNumber(randomN, 3, randomIndex);\r\n                randomIndex += 3;\r\n\r\n                ascendedTrait = _ascend(genes1Array[traitPos], genes2Array[traitPos], rand);\r\n            }"
              ExpressionStatement
                 Gas costs: 29
                 Source: "rand = _sliceNumber(randomN, 3, randomIndex)"
                Assignment using operator =
                   Type: uint256
                   Source: "rand = _sliceNumber(randomN, 3, randomIndex)"
                  Identifier rand
                     Type: uint256
                     Source: "rand"
                  FunctionCall
                     Type: uint256
                     Source: "_sliceNumber(randomN, 3, randomIndex)"
                    Identifier _sliceNumber
                       Type: function (uint256,uint256,uint256) pure returns (uint256)
                       Source: "_sliceNumber"
                    Identifier randomN
                       Type: uint256
                       Source: "randomN"
                    Literal, token: [no token] value: 3
                       Type: int_const 3
                       Source: "3"
                    Identifier randomIndex
                       Type: uint256
                       Source: "randomIndex"
              ExpressionStatement
                 Gas costs: 14
                 Source: "randomIndex += 3"
                Assignment using operator +=
                   Type: uint256
                   Source: "randomIndex += 3"
                  Identifier randomIndex
                     Type: uint256
                     Source: "randomIndex"
                  Literal, token: [no token] value: 3
                     Type: int_const 3
                     Source: "3"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "ascendedTrait = _ascend(genes1Array[traitPos], genes2Array[traitPos], rand)"
                Assignment using operator =
                   Type: uint8
                   Source: "ascendedTrait = _ascend(genes1Array[traitPos], genes2Array[traitPos], rand)"
                  Identifier ascendedTrait
                     Type: uint8
                     Source: "ascendedTrait"
                  FunctionCall
                     Type: uint8
                     Source: "_ascend(genes1Array[traitPos], genes2Array[traitPos], rand)"
                    Identifier _ascend
                       Type: function (uint8,uint8,uint256) pure returns (uint8)
                       Source: "_ascend"
                    IndexAccess
                       Type: uint8
                       Source: "genes1Array[traitPos]"
                      Identifier genes1Array
                         Type: uint8[] memory
                         Source: "genes1Array"
                      Identifier traitPos
                         Type: uint256
                         Source: "traitPos"
                    IndexAccess
                       Type: uint8
                       Source: "genes2Array[traitPos]"
                      Identifier genes2Array
                         Type: uint8[] memory
                         Source: "genes2Array"
                      Identifier traitPos
                         Type: uint256
                         Source: "traitPos"
                    Identifier rand
                       Type: uint256
                       Source: "rand"
          IfStatement
             Source: "if (ascendedTrait > 0) {\r\n                babyArray[traitPos] = uint8(ascendedTrait);\r\n            } else {\r\n                // did not ascend, pick one of the parent's traits for the baby\r\n                // We use the top bit of rand for this (the bottom three bits were used\r\n                // to check for the ascension itself).\r\n                rand = _sliceNumber(randomN, 1, randomIndex);\r\n                randomIndex += 1;\r\n\r\n                if (rand == 0) {\r\n                    babyArray[traitPos] = uint8(genes1Array[traitPos]);\r\n                } else {\r\n                    babyArray[traitPos] = uint8(genes2Array[traitPos]);\r\n                }\r\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 15
               Source: "ascendedTrait > 0"
              Identifier ascendedTrait
                 Type: uint8
                 Source: "ascendedTrait"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{\r\n                babyArray[traitPos] = uint8(ascendedTrait);\r\n            }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "babyArray[traitPos] = uint8(ascendedTrait)"
                Assignment using operator =
                   Type: uint8
                   Source: "babyArray[traitPos] = uint8(ascendedTrait)"
                  IndexAccess
                     Type: uint8
                     Source: "babyArray[traitPos]"
                    Identifier babyArray
                       Type: uint8[] memory
                       Source: "babyArray"
                    Identifier traitPos
                       Type: uint256
                       Source: "traitPos"
                  FunctionCall
                     Type: uint8
                     Source: "uint8(ascendedTrait)"
                    ElementaryTypeNameExpression uint8
                       Type: type(uint8)
                       Source: "uint8"
                    Identifier ascendedTrait
                       Type: uint8
                       Source: "ascendedTrait"
            Block
               Source: "{\r\n                // did not ascend, pick one of the parent's traits for the baby\r\n                // We use the top bit of rand for this (the bottom three bits were used\r\n                // to check for the ascension itself).\r\n                rand = _sliceNumber(randomN, 1, randomIndex);\r\n                randomIndex += 1;\r\n\r\n                if (rand == 0) {\r\n                    babyArray[traitPos] = uint8(genes1Array[traitPos]);\r\n                } else {\r\n                    babyArray[traitPos] = uint8(genes2Array[traitPos]);\r\n                }\r\n            }"
              ExpressionStatement
                 Gas costs: 29
                 Source: "rand = _sliceNumber(randomN, 1, randomIndex)"
                Assignment using operator =
                   Type: uint256
                   Source: "rand = _sliceNumber(randomN, 1, randomIndex)"
                  Identifier rand
                     Type: uint256
                     Source: "rand"
                  FunctionCall
                     Type: uint256
                     Source: "_sliceNumber(randomN, 1, randomIndex)"
                    Identifier _sliceNumber
                       Type: function (uint256,uint256,uint256) pure returns (uint256)
                       Source: "_sliceNumber"
                    Identifier randomN
                       Type: uint256
                       Source: "randomN"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
                    Identifier randomIndex
                       Type: uint256
                       Source: "randomIndex"
              ExpressionStatement
                 Gas costs: 14
                 Source: "randomIndex += 1"
                Assignment using operator +=
                   Type: uint256
                   Source: "randomIndex += 1"
                  Identifier randomIndex
                     Type: uint256
                     Source: "randomIndex"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              IfStatement
                 Source: "if (rand == 0) {\r\n                    babyArray[traitPos] = uint8(genes1Array[traitPos]);\r\n                } else {\r\n                    babyArray[traitPos] = uint8(genes2Array[traitPos]);\r\n                }"
                BinaryOperation using operator ==
                   Type: bool
                   Gas costs: 9
                   Source: "rand == 0"
                  Identifier rand
                     Type: uint256
                     Source: "rand"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                Block
                   Source: "{\r\n                    babyArray[traitPos] = uint8(genes1Array[traitPos]);\r\n                }"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "babyArray[traitPos] = uint8(genes1Array[traitPos])"
                    Assignment using operator =
                       Type: uint8
                       Source: "babyArray[traitPos] = uint8(genes1Array[traitPos])"
                      IndexAccess
                         Type: uint8
                         Source: "babyArray[traitPos]"
                        Identifier babyArray
                           Type: uint8[] memory
                           Source: "babyArray"
                        Identifier traitPos
                           Type: uint256
                           Source: "traitPos"
                      FunctionCall
                         Type: uint8
                         Source: "uint8(genes1Array[traitPos])"
                        ElementaryTypeNameExpression uint8
                           Type: type(uint8)
                           Source: "uint8"
                        IndexAccess
                           Type: uint8
                           Source: "genes1Array[traitPos]"
                          Identifier genes1Array
                             Type: uint8[] memory
                             Source: "genes1Array"
                          Identifier traitPos
                             Type: uint256
                             Source: "traitPos"
                Block
                   Source: "{\r\n                    babyArray[traitPos] = uint8(genes2Array[traitPos]);\r\n                }"
                  ExpressionStatement
                     Gas costs: [???]
                     Source: "babyArray[traitPos] = uint8(genes2Array[traitPos])"
                    Assignment using operator =
                       Type: uint8
                       Source: "babyArray[traitPos] = uint8(genes2Array[traitPos])"
                      IndexAccess
                         Type: uint8
                         Source: "babyArray[traitPos]"
                        Identifier babyArray
                           Type: uint8[] memory
                           Source: "babyArray"
                        Identifier traitPos
                           Type: uint256
                           Source: "traitPos"
                      FunctionCall
                         Type: uint8
                         Source: "uint8(genes2Array[traitPos])"
                        ElementaryTypeNameExpression uint8
                           Type: type(uint8)
                           Source: "uint8"
                        IndexAccess
                           Type: uint8
                           Source: "genes2Array[traitPos]"
                          Identifier genes2Array
                             Type: uint8[] memory
                             Source: "genes2Array"
                          Identifier traitPos
                             Type: uint256
                             Source: "traitPos"
      Return
         Gas costs: 23
         Source: "return encode(babyArray)"
        FunctionCall
           Type: uint256
           Source: "encode(babyArray)"
          Identifier encode
             Type: function (uint8[] memory) pure returns (uint256)
             Source: "encode"
          Identifier babyArray
             Type: uint8[] memory
             Source: "babyArray"
