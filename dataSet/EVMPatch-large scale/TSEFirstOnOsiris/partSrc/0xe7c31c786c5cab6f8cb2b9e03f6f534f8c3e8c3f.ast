Syntax trees:


======= /home/fabric/ArocRevision/Aroc/osirisData/contractSrc/0xe7c31c786c5cab6f8cb2b9e03f6f534f8c3e8c3f.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.17;"
ContractDefinition "SafeMath"
   Source: "library SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}"
  FunctionDefinition "mul"
     Source: "function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }"
      IfStatement
         Source: "if (a == 0) {\r\n      return 0;\r\n    }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "a == 0"
          Identifier a
             Type: uint256
             Source: "a"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n      return 0;\r\n    }"
          Return
             Gas costs: 19
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 19
         Source: "uint256 c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 60
         Source: "assert(c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(c / a == b)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "c / a == b"
            BinaryOperation using operator /
               Type: uint256
               Source: "c / a"
              Identifier c
                 Type: uint256
                 Source: "c"
              Identifier a
                 Type: uint256
                 Source: "a"
            Identifier b
               Type: uint256
               Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "div"
     Source: "function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 42
         Source: "uint256 c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "sub"
     Source: "function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 14
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "add"
     Source: "function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint256 c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint256 c"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 32
         Source: "assert(c >= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(c >= a)"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator >=
             Type: bool
             Source: "c >= a"
            Identifier c
               Type: uint256
               Source: "c"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 8
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
ContractDefinition "Ownable"
   Source: "contract Ownable {\r\n  address public owner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n  * account.\r\n  */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n  * @dev Throws if called by any account other than the owner.\r\n  */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n  * @param newOwner The address to transfer ownership to.\r\n  */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  EventDefinition "OwnershipTransferred"
     Gas costs: 0
     Source: "event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);"
    ParameterList
       Source: "(address indexed previousOwner, address indexed newOwner)"
      VariableDeclaration "previousOwner"
         Type: address
         Source: "address indexed previousOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address indexed newOwner"
        ElementaryTypeName address
           Source: "address"
  FunctionDefinition "Ownable" - public
     Source: "function Ownable() public {\r\n    owner = msg.sender;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    owner = msg.sender;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(msg.sender == owner);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 564
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }"
      ExpressionStatement
         Gas costs: 50
         Source: "require(newOwner != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(newOwner != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "newOwner != address(0)"
            Identifier newOwner
               Type: address
               Source: "newOwner"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 1790
         Source: "OwnershipTransferred(owner, newOwner)"
        FunctionCall
           Type: tuple()
           Source: "OwnershipTransferred(owner, newOwner)"
          Identifier OwnershipTransferred
             Type: function (address,address)
             Source: "OwnershipTransferred"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier newOwner
             Type: address
             Source: "newOwner"
ContractDefinition "Authorizable"
   Source: "contract Authorizable is Ownable {\r\nmapping(address => bool) public authorized;\r\n\r\nevent AuthorizationSet(address indexed addressAuthorized, bool indexed authorization);\r\n\r\n/**\r\n* @dev The Authorizable constructor sets the first `authorized` of the contract to the sender\r\n* account.\r\n*/\r\nfunction Authorizable() public {\r\n  AuthorizationSet(msg.sender, true);\r\n    authorized[msg.sender] = true;\r\n  }\r\n\r\n  /**\r\n  * @dev Throws if called by any account other than the authorized.\r\n  */\r\n  modifier onlyAuthorized() {\r\n    require(authorized[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the current owner to set an authorization.\r\n  * @param addressAuthorized The address to change authorization.\r\n  */\r\n  function setAuthorized(address addressAuthorized, bool authorization) public onlyOwner {\r\n    require(authorized[addressAuthorized] != authorization);\r\n    AuthorizationSet(addressAuthorized, authorization);\r\n    authorized[addressAuthorized] = authorization;\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  VariableDeclaration "authorized"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping(address => bool) public authorized"
    Mapping
       Source: "mapping(address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  EventDefinition "AuthorizationSet"
     Gas costs: 0
     Source: "event AuthorizationSet(address indexed addressAuthorized, bool indexed authorization);"
    ParameterList
       Source: "(address indexed addressAuthorized, bool indexed authorization)"
      VariableDeclaration "addressAuthorized"
         Type: address
         Source: "address indexed addressAuthorized"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "authorization"
         Type: bool
         Source: "bool indexed authorization"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "Authorizable" - public
     Source: "function Authorizable() public {\r\n  AuthorizationSet(msg.sender, true);\r\n    authorized[msg.sender] = true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n  AuthorizationSet(msg.sender, true);\r\n    authorized[msg.sender] = true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "AuthorizationSet(msg.sender, true)"
        FunctionCall
           Type: tuple()
           Source: "AuthorizationSet(msg.sender, true)"
          Identifier AuthorizationSet
             Type: function (address,bool)
             Source: "AuthorizationSet"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "authorized[msg.sender] = true"
        Assignment using operator =
           Type: bool
           Source: "authorized[msg.sender] = true"
          IndexAccess
             Type: bool
             Source: "authorized[msg.sender]"
            Identifier authorized
               Type: mapping(address => bool)
               Source: "authorized"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  ModifierDefinition "onlyAuthorized"
     Source: "modifier onlyAuthorized() {\r\n    require(authorized[msg.sender]);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(authorized[msg.sender]);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(authorized[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(authorized[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          IndexAccess
             Type: bool
             Source: "authorized[msg.sender]"
            Identifier authorized
               Type: mapping(address => bool)
               Source: "authorized"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "setAuthorized" - public
     Source: "function setAuthorized(address addressAuthorized, bool authorization) public onlyOwner {\r\n    require(authorized[addressAuthorized] != authorization);\r\n    AuthorizationSet(addressAuthorized, authorization);\r\n    authorized[addressAuthorized] = authorization;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address addressAuthorized, bool authorization)"
      VariableDeclaration "addressAuthorized"
         Type: address
         Source: "address addressAuthorized"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "authorization"
         Type: bool
         Source: "bool authorization"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(authorized[addressAuthorized] != authorization);\r\n    AuthorizationSet(addressAuthorized, authorization);\r\n    authorized[addressAuthorized] = authorization;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(authorized[addressAuthorized] != authorization)"
        FunctionCall
           Type: tuple()
           Source: "require(authorized[addressAuthorized] != authorization)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "authorized[addressAuthorized] != authorization"
            IndexAccess
               Type: bool
               Source: "authorized[addressAuthorized]"
              Identifier authorized
                 Type: mapping(address => bool)
                 Source: "authorized"
              Identifier addressAuthorized
                 Type: address
                 Source: "addressAuthorized"
            Identifier authorization
               Type: bool
               Source: "authorization"
      ExpressionStatement
         Gas costs: 0
         Source: "AuthorizationSet(addressAuthorized, authorization)"
        FunctionCall
           Type: tuple()
           Source: "AuthorizationSet(addressAuthorized, authorization)"
          Identifier AuthorizationSet
             Type: function (address,bool)
             Source: "AuthorizationSet"
          Identifier addressAuthorized
             Type: address
             Source: "addressAuthorized"
          Identifier authorization
             Type: bool
             Source: "authorization"
      ExpressionStatement
         Gas costs: 0
         Source: "authorized[addressAuthorized] = authorization"
        Assignment using operator =
           Type: bool
           Source: "authorized[addressAuthorized] = authorization"
          IndexAccess
             Type: bool
             Source: "authorized[addressAuthorized]"
            Identifier authorized
               Type: mapping(address => bool)
               Source: "authorized"
            Identifier addressAuthorized
               Type: address
               Source: "addressAuthorized"
          Identifier authorization
             Type: bool
             Source: "authorization"
ContractDefinition "WhiteList"
   Source: "contract WhiteList is Authorizable {\r\n  mapping(address => bool) whiteListed;\r\n\r\n  event WhiteListSet(address indexed addressWhiteListed, bool indexed whiteListStatus);\r\n\r\n  /**\r\n  * @dev The WhiteList constructor sets the first `whiteListed` of the contract to the sender\r\n  * account.\r\n  */\r\n  function WhiteList() public {\r\n    WhiteListSet(msg.sender, true);\r\n    whiteListed[msg.sender] = true;\r\n  }\r\n\r\n  /**\r\n  * @dev Throws if called by any account other than the whiteListed.\r\n  */\r\n  modifier onlyWhiteListed() {\r\n    require(whiteListed[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  function isWhiteListed(address _address) public view returns (bool) {\r\n    return whiteListed[_address];\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the current owner to set an whiteListStatus.\r\n  * @param addressWhiteListed The address to change whiteListStatus.\r\n  */\r\n  function setWhiteListed(address addressWhiteListed, bool whiteListStatus) public onlyAuthorized {\r\n    require(whiteListed[addressWhiteListed] != whiteListStatus);\r\n    WhiteListSet(addressWhiteListed, whiteListStatus);\r\n    whiteListed[addressWhiteListed] = whiteListStatus;\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Authorizable"
    UserDefinedTypeName "Authorizable"
       Source: "Authorizable"
  VariableDeclaration "whiteListed"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping(address => bool) whiteListed"
    Mapping
       Source: "mapping(address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  EventDefinition "WhiteListSet"
     Gas costs: 0
     Source: "event WhiteListSet(address indexed addressWhiteListed, bool indexed whiteListStatus);"
    ParameterList
       Source: "(address indexed addressWhiteListed, bool indexed whiteListStatus)"
      VariableDeclaration "addressWhiteListed"
         Type: address
         Source: "address indexed addressWhiteListed"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "whiteListStatus"
         Type: bool
         Source: "bool indexed whiteListStatus"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "WhiteList" - public
     Source: "function WhiteList() public {\r\n    WhiteListSet(msg.sender, true);\r\n    whiteListed[msg.sender] = true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    WhiteListSet(msg.sender, true);\r\n    whiteListed[msg.sender] = true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "WhiteListSet(msg.sender, true)"
        FunctionCall
           Type: tuple()
           Source: "WhiteListSet(msg.sender, true)"
          Identifier WhiteListSet
             Type: function (address,bool)
             Source: "WhiteListSet"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "whiteListed[msg.sender] = true"
        Assignment using operator =
           Type: bool
           Source: "whiteListed[msg.sender] = true"
          IndexAccess
             Type: bool
             Source: "whiteListed[msg.sender]"
            Identifier whiteListed
               Type: mapping(address => bool)
               Source: "whiteListed"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  ModifierDefinition "onlyWhiteListed"
     Source: "modifier onlyWhiteListed() {\r\n    require(whiteListed[msg.sender]);\r\n    _;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(whiteListed[msg.sender]);\r\n    _;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(whiteListed[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(whiteListed[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          IndexAccess
             Type: bool
             Source: "whiteListed[msg.sender]"
            Identifier whiteListed
               Type: mapping(address => bool)
               Source: "whiteListed"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  FunctionDefinition "isWhiteListed" - public - const
     Source: "function isWhiteListed(address _address) public view returns (bool) {\r\n    return whiteListed[_address];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    return whiteListed[_address];\r\n  }"
      Return
         Gas costs: 0
         Source: "return whiteListed[_address]"
        IndexAccess
           Type: bool
           Source: "whiteListed[_address]"
          Identifier whiteListed
             Type: mapping(address => bool)
             Source: "whiteListed"
          Identifier _address
             Type: address
             Source: "_address"
  FunctionDefinition "setWhiteListed" - public
     Source: "function setWhiteListed(address addressWhiteListed, bool whiteListStatus) public onlyAuthorized {\r\n    require(whiteListed[addressWhiteListed] != whiteListStatus);\r\n    WhiteListSet(addressWhiteListed, whiteListStatus);\r\n    whiteListed[addressWhiteListed] = whiteListStatus;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address addressWhiteListed, bool whiteListStatus)"
      VariableDeclaration "addressWhiteListed"
         Type: address
         Source: "address addressWhiteListed"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "whiteListStatus"
         Type: bool
         Source: "bool whiteListStatus"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAuthorized"
       Gas costs: 0
       Source: "onlyAuthorized"
      Identifier onlyAuthorized
         Type: modifier ()
         Source: "onlyAuthorized"
    Block
       Source: "{\r\n    require(whiteListed[addressWhiteListed] != whiteListStatus);\r\n    WhiteListSet(addressWhiteListed, whiteListStatus);\r\n    whiteListed[addressWhiteListed] = whiteListStatus;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(whiteListed[addressWhiteListed] != whiteListStatus)"
        FunctionCall
           Type: tuple()
           Source: "require(whiteListed[addressWhiteListed] != whiteListStatus)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "whiteListed[addressWhiteListed] != whiteListStatus"
            IndexAccess
               Type: bool
               Source: "whiteListed[addressWhiteListed]"
              Identifier whiteListed
                 Type: mapping(address => bool)
                 Source: "whiteListed"
              Identifier addressWhiteListed
                 Type: address
                 Source: "addressWhiteListed"
            Identifier whiteListStatus
               Type: bool
               Source: "whiteListStatus"
      ExpressionStatement
         Gas costs: 0
         Source: "WhiteListSet(addressWhiteListed, whiteListStatus)"
        FunctionCall
           Type: tuple()
           Source: "WhiteListSet(addressWhiteListed, whiteListStatus)"
          Identifier WhiteListSet
             Type: function (address,bool)
             Source: "WhiteListSet"
          Identifier addressWhiteListed
             Type: address
             Source: "addressWhiteListed"
          Identifier whiteListStatus
             Type: bool
             Source: "whiteListStatus"
      ExpressionStatement
         Gas costs: 0
         Source: "whiteListed[addressWhiteListed] = whiteListStatus"
        Assignment using operator =
           Type: bool
           Source: "whiteListed[addressWhiteListed] = whiteListStatus"
          IndexAccess
             Type: bool
             Source: "whiteListed[addressWhiteListed]"
            Identifier whiteListed
               Type: mapping(address => bool)
               Source: "whiteListed"
            Identifier addressWhiteListed
               Type: address
               Source: "addressWhiteListed"
          Identifier whiteListStatus
             Type: bool
             Source: "whiteListStatus"
ContractDefinition "ERC20Basic"
   Gas costs: 0
   Source: "contract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) public view returns (uint256);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address to, uint256 value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint256 value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "ERC20"
   Gas costs: 0
   Source: "contract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
  InheritanceSpecifier
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) public view returns (uint256);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address from, address to, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint256 value) public returns (bool);"
    ParameterList
       Source: "(address spender, uint256 value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint256 value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint256 value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "BasicToken"
   Source: "contract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20Basic"
    UserDefinedTypeName "ERC20Basic"
       Source: "ERC20Basic"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint256) balances"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_to != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_to != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != address(0)"
            Identifier _to
               Type: address
               Source: "_to"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_value <= balances[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= balances[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= balances[msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = balances[msg.sender].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "balances[msg.sender].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return balances[_owner];\r\n  }"
      Return
         Gas costs: 0
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is ERC20, BasicToken {\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  /**\r\n  * @dev Transfer tokens from one address to another\r\n  * @param _from address The address which you want to send tokens from\r\n  * @param _to address The address which you want to transfer to\r\n  * @param _value uint256 the amount of tokens to be transferred\r\n  */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n  *\r\n  * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n  * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n  * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n  * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n  * @param _spender The address which will spend the funds.\r\n  * @param _value The amount of tokens to be spent.\r\n  */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n  * @param _owner address The address which owns the funds.\r\n  * @param _spender address The address which will spend the funds.\r\n  * @return A uint256 specifying the amount of tokens still available for the spender.\r\n  */\r\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n  * approve should be called when allowed[_spender] == 0. To increment\r\n  * allowed value is better to use this function to avoid 2 calls (and wait until\r\n  * the first transaction is mined)\r\n  * From MonolithDAO Token.sol\r\n  */\r\n  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  InheritanceSpecifier
     Gas costs: 0
     Source: "BasicToken"
    UserDefinedTypeName "BasicToken"
       Source: "BasicToken"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) internal allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_to != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_to != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_to != address(0)"
            Identifier _to
               Type: address
               Source: "_to"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_value <= balances[_from])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= balances[_from])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= balances[_from]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[_from]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _from
                 Type: address
                 Source: "_from"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_value <= allowed[_from][msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= allowed[_from][msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= allowed[_from][msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "allowed[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[_from]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_from] = balances[_from].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_from] = balances[_from].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "balances[_from].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[_from].sub"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] = balances[_to].add(_value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = balances[_to].add(_value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "balances[_to].add(_value)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "balances[_to].add"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "allowed[_from][msg.sender].sub(_value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "allowed[_from][msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return allowed[_owner][_spender];\r\n  }"
      Return
         Gas costs: 0
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  FunctionDefinition "increaseApproval" - public
     Source: "function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _addedValue)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_addedValue"
         Type: uint256
         Source: "uint _addedValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          FunctionCall
             Type: uint256
             Source: "allowed[msg.sender][_spender].add(_addedValue)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "allowed[msg.sender][_spender].add"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
            Identifier _addedValue
               Type: uint256
               Source: "_addedValue"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "decreaseApproval" - public
     Source: "function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _subtractedValue)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_subtractedValue"
         Type: uint256
         Source: "uint _subtractedValue"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint oldValue = allowed[msg.sender][_spender]"
        VariableDeclaration "oldValue"
           Type: uint256
           Source: "uint oldValue"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "allowed[msg.sender][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[msg.sender]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
      IfStatement
         Source: "if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 0
           Source: "_subtractedValue > oldValue"
          Identifier _subtractedValue
             Type: uint256
             Source: "_subtractedValue"
          Identifier oldValue
             Type: uint256
             Source: "oldValue"
        Block
           Source: "{\r\n      allowed[msg.sender][_spender] = 0;\r\n    }"
          ExpressionStatement
             Gas costs: 0
             Source: "allowed[msg.sender][_spender] = 0"
            Assignment using operator =
               Type: uint256
               Source: "allowed[msg.sender][_spender] = 0"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }"
          ExpressionStatement
             Gas costs: 0
             Source: "allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)"
            Assignment using operator =
               Type: uint256
               Source: "allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
              FunctionCall
                 Type: uint256
                 Source: "oldValue.sub(_subtractedValue)"
                MemberAccess to member sub
                   Type: function (uint256,uint256) pure returns (uint256)
                   Source: "oldValue.sub"
                  Identifier oldValue
                     Type: uint256
                     Source: "oldValue"
                Identifier _subtractedValue
                   Type: uint256
                   Source: "_subtractedValue"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, allowed[msg.sender][_spender])"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
ContractDefinition "TreasureBox"
   Source: "contract TreasureBox {\r\n  // ERC20 basic token contract being held\r\n  StandardToken token;\r\n  // beneficiary of tokens after they are released\r\n  address public beneficiary;\r\n  // timestamp where token release is enabled\r\n  uint public releaseTime;\r\n\r\n  function TreasureBox(StandardToken _token, address _beneficiary, uint _releaseTime) public {\r\n    require(_beneficiary != address(0));\r\n    token = StandardToken(_token);\r\n    beneficiary = _beneficiary;\r\n    releaseTime = _releaseTime;\r\n  }\r\n\r\n  function claim() external {\r\n    require(available());\r\n    require(amount() > 0);\r\n    token.transfer(beneficiary, amount());\r\n  }\r\n\r\n  function available() public view returns (bool) {\r\n    return (now >= releaseTime);\r\n  }\r\n\r\n  function amount() public view returns (uint256) {\r\n    return token.balanceOf(this);\r\n  }\r\n}"
  VariableDeclaration "token"
     Type: contract StandardToken
     Gas costs: 0
     Source: "StandardToken token"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  VariableDeclaration "beneficiary"
     Type: address
     Gas costs: 0
     Source: "address public beneficiary"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "releaseTime"
     Type: uint256
     Gas costs: 0
     Source: "uint public releaseTime"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "TreasureBox" - public
     Source: "function TreasureBox(StandardToken _token, address _beneficiary, uint _releaseTime) public {\r\n    require(_beneficiary != address(0));\r\n    token = StandardToken(_token);\r\n    beneficiary = _beneficiary;\r\n    releaseTime = _releaseTime;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(StandardToken _token, address _beneficiary, uint _releaseTime)"
      VariableDeclaration "_token"
         Type: contract StandardToken
         Source: "StandardToken _token"
        UserDefinedTypeName "StandardToken"
           Source: "StandardToken"
      VariableDeclaration "_beneficiary"
         Type: address
         Source: "address _beneficiary"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_releaseTime"
         Type: uint256
         Source: "uint _releaseTime"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    require(_beneficiary != address(0));\r\n    token = StandardToken(_token);\r\n    beneficiary = _beneficiary;\r\n    releaseTime = _releaseTime;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_beneficiary != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_beneficiary != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_beneficiary != address(0)"
            Identifier _beneficiary
               Type: address
               Source: "_beneficiary"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "token = StandardToken(_token)"
        Assignment using operator =
           Type: contract StandardToken
           Source: "token = StandardToken(_token)"
          Identifier token
             Type: contract StandardToken
             Source: "token"
          FunctionCall
             Type: contract StandardToken
             Source: "StandardToken(_token)"
            Identifier StandardToken
               Type: type(contract StandardToken)
               Source: "StandardToken"
            Identifier _token
               Type: contract StandardToken
               Source: "_token"
      ExpressionStatement
         Gas costs: 0
         Source: "beneficiary = _beneficiary"
        Assignment using operator =
           Type: address
           Source: "beneficiary = _beneficiary"
          Identifier beneficiary
             Type: address
             Source: "beneficiary"
          Identifier _beneficiary
             Type: address
             Source: "_beneficiary"
      ExpressionStatement
         Gas costs: 0
         Source: "releaseTime = _releaseTime"
        Assignment using operator =
           Type: uint256
           Source: "releaseTime = _releaseTime"
          Identifier releaseTime
             Type: uint256
             Source: "releaseTime"
          Identifier _releaseTime
             Type: uint256
             Source: "_releaseTime"
  FunctionDefinition "claim" - public
     Source: "function claim() external {\r\n    require(available());\r\n    require(amount() > 0);\r\n    token.transfer(beneficiary, amount());\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    require(available());\r\n    require(amount() > 0);\r\n    token.transfer(beneficiary, amount());\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(available())"
        FunctionCall
           Type: tuple()
           Source: "require(available())"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "available()"
            Identifier available
               Type: function () view returns (bool)
               Source: "available"
      ExpressionStatement
         Gas costs: 0
         Source: "require(amount() > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(amount() > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "amount() > 0"
            FunctionCall
               Type: uint256
               Source: "amount()"
              Identifier amount
                 Type: function () view returns (uint256)
                 Source: "amount"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "token.transfer(beneficiary, amount())"
        FunctionCall
           Type: bool
           Source: "token.transfer(beneficiary, amount())"
          MemberAccess to member transfer
             Type: function (address,uint256) external returns (bool)
             Source: "token.transfer"
            Identifier token
               Type: contract StandardToken
               Source: "token"
          Identifier beneficiary
             Type: address
             Source: "beneficiary"
          FunctionCall
             Type: uint256
             Source: "amount()"
            Identifier amount
               Type: function () view returns (uint256)
               Source: "amount"
  FunctionDefinition "available" - public - const
     Source: "function available() public view returns (bool) {\r\n    return (now >= releaseTime);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    return (now >= releaseTime);\r\n  }"
      Return
         Gas costs: 0
         Source: "return (now >= releaseTime)"
        TupleExpression
           Type: bool
           Source: "(now >= releaseTime)"
          BinaryOperation using operator >=
             Type: bool
             Source: "now >= releaseTime"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier releaseTime
               Type: uint256
               Source: "releaseTime"
  FunctionDefinition "amount" - public - const
     Source: "function amount() public view returns (uint256) {\r\n    return token.balanceOf(this);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return token.balanceOf(this);\r\n  }"
      Return
         Gas costs: 0
         Source: "return token.balanceOf(this)"
        FunctionCall
           Type: uint256
           Source: "token.balanceOf(this)"
          MemberAccess to member balanceOf
             Type: function (address) view external returns (uint256)
             Source: "token.balanceOf"
            Identifier token
               Type: contract StandardToken
               Source: "token"
          Identifier this
             Type: contract TreasureBox
             Source: "this"
ContractDefinition "AirDropper"
   Source: "contract AirDropper is Authorizable {\r\n  mapping(address => bool) public isAnExchanger; // allow to airdrop to destination is exchanger with out minimum\r\n  mapping(address => bool) public isTreasureBox; // flag who not eligible airdrop\r\n  mapping(address => address) public airDropDestinations; // setTo 0x0 if want airdrop to self\r\n\r\n  StandardToken token;\r\n\r\n  event SetDestination(address _address, address _destination);\r\n  event SetExchanger(address _address, bool _isExchanger);\r\n\r\n  function AirDropper(StandardToken _token) public {\r\n    token = _token;\r\n  }\r\n\r\n  function getToken() public view returns(StandardToken) {\r\n    return token;\r\n  }\r\n\r\n  /**\r\n  * set _destination to 0x0 if want to self airdrop\r\n  */\r\n  function setAirDropDestination(address _destination) external {\r\n    require(_destination != msg.sender);\r\n    airDropDestinations[msg.sender] = _destination;\r\n    SetDestination(msg.sender, _destination);\r\n  }\r\n\r\n  function setTreasureBox (address _address, bool _status) public onlyAuthorized {\r\n    require(_address != address(0));\r\n    require(isTreasureBox[_address] != _status);\r\n    isTreasureBox[_address] = _status;\r\n  }\r\n\r\n  function setExchanger(address _address, bool _isExchanger) external onlyAuthorized {\r\n    require(_address != address(0));\r\n    require(isAnExchanger[_address] != _isExchanger);\r\n    isAnExchanger[_address] = _isExchanger;\r\n    SetExchanger(_address, _isExchanger);\r\n  }\r\n\r\n  /**\r\n  * help fix airdrop when holder > 100\r\n  * but need to calculate outer\r\n  */\r\n  function multiTransfer(address[] _address, uint[] _value) public returns (bool) {\r\n    for (uint i = 0; i < _address.length; i++) {\r\n      token.transferFrom(msg.sender, _address[i], _value[i]);\r\n    }\r\n    return true;\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Authorizable"
    UserDefinedTypeName "Authorizable"
       Source: "Authorizable"
  VariableDeclaration "isAnExchanger"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping(address => bool) public isAnExchanger"
    Mapping
       Source: "mapping(address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "isTreasureBox"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping(address => bool) public isTreasureBox"
    Mapping
       Source: "mapping(address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "airDropDestinations"
     Type: mapping(address => address)
     Gas costs: 0
     Source: "mapping(address => address) public airDropDestinations"
    Mapping
       Source: "mapping(address => address)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "token"
     Type: contract StandardToken
     Gas costs: 0
     Source: "StandardToken token"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  EventDefinition "SetDestination"
     Gas costs: 0
     Source: "event SetDestination(address _address, address _destination);"
    ParameterList
       Source: "(address _address, address _destination)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_destination"
         Type: address
         Source: "address _destination"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "SetExchanger"
     Gas costs: 0
     Source: "event SetExchanger(address _address, bool _isExchanger);"
    ParameterList
       Source: "(address _address, bool _isExchanger)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_isExchanger"
         Type: bool
         Source: "bool _isExchanger"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "AirDropper" - public
     Source: "function AirDropper(StandardToken _token) public {\r\n    token = _token;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(StandardToken _token)"
      VariableDeclaration "_token"
         Type: contract StandardToken
         Source: "StandardToken _token"
        UserDefinedTypeName "StandardToken"
           Source: "StandardToken"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    token = _token;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "token = _token"
        Assignment using operator =
           Type: contract StandardToken
           Source: "token = _token"
          Identifier token
             Type: contract StandardToken
             Source: "token"
          Identifier _token
             Type: contract StandardToken
             Source: "_token"
  FunctionDefinition "getToken" - public - const
     Source: "function getToken() public view returns(StandardToken) {\r\n    return token;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(StandardToken)"
      VariableDeclaration ""
         Type: contract StandardToken
         Source: "StandardToken"
        UserDefinedTypeName "StandardToken"
           Source: "StandardToken"
    Block
       Source: "{\r\n    return token;\r\n  }"
      Return
         Gas costs: 0
         Source: "return token"
        Identifier token
           Type: contract StandardToken
           Source: "token"
  FunctionDefinition "setAirDropDestination" - public
     Source: "function setAirDropDestination(address _destination) external {\r\n    require(_destination != msg.sender);\r\n    airDropDestinations[msg.sender] = _destination;\r\n    SetDestination(msg.sender, _destination);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _destination)"
      VariableDeclaration "_destination"
         Type: address
         Source: "address _destination"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    require(_destination != msg.sender);\r\n    airDropDestinations[msg.sender] = _destination;\r\n    SetDestination(msg.sender, _destination);\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_destination != msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "require(_destination != msg.sender)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_destination != msg.sender"
            Identifier _destination
               Type: address
               Source: "_destination"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "airDropDestinations[msg.sender] = _destination"
        Assignment using operator =
           Type: address
           Source: "airDropDestinations[msg.sender] = _destination"
          IndexAccess
             Type: address
             Source: "airDropDestinations[msg.sender]"
            Identifier airDropDestinations
               Type: mapping(address => address)
               Source: "airDropDestinations"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _destination
             Type: address
             Source: "_destination"
      ExpressionStatement
         Gas costs: 0
         Source: "SetDestination(msg.sender, _destination)"
        FunctionCall
           Type: tuple()
           Source: "SetDestination(msg.sender, _destination)"
          Identifier SetDestination
             Type: function (address,address)
             Source: "SetDestination"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _destination
             Type: address
             Source: "_destination"
  FunctionDefinition "setTreasureBox" - public
     Source: "function setTreasureBox (address _address, bool _status) public onlyAuthorized {\r\n    require(_address != address(0));\r\n    require(isTreasureBox[_address] != _status);\r\n    isTreasureBox[_address] = _status;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _address, bool _status)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_status"
         Type: bool
         Source: "bool _status"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAuthorized"
       Gas costs: 0
       Source: "onlyAuthorized"
      Identifier onlyAuthorized
         Type: modifier ()
         Source: "onlyAuthorized"
    Block
       Source: "{\r\n    require(_address != address(0));\r\n    require(isTreasureBox[_address] != _status);\r\n    isTreasureBox[_address] = _status;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_address != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_address != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_address != address(0)"
            Identifier _address
               Type: address
               Source: "_address"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(isTreasureBox[_address] != _status)"
        FunctionCall
           Type: tuple()
           Source: "require(isTreasureBox[_address] != _status)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "isTreasureBox[_address] != _status"
            IndexAccess
               Type: bool
               Source: "isTreasureBox[_address]"
              Identifier isTreasureBox
                 Type: mapping(address => bool)
                 Source: "isTreasureBox"
              Identifier _address
                 Type: address
                 Source: "_address"
            Identifier _status
               Type: bool
               Source: "_status"
      ExpressionStatement
         Gas costs: 0
         Source: "isTreasureBox[_address] = _status"
        Assignment using operator =
           Type: bool
           Source: "isTreasureBox[_address] = _status"
          IndexAccess
             Type: bool
             Source: "isTreasureBox[_address]"
            Identifier isTreasureBox
               Type: mapping(address => bool)
               Source: "isTreasureBox"
            Identifier _address
               Type: address
               Source: "_address"
          Identifier _status
             Type: bool
             Source: "_status"
  FunctionDefinition "setExchanger" - public
     Source: "function setExchanger(address _address, bool _isExchanger) external onlyAuthorized {\r\n    require(_address != address(0));\r\n    require(isAnExchanger[_address] != _isExchanger);\r\n    isAnExchanger[_address] = _isExchanger;\r\n    SetExchanger(_address, _isExchanger);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _address, bool _isExchanger)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_isExchanger"
         Type: bool
         Source: "bool _isExchanger"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAuthorized"
       Gas costs: 0
       Source: "onlyAuthorized"
      Identifier onlyAuthorized
         Type: modifier ()
         Source: "onlyAuthorized"
    Block
       Source: "{\r\n    require(_address != address(0));\r\n    require(isAnExchanger[_address] != _isExchanger);\r\n    isAnExchanger[_address] = _isExchanger;\r\n    SetExchanger(_address, _isExchanger);\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_address != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_address != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_address != address(0)"
            Identifier _address
               Type: address
               Source: "_address"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(isAnExchanger[_address] != _isExchanger)"
        FunctionCall
           Type: tuple()
           Source: "require(isAnExchanger[_address] != _isExchanger)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "isAnExchanger[_address] != _isExchanger"
            IndexAccess
               Type: bool
               Source: "isAnExchanger[_address]"
              Identifier isAnExchanger
                 Type: mapping(address => bool)
                 Source: "isAnExchanger"
              Identifier _address
                 Type: address
                 Source: "_address"
            Identifier _isExchanger
               Type: bool
               Source: "_isExchanger"
      ExpressionStatement
         Gas costs: 0
         Source: "isAnExchanger[_address] = _isExchanger"
        Assignment using operator =
           Type: bool
           Source: "isAnExchanger[_address] = _isExchanger"
          IndexAccess
             Type: bool
             Source: "isAnExchanger[_address]"
            Identifier isAnExchanger
               Type: mapping(address => bool)
               Source: "isAnExchanger"
            Identifier _address
               Type: address
               Source: "_address"
          Identifier _isExchanger
             Type: bool
             Source: "_isExchanger"
      ExpressionStatement
         Gas costs: 0
         Source: "SetExchanger(_address, _isExchanger)"
        FunctionCall
           Type: tuple()
           Source: "SetExchanger(_address, _isExchanger)"
          Identifier SetExchanger
             Type: function (address,bool)
             Source: "SetExchanger"
          Identifier _address
             Type: address
             Source: "_address"
          Identifier _isExchanger
             Type: bool
             Source: "_isExchanger"
  FunctionDefinition "multiTransfer" - public
     Source: "function multiTransfer(address[] _address, uint[] _value) public returns (bool) {\r\n    for (uint i = 0; i < _address.length; i++) {\r\n      token.transferFrom(msg.sender, _address[i], _value[i]);\r\n    }\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address[] _address, uint[] _value)"
      VariableDeclaration "_address"
         Type: address[] memory
         Source: "address[] _address"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
      VariableDeclaration "_value"
         Type: uint256[] memory
         Source: "uint[] _value"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    for (uint i = 0; i < _address.length; i++) {\r\n      token.transferFrom(msg.sender, _address[i], _value[i]);\r\n    }\r\n    return true;\r\n  }"
      ForStatement
         Source: "for (uint i = 0; i < _address.length; i++) {\r\n      token.transferFrom(msg.sender, _address[i], _value[i]);\r\n    }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < _address.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_address.length"
            Identifier _address
               Type: address[] memory
               Source: "_address"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n      token.transferFrom(msg.sender, _address[i], _value[i]);\r\n    }"
          ExpressionStatement
             Gas costs: 0
             Source: "token.transferFrom(msg.sender, _address[i], _value[i])"
            FunctionCall
               Type: bool
               Source: "token.transferFrom(msg.sender, _address[i], _value[i])"
              MemberAccess to member transferFrom
                 Type: function (address,address,uint256) external returns (bool)
                 Source: "token.transferFrom"
                Identifier token
                   Type: contract StandardToken
                   Source: "token"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              IndexAccess
                 Type: address
                 Source: "_address[i]"
                Identifier _address
                   Type: address[] memory
                   Source: "_address"
                Identifier i
                   Type: uint256
                   Source: "i"
              IndexAccess
                 Type: uint256
                 Source: "_value[i]"
                Identifier _value
                   Type: uint256[] memory
                   Source: "_value"
                Identifier i
                   Type: uint256
                   Source: "i"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
ContractDefinition "ZMINE"
   Source: "contract ZMINE is StandardToken, Ownable {\r\n  string public name = \"ZMINE Token\";\r\n  string public symbol = \"ZMN\";\r\n  uint8 public decimals = 18;\r\n\r\n  uint256 public totalSupply = 1000000000000000000000000000; // 1,000,000,000 ^ 18\r\n\r\n  function ZMINE() public {\r\n    balances[owner] = totalSupply;\r\n    Transfer(address(0x0), owner, totalSupply);\r\n  }\r\n\r\n  /**\r\n  * burn token if token is not sold out after Public\r\n  */\r\n  function burn(uint _amount) external onlyOwner {\r\n    require(balances[owner] >= _amount);\r\n    balances[owner] = balances[owner] - _amount;\r\n    totalSupply = totalSupply - _amount;\r\n    Transfer(owner, address(0x0), _amount);\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: 0
     Source: "string public name = \"ZMINE Token\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: ZMINE Token
       Type: literal_string "ZMINE Token"
       Source: "\"ZMINE Token\""
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: 0
     Source: "string public symbol = \"ZMN\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: ZMN
       Type: literal_string "ZMN"
       Source: "\"ZMN\""
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: 0
     Source: "uint8 public decimals = 18"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "totalSupply"
     Type: uint256
     Gas costs: 0
     Source: "uint256 public totalSupply = 1000000000000000000000000000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 1000000000000000000000000000
       Type: int_const 1000000000000000000000000000
       Source: "1000000000000000000000000000"
  FunctionDefinition "ZMINE" - public
     Source: "function ZMINE() public {\r\n    balances[owner] = totalSupply;\r\n    Transfer(address(0x0), owner, totalSupply);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    balances[owner] = totalSupply;\r\n    Transfer(address(0x0), owner, totalSupply);\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[owner] = totalSupply"
        Assignment using operator =
           Type: uint256
           Source: "balances[owner] = totalSupply"
          IndexAccess
             Type: uint256
             Source: "balances[owner]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier owner
               Type: address
               Source: "owner"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(address(0x0), owner, totalSupply)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(address(0x0), owner, totalSupply)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          FunctionCall
             Type: address
             Source: "address(0x0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
  FunctionDefinition "burn" - public
     Source: "function burn(uint _amount) external onlyOwner {\r\n    require(balances[owner] >= _amount);\r\n    balances[owner] = balances[owner] - _amount;\r\n    totalSupply = totalSupply - _amount;\r\n    Transfer(owner, address(0x0), _amount);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint _amount)"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(balances[owner] >= _amount);\r\n    balances[owner] = balances[owner] - _amount;\r\n    totalSupply = totalSupply - _amount;\r\n    Transfer(owner, address(0x0), _amount);\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balances[owner] >= _amount)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[owner] >= _amount)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[owner] >= _amount"
            IndexAccess
               Type: uint256
               Source: "balances[owner]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier owner
                 Type: address
                 Source: "owner"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[owner] = balances[owner] - _amount"
        Assignment using operator =
           Type: uint256
           Source: "balances[owner] = balances[owner] - _amount"
          IndexAccess
             Type: uint256
             Source: "balances[owner]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier owner
               Type: address
               Source: "owner"
          BinaryOperation using operator -
             Type: uint256
             Source: "balances[owner] - _amount"
            IndexAccess
               Type: uint256
               Source: "balances[owner]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier owner
                 Type: address
                 Source: "owner"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = totalSupply - _amount"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = totalSupply - _amount"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          BinaryOperation using operator -
             Type: uint256
             Source: "totalSupply - _amount"
            Identifier totalSupply
               Type: uint256
               Source: "totalSupply"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(owner, address(0x0), _amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(owner, address(0x0), _amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier owner
             Type: address
             Source: "owner"
          FunctionCall
             Type: address
             Source: "address(0x0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
          Identifier _amount
             Type: uint256
             Source: "_amount"
ContractDefinition "RateContract"
   Source: "contract RateContract is Authorizable {\r\n  uint public rate = 6000000000000000000000;\r\n\r\n  event UpdateRate(uint _oldRate, uint _newRate);\r\n\r\n  function updateRate(uint _rate) public onlyAuthorized {\r\n    require(rate != _rate);\r\n    UpdateRate(rate, _rate);\r\n    rate = _rate;\r\n  }\r\n\r\n  function getRate() public view returns (uint) {\r\n    return rate;\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Authorizable"
    UserDefinedTypeName "Authorizable"
       Source: "Authorizable"
  VariableDeclaration "rate"
     Type: uint256
     Gas costs: 0
     Source: "uint public rate = 6000000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 6000000000000000000000
       Type: int_const 6000000000000000000000
       Source: "6000000000000000000000"
  EventDefinition "UpdateRate"
     Gas costs: 0
     Source: "event UpdateRate(uint _oldRate, uint _newRate);"
    ParameterList
       Source: "(uint _oldRate, uint _newRate)"
      VariableDeclaration "_oldRate"
         Type: uint256
         Source: "uint _oldRate"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_newRate"
         Type: uint256
         Source: "uint _newRate"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "updateRate" - public
     Source: "function updateRate(uint _rate) public onlyAuthorized {\r\n    require(rate != _rate);\r\n    UpdateRate(rate, _rate);\r\n    rate = _rate;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint _rate)"
      VariableDeclaration "_rate"
         Type: uint256
         Source: "uint _rate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyAuthorized"
       Gas costs: 0
       Source: "onlyAuthorized"
      Identifier onlyAuthorized
         Type: modifier ()
         Source: "onlyAuthorized"
    Block
       Source: "{\r\n    require(rate != _rate);\r\n    UpdateRate(rate, _rate);\r\n    rate = _rate;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(rate != _rate)"
        FunctionCall
           Type: tuple()
           Source: "require(rate != _rate)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "rate != _rate"
            Identifier rate
               Type: uint256
               Source: "rate"
            Identifier _rate
               Type: uint256
               Source: "_rate"
      ExpressionStatement
         Gas costs: 0
         Source: "UpdateRate(rate, _rate)"
        FunctionCall
           Type: tuple()
           Source: "UpdateRate(rate, _rate)"
          Identifier UpdateRate
             Type: function (uint256,uint256)
             Source: "UpdateRate"
          Identifier rate
             Type: uint256
             Source: "rate"
          Identifier _rate
             Type: uint256
             Source: "_rate"
      ExpressionStatement
         Gas costs: 0
         Source: "rate = _rate"
        Assignment using operator =
           Type: uint256
           Source: "rate = _rate"
          Identifier rate
             Type: uint256
             Source: "rate"
          Identifier _rate
             Type: uint256
             Source: "_rate"
  FunctionDefinition "getRate" - public - const
     Source: "function getRate() public view returns (uint) {\r\n    return rate;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return rate;\r\n  }"
      Return
         Gas costs: 0
         Source: "return rate"
        Identifier rate
           Type: uint256
           Source: "rate"
ContractDefinition "FounderThreader"
   Source: "contract FounderThreader is Ownable {\r\n  using SafeMath for uint;\r\n\r\n  event TokenTransferForFounder(address _recipient, uint _value, address box1, address box2);\r\n\r\n  AirDropper public airdropper;\r\n\r\n  uint public hardCap = 300000000000000000000000000; // 300 000 000 * 1e18\r\n  uint public remain = 300000000000000000000000000; // 300 000 000 * 1e18\r\n\r\n  uint public minTx = 100000000000000000000; // 100 * 1e18\r\n\r\n  mapping(address => bool) isFounder;\r\n\r\n  function FounderThreader (AirDropper _airdropper, address[] _founders) public {\r\n    airdropper = AirDropper(_airdropper);\r\n    for (uint i = 0; i < _founders.length; i++) {\r\n      isFounder[_founders[i]] = true;\r\n    }\r\n  }\r\n\r\n  function transferFor(address _recipient, uint _tokens) external onlyOwner {\r\n    require(_recipient != address(0));\r\n    require(_tokens >= minTx);\r\n    require(isFounder[_recipient]);\r\n\r\n    StandardToken token = StandardToken(airdropper.getToken());\r\n\r\n    TreasureBox box1 = new TreasureBox(token, _recipient, 1533088800); // can open 2018-08-01 09+07:00\r\n    TreasureBox box2 = new TreasureBox(token, _recipient, 1548986400); // can open 2019-02-01 09+07:00\r\n\r\n    airdropper.setTreasureBox(box1, true);\r\n    airdropper.setTreasureBox(box2, true);\r\n\r\n    token.transferFrom(owner, _recipient, _tokens.mul(33).div(100)); // 33 % for now\r\n    token.transferFrom(owner, box1, _tokens.mul(33).div(100)); // 33 % for box1\r\n    token.transferFrom(owner, box2, _tokens.mul(34).div(100)); // 34 % for box2\r\n\r\n    remain = remain.sub(_tokens);\r\n\r\n    TokenTransferForFounder(_recipient, _tokens, box1, box2);\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint
       Source: "uint"
  EventDefinition "TokenTransferForFounder"
     Gas costs: 0
     Source: "event TokenTransferForFounder(address _recipient, uint _value, address box1, address box2);"
    ParameterList
       Source: "(address _recipient, uint _value, address box1, address box2)"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "box1"
         Type: address
         Source: "address box1"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "box2"
         Type: address
         Source: "address box2"
        ElementaryTypeName address
           Source: "address"
  VariableDeclaration "airdropper"
     Type: contract AirDropper
     Gas costs: 0
     Source: "AirDropper public airdropper"
    UserDefinedTypeName "AirDropper"
       Source: "AirDropper"
  VariableDeclaration "hardCap"
     Type: uint256
     Gas costs: 0
     Source: "uint public hardCap = 300000000000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 300000000000000000000000000
       Type: int_const 300000000000000000000000000
       Source: "300000000000000000000000000"
  VariableDeclaration "remain"
     Type: uint256
     Gas costs: 0
     Source: "uint public remain = 300000000000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 300000000000000000000000000
       Type: int_const 300000000000000000000000000
       Source: "300000000000000000000000000"
  VariableDeclaration "minTx"
     Type: uint256
     Gas costs: 0
     Source: "uint public minTx = 100000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 100000000000000000000
       Type: int_const 100000000000000000000
       Source: "100000000000000000000"
  VariableDeclaration "isFounder"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping(address => bool) isFounder"
    Mapping
       Source: "mapping(address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  FunctionDefinition "FounderThreader" - public
     Source: "function FounderThreader (AirDropper _airdropper, address[] _founders) public {\r\n    airdropper = AirDropper(_airdropper);\r\n    for (uint i = 0; i < _founders.length; i++) {\r\n      isFounder[_founders[i]] = true;\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(AirDropper _airdropper, address[] _founders)"
      VariableDeclaration "_airdropper"
         Type: contract AirDropper
         Source: "AirDropper _airdropper"
        UserDefinedTypeName "AirDropper"
           Source: "AirDropper"
      VariableDeclaration "_founders"
         Type: address[] memory
         Source: "address[] _founders"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    airdropper = AirDropper(_airdropper);\r\n    for (uint i = 0; i < _founders.length; i++) {\r\n      isFounder[_founders[i]] = true;\r\n    }\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "airdropper = AirDropper(_airdropper)"
        Assignment using operator =
           Type: contract AirDropper
           Source: "airdropper = AirDropper(_airdropper)"
          Identifier airdropper
             Type: contract AirDropper
             Source: "airdropper"
          FunctionCall
             Type: contract AirDropper
             Source: "AirDropper(_airdropper)"
            Identifier AirDropper
               Type: type(contract AirDropper)
               Source: "AirDropper"
            Identifier _airdropper
               Type: contract AirDropper
               Source: "_airdropper"
      ForStatement
         Source: "for (uint i = 0; i < _founders.length; i++) {\r\n      isFounder[_founders[i]] = true;\r\n    }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < _founders.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_founders.length"
            Identifier _founders
               Type: address[] memory
               Source: "_founders"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n      isFounder[_founders[i]] = true;\r\n    }"
          ExpressionStatement
             Gas costs: 0
             Source: "isFounder[_founders[i]] = true"
            Assignment using operator =
               Type: bool
               Source: "isFounder[_founders[i]] = true"
              IndexAccess
                 Type: bool
                 Source: "isFounder[_founders[i]]"
                Identifier isFounder
                   Type: mapping(address => bool)
                   Source: "isFounder"
                IndexAccess
                   Type: address
                   Source: "_founders[i]"
                  Identifier _founders
                     Type: address[] memory
                     Source: "_founders"
                  Identifier i
                     Type: uint256
                     Source: "i"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
  FunctionDefinition "transferFor" - public
     Source: "function transferFor(address _recipient, uint _tokens) external onlyOwner {\r\n    require(_recipient != address(0));\r\n    require(_tokens >= minTx);\r\n    require(isFounder[_recipient]);\r\n\r\n    StandardToken token = StandardToken(airdropper.getToken());\r\n\r\n    TreasureBox box1 = new TreasureBox(token, _recipient, 1533088800); // can open 2018-08-01 09+07:00\r\n    TreasureBox box2 = new TreasureBox(token, _recipient, 1548986400); // can open 2019-02-01 09+07:00\r\n\r\n    airdropper.setTreasureBox(box1, true);\r\n    airdropper.setTreasureBox(box2, true);\r\n\r\n    token.transferFrom(owner, _recipient, _tokens.mul(33).div(100)); // 33 % for now\r\n    token.transferFrom(owner, box1, _tokens.mul(33).div(100)); // 33 % for box1\r\n    token.transferFrom(owner, box2, _tokens.mul(34).div(100)); // 34 % for box2\r\n\r\n    remain = remain.sub(_tokens);\r\n\r\n    TokenTransferForFounder(_recipient, _tokens, box1, box2);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _recipient, uint _tokens)"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(_recipient != address(0));\r\n    require(_tokens >= minTx);\r\n    require(isFounder[_recipient]);\r\n\r\n    StandardToken token = StandardToken(airdropper.getToken());\r\n\r\n    TreasureBox box1 = new TreasureBox(token, _recipient, 1533088800); // can open 2018-08-01 09+07:00\r\n    TreasureBox box2 = new TreasureBox(token, _recipient, 1548986400); // can open 2019-02-01 09+07:00\r\n\r\n    airdropper.setTreasureBox(box1, true);\r\n    airdropper.setTreasureBox(box2, true);\r\n\r\n    token.transferFrom(owner, _recipient, _tokens.mul(33).div(100)); // 33 % for now\r\n    token.transferFrom(owner, box1, _tokens.mul(33).div(100)); // 33 % for box1\r\n    token.transferFrom(owner, box2, _tokens.mul(34).div(100)); // 34 % for box2\r\n\r\n    remain = remain.sub(_tokens);\r\n\r\n    TokenTransferForFounder(_recipient, _tokens, box1, box2);\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_recipient != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_recipient != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_recipient != address(0)"
            Identifier _recipient
               Type: address
               Source: "_recipient"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_tokens >= minTx)"
        FunctionCall
           Type: tuple()
           Source: "require(_tokens >= minTx)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "_tokens >= minTx"
            Identifier _tokens
               Type: uint256
               Source: "_tokens"
            Identifier minTx
               Type: uint256
               Source: "minTx"
      ExpressionStatement
         Gas costs: 0
         Source: "require(isFounder[_recipient])"
        FunctionCall
           Type: tuple()
           Source: "require(isFounder[_recipient])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          IndexAccess
             Type: bool
             Source: "isFounder[_recipient]"
            Identifier isFounder
               Type: mapping(address => bool)
               Source: "isFounder"
            Identifier _recipient
               Type: address
               Source: "_recipient"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "StandardToken token = StandardToken(airdropper.getToken())"
        VariableDeclaration "token"
           Type: contract StandardToken
           Source: "StandardToken token"
          UserDefinedTypeName "StandardToken"
             Source: "StandardToken"
        FunctionCall
           Type: contract StandardToken
           Source: "StandardToken(airdropper.getToken())"
          Identifier StandardToken
             Type: type(contract StandardToken)
             Source: "StandardToken"
          FunctionCall
             Type: contract StandardToken
             Source: "airdropper.getToken()"
            MemberAccess to member getToken
               Type: function () view external returns (contract StandardToken)
               Source: "airdropper.getToken"
              Identifier airdropper
                 Type: contract AirDropper
                 Source: "airdropper"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "TreasureBox box1 = new TreasureBox(token, _recipient, 1533088800)"
        VariableDeclaration "box1"
           Type: contract TreasureBox
           Source: "TreasureBox box1"
          UserDefinedTypeName "TreasureBox"
             Source: "TreasureBox"
        FunctionCall
           Type: contract TreasureBox
           Source: "new TreasureBox(token, _recipient, 1533088800)"
          NewExpression
             Type: function (contract StandardToken,address,uint256) returns (contract TreasureBox)
             Source: "new TreasureBox"
            UserDefinedTypeName "TreasureBox"
               Source: "TreasureBox"
          Identifier token
             Type: contract StandardToken
             Source: "token"
          Identifier _recipient
             Type: address
             Source: "_recipient"
          Literal, token: [no token] value: 1533088800
             Type: int_const 1533088800
             Source: "1533088800"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "TreasureBox box2 = new TreasureBox(token, _recipient, 1548986400)"
        VariableDeclaration "box2"
           Type: contract TreasureBox
           Source: "TreasureBox box2"
          UserDefinedTypeName "TreasureBox"
             Source: "TreasureBox"
        FunctionCall
           Type: contract TreasureBox
           Source: "new TreasureBox(token, _recipient, 1548986400)"
          NewExpression
             Type: function (contract StandardToken,address,uint256) returns (contract TreasureBox)
             Source: "new TreasureBox"
            UserDefinedTypeName "TreasureBox"
               Source: "TreasureBox"
          Identifier token
             Type: contract StandardToken
             Source: "token"
          Identifier _recipient
             Type: address
             Source: "_recipient"
          Literal, token: [no token] value: 1548986400
             Type: int_const 1548986400
             Source: "1548986400"
      ExpressionStatement
         Gas costs: 0
         Source: "airdropper.setTreasureBox(box1, true)"
        FunctionCall
           Type: tuple()
           Source: "airdropper.setTreasureBox(box1, true)"
          MemberAccess to member setTreasureBox
             Type: function (address,bool) external
             Source: "airdropper.setTreasureBox"
            Identifier airdropper
               Type: contract AirDropper
               Source: "airdropper"
          Identifier box1
             Type: contract TreasureBox
             Source: "box1"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "airdropper.setTreasureBox(box2, true)"
        FunctionCall
           Type: tuple()
           Source: "airdropper.setTreasureBox(box2, true)"
          MemberAccess to member setTreasureBox
             Type: function (address,bool) external
             Source: "airdropper.setTreasureBox"
            Identifier airdropper
               Type: contract AirDropper
               Source: "airdropper"
          Identifier box2
             Type: contract TreasureBox
             Source: "box2"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 0
         Source: "token.transferFrom(owner, _recipient, _tokens.mul(33).div(100))"
        FunctionCall
           Type: bool
           Source: "token.transferFrom(owner, _recipient, _tokens.mul(33).div(100))"
          MemberAccess to member transferFrom
             Type: function (address,address,uint256) external returns (bool)
             Source: "token.transferFrom"
            Identifier token
               Type: contract StandardToken
               Source: "token"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier _recipient
             Type: address
             Source: "_recipient"
          FunctionCall
             Type: uint256
             Source: "_tokens.mul(33).div(100)"
            MemberAccess to member div
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_tokens.mul(33).div"
              FunctionCall
                 Type: uint256
                 Source: "_tokens.mul(33)"
                MemberAccess to member mul
                   Type: function (uint256,uint256) pure returns (uint256)
                   Source: "_tokens.mul"
                  Identifier _tokens
                     Type: uint256
                     Source: "_tokens"
                Literal, token: [no token] value: 33
                   Type: int_const 33
                   Source: "33"
            Literal, token: [no token] value: 100
               Type: int_const 100
               Source: "100"
      ExpressionStatement
         Gas costs: 0
         Source: "token.transferFrom(owner, box1, _tokens.mul(33).div(100))"
        FunctionCall
           Type: bool
           Source: "token.transferFrom(owner, box1, _tokens.mul(33).div(100))"
          MemberAccess to member transferFrom
             Type: function (address,address,uint256) external returns (bool)
             Source: "token.transferFrom"
            Identifier token
               Type: contract StandardToken
               Source: "token"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier box1
             Type: contract TreasureBox
             Source: "box1"
          FunctionCall
             Type: uint256
             Source: "_tokens.mul(33).div(100)"
            MemberAccess to member div
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_tokens.mul(33).div"
              FunctionCall
                 Type: uint256
                 Source: "_tokens.mul(33)"
                MemberAccess to member mul
                   Type: function (uint256,uint256) pure returns (uint256)
                   Source: "_tokens.mul"
                  Identifier _tokens
                     Type: uint256
                     Source: "_tokens"
                Literal, token: [no token] value: 33
                   Type: int_const 33
                   Source: "33"
            Literal, token: [no token] value: 100
               Type: int_const 100
               Source: "100"
      ExpressionStatement
         Gas costs: 0
         Source: "token.transferFrom(owner, box2, _tokens.mul(34).div(100))"
        FunctionCall
           Type: bool
           Source: "token.transferFrom(owner, box2, _tokens.mul(34).div(100))"
          MemberAccess to member transferFrom
             Type: function (address,address,uint256) external returns (bool)
             Source: "token.transferFrom"
            Identifier token
               Type: contract StandardToken
               Source: "token"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier box2
             Type: contract TreasureBox
             Source: "box2"
          FunctionCall
             Type: uint256
             Source: "_tokens.mul(34).div(100)"
            MemberAccess to member div
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_tokens.mul(34).div"
              FunctionCall
                 Type: uint256
                 Source: "_tokens.mul(34)"
                MemberAccess to member mul
                   Type: function (uint256,uint256) pure returns (uint256)
                   Source: "_tokens.mul"
                  Identifier _tokens
                     Type: uint256
                     Source: "_tokens"
                Literal, token: [no token] value: 34
                   Type: int_const 34
                   Source: "34"
            Literal, token: [no token] value: 100
               Type: int_const 100
               Source: "100"
      ExpressionStatement
         Gas costs: 0
         Source: "remain = remain.sub(_tokens)"
        Assignment using operator =
           Type: uint256
           Source: "remain = remain.sub(_tokens)"
          Identifier remain
             Type: uint256
             Source: "remain"
          FunctionCall
             Type: uint256
             Source: "remain.sub(_tokens)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "remain.sub"
              Identifier remain
                 Type: uint256
                 Source: "remain"
            Identifier _tokens
               Type: uint256
               Source: "_tokens"
      ExpressionStatement
         Gas costs: 0
         Source: "TokenTransferForFounder(_recipient, _tokens, box1, box2)"
        FunctionCall
           Type: tuple()
           Source: "TokenTransferForFounder(_recipient, _tokens, box1, box2)"
          Identifier TokenTransferForFounder
             Type: function (address,uint256,address,address)
             Source: "TokenTransferForFounder"
          Identifier _recipient
             Type: address
             Source: "_recipient"
          Identifier _tokens
             Type: uint256
             Source: "_tokens"
          Identifier box1
             Type: contract TreasureBox
             Source: "box1"
          Identifier box2
             Type: contract TreasureBox
             Source: "box2"
ContractDefinition "PreSale"
   Source: "contract PreSale is Ownable {\r\n  using SafeMath for uint;\r\n\r\n  event TokenSold(address _recipient, uint _value, uint _tokens, uint _rate);\r\n  event TokenSold(address _recipient, uint _tokens);\r\n\r\n  ZMINE public token;\r\n  WhiteList whitelist;\r\n\r\n  uint public hardCap = 300000000000000000000000000; // 300 000 000 * 1e18\r\n  uint public remain = 300000000000000000000000000; // 300 000 000 * 1e18\r\n\r\n  uint public startDate = 1512525600; // 2017-12-06 09+07:00\r\n  uint public stopDate = 1517364000;  // 2018-01-31 09+07:00\r\n\r\n  uint public minTx = 100000000000000000000; // 100 * 1e18\r\n  uint public maxTx = 100000000000000000000000; // 100 000 * 1e18\r\n\r\n  RateContract rateContract;\r\n\r\n  function PreSale (ZMINE _token, RateContract _rateContract, WhiteList _whitelist) public {\r\n    token = ZMINE(_token);\r\n    rateContract = RateContract(_rateContract);\r\n    whitelist = WhiteList(_whitelist);\r\n  }\r\n\r\n  /**\r\n  * transfer token to presale investor who pay by cash\r\n  */\r\n  function transferFor(address _recipient, uint _tokens) external onlyOwner {\r\n    require(_recipient != address(0));\r\n    require(available());\r\n\r\n    remain = remain.sub(_tokens);\r\n    token.transferFrom(owner, _recipient, _tokens);\r\n\r\n    TokenSold(_recipient, _tokens);\r\n  }\r\n\r\n  function sale(address _recipient, uint _value, uint _rate) private {\r\n    require(_recipient != address(0));\r\n    require(available());\r\n    require(isWhiteListed(_recipient));\r\n    require(_value >= minTx && _value <= maxTx);\r\n    uint tokens = _rate.mul(_value).div(1000000000000000000);\r\n\r\n    remain = remain.sub(tokens);\r\n    token.transferFrom(owner, _recipient, tokens);\r\n    owner.transfer(_value);\r\n\r\n    TokenSold(_recipient, _value, tokens, _rate);\r\n  }\r\n\r\n  function rate() public view returns (uint) {\r\n    return rateContract.getRate();\r\n  }\r\n\r\n  function available() public view returns (bool) {\r\n    return (now > startDate && now < stopDate);\r\n  }\r\n\r\n  function isWhiteListed(address _address) public view returns (bool) {\r\n    return whitelist.isWhiteListed(_address);\r\n  }\r\n\r\n  function() external payable {\r\n    sale(msg.sender, msg.value, rate());\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint
       Source: "uint"
  EventDefinition "TokenSold"
     Gas costs: 0
     Source: "event TokenSold(address _recipient, uint _value, uint _tokens, uint _rate);"
    ParameterList
       Source: "(address _recipient, uint _value, uint _tokens, uint _rate)"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_rate"
         Type: uint256
         Source: "uint _rate"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "TokenSold"
     Gas costs: 0
     Source: "event TokenSold(address _recipient, uint _tokens);"
    ParameterList
       Source: "(address _recipient, uint _tokens)"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "token"
     Type: contract ZMINE
     Gas costs: 0
     Source: "ZMINE public token"
    UserDefinedTypeName "ZMINE"
       Source: "ZMINE"
  VariableDeclaration "whitelist"
     Type: contract WhiteList
     Gas costs: 0
     Source: "WhiteList whitelist"
    UserDefinedTypeName "WhiteList"
       Source: "WhiteList"
  VariableDeclaration "hardCap"
     Type: uint256
     Gas costs: 0
     Source: "uint public hardCap = 300000000000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 300000000000000000000000000
       Type: int_const 300000000000000000000000000
       Source: "300000000000000000000000000"
  VariableDeclaration "remain"
     Type: uint256
     Gas costs: 0
     Source: "uint public remain = 300000000000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 300000000000000000000000000
       Type: int_const 300000000000000000000000000
       Source: "300000000000000000000000000"
  VariableDeclaration "startDate"
     Type: uint256
     Gas costs: 0
     Source: "uint public startDate = 1512525600"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1512525600
       Type: int_const 1512525600
       Source: "1512525600"
  VariableDeclaration "stopDate"
     Type: uint256
     Gas costs: 0
     Source: "uint public stopDate = 1517364000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1517364000
       Type: int_const 1517364000
       Source: "1517364000"
  VariableDeclaration "minTx"
     Type: uint256
     Gas costs: 0
     Source: "uint public minTx = 100000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 100000000000000000000
       Type: int_const 100000000000000000000
       Source: "100000000000000000000"
  VariableDeclaration "maxTx"
     Type: uint256
     Gas costs: 0
     Source: "uint public maxTx = 100000000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 100000000000000000000000
       Type: int_const 100000000000000000000000
       Source: "100000000000000000000000"
  VariableDeclaration "rateContract"
     Type: contract RateContract
     Gas costs: 0
     Source: "RateContract rateContract"
    UserDefinedTypeName "RateContract"
       Source: "RateContract"
  FunctionDefinition "PreSale" - public
     Source: "function PreSale (ZMINE _token, RateContract _rateContract, WhiteList _whitelist) public {\r\n    token = ZMINE(_token);\r\n    rateContract = RateContract(_rateContract);\r\n    whitelist = WhiteList(_whitelist);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(ZMINE _token, RateContract _rateContract, WhiteList _whitelist)"
      VariableDeclaration "_token"
         Type: contract ZMINE
         Source: "ZMINE _token"
        UserDefinedTypeName "ZMINE"
           Source: "ZMINE"
      VariableDeclaration "_rateContract"
         Type: contract RateContract
         Source: "RateContract _rateContract"
        UserDefinedTypeName "RateContract"
           Source: "RateContract"
      VariableDeclaration "_whitelist"
         Type: contract WhiteList
         Source: "WhiteList _whitelist"
        UserDefinedTypeName "WhiteList"
           Source: "WhiteList"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    token = ZMINE(_token);\r\n    rateContract = RateContract(_rateContract);\r\n    whitelist = WhiteList(_whitelist);\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "token = ZMINE(_token)"
        Assignment using operator =
           Type: contract ZMINE
           Source: "token = ZMINE(_token)"
          Identifier token
             Type: contract ZMINE
             Source: "token"
          FunctionCall
             Type: contract ZMINE
             Source: "ZMINE(_token)"
            Identifier ZMINE
               Type: type(contract ZMINE)
               Source: "ZMINE"
            Identifier _token
               Type: contract ZMINE
               Source: "_token"
      ExpressionStatement
         Gas costs: 0
         Source: "rateContract = RateContract(_rateContract)"
        Assignment using operator =
           Type: contract RateContract
           Source: "rateContract = RateContract(_rateContract)"
          Identifier rateContract
             Type: contract RateContract
             Source: "rateContract"
          FunctionCall
             Type: contract RateContract
             Source: "RateContract(_rateContract)"
            Identifier RateContract
               Type: type(contract RateContract)
               Source: "RateContract"
            Identifier _rateContract
               Type: contract RateContract
               Source: "_rateContract"
      ExpressionStatement
         Gas costs: 0
         Source: "whitelist = WhiteList(_whitelist)"
        Assignment using operator =
           Type: contract WhiteList
           Source: "whitelist = WhiteList(_whitelist)"
          Identifier whitelist
             Type: contract WhiteList
             Source: "whitelist"
          FunctionCall
             Type: contract WhiteList
             Source: "WhiteList(_whitelist)"
            Identifier WhiteList
               Type: type(contract WhiteList)
               Source: "WhiteList"
            Identifier _whitelist
               Type: contract WhiteList
               Source: "_whitelist"
  FunctionDefinition "transferFor" - public
     Source: "function transferFor(address _recipient, uint _tokens) external onlyOwner {\r\n    require(_recipient != address(0));\r\n    require(available());\r\n\r\n    remain = remain.sub(_tokens);\r\n    token.transferFrom(owner, _recipient, _tokens);\r\n\r\n    TokenSold(_recipient, _tokens);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _recipient, uint _tokens)"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(_recipient != address(0));\r\n    require(available());\r\n\r\n    remain = remain.sub(_tokens);\r\n    token.transferFrom(owner, _recipient, _tokens);\r\n\r\n    TokenSold(_recipient, _tokens);\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_recipient != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_recipient != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_recipient != address(0)"
            Identifier _recipient
               Type: address
               Source: "_recipient"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(available())"
        FunctionCall
           Type: tuple()
           Source: "require(available())"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "available()"
            Identifier available
               Type: function () view returns (bool)
               Source: "available"
      ExpressionStatement
         Gas costs: 0
         Source: "remain = remain.sub(_tokens)"
        Assignment using operator =
           Type: uint256
           Source: "remain = remain.sub(_tokens)"
          Identifier remain
             Type: uint256
             Source: "remain"
          FunctionCall
             Type: uint256
             Source: "remain.sub(_tokens)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "remain.sub"
              Identifier remain
                 Type: uint256
                 Source: "remain"
            Identifier _tokens
               Type: uint256
               Source: "_tokens"
      ExpressionStatement
         Gas costs: 0
         Source: "token.transferFrom(owner, _recipient, _tokens)"
        FunctionCall
           Type: bool
           Source: "token.transferFrom(owner, _recipient, _tokens)"
          MemberAccess to member transferFrom
             Type: function (address,address,uint256) external returns (bool)
             Source: "token.transferFrom"
            Identifier token
               Type: contract ZMINE
               Source: "token"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier _recipient
             Type: address
             Source: "_recipient"
          Identifier _tokens
             Type: uint256
             Source: "_tokens"
      ExpressionStatement
         Gas costs: 0
         Source: "TokenSold(_recipient, _tokens)"
        FunctionCall
           Type: tuple()
           Source: "TokenSold(_recipient, _tokens)"
          Identifier TokenSold
             Type: function (address,uint256)
             Source: "TokenSold"
          Identifier _recipient
             Type: address
             Source: "_recipient"
          Identifier _tokens
             Type: uint256
             Source: "_tokens"
  FunctionDefinition "sale"
     Source: "function sale(address _recipient, uint _value, uint _rate) private {\r\n    require(_recipient != address(0));\r\n    require(available());\r\n    require(isWhiteListed(_recipient));\r\n    require(_value >= minTx && _value <= maxTx);\r\n    uint tokens = _rate.mul(_value).div(1000000000000000000);\r\n\r\n    remain = remain.sub(tokens);\r\n    token.transferFrom(owner, _recipient, tokens);\r\n    owner.transfer(_value);\r\n\r\n    TokenSold(_recipient, _value, tokens, _rate);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _recipient, uint _value, uint _rate)"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_rate"
         Type: uint256
         Source: "uint _rate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    require(_recipient != address(0));\r\n    require(available());\r\n    require(isWhiteListed(_recipient));\r\n    require(_value >= minTx && _value <= maxTx);\r\n    uint tokens = _rate.mul(_value).div(1000000000000000000);\r\n\r\n    remain = remain.sub(tokens);\r\n    token.transferFrom(owner, _recipient, tokens);\r\n    owner.transfer(_value);\r\n\r\n    TokenSold(_recipient, _value, tokens, _rate);\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_recipient != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_recipient != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_recipient != address(0)"
            Identifier _recipient
               Type: address
               Source: "_recipient"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(available())"
        FunctionCall
           Type: tuple()
           Source: "require(available())"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "available()"
            Identifier available
               Type: function () view returns (bool)
               Source: "available"
      ExpressionStatement
         Gas costs: 0
         Source: "require(isWhiteListed(_recipient))"
        FunctionCall
           Type: tuple()
           Source: "require(isWhiteListed(_recipient))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "isWhiteListed(_recipient)"
            Identifier isWhiteListed
               Type: function (address) view returns (bool)
               Source: "isWhiteListed"
            Identifier _recipient
               Type: address
               Source: "_recipient"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_value >= minTx && _value <= maxTx)"
        FunctionCall
           Type: tuple()
           Source: "require(_value >= minTx && _value <= maxTx)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_value >= minTx && _value <= maxTx"
            BinaryOperation using operator >=
               Type: bool
               Source: "_value >= minTx"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier minTx
                 Type: uint256
                 Source: "minTx"
            BinaryOperation using operator <=
               Type: bool
               Source: "_value <= maxTx"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier maxTx
                 Type: uint256
                 Source: "maxTx"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint tokens = _rate.mul(_value).div(1000000000000000000)"
        VariableDeclaration "tokens"
           Type: uint256
           Source: "uint tokens"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "_rate.mul(_value).div(1000000000000000000)"
          MemberAccess to member div
             Type: function (uint256,uint256) pure returns (uint256)
             Source: "_rate.mul(_value).div"
            FunctionCall
               Type: uint256
               Source: "_rate.mul(_value)"
              MemberAccess to member mul
                 Type: function (uint256,uint256) pure returns (uint256)
                 Source: "_rate.mul"
                Identifier _rate
                   Type: uint256
                   Source: "_rate"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Literal, token: [no token] value: 1000000000000000000
             Type: int_const 1000000000000000000
             Source: "1000000000000000000"
      ExpressionStatement
         Gas costs: 0
         Source: "remain = remain.sub(tokens)"
        Assignment using operator =
           Type: uint256
           Source: "remain = remain.sub(tokens)"
          Identifier remain
             Type: uint256
             Source: "remain"
          FunctionCall
             Type: uint256
             Source: "remain.sub(tokens)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "remain.sub"
              Identifier remain
                 Type: uint256
                 Source: "remain"
            Identifier tokens
               Type: uint256
               Source: "tokens"
      ExpressionStatement
         Gas costs: 0
         Source: "token.transferFrom(owner, _recipient, tokens)"
        FunctionCall
           Type: bool
           Source: "token.transferFrom(owner, _recipient, tokens)"
          MemberAccess to member transferFrom
             Type: function (address,address,uint256) external returns (bool)
             Source: "token.transferFrom"
            Identifier token
               Type: contract ZMINE
               Source: "token"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier _recipient
             Type: address
             Source: "_recipient"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: 0
         Source: "owner.transfer(_value)"
        FunctionCall
           Type: tuple()
           Source: "owner.transfer(_value)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "owner.transfer"
            Identifier owner
               Type: address
               Source: "owner"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "TokenSold(_recipient, _value, tokens, _rate)"
        FunctionCall
           Type: tuple()
           Source: "TokenSold(_recipient, _value, tokens, _rate)"
          Identifier TokenSold
             Type: function (address,uint256,uint256,uint256)
             Source: "TokenSold"
          Identifier _recipient
             Type: address
             Source: "_recipient"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier tokens
             Type: uint256
             Source: "tokens"
          Identifier _rate
             Type: uint256
             Source: "_rate"
  FunctionDefinition "rate" - public - const
     Source: "function rate() public view returns (uint) {\r\n    return rateContract.getRate();\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return rateContract.getRate();\r\n  }"
      Return
         Gas costs: 0
         Source: "return rateContract.getRate()"
        FunctionCall
           Type: uint256
           Source: "rateContract.getRate()"
          MemberAccess to member getRate
             Type: function () view external returns (uint256)
             Source: "rateContract.getRate"
            Identifier rateContract
               Type: contract RateContract
               Source: "rateContract"
  FunctionDefinition "available" - public - const
     Source: "function available() public view returns (bool) {\r\n    return (now > startDate && now < stopDate);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    return (now > startDate && now < stopDate);\r\n  }"
      Return
         Gas costs: 0
         Source: "return (now > startDate && now < stopDate)"
        TupleExpression
           Type: bool
           Source: "(now > startDate && now < stopDate)"
          BinaryOperation using operator &&
             Type: bool
             Source: "now > startDate && now < stopDate"
            BinaryOperation using operator >
               Type: bool
               Source: "now > startDate"
              Identifier now
                 Type: uint256
                 Source: "now"
              Identifier startDate
                 Type: uint256
                 Source: "startDate"
            BinaryOperation using operator <
               Type: bool
               Source: "now < stopDate"
              Identifier now
                 Type: uint256
                 Source: "now"
              Identifier stopDate
                 Type: uint256
                 Source: "stopDate"
  FunctionDefinition "isWhiteListed" - public - const
     Source: "function isWhiteListed(address _address) public view returns (bool) {\r\n    return whitelist.isWhiteListed(_address);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    return whitelist.isWhiteListed(_address);\r\n  }"
      Return
         Gas costs: 0
         Source: "return whitelist.isWhiteListed(_address)"
        FunctionCall
           Type: bool
           Source: "whitelist.isWhiteListed(_address)"
          MemberAccess to member isWhiteListed
             Type: function (address) view external returns (bool)
             Source: "whitelist.isWhiteListed"
            Identifier whitelist
               Type: contract WhiteList
               Source: "whitelist"
          Identifier _address
             Type: address
             Source: "_address"
  FunctionDefinition "" - public
     Source: "function() external payable {\r\n    sale(msg.sender, msg.value, rate());\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    sale(msg.sender, msg.value, rate());\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "sale(msg.sender, msg.value, rate())"
        FunctionCall
           Type: tuple()
           Source: "sale(msg.sender, msg.value, rate())"
          Identifier sale
             Type: function (address,uint256,uint256)
             Source: "sale"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          FunctionCall
             Type: uint256
             Source: "rate()"
            Identifier rate
               Type: function () view returns (uint256)
               Source: "rate"
ContractDefinition "PublicSale"
   Source: "contract PublicSale is Ownable {\r\n  using SafeMath for uint;\r\n\r\n  event TokenSold(address _recipient, uint _value, uint _tokens, uint _rate);\r\n  event IncreaseHardCap(uint _amount);\r\n\r\n  ZMINE public token;\r\n\r\n  WhiteList whitelistPublic;\r\n  WhiteList whitelistPRE;\r\n\r\n  uint public hardCap = 400000000000000000000000000; // 400 000 000 * 1e18\r\n  uint public remain = 400000000000000000000000000; // 400 000 000 * 1e18\r\n\r\n  uint public startDate = 1515376800; // 2018-01-08 09+07:00\r\n  uint public stopDate = 1517364000;  // 2018-01-31 09+07:00\r\n\r\n  uint public minTx = 1000000000000000000; // 1e18\r\n  uint public maxTx = 100000000000000000000000; // 100 000 1e18\r\n\r\n  RateContract rateContract;\r\n\r\n  function PublicSale(ZMINE _token, RateContract _rateContract, WhiteList _whitelistPRE, WhiteList _whitelistPublic) public {\r\n    token = ZMINE(_token);\r\n    rateContract = RateContract(_rateContract);\r\n    whitelistPRE = WhiteList(_whitelistPRE);\r\n    whitelistPublic = WhiteList(_whitelistPublic);\r\n  }\r\n\r\n  /**\r\n  * increase hard cap if previous dont sold out\r\n  */\r\n  function increaseHardCap(uint _amount) external onlyOwner {\r\n    require(_amount <= 300000000000000000000000000); // presale hard cap\r\n    hardCap = hardCap.add(_amount);\r\n    remain = remain.add(_amount);\r\n    IncreaseHardCap(_amount);\r\n  }\r\n\r\n  function sale(address _recipient, uint _value, uint _rate) private {\r\n    require(available());\r\n    require(isWhiteListed(_recipient));\r\n    require(_value >= minTx && _value <= maxTx);\r\n    uint tokens = _rate.mul(_value).div(1000000000000000000);\r\n\r\n    remain = remain.sub(tokens);\r\n    token.transferFrom(owner, _recipient, tokens);\r\n    owner.transfer(_value);\r\n\r\n    TokenSold(_recipient, _value, tokens, _rate);\r\n  }\r\n\r\n  function rate() public view returns (uint) {\r\n    return rateContract.getRate();\r\n  }\r\n\r\n  function available () public view returns (bool) {\r\n    return (now > startDate && now < stopDate);\r\n  }\r\n\r\n  function isWhiteListed (address _address) public view returns(bool) {\r\n    return (whitelistPRE.isWhiteListed(_address) || (whitelistPublic.isWhiteListed(_address)));\r\n  }\r\n\r\n  function() external payable {\r\n    sale(msg.sender, msg.value, rate());\r\n  }\r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Ownable"
    UserDefinedTypeName "Ownable"
       Source: "Ownable"
  UsingForDirective
     Gas costs: 0
     Source: "using SafeMath for uint;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint
       Source: "uint"
  EventDefinition "TokenSold"
     Gas costs: 0
     Source: "event TokenSold(address _recipient, uint _value, uint _tokens, uint _rate);"
    ParameterList
       Source: "(address _recipient, uint _value, uint _tokens, uint _rate)"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_tokens"
         Type: uint256
         Source: "uint _tokens"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_rate"
         Type: uint256
         Source: "uint _rate"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "IncreaseHardCap"
     Gas costs: 0
     Source: "event IncreaseHardCap(uint _amount);"
    ParameterList
       Source: "(uint _amount)"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "token"
     Type: contract ZMINE
     Gas costs: [???]
     Source: "ZMINE public token"
    UserDefinedTypeName "ZMINE"
       Source: "ZMINE"
  VariableDeclaration "whitelistPublic"
     Type: contract WhiteList
     Gas costs: 0
     Source: "WhiteList whitelistPublic"
    UserDefinedTypeName "WhiteList"
       Source: "WhiteList"
  VariableDeclaration "whitelistPRE"
     Type: contract WhiteList
     Gas costs: 0
     Source: "WhiteList whitelistPRE"
    UserDefinedTypeName "WhiteList"
       Source: "WhiteList"
  VariableDeclaration "hardCap"
     Type: uint256
     Gas costs: [???]
     Source: "uint public hardCap = 400000000000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 400000000000000000000000000
       Type: int_const 400000000000000000000000000
       Source: "400000000000000000000000000"
  VariableDeclaration "remain"
     Type: uint256
     Gas costs: [???]
     Source: "uint public remain = 400000000000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 400000000000000000000000000
       Type: int_const 400000000000000000000000000
       Source: "400000000000000000000000000"
  VariableDeclaration "startDate"
     Type: uint256
     Gas costs: [???]
     Source: "uint public startDate = 1515376800"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1515376800
       Type: int_const 1515376800
       Source: "1515376800"
  VariableDeclaration "stopDate"
     Type: uint256
     Gas costs: [???]
     Source: "uint public stopDate = 1517364000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1517364000
       Type: int_const 1517364000
       Source: "1517364000"
  VariableDeclaration "minTx"
     Type: uint256
     Gas costs: [???]
     Source: "uint public minTx = 1000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1000000000000000000
       Type: int_const 1000000000000000000
       Source: "1000000000000000000"
  VariableDeclaration "maxTx"
     Type: uint256
     Gas costs: [???]
     Source: "uint public maxTx = 100000000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 100000000000000000000000
       Type: int_const 100000000000000000000000
       Source: "100000000000000000000000"
  VariableDeclaration "rateContract"
     Type: contract RateContract
     Gas costs: 0
     Source: "RateContract rateContract"
    UserDefinedTypeName "RateContract"
       Source: "RateContract"
  FunctionDefinition "PublicSale" - public
     Source: "function PublicSale(ZMINE _token, RateContract _rateContract, WhiteList _whitelistPRE, WhiteList _whitelistPublic) public {\r\n    token = ZMINE(_token);\r\n    rateContract = RateContract(_rateContract);\r\n    whitelistPRE = WhiteList(_whitelistPRE);\r\n    whitelistPublic = WhiteList(_whitelistPublic);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(ZMINE _token, RateContract _rateContract, WhiteList _whitelistPRE, WhiteList _whitelistPublic)"
      VariableDeclaration "_token"
         Type: contract ZMINE
         Source: "ZMINE _token"
        UserDefinedTypeName "ZMINE"
           Source: "ZMINE"
      VariableDeclaration "_rateContract"
         Type: contract RateContract
         Source: "RateContract _rateContract"
        UserDefinedTypeName "RateContract"
           Source: "RateContract"
      VariableDeclaration "_whitelistPRE"
         Type: contract WhiteList
         Source: "WhiteList _whitelistPRE"
        UserDefinedTypeName "WhiteList"
           Source: "WhiteList"
      VariableDeclaration "_whitelistPublic"
         Type: contract WhiteList
         Source: "WhiteList _whitelistPublic"
        UserDefinedTypeName "WhiteList"
           Source: "WhiteList"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    token = ZMINE(_token);\r\n    rateContract = RateContract(_rateContract);\r\n    whitelistPRE = WhiteList(_whitelistPRE);\r\n    whitelistPublic = WhiteList(_whitelistPublic);\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "token = ZMINE(_token)"
        Assignment using operator =
           Type: contract ZMINE
           Source: "token = ZMINE(_token)"
          Identifier token
             Type: contract ZMINE
             Source: "token"
          FunctionCall
             Type: contract ZMINE
             Source: "ZMINE(_token)"
            Identifier ZMINE
               Type: type(contract ZMINE)
               Source: "ZMINE"
            Identifier _token
               Type: contract ZMINE
               Source: "_token"
      ExpressionStatement
         Gas costs: 0
         Source: "rateContract = RateContract(_rateContract)"
        Assignment using operator =
           Type: contract RateContract
           Source: "rateContract = RateContract(_rateContract)"
          Identifier rateContract
             Type: contract RateContract
             Source: "rateContract"
          FunctionCall
             Type: contract RateContract
             Source: "RateContract(_rateContract)"
            Identifier RateContract
               Type: type(contract RateContract)
               Source: "RateContract"
            Identifier _rateContract
               Type: contract RateContract
               Source: "_rateContract"
      ExpressionStatement
         Gas costs: 0
         Source: "whitelistPRE = WhiteList(_whitelistPRE)"
        Assignment using operator =
           Type: contract WhiteList
           Source: "whitelistPRE = WhiteList(_whitelistPRE)"
          Identifier whitelistPRE
             Type: contract WhiteList
             Source: "whitelistPRE"
          FunctionCall
             Type: contract WhiteList
             Source: "WhiteList(_whitelistPRE)"
            Identifier WhiteList
               Type: type(contract WhiteList)
               Source: "WhiteList"
            Identifier _whitelistPRE
               Type: contract WhiteList
               Source: "_whitelistPRE"
      ExpressionStatement
         Gas costs: 0
         Source: "whitelistPublic = WhiteList(_whitelistPublic)"
        Assignment using operator =
           Type: contract WhiteList
           Source: "whitelistPublic = WhiteList(_whitelistPublic)"
          Identifier whitelistPublic
             Type: contract WhiteList
             Source: "whitelistPublic"
          FunctionCall
             Type: contract WhiteList
             Source: "WhiteList(_whitelistPublic)"
            Identifier WhiteList
               Type: type(contract WhiteList)
               Source: "WhiteList"
            Identifier _whitelistPublic
               Type: contract WhiteList
               Source: "_whitelistPublic"
  FunctionDefinition "increaseHardCap" - public
     Source: "function increaseHardCap(uint _amount) external onlyOwner {\r\n    require(_amount <= 300000000000000000000000000); // presale hard cap\r\n    hardCap = hardCap.add(_amount);\r\n    remain = remain.add(_amount);\r\n    IncreaseHardCap(_amount);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint _amount)"
      VariableDeclaration "_amount"
         Type: uint256
         Source: "uint _amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n    require(_amount <= 300000000000000000000000000); // presale hard cap\r\n    hardCap = hardCap.add(_amount);\r\n    remain = remain.add(_amount);\r\n    IncreaseHardCap(_amount);\r\n  }"
      ExpressionStatement
         Gas costs: 38
         Source: "require(_amount <= 300000000000000000000000000)"
        FunctionCall
           Type: tuple()
           Source: "require(_amount <= 300000000000000000000000000)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_amount <= 300000000000000000000000000"
            Identifier _amount
               Type: uint256
               Source: "_amount"
            Literal, token: [no token] value: 300000000000000000000000000
               Type: int_const 300000000000000000000000000
               Source: "300000000000000000000000000"
      ExpressionStatement
         Gas costs: 20247
         Source: "hardCap = hardCap.add(_amount)"
        Assignment using operator =
           Type: uint256
           Source: "hardCap = hardCap.add(_amount)"
          Identifier hardCap
             Type: uint256
             Source: "hardCap"
          FunctionCall
             Type: uint256
             Source: "hardCap.add(_amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "hardCap.add"
              Identifier hardCap
                 Type: uint256
                 Source: "hardCap"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: 20247
         Source: "remain = remain.add(_amount)"
        Assignment using operator =
           Type: uint256
           Source: "remain = remain.add(_amount)"
          Identifier remain
             Type: uint256
             Source: "remain"
          FunctionCall
             Type: uint256
             Source: "remain.add(_amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "remain.add"
              Identifier remain
                 Type: uint256
                 Source: "remain"
            Identifier _amount
               Type: uint256
               Source: "_amount"
      ExpressionStatement
         Gas costs: [???]
         Source: "IncreaseHardCap(_amount)"
        FunctionCall
           Type: tuple()
           Source: "IncreaseHardCap(_amount)"
          Identifier IncreaseHardCap
             Type: function (uint256)
             Source: "IncreaseHardCap"
          Identifier _amount
             Type: uint256
             Source: "_amount"
  FunctionDefinition "sale"
     Source: "function sale(address _recipient, uint _value, uint _rate) private {\r\n    require(available());\r\n    require(isWhiteListed(_recipient));\r\n    require(_value >= minTx && _value <= maxTx);\r\n    uint tokens = _rate.mul(_value).div(1000000000000000000);\r\n\r\n    remain = remain.sub(tokens);\r\n    token.transferFrom(owner, _recipient, tokens);\r\n    owner.transfer(_value);\r\n\r\n    TokenSold(_recipient, _value, tokens, _rate);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _recipient, uint _value, uint _rate)"
      VariableDeclaration "_recipient"
         Type: address
         Source: "address _recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_rate"
         Type: uint256
         Source: "uint _rate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    require(available());\r\n    require(isWhiteListed(_recipient));\r\n    require(_value >= minTx && _value <= maxTx);\r\n    uint tokens = _rate.mul(_value).div(1000000000000000000);\r\n\r\n    remain = remain.sub(tokens);\r\n    token.transferFrom(owner, _recipient, tokens);\r\n    owner.transfer(_value);\r\n\r\n    TokenSold(_recipient, _value, tokens, _rate);\r\n  }"
      ExpressionStatement
         Gas costs: 30
         Source: "require(available())"
        FunctionCall
           Type: tuple()
           Source: "require(available())"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "available()"
            Identifier available
               Type: function () view returns (bool)
               Source: "available"
      ExpressionStatement
         Gas costs: 44
         Source: "require(isWhiteListed(_recipient))"
        FunctionCall
           Type: tuple()
           Source: "require(isWhiteListed(_recipient))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "isWhiteListed(_recipient)"
            Identifier isWhiteListed
               Type: function (address) view returns (bool)
               Source: "isWhiteListed"
            Identifier _recipient
               Type: address
               Source: "_recipient"
      ExpressionStatement
         Gas costs: 472
         Source: "require(_value >= minTx && _value <= maxTx)"
        FunctionCall
           Type: tuple()
           Source: "require(_value >= minTx && _value <= maxTx)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_value >= minTx && _value <= maxTx"
            BinaryOperation using operator >=
               Type: bool
               Source: "_value >= minTx"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier minTx
                 Type: uint256
                 Source: "minTx"
            BinaryOperation using operator <=
               Type: bool
               Source: "_value <= maxTx"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier maxTx
                 Type: uint256
                 Source: "maxTx"
      VariableDeclarationStatement
         Gas costs: 77
         Source: "uint tokens = _rate.mul(_value).div(1000000000000000000)"
        VariableDeclaration "tokens"
           Type: uint256
           Source: "uint tokens"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "_rate.mul(_value).div(1000000000000000000)"
          MemberAccess to member div
             Type: function (uint256,uint256) pure returns (uint256)
             Source: "_rate.mul(_value).div"
            FunctionCall
               Type: uint256
               Source: "_rate.mul(_value)"
              MemberAccess to member mul
                 Type: function (uint256,uint256) pure returns (uint256)
                 Source: "_rate.mul"
                Identifier _rate
                   Type: uint256
                   Source: "_rate"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Literal, token: [no token] value: 1000000000000000000
             Type: int_const 1000000000000000000
             Source: "1000000000000000000"
      ExpressionStatement
         Gas costs: 20247
         Source: "remain = remain.sub(tokens)"
        Assignment using operator =
           Type: uint256
           Source: "remain = remain.sub(tokens)"
          Identifier remain
             Type: uint256
             Source: "remain"
          FunctionCall
             Type: uint256
             Source: "remain.sub(tokens)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "remain.sub"
              Identifier remain
                 Type: uint256
                 Source: "remain"
            Identifier tokens
               Type: uint256
               Source: "tokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "token.transferFrom(owner, _recipient, tokens)"
        FunctionCall
           Type: bool
           Source: "token.transferFrom(owner, _recipient, tokens)"
          MemberAccess to member transferFrom
             Type: function (address,address,uint256) external returns (bool)
             Source: "token.transferFrom"
            Identifier token
               Type: contract ZMINE
               Source: "token"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier _recipient
             Type: address
             Source: "_recipient"
          Identifier tokens
             Type: uint256
             Source: "tokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "owner.transfer(_value)"
        FunctionCall
           Type: tuple()
           Source: "owner.transfer(_value)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "owner.transfer"
            Identifier owner
               Type: address
               Source: "owner"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "TokenSold(_recipient, _value, tokens, _rate)"
        FunctionCall
           Type: tuple()
           Source: "TokenSold(_recipient, _value, tokens, _rate)"
          Identifier TokenSold
             Type: function (address,uint256,uint256,uint256)
             Source: "TokenSold"
          Identifier _recipient
             Type: address
             Source: "_recipient"
          Identifier _value
             Type: uint256
             Source: "_value"
          Identifier tokens
             Type: uint256
             Source: "tokens"
          Identifier _rate
             Type: uint256
             Source: "_rate"
  FunctionDefinition "rate" - public - const
     Source: "function rate() public view returns (uint) {\r\n    return rateContract.getRate();\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return rateContract.getRate();\r\n  }"
      Return
         Gas costs: [???]
         Source: "return rateContract.getRate()"
        FunctionCall
           Type: uint256
           Source: "rateContract.getRate()"
          MemberAccess to member getRate
             Type: function () view external returns (uint256)
             Source: "rateContract.getRate"
            Identifier rateContract
               Type: contract RateContract
               Source: "rateContract"
  FunctionDefinition "available" - public - const
     Source: "function available () public view returns (bool) {\r\n    return (now > startDate && now < stopDate);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    return (now > startDate && now < stopDate);\r\n  }"
      Return
         Gas costs: 443
         Source: "return (now > startDate && now < stopDate)"
        TupleExpression
           Type: bool
           Source: "(now > startDate && now < stopDate)"
          BinaryOperation using operator &&
             Type: bool
             Source: "now > startDate && now < stopDate"
            BinaryOperation using operator >
               Type: bool
               Source: "now > startDate"
              Identifier now
                 Type: uint256
                 Source: "now"
              Identifier startDate
                 Type: uint256
                 Source: "startDate"
            BinaryOperation using operator <
               Type: bool
               Source: "now < stopDate"
              Identifier now
                 Type: uint256
                 Source: "now"
              Identifier stopDate
                 Type: uint256
                 Source: "stopDate"
  FunctionDefinition "isWhiteListed" - public - const
     Source: "function isWhiteListed (address _address) public view returns(bool) {\r\n    return (whitelistPRE.isWhiteListed(_address) || (whitelistPublic.isWhiteListed(_address)));\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _address)"
      VariableDeclaration "_address"
         Type: address
         Source: "address _address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    return (whitelistPRE.isWhiteListed(_address) || (whitelistPublic.isWhiteListed(_address)));\r\n  }"
      Return
         Gas costs: [???]
         Source: "return (whitelistPRE.isWhiteListed(_address) || (whitelistPublic.isWhiteListed(_address)))"
        TupleExpression
           Type: bool
           Source: "(whitelistPRE.isWhiteListed(_address) || (whitelistPublic.isWhiteListed(_address)))"
          BinaryOperation using operator ||
             Type: bool
             Source: "whitelistPRE.isWhiteListed(_address) || (whitelistPublic.isWhiteListed(_address))"
            FunctionCall
               Type: bool
               Source: "whitelistPRE.isWhiteListed(_address)"
              MemberAccess to member isWhiteListed
                 Type: function (address) view external returns (bool)
                 Source: "whitelistPRE.isWhiteListed"
                Identifier whitelistPRE
                   Type: contract WhiteList
                   Source: "whitelistPRE"
              Identifier _address
                 Type: address
                 Source: "_address"
            TupleExpression
               Type: bool
               Source: "(whitelistPublic.isWhiteListed(_address))"
              FunctionCall
                 Type: bool
                 Source: "whitelistPublic.isWhiteListed(_address)"
                MemberAccess to member isWhiteListed
                   Type: function (address) view external returns (bool)
                   Source: "whitelistPublic.isWhiteListed"
                  Identifier whitelistPublic
                     Type: contract WhiteList
                     Source: "whitelistPublic"
                Identifier _address
                   Type: address
                   Source: "_address"
  FunctionDefinition "" - public
     Source: "function() external payable {\r\n    sale(msg.sender, msg.value, rate());\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    sale(msg.sender, msg.value, rate());\r\n  }"
      ExpressionStatement
         Gas costs: 12
         Source: "sale(msg.sender, msg.value, rate())"
        FunctionCall
           Type: tuple()
           Source: "sale(msg.sender, msg.value, rate())"
          Identifier sale
             Type: function (address,uint256,uint256)
             Source: "sale"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          FunctionCall
             Type: uint256
             Source: "rate()"
            Identifier rate
               Type: function () view returns (uint256)
               Source: "rate"
